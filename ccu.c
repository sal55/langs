/*
 This generated C code is placed in the public domain.

 Recommended build instructions, when file is called prog.c:

   gcc -O2 -s prog.c -o prog -lm -ldl -fno-strict-aliasing

   -lm/-ldl are needed for Linux
   -O2 is recommended due to low quality C code
   -fno-strict-aliasing is needed when using gcc -O1/2/3

*/

#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void cc_cli_main();
void (*entrypoint)(void) = cc_cli_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u64 a[4];};   // mem:32;
struct $B18 {u64 a[50];};   // mem:400;
struct $B19 {u64 a[143];};   // mem:1144;
struct $B20 {u64 a[64];};   // mem:512;
struct $B21 {u64 a[16];};   // mem:128;
struct $B22 {u64 a[14];};   // mem:112;
struct $B23 {u16 a[7];};   // mem:14;
struct $B24 {u8 a[143];};   // mem:143;
struct $B25 {u64 a[7];};   // mem:56;
struct $B26 {u16 a[3];};   // mem:6;
struct $B27 {u16 a[9];};   // mem:18;
struct $B28 {u16 a[1];};   // mem:2;
struct $B29 {u64 a[12];};   // mem:96;
struct $B30 {u64 a[20];};   // mem:160;
struct $B31 {u64 a[8];};   // mem:64;
struct $B32 {u64 a[152];};   // mem:1216;
struct $B33 {u64 a[19];};   // mem:152;
struct $B34 {u64 a[21];};   // mem:168;
struct $B35 {u8 a[21];};   // mem:21;
struct $B36 {u64 a[137];};   // mem:1096;
struct $B37 {u8 a[137];};   // mem:137;
struct $B38 {u64 a[18];};   // mem:144;
struct $B39 {u16 a[25];};   // mem:50;
struct $B40 {u64 a[17];};   // mem:136;
struct $B41 {u64 a[256];};   // mem:2048;
struct $B42 {u64 a[128];};   // mem:1024;
struct $B43 {u64 a[193];};   // mem:1544;
struct $B44 {u64 a[1];};   // mem:8;
struct $B45 {u64 a[500];};   // mem:4000;
struct $B46 {u64 a[250];};   // mem:2000;
struct $B47 {u32 a[125];};   // mem:500;
struct $B48 {u64 a[90];};   // mem:720;
struct $B49 {u64 a[18006];};   // mem:144048;
struct $B50 {u64 a[2000];};   // mem:16000;
struct $B51 {u64 a[300];};   // mem:2400;
struct $B52 {u16 a[117009];};   // mem:234018;
struct $B53 {u64 a[5000];};   // mem:40000;
struct $B54 {u32 a[5];};   // mem:20;
struct $B55 {u64 a[3000];};   // mem:24000;
struct $B56 {u64 a[375];};   // mem:3000;
struct $B57 {u64 a[750];};   // mem:6000;
struct $B58 {u64 a[13];};   // mem:104;
struct $B59 {u64 a[53];};   // mem:424;
struct $B60 {u8 a[53];};   // mem:53;
struct $B61 {u64 a[80000];};   // mem:640000;
struct $B62 {u64 a[20000];};   // mem:160000;
struct $B63 {u64 a[10000];};   // mem:80000;
struct $B64 {u64 a[40000];};   // mem:320000;
struct $B65 {u64 a[201];};   // mem:1608;
struct $B66 {u32 a[201];};   // mem:804;
struct $B67 {u32 a[2101];};   // mem:8404;
struct $B68 {u32 a[101];};   // mem:404;
struct $B69 {u64 a[199];};   // mem:1592;
struct $B70 {u64 a[100];};   // mem:800;
struct $B71 {u64 a[22];};   // mem:176;
struct $B72 {u16 a[11];};   // mem:22;
struct $B73 {u64 a[5];};   // mem:40;
struct $B74 {u64 a[15];};   // mem:120;
struct $B75 {u32 a[15];};   // mem:60;
struct $B76 {u8 a[15];};   // mem:15;
struct $B77 {u64 a[78];};   // mem:624;
struct $B78 {u64 a[99];};   // mem:792;
struct $B79 {u8 a[99];};   // mem:99;
struct $B80 {u64 a[66];};   // mem:528;
struct $B81 {u64 a[33];};   // mem:264;
struct $B82 {u8 a[363];};   // mem:363;
struct $B83 {u8 a[3];};   // mem:3;
struct $B84 {u64 a[34];};   // mem:272;
struct $B85 {u64 a[60];};   // mem:480;
struct $B86 {u64 a[87000];};   // mem:696000;
struct $B87 {u64 a[200];};   // mem:1600;
struct $B88 {u32 a[39];};   // mem:156;
struct $B89 {u64 a[2048];};   // mem:16384;
struct $B90 {u64 a[30];};   // mem:240;
struct $B91 {u64 a[27];};   // mem:216;
struct $B92 {u64 a[130];};   // mem:1040;
struct $B93 {u64 a[45];};   // mem:360;
struct $B94 {u64 a[320];};   // mem:2560;
struct $B95 {u64 a[157];};   // mem:1256;

// Function Ptr Types:
typedef i64 (*F1)();
typedef i64 (*F2)(i64);
typedef i64 (*F3)(i64, i64);
typedef i64 (*F4)(i64, i64, i64);
typedef i64 (*F5)(i64, i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F13)();
typedef r64 (*F14)(i64);
typedef r64 (*F15)(i64, i64);
typedef i64 (*F16)(i64, u64, u64);
typedef i64 (*F17)(u64);
typedef void (*F18)(u64);
typedef u64 (*F19)(i64);
typedef void (*F20)();

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static i64 mlinux_init_flag;
static u8 pcl_pc_userunpcl;
static u8 pcl_asmonly;
static u8 pcl_pdcc;
static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc;
static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B17 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest;
static struct $B18 pc_decls_plibfiles;
static struct $B18 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype;
static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole;
static u8 pc_decls_fregoptim;
static u8 pc_decls_fnoconst;
static u8 pc_decls_fshowil;
static u8 pc_decls_flong64;
static i64 pc_decls_pcltime;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B19 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_decls_npcl;
static i64 pc_decls_npst;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest;
static i64 pc_diags_destlinestart;
static struct $B20 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static u64 pc_diags_psopnd_longstring;
static i64 pc_run_dotrace;
static i64 pc_run_dostep;
static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B21 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B22 pc_tables_pstdnames;
static struct $B23 pc_tables_psize;
static struct $B23 pc_tables_psigned;
static struct $B23 pc_tables_pint;
static struct $B23 pc_tables_pfloat;
static struct $B23 pc_tables_pmin;
static struct $B23 pc_tables_xxpiwrb;
static struct $B22 pc_tables_opndnames;
static struct $B19 pc_tables_pclnames;
static struct $B24 pc_tables_pclhastype;
static struct $B24 pc_tables_pclextra;
static struct $B24 pc_tables_pclhasopnd;
static struct $B24 pc_tables_pclargs;
static struct $B25 pc_tables_ccnames;
static struct $B1 pc_tables_idnames;
static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B19 mc_genmcl_px_handlertable;
static struct $B26 mc_genmcl_scondcodes;
static struct $B26 mc_genmcl_ucondcodes;
static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B29 mc_libmcl_smallinttable;
static struct $B30 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B30 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B20 mc_stackmcl_stropndstack_str;
static u8 mc_genss_rex;
static u8 mc_genss_sizeoverride;
static u8 mc_genss_addroverride;
static u8 mc_genss_f2override;
static u8 mc_genss_f3override;
static u8 mc_genss_nowmask;
static u8 mc_genss_usesizeb;
static u64 mc_genss_extraparam;
static i64 mc_genss_currseg;
static u64 mc_genss_currdata;
static u64 mc_genss_currrelocs;
static i64 mc_genss_nrelocs;
static struct $B3 mc_genss_ishighreg;
static u64 mc_genss_currmcl;
static u64 mc_genss_ripentry;
static struct $B11 mc_decls_valtypenames;
static struct $B32 mc_decls_mclnames;
static struct $B33 mc_decls_mclnopnds;
static struct $B33 mc_decls_mclcodes;
static struct $B34 mc_decls_regnames;
static struct $B35 mc_decls_regcodes;
static struct $B30 mc_decls_condnames;
static struct $B30 mc_decls_asmcondnames;
static struct $B30 mc_decls_asmrevcond;
static struct $B36 mc_decls_dregnames;
static struct $B37 mc_decls_regsizes;
static struct $B37 mc_decls_regindices;
static struct $B21 mc_decls_xmmregnames;
static struct $B31 mc_decls_fregnames;
static struct $B31 mc_decls_mregnames;
static struct $B38 mc_decls_jmpccnames;
static struct $B27 mc_decls_jmpcccodes;
static struct $B21 mc_decls_setccnames;
static struct $B3 mc_decls_setcccodes;
static struct $B21 mc_decls_cmovccnames;
static struct $B3 mc_decls_cmovcccodes;
static struct $B12 mc_decls_segmentnames;
static struct $B8 mc_decls_reftypenames;
static struct $B12 mc_decls_opndnames_ma;
static struct $B18 mc_decls_pclopnd;
static struct $B39 mc_decls_pclreg;
static struct $B39 mc_decls_pclmode;
static struct $B39 mc_decls_pclcount;
static struct $B39 mc_decls_pclloc;
static struct $B39 mc_decls_pcltempflags;
static struct $B18 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B17 mc_decls_locnames;
static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames;
static struct $B3 mc_decls_callalign;
static struct $B3 mc_decls_callblockret;
static struct $B31 mc_decls_callblocksize;
static struct $B20 mc_decls_callargmode;
static struct $B41 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used;
static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment;
static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B42 mc_decls_regtable;
static struct $B43 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes;
static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B18 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs;
static struct $B12 mc_decls_multxregs;
static struct $B23 mc_decls_ploadopx;
static struct $B23 mc_decls_ploadop;
static struct $B25 mc_objdecls_relocnames;
static u64 mc_writeasm_asmext;
static struct $B42 mc_writeasm_nregnames;
static struct $B21 mc_writeasm_regvars;
static struct $B21 mc_writeasm_xregvars;
static struct $B20 mc_writeasm_strmcl_str;
static struct $B20 mc_writeasm_mstropnd_str;
static struct $B20 mc_writeasm_strvalue_str;
static struct $B17 mc_writeasm_getregname_str;
static struct $B17 mc_writeasm_getxregname_str;
static struct $B16 mc_writeasm_getdispname_str;
static struct $B21 mc_writeasm_gettempname_str;
static struct $B18 mc_writeexe_libinsttable;
static struct $B18 mc_writeexe_libinstnames;
static struct $B18 mc_writeexe_libnotable;
static u64 mc_writeexe_basereloclist;
static i64 mc_writeexe_nbaserelocs;
static i64 mc_writeexe_maxrelocaddr;
static struct $B45 mc_writeexe_blockbases;
static struct $B46 mc_writeexe_blockcounts;
static struct $B46 mc_writeexe_blockbytes;
static struct $B47 mc_writeexe_blockpadding;
static i64 mc_writeexe_nbaseblocks;
static i64 mc_writeexe_basetablesize;
static i64 mc_writeexe_imagebase;
static i64 mc_writeexe_imagesize;
static i64 mc_writeexe_filesize;
static u64 mc_writeexe_thunktable;
static i64 mc_writeexe_fileiatoffset;
static i64 mc_writeexe_fileiatsize;
static u64 mc_writeexe_stentrypoint;
static u64 mc_writeexe_stentrypoint2;
static u64 mc_writeexe_stentrypoint3;
static struct $B48 mc_writeexe_sectiontable;
static i64 mc_writeexe_nsections;
static u64 mc_writeexe_importdir;
static struct $B49 mc_writeexe_importtable;
static i64 mc_writeexe_nimports;
static struct $B50 mc_writeexe_exporttable;
static i64 mc_writeexe_nexports;
static u64 mc_writeexe_dllfilename;
static i64 mc_writeexe_isdll;
static struct $B51 mc_writeexe_dlltable;
static i64 mc_writeexe_ndlls;
static u64 mc_writeexe_datastart;
static u64 mc_writeexe_dataptr;
static u64 mc_writeexe_userentrypoint;
static i64 mc_writeexe_exportdirvirtaddr;
static i64 mc_writeexe_exportdirvirtsize;
static i64 mc_writeexe_exportdiroffset;
static i64 mc_writeexe_blockdirvirtaddr;
static i64 mc_writeexe_blockdirvirtsize;
static i64 mc_writeexe_blockdiroffset;
static i64 mc_writeobj_symtaboffset;
static u64 mc_writeobj_datastart;
static u64 mc_writeobj_dataptr;
static struct $B52 mc_writeobj_symboltable;
static i64 mc_writeobj_nsymbols;
static i64 mc_writeobj_stoffset;
static struct $B53 mc_writeobj_stringtable;
static struct $B53 mc_writeobj_stringlengths;
static i64 mc_writeobj_nextstringoffset;
static i64 mc_writeobj_nstrings;
static struct $B2 mc_writeobj_writerelocs_s;
static struct $B27 mc_writeobj_makesymbol_r;
static struct $B27 mc_writeobj_strtoaux_r;
static struct $B27 mc_writeobj_sectiontoaux_r;
static i64 mc_disasm_nmodules;
static i64 mc_disasm_xfchsmask_pd;
static struct $B31 mc_disasm_opnames;
static struct $B21 mc_disasm_condnames;
static struct $B8 mc_disasm_addrmodenames;
static i64 mc_disasm_rex;
static i64 mc_disasm_addrmode;
static i64 mc_disasm_rmreg;
static i64 mc_disasm_rmopc;
static i64 mc_disasm_ripmode;
static i64 mc_disasm_basereg;
static i64 mc_disasm_indexreg;
static i64 mc_disasm_scale;
static i64 mc_disasm_opsize;
static i64 mc_disasm_offset;
static i64 mc_disasm_offsetsize;
static i64 mc_disasm_sizeoverride;
static i64 mc_disasm_addroverride;
static i64 mc_disasm_f2override;
static i64 mc_disasm_f3override;
static struct $B16 mc_disasm_deststr;
static u64 mc_disasm_destptr;
static u64 mc_disasm_codeptr;
static struct $B16 mc_disasm_decodeinstr_str;
static struct $B5 mc_disasm_printaddrmode_str;
static struct $B17 mc_disasm_strxmm_str;
static struct $B17 mc_disasm_strmmx_str;
static struct $B22 mx_decls_mcxdirnames;
static struct $B12 mx_decls_mcxrelocnames;
static struct $B30 mx_decls_dllnametable;
static struct $B30 mx_decls_dllinsttable;
static i64 mx_decls_ndlllibs;
static struct $B30 mx_decls_libnametable;
static struct $B30 mx_decls_libtable;
static struct $B54 mx_decls_librelocated;
static struct $B54 mx_decls_libinitdone;
static i64 mx_decls_nlibs;
static struct $B55 mx_decls_symbolnametable;
static struct $B56 mx_decls_symboldefined;
static struct $B55 mx_decls_symboladdress;
static struct $B57 mx_decls_symbollibindex;
static struct $B56 mx_decls_symboldllindex;
static i64 mx_decls_nsymbols;
static i64 mx_decls_nsymimports;
static i64 mx_decls_nsymexports;
static struct $B12 mx_lib_rsegmentnames;
static u64 mx_write_dest;
static u64 mx_write_entrypoint;
static struct $B58 cc_cli_passnames;
static struct $B58 cc_cli_extnames;
static u8 cc_cli_cc_pass;
static struct $B54 cc_cli_dummy;
static u8 cc_cli_debugmode;
static u64 cc_cli_outfile;
static u64 cc_cli_outext;
static i64 cc_cli_cmdskip;
static i64 cc_cli_ttt;
static u8 cc_cli_fverbose;
static u8 cc_cli_fshowincludes;
static u8 cc_cli_dointheaders;
static u8 cc_cli_highmem;
static u8 cc_cli_fshowst;
static u8 cc_cli_fshowstflat;
static u8 cc_cli_fshowast;
static u8 cc_cli_fshowpcl;
static u8 cc_cli_fshowpst;
static u8 cc_cli_fshowmcl;
static u8 cc_cli_fshowss;
static u8 cc_cli_fshowtypes;
static u8 cc_cli_fshowfiles;
static u8 cc_cli_fshowpaths;
static u8 cc_cli_fshowheaders;
static u8 cc_cli_fwriteheaders;
static u8 cc_cli_fshowlog;
static u8 cc_cli_fshowtiming;
static u8 cc_cli_fgendll;
static u8 cc_cli_fstdout;
static u8 cc_cli_fshortnames;
static u8 cc_cli_fwriteerrors;
static u64 cc_cli_entrypointname;
static struct $B59 cc_cli_optionnames;
static struct $B59 cc_cli_optvars;
static struct $B60 cc_cli_optvalues;
static i64 cc_cli_totallines;
static i64 cc_cli_nstringobjects;
static i64 cc_cli_startclock;
static i64 cc_cli_loadtime;
static i64 cc_cli_parsetime;
static i64 cc_cli_pcltime;
static i64 cc_cli_compiletime;
static i64 cc_cli_inittime;
static i64 cc_decls_ntypes;
static struct $B61 cc_decls_ttnamedef;
static struct $B62 cc_decls_ttbasetype;
static struct $B61 cc_decls_ttlength;
static struct $B63 cc_decls_ttconst;
static struct $B62 cc_decls_tttarget;
static struct $B62 cc_decls_ttreftype;
static struct $B62 cc_decls_ttconsttype;
static struct $B61 cc_decls_ttsize;
static struct $B63 cc_decls_ttisref;
static struct $B63 cc_decls_ttisblock;
static struct $B63 cc_decls_ttsigned;
static struct $B64 cc_decls_ttshared;
static struct $B61 cc_decls_ttparams;
static struct $B61 cc_decls_tttypedef;
static i64 cc_decls_trefchar;
static i64 cc_decls_trefwchar;
static u64 cc_decls_inputfile;
static i64 cc_decls_mainfileno;
static struct $B65 cc_decls_libfiles;
static struct $B65 cc_decls_sourcefilenames;
static struct $B65 cc_decls_sourcefilepaths;
static struct $B65 cc_decls_sourcefiletext;
static struct $B66 cc_decls_sourcefilesizes;
static i64 cc_decls_nsourcefiles;
static i64 cc_decls_nlibfiles;
static struct $B30 cc_decls_searchdirs;
static i64 cc_decls_nsearchdirs;
static struct $B30 cc_decls_includepaths;
static i64 cc_decls_nincludepaths;
static u64 cc_decls_stprogram;
static u64 cc_decls_stmodule;
static u64 cc_decls_logdev;
static u64 cc_decls_nullunit;
static i64 cc_decls_clineno;
static i64 cc_decls_cfileno;
static struct $B17 cc_decls_lx;
static struct $B17 cc_decls_nextlx;
static i64 cc_decls_debug;
static i64 cc_decls_hstsize;
static i64 cc_decls_hstmask;
static u64 cc_decls_hashtable;
static struct $B67 cc_decls_blockowner;
static struct $B67 cc_decls_blockcounts;
static struct $B68 cc_decls_blockstack;
static i64 cc_decls_currblockno;
static i64 cc_decls_nextblockno;
static i64 cc_decls_blocklevel;
static u64 cc_decls_currproc;
static u64 cc_decls_dheaderfile;
static i64 cc_decls_structpadding;
static i64 cc_decls_callbackflag;
static i64 cc_decls_slineno;
static i64 cc_decls_sfileno;
static u64 cc_decls_oemname;
static u64 cc_decls_mclstr;
static i64 cc_decls_mclstrlen;
static i64 cc_decls_nunits;
static struct $B69 cc_decls_pmodulelist;
static struct $B70 cc_decls_pheaderlist;
static struct $B70 cc_decls_pliblist;
static i64 cc_decls_npmodules;
static i64 cc_decls_npheaders;
static i64 cc_decls_nplibs;
static u8 cc_decls_pci_target;
static struct $B71 cc_tables_stdtypenames;
static struct $B72 cc_tables_stdtypewidths;
static struct $B72 cc_tables_stdsigned;
static struct $B72 cc_tables_stdpcl;
static struct $B72 cc_tables_stdsize;
static struct $B73 cc_tables_catnames;
static struct $B74 cc_tables_typespecnames;
static struct $B75 cc_tables_typespectypes;
static struct $B76 cc_tables_typespecsizes;
static struct $B17 cc_tables_pmflagnames;
static struct $B73 cc_tables_scopenames;
static struct $B12 cc_tables_cccnames;
static struct $B12 cc_tables_linkagenames;
static struct $B17 cc_tables_typequalnames;
static struct $B8 cc_tables_fnspecnames;
static struct $B77 cc_tables_jtagnames;
static struct $B78 cc_tables_symbolnames;
static struct $B78 cc_tables_shortsymbolnames;
static struct $B79 cc_tables_symboltojtag;
static struct $B74 cc_tables_sourcedirnames;
static struct $B73 cc_tables_namespacenames;
static struct $B74 cc_tables_namenames;
static struct $B75 cc_tables_namespaces;
static struct $B76 cc_tables_name2pid;
static struct $B80 cc_tables_stnames;
static struct $B81 cc_tables_stsymbols;
static struct $B81 cc_tables_stsubcodes;
static struct $B22 cc_tables_convnames;
static struct $B42 cc_tables_dominantmode;
static struct $B16 cc_tables_conversionops;
static struct $B82 cc_tables_dominantsetuptable;
static struct $B82 cc_tables_convsetuptable;
static struct $B84 cc_tables_badexprs;
static u64 cc_lex_tkptr;
static i64 cc_lex_dowhitespace;
static i64 cc_lex_nincludes;
static struct $B17 cc_lex_normaltkx;
static u64 cc_lex_normaltk;
static i64 cc_lex_noexpand;
static struct $B85 cc_lex_lx_stack;
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel;
static struct $B30 cc_lex_headerpathlist;
static struct $B15 cc_lex_headerpath;
static u64 cc_lex_lxstart;
static u64 cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static u64 cc_lex_lxsvalue;
static struct $B16 cc_lex_alphamap;
static struct $B16 cc_lex_digitmap;
static struct $B16 cc_lex_commentmap;
static struct $B16 cc_lex_linecommentmap;
static struct $B16 cc_lex_spacemap;
static u64 cc_lex_destcopy;
static struct $B86 cc_lex_pastedtokenlist;
static i64 cc_lex_npastedtokens;
static i64 cc_lex_isincludefile;
static i64 cc_lex_firstsymbol;
static u64 cc_lex_reallxsptr;
static i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static struct $B3 cc_lex_lex_preprocess_only_sbuffer;
static struct $B15 cc_lex_getsourcefile_filespec;
static i64 cc_lex_lasttoken;
static struct $B3 cc_lex_showtoken_buffer;
static struct $B3 cc_lex_stringify_buffer;
static u64 cc_parse_ist_symptr;
static struct $B31 cc_parse_looptypestack;
static i64 cc_parse_loopindex;
static struct $B20 cc_parse_casevaluestack;
static u8 cc_parse_ingeneric;
static i64 cc_genpcl_retindex;
static i64 cc_genpcl_initstaticsindex;
static struct $B87 cc_genpcl_loopstack;
static i64 cc_genpcl_loopindex;
static struct $B31 cc_genpcl_zero_unit;
static u64 cc_genpcl_pzero;
static i64 cc_genpcl_nvarlocals;
static i64 cc_genpcl_nvarparams;
static struct $B20 cc_blockpcl_continuestack;
static struct $B20 cc_blockpcl_breakstack;
static i64 cc_blockpcl_loopindex;
static u64 cc_blockpcl_sw_labeltable;
static u64 cc_blockpcl_sw_valuetable;
static i64 cc_blockpcl_sw_lower;
static i64 cc_blockpcl_sw_ncases;
static u8 cc_blockpcl_sw_defaultseen;
static i64 cc_blockpcl_sw_defaultlabel;
static i64 cc_blockpcl_sw_breaklabel;
static i64 cc_lib_autotypeno;
static i64 cc_lib_nextafindex;
static u64 cc_lib_unitheapptr;
static i64 cc_lib_remainingunits;
static struct $B88 cc_lib_getoptocode_opctotable;
static struct $B17 cc_lib_nextautotype_str;
static struct $B54 cc_lib_getopcjname_str;
static struct $B89 cc_lib_strmode_str;
static struct $B89 cc_lib_strmode2_str;
static struct $B15 cc_lib_typename_str;
static struct $B16 cc_lib_getstname_name;
static u64 cc_support_bytemasks;
static i64 cc_headers_builtinheaders;
static u64 cc_headers_h_assert;
static u64 cc_headers_h_ctype;
static u64 cc_headers_h_errno;
static u64 cc_headers_h_fenv;
static u64 cc_headers_h_float;
static u64 cc_headers_h_inttypes;
static u64 cc_headers_h_stdint;
static u64 cc_headers_h_limits;
static u64 cc_headers_h_locale;
static u64 cc_headers_h__ansi;
static u64 cc_headers_h_math;
static u64 cc_headers_h_setjmp;
static u64 cc_headers_h_signal;
static u64 cc_headers_h_stdarg;
static u64 cc_headers_h_stdbool;
static u64 cc_headers_h_stddef;
static u64 cc_headers_h_stdio;
static u64 cc_headers_h_stdlib;
static u64 cc_headers_h__syslist;
static u64 cc_headers_h_string;
static u64 cc_headers_h_time;
static u64 cc_headers_h_utime;
static u64 cc_headers_h_unistd;
static u64 cc_headers_h_safelib;
static u64 cc_headers_h_wchar;
static u64 cc_headers_h_wctype;
static u64 cc_headers_h_systypes;
static u64 cc_headers_h_sysstat;
static u64 cc_headers_h_systimeb;
static u64 cc_headers_h_sysutime;
static u64 cc_headers_h_memory;
static u64 cc_headers_h_fcntl;
static u64 cc_headers_h_io;
static u64 cc_headers_h_direct;
static u64 cc_headers_h_process;
static u64 cc_headers_h_malloc;
static u64 cc_headers_h_conio;
static u64 cc_headers_h_winsock2;
static u64 cc_headers_h__mingw;
static u64 cc_headers_h_windowsx;
static struct $B6 cc_headers_stdhdrnames;
static struct $B6 cc_headers_stdhdrtext;
static i64 cc_show_currfileno;
static i64 cc_show_currlineno;
static struct $B3 cc_show_sbuffer;
static u64 cc_show_dest;
static i64 cc_show_destlinestart;
static struct $B3 cc_show_exprstrvar;
static u64 cc_show_exprstr;
static struct $B20 cc_show_getprefix_str;
static struct $B16 cc_show_getdottedname_str;
static struct $B73 cc_show_getlineinfok_str;
static i64 $nprocs;
static struct $B92 $procname;
static struct $B92 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sqrt(r64 $1);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);
extern u64 dlopen(u64 $1, i32 $2);
extern u64 dlsym(u64 $1, u64 $2);
extern i32 tcgetattr(i32 $1, u64 $2);
extern i32 tcsetattr(i32 $1, i32 $2, u64 $3);
extern i32 gettimeofday(u64 $1, u64 $2);
extern u64 gmtime_r(u64 $1, u64 $2);
extern void stdin();
extern void stdout();

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static u64 pc_api_strpmode(i64 mode, i64 size);
static u64 pc_api_getfullname(u64 d, i64 backtick);
static u64 pc_api_addstr(u64 s, u64 t);
static u64 pc_diags_stropnd(u64 p);
static void pc_diags_psopnd(u64 p);
static void mc_genmcl_inithandlers();
static u64 mc_libmcl_mgenextname(u64 s);
static u64 mc_stackmcl_stropndstack(i64 indent);
static u64 mc_genss_genrm(i64 reg, i64 opc, u64 b, i64 isxreg);
static void mc_writeasm_strmcl(u64 mcl);
static u64 mc_writeasm_mstropnd(u64 a, i64 sizeprefix, i64 opcode);
static u64 mc_writeasm_strvalue(u64 a);
static u64 mc_writeasm_getregname(i64 reg, i64 size);
static u64 mc_writeasm_getxregname(i64 reg, i64 size);
static u64 mc_writeasm_getdispname(u64 d);
static u64 mc_writeasm_gettempname(u64 d, i64 n);
static void mc_writeexe_writedosstub();
static void mc_writeobj_writerelocs(u64 r, i64 nrelocs);
static u64 mc_writeobj_makesymbol(u64 name, i64 value, i64 sectionno, i64 symtype, i64 storage, i64 naux);
static u64 mc_writeobj_strtoaux(u64 s);
static u64 mc_writeobj_sectiontoaux(u64 data, i64 nrelocs);
static u64 mc_disasm_decodeinstr(u64 cptr, u64 baseaddr);
static u64 mc_disasm_strreg(i64 reg, i64 opsize);
static u64 mc_disasm_strfreg(i64 freg);
static void mc_disasm_printaddrmode(i64 xmm);
static u64 mc_disasm_strxmm(i64 reg);
static u64 mc_disasm_strmmx(i64 reg);
static void cc_cli_showextrainfo();
static void cc_lex_lex_preprocess_only(u64 infile, u64 outfile, i64 toconsole);
static i64 cc_lex_getsourcefile(u64 file, i64 syshdr);
static void cc_lex_lexm();
static void cc_lex_showtoken(u64 lp);
static void cc_lex_stringify(u64 seq, u64 dest);
static void cc_lex_expandpredefmacro(i64 pdmcode, u64 tk, i64 lineno);
static i64 cc_lex_issimpleconstmacro(u64 m);
static i64 cc_lib_getoptocode(i64 opc);
static u64 cc_lib_nextautotype();
static u64 cc_lib_getopcjname(i64 opc);
static u64 cc_lib_strmode(i64 m, i64 expand);
static u64 cc_lib_strmode2(i64 m, i64 expand);
static u64 cc_lib_typename(i64 m);
static u64 cc_lib_getstname(u64 d);
static u64 cc_show_getprefix(i64 level, u64 prefix, u64 p);
static u64 cc_show_getdottedname(u64 p);
static u64 cc_show_getlineinfok();
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_startcon();
static void msysc_m$print_setfmt(u64 format);
static void msysc_m$print_end();
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_newline();
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mlinux_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mlinux_os_init();
static i64 mlinux_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mlinux_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mlinux_os_getch();
static i64 mlinux_os_kbhit();
static void mlinux_os_flushkeys();
static u64 mlinux_os_getconsolein();
static u64 mlinux_os_getconsoleout();
static u64 mlinux_os_proginstance();
static u64 mlinux_os_getdllinst(u64 name);
static u64 mlinux_os_getdllprocaddr(i64 hlib, u64 name);
static void mlinux_os_initwindows();
static i64 mlinux_os_getchx();
static u64 mlinux_os_getos();
static i64 mlinux_os_gethostsize();
static i64 mlinux_os_iswindows();
static i64 mlinux_os_shellexec(u64 opc, u64 file);
static void mlinux_os_sleep(i64 a);
static u64 mlinux_os_getstdout();
static u64 mlinux_os_gethostname();
static u64 mlinux_os_getmpath();
static void mlinux_os_exitprocess(i64 x);
static i64 mlinux_os_clock();
static i64 mlinux_os_ticks();
static i64 mlinux_os_getclockspersec();
static void mlinux_os_setmesshandler(u64 addr);
static i64 mlinux_os_hpcounter();
static i64 mlinux_os_hpfrequency();
static i64 mlinux_os_filelastwritetime(u64 filename);
static void mlinux_os_getsystime(u64 tm);
static void mlinux_os_peek();
static u64 mlinux_os_allocexecmem(i64 n);
static i64 mlinux_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
static u64 pc_api_pcl_start(u64 name, i64 nunits);
static void pc_api_pclerror(u64 mess);
static u64 pc_api_pc_makesymbol(u64 s, i64 id);
static void pc_api_pcl_end();
static void pc_api_pc_gen(i64 opcode, u64 p);
static u64 pc_api_pcl_writepcl(u64 filename);
static u64 pc_diags_writeallpcl();
static u64 pc_api_pcl_writepst(u64 filename);
static u64 pc_diags_writepst();
static void pc_api_pcl_genmcl();
static void mc_genmcl_genmcl(u64 dummy);
static void pc_api_pcl_genss(i64 obj);
static void mc_genss_genss(i64 obj);
static u64 pc_api_pcl_writess(u64 filename, i64 obj);
static u64 mc_writess_writessdata(i64 fexe);
static u64 pc_api_pcl_writeasm(u64 filename, i64 atype);
static u64 mc_writeasm_getassemstr();
static void pc_api_pcl_writeobj(u64 filename);
static void mc_writeobj_writecoff(u64 outfile);
static void pc_api_pcl_writedll(u64 filename);
static void mc_writeexe_writeexe(u64 outfile, i64 dodll, u64 entrypoint);
static void pc_api_pcl_writeexe(u64 filename);
static void pc_api_pcl_writemx(u64 filename);
static void mx_write_writemcx(u64 filename);
static void pc_api_pcl_exec();
static void mx_run_runlibfile(u64 filename, i64 cmdskip);
static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames);
static void pc_api_extendpclblock();
static u64 pc_api_newpcl();
static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset);
static void pc_api_pc_genx(i64 opcode, i64 x, u64 p);
static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p);
static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p);
static u64 pc_api_genint(i64 a);
static u64 pc_api_genreal(r64 x, i64 mode);
static u64 pc_api_genrealimm(r64 x, i64 mode);
static u64 pc_api_genstring(u64 s, i64 length);
static u64 pc_api_genpcstrimm(u64 s);
static u64 pc_api_genlabel(i64 a);
static u64 pc_api_genmem(u64 d);
static u64 pc_api_genmemaddr(u64 d);
static u64 pc_api_gendata(u64 s, i64 length);
static void pc_api_gencomment(u64 s);
static u64 pc_api_genname(u64 s);
static u64 pc_api_gennameaddr(u64 s);
static u64 pc_api_genassem(u64 code);
static void pc_api_pc_setmode(i64 m, i64 size);
static void pc_api_pc_setmode2(i64 m);
static void pc_api_pc_setxy(i64 x, i64 y);
static void pc_api_pc_setscaleoff(i64 scale, i64 offset);
static void pc_api_pc_setoffset(i64 offset);
static void pc_api_pc_addoffset(i64 offset);
static void pc_api_pc_setincr(i64 n);
static void pc_api_pc_setnargs(i64 n);
static void pc_api_pc_setnvariadics(i64 n);
static void pc_api_pc_setalign(i64 n);
static void pc_api_perror(u64 mess);
static void pc_api_perror_s(u64 mess, u64 param);
static u64 pc_api_getbasename(u64 s);
static void pc_api_pc_addsymbol(u64 d);
static void pc_api_pcerrorstop(u64 filename, i64 lineno);
static void pc_api_pc_addplib(u64 name);
static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded);
static void pc_api_pc_setimport(u64 d);
static void pc_api_pc_addparam(u64 d);
static void pc_api_pc_addlocal(u64 d);
static void pc_api_pc_endproc();
static void pc_api_merror(u64 mess, u64 param);
static u64 pc_api_pc_duplpst(u64 d);
static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip);
static i64 pc_api_convertstring(u64 s, u64 t);
static void pc_diags_strpcl(u64 p);
static void pc_diags_strlabel(i64 labelno, i64 colon);
static void pc_diags_psstr(u64 s);
static void pc_diags_psname(u64 d);
static void pc_diags_psline();
static void pc_diags_psstrline(u64 s);
static void pc_diags_psdata(u64 p);
static void pc_diags_pstabto(i64 n);
static void pc_diags_psint(i64 a);
static i64 pc_diags_newconvertstring(u64 s, u64 t, i64 length);
static u64 pc_diags_strpclstr(u64 p, i64 buffsize);
static void pc_diags_writepcl(u64 p);
static void pc_diags_psstrx(u64 s);
static void pc_diags_writepsymbol(u64 d, u64 fmt);
static void pc_diags_showprocinfo(u64 d);
static void pc_reduce_pcl_reducetest();
static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain);
static i64 pc_runaux_pci_getopnd(u64 p, u64 locals);
static i64 pc_runaux_pci_loadptr(u64 p, i64 mode);
static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size);
static void pc_runaux_pcusopnd(u64 p);
static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j);
static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x);
static i64 pc_run_getlineno(u64 pc);
static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param);
static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode);
static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y);
static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y);
static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y);
static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals);
static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode);
static void pc_run_fixuppcl();
static u64 pc_runaux_getdllfnptr(u64 d);
static void pc_run_pcl_runpcl();
static void pc_runaux_loadlibs();
static void pc_runaux_docmdskip();
static void mc_libmcl_mclinit(i64 bypass);
static void mc_genmcl_convertpcl(u64 p);
static void mc_stackmcl_showopndstack();
static void mc_auxmcl_genrealtable();
static void mc_auxmcl_genabsneg();
static void mc_auxmcl_genstringtable();
static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b);
static void mc_optim_peephole();
static void mc_genmcl_doshowpcl(u64 p);
static void mc_genmcl_unimpl(u64 p);
static void mc_libmcl_mgencomment(u64 s);
static void mc_genmcl_px_nop(u64 p);
static void mc_genmcl_px_dupl(u64 p);
static void mc_stackmcl_duplpcl();
static void mc_genmcl_px_double(u64 p);
static void mc_genmcl_px_opnd(u64 p);
static void mc_genmcl_px_type(u64 p);
static void mc_genmcl_px_comment(u64 p);
static void mc_genmcl_px_proc(u64 p);
static void mc_libmcl_setsegment(i64 seg, i64 align);
static u64 mc_libmcl_mgenmemaddr(u64 d);
static void mc_auxmcl_initproc(u64 d);
static void mc_auxmcl_fixmain();
static void mc_genmcl_px_endproc(u64 p);
static void mc_genmcl_px_endprog(u64 p);
static void mc_genmcl_px_istatic(u64 p);
static void mc_genmcl_px_zstatic(u64 p);
static u64 mc_libmcl_mgenint(i64 x, i64 mode);
static void mc_genmcl_px_data(u64 p);
static void mc_auxmcl_do_blockdata(u64 p);
static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode);
static i64 mc_libmcl_getstringindex(u64 s, i64 length);
static u64 mc_libmcl_mgenlabel(i64 x);
static void mc_genmcl_px_label(u64 p);
static void mc_genmcl_px_load(u64 p);
static void mc_stackmcl_pushpcl(u64 p);
static void mc_genmcl_px_store(u64 p);
static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg);
static u64 mc_libmcl_mgenmem(u64 d, i64 mode);
static u64 mc_stackmcl_getworkregm(i64 mode);
static u64 mc_stackmcl_makeopndind(u64 a, i64 mode);
static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest);
static void mc_stackmcl_poppcl();
static void mc_genmcl_px_add(u64 p);
static u64 mc_stackmcl_isimmload(i64 n);
static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_sub(u64 p);
static void mc_genmcl_px_mul(u64 p);
static void mc_auxmcl_mulimm(u64 ax, i64 n);
static void mc_genmcl_px_div(u64 p);
static void mc_genmcl_px_eval(u64 p);
static void mc_genmcl_px_widen(u64 p);
static void mc_stackmcl_setnewzz(i64 reg, i64 mode);
static void mc_genmcl_px_jump(u64 p);
static void mc_genmcl_px_ijump(u64 p);
static void mc_genmcl_px_neg(u64 p);
static void mc_auxmcl_do_negreal(u64 ax, i64 mode);
static void mc_genmcl_px_abs(u64 p);
static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b);
static void mc_auxmcl_do_absreal(u64 ax, i64 mode);
static void mc_genmcl_px_bitnot(u64 p);
static void mc_genmcl_px_not(u64 p);
static u64 mc_libmcl_changeopndsize(u64 a, i64 size);
static void mc_genmcl_px_toboolt(u64 p);
static void mc_genmcl_px_sqr(u64 p);
static void mc_genmcl_px_sqrt(u64 p);
static void mc_genmcl_px_jumpcc(u64 p);
static void mc_genmcl_px_jumpt(u64 p);
static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond);
static void mc_genmcl_px_jumpf(u64 p);
static void mc_genmcl_px_bitand(u64 p);
static void mc_auxmcl_do_bitwise(u64 p, i64 opc);
static void mc_genmcl_px_bitor(u64 p);
static void mc_genmcl_px_bitxor(u64 p);
static void mc_genmcl_px_shl(u64 p);
static void mc_auxmcl_do_shift(u64 p, i64 opc);
static void mc_genmcl_px_shr(u64 p);
static void mc_genmcl_px_retproc(u64 p);
static void mc_auxmcl_do_procentry(u64 p);
static void mc_auxmcl_do_procexit();
static void mc_genmcl_px_retfn(u64 p);
static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset);
static u64 mc_libmcl_mgenreg(i64 reg, i64 mode);
static void mc_genmcl_px_setcall(u64 p);
static void mc_stackmcl_saveopnds(i64 n);
static void mc_libmcl_pushslots(i64 nslots);
static void mc_genmcl_px_setarg(u64 p);
static void mc_stackmcl_pushopnd(i64 n, i64 mode, i64 size);
static void mc_genmcl_px_callp(u64 p);
static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr, i64 pstack);
static void mc_libmcl_popslots(i64 nslots);
static void mc_auxmcl_do_getretvalue(u64 p);
static void mc_genmcl_px_jumpret(u64 p);
static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_jumpretm(u64 p);
static void mc_stackmcl_movetoreg(i64 newreg);
static void mc_genmcl_px_startmx(u64 p);
static void mc_genmcl_px_resetmx(u64 p);
static void mc_genmcl_px_stop(u64 p);
static void mc_genmcl_px_incrto(u64 p);
static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrto(u64 p);
static void mc_genmcl_px_incrload(u64 p);
static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrload(u64 p);
static void mc_genmcl_px_loadincr(u64 p);
static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_loaddecr(u64 p);
static void mc_genmcl_px_forup(u64 p);
static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond);
static void mc_genmcl_px_fordown(u64 p);
static void mc_genmcl_px_iload(u64 p);
static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode);
static i64 mc_genmcl_getsharereg(u64 ax, i64 mode);
static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode);
static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode);
static void mc_auxmcl_dolea(u64 ax, u64 px);
static void mc_genmcl_px_iloadx(u64 p);
static u64 mc_auxmcl_do_addrmode(u64 p);
static void mc_genmcl_px_istore(u64 p);
static u64 mc_stackmcl_makesimpleaddr(u64 ax);
static void mc_genmcl_px_istorex(u64 p);
static void mc_genmcl_px_storem(u64 p);
static u64 mc_libmcl_newblocktemp(i64 size);
static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size);
static void mc_genmcl_px_addpx(u64 p);
static void mc_genmcl_px_subpx(u64 p);
static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale);
static void mc_genmcl_px_to(u64 p);
static void mc_genmcl_px_iswap(u64 p);
static void mc_genmcl_px_swapstk(u64 p);
static void mc_stackmcl_swapopnds(i64 m, i64 n);
static void mc_genmcl_px_labeldef(u64 p);
static void mc_genmcl_px_addto(u64 p);
static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc);
static void mc_genmcl_px_subto(u64 p);
static void mc_genmcl_px_multo(u64 p);
static void mc_auxmcl_do_binto_float(u64 p, i64 opc);
static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg);
static void mc_genmcl_px_bitandto(u64 p);
static void mc_genmcl_px_bitorto(u64 p);
static void mc_genmcl_px_bitxorto(u64 p);
static void mc_genmcl_px_shlto(u64 p);
static void mc_auxmcl_do_shiftnto(u64 p, i64 opc);
static void mc_genmcl_px_shrto(u64 p);
static void mc_genmcl_px_fix(u64 p);
static void mc_genmcl_px_float(u64 p);
static i64 mc_libmcl_mcreatefwdlabel();
static void mc_libmcl_mdefinefwdlabel(i64 lab);
static u64 mc_libmcl_mgenlabelmem(i64 x);
static void mc_genmcl_px_idiv(u64 p);
static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv);
static void mc_genmcl_px_irem(u64 p);
static void mc_genmcl_px_idivrem(u64 p);
static void mc_genmcl_px_clear(u64 p);
static void mc_auxmcl_clearblock(u64 ax, i64 n);
static void mc_genmcl_px_subp(u64 p);
static i64 mc_libmcl_ispoweroftwo(i64 x);
static void mc_genmcl_px_switch(u64 p);
static i64 mc_stackmcl_getworkireg();
static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def);
static void mc_genmcl_px_switchu(u64 p);
static void mc_genmcl_px_swlabel(u64 p);
static void mc_genmcl_px_endsw(u64 p);
static void mc_genmcl_px_fwiden(u64 p);
static void mc_genmcl_px_fnarrow(u64 p);
static void mc_genmcl_px_truncate(u64 p);
static void mc_genmcl_px_typepun(u64 p);
static void mc_genmcl_px_unload(u64 p);
static void mc_genmcl_px_loadbit(u64 p);
static void mc_genmcl_px_assem(u64 p);
static void mc_genmcl_px_sin(u64 p);
static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs);
static void mc_genmcl_px_cos(u64 p);
static void mc_genmcl_px_tan(u64 p);
static void mc_genmcl_px_asin(u64 p);
static void mc_genmcl_px_acos(u64 p);
static void mc_genmcl_px_atan(u64 p);
static void mc_genmcl_px_log(u64 p);
static void mc_genmcl_px_log10(u64 p);
static void mc_genmcl_px_exp(u64 p);
static void mc_genmcl_px_round(u64 p);
static void mc_genmcl_px_floor(u64 p);
static void mc_genmcl_px_ceil(u64 p);
static void mc_genmcl_px_atan2(u64 p);
static void mc_genmcl_px_fmod(u64 p);
static void mc_genmcl_px_setcc(u64 p);
static void mc_genmcl_px_min(u64 p);
static void mc_auxmcl_do_max_int(i64 cond);
static void mc_auxmcl_do_max_float(i64 opc);
static void mc_genmcl_px_max(u64 p);
static void mc_genmcl_px_power(u64 p);
static u64 mc_auxmcl_gethostfn(i64 opc);
static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs);
static void mc_genmcl_px_minto(u64 p);
static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode);
static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode);
static void mc_genmcl_px_maxto(u64 p);
static void mc_genmcl_px_negto(u64 p);
static void mc_genmcl_px_absto(u64 p);
static void mc_genmcl_px_addpxto(u64 p);
static void mc_genmcl_px_subpxto(u64 p);
static void mc_genmcl_px_divto(u64 p);
static void mc_genmcl_px_bitnotto(u64 p);
static void mc_genmcl_px_notto(u64 p);
static void mc_genmcl_px_toboolto(u64 p);
static void mc_genmcl_px_sign(u64 p);
static void mc_libmcl_clearreg(u64 ax);
static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode);
static void mc_genmcl_px_loadbf(u64 p);
static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j);
static void mc_auxmcl_do_loadbf_var(u64 p);
static void mc_genmcl_px_storebit(u64 p);
static void mc_auxmcl_do_storebit(u64 p);
static void mc_genmcl_px_storebf(u64 p);
static void mc_auxmcl_do_storebf(u64 p);
static void mc_genmcl_px_loadall(u64 p);
static void mc_stackmcl_checkallloaded();
static void mc_genmcl_px_setjmp(u64 p);
static void mc_stackmcl_freeworkregs(u64 p);
static void mc_genmcl_px_longjmp(u64 p);
static void mc_stackmcl_swapopndregs(i64 reg2);
static void mc_genmcl_px_initdswx(u64 p);
static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf);
static void mc_auxmcl_setmclentry(u64 p);
static u64 mc_libmcl_mgenname(u64 s);
static i64 mc_libmcl_roundsizetg(i64 size);
static u64 mc_auxmcl_resetmclentry();
static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size);
static void mc_auxmcl_spillparams();
static void mc_auxmcl_setmclentryf(u64 p);
static void mc_libmcl_pushstack(i64 n);
static u64 mc_auxmcl_resetmclentryf();
static void mc_libmcl_popstack(i64 n);
static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno);
static i64 mc_auxmcl_ismemaddr(i64 n);
static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n);
static void mc_auxmcl_saverdx();
static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz);
static void mc_auxmcl_restorerdx();
static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype);
static void mc_auxmcl_gendb(i64 a);
static void mc_auxmcl_gendbstring(u64 s, i64 length);
static u64 mc_libmcl_mgenstring(u64 s, i64 length);
static void mc_auxmcl_gendq(i64 a);
static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs);
static u64 mc_libmcl_mgenreg0(i64 reg, i64 size);
static u64 mc_libmcl_newmclopnd();
static void mc_libmcl_initmcdest();
static u64 mc_libmcl_mgenint0(i64 x, i64 size);
static void mc_libmcl_genmc_str(i64 opcode, u64 s);
static u64 mc_libmcl_duplopnd(u64 a);
static i64 mc_libmcl_getrealindex(r64 x);
static i64 mc_libmcl_getr32index(r64 x);
static u64 mc_libmcl_mgenxregvar(u64 d);
static u64 mc_libmcl_mgenregvar(u64 d, i64 mode);
static u64 mc_libmcl_mgenregi(i64 reg, i64 mode);
static u64 mc_libmcl_mgentemp(i64 n, i64 mode);
static void mc_libmcl_merroropnd(u64 mess, i64 opndtype);
static u64 mc_libmcl_findnamesym(u64 s);
static void mc_libmcl_addnamesym(u64 d);
static i64 mc_libmcl_getprimreg(u64 ax);
static i64 mc_libmcl_addconst(u64 clist, i64 value, i64 length);
static void mc_libmcl_axerror(u64 mess);
static i64 mc_stackmcl_getworkreg(i64 mode);
static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg);
static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg);
static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax);
static void mc_stackmcl_savenextopnd();
static i64 mc_stackmcl_getworkxreg();
static void mc_stackmcl_saveopnd(i64 n, i64 allregs);
static void mc_stackmcl_savenextxopnd();
static i64 mc_optim_isreg0(u64 a);
static i64 mc_optim_endr0(u64 m);
static i64 mc_optim_isreg10(u64 a);
static i64 mc_optim_isreg(u64 a);
static u64 mc_optim_deletemcl(u64 p);
static i64 mc_optim_isconst(u64 a);
static i64 mc_optim_isreg00(u64 m);
static i64 mc_optim_sameoperand(u64 a, u64 b);
static i64 mc_optim_sameregopnd(u64 a, u64 b);
static void mc_genss_initlib(i64 nlabels);
static u64 mc_genss_buffercreate(i64 size);
static void mc_genss_switchseg(i64 newseg);
static void mc_genss_doinstr(u64 m, i64 index);
static i64 mc_genss_bufferlength(u64 a);
static u64 mc_genss_bufferelemptr(u64 a, i64 offset);
static void mc_genss_bufferexpand(u64 a);
static i64 mc_genss_getcurrdatalen(i64 id);
static i64 mc_genss_getstindex(u64 d);
static void mc_genss_dofwdrefs(u64 d);
static void mc_genss_do_call(u64 a);
static void mc_genss_do_jmp(u64 a, u64 m);
static u64 mc_genss_getdef(u64 a, i64 dneeded);
static i64 mc_genss_getrel32(u64 d, i64 offset);
static void mc_genss_gendword(i64 x);
static i64 mc_genss_checkshortjump(u64 m, u64 d);
static void mc_genss_genrel32(u64 a);
static void mc_genss_genrel8(u64 a);
static void mc_genss_genopnd(u64 a, i64 size);
static void mc_genss_genword(i64 x);
static void mc_genss_do_push(u64 a);
static void mc_genss_do_pop(u64 a);
static void mc_genss_do_inc(u64 a, i64 code);
static void mc_genss_do_neg(u64 a, i64 code);
static void mc_genss_do_arith(u64 a, u64 b, i64 code);
static void mc_genss_do_mov(u64 a, u64 b);
static void mc_genss_do_lea(u64 a, u64 b);
static void mc_genss_do_movsx(u64 a, u64 b, i64 opc);
static void mc_genss_do_movsxd(u64 a, u64 b);
static void mc_genss_do_exch(u64 a, u64 b);
static void mc_genss_do_imul2(u64 a, u64 b);
static void mc_genss_buffercheck(u64 a, i64 n);
static void mc_genss_do_shift(u64 a, u64 b, i64 code);
static void mc_genss_do_test(u64 a, u64 b);
static void mc_genss_do_loop(u64 a, i64 opc);
static void mc_genss_do_jcxz(u64 a, i64 opsize);
static void mc_genss_do_setcc(i64 cond, u64 b);
static void mc_genss_do_movxmm(u64 a, u64 b, i64 size);
static void mc_genss_do_arithxmm(u64 a, u64 b, i64 prefix, i64 opc);
static void mc_genss_do_logicxmm(u64 a, u64 b, i64 opc, i64 size);
static void mc_genss_do_convertfloat(u64 a, u64 b, i64 prefix);
static void mc_genss_do_fix(u64 a, u64 b, i64 prefix, i64 opc);
static void mc_genss_do_float(u64 a, u64 b, i64 prefix);
static void mc_genss_do_cmovcc(i64 cond, u64 a, u64 b);
static void mc_genss_do_fmem(u64 a, i64 freal, i64 code);
static void mc_genss_do_movdqx(u64 a, u64 b, i64 prefix);
static void mc_genss_do_popcnt(u64 a, u64 b);
static void mc_genss_do_bsf(u64 a, u64 b, i64 opc);
static void mc_genss_do_bswap(u64 a);
static void mc_genss_do_dshift(u64 a, u64 b, i64 c, i64 opc);
static void mc_genss_start();
static void mc_genss_addword(u64 a, i64 x);
static void mc_genss_adddword(u64 a, i64 x);
static void mc_genss_genqword(i64 x);
static void mc_genss_addqword(u64 a, i64 x);
static void mc_genss_genabs32(u64 a);
static void mc_genss_genabs64(u64 a);
static void mc_genss_addrelocitem(i64 reloctype, u64 d);
static void mc_genss_extendsymboltable();
static u64 mc_genss_addfwdref(u64 p, i64 offset, i64 reltype, i64 seg);
static void mc_genss_genrex();
static i64 mc_genss_isbytesized(i64 x);
static i64 mc_genss_isdwordsized(i64 x);
static void mc_genss_genamode(u64 a, u64 am);
static void mc_genss_setopsize(u64 a);
static i64 mc_genss_getdispsize(u64 a, u64 offset);
static void mc_genss_checkhighreg(u64 a);
static void mc_genss_genxrm(i64 opcode, i64 code, u64 b);
static void mc_genss_genrrm(i64 opcode, u64 a, u64 b);
static i64 mc_genss_getregcode(i64 reg, i64 mask, i64 isxreg);
static void mc_genss_checkimmrange(i64 value, i64 size);
static u64 mc_writeasm_strmclstr(u64 m);
static void mc_genss_fixrip(i64 dispsize);
static void mc_genss_checksize(u64 a, i64 size1, i64 size2);
static void mc_decls_start();
static void mc_writeasm_writemcl(i64 index, u64 mcl);
static void mc_writeasm_asmstr(u64 s);
static void mc_writeasm_asmchar(i64 c);
static void mc_writeasm_asmopnd(u64 a, i64 sizeprefix, i64 opcode);
static i64 mc_writeasm_needsizeprefix(i64 opcode, u64 a, u64 b);
static u64 mc_writeasm_strreg(i64 reg, i64 size);
static u64 mc_writeasm_getsizeprefix(i64 size, i64 enable);
static u64 mc_writeasm_strxreg(i64 reg, i64 size);
static void mc_writeasm_start();
static void mc_writeexe_genexe1(u64 entrypoint, u64 outfile, i64 dodll);
static void mc_writeexe_genexe2(u64 outfile, i64 dodll);
static void mc_writeexe_initsectiontable();
static void mc_writeexe_loadlibs();
static void mc_writeexe_scanst();
static void mc_writeexe_getoffsets();
static void mc_writeexe_relocdata(u64 s);
static i64 mc_writeexe_getripoffset(i64 addr, i64 dest, i64 extra);
static void mc_writeexe_writepesig();
static void mc_writeexe_writefileheader();
static void mc_writeexe_writeoptheader();
static void mc_writeexe_writesectionheader(u64 s);
static void mc_writeexe_writepadding(i64 offset);
static void mc_writeexe_writesectiondata(u64 s);
static u64 mc_writeexe_extractlibname(u64 name, u64 libno, i64 moduleno);
static void mc_writeexe_getbaserelocs(u64 s);
static void mc_writeexe_newbasereloc(i64 addr, i64 reltype);
static void mc_writeexe_writerecordx(u64 r, i64 length);
static void mc_writeexe_writeexporttable(u64 pstart);
static void mc_writeexe_sortexports(u64 sortindex);
static i64 mc_writeexe_getsectionno(i64 segment);
static i64 mc_writeexe_getexporttablesize();
static void mc_writeexe_scanbaserelocs();
static void mc_writeexe_writebasereloctable(u64 pstart);
static void mc_writeobj_initsymboltable(u64 filename);
static void mc_writeobj_convertsymboltable();
static void mc_writeobj_writerecord(u64 r, i64 length);
static void mc_writeobj_writedata(u64 data);
static void mc_writeobj_writesymboltable();
static void mc_writeobj_writestringtable();
static i64 mc_writeobj_addstringentry(u64 s, i64 length);
static void mc_writeobj_addsymbol(u64 r);
static void mc_writess_showssdata(i64 fexe);
static void mc_writess_showsectiondata(u64 d);
static void mc_writess_showsectioncode(u64 p);
static void mc_writess_showsymboltable2();
static void mc_writess_showimporttable();
static void mc_writess_showsectionrelocs2(u64 caption, u64 relocs, i64 nrelocs);
static void mc_writess_gs_value(u64 caption, i64 value);
static void mc_writess_showsections();
static void mc_disasm_decodeaddr(i64 w);
static void mc_disasm_getsilx(u64 reg);
static void mc_disasm_getsil(u64 reg);
static void mc_disasm_genstr(u64 s);
static i64 mc_disasm_readimm();
static void mc_disasm_genintd(i64 a);
static void mc_disasm_decodetwobyteinstr();
static i64 mc_disasm_getreg(i64 regcode, i64 upper);
static i64 mc_disasm_readint16();
static i64 mc_disasm_readint32();
static i64 mc_disasm_readsbyte();
static i64 mc_disasm_readimm8();
static i64 mc_disasm_readbyte();
static u64 mc_disasm_readword16();
static void mc_disasm_decode8087(i64 ttt);
static void mc_disasm_genhex(i64 a);
static u64 mc_disasm_readword32();
static i64 mc_disasm_readi64();
static void mc_disasm_do87arith(u64 opcstr, i64 ttt, i64 freg);
static void mc_disasm_do87mem(u64 opcstr, i64 mf);
static u64 mx_run_writememlib(u64 filename);
static void mx_run_roundsegment(u64 p, i64 align, i64 value);
static void mx_run_countsymbols();
static void mx_run_writerelocs(u64 lib);
static void mx_run_addsymbols(u64 lib);
static void mx_lib_loadmemmcu(u64 lib);
static void mx_lib_fixuplib(u64 lib);
static void mx_lib_runprogram(u64 lib, i64 cmdskip);
static u64 mx_lib_readlibfile(u64 filespec, u64 p);
static u64 mx_lib_readu32(u64 p);
static i64 mx_lib_readbyte(u64 p);
static u64 mx_lib_readstring(u64 p);
static void mx_lib_alloclibdata(u64 lib);
static void mx_lib_error(u64 mess, u64 param);
static void mx_lib_checknew(u64 name, u64 filename);
static i64 mx_lib_mxaddlib(u64 name);
static void mx_lib_loadimports(u64 plib);
static i64 mx_lib_findlib(u64 name);
static void mx_lib_loaddlls();
static void mx_lib_checksymbols();
static void mx_lib_dorelocations();
static u64 mx_lib_finddllsymbol(u64 name, u64 dllindex);
static void mx_lib_reloclib(u64 lib);
static void mx_lib_dosublib(u64 name);
static void mx_lib_dosymbols(u64 lib);
static u64 mx_lib_loadlibfile(u64 filename, i64 libno);
static u64 mx_lib_readmxfile(u64 filename);
static void mx_lib_adddll(u64 name);
static i64 mx_lib_addsymbol(u64 name);
static void mx_lib_setspecialglobals(i64 cmdskip);
static void mx_lib_calllibinit(u64 lib);
static u64 mx_lib_findsymbol(u64 name);
static u64 mx_lib_loadmx(u64 filename);
static u64 mx_lib_loadmemmcb(u64 filename, u64 p);
static void mx_write_roundsegment(u64 p, i64 align, i64 value);
static void mx_write_genu32(i64 x);
static void mx_write_genbyte(i64 x);
static void mx_write_genstring(u64 s);
static void mx_write_writerelocs();
static void mx_write_genblock(u64 p, i64 length);
static void mx_write_writesymbols();
void cc_cli_main();
static void pcl_start();
static void cc_cli_starttiming();
static void cc_cli_initdata();
static void cc_cli_getinputoptions();
static void cc_cli_initsearchdirs();
static void cc_cli_showsearchdirs();
static void cc_cli_initlogfile();
static i64 cc_cli_gettiming();
static void cc_cli_do_loadmodule();
static void cc_cli_do_preprocess();
static void cc_cli_do_parsemodule();
static void cc_cli_do_genpcl();
static void cc_cli_do_genmcl();
static void cc_cli_do_asm();
static void cc_cli_do_obj();
static void cc_cli_do_dll();
static void cc_cli_do_exe();
static void cc_cli_do_mx();
static void cc_cli_do_run();
static void cc_cli_showtiming();
static void cc_cli_closelogfile();
static u64 cc_lex_addnamestr(u64 name);
static u64 cc_lib_createdupldef(u64 owner, u64 symptr, i64 id);
static void cc_support_loaderror(u64 mess, u64 mess2);
static i64 cc_support_loadsourcefile(u64 file, u64 shortfile);
static i64 cc_parse_parsemodule();
static void cc_genpcl_codegen_pcl();
static void cc_lib_addtolog(u64 filename, u64 logdest);
static void cc_cli_showast();
static void cc_cli_showst(u64 caption);
static void cc_cli_showstflat(u64 caption);
static void cc_show_printmodelist(u64 f);
static void cc_lex_lexsetup();
static void cc_lib_inittypetables();
static void cc_lib_initcclib();
static i64 cc_cli_cgetsourceinfo(i64 pos, u64 filename, u64 sourceline);
static void cc_show_printcode(u64 f, u64 caption);
static void cc_show_printstflat(u64 f);
static void cc_show_printst(u64 f, u64 p, i64 level);
static void cc_cli_showfiles();
static void cc_cli_showtime(u64 caption, i64 t);
static void cc_cli_do_option(i64 sw, u64 value);
static void cc_cli_showcaption();
static void cc_headers_writeheaders();
static void cc_cli_showhelp();
static void cc_cli_showincludepaths();
static void cc_lex_setfileno(i64 fileno);
static void cc_lex_stacksourcefile(u64 file, i64 syshdr);
static void cc_lex_emittoken(u64 lp, u64 dest, i64 forcespace);
static void cc_lex_lxerror(u64 mess);
static void cc_lex_showtokens(u64 caption, u64 tk);
static void cc_lex_lexreadtoken();
static void cc_lex_lxreadstring(i64 termchar, i64 fwide);
static i64 cc_lex_lookup();
static void cc_lex_setnumberoffset(i64 offset);
static void cc_lex_readdecimal(u64 pstart);
static void cc_lex_readhex(u64 pstart);
static void cc_lex_readbinary(u64 pstart);
static void cc_lex_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base);
static void cc_lex_readoctal(u64 pstart);
static void cc_lex_readlinecomment();
static void cc_lex_readblockcomment();
static void cc_lex_unstacksourcefile();
static void cc_lex_old_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base);
static u64 cc_lex_scannumber(i64 base);
static i64 cc_lex_readexponent(u64 badexpon);
static void cc_lex_readalphanumeric(u64 pstart);
static i64 cc_lex_getfileno();
static void cc_lex_printsymbol(u64 lp);
static void cc_lex_printstrn(u64 s, i64 length, u64 f);
static void cc_lex_shownumberstr(u64 l, u64 f);
static void cc_lex_inithashtable();
static void cc_lex_fillhashtable();
static void cc_lex_newhashtable();
static u64 cc_lex_gethashvalue(u64 s, i64 length);
static i64 cc_lex_dolexdirective();
static i64 cc_lex_getlexdirective();
static u64 cc_lex_strtoken(u64 lp, u64 length);
static void cc_lex_dodefine();
static i64 cc_lex_getifdef();
static i64 cc_lex_getifexpr();
static i64 cc_lex_skipcode();
static void cc_lex_dopragmadir();
static void cc_lex_startlex(u64 caption, i64 fileno);
static void cc_lex_lex();
static void cc_lex_endlex();
static void cc_lex_ps(u64 caption);
static void cc_lex_psnext(u64 caption);
static i64 cc_lex_gethashtablesize();
static i64 cc_lex_checknumbersuffix();
static u64 cc_headers_findheader(u64 name);
static i64 cc_support_loadbuiltin(u64 shortfile, u64 hdrtext);
static i64 cc_lex_getfilenox(u64 tk);
static i64 cc_lex_getnumberoffsetx(u64 tk);
static void cc_lex_addlisttoken(u64 ulist, u64 ulistx, u64 p);
static void cc_lex_addlisttoken_copy(u64 ulist, u64 ulistx, u64 q);
static u64 cc_lex_alloctoken();
static void cc_lex_addlist_nextlx(u64 ulist, u64 ulistx);
static void cc_lex_addlisttoken_seq(u64 ulist, u64 ulistx, u64 seq);
static void cc_lex_addlistmparam(u64 ulist, u64 ulistx, u64 p);
static i64 cc_lex_inmacrostack(u64 d, u64 macrostack);
static void cc_lex_lexa(u64 tk);
static i64 cc_lex_peeklb();
static void cc_lex_dospecialinclude();
static u64 cc_lex_expandfnmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel, u64 endlineno);
static u64 cc_lex_expandobjmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel);
static i64 cc_lex_peektk(u64 tk);
static u64 cc_lex_substituteargs(u64 m, u64 args, u64 expargs, i64 nargs, u64 macrostack);
static u64 cc_lex_scantokenseq(u64 tk, u64 macrostack, u64 expanded);
static i64 cc_lex_readmacrocall(u64 d, u64 args, u64 tksource);
static u64 cc_lex_alloctokenz();
static void cc_lex_setfilenox(u64 tk, i64 fileno);
static void cc_lex_pastetokens(u64 tk, u64 tknext);
static u64 cc_lex_strstring(u64 s, i64 length, u64 newlength, i64 quotechar);
static i64 cc_lib_convertstringc(u64 s, u64 t, i64 length);
static i64 cc_lex_needspace(i64 a, i64 b);
static i64 cc_lex_evalcondexpr(u64 sx);
static i64 cc_lex_evalorexpr(u64 sx);
static i64 cc_lex_evalandexpr(u64 sx);
static i64 cc_lex_evaliorexpr(u64 sx);
static i64 cc_lex_evalixorexpr(u64 sx);
static i64 cc_lex_evaliandexpr(u64 sx);
static i64 cc_lex_evaleqexpr(u64 sx);
static i64 cc_lex_evalcmpexpr(u64 sx);
static i64 cc_lex_evalshiftexpr(u64 sx);
static i64 cc_lex_evaladdexpr(u64 sx);
static i64 cc_lex_evalmulexpr(u64 sx);
static i64 cc_lex_evalunaryexpr(u64 sx);
static i64 cc_lex_evalterm(u64 sx);
static void cc_lex_fastreadtoken();
static void cc_lex_freetokens(u64 tk);
static void cc_lex_addbuildinfo(i64 code);
static void cc_lex_freehashtable();
static void cc_lex_regenlookup(u64 d);
static void cc_parse_readmodule();
static void cc_support_serror(u64 mess);
static i64 cc_parse_readdllexport();
static i64 cc_parse_readdeclspec(u64 owner, u64 linkage);
static i64 cc_parse_readtype(u64 owner, u64 d, i64 m, u64 pm);
static i64 cc_lib_createprocmode(i64 m, u64 pm);
static u64 cc_parse_createtypedef(u64 owner, u64 symptr, i64 mode);
static u64 cc_parse_readfunction(u64 d, i64 m, i64 linkage, u64 pm, u64 wasdef, i64 exported);
static u64 cc_parse_readmodulevar(u64 d, i64 m, i64 linkage);
static void cc_lib_skipsymbol(i64 symbol);
static void cc_support_serror_s(u64 mess, u64 a);
static void cc_lib_checksymbol(i64 symbol);
static i64 cc_parse_readstructdecl(u64 owner);
static i64 cc_parse_readenumdecl(u64 owner);
static i64 cc_parse_isusertype(u64 owner);
static i64 cc_lib_createconstmode(i64 m);
static i64 cc_parse_istypestarter();
static u64 cc_lib_resolvename(u64 owner, u64 symptr, i64 ns, i64 blockno);
static i64 cc_parse_istypestarter_next();
static u64 cc_parse_readexpression();
static u64 cc_parse_readterm();
static u64 cc_parse_readassignexpr();
static void cc_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static u64 cc_lib_createunit1(i64 tag, u64 p);
static u64 cc_parse_readcondexpr();
static void cc_parse_checklvalue(u64 p, i64 assign);
static u64 cc_parse_createassignopref(i64 opc, u64 p, u64 q);
static u64 cc_parse_coercemode(u64 p, i64 t);
static void cc_support_terror(u64 mess);
static u64 cc_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 cc_parse_readorlexpr();
static void cc_parse_coercecond(u64 p);
static u64 cc_lib_createunit3(i64 tag, u64 p, u64 q, u64 r);
static u64 cc_parse_readandlexpr();
static u64 cc_parse_readiorexpr();
static u64 cc_parse_readixorexpr();
static u64 cc_parse_readiandexpr();
static u64 cc_parse_readeqexpr();
static u64 cc_parse_readrelexpr();
static i64 cc_parse_checkpointertypes(i64 s, i64 t, i64 hard);
static u64 cc_parse_readshiftexpr();
static u64 cc_parse_readaddexpr();
static void cc_parse_coercebasetype(u64 p);
static u64 cc_parse_readmulexpr();
static u64 cc_parse_createaddop(u64 x, u64 y);
static u64 cc_parse_createsubop(u64 x, u64 y);
static u64 cc_parse_createmulop(u64 x, u64 y);
static u64 cc_parse_createdivop(u64 x, u64 y);
static u64 cc_parse_createremop(u64 x, u64 y);
static u64 cc_lib_createconstunit(u64 a, i64 t);
static u64 cc_lib_createunit0(i64 tag);
static i64 cc_lib_createrefmode(i64 m);
static u64 cc_lib_createname(u64 p);
static u64 cc_parse_createaddrofop(u64 p);
static void cc_parse_fixmemopnd(u64 p);
static u64 cc_lib_createwstringconstunit(u64 s, i64 length);
static u64 cc_lib_createstringconstunit(u64 s, i64 length);
static u64 cc_parse_createnegop(u64 p);
static u64 cc_parse_createinotop(u64 p);
static u64 cc_parse_createptrop(u64 p);
static u64 cc_parse_createincrop(i64 opc, u64 p);
static u64 cc_parse_createabsop(u64 p);
static i64 cc_parse_readcasttype(u64 d, i64 allowname, u64 pm, i64 m, u64 mbase);
static u64 cc_parse_docast(u64 p, i64 t, i64 hard, i64 inplace);
static u64 cc_parse_createsizeofop(u64 p, i64 islength);
static u64 cc_parse_readgeneric();
static u64 cc_parse_createindexop(u64 p, u64 q);
static u64 cc_parse_createdotop(i64 opc, u64 p, u64 d);
static u64 cc_parse_readexprlist(u64 p);
static u64 cc_parse_createcall(u64 p, u64 q);
static u64 cc_lib_checkdupl(u64 owner, u64 symptr, i64 ns, i64 blockno);
static void cc_support_serror_ss(u64 mess, u64 a, u64 b);
static i64 cc_parse_comparemode(i64 s, i64 t);
static u64 cc_parse_readinitexpr(u64 owner, i64 m);
static u64 cc_parse_readframevar(u64 d, i64 m, i64 linkage);
static u64 cc_lib_checkdupl_inproc(u64 owner, u64 symptr, i64 ns, i64 blockno);
static void cc_parse_readnamedtype(u64 owner, u64 d, u64 modtype, u64 modvalue, u64 nmodifiers);
static i64 cc_lib_createarraymode(i64 m, i64 length);
static u64 cc_parse_readparams(u64 owner);
static i64 cc_parse_readconstintexpr();
static u64 cc_parse_readinitexpr2(u64 owner, i64 m, i64 istop);
static void cc_parse_pushblock();
static void cc_parse_popblock();
static u64 cc_parse_readcompoundstmt(i64 params);
static u64 cc_parse_readstatement();
static u64 cc_parse_readblock(i64 ifelse);
static u64 cc_parse_readifstmt();
static u64 cc_parse_readforstmt();
static u64 cc_parse_readwhilestmt();
static u64 cc_parse_readdostmt();
static u64 cc_parse_readreturnstmt();
static u64 cc_parse_readswitchstmt();
static u64 cc_parse_readgotostmt();
static u64 cc_parse_readcaselabel();
static u64 cc_parse_readlocaldecl();
static u64 cc_show_strexpr(u64 p);
static u64 cc_parse_readcond();
static i64 cc_parse_iscondtrue(u64 p);
static void cc_parse_deleteunit(u64 p, u64 q);
static i64 cc_parse_iscondfalse(u64 p);
static u64 cc_parse_readexprstmt();
static void cc_parse_pushloop(i64 looptype);
static void cc_parse_poploop();
static void cc_parse_addcasevalue(i64 value);
static void cc_lib_addlistparam(u64 ulist, u64 ulistx, u64 p);
static void cc_parse_readfunctionbody(u64 f);
static i64 cc_lib_isintcc(i64 m);
static void cc_show_printunit(u64 dev, u64 p, i64 level, u64 prefix);
static u64 cc_parse_arraytopointer(u64 p);
static i64 cc_parse_getmemmode(u64 p);
static u64 cc_parse_eval_add(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_divunit(u64 p, i64 elemtype);
static u64 cc_parse_mulunit(u64 p, i64 elemtype);
static u64 cc_parse_eval_sub(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_mul(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_div(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_rem(i64 opc, u64 x, u64 y, i64 t);
static void cc_parse_insertunit(u64 p, i64 tag);
static i64 cc_parse_eval_convert(u64 p, i64 t, i64 opc);
static void cc_support_terror_s(u64 mess, u64 a);
static void cc_parse_coercemode_inplace(u64 p, i64 t);
static i64 cc_lib_createstructmode(u64 s, i64 smode);
static void cc_lib_addlistdef(u64 ulist, u64 ulistx, u64 p);
static i64 cc_lib_getalignment(i64 m);
static i64 cc_parse_roundoffset(i64 offset, i64 alignment);
static void cc_parse_addnewfield(u64 flist, u64 d, i64 offset);
static u64 cc_lib_getautofieldname();
static void cc_parse_readenumnames(u64 owner);
static i64 cc_lib_createenummode(u64 e);
static void cc_support_terror_ss(u64 mess, u64 a, u64 b);
static i64 cc_parse_getpromotedtype(i64 t);
static void cc_genpcl_dolibs();
static void cc_genpcl_dostaticvar(u64 d);
static void cc_support_gerror_s(u64 mess, u64 s, u64 p);
static void cc_genpcl_genprocdef(u64 p);
static u64 cc_libpcl_getpsymbol(u64 d);
static i64 cc_libpcl_createfwdlabel();
static void cc_blockpcl_do_stmt(u64 p);
static void cc_libpcl_setmode(i64 mode);
static void cc_libpcl_definefwdlabel(i64 lab);
static u64 cc_libpcl_genmem_d(u64 d);
static void cc_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset);
static void cc_genpcl_doresb(i64 n);
static i64 cc_lib_isrealcc(i64 m);
static void cc_support_gerror(u64 mess, u64 p);
static u64 cc_libpcl_genmemaddr_d(u64 d);
static void cc_genpcl_pushint(i64 a);
static void cc_blockpcl_do_decl(u64 d);
static void cc_blockpcl_dx_call(u64 p, u64 a, u64 b, i64 res);
static void cc_blockpcl_do_return(u64 p, u64 a);
static void cc_blockpcl_do_assign(u64 a, u64 b, i64 res);
static void cc_blockpcl_do_if(u64 a, u64 b, u64 c);
static void cc_blockpcl_do_for(u64 pinit, u64 pbody);
static void cc_blockpcl_do_while(u64 pcond, u64 pbody);
static void cc_blockpcl_do_dowhile(u64 pbody, u64 pcond);
static void cc_blockpcl_do_goto(u64 d);
static void cc_blockpcl_do_labeldef(u64 d);
static void cc_blockpcl_do_casestmt(u64 p, u64 a);
static void cc_blockpcl_genjumpl(i64 lab);
static void cc_blockpcl_do_switch(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_binto(u64 a, u64 b, i64 opc, i64 res);
static void cc_blockpcl_do_preincr(u64 a, i64 incrop);
static void cc_blockpcl_dx_expr(u64 p, i64 am);
static void cc_libpcl_setmode_u(u64 p);
static void cc_blockpcl_dx_const(u64 p);
static void cc_blockpcl_dx_name(u64 p, i64 am);
static void cc_blockpcl_dx_andorl(u64 p);
static i64 cc_blockpcl_isboolexpr(u64 p);
static void cc_libpcl_setmode2(i64 mode);
static void cc_blockpcl_dx_ifx(u64 p, u64 a, u64 b, u64 c);
static void cc_blockpcl_dx_eq(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_bin(u64 a, u64 b, i64 opc);
static void cc_blockpcl_dx_ptr(u64 p, u64 a, i64 am);
static void cc_blockpcl_dx_addptr(u64 p, u64 a, u64 b, i64 opc, i64 am);
static void cc_blockpcl_dx_convert(u64 p, u64 a, i64 t, i64 opc);
static void cc_blockpcl_dx_scale(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_preincrx(u64 p, u64 a);
static void cc_blockpcl_dx_postincrx(u64 p, u64 a);
static void cc_blockpcl_dx_addrof(u64 p, u64 a, i64 am);
static void cc_blockpcl_dx_dot(u64 p, u64 a, u64 b, i64 am);
static void cc_blockpcl_widen(u64 p);
static void cc_blockpcl_do_setinplace();
static void cc_blockpcl_do_fixwiden(u64 a, u64 b);
static void cc_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab);
static void cc_blockpcl_gcomparejump(i64 jumpopc, u64 p, u64 lhs, u64 rhs, i64 lab);
static i64 cc_blockpcl_getpclcond(i64 op);
static i64 cc_blockpcl_reversecond(i64 cc);
static void cc_blockpcl_do_while1(u64 pbody);
static void cc_blockpcl_stacklooplabels(i64 a, i64 b);
static i64 cc_libpcl_definelabel();
static void cc_blockpcl_setincrstep(i64 m);
static i64 cc_lib_getpclmode(i64 t);
static u64 cc_lib_newstrec();
static u64 cc_lib_allocunitrec();
static i64 cc_lib_getconstvalue(u64 p, i64 id);
static i64 cc_lib_copymode(i64 m);
static i64 cc_lib_createnewmode(i64 m);
static void cc_lib_setnameptr(u64 p);
static void cc_lib_istrmode(i64 m, i64 expand, u64 dest);
static void cc_support_mcerror(u64 mess);
static u64 cc_lib_createnewmoduledef(u64 owner, u64 symptr);
static u64 cc_lib_createnewproc(u64 owner, u64 symptr);
static u64 cc_lib_resolvelabel(u64 owner, u64 symptr);
static i64 cc_lib_isexported(u64 d);
static i64 cc_lib_isimported(u64 d);
static void cc_lib_writegsfile(u64 filename, u64 d);
static void cc_lib_pause(u64 mess);
static void cc_support_stopcompiler(u64 filename, i64 lineno);
static void cc_support_serror_gen(u64 mess);
static void cc_support_showmacrolineno();
static void cc_support_terror_gen(u64 mess);
static void cc_support_gerror_gen(u64 mess, u64 p);
static i64 cc_support_nextpoweroftwo(i64 x);
static u64 cc_support_splicelines(u64 s);
static void cc_support_gs_copytostr(u64 source, u64 s);
static void cc_support_gs_additem(u64 dest, u64 s);
static i64 cc_support_isalphanum(i64 c);
static i64 cc_headers_isheaderfile(u64 file);
static void cc_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix);
static void cc_show_printstrec(u64 f, u64 p, i64 level);
static void cc_show_jeval(u64 dest, u64 p);
static void cc_show_printfilelist(u64 f);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    cc_cli_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static i64 mlinux_init_flag = 0;

static u8 pcl_pc_userunpcl = 0;

static u8 pcl_asmonly = 0;

static u8 pcl_pdcc = 0;

static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc = 65536;

static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B17 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest = (u64)&pc_decls_sbuffer;

static struct $B18 pc_decls_plibfiles;
static struct $B18 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype = 16705;

static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole = 1;

static u8 pc_decls_fregoptim = 1;

static u8 pc_decls_fnoconst = 0;

static u8 pc_decls_fshowil = 0;

static u8 pc_decls_flong64 = 0;

static i64 pc_decls_pcltime;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B19 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_decls_npcl;
static i64 pc_decls_npst;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest = (u64)&pc_diags_sbuffer;

static i64 pc_diags_destlinestart;
static struct $B20 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static u64 pc_diags_psopnd_longstring;
static i64 pc_run_dotrace = 0;

static i64 pc_run_dostep = 1;

static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B21 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B22 pc_tables_pstdnames = {{
(u64)"void",
(u64)"r32",
(u64)"r64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"mem",
(u64)"vec",
(u64)"$last"}};

static struct $B23 pc_tables_psize = {{
1024,
264,
1026,
264,
1026,
8,
0}};

static struct $B23 pc_tables_psigned = {{
0,
0,
0,
256,
257,
1,
0}};

static struct $B23 pc_tables_pint = {{
0,
256,
257,
257,
257,
1,
0}};

static struct $B23 pc_tables_pfloat = {{
256,
1,
0,
0,
0,
0,
0}};

static struct $B23 pc_tables_pmin = {{
256,
1282,
1285,
2310,
2313,
2826,
12}};

static struct $B23 pc_tables_xxpiwrb = {{
256,
1538,
1542,
2566,
2570,
10,
0}};

static struct $B22 pc_tables_opndnames = {{
(u64)"no_opnd",
(u64)"mem_opnd",
(u64)"memaddr_opnd",
(u64)"label_opnd",
(u64)"int_opnd",
(u64)"real_opnd",
(u64)"r32_opnd",
(u64)"string_opnd",
(u64)"strimm_opnd",
(u64)"assem_opnd",
(u64)"realimm_opnd",
(u64)"realimm32_opnd",
(u64)"data_opnd",
(u64)"any_opnd"}};

static struct $B19 pc_tables_pclnames = {{
(u64)"nop",
(u64)"load",
(u64)"iload",
(u64)"iloadx",
(u64)"store",
(u64)"istore",
(u64)"istorex",
(u64)"storem",
(u64)"dupl",
(u64)"double",
(u64)"swapstk",
(u64)"unload",
(u64)"opnd",
(u64)"type",
(u64)"loadbit",
(u64)"loadbf",
(u64)"storebit",
(u64)"storebf",
(u64)"callp",
(u64)"icallp",
(u64)"retproc",
(u64)"callf",
(u64)"icallf",
(u64)"retfn",
(u64)"jump",
(u64)"ijump",
(u64)"jumpcc",
(u64)"jumpt",
(u64)"jumpf",
(u64)"jumpret",
(u64)"jumpretm",
(u64)"setcc",
(u64)"stop",
(u64)"to",
(u64)"forup",
(u64)"fordown",
(u64)"iswap",
(u64)"switch",
(u64)"switchu",
(u64)"swlabel",
(u64)"endsw",
(u64)"clear",
(u64)"assem",
(u64)"add",
(u64)"sub",
(u64)"mul",
(u64)"div",
(u64)"idiv",
(u64)"irem",
(u64)"idivrem",
(u64)"bitand",
(u64)"bitor",
(u64)"bitxor",
(u64)"shl",
(u64)"shr",
(u64)"min",
(u64)"max",
(u64)"addpx",
(u64)"subpx",
(u64)"subp",
(u64)"neg",
(u64)"abs",
(u64)"bitnot",
(u64)"not",
(u64)"toboolt",
(u64)"toboolf",
(u64)"sqr",
(u64)"sqrt",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"sign",
(u64)"atan2",
(u64)"power",
(u64)"fmod",
(u64)"incrto",
(u64)"decrto",
(u64)"incrload",
(u64)"decrload",
(u64)"loadincr",
(u64)"loaddecr",
(u64)"addto",
(u64)"subto",
(u64)"multo",
(u64)"divto",
(u64)"idivto",
(u64)"iremto",
(u64)"bitandto",
(u64)"bitorto",
(u64)"bitxorto",
(u64)"shlto",
(u64)"shrto",
(u64)"minto",
(u64)"maxto",
(u64)"addpxto",
(u64)"subpxto",
(u64)"negto",
(u64)"absto",
(u64)"bitnotto",
(u64)"notto",
(u64)"toboolto",
(u64)"typepun",
(u64)"float",
(u64)"fix",
(u64)"truncate",
(u64)"widen",
(u64)"fwiden",
(u64)"fnarrow",
(u64)"startmx",
(u64)"resetmx",
(u64)"endmx",
(u64)"proc",
(u64)"tcproc",
(u64)"endproc",
(u64)"istatic",
(u64)"zstatic",
(u64)"data",
(u64)"initdswx",
(u64)"label",
(u64)"labeldef",
(u64)"setjmp",
(u64)"longjmp",
(u64)"setcall",
(u64)"setarg",
(u64)"loadall",
(u64)"eval",
(u64)"comment",
(u64)"endprog",
(u64)"param",
(u64)"local",
(u64)"rettype",
(u64)"variadic",
(u64)"addlib",
(u64)"extproc"}};

static struct $B24 pc_tables_pclhastype = {{
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
2,
2,
2,
2,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0}};

static struct $B24 pc_tables_pclextra = {{
0,
1,
0,
2,
0,
0,
2,
0,
0,
0,
2,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
2,
2,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
0,
0,
0,
0,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B24 pc_tables_pclhasopnd = {{
0,
13,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
13,
0,
0,
0,
0,
0,
2,
0,
0,
2,
0,
0,
3,
0,
3,
3,
3,
3,
3,
0,
0,
3,
3,
3,
0,
3,
3,
3,
0,
0,
13,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
1,
1,
13,
0,
3,
2,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
7,
1}};

static struct $B24 pc_tables_pclargs = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
9,
9,
0,
9,
9,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B25 pc_tables_ccnames = {{
(u64)"xx",
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B1 pc_tables_idnames = {{
(u64)"--",
(u64)"Import",
(u64)"Proc",
(u64)"Static",
(u64)"Local",
(u64)"Param",
(u64)"Label",
(u64)"Export",
(u64)"Misc",
(u64)"Program"}};

static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B19 mc_genmcl_px_handlertable;
static struct $B26 mc_genmcl_scondcodes = {{
1284,
3596,
3853}};

static struct $B26 mc_genmcl_ucondcodes = {{
1284,
1538,
1795}};

// Istatic skipped:mc_genmcl.inithandlers.initdone

// Istatic skipped:mc_genmcl.inithandlers.dupltable

static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B29 mc_libmcl_smallinttable;
static struct $B30 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B30 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B20 mc_stackmcl_stropndstack_str;
static u8 mc_genss_rex;
static u8 mc_genss_sizeoverride;
static u8 mc_genss_addroverride;
static u8 mc_genss_f2override;
static u8 mc_genss_f3override;
static u8 mc_genss_nowmask;
static u8 mc_genss_usesizeb;
static u64 mc_genss_extraparam;
static i64 mc_genss_currseg = 0;

static u64 mc_genss_currdata;
static u64 mc_genss_currrelocs;
static i64 mc_genss_nrelocs;
static struct $B3 mc_genss_ishighreg;
static u64 mc_genss_currmcl;
static u64 mc_genss_ripentry;
// Istatic skipped:mc_genss.genrm.scaletable

static struct $B11 mc_decls_valtypenames = {{
(u64)"no_val",
(u64)"intimm_val",
(u64)"realimm_val",
(u64)"realmem_val",
(u64)"stringimm_val",
(u64)"def_val",
(u64)"label_val",
(u64)"name_val",
(u64)"temp_val"}};

static struct $B32 mc_decls_mclnames = {{
(u64)"m_procstart",
(u64)"m_procend",
(u64)"m_comment",
(u64)"m_labelname",
(u64)"m_define",
(u64)"m_definereg",
(u64)"m_trace",
(u64)"m_endx",
(u64)"m_labelx",
(u64)"m_nop",
(u64)"m_mov",
(u64)"m_push",
(u64)"m_pop",
(u64)"m_lea",
(u64)"m_cmovcc",
(u64)"m_movd",
(u64)"m_movq",
(u64)"m_movsx",
(u64)"m_movzx",
(u64)"m_movsxd",
(u64)"m_call",
(u64)"m_ret",
(u64)"m_leave",
(u64)"m_retn",
(u64)"m_jmp",
(u64)"m_jmpcc",
(u64)"m_xchg",
(u64)"m_add",
(u64)"m_sub",
(u64)"m_adc",
(u64)"m_sbb",
(u64)"m_imul",
(u64)"m_mul",
(u64)"m_imul2",
(u64)"m_imul3",
(u64)"m_idiv",
(u64)"m_div",
(u64)"m_andx",
(u64)"m_orx",
(u64)"m_xorx",
(u64)"m_test",
(u64)"m_cmp",
(u64)"m_shl",
(u64)"m_sar",
(u64)"m_shr",
(u64)"m_rol",
(u64)"m_ror",
(u64)"m_rcl",
(u64)"m_rcr",
(u64)"m_neg",
(u64)"m_notx",
(u64)"m_inc",
(u64)"m_dec",
(u64)"m_cbw",
(u64)"m_cwd",
(u64)"m_cdq",
(u64)"m_cqo",
(u64)"m_setcc",
(u64)"m_bsf",
(u64)"m_bsr",
(u64)"m_shld",
(u64)"m_shrd",
(u64)"m_sqrtss",
(u64)"m_sqrtsd",
(u64)"m_addss",
(u64)"m_addsd",
(u64)"m_subss",
(u64)"m_subsd",
(u64)"m_mulss",
(u64)"m_mulsd",
(u64)"m_divss",
(u64)"m_divsd",
(u64)"m_comiss",
(u64)"m_comisd",
(u64)"m_ucomisd",
(u64)"m_xorps",
(u64)"m_xorpd",
(u64)"m_andps",
(u64)"m_andpd",
(u64)"m_pxor",
(u64)"m_pand",
(u64)"m_cvtss2si",
(u64)"m_cvtsd2si",
(u64)"m_cvttss2si",
(u64)"m_cvttsd2si",
(u64)"m_cvtsi2ss",
(u64)"m_cvtsi2sd",
(u64)"m_cvtsd2ss",
(u64)"m_cvtss2sd",
(u64)"m_movdqa",
(u64)"m_movdqu",
(u64)"m_pcmpistri",
(u64)"m_pcmpistrm",
(u64)"m_fld",
(u64)"m_fst",
(u64)"m_fstp",
(u64)"m_fild",
(u64)"m_fist",
(u64)"m_fistp",
(u64)"m_fadd",
(u64)"m_fsub",
(u64)"m_fmul",
(u64)"m_fdiv",
(u64)"m_fsqrt",
(u64)"m_fsin",
(u64)"m_fcos",
(u64)"m_fsincos",
(u64)"m_fptan",
(u64)"m_fpatan",
(u64)"m_fabs",
(u64)"m_fchs",
(u64)"m_minss",
(u64)"m_maxss",
(u64)"m_minsd",
(u64)"m_maxsd",
(u64)"m_db",
(u64)"m_dw",
(u64)"m_dd",
(u64)"m_dq",
(u64)"m_ascii",
(u64)"m_isegment",
(u64)"m_zsegment",
(u64)"m_csegment",
(u64)"m_align",
(u64)"m_resb",
(u64)"m_resw",
(u64)"m_resd",
(u64)"m_resq",
(u64)"m_xlat",
(u64)"m_loopnz",
(u64)"m_loopz",
(u64)"m_loopcx",
(u64)"m_jecxz",
(u64)"m_jrcxz",
(u64)"m_cmpsb",
(u64)"m_cmpsw",
(u64)"m_cmpsd",
(u64)"m_cmpsq",
(u64)"m_rdtsc",
(u64)"m_popcnt",
(u64)"m_bswap",
(u64)"m_finit",
(u64)"m_fldz",
(u64)"m_fld1",
(u64)"m_fldpi",
(u64)"m_fld2t",
(u64)"m_fld2e",
(u64)"m_fldlg2",
(u64)"m_fldln2",
(u64)"m_cpuid",
(u64)"m_xxxx",
(u64)"m_halt"}};

static struct $B33 mc_decls_mclnopnds = {{
0,
144680341364408321,
72057598366581250,
72622751638225153,
144680341364474369,
144680345676153346,
4311810306,
144680345676153088,
144680345676153346,
144680345676153346,
144680345676153346,
72340181461631490,
65793,
144115188075855872,
72340172838142466,
72340172838010880,
1103823438080,
4328521728,
0}};

static struct $B33 mc_decls_mclcodes = {{
0,
36864,
56791871518670848,
361134615617863913,
432631463138033668,
144396684645107456,
4295099139,
5859654413743554560,
6799970727712544856,
-1201242466499547392,
219,
216736154650895872,
-362036289223851520,
6764655078180388862,
6249823,
577588855528488960,
250567903535319,
-1662391212449923072,
-796010212255667733}};

static struct $B34 mc_decls_regnames = {{
(u64)"rnone",
(u64)"r0",
(u64)"r1",
(u64)"r2",
(u64)"r3",
(u64)"r4",
(u64)"r5",
(u64)"r6",
(u64)"r7",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"r16",
(u64)"r17",
(u64)"r18",
(u64)"r19"}};

static struct $B35 mc_decls_regcodes = {{
0,
0,
10,
11,
7,
3,
6,
12,
13,
14,
15,
1,
2,
8,
9,
5,
4,
4,
7,
5,
6}};

static struct $B30 mc_decls_condnames = {{
(u64)"ov",
(u64)"nov",
(u64)"ltu",
(u64)"geu",
(u64)"eq",
(u64)"ne",
(u64)"leu",
(u64)"gtu",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"lt",
(u64)"ge",
(u64)"le",
(u64)"gt",
(u64)"flt",
(u64)"fge",
(u64)"fle",
(u64)"fgt"}};

static struct $B30 mc_decls_asmcondnames = {{
(u64)"o",
(u64)"no",
(u64)"b",
(u64)"ae",
(u64)"z",
(u64)"nz",
(u64)"be",
(u64)"a",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"l",
(u64)"ge",
(u64)"le",
(u64)"g",
(u64)"b",
(u64)"ae",
(u64)"be",
(u64)"a"}};

static struct $B30 mc_decls_asmrevcond = {{
1,
0,
3,
2,
5,
4,
7,
6,
9,
8,
11,
10,
13,
12,
15,
14,
17,
16,
19,
18}};

static struct $B36 mc_decls_dregnames = {{
(u64)"d0",
(u64)"d1",
(u64)"d2",
(u64)"d3",
(u64)"d4",
(u64)"d5",
(u64)"d6",
(u64)"d7",
(u64)"d8",
(u64)"d9",
(u64)"d10",
(u64)"d11",
(u64)"d12",
(u64)"d13",
(u64)"d14",
(u64)"d15",
(u64)"a0",
(u64)"a1",
(u64)"a2",
(u64)"a3",
(u64)"a4",
(u64)"a5",
(u64)"a6",
(u64)"a7",
(u64)"a8",
(u64)"a9",
(u64)"a10",
(u64)"a11",
(u64)"a12",
(u64)"a13",
(u64)"a14",
(u64)"a15",
(u64)"w0",
(u64)"w1",
(u64)"w2",
(u64)"w3",
(u64)"w4",
(u64)"w5",
(u64)"w6",
(u64)"w7",
(u64)"w8",
(u64)"w9",
(u64)"w10",
(u64)"w11",
(u64)"w12",
(u64)"w13",
(u64)"w14",
(u64)"w15",
(u64)"b0",
(u64)"b1",
(u64)"b2",
(u64)"b3",
(u64)"b4",
(u64)"b5",
(u64)"b6",
(u64)"b7",
(u64)"b8",
(u64)"b9",
(u64)"b10",
(u64)"b11",
(u64)"b12",
(u64)"b13",
(u64)"b14",
(u64)"b15",
(u64)"b16",
(u64)"b17",
(u64)"b18",
(u64)"b19",
(u64)"_b20",
(u64)"rax",
(u64)"rbx",
(u64)"rcx",
(u64)"rdx",
(u64)"rsi",
(u64)"rdi",
(u64)"rbp",
(u64)"rsp",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"eax",
(u64)"ebx",
(u64)"ecx",
(u64)"edx",
(u64)"esi",
(u64)"edi",
(u64)"ebp",
(u64)"esp",
(u64)"r8d",
(u64)"r9d",
(u64)"r10d",
(u64)"r11d",
(u64)"r12d",
(u64)"r13d",
(u64)"r14d",
(u64)"r15d",
(u64)"ax",
(u64)"bx",
(u64)"cx",
(u64)"dx",
(u64)"si",
(u64)"di",
(u64)"bp",
(u64)"sp",
(u64)"r8w",
(u64)"r9w",
(u64)"r10w",
(u64)"r11w",
(u64)"r12w",
(u64)"r13w",
(u64)"r14w",
(u64)"r15w",
(u64)"al",
(u64)"bl",
(u64)"cl",
(u64)"dl",
(u64)"ah",
(u64)"bh",
(u64)"ch",
(u64)"dh",
(u64)"sil",
(u64)"dil",
(u64)"bpl",
(u64)"spl",
(u64)"r8b",
(u64)"r9b",
(u64)"r10b",
(u64)"r11b",
(u64)"r12b",
(u64)"r13b",
(u64)"r14b",
(u64)"r15b"}};

static struct $B37 mc_decls_regsizes = {{
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1}};

static struct $B37 mc_decls_regindices = {{
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
0,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
17,
18,
19,
20,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10}};

static struct $B21 mc_decls_xmmregnames = {{
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm14",
(u64)"xmm15"}};

static struct $B31 mc_decls_fregnames = {{
(u64)"st0",
(u64)"st1",
(u64)"st2",
(u64)"st3",
(u64)"st4",
(u64)"st5",
(u64)"st6",
(u64)"st7"}};

static struct $B31 mc_decls_mregnames = {{
(u64)"mmx0",
(u64)"mmx1",
(u64)"mmx2",
(u64)"mmx3",
(u64)"mmx4",
(u64)"mmx5",
(u64)"mmx6",
(u64)"mmx7"}};

static struct $B38 mc_decls_jmpccnames = {{
(u64)"jo",
(u64)"jno",
(u64)"jb",
(u64)"jae",
(u64)"jz",
(u64)"jnz",
(u64)"jbe",
(u64)"ja",
(u64)"js",
(u64)"jns",
(u64)"jp",
(u64)"jnp",
(u64)"jl",
(u64)"jge",
(u64)"jle",
(u64)"jg",
(u64)"jc",
(u64)"jnc"}};

static struct $B27 mc_decls_jmpcccodes = {{
256,
770,
1284,
1798,
2312,
2826,
3340,
3854,
770}};

static struct $B21 mc_decls_setccnames = {{
(u64)"seto",
(u64)"setno",
(u64)"setb",
(u64)"setae",
(u64)"setz",
(u64)"setnz",
(u64)"setbe",
(u64)"seta",
(u64)"sets",
(u64)"setns",
(u64)"setp",
(u64)"setnp",
(u64)"setl",
(u64)"setge",
(u64)"setle",
(u64)"setg"}};

static struct $B3 mc_decls_setcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B21 mc_decls_cmovccnames = {{
(u64)"cmovo",
(u64)"cmovno",
(u64)"cmovb",
(u64)"cmovae",
(u64)"cmovz",
(u64)"cmovnz",
(u64)"cmovbe",
(u64)"cmova",
(u64)"cmovs",
(u64)"cmovns",
(u64)"cmovp",
(u64)"cmovnp",
(u64)"cmovl",
(u64)"cmovge",
(u64)"cmovle",
(u64)"cmovg"}};

static struct $B3 mc_decls_cmovcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B12 mc_decls_segmentnames = {{
(u64)"no_seg",
(u64)"code_seg",
(u64)"idata_seg",
(u64)"zdata_seg",
(u64)"rodata_seg",
(u64)"impdata_seg"}};

static struct $B8 mc_decls_reftypenames = {{
(u64)"extern_ref",
(u64)"fwd_ref",
(u64)"back_ref"}};

static struct $B12 mc_decls_opndnames_ma = {{
(u64)"a_none",
(u64)"a_reg",
(u64)"a_imm",
(u64)"a_mem",
(u64)"a_cond",
(u64)"a_xreg"}};

static struct $B18 mc_decls_pclopnd;
static struct $B39 mc_decls_pclreg;
static struct $B39 mc_decls_pclmode;
static struct $B39 mc_decls_pclcount;
static struct $B39 mc_decls_pclloc;
static struct $B39 mc_decls_pcltempflags;
static struct $B18 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B17 mc_decls_locnames = {{
(u64)"pend",
(u64)"reg",
(u64)"regvar",
(u64)"temp"}};

static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames = {{
(u64)"-",
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm15",
(u64)"xmm15"}};

static struct $B3 mc_decls_callalign;
static struct $B3 mc_decls_callblockret;
static struct $B31 mc_decls_callblocksize;
static struct $B20 mc_decls_callargmode;
static struct $B41 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used = 0;

static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment = 0;

static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B42 mc_decls_regtable;
static struct $B43 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes = 432345564311454723;

static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B18 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs = {{
1,
2,
3,
11,
12,
13}};

static struct $B12 mc_decls_multxregs = {{
1,
2,
3,
4,
5,
6}};

static struct $B23 mc_decls_ploadopx;
static struct $B23 mc_decls_ploadop;
static struct $B25 mc_objdecls_relocnames = {{
(u64)"abs_rel",
(u64)"addr64_rel",
(u64)"addr32_rel",
(u64)"addr32nb_rel",
(u64)"rel32_rel",
(u64)"rel321_rel",
(u64)"rel8_rel"}};

static u64 mc_writeasm_asmext = (u64)"asm";

static struct $B42 mc_writeasm_nregnames;
static struct $B21 mc_writeasm_regvars;
static struct $B21 mc_writeasm_xregvars;
static struct $B20 mc_writeasm_strmcl_str;
static struct $B20 mc_writeasm_mstropnd_str;
static struct $B20 mc_writeasm_strvalue_str;
// Istatic skipped:mc_writeasm.getregname.prefix

static struct $B17 mc_writeasm_getregname_str;
static struct $B17 mc_writeasm_getxregname_str;
static struct $B16 mc_writeasm_getdispname_str;
static struct $B21 mc_writeasm_gettempname_str;
static struct $B18 mc_writeexe_libinsttable;
static struct $B18 mc_writeexe_libinstnames;
static struct $B18 mc_writeexe_libnotable;
static u64 mc_writeexe_basereloclist;
static i64 mc_writeexe_nbaserelocs;
static i64 mc_writeexe_maxrelocaddr;
static struct $B45 mc_writeexe_blockbases;
static struct $B46 mc_writeexe_blockcounts;
static struct $B46 mc_writeexe_blockbytes;
static struct $B47 mc_writeexe_blockpadding;
static i64 mc_writeexe_nbaseblocks;
static i64 mc_writeexe_basetablesize;
static i64 mc_writeexe_imagebase;
static i64 mc_writeexe_imagesize;
static i64 mc_writeexe_filesize;
static u64 mc_writeexe_thunktable;
static i64 mc_writeexe_fileiatoffset;
static i64 mc_writeexe_fileiatsize;
static u64 mc_writeexe_stentrypoint;
static u64 mc_writeexe_stentrypoint2;
static u64 mc_writeexe_stentrypoint3;
static struct $B48 mc_writeexe_sectiontable;
static i64 mc_writeexe_nsections;
static u64 mc_writeexe_importdir;
static struct $B49 mc_writeexe_importtable;
static i64 mc_writeexe_nimports;
static struct $B50 mc_writeexe_exporttable;
static i64 mc_writeexe_nexports;
static u64 mc_writeexe_dllfilename;
static i64 mc_writeexe_isdll;
static struct $B51 mc_writeexe_dlltable;
static i64 mc_writeexe_ndlls;
static u64 mc_writeexe_datastart;
static u64 mc_writeexe_dataptr;
static u64 mc_writeexe_userentrypoint;
static i64 mc_writeexe_exportdirvirtaddr;
static i64 mc_writeexe_exportdirvirtsize;
static i64 mc_writeexe_exportdiroffset;
static i64 mc_writeexe_blockdirvirtaddr;
static i64 mc_writeexe_blockdirvirtsize;
static i64 mc_writeexe_blockdiroffset;
// Istatic skipped:mc_writeexe.writedosstub.stubdata

static i64 mc_writeobj_symtaboffset;
static u64 mc_writeobj_datastart;
static u64 mc_writeobj_dataptr;
static struct $B52 mc_writeobj_symboltable;
static i64 mc_writeobj_nsymbols;
static i64 mc_writeobj_stoffset = 0;

static struct $B53 mc_writeobj_stringtable;
static struct $B53 mc_writeobj_stringlengths;
static i64 mc_writeobj_nextstringoffset = 0;

static i64 mc_writeobj_nstrings = 0;

static struct $B2 mc_writeobj_writerelocs_s;
static struct $B27 mc_writeobj_makesymbol_r;
static struct $B27 mc_writeobj_strtoaux_r;
static struct $B27 mc_writeobj_sectiontoaux_r;
static i64 mc_disasm_nmodules;
static i64 mc_disasm_xfchsmask_pd;
static struct $B31 mc_disasm_opnames = {{
(u64)"add",
(u64)"or",
(u64)"adc",
(u64)"sbb",
(u64)"and",
(u64)"sub",
(u64)"xor",
(u64)"cmp"}};

static struct $B21 mc_disasm_condnames = {{
(u64)"o",
(u64)"no",
(u64)"b",
(u64)"ae",
(u64)"z",
(u64)"nz",
(u64)"be",
(u64)"a",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"l",
(u64)"ge",
(u64)"le",
(u64)"g"}};

static struct $B8 mc_disasm_addrmodenames = {{
(u64)"amreg",
(u64)"ammem",
(u64)"amrel"}};

static i64 mc_disasm_rex;
static i64 mc_disasm_addrmode;
static i64 mc_disasm_rmreg;
static i64 mc_disasm_rmopc;
static i64 mc_disasm_ripmode;
static i64 mc_disasm_basereg;
static i64 mc_disasm_indexreg;
static i64 mc_disasm_scale;
static i64 mc_disasm_opsize;
static i64 mc_disasm_offset;
static i64 mc_disasm_offsetsize;
static i64 mc_disasm_sizeoverride;
static i64 mc_disasm_addroverride;
static i64 mc_disasm_f2override;
static i64 mc_disasm_f3override;
static struct $B16 mc_disasm_deststr;
static u64 mc_disasm_destptr;
static u64 mc_disasm_codeptr;
static struct $B16 mc_disasm_decodeinstr_str;
// Istatic skipped:mc_disasm.strreg.regnames8

// Istatic skipped:mc_disasm.strreg.regnames16

// Istatic skipped:mc_disasm.strreg.regnames32

// Istatic skipped:mc_disasm.strreg.regnames64

// Istatic skipped:mc_disasm.strreg.mregnames8

// Istatic skipped:mc_disasm.strreg.mregnames16

// Istatic skipped:mc_disasm.strreg.mregnames32

// Istatic skipped:mc_disasm.strreg.mregnames64

// Istatic skipped:mc_disasm.strfreg.xxfregnames

static struct $B5 mc_disasm_printaddrmode_str;
static struct $B17 mc_disasm_strxmm_str;
static struct $B17 mc_disasm_strmmx_str;
static struct $B22 mx_decls_mcxdirnames = {{
(u64)"pad_dir",
(u64)"version_dir",
(u64)"code_dir",
(u64)"idata_dir",
(u64)"zdata_dir",
(u64)"reloc_dir",
(u64)"dlls_dir",
(u64)"libs_dir",
(u64)"importsymbols_dir",
(u64)"exportsymbols_dir",
(u64)"exportsegs_dir",
(u64)"exportoffsets_dir",
(u64)"entry_dir",
(u64)"end_dir"}};

static struct $B12 mx_decls_mcxrelocnames = {{
(u64)"no_rel",
(u64)"locabs32",
(u64)"locabs64",
(u64)"impabs32",
(u64)"impabs64",
(u64)"imprel32"}};

static struct $B30 mx_decls_dllnametable;
static struct $B30 mx_decls_dllinsttable;
static i64 mx_decls_ndlllibs;
static struct $B30 mx_decls_libnametable;
static struct $B30 mx_decls_libtable;
static struct $B54 mx_decls_librelocated;
static struct $B54 mx_decls_libinitdone;
static i64 mx_decls_nlibs;
static struct $B55 mx_decls_symbolnametable;
static struct $B56 mx_decls_symboldefined;
static struct $B55 mx_decls_symboladdress;
static struct $B57 mx_decls_symbollibindex;
static struct $B56 mx_decls_symboldllindex;
static i64 mx_decls_nsymbols;
static i64 mx_decls_nsymimports = 0;

static i64 mx_decls_nsymexports = 0;

static struct $B12 mx_lib_rsegmentnames = {{
(u64)"no_seg",
(u64)"code_rseg",
(u64)"idata_rseg",
(u64)"zdata_rseg",
(u64)"rodata_rseg",
(u64)"impdata_rseg"}};

static u64 mx_write_dest;
static u64 mx_write_entrypoint;
static struct $B58 cc_cli_passnames = {{
(u64)"load_pass",
(u64)"pp_pass",
(u64)"parse_pass",
(u64)"type_pass",
(u64)"pcl_pass",
(u64)"runpcl_pass",
(u64)"mcl_pass",
(u64)"asm_pass",
(u64)"mx_pass",
(u64)"obj_pass",
(u64)"dll_pass",
(u64)"exe_pass",
(u64)"run_pass"}};

static struct $B58 cc_cli_extnames = {{
(u64)"",
(u64)"i",
(u64)"",
(u64)"",
(u64)"pcl",
(u64)"(int)",
(u64)"asm",
(u64)"asm",
(u64)"mx",
(u64)"obj",
(u64)"dll",
(u64)"exe",
(u64)"(run)"}};

static u8 cc_cli_cc_pass;
static struct $B54 cc_cli_dummy;
static u8 cc_cli_debugmode;
static u64 cc_cli_outfile;
static u64 cc_cli_outext = (u64)"exe";

static i64 cc_cli_cmdskip;
static i64 cc_cli_ttt;
static u8 cc_cli_fverbose = 1;

static u8 cc_cli_fshowincludes = 0;

static u8 cc_cli_dointheaders = 1;

static u8 cc_cli_highmem = 1;

static u8 cc_cli_fshowst;
static u8 cc_cli_fshowstflat;
static u8 cc_cli_fshowast;
static u8 cc_cli_fshowpcl;
static u8 cc_cli_fshowpst;
static u8 cc_cli_fshowmcl;
static u8 cc_cli_fshowss;
static u8 cc_cli_fshowtypes;
static u8 cc_cli_fshowfiles;
static u8 cc_cli_fshowpaths;
static u8 cc_cli_fshowheaders;
static u8 cc_cli_fwriteheaders;
static u8 cc_cli_fshowlog;
static u8 cc_cli_fshowtiming;
static u8 cc_cli_fgendll;
static u8 cc_cli_fstdout;
static u8 cc_cli_fshortnames;
static u8 cc_cli_fwriteerrors = 1;

static u64 cc_cli_entrypointname;
static struct $B59 cc_cli_optionnames = {{
(u64)"load",
(u64)"e",
(u64)"ei",
(u64)"parse",
(u64)"type",
(u64)"p",
(u64)"pi",
(u64)"i",
(u64)"mcl",
(u64)"s",
(u64)"a",
(u64)"c",
(u64)"obj",
(u64)"mx",
(u64)"dll",
(u64)"exe",
(u64)"r",
(u64)"noregs",
(u64)"nopeep",
(u64)"no",
(u64)"noconst",
(u64)"paths",
(u64)"headers",
(u64)"incl",
(u64)"includes",
(u64)"showst",
(u64)"showstflat",
(u64)"showast",
(u64)"showpcl",
(u64)"showpst",
(u64)"showmcl",
(u64)"showss",
(u64)"showtypes",
(u64)"showfiles",
(u64)"time",
(u64)"time2",
(u64)"v",
(u64)"vv",
(u64)"q",
(u64)"cs",
(u64)"ss",
(u64)"h",
(u64)"help",
(u64)"ext",
(u64)"writeheaders",
(u64)"o",
(u64)"stdout",
(u64)"shortnames",
(u64)"norip",
(u64)"himem",
(u64)"options",
(u64)"showil",
(u64)"long64"}};

static struct $B59 cc_cli_optvars = {{
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&pc_decls_fregoptim,
(u64)&pc_decls_fpeephole,
0,
(u64)&pc_decls_fnoconst,
(u64)&cc_cli_fshowpaths,
(u64)&cc_cli_fshowheaders,
0,
(u64)&cc_cli_fshowincludes,
(u64)&cc_cli_fshowst,
(u64)&cc_cli_fshowstflat,
(u64)&cc_cli_fshowast,
(u64)&cc_cli_fshowpcl,
(u64)&cc_cli_fshowpst,
(u64)&cc_cli_fshowmcl,
(u64)&cc_cli_fshowss,
(u64)&cc_cli_fshowtypes,
(u64)&cc_cli_fshowfiles,
(u64)&cc_cli_fshowtiming,
(u64)&cc_cli_fshowtiming,
(u64)&cc_cli_fverbose,
(u64)&cc_cli_fverbose,
(u64)&cc_cli_fverbose,
(u64)&pc_decls_pverbose,
(u64)&pc_decls_pverbose,
0,
0,
(u64)&cc_cli_dointheaders,
(u64)&cc_cli_fwriteheaders,
0,
(u64)&cc_cli_fstdout,
(u64)&cc_cli_fshortnames,
(u64)&cc_cli_highmem,
(u64)&cc_cli_highmem,
0,
(u64)&pc_decls_fshowil,
(u64)&pc_decls_flong64}};

static struct $B60 cc_cli_optvalues = {{
1,
2,
2,
3,
4,
5,
5,
6,
7,
8,
8,
10,
10,
9,
11,
12,
13,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
3,
0,
1,
2,
0,
0,
0,
1,
0,
1,
1,
0,
2,
0,
1,
1}};

static i64 cc_cli_totallines = 0;

static i64 cc_cli_nstringobjects = 0;

static i64 cc_cli_startclock;
static i64 cc_cli_loadtime;
static i64 cc_cli_parsetime;
static i64 cc_cli_pcltime;
static i64 cc_cli_compiletime;
static i64 cc_cli_inittime;
// Istatic skipped:cc_cli.showextrainfo.infotext

static i64 cc_decls_ntypes;
static struct $B61 cc_decls_ttnamedef;
static struct $B62 cc_decls_ttbasetype;
static struct $B61 cc_decls_ttlength;
static struct $B63 cc_decls_ttconst;
static struct $B62 cc_decls_tttarget;
static struct $B62 cc_decls_ttreftype;
static struct $B62 cc_decls_ttconsttype;
static struct $B61 cc_decls_ttsize;
static struct $B63 cc_decls_ttisref;
static struct $B63 cc_decls_ttisblock;
static struct $B63 cc_decls_ttsigned;
static struct $B64 cc_decls_ttshared;
static struct $B61 cc_decls_ttparams;
static struct $B61 cc_decls_tttypedef;
static i64 cc_decls_trefchar;
static i64 cc_decls_trefwchar;
static u64 cc_decls_inputfile;
static i64 cc_decls_mainfileno;
static struct $B65 cc_decls_libfiles;
static struct $B65 cc_decls_sourcefilenames;
static struct $B65 cc_decls_sourcefilepaths;
static struct $B65 cc_decls_sourcefiletext;
static struct $B66 cc_decls_sourcefilesizes;
static i64 cc_decls_nsourcefiles;
static i64 cc_decls_nlibfiles;
static struct $B30 cc_decls_searchdirs;
static i64 cc_decls_nsearchdirs = 0;

static struct $B30 cc_decls_includepaths;
static i64 cc_decls_nincludepaths = 0;

static u64 cc_decls_stprogram;
static u64 cc_decls_stmodule;
static u64 cc_decls_logdev;
static u64 cc_decls_nullunit;
static i64 cc_decls_clineno = 0;

static i64 cc_decls_cfileno = 0;

static struct $B17 cc_decls_lx;
static struct $B17 cc_decls_nextlx;
static i64 cc_decls_debug = 0;

static i64 cc_decls_hstsize = 65536;

static i64 cc_decls_hstmask;
static u64 cc_decls_hashtable;
static struct $B67 cc_decls_blockowner;
static struct $B67 cc_decls_blockcounts;
static struct $B68 cc_decls_blockstack;
static i64 cc_decls_currblockno;
static i64 cc_decls_nextblockno;
static i64 cc_decls_blocklevel;
static u64 cc_decls_currproc;
static u64 cc_decls_dheaderfile = 0;

static i64 cc_decls_structpadding = 1;

static i64 cc_decls_callbackflag = 0;

static i64 cc_decls_slineno;
static i64 cc_decls_sfileno;
static u64 cc_decls_oemname = (u64)"MCC";

static u64 cc_decls_mclstr;
static i64 cc_decls_mclstrlen;
static i64 cc_decls_nunits;
static struct $B69 cc_decls_pmodulelist;
static struct $B70 cc_decls_pheaderlist;
static struct $B70 cc_decls_pliblist;
static i64 cc_decls_npmodules;
static i64 cc_decls_npheaders;
static i64 cc_decls_nplibs;
static u8 cc_decls_pci_target;
static struct $B71 cc_tables_stdtypenames = {{
(u64)"void",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"bool",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"r32",
(u64)"r64",
(u64)"enum",
(u64)"ref",
(u64)"proc",
(u64)"label",
(u64)"block",
(u64)"array",
(u64)"struct",
(u64)"union",
(u64)"notset",
(u64)"tlast"}};

static struct $B72 cc_tables_stdtypewidths = {{
2048,
8208,
2112,
4104,
16416,
16416,
16384,
16448,
0,
0,
0}};

static struct $B72 cc_tables_stdsigned = {{
256,
257,
1,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B72 cc_tables_stdpcl = {{
1792,
2312,
778,
1027,
1541,
513,
1545,
0,
2827,
2827,
0}};

static struct $B72 cc_tables_stdsize = {{
256,
1026,
264,
513,
2052,
2052,
0,
0,
0,
0,
0}};

static struct $B73 cc_tables_catnames = {{
(u64)"voidcat",
(u64)"intcat",
(u64)"realcat",
(u64)"shortcat",
(u64)"blockcat"}};

static struct $B74 cc_tables_typespecnames = {{
(u64)"ts_void",
(u64)"ts_char",
(u64)"ts_short",
(u64)"ts_long",
(u64)"ts_int",
(u64)"ts_float",
(u64)"ts_double",
(u64)"ts_signed",
(u64)"ts_unsigned",
(u64)"ts_bool",
(u64)"ts_user",
(u64)"ts_struct",
(u64)"ts_union",
(u64)"ts_enum",
(u64)"ts_atomic"}};

static struct $B75 cc_tables_typespectypes = {{
0,
1,
0,
0,
3,
10,
11,
0,
0,
5,
0,
0,
0,
0,
0}};

static struct $B76 cc_tables_typespecsizes = {{
0,
1,
2,
4,
4,
4,
8,
0,
0,
1,
0,
0,
0,
4,
0}};

static struct $B17 cc_tables_pmflagnames = {{
(u64)"pm_normal",
(u64)"pm_notset",
(u64)"pm_empty",
(u64)"pm_variadic"}};

static struct $B73 cc_tables_scopenames = {{
(u64)"-",
(u64)"Fn",
(u64)"Loc",
(u64)"Imp",
(u64)"Exp"}};

static struct $B12 cc_tables_cccnames = {{
(u64)"open_cc",
(u64)"own_cc",
(u64)"clang_cc",
(u64)"stdcall_cc",
(u64)"callback_cc",
(u64)"dummy_cc"}};

static struct $B12 cc_tables_linkagenames = {{
(u64)"none_ss",
(u64)"static_ss",
(u64)"auto_ss",
(u64)"register_ss",
(u64)"extern_ss",
(u64)"typedef_ss"}};

static struct $B17 cc_tables_typequalnames = {{
(u64)"const_qual",
(u64)"volatile_qual",
(u64)"restrict_qual",
(u64)"atomic_qual"}};

static struct $B8 cc_tables_fnspecnames = {{
(u64)"inline_fnspec",
(u64)"noreturn_fnspec",
(u64)"callback_fnspec"}};

static struct $B77 cc_tables_jtagnames = {{
(u64)"jnone",
(u64)"jconst",
(u64)"jnull",
(u64)"jname",
(u64)"jwidenmem",
(u64)"jfuncname",
(u64)"jblock",
(u64)"jtempdecl",
(u64)"jdecl",
(u64)"jreturn",
(u64)"jreturnx",
(u64)"jassign",
(u64)"jif",
(u64)"jfor",
(u64)"jwhile",
(u64)"jdowhile",
(u64)"jgoto",
(u64)"jlabelstmt",
(u64)"jcasestmt",
(u64)"jdefaultstmt",
(u64)"jbreak",
(u64)"jcontinue",
(u64)"jswitch",
(u64)"jbreaksw",
(u64)"&& andl",
(u64)"|| orl",
(u64)"! notl",
(u64)"jistruel",
(u64)"jmakelist",
(u64)"jexprlist",
(u64)"jcallfn",
(u64)"jifx",
(u64)"&&",
(u64)"==",
(u64)"!=",
(u64)"<",
(u64)"<=",
(u64)">",
(u64)">=",
(u64)"+ add",
(u64)"- sub",
(u64)"* mul",
(u64)"/ div",
(u64)"% mod",
(u64)"& iand",
(u64)"| ior",
(u64)"^ ixor",
(u64)"<<",
(u64)">>",
(u64)"jdot",
(u64)"jidot",
(u64)"jindex",
(u64)"ptr",
(u64)"addptr",
(u64)"subptr",
(u64)"addrof &",
(u64)"jconvert",
(u64)"jscale",
(u64)"- neg",
(u64)"abs",
(u64)"~ inot",
(u64)"+=",
(u64)"-=",
(u64)"*=",
(u64)"/=",
(u64)"%=",
(u64)"&=",
(u64)"|=",
(u64)"^=",
(u64)"<<=",
(u64)">>=",
(u64)"++ preincr",
(u64)"-- preincr",
(u64)"++ postincr",
(u64)"-- postdecr",
(u64)"setjmp",
(u64)"longjmp",
(u64)"jdummy"}};

static struct $B78 cc_tables_symbolnames = {{
(u64)"errorsym",
(u64)"dotsym",
(u64)"idotsym",
(u64)"lexhashsym",
(u64)"hashsym",
(u64)"lithashsym",
(u64)"hashhashsym",
(u64)"commasym",
(u64)"semisym",
(u64)"colonsym",
(u64)"assignsym",
(u64)"assignsym2",
(u64)"lbracksym",
(u64)"rbracksym",
(u64)"lsqsym",
(u64)"rsqsym",
(u64)"lcurlysym",
(u64)"rcurlysym",
(u64)"questionsym",
(u64)"curlsym",
(u64)"ellipsissym",
(u64)"backslashsym",
(u64)"addsym",
(u64)"subsym",
(u64)"mulsym",
(u64)"divsym",
(u64)"remsym",
(u64)"iorsym",
(u64)"iandsym",
(u64)"ixorsym",
(u64)"orlsym",
(u64)"andlsym",
(u64)"shlsym",
(u64)"shrsym",
(u64)"inotsym",
(u64)"notlsym",
(u64)"incrsym",
(u64)"decrsym",
(u64)"abssym",
(u64)"eqsym",
(u64)"nesym",
(u64)"ltsym",
(u64)"lesym",
(u64)"gesym",
(u64)"gtsym",
(u64)"addtosym",
(u64)"subtosym",
(u64)"multosym",
(u64)"divtosym",
(u64)"remtosym",
(u64)"iortosym",
(u64)"iandtosym",
(u64)"ixortosym",
(u64)"shltosym",
(u64)"shrtosym",
(u64)"eolsym",
(u64)"eofsym",
(u64)"rawnumbersym",
(u64)"intconstsym",
(u64)"realconstsym",
(u64)"charconstsym",
(u64)"wcharconstsym",
(u64)"stringconstsym",
(u64)"wstringconstsym",
(u64)"whitespacesym",
(u64)"placeholdersym",
(u64)"namesym",
(u64)"ksourcedirsym",
(u64)"predefmacrosym",
(u64)"kdeclspecsym",
(u64)"ktypespecsym",
(u64)"kifsym",
(u64)"kelsesym",
(u64)"kcasesym",
(u64)"kdefaultsym",
(u64)"kforsym",
(u64)"kwhilesym",
(u64)"kdosym",
(u64)"kreturnsym",
(u64)"kbreaksym",
(u64)"kcontinuesym",
(u64)"kgotosym",
(u64)"kswitchsym",
(u64)"kstructsym",
(u64)"kunionsym",
(u64)"klinkagesym",
(u64)"ktypequalsym",
(u64)"kstdtypesym",
(u64)"kfnspecsym",
(u64)"kalignassym",
(u64)"kenumsym",
(u64)"ksizeofsym",
(u64)"kdefinedsym",
(u64)"kgenericsym",
(u64)"kalignofsym",
(u64)"ksetjmpsym",
(u64)"kshowmodesym",
(u64)"kshowtypesym",
(u64)"kdummysym"}};

static struct $B78 cc_tables_shortsymbolnames = {{
(u64)"",
(u64)".",
(u64)"->",
(u64)"#",
(u64)"#",
(u64)"#",
(u64)"##",
(u64)",",
(u64)";",
(u64)":",
(u64)"=",
(u64)":=",
(u64)"(",
(u64)")",
(u64)"[",
(u64)"]",
(u64)"{",
(u64)"}",
(u64)"?",
(u64)"~",
(u64)"...",
(u64)"\\",
(u64)"+",
(u64)"-",
(u64)"*",
(u64)"/",
(u64)"%",
(u64)"|",
(u64)"&",
(u64)"^",
(u64)"||",
(u64)"&&",
(u64)"<<",
(u64)">>",
(u64)"~",
(u64)"!",
(u64)"++",
(u64)"--",
(u64)"abs",
(u64)"==",
(u64)"!=",
(u64)"<",
(u64)"<=",
(u64)">=",
(u64)">",
(u64)"+=",
(u64)"-=",
(u64)"*=",
(u64)"/=",
(u64)"%=",
(u64)"|=",
(u64)"&=",
(u64)"^=",
(u64)"<<=",
(u64)">>=",
(u64)"",
(u64)"",
(u64)"n",
(u64)"n",
(u64)"n",
(u64)"s",
(u64)"s",
(u64)"s",
(u64)"s",
(u64)"w",
(u64)"",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)""}};

static struct $B79 cc_tables_symboltojtag = {{
0,
49,
50,
0,
0,
0,
0,
0,
0,
0,
11,
11,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
39,
40,
41,
42,
43,
45,
44,
46,
25,
24,
47,
48,
60,
26,
71,
72,
59,
33,
34,
35,
36,
38,
37,
61,
62,
63,
64,
65,
67,
66,
68,
69,
70,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B74 cc_tables_sourcedirnames = {{
(u64)"definedir",
(u64)"emitdir",
(u64)"ifdir",
(u64)"elifdir",
(u64)"elsedir",
(u64)"endifdir",
(u64)"includedir",
(u64)"ifdefdir",
(u64)"ifndefdir",
(u64)"undefdir",
(u64)"errordir",
(u64)"messagedir",
(u64)"blankdir",
(u64)"linedir",
(u64)"pragmadir"}};

static struct $B73 cc_tables_namespacenames = {{
(u64)"ns_none",
(u64)"ns_general",
(u64)"ns_tags",
(u64)"ns_labels",
(u64)"ns_fields"}};

static struct $B74 cc_tables_namenames = {{
(u64)"nullid",
(u64)"macroid",
(u64)"programid",
(u64)"moduleid",
(u64)"extmoduleid",
(u64)"typeid",
(u64)"procid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"fieldid",
(u64)"enumid",
(u64)"enumtagid",
(u64)"structtagid",
(u64)"labelid"}};

static struct $B75 cc_tables_namespaces = {{
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
4,
1,
2,
2,
3}};

static struct $B76 cc_tables_name2pid = {{
0,
0,
0,
0,
0,
0,
2,
3,
4,
5,
0,
0,
0,
0,
6}};

static struct $B80 cc_tables_stnames = {{
(u64)"if",
(u64)"else",
(u64)"case",
(u64)"default",
(u64)"for",
(u64)"do",
(u64)"while",
(u64)"return",
(u64)"break",
(u64)"continue",
(u64)"goto",
(u64)"switch",
(u64)"struct",
(u64)"union",
(u64)"include",
(u64)"define",
(u64)"elif",
(u64)"ifdef",
(u64)"ifndef",
(u64)"endif",
(u64)"undef",
(u64)"error",
(u64)"pragma",
(u64)"line",
(u64)"auto",
(u64)"register",
(u64)"static",
(u64)"extern",
(u64)"typedef",
(u64)"const",
(u64)"volatile",
(u64)"restrict",
(u64)"_Atomic",
(u64)"inline",
(u64)"_Noreturn",
(u64)"_Alignas",
(u64)"enum",
(u64)"void",
(u64)"char",
(u64)"short",
(u64)"long",
(u64)"int",
(u64)"float",
(u64)"double",
(u64)"signed",
(u64)"unsigned",
(u64)"_Bool",
(u64)"__DATE__",
(u64)"__FILE__",
(u64)"__LINE__",
(u64)"__TIME__",
(u64)"__MCC__",
(u64)"__MCCI__",
(u64)"__func__",
(u64)"__FUNCTION__",
(u64)"__declspec",
(u64)"sizeof",
(u64)"lengthof",
(u64)"defined",
(u64)"_Generic",
(u64)"_Alignof",
(u64)"$setjmp",
(u64)"$longjmp",
(u64)"$showmode",
(u64)"$showtype",
(u64)"$$dummy"}};

static struct $B81 cc_tables_stsymbols = {{
313532612680,
322122547274,
335007449164,
339302416461,
347892351056,
356482285650,
365072220244,
292057776196,
292057776196,
292057776196,
292057776196,
292057776196,
369367187542,
369367187542,
373662154838,
373662154839,
382252089431,
386547056729,
304942678107,
304942678087,
304942678087,
304942678087,
304942678087,
296352743495,
296352743493,
296352743493,
296352743493,
300647710789,
395136991324,
403726925917,
412316860511,
416611827808,
98}};

static struct $B81 cc_tables_stsubcodes = {{
12,
0,
0,
0,
0,
0,
0,
4294967303,
34359738372,
25769803785,
47244640266,
60129542159,
12884901890,
17179869185,
4294967301,
12884901890,
4294967300,
2,
4294967296,
12884901890,
21474836484,
30064771078,
38654705672,
4294967306,
17179869187,
30064771074,
21474836488,
5,
4294967296,
0,
322122547200,
76,
0}};

static struct $B22 cc_tables_convnames = {{
(u64)"no_conv",
(u64)"soft_c",
(u64)"hard_c",
(u64)"swiden_c",
(u64)"uwiden_c",
(u64)"sfloat_c",
(u64)"ufloat_c",
(u64)"sfix_c",
(u64)"ufix_c",
(u64)"fwiden_c",
(u64)"fnarrow_c",
(u64)"narrow_c",
(u64)"truncate_c",
(u64)"bool_c"}};

static struct $B42 cc_tables_dominantmode;
static struct $B16 cc_tables_conversionops;
static struct $B82 cc_tables_dominantsetuptable = {{
1,
1,
3,
1,
2,
3,
1,
3,
3,
1,
4,
4,
1,
5,
3,
1,
6,
3,
1,
7,
3,
1,
8,
3,
1,
9,
4,
1,
10,
10,
1,
11,
11,
2,
1,
3,
2,
2,
3,
2,
3,
3,
2,
4,
4,
2,
5,
3,
2,
6,
3,
2,
7,
3,
2,
8,
3,
2,
9,
4,
2,
10,
10,
2,
11,
11,
3,
1,
3,
3,
2,
3,
3,
3,
3,
3,
4,
4,
3,
5,
3,
3,
6,
3,
3,
7,
3,
3,
8,
8,
3,
9,
4,
3,
10,
10,
3,
11,
11,
4,
1,
4,
4,
2,
4,
4,
3,
4,
4,
4,
4,
4,
5,
4,
4,
6,
4,
4,
7,
4,
4,
8,
4,
4,
9,
9,
4,
10,
10,
4,
11,
11,
5,
1,
3,
5,
2,
3,
5,
3,
3,
5,
4,
4,
5,
5,
8,
5,
6,
8,
5,
7,
8,
5,
8,
8,
5,
9,
9,
5,
10,
10,
5,
11,
11,
6,
1,
3,
6,
2,
3,
6,
3,
3,
6,
4,
4,
6,
5,
0,
6,
6,
8,
6,
7,
8,
6,
8,
8,
6,
9,
9,
6,
10,
10,
6,
11,
11,
7,
1,
3,
7,
2,
3,
7,
3,
3,
7,
4,
4,
7,
5,
8,
7,
6,
8,
7,
7,
8,
7,
8,
8,
7,
9,
9,
7,
10,
10,
7,
11,
11,
8,
1,
3,
8,
2,
3,
8,
3,
8,
8,
4,
4,
8,
5,
8,
8,
6,
8,
8,
7,
8,
8,
8,
8,
8,
9,
9,
8,
10,
10,
8,
11,
11,
9,
1,
9,
9,
2,
9,
9,
3,
9,
9,
4,
9,
9,
5,
9,
9,
6,
9,
9,
7,
9,
9,
8,
9,
9,
9,
9,
9,
10,
10,
9,
11,
11,
10,
1,
11,
10,
2,
11,
10,
3,
11,
10,
4,
11,
10,
5,
11,
10,
6,
11,
10,
7,
11,
10,
8,
11,
10,
9,
11,
10,
10,
10,
10,
11,
11,
11,
1,
11,
11,
2,
11,
11,
3,
11,
11,
4,
11,
11,
5,
11,
11,
6,
11,
11,
7,
11,
11,
8,
11,
11,
9,
11,
11,
10,
11,
11,
11,
11}};

static struct $B82 cc_tables_convsetuptable = {{
1,
1,
3,
1,
2,
3,
1,
3,
3,
1,
4,
3,
1,
5,
13,
1,
6,
1,
1,
7,
3,
1,
8,
3,
1,
9,
3,
1,
10,
5,
1,
11,
5,
2,
1,
12,
2,
2,
0,
2,
3,
3,
2,
4,
3,
2,
5,
13,
2,
6,
12,
2,
7,
1,
2,
8,
3,
2,
9,
3,
2,
10,
5,
2,
11,
5,
3,
1,
12,
3,
2,
12,
3,
3,
0,
3,
4,
3,
3,
5,
13,
3,
6,
12,
3,
7,
12,
3,
8,
1,
3,
9,
3,
3,
10,
5,
3,
11,
5,
4,
1,
12,
4,
2,
12,
4,
3,
12,
4,
4,
0,
4,
5,
13,
4,
6,
12,
4,
7,
12,
4,
8,
12,
4,
9,
1,
4,
10,
5,
4,
11,
5,
5,
1,
1,
5,
2,
4,
5,
3,
4,
5,
4,
4,
5,
5,
0,
5,
6,
1,
5,
7,
4,
5,
8,
4,
5,
9,
4,
5,
10,
6,
5,
11,
6,
6,
1,
1,
6,
2,
4,
6,
3,
4,
6,
4,
4,
6,
5,
13,
6,
6,
1,
6,
7,
4,
6,
8,
4,
6,
9,
4,
6,
10,
6,
6,
11,
6,
7,
1,
12,
7,
2,
1,
7,
3,
4,
7,
4,
4,
7,
5,
13,
7,
6,
12,
7,
7,
0,
7,
8,
4,
7,
9,
4,
7,
10,
6,
7,
11,
6,
8,
1,
12,
8,
2,
12,
8,
3,
1,
8,
4,
4,
8,
5,
13,
8,
6,
12,
8,
7,
12,
8,
8,
0,
8,
9,
4,
8,
10,
6,
8,
11,
6,
9,
1,
12,
9,
2,
12,
9,
3,
12,
9,
4,
1,
9,
5,
13,
9,
6,
12,
9,
7,
12,
9,
8,
12,
9,
9,
0,
9,
10,
6,
9,
11,
6,
10,
1,
7,
10,
2,
7,
10,
3,
7,
10,
4,
7,
10,
5,
8,
10,
6,
8,
10,
7,
8,
10,
8,
8,
10,
9,
8,
10,
10,
0,
10,
11,
9,
11,
1,
7,
11,
2,
7,
11,
3,
7,
11,
4,
7,
11,
5,
8,
11,
6,
8,
11,
7,
8,
11,
8,
8,
11,
9,
8,
11,
10,
10,
11,
11,
0}};

static struct $B84 cc_tables_badexprs = {{
1,
3,
31,
24,
25,
26,
27,
29,
32,
33,
34,
35,
36,
38,
37,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
58,
59,
60}};

static u64 cc_lex_tkptr = 0;

static i64 cc_lex_dowhitespace = 0;

static i64 cc_lex_nincludes;
static struct $B17 cc_lex_normaltkx;
static u64 cc_lex_normaltk = (u64)&cc_lex_normaltkx;

static i64 cc_lex_noexpand = 0;

static struct $B85 cc_lex_lx_stack;
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel = 0;

static struct $B30 cc_lex_headerpathlist;
static struct $B15 cc_lex_headerpath;
static u64 cc_lex_lxstart;
static u64 cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static u64 cc_lex_lxsvalue;
static struct $B16 cc_lex_alphamap;
static struct $B16 cc_lex_digitmap;
static struct $B16 cc_lex_commentmap;
static struct $B16 cc_lex_linecommentmap;
static struct $B16 cc_lex_spacemap;
static u64 cc_lex_destcopy;
static struct $B86 cc_lex_pastedtokenlist;
static i64 cc_lex_npastedtokens = 0;

static i64 cc_lex_isincludefile = 0;

static i64 cc_lex_firstsymbol = 1;

static u64 cc_lex_reallxsptr;
static i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static struct $B3 cc_lex_lex_preprocess_only_sbuffer;
// Istatic skipped:cc_lex.lex_preprocess_only.dest

static struct $B15 cc_lex_getsourcefile_filespec;
// Istatic skipped:cc_lex.lexm.doreset

static i64 cc_lex_lasttoken = 0;

static struct $B3 cc_lex_showtoken_buffer;
// Istatic skipped:cc_lex.showtoken.dest

static struct $B3 cc_lex_stringify_buffer;
// Istatic skipped:cc_lex.stringify.deststr

// Istatic skipped:cc_lex.expandpredefmacro.monthnames

// Istatic skipped:cc_lex.issimpleconstmacro.specialnames

static u64 cc_parse_ist_symptr;
static struct $B31 cc_parse_looptypestack;
static i64 cc_parse_loopindex;
static struct $B20 cc_parse_casevaluestack;
static u8 cc_parse_ingeneric = 0;

static i64 cc_genpcl_retindex;
static i64 cc_genpcl_initstaticsindex;
static struct $B87 cc_genpcl_loopstack;
static i64 cc_genpcl_loopindex;
static struct $B31 cc_genpcl_zero_unit;
static u64 cc_genpcl_pzero = (u64)&cc_genpcl_zero_unit;

static i64 cc_genpcl_nvarlocals;
static i64 cc_genpcl_nvarparams;
static struct $B20 cc_blockpcl_continuestack;
static struct $B20 cc_blockpcl_breakstack;
static i64 cc_blockpcl_loopindex;
static u64 cc_blockpcl_sw_labeltable;
static u64 cc_blockpcl_sw_valuetable;
static i64 cc_blockpcl_sw_lower;
static i64 cc_blockpcl_sw_ncases;
static u8 cc_blockpcl_sw_defaultseen;
static i64 cc_blockpcl_sw_defaultlabel;
static i64 cc_blockpcl_sw_breaklabel;
static i64 cc_lib_autotypeno = 0;

static i64 cc_lib_nextafindex = 0;

static u64 cc_lib_unitheapptr = 0;

static i64 cc_lib_remainingunits = 0;

static struct $B88 cc_lib_getoptocode_opctotable;
static struct $B17 cc_lib_nextautotype_str;
static struct $B54 cc_lib_getopcjname_str;
static struct $B89 cc_lib_strmode_str;
static struct $B89 cc_lib_strmode2_str;
static struct $B15 cc_lib_typename_str;
static struct $B16 cc_lib_getstname_name;
static u64 cc_support_bytemasks = -9205322385119247871;

static i64 cc_headers_builtinheaders = 1;

static u64 cc_headers_h_assert = (u64)"/* Header assert.h */\r\n\r\n//#define assert(x) 0\r\n#define assert(x)\r\n";

static u64 cc_headers_h_ctype = (u64)"/* Header ctype.h */\r\n\r\nint tolower(int);\r\nint toupper(int);\r\nint isalpha(int);\r\nint isdigit(int);\r\nint isspace(int);\r\nint isalnum(int);\r\nint isupper(int);\r\nint islower(int);\r\n\r\nint isxdigit(int);\r\nint iscntrl(int);\r\nint isgraph(int);\r\nint ispunct(int);\r\nint isprint(int);\r\nint __isascii(int);\r\n#define isascii __isascii\r\n\r\nint __toascii(int);\r\n#define toascii __toascii\r\n";

static u64 cc_headers_h_errno = (u64)"/* Header errno.h */\r\n\r\n#ifndef $errno\r\n#define $errno\r\n\r\nextern int* _errno(void);\r\n#define errno (*_errno())\r\n\r\n#define EPERM 1\r\n#define ENOENT 2\r\n#define ESRCH 3\r\n#define EINTR 4\r\n#define EIO 5\r\n#define ENXIO 6\r\n#define E2BIG 7\r\n#define ENOEXEC 8\r\n#define EBADF 9\r\n#define ECHILD 10\r\n#define EAGAIN 11\r\n#define ENOMEM 12\r\n#define EACCES 13\r\n#define EFAULT 14\r\n#define ENOTBLK 15\r\n#define EBUSY 16\r\n#define EEXIST 17\r\n#define EXDEV 18\r\n#define ENODEV 19\r\n#define ENOTDIR 20\r\n#define EISDIR 21\r\n#define EINVAL 22\r\n#define ENFILE 23\r\n#define EMFILE 24\r\n#define ENOTTY 25\r\n#define ETXTBSY 26\r\n#define EFBIG 27\r\n#define ENOSPC 28\r\n#define ESPIPE 29\r\n#define EROFS 30\r\n#define EMLINK 31\r\n#define EPIPE 32\r\n#define EDOM 33\r\n#define ERANGE 34\r\n#define ENOMSG 35\r\n#define EIDRM 36\r\n#define ECHRNG 37\r\n#define EL2NSYNC 38\r\n#define EL3HLT 39\r\n#define EL3RST 40\r\n#define ELNRNG 41\r\n#define EUNATCH 42\r\n#define ENOCSI 43\r\n#define EL2HLT 44\r\n#define EDEADLK 45\r\n#define ENOLCK 46\r\n#define EBADE 50\r\n#define EBADR 51\r\n#define EXFULL 52\r\n#define ENOANO 53\r\n#define EBADRQC 54\r\n#define EBADSLT 55\r\n#define EDEADLOCK 56\r\n#define EBFONT 57\r\n#define ENOSTR 60\r\n#define ENODATA 61\r\n#define ETIME 62\r\n#define ENOSR 63\r\n#define ENONET 64\r\n#define ENOPKG 65\r\n#define EREMOTE 66\r\n#define ENOLINK 67\r\n#define EADV 68\r\n#define ESRMNT 69\r\n#define ECOMM 70\r\n#define EPROTO 71\r\n#define EMULTIHOP 74\r\n#define ELBIN 75\r\n#define EOVERFLOW 76\r\n#define EBADMSG 77\r\n#define ENOTUNIQ 80\r\n#define EBADFD 81\r\n#define EREMCHG 82\r\n#define ELIBACC 83\r\n#define ELIBBAD 84\r\n#define ELIBSCN 85\r\n#define ELIBMAX 86\r\n#define ELIBEXEC 87\r\n#define ENOSYS 88\r\n#define ENMFILE 89\r\n#define ENOTEMPTY 90\r\n#define ENAMETOOLONG 91\r\n#define EILSEQ 92\r\n#define __ELASTERROR 2000\r\n\r\n#endif\r\n";

static u64 cc_headers_h_fenv = (u64)"/* Header fenv.h */\r\n\r\nint feclearexcept(int);\r\nint fetestexcept(int);\r\n\r\n#define FE_INVALID 1\r\n#define FE_DENORMAL 2\r\n#define FE_INEXACT 32\r\n#define FE_DIVBYZERO 4 \r\n#define FE_OVERFLOW 8\r\n#define FE_UNDERFLOW 16\r\n#define FE_STACKFAULT 64\r\n#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)\r\n";

static u64 cc_headers_h_float = (u64)"/* Header float.h */\r\n\r\n//#define DBL_MAX_10_EXP 308\r\n//#define DBL_MANT_DIG 53\r\n\r\n#define FLT_RADIX 2\r\n\r\n#define FLT_DIG 6\r\n#define FLT_MIN_EXP -125\r\n#define FLT_MIN 1.17549435E-38F // decimal constant\r\n#define FLT_MIN 0X1P-126F // hex constant\r\n#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant\r\n#define FLT_TRUE_MIN 0X1P-149F // hex constant\r\n#define FLT_HAS_SUBNORM 1\r\n#define FLT_MIN_10_EXP -37\r\n#define FLT_MAX_EXP +128\r\n#define FLT_MAX 3.40282347E+38F // decimal constant\r\n#define FLT_MAX 0X1.fffffeP127F // hex constant\r\n#define FLT_MAX_10_EXP +38\r\n#define FLT_EPSILON 1.19209290e-07F\r\n#define FLT_MANT_DIG 23\r\n\r\n#define DBL_MANT_DIG 53\r\n#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant\r\n//#define DBL_EPSILON 0X1P-52 // hex constant\r\n#define DBL_DECIMAL_DIG 17\r\n#define DBL_DIG 15\r\n#define DBL_MIN_EXP -1021\r\n#define DBL_MIN 2.2250738585072014E-308 // decimal constant\r\n//#define DBL_MIN 0X1P-1022 // hex constant\r\n#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant\r\n//#define DBL_TRUE_MIN 0X1P-1074 // hex constant\r\n#define DBL_HAS_SUBNORM 1\r\n#define DBL_MIN_10_EXP -307\r\n#define DBL_MAX_EXP +1024\r\n#define DBL_MAX 1.7976931348623157E+308 // decimal constant\r\n//#define DBL_MAX 0X1.fffffffffffffP1023 // h\r\n#define DBL_MAX_10_EXP +308\r\n\r\n#define LDBL_MIN DBL_MIN\r\n#define LDBL_MAX DBL_MAX\r\n#define LDBL_EPSILON 2.2204460492503131E-16\r\n#define LDBL_MANT_DIG 53\r\n#define LDBL_MIN_EXP -1021\r\n#define LDBL_MAX_EXP +1024\r\n\r\nint     _isnan(double);\r\n#define isnan _isnan\r\n";

static u64 cc_headers_h_inttypes = (u64)"/* Header inttypes.h */\r\n\r\n#include <stdint.h>\r\n\r\n/* fprintf macros for signed types */\r\n#define PRId8 \"d\"\r\n#define PRId16 \"d\"\r\n#define PRId32 \"d\"\r\n#define PRId64 \"I64d\"\r\n\r\n#define PRIdLEAST8 \"d\"\r\n#define PRIdLEAST16 \"d\"\r\n#define PRIdLEAST32 \"d\"\r\n#define PRIdLEAST64 \"I64d\"\r\n\r\n#define PRIdFAST8 \"d\"\r\n#define PRIdFAST16 \"d\"\r\n#define PRIdFAST32 \"d\"\r\n#define PRIdFAST64 \"I64d\"\r\n\r\n#define PRIdMAX \"I64d\"\r\n\r\n#define PRIi8 \"i\"\r\n#define PRIi16 \"i\"\r\n#define PRIi32 \"i\"\r\n#define PRIi64 \"I64i\"\r\n\r\n#define PRIiLEAST8 \"i\"\r\n#define PRIiLEAST16 \"i\"\r\n#define PRIiLEAST32 \"i\"\r\n#define PRIiLEAST64 \"I64i\"\r\n\r\n#define PRIiFAST8 \"i\"\r\n#define PRIiFAST16 \"i\"\r\n#define PRIiFAST32 \"i\"\r\n#define PRIiFAST64 \"I64i\"\r\n\r\n#define PRIiMAX \"I64i\"\r\n\r\n#define PRIo8 \"o\"\r\n#define PRIo16 \"o\"\r\n#define PRIo32 \"o\"\r\n#define PRIo64 \"I64o\"\r\n\r\n#define PRIoLEAST8 \"o\"\r\n#define PRIoLEAST16 \"o\"\r\n#define PRIoLEAST32 \"o\"\r\n#define PRIoLEAST64 \"I64o\"\r\n\r\n#define PRIoFAST8 \"o\"\r\n#define PRIoFAST16 \"o\"\r\n#define PRIoFAST32 \"o\"\r\n#define PRIoFAST64 \"I64o\"\r\n\r\n#define PRIoMAX \"I64o\"\r\n\r\n/* fprintf macros for unsigned types */\r\n#define PRIu8 \"u\"\r\n#define PRIu16 \"u\"\r\n#define PRIu32 \"u\"\r\n#define PRIu64 \"I64u\"\r\n\r\n\r\n#define PRIuLEAST8 \"u\"\r\n#define PRIuLEAST16 \"u\"\r\n#define PRIuLEAST32 \"u\"\r\n#define PRIuLEAST64 \"I64u\"\r\n\r\n#define PRIuFAST8 \"u\"\r\n#define PRIuFAST16 \"u\"\r\n#define PRIuFAST32 \"u\"\r\n#define PRIuFAST64 \"I64u\"\r\n\r\n#define PRIuMAX \"I64u\"\r\n\r\n#define PRIx8 \"x\"\r\n#define PRIx16 \"x\"\r\n#define PRIx32 \"x\"\r\n#define PRIx64 \"I64x\"\r\n\r\n#define PRIxLEAST8 \"x\"\r\n#define PRIxLEAST16 \"x\"\r\n#define PRIxLEAST32 \"x\"\r\n#define PRIxLEAST64 \"I64x\"\r\n\r\n#define PRIxFAST8 \"x\"\r\n#define PRIxFAST16 \"x\"\r\n#define PRIxFAST32 \"x\"\r\n#define PRIxFAST64 \"I64x\"\r\n\r\n#define PRIxMAX \"I64x\"\r\n\r\n#define PRIX8 \"X\"\r\n#define PRIX16 \"X\"\r\n#define PRIX32 \"X\"\r\n#define PRIX64 \"I64X\"\r\n\r\n#define PRIXLEAST8 \"X\"\r\n#define PRIXLEAST16 \"X\"\r\n#define PRIXLEAST32 \"X\"\r\n#define PRIXLEAST64 \"I64X\"\r\n\r\n#define PRIXFAST8 \"X\"\r\n#define PRIXFAST16 \"X\"\r\n#define PRIXFAST32 \"X\"\r\n#define PRIXFAST64 \"I64X\"\r\n\r\n#define PRIXMAX \"I64X\"\r\n\r\n";

static u64 cc_headers_h_stdint = (u64)"/* Header stdint.h */\r\n\r\n#ifndef $stdint\r\n#define $stdint\r\n\r\ntypedef signed char int8_t;\r\ntypedef short int16_t;\r\ntypedef int int32_t;\r\ntypedef long long int int64_t;\r\n\r\ntypedef unsigned char uint8_t;\r\ntypedef unsigned short uint16_t;\r\ntypedef unsigned int uint32_t;\r\ntypedef unsigned long long int uint64_t;\r\n\r\ntypedef long long int intptr_t;\r\ntypedef unsigned long long int uintptr_t;\r\ntypedef long long intmax_t;\r\ntypedef unsigned long long uintmax_t;\r\n\r\ntypedef char int_least8_t;\r\ntypedef unsigned char uint_least8_t;\r\ntypedef short int_least16_t;\r\ntypedef unsigned short uint_least16_t;\r\ntypedef int int_least32_t;\r\ntypedef unsigned int uint_least32_t;\r\ntypedef long long int_least64_t;\r\ntypedef unsigned long long uint_least64_t;\r\n\r\n#define INTMAX_C(a) (a##LL)\r\n#define UINTMAX_C(a) (a##ULL)\r\n\r\ntypedef char int_fast8_t;\r\ntypedef unsigned char uint_fast8_t;\r\ntypedef short int_fast16_t;\r\ntypedef unsigned short uint_fast16_t;\r\ntypedef int int_fast32_t;\r\ntypedef unsigned int uint_fast32_t;\r\ntypedef long long int_fast64_t;\r\ntypedef unsigned long long uint_fast64_t;\r\n\r\n\r\n#define INT8_MIN -128\r\n#define INT8_MAX 127\r\n#define INT16_MIN -32768\r\n#define INT16_MAX 32767\r\n#define INT32_MIN 0x80000000\r\n#define INT32_MAX 0x7FFFFFFF\r\n#define INT64_MIN 0x8000000000000000\r\n#define INT64_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define UINT8_MAX 255\r\n#define UINT16_MAX 65535\r\n#define UINT32_MAX 0xFFFFFFFF\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define INTPTR_MIN 0x8000000000000000\r\n#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF\r\n#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n#define SIZE_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define PTRDIFF_MIN 0x8000000000000000\r\n#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define WCHAR_MIN 0\r\n#define WCHAR_MAX 65535\r\n\r\n#define WINT_MIN 0\r\n#define WINT_MAX 65535\r\n\r\n#define UINT64_C(x) (x##ull)\r\n\r\n#endif\r\n";

static u64 cc_headers_h_limits = (u64)"/* Header limits.h */\n\n#define CHAR_BIT 8\n\n#define CHAR_MIN 0\n#define CHAR_MAX 255\n\n#define UCHAR_MIN 0\n#define UCHAR_MAX 255\n\n#define SCHAR_MIN -128\n#define SCHAR_MAX 127\n\n#define SHRT_MIN -32768\n#define SHRT_MAX 32767\n\n#define USHRT_MIN 0\n#define USHRT_MAX 65535\n\n#define INT_MIN -2147483648\n#define INT_MAX  2147483647\n\n#define UINT_MIN 0\n#define UINT_MAX 4294967295\n\n#define LONG_MIN -2147483648\n#define LONG_MAX  2147483647\n\n#define ULONG_MIN 0\n#define ULONG_MAX 4294967295\n\n#define LLONG_MIN -9223372036854775808LL\n#define LLONG_MAX  9223372036854775807LL\n\n#define ULLONG_MIN 0\n#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL\n\n#define SIZE_MAX ULLONG_MAX\n";

static u64 cc_headers_h_locale = (u64)"/* Header locale.h */\r\n\r\n#ifndef $locale\r\n#define $locale\r\n\r\n#define LC_ALL 0\r\n#define LC_COLLATE 1\r\n#define LC_CTYPE 2\r\n#define LC_MONETARY 3\r\n#define LC_NUMERIC 4\r\n#define LC_TIME 5\r\n\r\nstruct lconv {\r\n\tchar *decimal_point;\r\n\tchar *thousands_sep;\r\n\tchar *grouping;\r\n\tchar *int_curr_symbol;\r\n\tchar *currency_symbol;\r\n\tchar *mon_decimal_point;\r\n\tchar *mon_thousands_sep;\r\n\tchar *mon_grouping;\r\n\tchar *positive_sign;\r\n\tchar *negative_sign;\r\n\tchar int_frac_digits;\r\n\tchar frac_digits;\r\n\tchar p_cs_precedes;\r\n\tchar p_sep_by_space;\r\n\tchar n_cs_precedes;\r\n\tchar n_sep_by_space;\r\n\tchar p_sign_posn;\r\n\tchar n_sign_posn;\r\n};\r\nchar *setlocale(int category, const char *locale);\r\n\r\nstruct lconv *localeconv(void);\r\n\r\nchar * setlocale(int,const char *);\r\n#endif\r\n";

static u64 cc_headers_h__ansi = (u64)"/* Header _ansi.h */\r\n";

static u64 cc_headers_h_math = (u64)"/* Header math.h */\n\n#define HUGE_VAL 1.7976931348623156e+308\n\ndouble floor(double);\ndouble ceil(double);\ndouble sqrt(double);\ndouble sin(double);\ndouble cos(double);\ndouble tan(double);\ndouble fmod(double,double);\ndouble asin(double);\ndouble acos(double);\ndouble atan(double);\ndouble log(double);\ndouble log10(double);\ndouble exp(double);\ndouble modf(double,double*);\ndouble atan2(double,double);\ndouble pow(double,double);\ndouble fabs(double);\ndouble sinh(double);\ndouble cosh(double);\ndouble tanh(double);\ndouble frexp(double,int*);\ndouble ldexp(double,int);\nint isnan(double);\n\n#define ldexpl ldexp\n\nfloat sinf(float);\nfloat cosf(float);\nfloat tanf(float);\nfloat expf(float);\nfloat powf(float, float);\nfloat logf(float);\n\nfloat sqrtf(float);\nfloat acosf(float);\nfloat atan2f(float,float);\nfloat ceilf(float);\n\ndouble acosh (double);\nlong double acoshl(long double);\nlong double acoshl(long double);\nfloat acoshf(float);\n\ndouble asinh (double);\nlong double asinhl(long double);\nlong double sinhl(long double);\nfloat asinhf(float);\n\ndouble atanh(double);\nlong double atanhl(long double);\nfloat atanhf(float);\n\nlong double expm1l(long double);\ndouble expm1(double);\nfloat expm1f(float);\ndouble _expm1i(int);\n\ndouble cbrt(double);\nlong double cbrtl(long double);\nfloat cbrtf(float);\n\ndouble trunc(double x);\nlong double truncl(long double);\nfloat truncf(float);\n\ndouble round(double);\nfloat roundf(float);\nlong double roundl(long double);\ndouble _roundi(int);\n\nlong double fminl(long double,long double);\nfloat fminf(float ,float);\ndouble fmin(double,double);\n\n//float fabsf(float);\n#define fabsf fabs\n\ndouble lgamma (double);\nlong double lgammal(long double);\nfloat lgammaf(float);\n\nlong double tgammal(long double);\ndouble tgamma(double);\nfloat tgammaf(float);\n\ndouble log1p(double);\nlong double log1pl(long double);\nfloat log1pf(float);\n\nlong double log10l(long double);\nfloat log10f(float);\ndouble _log10i(int);\ndouble log10(double);\n\ndouble erf(double);\nlong double erfl(long double);\nfloat erff(float);\n\ndouble hypot (double, double);\ndouble _hypot(double,double);\nlong double hypotl(long double,long double);\nfloat hypotf(float,float);\n\ndouble nextafter (double, double);\nlong double nextafterl(long double,long double);\nfloat nextafterf(float,float);\n\ndouble nexttoward(double,long double);\nlong double nexttowardl(long double,long double);\nfloat nexttowardf(float,long double);\n\ndouble erfc(double);\nlong double erfcl(long double);\nfloat erfcf(float);\n\nint _finite(double);\n#define finite _finite\n\nfloat floorf(float);\n\ndouble _copysign(double,double);\n#define copysign _copysign\n\nlong double fmaxl(long double,long double);\ndouble fmax(double,double);\nfloat fmaxf(float,float);\nfloat fmodf(float,float);\n\n//long double exp2l(long double);\ndouble exp2(double);\nfloat exp2f(float);\n\n//double log2(double);\n#define log2(x) (log(x)*1.442695041)\n\n#define M_PI 3.1415926535897932384625433\n#define M_PI_2 (M_PI/2.0)\n#define M_2_PI 0.63661977236758134308\n\nint isinf(double);\n\nint _finite(double);\n\n#define isfinite _finite\n\nint isfinitef(float);\nint isfinitel(long double);\n\n";

static u64 cc_headers_h_setjmp = (u64)"/* Header setjmp.h */\n\n\n#ifndef $setjmphdr\n#define $setjmphdr 1\n\ntypedef int jmp_buf[128];\n\n//void $mcclongjmp(jmp_buf, int);\n//int $mccsetjmp(jmp_buf);\n\n#define setjmp $setjmp\n#define longjmp $longjmp\n\n#endif\n\n";

static u64 cc_headers_h_signal = (u64)"/* Header signal.h */\r\n\r\n#define SIGINT    2\r\n#define SIGILL    4\r\n#define SIGFPE    8\r\n#define SIGSEGV  11\r\n#define SIGTERM  15\r\n#define SIGBREAK 21\r\n#define SIGABRT  22\r\n\r\n#define SIG_DFL (void (*)(int))0\r\n#define SIG_IGN (void (*)(int))1\r\n#define SIG_SGE (void (*)(int))3\r\n#define SIG_ACK (void (*)(int))4\r\n\r\n#define SIG_ERR (void (*)(int))-1\r\n\r\nextern void (*signal(int, void (*)(int)))(int);\r\n\r\nextern int raise(int);\r\n\r\n\r\ntypedef int sig_atomic_t;\r\n";

static u64 cc_headers_h_stdarg = (u64)"/* Header stdarg.h */\n\n#ifndef $STDARG\n #define $STDARG\n\n//coded for x64 target as used by mcc (with first four params also on stack)\n\n typedef char *\tva_list;\n\n #if __MCCI__\n  #define va_start(ap,v) ap=((va_list)&v-8)\n  #define va_arg(ap,t) *(t*)((ap-=8)+8)\n  #define va_copy(dest,src) (dest=src)\n  #define va_end(ap)\t( ap = (va_list)0 )\n\n #else\n  #define va_start(ap,v) ap=((va_list)&v+8)\n  #define va_arg(ap,t) *(t*)((ap+=8)-8)\n  #define va_copy(dest,src) (dest=src)\n  #define va_end(ap)\t( ap = (va_list)0 )\n\n #endif\n\n#endif\n";

static u64 cc_headers_h_stdbool = (u64)"/* Header stdbool.h */\r\n\r\n#define bool unsigned char\r\n#define true 1\r\n#define false 0\r\n\r\n\r\n";

static u64 cc_headers_h_stddef = (u64)"/* Header stddef.h */\r\n\r\n#ifndef $stddef\r\n#define $stddef\r\n\r\ntypedef signed long long int ssize_t;\r\ntypedef unsigned long long int size_t;\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\n#define NULL ((void*)0)\r\n\r\n#define offsetof(a,b) (size_t) &( ((a*)0) -> b)\r\n\r\ntypedef long long int ptrdiff_t;\r\n\r\n#endif // stddef\r\n";

static u64 cc_headers_h_stdio = (u64)"/* Header stdio.h */\n\n#ifndef $stdio\n#define $stdio 1\n\n#define __attribute__(x)\n\n#ifndef $valist\n\ttypedef char* va_list;\n\t#define $valist\n#endif\n\n#include <stddef.h>\n\ntypedef long long int fpos_t;\n\n#define SEEK_SET 0\n#define SEEK_CUR 1\n#define SEEK_END 2\n\n#define\tSTDIN_FILENO\t0\n#define\tSTDOUT_FILENO\t1\n#define\tSTDERR_FILENO\t2\n\n#define EOF (-1)\n#define FILENAME_MAX 260\n\n#define L_tmpnam 10\n\ntypedef struct {\n\tchar *_ptr;\n\tint   _cnt;\n\tchar *_base;\n\tint   _flag;\n\tint   _file;\n\tint   _charbuf;\n\tint   _bufsiz;\n\tchar *_tmpfname;\n} FILE;\n\nextern char* __iob_func(void);\n\n#define stdin ((FILE*)(__iob_func()))\n#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))\n#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))\n\n#define _IOREAD 0x0001\n#define _IOWRT 0x0002\n\n#define _IOFBF 0x0000\n#define _IOLBF 0x0040\n#define _IONBF 0x0004\n\n#define _IOMYBUF 0x0008\n#define _IOEOF 0x0010\n#define _IOERR 0x0020\n#define _IOSTRG 0x0040\n#define _IORW 0x0080\n\n#define BUFSIZ 512\n\nFILE* fopen(const char*, const char*);\nint fclose(FILE*);\nlong ftell(FILE*);\n//long long int _ftelli64(FILE*);\nint fseek(FILE*,long,int);\nint _fseeki64(FILE*,long long int,int);\n\nsize_t fread(void*, size_t, size_t, FILE*);\nsize_t fwrite(const void*, size_t, size_t, FILE*);\nint remove(const char*);\nint rename(const char *,const char *);\nFILE* freopen(const char*, const char*, FILE*);\nFILE* _wfopen(const wchar_t*,const wchar_t *);\n\nint printf(const char*, ...);\nint sprintf(char*,const char*, ...);\nint fprintf(FILE*,const char*, ...);\nint sscanf(const char*, const char*, ...);\nint scanf(const char*, ...);\nint fscanf(FILE *,const char *, ...);\nint _snprintf(char *,size_t,const char*,...);\n#define snprintf _snprintf\nint _vsnprintf(char*, size_t, const char*, va_list);\nint vsnprintf(char*,size_t,const char*,va_list);\nint vsprintf(char*, const char*, va_list);\nint _wremove(const wchar_t*);\nint _wrename(const wchar_t*,const wchar_t*);\n\ntypedef char* va_list;\n\nint vfprintf(FILE*, const char*, va_list);\nint vprintf(const char*, va_list);\n\nint puts(const char*);\nchar* fgets(char*, int, FILE*);\nint fputs(const char*, FILE*);\nint fgetc(FILE*);\nint fputc(int, FILE*);\nint ungetc(int, FILE*);\nint getchar(void);\nint putchar(int);\nint fflush(FILE *);\nint getc(FILE *);\nint putc(int, FILE *);\n\nint feof(FILE*);\nint ferror(FILE*);\nvoid clearerr(FILE*);\n\nint fileno(FILE*);\nint _fileno(FILE*);\nint setvbuf(FILE*,char*,int,size_t);\nFILE* _popen(const char*, const char*);\nint _pclose(FILE*);\nint _unlink(const char *);\n#define unlink _unlink;\nFILE* _fdopen(int, const char *);\n#define fdopen _fdopen\nint fgetpos(FILE*, fpos_t*);\nint fsetpos(FILE*, const fpos_t*);\nvoid perror(char*);\nvoid setbuf(FILE*, char*);\n\nvoid rewind(FILE*);\n\nFILE* tmpfile(void);\n\nchar* tmpnam(char*);\nwchar_t getwc(FILE *);\n\nextern void* _wenviron;\n\n#endif\n\n";

static u64 cc_headers_h_stdlib = (u64)"/* Header stdlib.h */\n\n#ifndef $stdlib\n#define $stdlib 1\n\n#include <stddef.h>\n\n#define EXIT_FAILURE 1\n#define EXIT_SUCCESS 0\n\n#define RAND_MAX 32767\n\nvoid* malloc(size_t);\nvoid* realloc(void*, size_t);\nvoid* calloc(size_t, size_t);\n\nvoid free(void*);\n\nvoid exit(int);\n\nint system(const char*);\nint _wsystem(const wchar_t*);\n\nint abs(int);\nlong labs(long);\nlong long llabs(long);\nint rand(void);\nvoid srand(unsigned int);\nint atoi(const char*);\nlong atol(const char*);\nlong long atoll(const char*);\nlong long atoi64(const char*);\ndouble atof(const char *);\nint\tatexit(void (*)(void));\nchar *_itoa(int,char *,int);\n\n#define itoa _itoa\n\nvoid qsort(void*, size_t, size_t, int (*)(void*, void*));\n\ntypedef struct {\n\tlong long int quot;\n\tlong long int rem;\n} lldiv_t;\n\nlldiv_t lldiv(long long int, long long int);\n\nchar* getenv(const char*);\nwchar_t* _wgetenv(const wchar_t*);\nint _wputenv(const wchar_t*);\n\n\ndouble strtod(const char*, char**);\n\n//float strtof(const char *, char**);\n#define strtof strtod\n\nlong double strtold(const char*, char**);\nvoid abort(void);\nlong int strtol(const char*, char**, int);\n\nlong double strtold(const char *,char **);\n\nlong long int _strtoi64(const char *,char **,int);\n#define strtoll _strtoi64\n\nunsigned long long int _strtoui64(const char *,char **,int);\n\nunsigned long long int _strtoui64(const char*, char**, int);\n#define strtoull _strtoui64\nunsigned long strtoul(const char*, char**, int);\n\nsize_t _msize(void *);\n#define msize _msize\n\nvoid* bsearch(const void *,const void *, size_t, size_t,\n\t\tint (*_compar)(const void *,const void *));\n\n\nchar* _fullpath(char*, const char*, size_t);\n\n\n#endif\n";

static u64 cc_headers_h__syslist = (u64)"/* Header _syslist.h */\r\n";

static u64 cc_headers_h_string = (u64)"/* Header string.h */\n\n#include <stddef.h>\n\nvoid* memcpy(void*, const void*, size_t);\nvoid* memmove(const void*, const void*, size_t);\nvoid* memset(void*, int, size_t);\nint memcmp(const void*, const void*, size_t);\nvoid* memchr(const void *, int, size_t);\n\nsize_t strlen(const char*);\nchar* strcpy(char*, const char*);\nchar* strncpy(char*, const char*, size_t);\nchar* strcat(char*, const char*);\nint strcmp(const char*, const char*);\nint strncmp(const char*, const char*, size_t);\nchar* strchr(const char*, int);\nchar* strstr(const char*, const char*);\nchar* strrchr(const char*, int);\nint _stricmp(const char*, const char*);\n#define stricmp _stricmp\n#define strcasecmp _stricmp\n\n\n\nint _strnicmp(const char*, const char*, size_t);\n#define strnicmp _strnicmp\nchar* strncat(char*, const char*, size_t);\nchar* strtok(char*, const char*);\n\nsize_t strcspn(const char*, const char*);\nsize_t strspn(const char*, const char*);\nint strcoll(const char *, const char *);\n\nunsigned long strtoul(const char*, char**, int);\n\nchar* strerror(int);\nchar* strpbrk(const char*, const char*);\nsize_t strxfrm(char*, const char *, size_t);\n\nchar* _strupr(char*);\nchar* _strlwr(char*);\n#define strupr _strupr\n#define strlwr _strlwr\n\nchar*strnupr(char*,size_t);\nchar*strnlwr(char*,size_t);\nint strtrim(char*);\nchar*strrev(char*);\n\nchar* _strdup(const char*);\n#define strdup _strdup\n\nint _wcsicmp(const wchar_t *,const wchar_t *);\n\nwchar_t *wcspbrk(const wchar_t*,const wchar_t*);\n\nsize_t wcslen(const wchar_t*);\n";

static u64 cc_headers_h_time = (u64)"/* Header time.h */\r\n\r\n#ifndef $time\r\n#define $time\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long clock_t;\r\nclock_t clock(void);\r\n\r\n//typedef long time_t;\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\ntypedef long long int time_t;\r\n#endif\r\n\r\nstruct tm\r\n{\r\n  int\ttm_sec;\r\n  int\ttm_min;\r\n  int\ttm_hour;\r\n  int\ttm_mday;\r\n  int\ttm_mon;\r\n  int\ttm_year;\r\n  int\ttm_wday;\r\n  int\ttm_yday;\r\n  int\ttm_isdst;\r\n};\r\n\r\n//struct tm *localtime(time_t*);\r\nstruct tm* _localtime32(time_t*);\r\n#define localtime _localtime32\r\n\r\ntime_t _time64(time_t *_timer);\r\n#define time _time64\r\n\r\n#define CLOCKS_PER_SEC 1000\r\n\r\nstruct tm *gmtime(const time_t*);\r\nsize_t strftime(char *, size_t, const char *, const struct tm *);\r\ntime_t mktime(struct tm *);\r\ndouble difftime(time_t, time_t);\r\n\r\nchar* asctime(const struct tm*);\r\n//char* ctime(const time_t *_time);\r\nchar* _ctime64(const time_t *_time);\r\n#define ctime _ctime64\r\n\r\n#endif\r\n";

static u64 cc_headers_h_utime = (u64)"/* sys/utime.h header */\n\n#ifndef $utime\n#define $utime\n\nstruct _utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\n\nstruct utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\nstruct __utimbuf64 {\n  long long int actime;\n  long long int modtime;\n};\n\nint _utime64(const char *_Filename,struct __utimbuf64 *_Time);\n\nint utime(const char *_Filename,struct utimbuf *_Utimbuf) {\n  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);\n}\n\n#endif\n";

static u64 cc_headers_h_unistd = (u64)"/* unistd.h header */\r\n\r\nunsigned int _sleep(unsigned int);\r\n#define sleep _sleep\r\n\r\n#define alarm(x) {puts(\"ALARM\"); exit(1);}\r\n\r\nint _write(int,void*,unsigned int);\r\n#define write _write\r\n\r\nint _close(int);\r\n#define close _close\r\n";

static u64 cc_headers_h_safelib = (u64)"/* Header safelib.h */\r\n";

static u64 cc_headers_h_wchar = (u64)"/* Header wchar.h */\r\n\r\n#include <stddef.h>\r\n\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wint_t;\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\nsize_t wcslen(const wchar_t*);\r\nwchar_t* wcscpy(wchar_t*,const wchar_t*);\r\n//wchar_t* _wgetenv(constwchar_t*);\r\nwchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);\r\nwchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);\r\n\r\nwchar_t* wcschr(wchar_t*,wchar_t);\r\nwchar_t* wcsstr(const wchar_t*,const wchar_t*);\r\n\r\n\r\nint wcscmp(const wchar_t*,const wchar_t*);\r\ntypedef long _off_t;\r\n";

static u64 cc_headers_h_wctype = (u64)"/* Header wctype.h */\r\n";

static u64 cc_headers_h_systypes = (u64)"/* types.h */\r\n#ifndef $systypes\r\n#define $systypes 1\r\n\r\ntypedef long int off_t;\r\ntypedef long int ino_t;\r\ntypedef unsigned int dev_t;\r\n\r\ntypedef long long time_t;\r\n\r\n#endif\r\n";

static u64 cc_headers_h_sysstat = (u64)"/* stat.h */\r\n\r\n#ifndef $sysstat\r\n#define $sysstat\r\n\r\n#include <stddef.h>\r\n\r\nstruct _stat {\r\n\tunsigned int\tst_dev;\r\n\tunsigned short\tst_ino;\r\n\tunsigned short\tst_mode;\r\n\tshort\t\t\tst_nlink;\r\n\tshort\t\t\tst_uid;\r\n\tshort\t\t\tst_gid;\r\n\tunsigned long\tst_rdev;\r\n\tunsigned int\tst_size;\r\n\tunsigned long long int\tst_atime;\r\n\tunsigned long long int\tst_mtime;\r\n\tunsigned long long int\tst_ctime;\r\n};\r\n\r\n#define stat _stat\r\n#define _stati64 _stat\r\n\r\n#define _S_IFMT 0xF000\r\n#define _S_IFDIR 0x4000\r\n#define _S_IFCHR 0x2000\r\n#define _S_IFIFO 0x1000\r\n#define _S_IFREG 0x8000\r\n#define _S_IREAD 0x0100\r\n#define _S_IWRITE 0x0080\r\n#define _S_IEXEC 0x0040\r\n\r\n#define S_IFMT 0xF000\r\n#define S_IFDIR 0x4000\r\n#define S_IFCHR 0x2000\r\n#define S_IFIFO 0x1000\r\n#define S_IFREG 0x8000\r\n#define S_IREAD 0x0100\r\n#define S_IWRITE 0x0080\r\n#define S_IEXEC 0x0040\r\n\r\n#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)\r\n#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)\r\n#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)\r\n#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)\r\n\r\n\r\n#define\t_S_IRWXU\t(_S_IREAD | _S_IWRITE | _S_IEXEC)\r\n#define\t_S_IXUSR\t_S_IEXEC\r\n#define\t_S_IWUSR\t_S_IWRITE\r\n\r\n#define\tS_IRWXU\t\t_S_IRWXU\r\n#define\tS_IXUSR\t\t_S_IXUSR\r\n#define\tS_IWUSR\t\t_S_IWUSR\r\n#define\tS_IRUSR\t\t_S_IRUSR\r\n#define\t_S_IRUSR\t_S_IREAD\r\n\r\n#define S_IRGRP    (S_IRUSR >> 3)\r\n#define S_IWGRP    (S_IWUSR >> 3)\r\n#define S_IXGRP    (S_IXUSR >> 3)\r\n#define S_IRWXG    (S_IRWXU >> 3)\r\n\r\n#define S_IROTH    (S_IRGRP >> 3)\r\n#define S_IWOTH    (S_IWGRP >> 3)\r\n#define S_IXOTH    (S_IXGRP >> 3)\r\n#define S_IRWXO    (S_IRWXG >> 3)\r\n\r\n//#define\tS_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\r\n//#define\tS_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\r\n//#define\tS_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\r\n#define\tS_IFBLK\t0x3000\t/* Block: Is this ever set under w32? */\r\n#define\tS_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\r\n#define\tS_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\r\n\r\n\r\n\r\nint stat(const char *, struct stat*);\r\n\r\nint _fstati64(int, struct stat*);\r\n\r\nint fstat(int, struct stat *);\r\n#define _fstat fstat\r\n\r\nint _wstati64(const wchar_t,struct _stati64 *buffer);  \r\n\r\n\r\n\r\n#endif\r\n";

static u64 cc_headers_h_systimeb = (u64)"/* timeb.h */\r\n\r\n#ifndef $timeb\r\n#define $timeb\r\n\r\n#include <time.h>\r\n\r\nstruct _timeb {\r\n\ttime_t time;\r\n\tunsigned short millitm;\r\n\tshort timezone;\r\n\tshort dstflag;\r\n};\r\n#define timeb _timeb\r\n\r\nvoid _ftime64(struct _timeb*);\r\n#define _ftime _ftime64\r\n#define ftime _ftime64\r\n\r\n#endif\r\n";

static u64 cc_headers_h_sysutime = (u64)"/* sys/utime.h header */\n\n#ifndef $utime\n#define $utime\n\nstruct _utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\n\nstruct utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\nstruct __utimbuf64 {\n  long long int actime;\n  long long int modtime;\n};\n\nint _utime64(const char *_Filename,struct __utimbuf64 *_Time);\n\nint utime(const char *_Filename,struct utimbuf *_Utimbuf) {\n  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);\n}\n\n#endif\n";

static u64 cc_headers_h_memory = (u64)"#include <malloc.h>\r\n";

static u64 cc_headers_h_fcntl = (u64)"/* FCNTL.H */\r\n\r\nint _setmode(int,int);\r\n\r\n#ifndef _INC_FCNTL\r\n#define _INC_FCNTL\r\n\r\n#define _O_RDONLY 0x0000\r\n#define _O_WRONLY 0x0001\r\n#define _O_RDWR 0x0002\r\n#define _O_APPEND 0x0008\r\n#define _O_CREAT 0x0100\r\n#define _O_TRUNC 0x0200\r\n#define _O_EXCL 0x0400\r\n#define _O_TEXT 0x4000\r\n#define _O_BINARY 0x8000\r\n#define _O_WTEXT 0x10000\r\n#define _O_U16TEXT 0x20000\r\n#define _O_U8TEXT 0x40000\r\n#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)\r\n\r\n#define _O_RAW _O_BINARY\r\n#define _O_NOINHERIT 0x0080\r\n#define _O_TEMPORARY 0x0040\r\n#define _O_SHORT_LIVED 0x1000\r\n\r\n#define _O_SEQUENTIAL 0x0020\r\n#define _O_RANDOM 0x0010\r\n\r\n#if !defined(NO_OLDNAMES) || defined(_POSIX)\r\n#define O_RDONLY _O_RDONLY\r\n#define O_WRONLY _O_WRONLY\r\n#define O_RDWR _O_RDWR\r\n#define O_APPEND _O_APPEND\r\n#define O_CREAT _O_CREAT\r\n#define O_TRUNC _O_TRUNC\r\n#define O_EXCL _O_EXCL\r\n#define O_TEXT _O_TEXT\r\n#define O_BINARY _O_BINARY\r\n#define O_RAW _O_BINARY\r\n#define O_TEMPORARY _O_TEMPORARY\r\n#define O_NOINHERIT _O_NOINHERIT\r\n#define O_SEQUENTIAL _O_SEQUENTIAL\r\n#define O_RANDOM _O_RANDOM\r\n#define O_ACCMODE _O_ACCMODE\r\n#endif\r\n\r\n#endif\r\n";

static u64 cc_headers_h_io = (u64)"\r\n#ifndef $io\r\n#define $io\r\n\r\n#include <stdint.h>\r\n#include <wchar.h>\r\n#include <time.h>\r\n\r\n/* io.h */\r\n\r\n#define _A_NORMAL 0x00\r\n#define _A_RDONLY 0x01\r\n#define _A_HIDDEN 0x02\r\n#define _A_SYSTEM 0x04\r\n#define _A_SUBDIR 0x10\r\n#define _A_ARCH 0x20\r\n\r\n\r\n//#message \"IO included\"\r\nstruct _finddata_t {\r\n        unsigned    attrib;\r\n        time_t      time_create;\r\n        time_t      time_access;\r\n        time_t      time_write;\r\n        unsigned long    size;\r\n        char        name[260];\r\n};\r\n\r\nint _isatty(int);\r\n\r\nint _read(int, void*, unsigned int);\r\n#define read _read\r\n\r\nint _open(const char*, int, ...);\r\n#define open _open\r\n\r\nlong _lseek(int, long, int);\r\n#define lseek _lseek\r\n\r\nint _close(int);\r\n#define close _close\r\n\r\nintptr_t _get_osfhandle(int);\r\nint _open_osfhandle(intptr_t,int);\r\n\r\nint _setmode(int,int);\r\n#define setmode _setmode\r\n\r\nint _wchmod(const wchar_t*, int);\r\n\r\nint _chmod(const char *, int);\r\n#define chmod _chmod\r\n\r\nint _dup(int);\r\n#define dup _dup\r\n\r\nintptr_t _findfirst(const char*, struct _finddata_t*);\r\nint _findnext(intptr_t, struct _finddata_t*);\r\nint _findclose(intptr_t);\r\n\r\nint _access(const char*,int);\r\n#define access _access\r\n\r\nint _wunlink(const wchar_t*);\r\n\r\n\r\n#endif\r\n";

static u64 cc_headers_h_direct = (u64)"#ifndef $direct\r\n#define $direct\r\n\r\ntypedef struct {\r\n unsigned int total_clusters;\r\n unsigned int avail_clusters;\r\n unsigned int sectors_per_cluster;\r\n unsigned int bytes_per_sector;\r\n} diskfree_t;\r\n\r\nint chdir(const char *);\r\nchar* _getcwd(char *, int);\r\n#define getcwd _getcwd\r\nint _mkdir(const char *);\r\nint _rmdir(const char *);\r\nint _wrmdir(const wchar_t*);\r\nint _wmkdir(const wchar_t*);\r\n\r\n#define mkdir _mkdir\r\n#define rmdir _rmdir\r\n\r\nint _chdrive(int);\r\nchar* _getdcwd(int, char *, int);\r\nwchar_t* _wgetcwd(wchar_t*, int);\r\nint _wchdir(const wchar_t*);\r\nint _getdrive(void);\r\nint _chdir(const char*);\r\n#define chdir _chdir\r\n\r\nunsigned long _getdrives(void);\r\nunsigned int _getdiskfree(unsigned int, diskfree_t*);\r\n\r\n#endif\r\n\r\n";

static u64 cc_headers_h_process = (u64)"/* Header process.h */\r\n#ifndef $process\r\n#define $process\r\n\r\n#include <stdint.h>\r\n\r\n#define P_WAIT\t\t0\r\n#define P_NOWAIT\t1\r\n#define P_OVERLAY\t2\r\n#define P_DETACH\t4\r\n#define WAIT_CHILD 0\r\n#define _P_WAIT P_WAIT\r\n#define _P_NOWAIT P_NOWAIT\r\n#define _P_OVERLAY P_OVERLAY\r\n\r\nint _spawnvp(int, const char*, const char*const*);\r\n#define spawnvp _spawnvp\r\n\r\nvoid endthread(void);\r\nunsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);\r\nvoid _endthreadex(unsigned);\r\nint _cwait(int*, int, int);\r\n#define cwait _cwait\r\n//int _System(const char *cmd,int nCmdShow);\r\n\r\nintptr_t _execve(const char*, const char*const*, const char*const*);\r\n#define execve _execve\r\n\r\n//#define _WAIT_CHILD\t0\r\n//#endif\r\n#endif\r\n\r\n";

static u64 cc_headers_h_malloc = (u64)"#include <stddef.h>\n\nvoid* malloc(size_t);\nvoid* realloc(void *, size_t);\nvoid  free(void *);\nvoid *_alloca(size_t);\n\n#define alloca malloc\n";

static u64 cc_headers_h_conio = (u64)"/* conio.h */\r\n#include <stddef.h>\r\n#include <wchar.h>\r\n\r\nint _getch(void);\r\nint _kbhit(void);\r\nwint_t _getwch(void);\r\n\r\n#define getch _getch\r\n#define kbhit _kbhit\r\n\r\nint _putch(int);\r\nint _cprintf(char *, ...);\r\nint _getche(void);\r\nint _ungetch(int);\r\n\r\n#define putch _putch\r\n#define cprintf _cprintf\r\n#define getche _getche\r\n#define ungetch _ungetch\r\n";

static u64 cc_headers_h_winsock2 = (u64)"#ifndef _WINSOCK2_H\r\n#define _WINSOCK2_H\r\n\r\n#include <_mingw.h>\r\n#include <windows.h>\r\n\r\n#ifndef FD_SETSIZE\r\n#define FD_SETSIZE 64\r\n#endif\r\n\r\ntypedef unsigned int SOCKET;\r\n\r\ntypedef struct fd_set {\r\n  unsigned int   fd_count;\r\n  SOCKET  fd_array[FD_SETSIZE];\r\n} fd_set;\r\n\r\nextern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);\r\n\r\n#ifndef FD_CLR\r\n#define FD_CLR(fd,set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n    while (__i < ((fd_set *)(set))->fd_count-1) {\\\r\n        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\\\r\n        __i++;\\\r\n    }\\\r\n    ((fd_set*)(set))->fd_count--;\\\r\n    break;\\\r\n    }\\\r\n}\\\r\n} while (0)\r\n#endif\r\n\r\n#ifndef FD_SET\r\n/* this differs from the define in winsock.h and in cygwin sys/types.h */\r\n#define FD_SET(fd, set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n        break;\\\r\n    }\\\r\n}\\\r\nif (__i == ((fd_set *)(set))->fd_count) {\\\r\n    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\\\r\n        ((fd_set *)(set))->fd_array[__i] = (fd);\\\r\n        ((fd_set *)(set))->fd_count++;\\\r\n    }\\\r\n}\\\r\n} while(0)\r\n#endif\r\n\r\n#ifndef FD_ZERO\r\n#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)\r\n#endif\r\n\r\n#ifndef FD_ISSET\r\n#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))\r\n#endif\r\n\r\n#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */\r\n#define _TIMEVAL_DEFINED\r\nstruct timeval {\r\n    long tv_sec;\r\n    long tv_usec;\r\n};\r\n#endif\r\n\r\nstruct in_addr {\r\n    union {\r\n        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;\r\n        struct { unsigned short s_w1,s_w2; } S_un_w;\r\n        unsigned long S_addr;\r\n    } S_un;\r\n};\r\n#define s_addr  S_un.S_addr\r\n\r\nstruct sockaddr_in {\r\n    short sin_family;\r\n    unsigned short sin_port;\r\n    struct in_addr sin_addr;\r\n    char sin_zero[8];\r\n};\r\n\r\nstruct sockaddr {\r\n    unsigned short sa_family;\r\n    char sa_data[14];\r\n};\r\n\r\nstruct hostent {\r\n    char *h_name;\r\n    char **h_aliases;\r\n    short h_addrtype;\r\n    short h_length;\r\n    char **h_addr_list;\r\n};\r\n#define h_addr h_addr_list[0]\r\n\r\n#define WSADESCRIPTION_LEN  256\r\n#define WSASYS_STATUS_LEN   128\r\ntypedef struct WSAData {\r\n    WORD wVersion;\r\n    WORD wHighVersion;\r\n    char szDescription[WSADESCRIPTION_LEN+1];\r\n    char szSystemStatus[WSASYS_STATUS_LEN+1];\r\n    unsigned short iMaxSockets;\r\n    unsigned short iMaxUdpDg;\r\n    char *lpVendorInfo;\r\n} WSADATA;\r\ntypedef WSADATA *LPWSADATA;\r\n\r\n#define INVALID_SOCKET (SOCKET)(~0)\r\n#define SOCK_STREAM  1\r\n#define SO_REUSEADDR 4\r\n#define AF_INET 2\r\n#define MSG_PEEK 0x2\r\n#define INADDR_ANY (unsigned long)0x00000000\r\n#define INADDR_LOOPBACK 0x7f000001\r\n#define SOL_SOCKET 0xffff\r\n\r\n#define SD_RECEIVE  0x00\r\n#define SD_SEND     0x01\r\n#define SD_BOTH     0x02\r\n\r\n#define h_errno WSAGetLastError()\r\n\r\n#define WSABASEERR 10000\r\n#define TRY_AGAIN (WSABASEERR+1002)\r\n\r\nSOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);\r\nint __stdcall bind(SOCKET, const struct sockaddr *, int);\r\nint __stdcall closesocket(SOCKET);\r\nint __stdcall connect(SOCKET, const struct sockaddr *, int);\r\nstruct hostent *__stdcall gethostbyname(const char *);\r\nint __stdcall gethostname(char *, int);\r\nint __stdcall getpeername(SOCKET, struct sockaddr *, int *);\r\nint __stdcall getsockname(SOCKET, struct sockaddr *, int *);\r\nunsigned long __stdcall htonl(unsigned long);\r\nunsigned short __stdcall htons(unsigned short);\r\nint __stdcall listen(SOCKET, int);\r\nunsigned long __stdcall ntohl(unsigned long);\r\nunsigned short __stdcall ntohs(unsigned short);\r\nint __stdcall recv(SOCKET, char *, int, int);\r\nint __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);\r\nint __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);\r\nint __stdcall send(SOCKET, const char *, int, int);\r\nint __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);\r\nint __stdcall setsockopt(SOCKET, int, int, const char *, int);\r\nint __stdcall shutdown(SOCKET, int);\r\nint __stdcall WSACleanup(void);\r\nint __stdcall WSAGetLastError(void);\r\nint __stdcall WSAStartup(WORD, LPWSADATA);\r\n\r\nSOCKET __stdcall socket(int, int, int);\r\n\r\n#endif\r\n\r\n";

static u64 cc_headers_h__mingw = (u64)"/*\r\n * _mingw.h\r\n *\r\n *  This file is for TinyCC and not part of the Mingw32 package.\r\n *\r\n *  THIS SOFTWARE IS NOT COPYRIGHTED\r\n *\r\n *  This source code is offered for use in the public domain. You may\r\n *  use, modify or distribute it freely.\r\n *\r\n *  This code is distributed in the hope that it will be useful but\r\n *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY\r\n *  DISCLAIMED. This includes but is not limited to warranties of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n *\r\n */\r\n\r\n#ifndef __MINGW_H\r\n#define __MINGW_H\r\n\r\n/* some winapi files define these before including _mingw.h --> */\r\n#undef __cdecl\r\n#undef _X86_\r\n#undef WIN32\r\n/* <-- */\r\n\r\n#include <stddef.h>\r\n#include <stdarg.h>\r\n\r\n#define __int8 char\r\n#define __int16 short\r\n#define __int32 int\r\n#define __int64 long long\r\n#define _HAVE_INT64\r\n\r\n#define __cdecl\r\n#define __declspec(x) __attribute__((x))\r\n#define __unaligned __attribute__((packed))\r\n#define __fastcall __attribute__((fastcall))\r\n\r\n#define __MSVCRT__ 1\r\n#undef _MSVCRT_\r\n#define __MINGW_IMPORT extern __declspec(dllimport)\r\n#define __MINGW_ATTRIB_NORETURN\r\n#define __MINGW_ATTRIB_CONST\r\n#define __MINGW_ATTRIB_DEPRECATED\r\n#define __MINGW_ATTRIB_MALLOC\r\n#define __MINGW_ATTRIB_PURE\r\n#define __MINGW_ATTRIB_NONNULL(arg)\r\n#define __MINGW_NOTHROW\r\n#define __GNUC_VA_LIST\r\n\r\n#define _CRTIMP extern\r\n#define __CRT_INLINE extern __inline__\r\n\r\n#define _CRT_ALIGN(x) __attribute__((aligned(x)))\r\n#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))\r\n#define _CRT_PACKING 8\r\n#define __CRT_UNALIGNED\r\n#define _CONST_RETURN\r\n\r\n#ifndef _TRUNCATE\r\n#define _TRUNCATE ((size_t)-1)\r\n#endif\r\n\r\n#define __CRT_STRINGIZE(_Value) #_Value\r\n#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)\r\n#define __CRT_WIDE(_String) L ## _String\r\n#define _CRT_WIDE(_String) __CRT_WIDE(_String)\r\n\r\n#ifdef _WIN64\r\n#define __stdcall\r\n#define _AMD64_ 1\r\n#define __x86_64 1\r\n#define _M_X64 100 /* Visual Studio */\r\n#define _M_AMD64 100 /* Visual Studio */\r\n#define USE_MINGW_SETJMP_TWO_ARGS\r\n#define mingw_getsp tinyc_getbp\r\n#define __TRY__\r\n#else\r\n#define __stdcall __attribute__((__stdcall__))\r\n#define _X86_ 1\r\n#define _M_IX86 300 /* Visual Studio */\r\n#define WIN32 1\r\n#define _USE_32BIT_TIME_T\r\n#ifdef __arm__\r\n#define __TRY__\r\n#else\r\n#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);\r\n#endif\r\n#endif\r\n\r\n/* in stddef.h */\r\n#define _SIZE_T_DEFINED\r\n#define _SSIZE_T_DEFINED\r\n#define _PTRDIFF_T_DEFINED\r\n#define _WCHAR_T_DEFINED\r\n#define _UINTPTR_T_DEFINED\r\n#define _INTPTR_T_DEFINED\r\n#define _INTEGRAL_MAX_BITS 64\r\n\r\n#ifndef _TIME32_T_DEFINED\r\n#define _TIME32_T_DEFINED\r\ntypedef long __time32_t;\r\n#endif\r\n\r\n#ifndef _TIME64_T_DEFINED\r\n#define _TIME64_T_DEFINED\r\ntypedef long long __time64_t;\r\n#endif\r\n\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\n#ifdef _USE_32BIT_TIME_T\r\ntypedef __time32_t time_t;\r\n#else\r\ntypedef __time64_t time_t;\r\n#endif\r\n#endif\r\n\r\n#ifndef _WCTYPE_T_DEFINED\r\n#define _WCTYPE_T_DEFINED\r\ntypedef wchar_t wctype_t;\r\n#endif\r\n\r\n#ifndef _WINT_T\r\n#define _WINT_T\r\ntypedef short wint_t;\r\n#endif\r\n\r\ntypedef int errno_t;\r\n#define _ERRCODE_DEFINED\r\n\r\ntypedef struct threadlocaleinfostruct *pthreadlocinfo;\r\ntypedef struct threadmbcinfostruct *pthreadmbcinfo;\r\ntypedef struct localeinfo_struct _locale_tstruct,*_locale_t;\r\n\r\n/* for winapi */\r\n#define _ANONYMOUS_UNION\r\n#define _ANONYMOUS_STRUCT\r\n#define DECLSPEC_NORETURN\r\n#define DECLARE_STDCALL_P(type) __stdcall type\r\n#define NOSERVICE 1\r\n#define NOMCX 1\r\n#define NOIME 1\r\n#define __INTRIN_H_\r\n#ifndef DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME1\r\n#  define DUMMYUNIONNAME2\r\n#  define DUMMYUNIONNAME3\r\n#  define DUMMYUNIONNAME4\r\n#  define DUMMYUNIONNAME5\r\n#endif\r\n#ifndef DUMMYSTRUCTNAME\r\n#  define DUMMYSTRUCTNAME\r\n#endif\r\n#ifndef WINVER\r\n# define WINVER 0x0502\r\n#endif\r\n#ifndef _WIN32_WINNT\r\n# define _WIN32_WINNT 0x502\r\n#endif\r\n\r\n#define __C89_NAMELESS\r\n#define __MINGW_EXTENSION\r\n#define WINAPI_FAMILY_PARTITION(X) 1\r\n#define MINGW_HAS_SECURE_API\r\n\r\n#endif /* __MINGW_H */\r\n";

static u64 cc_headers_h_windowsx = (u64)"/* Header windowsx.h */\r\n\r\n#ifndef $windowsx\r\n#define $windowsx 1\r\n\r\n#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))\r\n#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))\r\n\r\n#endif // windowsx\r\n\r\n";

static struct $B6 cc_headers_stdhdrnames = {{
(u64)"assert.h",
(u64)"ctype.h",
(u64)"errno.h",
(u64)"fenv.h",
(u64)"float.h",
(u64)"inttypes.h",
(u64)"stdint.h",
(u64)"limits.h",
(u64)"locale.h",
(u64)"_ansi.h",
(u64)"math.h",
(u64)"setjmp.h",
(u64)"signal.h",
(u64)"stdarg.h",
(u64)"stdbool.h",
(u64)"stddef.h",
(u64)"stdio.h",
(u64)"stdlib.h",
(u64)"_syslist.h",
(u64)"string.h",
(u64)"time.h",
(u64)"utime.h",
(u64)"unistd.h",
(u64)"safelib.h",
(u64)"wchar.h",
(u64)"wctype.h",
(u64)"sys/types.h",
(u64)"sys/stat.h",
(u64)"sys/timeb.h",
(u64)"sys/utime.h",
(u64)"malloc.h",
(u64)"fcntl.h",
(u64)"io.h",
(u64)"direct.h",
(u64)"process.h",
(u64)"memory.h",
(u64)"conio.h",
(u64)"winsock2.h",
(u64)"_mingw.h",
(u64)"windowsx.h"}};

static struct $B6 cc_headers_stdhdrtext = {{
(u64)&cc_headers_h_assert,
(u64)&cc_headers_h_ctype,
(u64)&cc_headers_h_errno,
(u64)&cc_headers_h_fenv,
(u64)&cc_headers_h_float,
(u64)&cc_headers_h_inttypes,
(u64)&cc_headers_h_stdint,
(u64)&cc_headers_h_limits,
(u64)&cc_headers_h_locale,
(u64)&cc_headers_h__ansi,
(u64)&cc_headers_h_math,
(u64)&cc_headers_h_setjmp,
(u64)&cc_headers_h_signal,
(u64)&cc_headers_h_stdarg,
(u64)&cc_headers_h_stdbool,
(u64)&cc_headers_h_stddef,
(u64)&cc_headers_h_stdio,
(u64)&cc_headers_h_stdlib,
(u64)&cc_headers_h__syslist,
(u64)&cc_headers_h_string,
(u64)&cc_headers_h_time,
(u64)&cc_headers_h_utime,
(u64)&cc_headers_h_unistd,
(u64)&cc_headers_h_safelib,
(u64)&cc_headers_h_wchar,
(u64)&cc_headers_h_wctype,
(u64)&cc_headers_h_systypes,
(u64)&cc_headers_h_sysstat,
(u64)&cc_headers_h_systimeb,
(u64)&cc_headers_h_sysutime,
(u64)&cc_headers_h_malloc,
(u64)&cc_headers_h_fcntl,
(u64)&cc_headers_h_io,
(u64)&cc_headers_h_direct,
(u64)&cc_headers_h_process,
(u64)&cc_headers_h_memory,
(u64)&cc_headers_h_conio,
(u64)&cc_headers_h_winsock2,
(u64)&cc_headers_h__mingw,
(u64)&cc_headers_h_windowsx}};

static i64 cc_show_currfileno;
static i64 cc_show_currlineno;
static struct $B3 cc_show_sbuffer;
static u64 cc_show_dest = (u64)&cc_show_sbuffer;

static i64 cc_show_destlinestart;
static struct $B3 cc_show_exprstrvar;
static u64 cc_show_exprstr = (u64)&cc_show_exprstrvar;

static struct $B20 cc_show_getprefix_str;
static struct $B16 cc_show_getdottedname_str;
static struct $B73 cc_show_getlineinfok_str;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B73 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B73 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B93 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B17 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B54 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B93 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B93 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B93 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B93 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B93 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B93 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B93 str;
	struct $B93 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B20 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L447;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L446;
L447:
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L449;
	asu64(R1) = p;
	free(asu64(R1));
	goto L448;
L449:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L448:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L454;
	goto L452;
L454:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L455:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L459;
L458:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L459:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L458;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L455;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L461:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L465;
	asi64(R1) = i;
	k = asi64(R1);
	goto L463;
L465:
	i += 1; if (i <= 27) goto L461;
L463:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L468;
L466:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L470;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L469;
L470:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L468;
L469:
	i += 1; if (i <= av_1) goto L466;
L468:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L452:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L473;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L471;
L473:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L475;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L471;
L475:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L477;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L471;
L477:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L471;
L471:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L480;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L480:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L482;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L482:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L478;
L478:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L485;
	asi64(R1) = n;
	goto L484;
L485:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L484:
	goto L483;
L483:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L486;
L486:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L489;
	R1 = 0;
	goto L487;
L489:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L492;
	R1 = 0;
	goto L490;
L492:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L490;
L490:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L495;
	R1 = 0;
	goto L493;
L495:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L493;
L493:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L498;
	asu64(R1) = p;
	goto L496;
L498:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L496;
L496:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L501;
	asu64(R1) = p;
	goto L499;
L501:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L499;
L499:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L503;
L503:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L505;
L505:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L510;
	R1 = 0;
	goto L508;
L510:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L512;
	R1 = 0;
	goto L508;
L512:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L508;
L508:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L515;
	R1 = 0;
	goto L513;
L515:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L513;
L513:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L518;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L516;
L518:
	R1 = 0;
	goto L516;
L516:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L521;
	asu64(R1) = mlinux_os_getstdin();
	handlex = asu64(R1);
L521:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L523;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L524:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L527;
L528:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L527:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L530;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L530:
	goto L524;
L523:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L532;
	goto L519;
L532:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L534;
	goto L519;
L534:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L536;
L535:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L540;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L539;
L540:
	R1 = 1;
	crseen = asu8(R1);
L539:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L536:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L535;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L535;
L541:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L543;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L543;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L543:
L519:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L547;
L545:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L545;
L547:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L551;
L549:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L549;
L551:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L554;
L553:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L553;
	asu64(R1) = s0;
	goto L552;
L552:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L558;
L557:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L557;
	asu64(R1) = s0;
	goto L556;
L556:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B17 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L562;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L563;
	goto L564;
L562:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L561;
L563:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L561;
L564:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L561:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L566;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L567;
	goto L568;
L566:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L567:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L568:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L565:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L560;
L560:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L571;
	R1 = tou64("");
	goto L569;
L571:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L573;
L572:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L576;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L578;
	asi64(R1) = period;
	if (!asi64(R1)) goto L580;
	R1 = tou64(".");
	goto L579;
L580:
	R1 = tou64("");
L579:
	goto L569;
L578:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L569;
L576:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L573:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L572;
	R1 = tou64("");
	goto L569;
L569:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L583;
L582:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L586;
	goto L587;
L586:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L581;
	goto L585;
L587:
L585:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L583:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L582;
	R1 = tou64("");
	goto L581;
L581:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L590;
	asu64(R1) = s;
	goto L588;
L590:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L588;
L588:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L593;
	R1 = tou64("");
	goto L591;
L593:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L595;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L595:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L597;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L597:
	asu64(R1) = f;
	goto L591;
L591:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L600;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L598;
L600:
	asu64(R1) = s;
	goto L598;
L598:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L603;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L601;
L603:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L601;
L601:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L613;
	R1 = 1;
	goto L611;
L613:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L611;
L611:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L616;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L616:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L618;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L614;
L618:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L620;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L620:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L614:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L624;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L624:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L633;
L633:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B94 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L636;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L639;
L637:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L637;
L639:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L636:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B94 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L643;
	goto L641;
L643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L646;
L644:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L644;
L646:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L641:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L649;
	goto L647;
L649:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L651;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L650;
L651:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L650:
L647:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L653:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L655;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L657;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L657:
	goto L654;
L655:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L659;
	R1 = 0;
	goto L652;
L659:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L661;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L663;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L663:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L661:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L665;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L652;
L665:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L667;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L669;
	R2 = 0;
	goto L668;
L669:
	R2 = 1;
L668:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L671;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L671:
	asu64(R1) = q;
	if (!asu64(R1)) goto L673;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L673:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L675;
	R1 = 5;
	goto L674;
L675:
	R1 = 1;
L674:
	goto L652;
L667:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L677;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L679;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L679;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L679:
	goto L676;
L677:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L681;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L680;
L681:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L683;
	R1 = 5;
	goto L682;
L683:
	R1 = 3;
L682:
	goto L652;
L680:
L676:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L685;
	R1 = 5;
	goto L684;
L685:
	R1 = 2;
L684:
	goto L652;
L652:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L687:
L688:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L692;
	goto L693;
L691:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L690;
L692:
	R1 = 0;
	goto L686;
	goto L690;
L693:
	goto L689;
L690:
	goto L688;
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L695;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L695;
	goto L696;
L695:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L697:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L699;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L700;
	goto L701;
L699:
	goto L687;
	goto L697;
L700:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L686;
	goto L697;
L701:
	goto L697;
	goto L694;
L696:
L694:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L703;
	goto L704;
L703:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L705:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L709;
	goto L710;
L708:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L707;
L709:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L712;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L712:
	goto L706;
	goto L707;
L710:
L707:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L705;
L706:
	goto L702;
L704:
	asu64(R1) = p;
	pstart = asu64(R1);
L713:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L717;
	goto L718;
L716:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L714;
	goto L715;
L717:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L714;
	goto L715;
L718:
L715:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L713;
L714:
L702:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L720;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L720:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L686;
L686:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L724;
L722:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L722;
L724:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L725;
L725:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L726;
L726:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L729;
	R1 = -1;
	goto L728;
L729:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L730;
	R1 = 1;
	goto L728;
L730:
	R1 = 0;
L728:
	goto L727;
L727:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L733;
	R1 = -1;
	goto L732;
L733:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L734;
	R1 = 1;
	goto L732;
L734:
	R1 = 0;
L732:
	goto L731;
L731:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L735;
L735:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L738;
	R1 = -1;
	goto L737;
L738:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L739;
	R1 = 1;
	goto L737;
L739:
	R1 = 0;
L737:
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L740;
L740:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L743;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L742;
L743:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L742:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L744;
L744:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L745;
L745:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L749;
	R1 = 0;
	goto L747;
L749:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L751:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L751;
	asr64(R1) = x;
	goto L750;
L750:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L754;
L754:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L755;
L755:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L759;
L757:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L761;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L756;
L761:
	i += 1; if (i <= av_1) goto L757;
L759:
	R1 = 0;
	goto L756;
L756:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L764;
	asi64(R1) = n;
	goto L762;
L764:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L762;
L762:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L767;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L767:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L769;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L769:
	asu64(R1) = p;
	goto L765;
L765:
	return asu64(R1);
}

static void mlinux_os_init() {
    u64 R1; 
	R1 = 1;
	mlinux_init_flag = asi64(R1);
	return;
}

static i64 mlinux_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1; 
	asu64(R1) = cmdline;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L771;
L771:
	return asi64(R1);
}

static i64 mlinux_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1; 
	asu64(R1) = cmdline;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L772;
L772:
	return asi64(R1);
}

static i64 mlinux_os_getch() {
    u64 R1, R2, R3; struct $B75 R1_B75; 
	struct $B75 old;
	struct $B75 new;
	u8 ch;
	R1 = (u64)&old;
	R2 = 0;
	asi32(R1) = tcgetattr(asi32(R2), asu64(R1));
	(R1_B75) = old;
	new = (R1_B75);
	R1 = -3;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = -9;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = -2;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = (u64)&new;
	R2 = 0;
	R3 = 0;
	asi32(R1) = tcsetattr(asi32(R3), asi32(R2), asu64(R1));
	asi32(R1) = getchar();
	ch = asu8(R1);
	R1 = (u64)&old;
	R2 = 0;
	R3 = 0;
	asi32(R1) = tcsetattr(asi32(R3), asi32(R2), asu64(R1));
	asu8(R1) = ch;
	R1 = toi64(tou8(R1));
	goto L773;
L773:
	return asi64(R1);
}

static i64 mlinux_os_kbhit() {
    u64 R1; 
	R1 = tou64("kbhit");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L774;
L774:
	return asi64(R1);
}

static void mlinux_os_flushkeys() {
    u64 R1; 
	R1 = tou64("flushkeys");
	mlib_abortprogram(asu64(R1));
	return;
}

static u64 mlinux_os_getconsolein() {
    u64 R1; 
	R1 = 0;
	goto L776;
L776:
	return asu64(R1);
}

static u64 mlinux_os_getconsoleout() {
    u64 R1; 
	R1 = 0;
	goto L777;
L777:
	return asu64(R1);
}

static u64 mlinux_os_proginstance() {
    u64 R1; 
	R1 = tou64("PROGINST");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L778;
L778:
	return asu64(R1);
}

static u64 mlinux_os_getdllinst(u64 name) {
    u64 R1, R2; 
	u64 h;
	R1 = 1;
	asu64(R2) = name;
	asu64(R1) = dlopen(asu64(R2), asi32(R1));
	h = asu64(R1);
	asu64(R1) = h;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L781;
	R1 = tou64("msvcrt");
	asu64(R2) = name;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L783;
	R1 = 1;
	R2 = tou64("libc.so.6");
	asu64(R1) = dlopen(asu64(R2), asi32(R1));
	h = asu64(R1);
L783:
L781:
	asu64(R1) = h;
	goto L779;
L779:
	return asu64(R1);
}

static u64 mlinux_os_getdllprocaddr(i64 hlib, u64 name) {
    u64 R1, R2; 
	u64 fnaddr;
	asi64(R1) = hlib;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L786;
	R1 = 0;
	goto L784;
L786:
	asu64(R1) = name;
	asi64(R2) = hlib;
	asu64(R1) = dlsym(asu64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	goto L784;
L784:
	return asu64(R1);
}

static void mlinux_os_initwindows() {
	return;
}

static i64 mlinux_os_getchx() {
    u64 R1; 
	R1 = tou64("getchx");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L788;
L788:
	return asi64(R1);
}

static u64 mlinux_os_getos() {
    u64 R1; 
	R1 = tou64("L64");
	goto L789;
L789:
	return asu64(R1);
}

static i64 mlinux_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L790;
L790:
	return asi64(R1);
}

static i64 mlinux_os_iswindows() {
    u64 R1; 
	R1 = 0;
	goto L791;
L791:
	return asi64(R1);
}

static i64 mlinux_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	R1 = tou64("SHELL EXEC");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L792;
L792:
	return asi64(R1);
}

static void mlinux_os_sleep(i64 a) {
	return;
}

static u64 mlinux_os_getstdin() {
    u64 R1; 
	u64 pf;
	R1 = (u64)&stdin;
	pf = asu64(R1);
	asu64(R1) = pf;
	asu64(R1) = *tou64p(R1);
	goto L794;
L794:
	return asu64(R1);
}

static u64 mlinux_os_getstdout() {
    u64 R1; 
	u64 pf;
	R1 = (u64)&stdout;
	pf = asu64(R1);
	asu64(R1) = pf;
	asu64(R1) = *tou64p(R1);
	goto L795;
L795:
	return asu64(R1);
}

static u64 mlinux_os_gethostname() {
    u64 R1; 
	R1 = tou64("");
	goto L796;
L796:
	return asu64(R1);
}

static u64 mlinux_os_getmpath() {
    u64 R1; 
	R1 = tou64("");
	goto L797;
L797:
	return asu64(R1);
}

static void mlinux_os_exitprocess(i64 x) {
    u64 R1; 
	R1 = 0;
	exit(R1);
	return;
}

static i64 mlinux_os_clock() {
    u64 R1, R2; 
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L801;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L800;
L801:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
L800:
	goto L799;
L799:
	return asi64(R1);
}

static i64 mlinux_os_ticks() {
    u64 R1; 
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L802;
L802:
	return asi64(R1);
}

static i64 mlinux_os_getclockspersec() {
    u64 R1; 
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L805;
	R1 = 1000;
	goto L804;
L805:
	R1 = 1000000;
L804:
	goto L803;
L803:
	return asi64(R1);
}

static void mlinux_os_setmesshandler(u64 addr) {
    u64 R1; 
	R1 = tou64("SETMESSHANDLER");
	mlib_abortprogram(asu64(R1));
	return;
}

static i64 mlinux_os_hpcounter() {
    u64 R1; 
	R1 = 1;
	goto L807;
L807:
	return asi64(R1);
}

static i64 mlinux_os_hpfrequency() {
    u64 R1; 
	R1 = 1;
	goto L808;
L808:
	return asi64(R1);
}

static i64 mlinux_os_filelastwritetime(u64 filename) {
    u64 R1; 
	R1 = 0;
	goto L809;
L809:
	return asi64(R1);
}

static void mlinux_os_getsystime(u64 tm) {
    u64 R1, R2, R3; 
	struct $B3 tv;
	struct $B25 tmr;
	R1 = 0;
	R2 = (u64)&tv;
	asi32(R1) = gettimeofday(asu64(R2), asu64(R1));
	R1 = (u64)&tmr;
	R2 = (u64)&tv;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = gmtime_r(asu64(R2), asu64(R1));
	R1 = (u64)&tmr;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1900;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tv;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = tm;
	R3 = 28;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = tm;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mlinux_os_peek() {
	return;
}

static u64 mlinux_os_allocexecmem(i64 n) {
    u64 R1; 
	R1 = tou64("No allocexec");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L812;
L812:
	return asu64(R1);
}

static i64 mlinux_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1; 
	R1 = 0;
	goto L813;
L813:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L816;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L815;
L816:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L815:
	goto L814;
L814:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L819;
	R4 = 0;
	goto L818;
L819:
	R4 = 73;
L818:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L817;
L817:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L824;
	case 1: goto L825;
	case 2: goto L826;
	case 3: goto L827;
	case 4: goto L828;
	case 5: goto L829;
	case 6: goto L830;
	case 7: goto L823;
	case 8: goto L831;
	case 9: goto L832;
	case 10: goto L833;
	case 11: goto L834;
	case 12: goto L835;
	default: goto L823;
    };
// SWITCH
L824:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F1)R1)();
	goto L820;
	goto L821;
L825:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F2)R2)(asi64(R1));
	goto L820;
	goto L821;
L826:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F3)R3)(asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L827:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F4)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L828:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F5)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L829:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F6)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L830:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F7)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L831:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F8)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L832:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F9)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L833:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F10)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L834:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F11)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L835:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F12)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L823:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L821:
	R1 = 0;
	goto L820;
L820:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L838;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L839;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L840;
	goto L841;
L838:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F13)R1)();
	R1 = toi64(asr64(R1));
	goto L836;
	goto L837;
L839:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F14)R2)(asi64(R1));
	x = asr64(R1);
	goto L837;
L840:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F15)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L837;
L841:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L837:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L836;
L836:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

static u64 pc_api_pcl_start(u64 name, i64 nunits) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_pcldone;
	if (!asu8(R1)) goto L845;
	R1 = tou64("PCL start?");
	pc_api_pclerror(asu64(R1));
L845:
	asu64(R1) = name;
	if (!asu64(R1)) goto L847;
	R1 = 9;
	asu64(R2) = name;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	pc_decls_currprog = asu64(R1);
L847:
	asi64(R1) = pc_api_initpcalloc;
	pc_api_pcalloc = asi64(R1);
	asi64(R1) = nunits;
	if (!asi64(R1)) goto L849;
	asi64(R1) = nunits;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nunits = asi64(R1);
	goto L851;
L850:
	R1 = 2;
	R2 = (u64)&pc_api_pcalloc;
	*toi64p(R2) *= asi64(R1);
L851:
	asi64(R1) = pc_api_pcalloc;
	asi64(R2) = nunits;
	if (asi64(R1) < asi64(R2)) goto L850;
L849:
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pc_api_pcstart = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	asi64(R2) = pc_api_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	R1 = 0;
	pc_api_pcfixed = asu8(R1);
	R1 = 0;
	pc_api_pcseqno = asi64(R1);
	R1 = 0;
	pc_api_pcneedfntable = asi64(R1);
	R1 = 0;
	pc_api_mlabelno = asi64(R1);
	asu64(R1) = pc_decls_currprog;
	goto L843;
L843:
	return asu64(R1);
}

static void pc_api_pcl_end() {
    u64 R1, R2; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) < asu64(R2)) goto L855;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L855;
	R1 = 0;
	R2 = 136;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L855:
	R1 = 1;
	pc_decls_pcldone = asu8(R1);
	return;
}

static u64 pc_api_pcl_writepcl(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writeallpcl();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L858;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L860;
	msysc_m$print_startcon();
	R1 = tou64("Writing PCL");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L860:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L857;
L858:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L857:
	goto L856;
L856:
	return asu64(R1);
}

static u64 pc_api_pcl_writepst(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writepst();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L863;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L865;
	msysc_m$print_startcon();
	R1 = tou64("Writing PST");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L865:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L862;
L863:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L862:
	goto L861;
L861:
	return asu64(R1);
}

static void pc_api_pcl_genmcl() {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	return;
}

static void pc_api_pcl_genss(i64 obj) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_genss(asi64(R1));
	return;
}

static u64 pc_api_pcl_writess(u64 filename, i64 obj) {
    u64 R1, R2; 
	u64 ssstr;
	u64 f;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_genss(asi64(R1));
	asi64(R1) = obj;
	asi64(R1) = !asi64(R1);
	asu64(R1) = mc_writess_writessdata(asi64(R1));
	ssstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L870;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = ssstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = ssstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L869;
L870:
	asu64(R1) = ssstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L869:
	goto L868;
L868:
	return asu64(R1);
}

static u64 pc_api_pcl_writeasm(u64 filename, i64 atype) {
    u64 R1, R2; 
	u64 asmstr;
	u64 f;
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L873;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
L873:
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asu64(R1) = mc_writeasm_getassemstr();
	asmstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L875;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L877;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L877:
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = asmstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = asmstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L874;
L875:
	asu64(R1) = asmstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L874:
	goto L871;
L871:
	return asu64(R1);
}

static void pc_api_pcl_writeobj(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 1;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mlinux_os_clock();
	tt = asi64(R1);
	asu64(R1) = filename;
	mc_writeobj_writecoff(asu64(R1));
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_objtime = asi64(R1);
	return;
}

static void pc_api_pcl_writedll(u64 filename) {
    u64 R1, R2, R3; 
	i64 tt;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mlinux_os_clock();
	tt = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = filename;
	mc_writeexe_writeexe(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writeexe(u64 filename) {
    u64 R1, R2, R3; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mlinux_os_clock();
	tt = asi64(R1);
	R1 = 0;
	R2 = 0;
	asu64(R3) = filename;
	mc_writeexe_writeexe(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writemx(u64 filename) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asu64(R1) = filename;
	mx_write_writemcx(asu64(R1));
	return;
}

static void pc_api_pcl_exec() {
    u64 R1, R2; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	R2 = tou64("dummy");
	mx_run_runlibfile(asu64(R2), asi64(R1));
	return;
}

static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames) {
    u64 R1, R2; 
	asi64(R1) = highmem;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L885;
	asi64(R1) = highmem;
	pc_api_phighmem = asu8(R1);
L885:
	asi64(R1) = verbose;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L887;
	asi64(R1) = verbose;
	pc_decls_pverbose = asu8(R1);
L887:
	asi64(R1) = shortnames;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L889;
	asi64(R1) = shortnames;
	pc_api_fpshortnames = asu8(R1);
L889:
	return;
}

static void pc_api_extendpclblock() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	i64 lengthused;
	u64 newpcstart;
	asi64(R1) = pc_api_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	lengthused = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	asi64(R1) = lengthused;
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pc_api_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newpcalloc;
	asi64(R2) = lengthused;
	asi64(R1) -= asi64(R2);
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newpcstart;
	asi64(R3) = lengthused;
	R2 += (i64)R3*32;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = pc_api_pccurr;
	asu64(R3) = pc_api_pcstart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 32;
	R1 += (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	pc_api_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	pc_api_pcalloc = asi64(R1);
	return;
}

static u64 pc_api_newpcl() {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcend;
	if (asu64(R1) < asu64(R2)) goto L893;
	pc_api_extendpclblock();
L893:
	R1 = (u64)&pc_api_pccurr;
	(*tou64p(R1)) += 32;
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = pc_api_pccurr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc_api_pclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_decls_npcl;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc_api_pccurr;
	goto L891;
L891:
	return asu64(R1);
}

static void pc_api_pc_gen(i64 opcode, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L896;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L896:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genx(i64 opcode, i64 x, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L900;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L900:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L903;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L903:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L906;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L906:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cond;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 pc_api_genint(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L907;
L907:
	return asu64(R1);
}

static u64 pc_api_genreal(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L910;
	R1 = 5;
	goto L909;
L910:
	R1 = 6;
L909:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L908;
L908:
	return asu64(R1);
}

static u64 pc_api_genrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L913;
	R1 = 10;
	goto L912;
L913:
	R1 = 11;
L912:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L911;
L911:
	return asu64(R1);
}

static u64 pc_api_genstring(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L916;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
L916:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L914;
L914:
	return asu64(R1);
}

static u64 pc_api_genpcstrimm(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L917;
L917:
	return asu64(R1);
}

static u64 pc_api_genlabel(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L918;
L918:
	return asu64(R1);
}

static u64 pc_api_genmem(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L919;
L919:
	return asu64(R1);
}

static u64 pc_api_genmemaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L920;
L920:
	return asu64(R1);
}

static u64 pc_api_gendata(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 12;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L921;
L921:
	return asu64(R1);
}

static void pc_api_gencomment(u64 s) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L925;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L924;
L925:
	goto L922;
L924:
	asu64(R1) = s;
	asu64(R1) = pc_api_genpcstrimm(asu64(R1));
	R2 = 135;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L922:
	return;
}

static u64 pc_api_genname(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L926;
L926:
	return asu64(R1);
}

static u64 pc_api_gennameaddr(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L927;
L927:
	return asu64(R1);
}

static u64 pc_api_genassem(u64 code) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = code;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 9;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L928;
L928:
	return asu64(R1);
}

static u64 pc_api_strpmode(i64 mode, i64 size) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L931;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L932;
	goto L933;
L931:
	R1 = tou64("mem:");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = size;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_strpmode_str;
	goto L930;
L932:
	R1 = tou64("---");
	goto L930;
L933:
	R1 = (u64)&pc_tables_pstdnames;
	asi64(R2) = mode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L930:
	goto L929;
L929:
	return asu64(R1);
}

static void pc_api_pc_setmode(i64 m, i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L936;
	asi64(R1) = size;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L935;
L936:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L935:
	R1 = (u64)&pc_tables_pclhastype;
	asu64(R2) = pc_api_pccurr;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L938;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L938:
	return;
}

static void pc_api_pc_setmode2(i64 m) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void pc_api_pc_setxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setscaleoff(i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = scale;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_addoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	return;
}

static void pc_api_pc_setincr(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnargs(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnvariadics(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setalign(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_perror(u64 mess) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = mess;
	pc_api_perror_s(asu64(R2), asu64(R1));
	return;
}

static void pc_api_perror_s(u64 mess, u64 param) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = param;
	if (!asu64(R1)) goto L951;
	msysc_m$print_startcon();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L951:
	R1 = 1;
	exit(R1);
	return;
}

static u64 pc_api_getbasename(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L954;
L953:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L954:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) <= asu64(R2)) goto L956;
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L953;
L956:
	asu64(R1) = t;
	goto L952;
L952:
	return asu64(R1);
}

static void pc_api_pclerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addsymbol(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_psymboltable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L960;
	asu64(R1) = d;
	R2 = R1;
	pc_decls_psymboltablex = asu64(R2);
	pc_decls_psymboltable = asu64(R1);
	goto L959;
L960:
	asu64(R1) = d;
	asu64(R2) = pc_decls_psymboltablex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	pc_decls_psymboltablex = asu64(R1);
L959:
	return;
}

static u64 pc_api_pc_makesymbol(u64 s, i64 id) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = (u64)&pc_decls_npst;
	(*toi64p(R1)) += 1;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = id;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L963;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L964;
	goto L965;
L963:
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L962;
L964:
	R1 = 1;
	asu64(R2) = d;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	id = asi64(R1);
	goto L962;
L965:
L962:
	asi64(R1) = id;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L968;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L967;
L968:
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L966;
L967:
	asi64(R1) = id;
	if (!asi64(R1)) goto L969;
	asu64(R1) = d;
	pc_api_pc_addsymbol(asu64(R1));
L969:
L966:
	asu64(R1) = d;
	goto L961;
L961:
	return asu64(R1);
}

static u64 pc_api_getfullname(u64 d, i64 backtick) {
    u64 R1, R2, R3; 
	i64 n;
	u64 e;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	R2 = (u64)&pc_api_getfullname_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L972;
	R1 = tou64("`");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L972:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L974;
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L976;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L975;
L976:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L975:
	R1 = (u64)&pc_api_getfullname_str;
	goto L970;
L974:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L979;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L978;
L979:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_getfullname_str;
	goto L970;
L978:
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L981;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L980;
L981:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L980:
	goto L970;
L970:
	return asu64(R1);
}

static void pc_api_pcerrorstop(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addplib(u64 name) {
    u64 R1, R2, R3; 
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L985;
	R1 = tou64("Too many libs");
	pc_api_perror(asu64(R1));
L985:
	R1 = tou64("");
	asu64(R2) = name;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&pc_decls_plibfiles;
	R3 = (u64)&pc_decls_nplibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L988;
	R1 = tou64("Nested proc");
	pc_api_pclerror(asu64(R1));
L988:
	asu64(R1) = d;
	asu64(R1) = pc_api_genmem(asu64(R1));
	asi64(R2) = threaded;
	if (!asi64(R2)) goto L990;
	R2 = 121;
	goto L989;
L990:
	R2 = 120;
L989:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L992;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L992:
	R1 = 0;
	asi64(R2) = mode;
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L994;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl proc:");
	asu64(R1) = pc_api_addstr(asu64(R2), asu64(R1));
	pc_api_pclerror(asu64(R1));
L994:
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L996;
	asi64(R1) = isentry;
	if (!asi64(R1)) goto L996;
	asu64(R1) = d;
	pc_decls_entryproc = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 83;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L996:
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_setimport(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_addparam(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1000;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1000:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1002;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1001;
L1002:
	goto L1004;
L1003:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1004:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1003;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1001:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1007;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1007:
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	return;
}

static void pc_api_pc_addlocal(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1010;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1010:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1012;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1011;
L1012:
	goto L1014;
L1013:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1014:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1013;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1011:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1017;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1017:
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	return;
}

static void pc_api_pc_endproc() {
    u64 R1, R2; 
	asu64(R1) = pc_decls_currfunc;
	if (asu64(R1)) goto L1020;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1020:
	R1 = 0;
	R2 = 122;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_decls_currfunc = asu64(R1);
	return;
}

static u64 pc_api_addstr(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = t;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_addstr_str;
	goto L1021;
L1021:
	return asu64(R1);
}

static void pc_api_merror(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1024;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F16)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L1023;
L1024:
	R1 = 0;
	lineno = asi64(R1);
	R1 = tou64("?");
	filename = asu64(R1);
L1023:
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1026;
	msysc_m$print_startcon();
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1026:
	msysc_m$print_startcon();
	R1 = tou64("MCL Error: # (#) on Line: # in #, PCL:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pc_decls_ppseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	asu64(R2) = filename;
	pc_api_pcerrorstop(asu64(R2), asi64(R1));
	return;
}

static u64 pc_api_pc_duplpst(u64 d) {
    u64 R1, R2, R3; struct $B21 R1_B21; 
	u64 e;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	(R1_B21) = *(struct $B21*)(R1);
	asu64(R2) = e;
	*(struct $B21*)(R2) = (R1_B21);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = e;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L1027;
L1027:
	return asu64(R1);
}

static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip) {
    u64 R1; 
	asi64(R1) = cmdskip;
	pc_decls_pcmdskip = asi64(R1);
	return;
}

static i64 pc_api_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	asu64(R1) = t;
	t0 = asu64(R1);
	goto L1031;
L1030:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1034;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1035;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1036;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1037;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1038;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1039;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1039;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1039;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1039;
	goto L1040;
L1034:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1033;
L1035:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1033;
L1036:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1033;
L1037:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1033;
L1038:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1033;
L1039:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1033;
L1040:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1042;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1042;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1041;
L1042:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 120;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2h");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1041:
L1033:
L1031:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L1030;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1029;
L1029:
	return asi64(R1);
}

static void pc_diags_strpcl(u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	i64 opcode;
	i64 n;
	i64 x;
	i64 y;
	u64 d;
	u64 e;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asi64(R1) = opcode;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1045;
	R2 = 128;
	if (asi64(R1) == asi64(R2)) goto L1046;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1047;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1048;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1048;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1049;
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L1050;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1051;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1052;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1052;
	goto L1053;
L1045:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	pc_diags_strlabel(asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1055;
	R1 = tou64(" NOT USED");
	pc_diags_psstr(asu64(R1));
L1055:
	goto L1043;
	goto L1044;
L1046:
	R1 = tou64("! ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
	goto L1043;
	goto L1044;
L1047:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L1057;
	R1 = tou64("!");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	goto L1056;
L1057:
	R1 = tou64("! - - -");
	pc_diags_psstr(asu64(R1));
L1056:
	goto L1043;
	goto L1044;
L1048:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = opcode;
	R2 = 121;
	if (asi64(R1) != asi64(R2)) goto L1059;
	R1 = tou64("tcproc");
	pc_diags_psstr(asu64(R1));
	goto L1058;
L1059:
	R1 = tou64("proc");
	pc_diags_psstr(asu64(R1));
L1058:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	pc_diags_psname(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1061;
	R1 = tou64("::");
	goto L1060;
L1061:
	R1 = tou64(":");
L1060:
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1063;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1063:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1067;
L1064:
	R1 = tou64("    param    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1067:
	asu64(R1) = e;
	if (asu64(R1)) goto L1064;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1071;
L1068:
	R1 = tou64("    local    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1071:
	asu64(R1) = e;
	if (asu64(R1)) goto L1068;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1073;
	R1 = tou64("    rettype  ");
	pc_diags_psstr(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
L1073:
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1075;
	R1 = tou64("    variadic");
	pc_diags_psstrline(asu64(R1));
L1075:
	goto L1043;
	goto L1044;
L1049:
	R1 = tou64("endproc");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	goto L1043;
	goto L1044;
L1050:
	R1 = tou64("endprog");
	pc_diags_psstr(asu64(R1));
	goto L1043;
	goto L1044;
L1051:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1077;
	asu64(R1) = p;
	pc_diags_psdata(asu64(R1));
	goto L1043;
L1077:
	goto L1044;
L1052:
	goto L1078;
	goto L1044;
L1053:
L1044:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
// pc_diags.strpcl.skiptab:
L1078:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1080;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L1081;
	goto L1082;
L1080:
	R1 = tou64("jump");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1079;
L1081:
	R1 = tou64("set");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1079;
L1082:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L1079:
	R1 = 32;
	R2 = 9;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1084;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pclhastype;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1086;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1086:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1084:
	R1 = 32;
	R2 = 4;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_pclextra;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L1088;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	x = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L1091;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1090;
L1091:
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1090:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1093;
	asi64(R1) = y;
	if (!asi64(R1)) goto L1093;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = y;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1093:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1088:
	R1 = 32;
	R2 = 5;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1095;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	pc_diags_psopnd(asu64(R1));
L1095:
	R1 = 40;
	pc_diags_pstabto(asi64(R1));
L1043:
	return;
}

static u64 pc_diags_stropnd(u64 p) {
    u64 R1, R2, R3; 
	i64 length;
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1098;
	R1 = tou64("");
	goto L1096;
L1098:
	R1 = 0;
	R2 = (u64)&pc_diags_stropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1100;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1101;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1101;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1101;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1101;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1102;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1103;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1104;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1105;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1106;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1107;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1108;
	goto L1109;
L1100:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1096;
	goto L1099;
L1101:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L1111;
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("infinity");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L1110;
L1111:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e16.16");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L1110:
	goto L1099;
L1102:
	asu64(R1) = p;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L1113;
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_diags_stropnd_str;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1112;
L1113:
	asu64(R1) = pc_diags_stropnd_longstring;
	if (!asu64(R1)) goto L1115;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_diags_stropnd_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1115:
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	pc_api_longstringlen = asi64(R1);
	asi64(R1) = pc_api_longstringlen;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_diags_stropnd_longstring = asu64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	length = asi64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+2)) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	goto L1096;
L1112:
	goto L1099;
L1103:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1118;
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L1117;
L1118:
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1120;
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1120:
L1117:
	goto L1099;
L1104:
	R1 = tou64("&");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L1103;
	goto L1099;
L1105:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L1099;
L1106:
	R1 = tou64("");
	goto L1096;
	goto L1099;
L1107:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1096;
	goto L1099;
L1108:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<Data * # (#)>");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L1099;
L1109:
	msysc_m$print_startcon();
	R1 = tou64("---------");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<PCLOPND?>");
	goto L1096;
L1099:
	R1 = (u64)&pc_diags_stropnd_str;
	goto L1096;
L1096:
	return asu64(R1);
}

static void pc_diags_psopnd(u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B20 str;
	i64 length;
	u64 d;
	u64 ss;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1123;
	goto L1121;
L1123:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1125;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1126;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1126;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1126;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1126;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1127;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1128;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1129;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1130;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1131;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1132;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1133;
	goto L1134;
L1125:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	pc_diags_psint(asi64(R1));
	goto L1124;
L1126:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L1136;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("infinity");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L1135;
L1136:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e16.16");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L1135:
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	goto L1124;
L1127:
	asu64(R1) = p;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L1138;
	R1 = tou64("\"");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&str;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = pc_diags_newconvertstring(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	R1 = tou64("\"*");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_diags_psint(asi64(R1));
	goto L1137;
L1138:
	asu64(R1) = pc_diags_psopnd_longstring;
	if (!asu64(R1)) goto L1140;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_diags_psopnd_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1140:
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	pc_api_longstringlen = asi64(R1);
	asi64(R1) = pc_api_longstringlen;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_diags_psopnd_longstring = asu64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_psopnd_longstring;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc_diags_psopnd_longstring;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	length = asi64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_psopnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = pc_diags_psopnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+2)) = asu8(R1);
	asu64(R1) = pc_diags_psopnd_longstring;
	pc_diags_psstr(asu64(R1));
L1137:
	goto L1124;
L1128:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1143;
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L1142;
L1143:
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1145;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1145:
L1142:
	goto L1124;
L1129:
	R1 = tou64("&");
	pc_diags_psstr(asu64(R1));
	goto L1128;
	goto L1124;
L1130:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	goto L1124;
L1131:
	goto L1121;
	goto L1124;
L1132:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	pc_diags_psint(asi64(R1));
	goto L1124;
L1133:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<Data * # (#)>");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	goto L1124;
L1134:
	R1 = tou64("<PCLOPND?>");
	pc_diags_psstr(asu64(R1));
L1124:
L1121:
	return;
}

static u64 pc_diags_strpclstr(u64 p, i64 buffsize) {
    u64 R1, R2; 
	asu64(R1) = pc_diags_dest;
	mlib_gs_free(asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	pc_diags_destlinestart = asi64(R1);
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	R1 = 0;
	asu64(R2) = pc_diags_dest;
	mlib_gs_char(asu64(R2), asi64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = buffsize;
	if (asi64(R1) < asi64(R2)) goto L1148;
	R1 = tou64("<BIGSTR>");
	goto L1146;
L1148:
	asu64(R1) = pc_diags_dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1146;
L1146:
	return asu64(R1);
}

static void pc_diags_writepcl(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1151;
	goto L1152;
L1151:
	goto L1150;
L1152:
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
L1150:
	return;
}

static u64 pc_diags_writeallpcl() {
    u64 R1, R2; 
	u64 p;
	u64 d;
	i64 i;
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = tou64("!PROC PCL");
	asu64(R2) = pc_diags_dest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1156;
L1154:
	R1 = tou64("addlib    \"");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("\"");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	i += 1; if (i <= pc_decls_nplibfiles) goto L1154;
L1156:
	asi64(R1) = pc_decls_nplibfiles;
	if (!asi64(R1)) goto L1158;
	pc_diags_psline();
L1158:
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1162;
L1159:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1164;
	R1 = tou64("extproc    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1166;
	R1 = tou64(" 1");
	pc_diags_psstr(asu64(R1));
L1166:
	pc_diags_psline();
L1164:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1162:
	asu64(R1) = d;
	if (asu64(R1)) goto L1159;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1168;
L1167:
	asu64(R1) = p;
	pc_diags_writepcl(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1168:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1167;
	pc_diags_psline();
	asu64(R1) = pc_api_longstring;
	if (!asu64(R1)) goto L1171;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_api_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1171:
	asu64(R1) = pc_diags_dest;
	goto L1153;
L1153:
	return asu64(R1);
}

static void pc_diags_psstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psstrx(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psstrline(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void pc_diags_psline() {
    u64 R1, R2; 
	R1 = tou64("\n");
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psint(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psname(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_pstabto(i64 n) {
    u64 R1, R2; 
	i64 col;
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = pc_diags_destlinestart;
	asi64(R1) -= asi64(R2);
	col = asi64(R1);
	goto L1180;
L1179:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&col;
	(*toi64p(R1)) += 1;
L1180:
	asi64(R1) = n;
	asi64(R2) = col;
	if (asi64(R1) > asi64(R2)) goto L1179;
	return;
}

static void pc_diags_strlabel(i64 labelno, i64 colon) {
    u64 R1; 
	R1 = tou64("#");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = labelno;
	pc_diags_psint(asi64(R1));
	asi64(R1) = colon;
	if (!asi64(R1)) goto L1184;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1184:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	return;
}

static void pc_diags_psdata(u64 p) {
    u64 R1, R2; 
	i64 n;
	i64 m;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1187;
	goto L1185;
L1187:
	goto L1189;
L1188:
	asi64(R1) = n;
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L1192;
	R1 = 20;
	m = asi64(R1);
L1192:
	asi64(R1) = m;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = tou64("    data mem:");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	pc_diags_psint(asi64(R1));
	R1 = tou64("  ");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L1194;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
L1194:
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1197;
L1195:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L1195;
L1197:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1199;
	pc_diags_psline();
L1199:
L1189:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1188;
L1185:
	return;
}

static u64 pc_diags_writepst() {
    u64 R1, R2; 
	u8 localfile;
	i64 i;
	i64 j;
	u64 d;
	u64 e;
	R1 = 0;
	localfile = asu8(R1);
	R1 = 0;
	i = asi64(R1);
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("PROC PC Symbol table");
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1204;
L1201:
	R1 = tou64("H");
	asu64(R2) = d;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("25jl");
	asu64(R2) = d;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1207;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1206;
L1207:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1211;
L1208:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1211:
	asu64(R1) = e;
	if (asu64(R1)) goto L1208;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1215;
L1212:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1215:
	asu64(R1) = e;
	if (asu64(R1)) goto L1212;
L1206:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1204:
	asu64(R1) = d;
	if (asu64(R1)) goto L1201;
	pc_diags_psline();
	asu64(R1) = pc_diags_dest;
	goto L1200;
L1200:
	return asu64(R1);
}

static void pc_diags_writepsymbol(u64 d, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u8 localfile;
	struct $B16 str;
	i64 av_1;
	R1 = 0;
	localfile = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("4");
	asu64(R2) = d;
	R3 = 120;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = (u64)&pc_tables_idnames;
	asu64(R2) = d;
	R3 = 72;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	R1 = 8;
	R2 = (u64)&pc_tables_idnames;
	asu64(R3) = d;
	R4 = 72;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1219;
L1217:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	if (--asi64(av_1)) goto L1217;
L1219:
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmt;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1221;
	R1 = tou64(" Pm:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" Loc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	pc_diags_psint(asi64(R1));
L1221:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1223;
	R1 = tou64(" Exp");
	pc_diags_psstr(asu64(R1));
L1223:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1225;
	R1 = tou64(" Imp");
	pc_diags_psstr(asu64(R1));
L1225:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1227;
	R1 = tou64(" Var:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
L1227:
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1229;
	R1 = tou64(" TC");
	pc_diags_psstr(asu64(R1));
L1229:
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1231;
	R1 = tou64(" Dot");
	pc_diags_psstr(asu64(R1));
L1231:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1233;
	R1 = tou64(" ENTRY PT");
	pc_diags_psstr(asu64(R1));
L1233:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1235;
	R1 = tou64(" .PCADDR =");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
L1235:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1237;
	R1 = tou64(" (");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1237:
	R1 = 0;
	if (!asu16(R1)) goto L1239;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1239;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1239;
	R1 = tou64(" (Proc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(") (D:");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1239:
	R1 = 0;
	if (!asu16(R1)) goto L1241;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1241;
	asu64(R1) = d;
	R2 = 104;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1241;
	R1 = tou64(" Has statics");
	pc_diags_psstr(asu64(R1));
L1241:
	pc_diags_psline();
	return;
}

static void pc_diags_showprocinfo(u64 d) {
    u64 R1, R2; 
	struct $B16 str;
	u64 p;
	u64 e;
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1244;
	goto L1242;
L1244:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("PROC INFO FOR: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Params:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Locals:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Leaf:     #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Nmaxargs: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Assem:    #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  MCLdone:  #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Hasblocks:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1248;
L1245:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Pm: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1248:
	asu64(R1) = e;
	if (asu64(R1)) goto L1245;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1252;
L1249:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Loc: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1252:
	asu64(R1) = e;
	if (asu64(R1)) goto L1249;
	pc_diags_psline();
L1242:
	return;
}

static i64 pc_diags_newconvertstring(u64 s, u64 t, i64 length) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	i64 av_1;
	asu64(R1) = t;
	t0 = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1256;
L1254:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1258;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1259;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1260;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1261;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1262;
	goto L1263;
L1258:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1257;
L1259:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1257;
L1260:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1257;
L1261:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1257;
L1262:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1257;
L1263:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1265;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1265;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1264;
L1265:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z3x8");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1264:
L1257:
	if (--asi64(av_1)) goto L1254;
L1256:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1253;
L1253:
	return asi64(R1);
}

static void pc_reduce_pcl_reducetest() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 nn;
	i64 seqno;
	i64 lab;
	i64 lab2;
	i64 nargs;
	u64 pc;
	u64 newpc;
	u64 pcnext;
	u64 pcnext2;
	u64 pcproc;
	u64 labelmap;
	u64 pdef;
	struct $B21 callstack;
	i64 ncall;
	i64 nprocs;
	i64 nleaf;
	i64 nallparams;
	i64 nalllocals;
	i64 offset;
	i64 av_1;
	R1 = 0;
	nprocs = asi64(R1);
	R1 = 0;
	nleaf = asi64(R1);
	R1 = 0;
	nallparams = asi64(R1);
	R1 = 0;
	nalllocals = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nn = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	goto L1270;
L1267:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1272;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1273;
	goto L1274;
L1272:
	goto L1271;
L1273:
	asu64(R1) = pc_api_icheckasmlabel;
	if (!asu64(R1)) goto L1276;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_icheckasmlabel;
	asi64(R1) = ((F17)R2)(asu64(R1));
	lab = asi64(R1);
	asi64(R1) = lab;
	if (!asi64(R1)) goto L1278;
	asu64(R1) = labelmap;
	asi64(R2) = lab;
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1278:
L1276:
	goto L1271;
L1274:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1280;
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1280:
L1271:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1270:
	asu64(R1) = pc;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1267;
// pc_reduce.pcl_reducetest.skip:
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	newpc = asu64(R1);
	R1 = 0;
	seqno = asi64(R1);
	asi64(R1) = nn;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1284;
L1282:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcnext = asu64(R1);
	R1 = (u64)&pc_tables_pclargs;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	nargs = asi64(R2);
	if (!asi64(R1)) goto L1286;
	asi64(R1) = nargs;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L1288;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	nargs = asi64(R1);
L1288:
	asu64(R1) = pc_decls_pinfo;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = nargs;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1286:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1290;
	asu64(R1) = pc_decls_pinfo;
	if (!asu64(R1)) goto L1290;
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1290;
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1290:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1292;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1293;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1294;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1294;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L1295;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L1295;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1295;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1295;
	R2 = 131;
	if (asi64(R1) == asi64(R2)) goto L1296;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1297;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1298;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1299;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1299;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L1300;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L1301;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1302;
	goto L1303;
L1292:
	goto L1291;
L1293:
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu16(R1) = *tou16p(((i64)R1+(i64)R2*2-2));
	if (!asu16(R1)) goto L1305;
	goto L1303;
	goto L1303;
L1305:
	goto L1291;
L1294:
	R1 = (u64)&nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdef = asu64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pdef;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	asu64(R2) = pdef;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&nallparams;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&nalllocals;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	ncall = asi64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcproc = asu64(R1);
	goto L1303;
	goto L1303;
	goto L1291;
L1295:
	R1 = 0;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&ncall;
	(*toi64p(R1)) -=1;
	goto L1303;
	goto L1303;
	goto L1291;
L1296:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = newpc;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = (u64)&callstack;
	R3 = (u64)&ncall;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1291;
L1297:
	asu64(R1) = pc_decls_pinfo;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1307;
	R1 = (u64)&nleaf;
	(*toi64p(R1)) += 1;
L1307:
	R1 = 0;
	pc_decls_pinfo = asu64(R1);
	goto L1303;
	goto L1303;
	goto L1291;
L1298:
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1303;
	goto L1303;
	goto L1291;
L1299:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1309;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1309;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = newpc;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1311;
	R1 = 3;
	goto L1310;
L1311:
	R1 = 6;
L1310:
	asu64(R2) = newpc;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1308;
L1309:
	goto L1303;
	goto L1303;
L1308:
	goto L1291;
L1300:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) != asi64(R2)) goto L1313;
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L1313;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1312;
L1313:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1315;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1314;
L1315:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1312;
L1314:
	goto L1303;
	goto L1303;
L1312:
	goto L1291;
L1301:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1318;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1318;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1317;
L1318:
	asu64(R1) = newpc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) != asi64(R2)) goto L1317;
	goto L1316;
L1317:
	goto L1303;
	goto L1303;
L1316:
	goto L1291;
L1302:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1320;
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = newpc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1321;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1321;
	R1 = 1;
	goto L1322;
L1321:
	R1 = 0;
L1322:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L1320;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pcnext;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = pcnext;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = newpc;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1319;
L1320:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1323;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1319;
L1323:
	goto L1303;
	goto L1303;
L1319:
	goto L1291;
L1303:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = newpc;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1325;
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1328;
	asu64(R1) = newpc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1327;
L1328:
	R1 = 1;
	asu64(R2) = newpc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1327:
L1325:
L1291:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	if (--asi64(av_1)) goto L1282;
L1284:
	asu64(R1) = newpc;
	pc_api_pccurr = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 stack;
	u64 pc;
	i64 sp;
	i64 fp;
	i64 a;
	u64 ptr;
	i64 b;
	u64 ptrb;
	i64 n;
	u64 d;
	struct $B53 callstack;
	struct $B63 callstackst;
	i64 callsp;
	struct $B16 str;
	i64 mag;
	i64 oldsp;
	i64 ncmd;
	u64 cmd;
	i64 lastpos;
	i64 count;
	i64 av_1;
	i64 av_2;
	asu64(R1) = pcentry;
	pc = asu64(R1);
	R1 = 0;
	sp = asi64(R1);
	R1 = 0;
	fp = asi64(R1);
	R1 = 0;
	callsp = asi64(R1);
	R1 = 560000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	stack = asu64(R1);
	asi64(R1) = cmain;
	if (!asi64(R1)) goto L1331;
	asi64(R1) = msysc_ncmdparams;
	ncmd = asi64(R1);
	asu64(R1) = msysc_cmdparams;
	cmd = asu64(R1);
	asi64(R1) = ncmd;
	asi64(R2) = pc_decls_pcmdskip;
	asi64(R1) -= asi64(R2);
	ncmd = asi64(R1);
	asu64(R1) = cmd;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	cmd = asu64(R1);
	asu64(R1) = cmd;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1331:
	R1 = 0;
	lastpos = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1333;
	R1 = tou64("<Fn ptr>");
	R2 = (u64)&pc_run_emptyst;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1333:
L1334:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L1338;
	case 1: goto L1339;
	case 2: goto L1342;
	case 3: goto L1343;
	case 4: goto L1344;
	case 5: goto L1351;
	case 6: goto L1352;
	case 7: goto L1337;
	case 8: case 9: goto L1353;
	case 10: goto L1354;
	case 11: goto L1355;
	case 12: goto L1356;
	case 13: goto L1358;
	case 14: goto L1359;
	case 15: goto L1360;
	case 16: goto L1361;
	case 17: goto L1364;
	case 18: case 21: goto L1365;
	case 19: goto L1390;
	case 20: goto L1380;
	case 22: goto L1398;
	case 23: goto L1385;
	case 24: goto L1403;
	case 25: goto L1404;
	case 26: goto L1405;
	case 27: goto L1413;
	case 28: goto L1416;
	case 29: goto L1419;
	case 30: goto L1420;
	case 31: goto L1421;
	case 32: goto L1428;
	case 33: goto L1429;
	case 34: goto L1432;
	case 35: goto L1435;
	case 36: goto L1438;
	case 37: case 38: goto L1441;
	case 39: goto L1444;
	case 40: goto L1445;
	case 41: goto L1446;
	case 42: goto L1447;
	case 43: goto L1448;
	case 44: goto L1451;
	case 45: goto L1454;
	case 46: goto L1457;
	case 47: goto L1458;
	case 48: goto L1461;
	case 49: goto L1464;
	case 50: goto L1465;
	case 51: goto L1466;
	case 52: goto L1467;
	case 53: goto L1468;
	case 54: goto L1469;
	case 55: goto L1472;
	case 56: goto L1476;
	case 57: goto L1480;
	case 58: goto L1481;
	case 59: goto L1482;
	case 60: goto L1483;
	case 61: goto L1486;
	case 62: goto L1489;
	case 63: goto L1490;
	case 64: goto L1491;
	case 65: goto L1492;
	case 66: goto L1493;
	case 67: goto L1496;
	case 68: goto L1497;
	case 69: goto L1498;
	case 70: goto L1499;
	case 71: goto L1500;
	case 72: goto L1501;
	case 73: goto L1502;
	case 74: goto L1503;
	case 75: goto L1504;
	case 76: goto L1505;
	case 77: goto L1506;
	case 78: goto L1507;
	case 79: goto L1508;
	case 80: goto L1509;
	case 81: goto L1510;
	case 82: goto L1511;
	case 83: goto L1514;
	case 84: goto L1515;
	case 85: goto L1516;
	case 86: goto L1517;
	case 87: goto L1518;
	case 88: goto L1519;
	case 89: goto L1520;
	case 90: goto L1521;
	case 91: goto L1524;
	case 92: goto L1527;
	case 93: case 94: goto L1530;
	case 95: goto L1533;
	case 96: goto L1534;
	case 97: goto L1535;
	case 98: goto L1536;
	case 99: goto L1537;
	case 100: goto L1538;
	case 101: goto L1541;
	case 102: goto L1545;
	case 103: goto L1549;
	case 104: goto L1550;
	case 105: goto L1551;
	case 106: goto L1552;
	case 107: goto L1553;
	case 108: goto L1554;
	case 109: goto L1555;
	case 110: goto L1556;
	case 111: goto L1557;
	case 112: goto L1560;
	case 113: goto L1561;
	case 114: goto L1562;
	case 115: goto L1563;
	case 116: goto L1564;
	case 117: goto L1565;
	case 118: goto L1566;
	case 119: goto L1567;
	case 120: goto L1568;
	case 121: goto L1574;
	case 122: goto L1575;
	case 123: goto L1576;
	case 124: goto L1577;
	case 125: goto L1578;
	case 126: goto L1589;
	case 127: goto L1579;
	case 128: goto L1580;
	case 129: goto L1581;
	case 130: goto L1582;
	case 131: goto L1583;
	case 132: goto L1584;
	case 133: goto L1585;
	case 134: goto L1586;
	case 135: goto L1587;
	case 136: goto L1588;
	default: goto L1337;
    };
// SWITCH
L1338:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1339:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1341;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1340;
L1341:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1340:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1342:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1343:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1344:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1346;
	goto L1347;
L1346:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1349;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1348;
L1349:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1350;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1350;
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	goto L1348;
L1350:
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	R1 += (i64)R2*8-8;
	ptr = asu64(R1);
L1348:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1345;
L1347:
	asu64(R1) = pc;
	pc_runaux_pcusopnd(asu64(R1));
L1345:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1351:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1352:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1353:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1354:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asi64(R2) -= asi64(R3);
	R1 += (i64)R2*8-8;
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R4) = pc;
	R5 = 20;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) -= asi64(R4);
	R2 += (i64)R3*8-8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1355:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1356:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1358:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1359:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1360:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-24));
	asi64(R1) = pc_runaux_pci_loadbf(asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1361:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-24));
	if (!asi64(R1)) goto L1363;
	R1 = 1;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L1362;
L1363:
	R1 = 0;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L1362:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1364:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-24));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-32));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-16));
	asi64(R4) = a;
	asi64(R1) = pc_runaux_pci_storebf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1365:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1367;
	asi64(R1) = callsp;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1370;
L1368:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L1368;
L1370:
	msysc_m$print_startcon();
	R1 = tou64("# Call:   # # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_run_seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	asi64(R1) = pc_run_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1367:
	asi64(R1) = sp;
	R2 = 69900;
	if (asi64(R1) <= asi64(R2)) goto L1372;
	R1 = tou64("");
	R2 = tou64("Stack overflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1372:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1374;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	R5 = 0;
	asu64(R6) = d;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L1376;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1375;
L1376:
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1375:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1373;
L1374:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1377;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Proc not defined:");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1373;
L1377:
	asi64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 21;
	if (asi64(R2) != asi64(R3)) goto L1379;
	R2 = 1;
	goto L1378;
L1379:
	R2 = 0;
L1378:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	asu64(R1) = d;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L1373:
	goto L1334;
L1380:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1382;
	R1 = tou64("");
	R2 = tou64("retp/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1382:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1384;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETP/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1384:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1334;
L1385:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1387;
	R1 = tou64("");
	R2 = tou64("ref/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1387:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1389;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETF/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1389:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1334;
L1390:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1392;
	R1 = tou64("");
	R2 = tou64("ICALLP NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1392:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1394;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1394;
// pc_run.dispatch_loop.icallp:
L1395:
	asi64(R1) = sp;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 22;
	if (asi64(R2) != asi64(R3)) goto L1397;
	R2 = 1;
	goto L1396;
L1397:
	R2 = 0;
L1396:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&pc_run_emptyst;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = ptr;
	pc = asu64(R1);
	goto L1393;
L1394:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1393:
	goto L1334;
L1398:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1400;
	R1 = tou64("");
	R2 = tou64("ICALLF NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1400:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1402;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1402;
	goto L1395;
	goto L1401;
L1402:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1401:
	goto L1334;
L1403:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1334;
L1404:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1334;
L1405:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1407;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpreal(asi64(R3), asr64(R2), asr64(R1));
	n = asi64(R1);
	goto L1406;
L1407:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1408;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1406;
L1408:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1406:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1410;
	asi64(R1) = n;
	if (asi64(R1)) goto L1410;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1409;
L1410:
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
L1409:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1412;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1411;
L1412:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1411:
	goto L1334;
L1413:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L1415;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1414;
L1415:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1414:
	goto L1334;
L1416:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1418;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1417;
L1418:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1417:
	goto L1334;
L1419:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1334;
L1420:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1421:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1423;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1424;
	goto L1425;
L1423:
	R1 = tou64("");
	R2 = tou64("setcc/r64");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1422;
L1424:
	R1 = tou64("");
	R2 = tou64("setcc/r32");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1422;
L1425:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1427;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1426;
L1427:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1426:
L1422:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1428:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L1329;
	goto L1334;
L1429:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	(*toi64p(R1)) -=1;
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L1431;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1430;
L1431:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1430:
	goto L1334;
L1432:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L1434;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1433;
L1434:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1433:
	goto L1334;
L1435:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L1437;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1436;
L1437:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1436:
	goto L1334;
L1438:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1440;
	R1 = tou64("");
	R2 = tou64("swap/block");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1440:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptrb = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptrb;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	b = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = b;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptrb;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1441:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) < asi64(R2)) goto L1443;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) > asi64(R2)) goto L1443;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2*32;
	asi64(R2) = a;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 -= (i64)R2*32;
	pc = asu64(R1);
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1442;
L1443:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
L1442:
	goto L1334;
L1444:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1445:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1446:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = 0;
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1447:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1448:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1450;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) += asr64(R1);
	goto L1449;
L1450:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) += asi64(R1);
L1449:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1451:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1453;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) -= asr64(R1);
	goto L1452;
L1453:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) -= asi64(R1);
L1452:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1454:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1456;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) *= asr64(R1);
	goto L1455;
L1456:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) *= asi64(R1);
L1455:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1457:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) /= asr64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1458:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1460;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1459;
L1460:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1459:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1461:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1463;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) %= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1462;
L1463:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) %= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1462:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1464:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1465:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1466:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) |= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1467:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) ^= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1468:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) <<= asu64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1469:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1471;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) >>= asi64(R1);
	goto L1470;
L1471:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) >>= asu64(R1);
L1470:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1472:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1474;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Min(*tor64p(R2), asr64(R1));
	goto L1473;
L1474:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1475;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1473;
L1475:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1473:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1476:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1478;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Max(*tor64p(R2), asr64(R1));
	goto L1477;
L1478:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1479;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1477;
L1479:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1477:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1480:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1481:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1482:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1483:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1485;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1484;
L1485:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1484:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1486:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1488;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1487;
L1488:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1487:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1489:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = ~asu64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1490:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) ^= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1491:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !!asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1492:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1493:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1495;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	*tor64p(R2) *= asr64(R1);
	goto L1494;
L1495:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) *= asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1494:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1496:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = sqrt(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1497:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = sin(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1498:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = cos(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1499:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1500:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1501:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1502:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = atan(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1503:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = log(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1504:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1505:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = exp(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1506:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1507:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1508:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1509:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1510:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1511:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1513;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) = pow(asr64(R1), asr64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	goto L1512;
L1513:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
L1512:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1514:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1515:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1516:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1517:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1518:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1519:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1520:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1521:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1523;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) += asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1522;
L1523:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) += asi64(R1);
L1522:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1524:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1526;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) -= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1525;
L1526:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) -= asi64(R1);
L1525:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1527:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1529;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) *= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1528;
L1529:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) *= asi64(R1);
L1528:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1530:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1532;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) /= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1531;
L1532:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	a = asi64(R1);
L1531:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1533:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) %= asi64(R2);
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1534:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1535:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) |= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1536:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) ^= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1537:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1538:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1540;
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) >>= asi64(R1);
	goto L1539;
L1540:
	asu64(R1) = b;
	R2 = (u64)&a;
	*tou64p(R2) >>= asu64(R1);
L1539:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1541:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1543;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Min(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1542;
L1543:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1544;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1542;
L1544:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1542:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1545:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1547;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Max(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1546;
L1547:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1548;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1546;
L1548:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1546:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1549:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1550:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) -= asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1551:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1552:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1553:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1554:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1555:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1556:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1557:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1559;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1558;
L1559:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asu64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
L1558:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1560:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	R1 = toi64(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1561:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1562:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1563:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1564:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1565:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1566:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1567:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1568:
	asi64(R1) = fp;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = sp;
	fp = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1570;
	asi64(R1) = callsp;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1573;
L1571:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_2)) goto L1571;
L1573:
	msysc_m$print_startcon();
	R1 = tou64("# Enter:  # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = pc_run_seqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = fp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1570:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1574:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1575:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1576:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1577:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1578:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1579:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1580:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1581:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = ptr;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = sp;
	asu64(R2) = ptr;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = fp;
	asu64(R2) = ptr;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1582:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	pc = asu64(R1);
	asu64(R1) = ptr;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	sp = asi64(R1);
	asu64(R1) = ptr;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	fp = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1334;
L1583:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1584:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1585:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1586:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1587:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1588:
	goto L1357;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1334;
L1589:
	goto L1334;
L1337:
// pc_run.dispatch_loop.unimpl:
L1357:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("GETOPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Unimpl: # at seq: #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	goto L1334;
	R1 = 0;
	goto L1329;
L1329:
	return asi64(R1);
}

static void pc_run_fixuppcl() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 d;
	u64 e;
	u64 dproc;
	u64 pdata;
	i64 parambytes;
	i64 framebytes;
	i64 paramslots;
	i64 localslots;
	u64 a;
	asi64(R1) = pc_api_mlabelno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_run_labeltable = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1594;
L1591:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1596;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1596;
	goto L1597;
L1596:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1595;
L1597:
L1595:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1594:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1591;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1601;
L1598:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1603;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1603;
	goto L1604;
L1603:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1602;
L1604:
L1602:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1601:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1598;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1608;
L1605:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1610;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1610;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1611;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1612;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1613;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1614;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1614;
	goto L1615;
L1610:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdata = asu64(R1);
	goto L1609;
L1611:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1617;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1619;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1620;
	goto L1621;
L1619:
	R1 = tou64("");
	R2 = tou64("FIX/DATA/MEM");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1618;
L1620:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1623;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1624;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1625;
	goto L1626;
L1623:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1622;
L1624:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1622;
L1625:
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asu64(R1);
	goto L1622;
L1626:
	R1 = tou64("");
	R2 = tou64("data &mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1622:
	asu64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1628;
	R1 = tou64("");
	R2 = tou64("data &mem = nil");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1628:
	goto L1618;
L1621:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L1618:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = (u64)&a;
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1616;
L1617:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1616:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pdata;
	*tou64p(R2) += asu64(R1);
	goto L1609;
L1612:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	dproc = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	parambytes = asi64(R1);
	goto L1632;
L1629:
	R1 = 8;
	R2 = (u64)&parambytes;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1632:
	asu64(R1) = e;
	if (asu64(R1)) goto L1629;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	framebytes = asi64(R1);
	goto L1636;
L1633:
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 8;
	asu64(R2) = e;
	R3 = 84;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&framebytes;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1636:
	asu64(R1) = e;
	if (asu64(R1)) goto L1633;
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	paramslots = asi64(R2);
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	localslots = asi64(R2);
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1609;
L1613:
	asu64(R1) = p;
	asu64(R2) = pc_run_labeltable;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1609;
L1614:
	asi64(R1) = paramslots;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = localslots;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1609;
L1615:
L1609:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1608:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1605;
	return;
}

static void pc_run_pcl_runpcl() {
    u64 R1, R2, R3; 
	i64 stopcode;
	pc_runaux_loadlibs();
	pc_run_fixuppcl();
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1639;
	R1 = tou64("");
	R2 = tou64("No 'main' entry point");
	asu64(R3) = pc_api_pcstart;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1639:
	pc_runaux_docmdskip();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1641;
	msysc_m$print_startcon();
	R1 = tou64("Run PCL:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1641:
	asu64(R1) = pc_decls_entryproc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = pc_decls_entryproc;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_run_dispatch_loop(asu64(R2), asi64(R1));
	stopcode = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1643;
	msysc_m$print_startcon();
	R1 = tou64("Stopped");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = stopcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L1643:
	asi64(R1) = stopcode;
	exit(R1);
	return;
}

static i64 pc_run_getlineno(u64 pc) {
    u64 R1, R2, R3, R4; 
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1646;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asu64(R3) = pc;
	R4 = 24;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F16)R4)(asi64(R3), asu64(R2), asu64(R1));
	goto L1645;
L1646:
	R1 = 0;
L1645:
	goto L1644;
L1644:
	return asi64(R1);
}

static i64 pc_runaux_pci_getopnd(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	i64 a;
	u64 d;
	u64 ptr;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1649;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1650;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1651;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1652;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1653;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1653;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1654;
	goto L1655;
L1649:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1648;
L1650:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1657;
	goto L1658;
L1657:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1656;
L1658:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	ptr = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1660;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1660;
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	ptr = asu64(R1);
L1660:
L1656:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	goto L1648;
L1651:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1662;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1663;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1664;
	goto L1665;
L1662:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	goto L1661;
L1663:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1667;
	asi64(R1) = a;
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	a = asi64(R1);
L1667:
	goto L1661;
L1664:
	asu64(R1) = d;
	asi64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asi64(R1);
	goto L1661;
L1665:
	asu64(R1) = d;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
L1661:
	goto L1648;
L1652:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1648;
L1653:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1648;
L1654:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	goto L1648;
L1655:
	asu64(R1) = p;
	pc_runaux_pcusopnd(asu64(R1));
L1648:
	asi64(R1) = a;
	goto L1647;
L1647:
	return asi64(R1);
}

static i64 pc_runaux_pci_loadptr(u64 p, i64 mode) {
    u64 R1, R2; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1670;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1670:
	asi64(R1) = mode;
	switch (asi64(R1)) {
	case 1: goto L1676;
	case 2: goto L1675;
	case 3: goto L1684;
	case 4: goto L1683;
	case 5: goto L1682;
	case 6: goto L1681;
	case 7: goto L1680;
	case 8: goto L1679;
	case 9: goto L1678;
	case 10: goto L1677;
	case 11: goto L1674;
	default: goto L1673;
    };
// SWITCH
L1674:
	asu64(R1) = p;
	goto L1671;
L1675:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1671;
L1676:
	asu64(R1) = p;
	asr32(R1) = *tor32p(R1);
    asr64(R1) = tor64(asr32(R1));
	x = asr64(R1);
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L1671;
L1677:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1671;
L1678:
	asu64(R1) = p;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	goto L1671;
L1679:
	asu64(R1) = p;
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	goto L1671;
L1680:
	asu64(R1) = p;
	asi8(R1) = *toi8p(R1);
	R1 = toi64(toi8(R1));
	goto L1671;
L1681:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1671;
L1682:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	goto L1671;
L1683:
	asu64(R1) = p;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	goto L1671;
L1684:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L1671;
L1673:
	R1 = 0;
L1671:
	goto L1668;
L1668:
	return asi64(R1);
}

static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size) {
    u64 R1, R2, R3; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1687;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1687:
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1689;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1690;
	goto L1691;
L1689:
	asi64(R1) = size;
	asi64(R2) = a;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1688;
L1690:
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	x = asr64(R1);
	asr64(R1) = x;
    asr32(R1) = tor32(asr64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L1688;
L1691:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1693;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1694;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1695;
	goto L1696;
L1693:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L1692;
L1694:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L1692;
L1695:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	goto L1692;
L1696:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi8p(R2) = asi8(R1);
L1692:
L1688:
	return;
}

static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1699;
	R1 = tou64("");
	R2 = tou64("Not mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1699:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1701;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1700;
L1701:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
L1700:
	goto L1697;
L1697:
	return asu64(R1);
}

static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("PC Exec error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("seq:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	if (!asu64(R2)) goto L1704;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	goto L1703;
L1704:
	R2 = 0;
L1703:
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_runaux_pcusopnd(u64 p) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("Unsupported operand:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode) {
    u64 R1, R2, R3, R4, R5; 
	struct $B70 args;
	i64 retval;
	i64 i;
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1708;
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	fnaddr = asu64(R1);
L1708:
	asi64(R1) = nargs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1711;
L1709:
	asu64(R1) = revargs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = i;
	asi64(R3) -= asi64(R4);
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	i += -1; if (i >= 1) goto L1709;
L1711:
	R1 = 0;
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = retmode;
	R5 = 1;
	if (asi64(R4) == asi64(R5)) goto L1714;
	R5 = 2;
	if (asi64(R4) != asi64(R5)) goto L1713;
L1714:
	R4 = 82;
	goto L1712;
L1713:
	R4 = 73;
L1712:
	asu64(R5) = fnaddr;
	asi64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	retval = asi64(R1);
	asi64(R1) = retval;
	goto L1706;
L1706:
	return asi64(R1);
}

static u64 pc_runaux_getdllfnptr(u64 d) {
    u64 R1, R2, R3; 
	u64 fnaddr;
	i64 libindex;
	u64 dllinst;
	u64 procname;
	u64 libname;
	i64 i;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1717;
	asu64(R1) = fnaddr;
	goto L1715;
L1717:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	procname = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1721;
L1718:
	asu64(R1) = procname;
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlinux_os_getdllprocaddr(asi64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1723;
	goto L1720;
L1723:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1718;
L1721:
	asu64(R1) = procname;
	R2 = tou64("Can't find DLL func:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1720:
	asu64(R1) = fnaddr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fnaddr;
	goto L1715;
L1715:
	return asu64(R1);
}

static void pc_runaux_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1727;
L1725:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mlinux_os_getdllinst(asu64(R1));
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc_decls_plibinst;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L1729;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't load lib:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1729:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1725;
L1727:
	return;
}

static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1732;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1733;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1734;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1735;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1736;
	goto L1737;
L1732:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  ==  asr64(R2);
	goto L1731;
L1733:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  !=  asr64(R2);
	goto L1731;
L1734:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <  asr64(R2);
	goto L1731;
L1735:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <=  asr64(R2);
	goto L1731;
L1736:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >=  asr64(R2);
	goto L1731;
L1737:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >  asr64(R2);
L1731:
	goto L1730;
L1730:
	return asi64(R1);
}

static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1740;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1741;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1742;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1743;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1744;
	goto L1745;
L1740:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1739;
L1741:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L1739;
L1742:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	goto L1739;
L1743:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L1739;
L1744:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	goto L1739;
L1745:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
L1739:
	goto L1738;
L1738:
	return asi64(R1);
}

static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1748;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1749;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1750;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1751;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1752;
	goto L1753;
L1748:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  ==  asu64(R2);
	goto L1747;
L1749:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	goto L1747;
L1750:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	goto L1747;
L1751:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	goto L1747;
L1752:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	goto L1747;
L1753:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >  asu64(R2);
L1747:
	goto L1746;
L1746:
	return asi64(R1);
}

static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1756;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1757;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1758;
	goto L1759;
L1756:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou64p(R2) += asu64(R1);
	goto L1755;
L1757:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou32p(R2) += asu32(R1);
	goto L1755;
L1758:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou16p(R2) += asu16(R1);
	goto L1755;
L1759:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou8p(R2) += asu8(R1);
L1755:
	return;
}

static void pc_runaux_docmdskip() {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1764;
L1761:
	R1 = tou64("$cmdskip");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1766;
	asi64(R1) = pc_decls_pcmdskip;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) = asu8(R1);
	goto L1763;
L1766:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1764:
	asu64(R1) = d;
	if (asu64(R1)) goto L1761;
L1763:
	return;
}

static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j) {
    u64 R1, R2; 
	u64 mask;
	i64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1769;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1769:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	R1 = -1;
	asi64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	asu64(R2) = i;
	asu64(R1) >>= asu64(R2);
	goto L1767;
L1767:
	return asu64(R1);
}

static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x) {
    u64 R1, R2; 
	u64 mask;
	u64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1772;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1772:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asu64(R1) += asu64(R2);
	n = asu64(R1);
	R1 = -1;
	asu64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = x;
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	x = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R2) = ~asu64(R2);
	asu64(R1) &= asu64(R2);
	asu64(R2) = x;
	asu64(R1) |= asu64(R2);
	goto L1770;
L1770:
	return asu64(R1);
}

static void mc_genmcl_genmcl(u64 dummy) {
    u64 R1, R2, R3; 
	i64 tt;
	i64 i;
	asu8(R1) = pc_decls_mcldone;
	if (!asu8(R1)) goto L1775;
	goto L1773;
L1775:
	asi64(R1) = mlinux_os_clock();
	tt = asi64(R1);
	mc_genmcl_inithandlers();
	R1 = 0;
	mc_libmcl_mclinit(asi64(R1));
	asu64(R1) = pc_api_pcstart;
	mc_decls_currpcl = asu64(R1);
	R1 = 0;
	i = asi64(R1);
L1776:
	asu64(R1) = mc_decls_currpcl;
	mc_genmcl_convertpcl(asu64(R1));
	R1 = 0;
	if (!asu16(R1)) goto L1780;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1780;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1780;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1780;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1780;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1780;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1780;
	mc_stackmcl_showopndstack();
L1780:
	R1 = (u64)&mc_decls_currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = mc_decls_currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1781;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) != asi64(R2)) goto L1776;
L1781:
	mc_auxmcl_genrealtable();
	mc_auxmcl_genabsneg();
	mc_auxmcl_genstringtable();
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L1783;
	mc_optim_peephole();
L1783:
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
L1773:
	return;
}

static void mc_genmcl_convertpcl(u64 p) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 oldregset;
	i64 reg;
	i64 i;
	asu8(R1) = pc_decls_fshowil;
	if (!asu8(R1)) goto L1786;
	asu64(R1) = p;
	mc_genmcl_doshowpcl(asu64(R1));
L1786:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	mc_decls_pmode = asu8(R1);
	asu64(R1) = p;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pc_decls_ppseqno = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	((F18)R2)(asu64(R1));
	(R1_B3) = mc_decls_regset;
	oldregset = (R1_B3);
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1789;
L1787:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L1791;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1793;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1792;
L1793:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1792:
L1791:
	i += 1; if (i <= mc_decls_noperands) goto L1787;
L1789:
	R1 = (u64)&oldregset;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 48;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	R1 = (u64)&oldregset;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 56;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	return;
}

static void mc_genmcl_inithandlers() {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	i64 n;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	i64 k;
// PROC LOCAL STATICS GO HERE
	static u8 mc_genmcl_inithandlers_initdone = 0;
	static struct $B27 mc_genmcl_inithandlers_dupltable = {{
22605,
	16449,
	4629,
	4627,
	4630,
	30327,
	30841,
	12126,
	12383    }};
	asu8(R1) = mc_genmcl_inithandlers_initdone;
	if (!asu8(R1)) goto L1796;
	goto L1794;
L1796:
	asi64(R1) = $nprocs;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1799;
L1797:
	R1 = (u64)&$procname;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 3;
	R2 = tou64("px_");
	asu64(R3) = name;
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L1801;
	R1 = 0;
	k = asi64(R1);
	R1 = 142;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1805;
L1802:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	s = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) != asu64(R2)) goto L1807;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L1807:
	asu64(R1) = name;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1809;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L1804;
L1809:
	k += 1; if (k <= av_1) goto L1802;
L1805:
	asu64(R1) = name;
	R2 = tou64("Invalid handler name:");
	pc_api_merror(asu64(R2), asu64(R1));
L1804:
L1801:
	i += 1; if (i <= n) goto L1797;
L1799:
	R1 = 1;
	i = asi64(R1);
	R1 = 9;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1812;
L1810:
	R1 = (u64)&mc_genmcl_px_handlertable;
	R2 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R3) = i;
	R2 += (i64)R3*2-2;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	R3 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R4) = i;
	R3 += (i64)R4*2-2;
	R4 = 1;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L1810;
L1812:
	R1 = 0;
	i = asi64(R1);
	R1 = 142;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1815;
L1813:
	R1 = (u64)&mc_genmcl_px_handlertable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (asu64(R1)) goto L1817;
	R1 = (u64)&mc_genmcl_unimpl;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L1817:
	i += 1; if (i <= av_3) goto L1813;
L1815:
	R1 = 1;
	mc_genmcl_inithandlers_initdone = asu8(R1);
L1794:
	return;
}

static void mc_genmcl_doshowpcl(u64 p) {
    u64 R1, R2; 
	struct $B95 str;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1820;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1820;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1820;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1820;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1820;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1820;
	goto L1821;
L1820:
	goto L1819;
L1821:
	R1 = tou64("                       ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1256;
	asu64(R2) = p;
	asu64(R1) = pc_diags_strpclstr(asu64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
L1819:
	return;
}

static void mc_genmcl_unimpl(u64 p) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Unimpl: # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_nop(u64 p) {
	return;
}

static void mc_genmcl_px_dupl(u64 p) {
	mc_stackmcl_duplpcl();
	return;
}

static void mc_genmcl_px_double(u64 p) {
    u64 R1, R2; 
	asi64(R1) = mc_decls_ncalldepth;
	if (!asi64(R1)) goto L1827;
	mc_stackmcl_duplpcl();
	goto L1826;
L1827:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L1826:
	return;
}

static void mc_genmcl_px_opnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_type(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_comment(u64 p) {
	return;
}

static void mc_genmcl_px_proc(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_currfunc = asu64(R1);
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 1;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	mc_auxmcl_initproc(asu64(R1));
	R1 = tou64("?>>");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mclprocentry = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1833;
	asu64(R1) = pc_decls_currfunc;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1833;
	asu8(R1) = pcl_pdcc;
	if (asu8(R1)) goto L1833;
	mc_auxmcl_fixmain();
L1833:
	return;
}

static void mc_genmcl_px_endproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1836;
	msysc_m$print_startcon();
	R1 = tou64("PCL STACK NOT EMPTY");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PCL STACK NOT EMPTY");
	mc_libmcl_mgencomment(asu64(R1));
L1836:
	R1 = 0;
	R2 = 0;
	R3 = 2;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endprog(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_istatic(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_zstatic(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_data(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 opc;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1842;
	asu64(R1) = p;
	mc_auxmcl_do_blockdata(asu64(R1));
	goto L1840;
L1842:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1844;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1845;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1846;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1847;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1848;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1849;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1850;
	goto L1851;
L1844:
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1843;
L1845:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1843;
L1846:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1843;
L1847:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1843;
L1848:
	asu64(R1) = p;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R2), asi64(R1));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1843;
L1849:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1843;
L1850:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1843;
L1851:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("db/dq optype? #");
	pc_api_merror(asu64(R2), asu64(R1));
L1843:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1853;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1854;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1855;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1856;
	goto L1857;
L1853:
	R1 = 116;
	opc = asi64(R1);
	goto L1852;
L1854:
	R1 = 117;
	opc = asi64(R1);
	goto L1852;
L1855:
	R1 = 118;
	opc = asi64(R1);
	goto L1852;
L1856:
	R1 = 119;
	opc = asi64(R1);
	goto L1852;
L1857:
	msysc_m$print_startcon();
	R1 = tou64("P.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STRPMODE(P.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("DATA/not 1248");
	pc_api_merror(asu64(R2), asu64(R1));
L1852:
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1840:
	return;
}

static void mc_genmcl_px_label(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_load(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_stackmcl_pushpcl(asu64(R1));
	return;
}

static void mc_genmcl_px_store(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 d;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1862;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1861;
L1862:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 6;
	asu64(R2) = d;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	asu64(R3) = d;
	R4 = 72;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 5;
	if (asi64(R3) != asi64(R4)) goto L1864;
	R3 = 11;
	goto L1863;
L1864:
	R3 = 14;
L1863:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L1861:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_add(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1867;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1869;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1869;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 52;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1868;
L1869:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1868:
	goto L1866;
L1867:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 65;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1866:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_sub(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1872;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1874;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1874;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1873;
L1874:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1873:
	goto L1871;
L1872:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 67;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1871:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_mul(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	i64 x;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1877;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1879;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1878;
L1879:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1878:
	goto L1876;
L1877:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 69;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1876:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_div(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 71;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_eval(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_widen(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1884;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1884;
	R1 = 0;
	R2 = 5;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1886;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1886:
	goto L1883;
L1884:
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = (u64)&pc_tables_psigned;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	if (!asu8(R3)) goto L1888;
	R3 = 18;
	goto L1887;
L1888:
	R3 = 19;
L1887:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1883:
	return;
}

static void mc_genmcl_px_jump(u64 p) {
    u64 R1, R2, R3; 
	i64 labno;
	u64 q;
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	goto L1891;
L1890:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
L1891:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1890;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1894;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1895;
	goto L1896;
L1894:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1898;
	goto L1889;
L1898:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) != asi64(R2)) goto L1900;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1900;
	goto L1889;
L1900:
	goto L1893;
L1895:
	R1 = 0;
	asu64(R2) = q;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1893;
L1896:
L1893:
	R1 = 0;
	asi64(R2) = labno;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1889:
	return;
}

static void mc_genmcl_px_ijump(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_neg(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1904;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1903;
L1904:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
L1903:
	return;
}

static void mc_genmcl_px_abs(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 lx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1907;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1906;
L1907:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L1906:
	return;
}

static void mc_genmcl_px_bitnot(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_not(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 cx;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1912;
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = cx;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1914;
	R3 = 5;
	goto L1913;
L1914:
	R3 = 4;
L1913:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1911;
L1912:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1916;
	R3 = 5;
	goto L1915;
L1916:
	R3 = 4;
L1915:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-3)) = asu8(R1);
L1911:
	return;
}

static void mc_genmcl_px_sqr(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1919;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1918;
L1919:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 69;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1918:
	return;
}

static void mc_genmcl_px_sqrt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 63;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_jumpcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 mcond;
	u64 ax;
	u64 bx;
	u64 lx;
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	lx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1923;
	R1 = tou64("");
	R2 = tou64("JUMPCC/BLOCK");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1922;
L1923:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1925;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1927;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1927;
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1928;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1927;
L1928:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1926;
L1927:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1930;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
L1930:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1926:
	goto L1924;
L1925:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1924:
	R1 = 0;
	asu64(R2) = lx;
	asi64(R3) = mcond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1932;
	mc_stackmcl_poppcl();
L1932:
L1922:
	return;
}

static void mc_genmcl_px_jumpt(u64 p) {
    u64 R1, R2; 
	R1 = 5;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_jumpf(u64 p) {
    u64 R1, R2; 
	R1 = 4;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitand(u64 p) {
    u64 R1, R2; 
	R1 = 38;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitor(u64 p) {
    u64 R1, R2; 
	R1 = 39;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxor(u64 p) {
    u64 R1, R2; 
	R1 = 40;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shl(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shr(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1941;
	R1 = 44;
	goto L1940;
L1941:
	R1 = 45;
L1940:
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_retproc(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mclprocentry;
	asu64(R2) = mc_decls_mccodex;
	if (asu64(R1) != asu64(R2)) goto L1944;
	R1 = tou64("---");
	mc_libmcl_mgencomment(asu64(R1));
L1944:
	asu64(R1) = p;
	mc_auxmcl_do_procentry(asu64(R1));
	mc_auxmcl_do_procexit();
	return;
}

static void mc_genmcl_px_retfn(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1947;
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 6;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1947:
	asu64(R1) = p;
	mc_genmcl_px_retproc(asu64(R1));
	return;
}

static void mc_genmcl_px_setcall(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	asi64(R1) = mc_decls_ncalldepth;
	R2 = 16;
	if (asi64(R1) < asi64(R2)) goto L1950;
	R1 = tou64("");
	R2 = tou64("Too many nested calls");
	pc_api_merror(asu64(R2), asu64(R1));
L1950:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1952;
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1951;
L1952:
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asi64(R2) = mc_decls_mstackdepth;
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1951:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callblocksize;
	asi64(R3) = mc_decls_ncalldepth;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1954;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
L1954:
	return;
}

static void mc_genmcl_px_setarg(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_callargmode;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*32-32;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*128-128;
	asi64(R3) = n;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1957;
	R1 = 6;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1956;
L1957:
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1956:
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L1959;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	mc_stackmcl_pushopnd(asi64(R3), asi64(R2), asi64(R1));
	goto L1958;
L1959:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1960;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*128-128;
	asi64(R3) = n;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
L1960:
L1958:
	return;
}

static void mc_genmcl_px_callp(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 nargs;
	i64 nregargs;
	i64 slots;
	i64 isptr;
	i64 shadow;
	i64 blockret;
	i64 av_1;
	R1 = 0;
	isptr = asi64(R1);
	R1 = 0;
	shadow = asi64(R1);
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	nargs = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nregargs = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1964;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L1963;
L1964:
	R1 = 1;
	isptr = asi64(R1);
L1963:
	R1 = 0;
	asi64(R2) = isptr;
	asu64(R3) = p;
	R4 = 20;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R4) = nregargs;
	mc_auxmcl_do_pushlowargs(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1966;
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L1968;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	goto L1967;
L1968:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L1967:
	goto L1965;
L1966:
	asi64(R1) = nargs;
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	slots = asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
L1965:
	asi64(R1) = isptr;
	if (!asi64(R1)) goto L1970;
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L1969;
L1970:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1969:
	asi64(R1) = nregargs;
	asi64(R2) = blockret;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1973;
L1971:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L1971;
L1973:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L1975;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L1975:
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1977;
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
L1977:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mc_genmcl_px_jumpret(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1980;
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1982;
	R1 = 1;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
L1982:
L1980:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_jumpretm(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	i64 reg;
	i64 av_1;
	i64 av_2;
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1986;
L1984:
	R1 = 0;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1984;
L1986:
	R1 = 1;
	reg = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1989;
L1987:
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1991;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1991;
	R1 = 11;
	reg = asi64(R1);
L1991:
	asi64(R1) = reg;
	mc_stackmcl_movetoreg(asi64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	if (--asi64(av_2)) goto L1987;
L1989:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_startmx(u64 p) {
    u64 R1; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	return;
}

static void mc_genmcl_px_resetmx(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L1995;
	mc_stackmcl_poppcl();
L1995:
	return;
}

static void mc_genmcl_px_stop(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 11;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = tou64("exit*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_incrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_incrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadincr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loaddecr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_forup(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 14;
	R2 = 28;
	R3 = 52;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fordown(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 13;
	R2 = 29;
	R3 = 53;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_iload(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 px;
	u64 nextpcl;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2007;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2009;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L2008;
L2009:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L2008:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L2011;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L2010;
L2011:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L2010:
	goto L2006;
L2007:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
L2006:
	return;
}

static i64 mc_genmcl_getsharereg(u64 ax, i64 mode) {
    u64 R1, R2; 
	u8 reg;
	u8 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	reg = asu8(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	regix = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2014;
	R1 = 0;
	goto L2012;
L2014:
	asu8(R1) = reg;
	if (!asu8(R1)) goto L2016;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = reg;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2017;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2016;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2016;
L2017:
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	goto L2012;
	goto L2015;
L2016:
	asu8(R1) = regix;
	if (!asu8(R1)) goto L2018;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = regix;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2019;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2018;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2018;
L2019:
	asu8(R1) = regix;
	R1 = toi64(tou8(R1));
	goto L2012;
L2018:
L2015:
	R1 = 0;
	goto L2012;
L2012:
	return asi64(R1);
}

static void mc_genmcl_px_iloadx(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 z;
	u64 nextpcl;
	u64 ax;
	u64 bx;
	u64 px;
	u64 fx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2022;
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L2021;
L2022:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L2024;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L2023;
L2024:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L2023:
L2021:
	return;
}

static void mc_genmcl_px_istore(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 bx;
	u64 px;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2027;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L2026;
L2027:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L2026:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2029;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L2028;
L2029:
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2028:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_istorex(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 px;
	u64 z;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2032;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	cx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = cx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L2031;
L2032:
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2031:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_storem(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 z;
	u64 dblock;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2035;
	R1 = tou64("");
	R2 = tou64("Storem not 16");
	pc_api_merror(asu64(R2), asu64(R1));
L2035:
	R1 = 16;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	R2 = 0;
	R3 = 8;
	asu64(R4) = px;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = px;
	R2 = 6;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_addpx(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 cx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	cx = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subpx(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 scale;
	i64 extra;
	i64 offset;
	u64 ax;
	u64 bx;
	u64 z;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2039;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R3) = extra;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2038;
L2039:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = scale;
	asu64(R2) = bx;
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2041;
	asi64(R1) = scale;
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
L2041:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = extra;
	if (!asi64(R1)) goto L2043;
	msysc_m$print_startcon();
	R1 = tou64("EXTRA=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = extra;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUBREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L2043:
L2038:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_to(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 ax;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	q = asu64(R1);
	R1 = 6;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_iswap(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 qx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	qx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2047;
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qx;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = qx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2046;
L2047:
	R1 = tou64("");
	R2 = tou64("swap/block");
	pc_api_merror(asu64(R2), asu64(R1));
L2046:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swapstk(u64 p) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_noperands;
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_labeldef(u64 p) {
    u64 R1, R2; 
	struct $B5 str;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(":");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_addto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 65;
	R2 = 28;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 67;
	R2 = 29;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_multo(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 cx;
	u64 x;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2054;
	R1 = 69;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2052;
L2054:
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2056;
	R1 = tou64("");
	R2 = tou64("multo/byte");
	pc_api_merror(asu64(R2), asu64(R1));
L2056:
	R1 = 0;
	R2 = 10;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	x = asu64(R2);
	if (!asu64(R1)) goto L2058;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = cx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L2057;
L2058:
	asu64(R1) = bx;
	asu64(R2) = cx;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2057:
	asu64(R1) = cx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2052:
	return;
}

static void mc_genmcl_px_bitandto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 38;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 39;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 40;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shlto(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shrto(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2065;
	R1 = 44;
	goto L2064;
L2065:
	R1 = 45;
L2064:
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fix(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 fx;
	u64 ax;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&pc_tables_pmin;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = fx;
	asu64(R2) = ax;
	R3 = 84;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_float(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 fx;
	i64 lab;
	i64 lab2;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2069;
	R1 = tou64("");
	R2 = tou64("float/short");
	pc_api_merror(asu64(R2), asu64(R1));
L2069:
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2071;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 86;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2070;
L2071:
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L2072;
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab2 = asi64(R1);
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 12;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab2;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	asi64(R1) = mc_decls_labmask63;
	if (asi64(R1)) goto L2074;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_labmask63 = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_laboffset64 = asi64(R1);
L2074:
	asi64(R1) = mc_decls_labmask63;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_laboffset64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = fx;
	R3 = 66;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab2;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
// mc_genmcl.px_float.reduce:
L2075:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2077;
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2077:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2070;
L2072:
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2075;
L2070:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_idiv(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_irem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_idivrem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 2;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_clear(u64 p) {
    u64 R1, R2; 
	u64 ax;
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = ax;
	mc_auxmcl_clearblock(asu64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 n;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2084;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L2086;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2085;
L2086:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUB/REF NOT POWER OF xx");
	pc_api_merror(asu64(R2), asu64(R1));
L2085:
L2084:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_switch(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 elselab;
	i64 reg;
	u64 ax;
	u64 bx;
	u64 ax2;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = mc_decls_currpcl;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	elselab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L2089;
	asu64(R1) = ax;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	ax2 = asu64(R3);
	R3 = 18;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax2;
	ax = asu64(R1);
L2089:
	asi64(R1) = minlab;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2091;
	R1 = 10;
	asi64(R2) = minlab;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2091:
	R1 = 10;
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = elselab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 3;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2093;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	R1 = 6;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2092;
L2093:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2092:
	mc_stackmcl_poppcl();
	R1 = 1;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_switchu(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 reg;
	u64 ax;
	u64 bx;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2096;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2095;
L2096:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2095:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swlabel(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endsw(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fwiden(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 8;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 89;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_fnarrow(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_truncate(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = pmode2;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2103;
	asu64(R1) = ax;
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = (u64)&mc_decls_ploadop;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2103:
	return;
}

static void mc_genmcl_px_typepun(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_unload(u64 p) {
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_loadbit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 z;
	i64 i;
	i64 m;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2108;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2110;
	R2 = 31;
	if (asi64(R1) > asi64(R2)) goto L2110;
	R1 = 5;
	goto L2109;
L2110:
	R1 = 6;
L2109:
	m = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = i;
	if (!asi64(R1)) goto L2112;
	asi64(R1) = m;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2114;
	goto L2115;
L2114:
L2112:
	goto L2107;
L2108:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2117;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2117:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2119;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2119:
L2107:
	R1 = 5;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
// mc_genmcl.px_loadbit.skip:
L2115:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_assem(u64 p) {
    u64 R1, R2; 
	asu64(R1) = pc_api_idomcl_assem;
	if (!asu64(R1)) goto L2122;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_idomcl_assem;
	((F18)R2)(asu64(R1));
	goto L2121;
L2122:
	R1 = tou64("");
	R2 = tou64("No Assem handler");
	pc_api_merror(asu64(R2), asu64(R1));
L2121:
	return;
}

static void mc_genmcl_px_sin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("sin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_cos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("cos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_tan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("tan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_asin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("asin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_acos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("acos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("atan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log10(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log10*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_exp(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("exp*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_round(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("round*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_floor(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("floor*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_ceil(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("ceil*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan2(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("atan2*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fmod(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("fmod*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_setcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 cond;
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2139;
	R1 = tou64("");
	R2 = tou64("setcc/block");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2138;
L2139:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2140;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2142;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
L2142:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	cx = asu64(R1);
	goto L2138;
L2140:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	R1 = 10;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
L2138:
	R1 = 0;
	asu64(R2) = cx;
	asi64(R3) = cond;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_min(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2145;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2147;
	R1 = 15;
	goto L2146;
L2147:
	R1 = 7;
L2146:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L2144;
L2145:
	R1 = 112;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L2144:
	return;
}

static void mc_genmcl_px_max(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2150;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2152;
	R1 = 12;
	goto L2151;
L2152:
	R1 = 2;
L2151:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L2149;
L2150:
	R1 = 113;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L2149:
	return;
}

static void mc_genmcl_px_power(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 d;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2155;
	R1 = 82;
	asu64(R1) = mc_auxmcl_gethostfn(asi64(R1));
	d = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	asu64(R2) = d;
	asu64(R3) = p;
	mc_auxmcl_do_host(asu64(R3), asu64(R2), asi64(R1));
	goto L2154;
L2155:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("pow*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
L2154:
	return;
}

static void mc_genmcl_px_minto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2158;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2160;
	R2 = 14;
	goto L2159;
L2160:
	R2 = 6;
L2159:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L2157;
L2158:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L2157:
	return;
}

static void mc_genmcl_px_maxto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2163;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2165;
	R2 = 13;
	goto L2164;
L2165:
	R2 = 3;
L2164:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L2162;
L2163:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L2162:
	return;
}

static void mc_genmcl_px_negto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2168;
	R1 = 0;
	asu64(R2) = px;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2167;
L2168:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	fx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = fx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = fx;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
	asu64(R1) = fx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2167:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_absto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 lx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2171;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2170;
L2171:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L2170:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_addpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2174;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2173;
L2174:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2173:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2177;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2176;
L2177:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L2179;
	R1 = tou64("");
	R2 = tou64("SUBTOREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L2179:
L2176:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_divto(u64 p) {
    u64 R1, R2; 
	R1 = 71;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitnotto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu64(R2) = px;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_notto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = px;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	R3 = 5;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_sign(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 lx1;
	u64 lx2;
	u64 lx3;
	u8 gtop;
	u8 ltop;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2186;
	R1 = 7;
	gtop = asu8(R1);
	R1 = 2;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asr64(R2) = 0.000000000000000000e+000;
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2185;
L2186:
	R1 = 15;
	gtop = asu8(R1);
	R1 = 12;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2185:
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx1 = asu64(R3);
	asu8(R3) = gtop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx2 = asu64(R3);
	asu8(R3) = ltop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx3 = asu64(R3);
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx1;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = bx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx2;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = bx;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadbf(u64 p) {
    u64 R1, R2, R3; 
	u64 y;
	u64 z;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	y = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	z = asu64(R1);
	asu64(R1) = y;
	if (!asu64(R1)) goto L2189;
	asu64(R1) = z;
	if (!asu64(R1)) goto L2189;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	mc_auxmcl_do_loadbf_const(asu64(R3), asi64(R2), asi64(R1));
	goto L2188;
L2189:
	asu64(R1) = p;
	mc_auxmcl_do_loadbf_var(asu64(R1));
L2188:
	return;
}

static void mc_genmcl_px_storebit(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebit(asu64(R1));
	return;
}

static void mc_genmcl_px_storebf(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebf(asu64(R1));
	return;
}

static void mc_genmcl_px_loadall(u64 p) {
	mc_stackmcl_checkallloaded();
	return;
}

static void mc_genmcl_px_setjmp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 lab;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = lab;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	R2 = 0;
	R3 = 8;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dframeopnd;
	R2 = 0;
	R3 = 16;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	asu64(R1) = p;
	mc_stackmcl_freeworkregs(asu64(R1));
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	return;
}

static void mc_genmcl_px_longjmp(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 16;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	R1 = 1;
	mc_stackmcl_swapopndregs(asi64(R1));
	R1 = 0;
	asu64(R2) = cx;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_initdswx(u64 p) {
	return;
}

static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf) {
    u64 R1, R2, R3; 
	struct $B17 params;
	struct $B17 xparams;
	struct $B17 leafparams;
	struct $B17 xleafparams;
	u32 leafparamno;
	u32 xleafparamno;
	struct $B16 locals;
	struct $B16 xlocals;
	i64 nparams;
	i64 nxparams;
	i64 nleafparams;
	i64 nxleafparams;
	i64 nlocals;
	i64 nxlocals;
	i64 n;
	i64 reg;
	i64 xreg;
	i64 nl;
	i64 np;
	i64 nlx;
	i64 npx;
	u64 d;
	i64 i;
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nxparams = asi64(R1);
	R1 = 0;
	nleafparams = asi64(R1);
	R1 = 0;
	nxleafparams = asi64(R1);
	R1 = 0;
	nlocals = asi64(R1);
	R1 = 0;
	nxlocals = asi64(R1);
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = mc_decls_maxxregvars;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2198;
	goto L2196;
L2198:
	asi64(R1) = skipparams;
	if (asi64(R1)) goto L2200;
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L2204;
L2201:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2206;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2206;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2206;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2206;
	asi64(R1) = isleaf;
	if (asi64(R1)) goto L2208;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2210;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2212;
	asu64(R1) = d;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2212:
	goto L2209;
L2210:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2213;
	asi64(R1) = nxparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2215;
	asu64(R1) = d;
	R2 = (u64)&xparams;
	R3 = (u64)&nxparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2215:
L2213:
L2209:
	goto L2207;
L2208:
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2217;
	asi64(R1) = nleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2219;
	asu64(R1) = d;
	R2 = (u64)&leafparams;
	R3 = (u64)&nleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&leafparamno;
	asi64(R3) = nleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2219:
	goto L2216;
L2217:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2220;
	asi64(R1) = nxleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2222;
	asu64(R1) = d;
	R2 = (u64)&xleafparams;
	R3 = (u64)&nxleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&xleafparamno;
	asi64(R3) = nxleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2222:
L2220:
L2216:
L2207:
L2206:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2204:
	asu64(R1) = d;
	if (asu64(R1)) goto L2201;
L2200:
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2226;
L2223:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2228;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2228;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2228;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2230;
	asi64(R1) = nlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L2232;
	asu64(R1) = d;
	R2 = (u64)&locals;
	R3 = (u64)&nlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2232:
	goto L2229;
L2230:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2233;
	asi64(R1) = nxlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L2233;
	asu64(R1) = d;
	R2 = (u64)&xlocals;
	R3 = (u64)&nxlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2233:
L2229:
L2228:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2226:
	asu64(R1) = d;
	if (asu64(R1)) goto L2223;
	asi64(R1) = nlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2235;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	np = asi64(R1);
	R1 = 0;
	nl = asi64(R1);
	goto L2234;
L2235:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2236;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nl = asi64(R1);
	R1 = 0;
	np = asi64(R1);
	goto L2234;
L2236:
	asi64(R1) = nlocals;
	nl = asi64(R1);
	asi64(R1) = nparams;
	np = asi64(R1);
	asi64(R1) = np;
	asi64(R2) = nl;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2238;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2240;
	asi64(R1) = np;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2240;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2240:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2242;
	asi64(R1) = n;
	R2 = (u64)&nl;
	*toi64p(R2) -= asi64(R1);
L2242:
L2238:
L2234:
	R1 = 4;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nl;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2245;
L2243:
	R1 = (u64)&locals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= nl) goto L2243;
L2245:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = np;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2248;
L2246:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= np) goto L2246;
L2248:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2251;
L2249:
	R1 = (u64)&leafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&leafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2253;
	R1 = 1;
	pc_decls_r10used = asu8(R1);
L2253:
	asi64(R1) = reg;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2255;
	R1 = 1;
	pc_decls_r11used = asu8(R1);
L2255:
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nleafparams) goto L2249;
L2251:
	asi64(R1) = nxlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2257;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npx = asi64(R1);
	R1 = 0;
	nlx = asi64(R1);
	goto L2256;
L2257:
	asi64(R1) = nxparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2258;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nlx = asi64(R1);
	R1 = 0;
	npx = asi64(R1);
	goto L2256;
L2258:
	asi64(R1) = nxlocals;
	nlx = asi64(R1);
	asi64(R1) = nxparams;
	npx = asi64(R1);
	asi64(R1) = npx;
	asi64(R2) = nlx;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2260;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2262;
	asi64(R1) = npx;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2262;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2262:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2264;
	asi64(R1) = n;
	R2 = (u64)&nlx;
	*toi64p(R2) -= asi64(R1);
L2264:
L2260:
L2256:
	R1 = 16;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2267;
L2265:
	R1 = (u64)&xlocals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= nlx) goto L2265;
L2267:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = npx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2270;
L2268:
	R1 = (u64)&xparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= npx) goto L2268;
L2270:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nxleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2273;
L2271:
	R1 = (u64)&xleafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&xleafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nxleafparams) goto L2271;
L2273:
L2196:
	return;
}

static void mc_auxmcl_initproc(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 e;
	u64 pinfi;
	i64 reg;
	i64 xreg;
	i64 n;
	i64 r;
	i64 npregs;
	i64 av_1;
	i64 av_2;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isregvar;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isxregvar;
	memset(R1, 0, 16);
	R1 = 3;
	mc_decls_nworkregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	mc_decls_maxxregvars = asi64(R2);
	mc_decls_maxregvars = asi64(R1);
	R1 = 0;
	npregs = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2276;
	R1 = 10;
	mc_decls_nworkregs = asi64(R1);
	R1 = 12;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 4;
	r = asi64(R1);
L2277:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 10) goto L2277;
	R1 = 7;
	r = asi64(R1);
L2280:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 16) goto L2280;
	goto L2275;
L2276:
	R1 = 4;
	asu64(R2) = pc_decls_currfunc;
	R3 = 112;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = pc_decls_pinfo;
	R4 = 4;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) = Max(asi64(R2), asi64(R3));
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npregs = asi64(R1);
	R1 = 4;
	mc_decls_nworkregs = asi64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2284;
	R1 = (u64)&mc_decls_nworkregs;
	(*toi64p(R1)) += 1;
L2284:
	R1 = 5;
	mc_decls_nworkxregs = asi64(R1);
	asi64(R1) = mc_decls_nworkregs;
	R2 = 3;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = npregs;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L2286;
	asi64(R1) = n;
	if (!asi64(R1)) goto L2286;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = npregs;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2288;
	asi64(R1) = n;
	if (!asi64(R1)) goto L2288;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2288:
L2286:
	R1 = 10;
	r = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2291;
L2289:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_1)) goto L2289;
L2291:
	R1 = 7;
	r = asi64(R1);
	asi64(R1) = mc_decls_nworkxregs;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2294;
L2292:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_2)) goto L2292;
L2294:
L2275:
	R1 = 4;
	r = asi64(R1);
L2295:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2299;
	R1 = (u64)&mc_decls_maxregvars;
	(*toi64p(R1)) += 1;
L2299:
	r += 1; if (r <= 10) goto L2295;
	R1 = 7;
	r = asi64(R1);
L2300:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2304;
	R1 = (u64)&mc_decls_maxxregvars;
	(*toi64p(R1)) += 1;
L2304:
	r += 1; if (r <= 16) goto L2300;
	R1 = (u64)&mc_decls_usedregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_usedxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_pcltempflags;
	memset(R1, 0, 50);
	R1 = 0;
	R2 = R1;
	pc_decls_r11used = asu8(R2);
	pc_decls_r10used = asu8(R1);
	R1 = 0;
	mc_decls_mstackdepth = asi64(R1);
	R1 = 0;
	mc_decls_noperands = asi64(R1);
	R1 = 0;
	R2 = R1;
	mc_genmcl_framebytes = asi64(R2);
	R2 = R1;
	mc_genmcl_paramoffset = asi64(R2);
	mc_genmcl_frameoffset = asi64(R1);
	R1 = 0;
	pc_decls_localshadow = asu8(R1);
	R1 = 0;
	mc_decls_nblocktemps = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2306;
	R1 = 8;
	R2 = tou64("$1x");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	asu64(R2) = e;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = e;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = pc_decls_currfunc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	pc_decls_blockretname = asu64(R1);
L2306:
	asu8(R1) = pc_decls_fregoptim;
	if (!asu8(R1)) goto L2309;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2308;
L2309:
	goto L2274;
L2308:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2311;
	goto L2274;
L2311:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_decls_currfunc;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (asu8(R2)) goto L2312;
	asu64(R2) = pc_decls_currfunc;
	R3 = 113;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2313;
L2312:
	R2 = 1;
	goto L2314;
L2313:
	R2 = 0;
L2314:
	mc_auxmcl_allocregvars(asi64(R2), asi64(R1));
L2274:
	return;
}

static void mc_auxmcl_do_procentry(u64 p) {
    u64 R1, R2, R3; 
	i64 retmode;
	i64 ntemps;
	i64 hasequiv;
	i64 offset;
	i64 size;
	i64 reg;
	u64 ax;
	u64 d;
	struct $B5 str;
	struct $B5 newname;
	i64 rr;
	i64 ff;
	i64 r;
	i64 i;
	asu64(R1) = mc_decls_mclprocentry;
	mc_auxmcl_setmclentry(asu64(R1));
	R1 = 0;
	R2 = R1;
	pc_decls_bxspill = asi64(R2);
	pc_decls_bspill = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2318;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2317;
L2318:
	R1 = 4;
	r = asi64(R1);
L2319:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2324;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2323;
L2324:
	R1 = (u64)&pc_decls_bspill;
	(*toi64p(R1)) += 1;
L2323:
	r += 1; if (r <= 10) goto L2319;
	R1 = 7;
	r = asi64(R1);
L2325:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2330;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2329;
L2330:
	R1 = (u64)&pc_decls_bxspill;
	(*toi64p(R1)) += 1;
L2329:
	r += 1; if (r <= 16) goto L2325;
L2317:
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2334;
L2331:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2336;
	R1 = tou64("");
	R2 = tou64("@PARAM");
	pc_api_merror(asu64(R2), asu64(R1));
L2336:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2338;
	asi64(R1) = mc_genmcl_paramoffset;
	R2 = 16;
	asi64(R1) += asi64(R2);
	asi64(R2) = pc_decls_bspill;
	asi64(R3) = pc_decls_bxspill;
	asi64(R2) += asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writeasm_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2337;
L2338:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2337:
	R1 = 8;
	R2 = (u64)&mc_genmcl_paramoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2334:
	asu64(R1) = d;
	if (asu64(R1)) goto L2331;
	asu64(R1) = pc_decls_currfunc;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	retmode = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2342;
L2339:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2344;
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	size = asi64(R1);
L2344:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2346;
	goto L2340;
L2346:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2348;
	R1 = 1;
	hasequiv = asi64(R1);
	goto L2347;
L2348:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2349;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2347;
L2349:
	asi64(R1) = size;
	asi64(R1) = mc_libmcl_roundsizetg(asi64(R1));
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writeasm_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2347:
L2340:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2342:
	asu64(R1) = d;
	if (asu64(R1)) goto L2339;
	R1 = 0;
	ntemps = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L2350:
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2354;
	R1 = (u64)&ntemps;
	(*toi64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&mc_decls_pcltempopnds;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ax = asu64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = ax;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asi64(R2) = i;
	asu64(R3) = pc_decls_currfunc;
	asu64(R2) = mc_writeasm_gettempname(asu64(R3), asi64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2354:
	i += 1; if (i <= 50) goto L2350;
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2356;
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (asi16(R1)) goto L2359;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2358;
L2359:
	R1 = tou64("");
	R2 = tou64("Threaded proc has locals/params");
	pc_api_merror(asu64(R2), asu64(R1));
L2358:
	asi64(R1) = ntemps;
	if (!asi64(R1)) goto L2361;
	R1 = tou64("");
	R2 = tou64("Threaded proc has temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2361:
	asu64(R1) = mc_auxmcl_resetmclentry();
	goto L2315;
L2356:
	asi64(R1) = mc_genmcl_frameoffset;
	asi64(R1) = -asi64(R1);
	mc_genmcl_framebytes = asi64(R1);
	asi64(R1) = pc_decls_bspill;
	asi64(R2) = pc_decls_bxspill;
	asi64(R1) += asi64(R2);
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2363;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L2365;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2365:
	goto L2362;
L2363:
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2367;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2367:
L2362:
	asu8(R1) = pc_decls_localshadow;
	if (!asu8(R1)) goto L2369;
	R1 = 32;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2369:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L2371;
	R1 = 4;
	r = asi64(R1);
L2372:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2377;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2376;
L2377:
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2376:
	r += 1; if (r <= 10) goto L2372;
L2371:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L2379;
	R1 = 6;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 7;
	r = asi64(R1);
L2380:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2385;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2384;
L2385:
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2384:
	r += 1; if (r <= 16) goto L2380;
L2379:
	R1 = tou64("?]]");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_auxmcl_mclframesetup = asu64(R1);
	mc_auxmcl_spillparams();
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_auxmcl_resetmclentry();
L2315:
	return;
}

static void mc_auxmcl_do_procexit() {
    u64 R1, R2, R3; 
	u64 ax;
	i64 offset;
	i64 r;
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2388;
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2386;
L2388:
	asu64(R1) = mc_auxmcl_mclframesetup;
	mc_auxmcl_setmclentryf(asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L2391;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2391;
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2390;
L2391:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2393;
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_pushstack(asi64(R1));
	goto L2392;
L2393:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L2395;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
L2395:
L2392:
L2390:
	asu64(R1) = mc_auxmcl_resetmclentryf();
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L2398;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2398;
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2397;
L2398:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2400;
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_popstack(asi64(R1));
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2399;
L2400:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L2402;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_popstack(asi64(R1));
L2402:
L2399:
L2397:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L2404;
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 16;
	r = asi64(R1);
L2405:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2409;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	R2 = 8;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2409:
	r += -1; if (r >= 7) goto L2405;
L2404:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L2411;
	R1 = 10;
	r = asi64(R1);
L2412:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2416;
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2416:
	r += -1; if (r >= 4) goto L2412;
L2411:
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2386:
	return;
}

static void mc_auxmcl_spillparams() {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 d;
	u64 ax;
	i64 offset;
	i64 regoffset;
	i64 xregoffset;
	i64 firstoffset;
	i64 i;
	R1 = 16;
	offset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2419;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	firstoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L2422;
L2420:
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asi64(R4) = i;
	R5 = 8;
	asi64(R4) *= asi64(R5);
	asi64(R5) = firstoffset;
	asi64(R4) += asi64(R5);
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = i;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	i += 1; if (i <= 3) goto L2420;
L2422:
L2419:
	goto L2426;
L2423:
	asi64(R1) = regoffset;
	R2 = 3;
	if (asi64(R1) <= asi64(R2)) goto L2428;
	goto L2425;
L2428:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2430;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2432;
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asu64(R4) = d;
	R5 = 76;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2434;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2435;
	goto L2436;
L2434:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2433;
L2435:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 16;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2433;
L2436:
	R1 = 10;
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2433:
	goto L2431;
L2432:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2437;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2439;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L2441;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 8;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2441:
	goto L2438;
L2439:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2442;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2442:
L2438:
L2437:
L2431:
L2430:
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&regoffset;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2426:
	asu64(R1) = d;
	if (asu64(R1)) goto L2423;
L2425:
	return;
}

static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2445;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2444;
L2445:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2444:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_bitwise(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shift(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 y;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	y = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2449;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2449;
	R1 = 10;
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2448;
L2449:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2451;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2451:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2453;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2453:
L2448:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_setmclentry(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mce_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentry() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mce_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mce_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mce_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L2455;
L2455:
	return asu64(R1);
}

static void mc_auxmcl_setmclentryf(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mcf_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentryf() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mcf_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mcf_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mcf_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L2457;
L2457:
	return asu64(R1);
}

static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr, i64 pstack) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 j;
	i64 k;
	i64 nextireg;
	i64 nextxreg;
	i64 mode;
	i64 imode;
	i64 blockret;
	u64 dblock;
	i64 av_1;
	i64 i;
	asi64(R1) = nargs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2460;
	goto L2458;
L2460:
	asi64(R1) = pstack;
	if (!asi64(R1)) goto L2462;
	R1 = 0;
	blockret = asi64(R1);
	goto L2461;
L2462:
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
L2461:
	R1 = 11;
	nextireg = asi64(R1);
	R1 = 1;
	nextxreg = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = nargs;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) < asi64(R2)) goto L2465;
L2463:
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = k;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2467;
	asi64(R1) = blockret;
	if (!asi64(R1)) goto L2467;
	R1 = (u64)&mc_decls_callblocksize;
	asi64(R2) = mc_decls_ncalldepth;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2466;
L2467:
	asi64(R1) = i;
	asi64(R2) = isptr;
	asi64(R1) -= asi64(R2);
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	j = asi64(R1);
	asi64(R1) = pstack;
	if (!asi64(R1)) goto L2469;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = j;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	goto L2468;
L2469:
	R1 = (u64)&mc_decls_callargmode;
	asi64(R2) = mc_decls_ncalldepth;
	R1 += (i64)R2*32-32;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L2468:
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2471;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2472;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2472;
	goto L2473;
L2471:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = k;
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*128-128;
	asi64(R3) = k;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(tou32(R2));
	asu64(R3) = ax;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
	goto L2470;
L2472:
	asi64(R1) = nextxreg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L2475;
	asi64(R1) = k;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L2475;
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2477;
	R1 = 5;
	goto L2476;
L2477:
	R1 = 6;
L2476:
	imode = asi64(R1);
	asi64(R1) = mode;
	asi64(R2) = nextxreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = imode;
	asi64(R3) = nextireg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2475:
	goto L2470;
L2473:
// mc_auxmcl.do_pushlowargs.doint:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
L2470:
L2466:
	R1 = (u64)&nextireg;
	(*toi64p(R1)) += 1;
	R1 = (u64)&nextxreg;
	(*toi64p(R1)) += 1;
	i += -1; if (i >= av_1) goto L2463;
L2465:
L2458:
	return;
}

static void mc_auxmcl_do_getretvalue(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 xreg;
	i64 i;
	i64 n;
	i64 m;
	struct $B1 modes;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L2481;
	R1 = 0;
	n = asi64(R1);
	goto L2483;
L2482:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&modes;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L2483:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2482;
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2487;
L2485:
	R1 = (u64)&modes;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2489;
	R1 = (u64)&mc_decls_multxregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L2488;
L2489:
	R1 = (u64)&mc_decls_multregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
L2488:
	asi64(R2) = m;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	i += -1; if (i >= 1) goto L2485;
L2487:
	goto L2480;
L2481:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2490;
	R1 = 1;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
L2490:
L2480:
	return;
}

static i64 mc_auxmcl_ismemaddr(i64 n) {
    u64 R1, R2; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2493;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2493;
	R1 = 1;
	goto L2491;
L2493:
	R1 = 0;
	goto L2491;
L2491:
	return asi64(R1);
}

static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 mx;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2496;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2495;
L2496:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2495:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2499;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2498;
L2499:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2498:
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2502;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2501;
L2502:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2501:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 r;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 mx;
	i64 reg;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	r = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2505;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2507;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2506;
L2507:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2506:
	asu64(R1) = mx;
	ax = asu64(R1);
	goto L2504;
L2505:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2509;
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2508;
L2509:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2508:
	asu64(R1) = ax;
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2504:
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2511;
	R1 = 10;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	goto L2510;
L2511:
	R1 = 6;
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	bx = asu64(R1);
L2510:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale) {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2515;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2515;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2515;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2514;
L2515:
	asi64(R1) = scale;
	goto L2512;
L2514:
	asi64(R1) = scale;
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	goto L2512;
L2512:
	return asi64(R1);
}

static void mc_auxmcl_mulimm(u64 ax, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 shifts;
	i64 m;
	u64 bx;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2518;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2519;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L2520;
	goto L2521;
L2518:
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	goto L2516;
	goto L2517;
L2519:
	goto L2516;
	goto L2517;
L2520:
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2516;
	goto L2517;
L2521:
L2517:
	R1 = 0;
	shifts = asi64(R1);
	asi64(R1) = n;
	m = asi64(R1);
	goto L2523;
L2522:
	R1 = 1;
	R2 = (u64)&m;
	*toi64p(R2) >>= asi64(R1);
	R1 = (u64)&shifts;
	(*toi64p(R1)) += 1;
L2523:
	asi64(R1) = m;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2522;
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2526;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2526:
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2528;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2529;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2529;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2529;
	goto L2530;
L2528:
	goto L2516;
	goto L2527;
L2529:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = m;
	R6 = 1;
	asi64(R5) -= asi64(R6);
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2527;
L2530:
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2532;
	R1 = 34;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_mccodex;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2531;
L2532:
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2534;
	R1 = 9;
	goto L2533;
L2534:
	R1 = 10;
L2533:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2531:
L2527:
L2516:
	return;
}

static u64 mc_auxmcl_do_addrmode(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 px;
	u64 ax;
	u64 bx;
	i64 scale;
	i64 extra;
	i64 offset;
	i64 reg;
	i64 regix;
	u64 d;
	u64 q;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2537;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
L2537:
	R1 = 0;
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2539;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2541;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2540;
L2541:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2542;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2540;
L2542:
	asi64(R1) = scale;
	R2 = 0;
	R3 = (u64)&mc_decls_pclmode;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2540:
	goto L2538;
L2539:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R1) = mc_auxmcl_ismemaddr(asi64(R1));
	if (!asi64(R1)) goto L2543;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2548;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2547;
L2548:
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2546;
L2547:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2545;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2545;
L2546:
	goto L2549;
L2545:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2551;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2550;
L2551:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2552;
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2550;
L2552:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 10;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2550:
	goto L2538;
L2543:
// mc_auxmcl.do_addrmode.skip:
L2549:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2554;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2553;
L2554:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2555;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2553;
L2555:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2553:
L2538:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = px;
	goto L2535;
L2535:
	return asu64(R1);
}

static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	i64 regix;
	u64 ax;
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2559;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2559;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2559;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2558;
L2559:
	asi64(R1) = reg;
	goto L2556;
L2558:
	asi64(R1) = mc_stackmcl_getworkireg();
	regix = asi64(R1);
	R1 = 10;
	asi64(R2) = regix;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2561;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 1;
	asi64(R6) = reg;
	asi64(R7) = reg;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
	goto L2560;
L2561:
	R1 = 10;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
L2560:
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = regix;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 10;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = regix;
	goto L2556;
L2556:
	return asi64(R1);
}

static void mc_auxmcl_dolea(u64 ax, u64 px) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = px;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2566;
	asu64(R2) = px;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2566;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2566;
	R1 = 1;
	goto L2567;
L2566:
	R1 = 0;
L2567:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2565;
	asu64(R1) = px;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2564;
L2565:
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2564:
	return;
}

static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 rx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2570;
	asi64(R1) = fopc;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2568;
L2570:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2568:
	return;
}

static void mc_auxmcl_do_binto_float(u64 p, i64 opc) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = cx;
	asi64(R3) = opc;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shiftnto(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 cx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2574;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2574;
	R1 = 10;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2573;
L2574:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2576;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2576:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2578;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2578:
L2573:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 q;
	i64 opc;
	i64 n;
	i64 shifts;
	u8 fdivto;
	i64 locyy;
	i64 loczz;
	R1 = 0;
	fdivto = asu8(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	locyy = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	loczz = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L2582;
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L2581;
L2582:
	R1 = (u64)&locyy;
	R2 = (u64)&loczz;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	fdivto = asu8(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2580;
L2581:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
L2580:
	asi64(R1) = loczz;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2584;
	asi64(R1) = isdiv;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2584;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2586;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2587;
	goto L2588;
L2586:
	R1 = tou64("");
	R2 = tou64("Divide by zero");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2585;
L2587:
	mc_stackmcl_poppcl();
	goto L2579;
	goto L2585;
L2588:
	asi64(R1) = n;
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	shifts = asi64(R1);
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2590;
	asu8(R1) = fdivto;
	if (asu8(R1)) goto L2590;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = issigned;
	if (!asi64(R3)) goto L2592;
	R3 = 44;
	goto L2591;
L2592:
	R3 = 45;
L2591:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L2579;
L2590:
L2585:
L2584:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	mc_auxmcl_saverdx();
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_auxmcl_fixdivopnds(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = issigned;
	if (!asi64(R1)) goto L2594;
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2596;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2597;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2598;
	goto L2599;
L2596:
	R1 = 57;
	goto L2595;
L2597:
	R1 = 56;
	goto L2595;
L2598:
	R1 = 55;
	goto L2595;
L2599:
	R1 = tou64("");
	R2 = tou64("div/u8");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
L2595:
	opc = asi64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 36;
	opc = asi64(R1);
	goto L2593;
L2594:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 37;
	opc = asi64(R1);
L2593:
	R1 = 0;
	asu64(R2) = bx;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = isdiv;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2601;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2602;
	goto L2603;
L2601:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2600;
L2602:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	mc_stackmcl_swapopndregs(asi64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2600;
L2603:
L2600:
	mc_auxmcl_restorerdx();
	asu8(R1) = fdivto;
	if (!asu8(R1)) goto L2605;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu64(R2) = bx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = bx;
	asu64(R2) = mc_stackmcl_makeopndind(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
L2605:
	asi64(R1) = isdiv;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2607;
	mc_stackmcl_poppcl();
L2607:
L2579:
	return;
}

static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz) {
    u64 R1, R2, R3; 
	i64 regx;
	i64 regy;
	i64 zop;
	u64 bx;
	u64 ax;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regx = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = loczz;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regy = asi64(R1);
	asi64(R1) = regx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2610;
	goto L2608;
L2610:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = regy;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2612;
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2608;
L2612:
	R1 = (u64)&mc_decls_regset;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2614;
	asu64(R1) = bx;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = regx;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = locyy;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2608;
L2614:
	asi64(R1) = mc_decls_noperands;
	zop = asi64(R1);
	asi64(R1) = zop;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2618;
L2615:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2620;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2620;
	goto L2617;
L2620:
	zop += -1; if (zop >= 1) goto L2615;
L2618:
	goto L2608;
L2617:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = zop;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
L2608:
	return;
}

static void mc_auxmcl_saverdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2623;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2623:
	return;
}

static void mc_auxmcl_restorerdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2626;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2626:
	return;
}

static void mc_auxmcl_clearblock(u64 ax, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 av_1;
	i64 i;
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2629;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L2629;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2632;
L2630:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2630;
L2632:
	goto L2628;
L2629:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2633;
	asi64(R1) = nwords;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2635;
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	goto L2634;
L2635:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	R3 = 4;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
L2636:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= 4) goto L2636;
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2634:
L2633:
L2628:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2640;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2642;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2642:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2644;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2644:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2646;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2646:
L2640:
	return;
}

static void mc_auxmcl_do_blockdata(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 d;
	i64 n;
	i64 nqwords;
	i64 nwords;
	i64 r;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2649;
	goto L2647;
L2649:
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2652;
L2650:
	R1 = 0;
	R2 = 10;
	R3 = (u64)&d;
	asu64(R4) = *tou64p(R3); *(tou64p(R3)) += 8; asu64(R3) = asu64(R4);
	asi64(R3) = *toi64p(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L2650;
L2652:
	asi64(R1) = n;
	asi64(R2) = nwords;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) -= asi64(R2);
	r = asi64(R1);
	asi64(R1) = r;
	if (!asi64(R1)) goto L2654;
	R1 = 66;
	asi64(R2) = r;
	asu64(R3) = d;
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
L2654:
	R1 = tou64("ENDDATA");
	mc_libmcl_mgencomment(asu64(R1));
L2647:
	return;
}

static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 axreg;
	u8 saved;
	i64 av_1;
	R1 = 0;
	saved = asu8(R1);
	asi64(R1) = n;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2657;
	R1 = 2;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2655;
L2657:
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2659;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2659;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 8;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2662;
L2660:
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2660;
L2662:
	goto L2658;
L2659:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2663;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asi64(R1) = savedest;
	if (!asi64(R1)) goto L2665;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	axreg = asi64(R1);
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	saved = asu8(R1);
L2665:
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	bx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2663:
L2658:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2667;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2669;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 4;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2669:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2671;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 2;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2671:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2673;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 1;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2673:
L2667:
	asu8(R1) = saved;
	if (!asu8(R1)) goto L2675;
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2675:
L2655:
	return;
}

static void mc_auxmcl_genstringtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_cstringlist;
	if (asu64(R1)) goto L2678;
	goto L2676;
L2678:
	R1 = tou64("String Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_kk0used;
	if (!asi64(R1)) goto L2680;
	R1 = 0;
	asi64(R2) = mc_decls_kk0used;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2680:
	asu64(R1) = mc_decls_cstringlist;
	p = asu64(R1);
	goto L2684;
L2681:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2684:
	asu64(R1) = p;
	if (asu64(R1)) goto L2681;
L2676:
	return;
}

static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype) {
    u64 R1, R2; 
	i64 i;
	i64 c;
	i64 seqlen;
	u64 seq;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L2687;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2687:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2689;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
	goto L2685;
L2689:
	R1 = 0;
	seqlen = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2692;
L2690:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L2695;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) >= asi64(R2)) goto L2695;
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2696;
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L2694;
L2696:
L2695:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2698;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
	R1 = 0;
	seqlen = asi64(R1);
L2698:
	asi64(R1) = c;
	mc_auxmcl_gendb(asi64(R1));
	goto L2693;
L2694:
	asi64(R1) = seqlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2700;
	R1 = 1;
	seqlen = asi64(R1);
	asu64(R1) = s;
	R2 = 1;
	R1 -= (i64)R2;
	seq = asu64(R1);
	goto L2699;
L2700:
	R1 = (u64)&seqlen;
	(*toi64p(R1)) += 1;
L2699:
L2693:
	if (--asi64(av_1)) goto L2690;
L2692:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2702;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
L2702:
	asi64(R1) = strtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2704;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2704:
L2685:
	return;
}

static void mc_auxmcl_gendb(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendbstring(u64 s, i64 length) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	R3 = 120;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendq(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_genrealtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_creallist;
	if (asu64(R1)) goto L2710;
	asu64(R1) = mc_decls_cr32list;
	if (asu64(R1)) goto L2710;
	goto L2708;
L2710:
	R1 = tou64("Real Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = mc_decls_creallist;
	p = asu64(R1);
	goto L2714;
L2711:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2716;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2715;
L2716:
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2715:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2714:
	asu64(R1) = p;
	if (asu64(R1)) goto L2711;
	R1 = tou64("Real32 Table");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_cr32list;
	p = asu64(R1);
	goto L2720;
L2717:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2722;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
    asr32(R3) = tor32(asr64(R3));
	asi32(R3) = asi32(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2721;
L2722:
	R1 = 0;
	R2 = 1;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2721:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2720:
	asu64(R1) = p;
	if (asu64(R1)) goto L2717;
L2708:
	return;
}

static void mc_auxmcl_genabsneg() {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_lababs32;
	asi64(R2) = mc_decls_lababs64;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg32;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg64;
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L2725;
	R1 = 16;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
L2725:
	asi64(R1) = mc_decls_lababs32;
	if (!asi64(R1)) goto L2727;
	R1 = tou64("lababs32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
L2727:
	asi64(R1) = mc_decls_lababs64;
	if (!asi64(R1)) goto L2729;
	R1 = tou64("lababs64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
L2729:
	asi64(R1) = mc_decls_labneg32;
	if (!asi64(R1)) goto L2731;
	R1 = tou64("labneg32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
L2731:
	asi64(R1) = mc_decls_labneg64;
	if (!asi64(R1)) goto L2733;
	R1 = tou64("labneg64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
L2733:
	asi64(R1) = mc_decls_labzero;
	if (!asi64(R1)) goto L2735;
	R1 = tou64("labzero");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labzero;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendq(asi64(R1));
L2735:
	asi64(R1) = mc_decls_labmask63;
	if (!asi64(R1)) goto L2737;
	R1 = tou64("mask63/offset64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labmask63;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_laboffset64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4890909195324358656;
	mc_auxmcl_gendq(asi64(R1));
L2737:
	return;
}

static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	R2 = 0;
	asu64(R3) = opname;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	asu64(R2) = d;
	R3 = 0;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs) {
    u64 R1, R2, R3, R4; 
	i64 slots;
	i64 av_1;
	asi64(R1) = nargs;
	mc_stackmcl_saveopnds(asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2742;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
	R1 = 1;
	slots = asi64(R1);
L2742:
	R1 = 1;
	R2 = 0;
	R3 = 0;
	asi64(R4) = nargs;
	mc_auxmcl_do_pushlowargs(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L2744;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	goto L2743;
L2744:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L2743:
	asu64(R1) = opname;
	if (!asu64(R1)) goto L2746;
	R1 = 0;
	asu64(R2) = opname;
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2745;
L2746:
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2745:
	asi64(R1) = nargs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2749;
L2747:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L2747;
L2749:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L2751;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L2751:
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
	return;
}

static void mc_auxmcl_do_max_int(i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = cond;
	R4 = 15;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_max_float(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asi64(R1) = mode;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asi64(R4) = mode;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_negreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2758;
	asi64(R1) = mc_decls_labneg64;
	if (asi64(R1)) goto L2760;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg64 = asi64(R1);
L2760:
	asi64(R1) = mc_decls_labneg64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 77;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2757;
L2758:
	asi64(R1) = mc_decls_labneg32;
	if (asi64(R1)) goto L2762;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg32 = asi64(R1);
L2762:
	asi64(R1) = mc_decls_labneg32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 76;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2757:
	return;
}

static void mc_auxmcl_do_absreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2765;
	asi64(R1) = mc_decls_lababs64;
	if (asi64(R1)) goto L2767;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs64 = asi64(R1);
L2767:
	asi64(R1) = mc_decls_lababs64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 79;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2764;
L2765:
	asi64(R1) = mc_decls_lababs32;
	if (asi64(R1)) goto L2769;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs32 = asi64(R1);
L2769:
	asi64(R1) = mc_decls_lababs32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 78;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2764:
	return;
}

static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 mx;
	u64 mask;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2772;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 44;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2771;
L2772:
	asi64(R1) = i;
	if (!asi64(R1)) goto L2774;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2774:
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	asu64(R1) = mask;
	R2 = 2147483647;
	if (asu64(R1) > asu64(R2)) goto L2776;
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2775;
L2776:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2775:
L2771:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_loadbf_var(u64 p) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = tou64("LOADBF_VAR");
	pc_api_merror(asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_do_storebit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 cx;
	u64 ix;
	u64 q;
	u64 r;
	i64 i;
	i64 offset;
	u8 mask1s;
	u8 mask0s;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2780;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	offset = asi64(R1);
	R1 = 7;
	R2 = (u64)&i;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = px;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	mask0s = asu8(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	mask1s = asu8(R1);
	asu64(R1) = r;
	if (!asu64(R1)) goto L2782;
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2784;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2783;
L2784:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask0s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2783:
	goto L2781;
L2782:
	R1 = 0;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2786;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2786:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2781:
	goto L2779;
L2780:
	asu64(R1) = r;
	if (!asu64(R1)) goto L2787;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2789;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2791;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2791:
	R1 = 11;
	R2 = 10;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ix = asu64(R1);
	R1 = 1;
	asu64(R2) = cx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2793;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2793:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2795;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2794;
L2795:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2794:
	goto L2788;
L2789:
	R1 = tou64("");
	R2 = tou64("STOREBIT/VAR");
	pc_api_merror(asu64(R2), asu64(R1));
L2788:
	goto L2779;
L2787:
	R1 = tou64("");
	R2 = tou64("Storebit: both vars");
	pc_api_merror(asu64(R2), asu64(R1));
L2779:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_storebf(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 rx;
	u64 mx;
	u64 mx4;
	u64 dx;
	i64 i;
	i64 j;
	u64 q;
	u64 r;
	u64 mask;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = r;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2798;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2798;
	R1 = tou64("");
	R2 = tou64("storebf not imm");
	pc_api_merror(asu64(R2), asu64(R1));
L2798:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 3;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	dx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	j = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	asi64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2800;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = dx;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2800:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = mx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dx;
	asu64(R2) = rx;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static u64 mc_auxmcl_gethostfn(i64 opc) {
    u64 R1, R2; 
	u64 d;
	u64 name;
	u64 namec;
	u64 ps;
	asu64(R1) = pc_api_igethostfn;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2803;
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2805;
	goto L2806;
L2805:
	R1 = tou64("msys.m$power_i64");
	name = asu64(R1);
	R1 = tou64("msysc.m$power_i64");
	namec = asu64(R1);
	goto L2804;
L2806:
	R1 = 0;
	name = asu64(R1);
L2804:
	asu64(R1) = name;
	if (!asu64(R1)) goto L2808;
	asu64(R1) = pc_decls_psymboltable;
	ps = asu64(R1);
	goto L2812;
L2809:
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L2815;
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = namec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2814;
L2815:
	asu64(R1) = ps;
	goto L2801;
L2814:
	asu64(R1) = ps;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ps = asu64(R1);
L2812:
	asu64(R1) = ps;
	if (asu64(R1)) goto L2809;
L2808:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("gethostfn?");
	pc_api_merror(asu64(R2), asu64(R1));
L2803:
	asi64(R1) = opc;
	asu64(R2) = pc_api_igethostfn;
	asu64(R1) = ((F19)R2)(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2817;
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("No host fn:");
	pc_api_merror(asu64(R2), asu64(R1));
L2817:
	asu64(R1) = d;
	goto L2801;
L2801:
	return asu64(R1);
}

static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 dblock;
	u64 ax;
	u64 bx;
	u64 axi;
	u64 bxi;
	asu64(R1) = px;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2820;
	msysc_m$print_startcon();
	R1 = tou64("High block arg not copied in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("()");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L2818;
L2820:
	asi64(R1) = size;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = px;
	if (!asu64(R1)) goto L2822;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2821;
L2822:
	R1 = 0;
	R2 = 11;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
L2821:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = size;
	R3 = 0;
	R4 = 10;
	asu64(R5) = bx;
	R6 = 10;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asu64(R3) = mc_libmcl_mgenireg(asi64(R5), asi64(R4), asi64(R3));
	R4 = 0;
	R5 = 10;
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R4) = mc_libmcl_mgenireg(asi64(R6), asi64(R5), asi64(R4));
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = px;
	if (!asu64(R1)) goto L2824;
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2824:
	R1 = 0;
	mc_stackmcl_freeworkregs(asu64(R1));
L2818:
	return;
}

static void mc_auxmcl_fixmain() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 dn;
	u64 dargs;
	u64 denv;
	u64 dinfo;
	u64 ax;
	asu64(R1) = pc_decls_currfunc;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dn = asu64(R1);
	asu64(R1) = dn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dargs = asu64(R1);
	R1 = 3;
	R2 = tou64("$env");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	denv = asu64(R1);
	R1 = 6;
	asu64(R2) = denv;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = denv;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = tou64("$info");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	dinfo = asu64(R1);
	R1 = 11;
	asu64(R2) = dinfo;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 128;
	asu64(R2) = dinfo;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 8;
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = dinfo;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 128;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = denv;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 8;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = denv;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dinfo;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = R1;
	asu64(R3) = d;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = dargs;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = dn;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dn;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = dn;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = dargs;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dn;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = R2;
	ax = asu64(R3);
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dinfo;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dinfo;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dn;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dn;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dargs;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dargs;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = denv;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 13;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = denv;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	R2 = 14;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	R2 = tou64("__getmainargs*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 48;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	if (!asi64(R1)) goto L2827;
	R1 = 9;
	asi64(R2) = pc_decls_pcmdskip;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dn;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dargs;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2827:
	return;
}

static void mc_libmcl_mclinit(i64 bypass) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 r;
	i64 s;
	i64 av_1;
	i64 av_2;
	i64 i;
	R1 = 64;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2830;
	R1 = tou64("MCLREC>64B");
	mlib_abortprogram(asu64(R1));
L2830:
	R1 = 1;
	r = asi64(R1);
L2831:
	R1 = 1;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 2;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 4;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 4;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	r += 1; if (r <= 16) goto L2831;
	R1 = -128;
	i = asi64(R1);
	R1 = 64;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L2836;
L2834:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = i;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_frameregtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+1024)) = asu64(R1);
	i += 1; if (i <= av_1) goto L2834;
L2836:
	R1 = 6;
	R2 = 15;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dframeopnd = asu64(R1);
	R1 = 6;
	R2 = 16;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dstackopnd = asu64(R1);
	mc_libmcl_initmcdest();
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	mc_decls_lab_funcnametable = asi64(R1);
	R1 = 0;
	mc_decls_lab_funcaddrtable = asi64(R1);
	R1 = -1;
	i = asi64(R1);
	R1 = 10;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2839;
L2837:
	R1 = 8;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_libmcl_smallinttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L2837;
L2839:
	asi64(R1) = bypass;
	if (!asi64(R1)) goto L2841;
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
L2841:
	return;
}

static void mc_libmcl_initmcdest() {
    u64 R1, R2; 
	R1 = 0;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
	return;
}

static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 m;
	u64 oldm;
	i64 labno;
	R1 = 64;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	m = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_libmcl_mclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = m;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opcode;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2845;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2846;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2847;
	goto L2848;
L2845:
	asu64(R1) = b;
	if (!asu64(R1)) goto L2850;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2850;
	R1 = 1;
	asu64(R2) = b;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2850:
	goto L2844;
L2846:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	goto L2844;
L2847:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2853;
	asu64(R1) = b;
	if (!asu64(R1)) goto L2852;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2852;
L2853:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2855;
	R1 = 17;
	goto L2854;
L2855:
	R1 = 16;
L2854:
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2852:
	goto L2844;
L2848:
L2844:
	asu64(R1) = mc_decls_mccode;
	if (!asu64(R1)) goto L2857;
	asu64(R1) = mc_decls_mccodex;
	asu64(R2) = m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	mc_decls_mccodex = asu64(R1);
	goto L2856;
L2857:
	asu64(R1) = m;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
L2856:
	return;
}

static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = mc_decls_mccodex;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mc_libmcl_genmc_str(i64 opcode, u64 s) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = -1;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_newmclopnd() {
    u64 R1; 
	u64 a;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	a = asu64(R1);
	R1 = (u64)&mc_libmcl_nmclopnd;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	goto L2860;
L2860:
	return asu64(R1);
}

static u64 mc_libmcl_duplopnd(u64 a) {
    u64 R1, R2; struct $B3 R1_B3; 
	u64 b;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	b = asu64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = b;
	goto L2861;
L2861:
	return asu64(R1);
}

static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = areg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = areg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2865;
	asi64(R1) = ireg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2864;
L2865:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2864:
	asi64(R1) = ireg;
	asu64(R2) = a;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 5;
	R4 = 8;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = labno;
	if (!asi64(R1)) goto L2867;
	asi64(R1) = labno;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2866;
L2867:
	asu64(R1) = def;
	if (!asu64(R1)) goto L2868;
	asu64(R1) = def;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = def;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = def;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2871;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2870;
L2871:
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2870:
L2868:
L2866:
	asu64(R1) = a;
	goto L2862;
L2862:
	return asu64(R1);
}

static void mc_libmcl_mgencomment(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = 3;
	mc_libmcl_genmc_str(asi64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenstring(u64 s, i64 length) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2875;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2875:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = a;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2873;
L2873:
	return asu64(R1);
}

static u64 mc_libmcl_mgenname(u64 s) {
    u64 R1, R2, R3, R4; 
	struct $B31 str;
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2876;
L2876:
	return asu64(R1);
}

static void mc_libmcl_setsegment(i64 seg, i64 align) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 oldalign;
	asi64(R1) = seg;
	asi64(R2) = mc_decls_currsegment;
	if (asi64(R1) == asi64(R2)) goto L2879;
	asi64(R1) = seg;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L2881;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L2882;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L2883;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2884;
	goto L2885;
L2881:
	R1 = 121;
	opc = asi64(R1);
	goto L2880;
L2882:
	R1 = 122;
	opc = asi64(R1);
	goto L2880;
L2883:
	R1 = 123;
	opc = asi64(R1);
	goto L2880;
L2884:
	R1 = tou64("");
	R2 = tou64("CAN'T DO RODATA SEG");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2880;
L2885:
	R1 = tou64("");
	R2 = tou64("BAD SEG CODE");
	pc_api_merror(asu64(R2), asu64(R1));
L2880:
	asu64(R1) = mc_decls_mccodex;
	if (!asu64(R1)) goto L2887;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2888;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L2888;
	R2 = 123;
	if (asi64(R1) != asi64(R2)) goto L2887;
L2888:
	asi64(R1) = opc;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2886;
L2887:
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2886:
	asi64(R1) = seg;
	mc_decls_currsegment = asi64(R1);
L2879:
	asi64(R1) = align;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2890;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L2892;
	asu64(R1) = mc_decls_mccodex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldalign = asi64(R1);
	asi64(R1) = oldalign;
	asi64(R2) = align;
	if (asi64(R1) < asi64(R2)) goto L2894;
	goto L2877;
L2894:
L2892:
	R1 = 0;
	R2 = 10;
	asi64(R3) = align;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2890:
L2877:
	return;
}

static u64 mc_libmcl_changeopndsize(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L2897;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2899;
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	b = asu64(R1);
	goto L2898;
L2899:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2898:
	asu64(R1) = b;
	goto L2895;
L2897:
	asu64(R1) = a;
	goto L2895;
L2895:
	return asu64(R1);
}

static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2902;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2902;
	asu64(R1) = a;
	goto L2900;
L2902:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = b;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L2904;
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2904:
	asu64(R1) = b;
	goto L2900;
L2900:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint(i64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = x;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2907;
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2907;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2907;
	R1 = (u64)&mc_libmcl_smallinttable;
	asi64(R2) = x;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8+8));
	goto L2905;
L2907:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2905;
L2905:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint0(i64 x, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2908;
L2908:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2911;
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getrealindex(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2910;
L2911:
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getr32index(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2910:
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2909;
L2909:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asr64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2912;
L2912:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabel(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2915;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	x = asi64(R1);
L2915:
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2913;
L2913:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabelmem(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asi64(R1) = x;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2916;
L2916:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmem(u64 d, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2919;
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2921;
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenxregvar(asu64(R1));
	goto L2917;
	goto L2920;
L2921:
	asi64(R1) = mode;
	asu64(R2) = d;
	asu64(R1) = mc_libmcl_mgenregvar(asu64(R2), asi64(R1));
	goto L2917;
L2920:
L2919:
	R1 = 0;
	reg = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2924;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2923;
L2924:
	R1 = 15;
	reg = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2923:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	if (!asi64(R1)) goto L2926;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2925;
L2926:
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asu64(R1) = Min(asu64(R1), asu64(R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2925:
	asu64(R1) = a;
	goto L2917;
L2917:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmemaddr(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2927;
L2927:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg0(i64 reg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2930;
	R1 = tou64("");
	R2 = tou64("1:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2930:
	asu64(R1) = a;
	goto L2928;
L2928:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = xreg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2933;
	R1 = tou64("");
	R2 = tou64("2:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2933:
	asu64(R1) = a;
	goto L2931;
L2931:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg(i64 reg, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2936;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedxregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2935;
L2936:
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2938;
	R1 = 8;
	size = asi64(R1);
L2938:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2940;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2940;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2940:
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2934;
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
L2935:
	goto L2934;
L2934:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregi(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	R2 = (u64)&pc_tables_psize;
	asi64(R3) = mode;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2941;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	goto L2941;
L2941:
	return asu64(R1);
}

static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	goto L2942;
L2942:
	return asu64(R1);
}

static u64 mc_libmcl_mgentemp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	i64 size;
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2945;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	goto L2943;
L2945:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pcltempflags;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2943;
L2943:
	return asu64(R1);
}

static i64 mc_libmcl_roundsizetg(i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2948;
	asi64(R1) = size;
	goto L2946;
L2948:
	asi64(R1) = size;
	R2 = 8;
	asi64(R3) = size;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L2946;
L2946:
	return asi64(R1);
}

static void mc_libmcl_merroropnd(u64 mess, i64 opndtype) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MCL Opnd not supported: # (#) [#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asi64(R2) = opndtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 mc_libmcl_mcreatefwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L2950;
L2950:
	return asi64(R1);
}

static void mc_libmcl_mdefinefwdlabel(i64 lab) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenextname(u64 s) {
    u64 R1, R2, R3; 
	struct $B31 str;
	u64 d;
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mc_libmcl_findnamesym(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L2954;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	mc_libmcl_addnamesym(asu64(R1));
L2954:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	goto L2952;
L2952:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregvar(u64 d, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	goto L2955;
L2955:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxregvar(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 8;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2956;
L2956:
	return asu64(R1);
}

static i64 mc_libmcl_getprimreg(u64 ax) {
    u64 R1, R2; 
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2959;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L2958;
L2959:
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
L2958:
	goto L2957;
L2957:
	return asi64(R1);
}

static void mc_libmcl_pushslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) += asi64(R1);
	return;
}

static void mc_libmcl_popslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_popstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) -= asi64(R1);
	return;
}

static void mc_libmcl_pushstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2964;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2964:
	return;
}

static void mc_libmcl_popstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2967;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2967:
	return;
}

static i64 mc_libmcl_getstringindex(u64 s, i64 length) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2970;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_kk0used = asi64(R1);
	asi64(R1) = mc_decls_kk0used;
	goto L2968;
L2970:
	asu64(R1) = mc_decls_cstringlist;
	if (!asu64(R1)) goto L2972;
	asi64(R1) = length;
	asu64(R2) = mc_decls_cstringlist;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L2972;
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = mc_decls_cstringlist;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L2972;
	asu64(R1) = mc_decls_cstringlist;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2968;
L2972:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&mc_decls_cstringlist;
	asi64(R1) = mc_libmcl_addconst(asu64(R3), asi64(R2), asi64(R1));
	goto L2968;
L2968:
	return asi64(R1);
}

static i64 mc_libmcl_addconst(u64 clist, i64 value, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = clist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = clist;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	goto L2973;
L2973:
	return asi64(R1);
}

static i64 mc_libmcl_getrealindex(r64 x) {
    u64 R1, R2, R3; 
	R1 = 0;
	asr64(R2) = x;
	asi64(R2) = asi64(R2);
	R3 = (u64)&mc_decls_creallist;
	asi64(R1) = mc_libmcl_addconst(asu64(R3), asi64(R2), asi64(R1));
	goto L2974;
L2974:
	return asi64(R1);
}

static i64 mc_libmcl_getr32index(r64 x) {
    u64 R1, R2, R3; 
	R1 = 0;
	asr64(R2) = x;
	asi64(R2) = asi64(R2);
	R3 = (u64)&mc_decls_cr32list;
	asi64(R1) = mc_libmcl_addconst(asu64(R3), asi64(R2), asi64(R1));
	goto L2975;
L2975:
	return asi64(R1);
}

static i64 mc_libmcl_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L2977:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L2981;
	asi64(R1) = n;
	goto L2976;
L2981:
	if (--asi64(av_1)) goto L2977;
	R1 = 0;
	goto L2976;
L2976:
	return asi64(R1);
}

static void mc_libmcl_axerror(u64 mess) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	msysc_m$print_startcon();
	R1 = tou64("AX ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("AASEQ:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("AAPOS=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aapos;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L2984;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F16)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L2984:
	R1 = 1;
	exit(R1);
	return;
}

static u64 mc_libmcl_newblocktemp(i64 size) {
    u64 R1, R2, R3; 
	struct $B3 str;
	u64 d;
	asi64(R1) = mc_decls_nblocktemps;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L2987;
	R1 = tou64("");
	R2 = tou64("Too many block temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2987:
	R1 = (u64)&mc_decls_nblocktemps;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$B#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_nblocktemps;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 8;
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 11;
	asu64(R2) = d;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = d;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pc_decls_currfunc;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_decls_blockdefs;
	asi64(R3) = mc_decls_nblocktemps;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	goto L2985;
L2985:
	return asu64(R1);
}

static u64 mc_libmcl_findnamesym(u64 s) {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2991;
L2989:
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2993;
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2988;
L2993:
	i += 1; if (i <= mc_libmcl_nnametable) goto L2989;
L2991:
	R1 = 0;
	goto L2988;
L2988:
	return asu64(R1);
}

static void mc_libmcl_addnamesym(u64 d) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 20;
	if (asi64(R1) >= asi64(R2)) goto L2996;
	asu64(R1) = d;
	R2 = (u64)&mc_libmcl_nametable;
	R3 = (u64)&mc_libmcl_nnametable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L2995;
L2996:
	R1 = tou64("");
	R2 = tou64("Ext nametab overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2995:
	return;
}

static void mc_libmcl_clearreg(u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2999;
	R1 = 4;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2999:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3002;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3002;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3003;
	goto L3004;
L3002:
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L3000;
	goto L3001;
L3003:
	asi64(R1) = mode;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgentemp(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	goto L3000;
	goto L3001;
L3004:
L3001:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3006;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3007;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3008;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3009;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3009;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3010;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3011;
	goto L3012;
L3006:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3014;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3014;
	R1 = 6;
	mode = asi64(R1);
	goto L3007;
	goto L3013;
L3014:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
L3013:
	goto L3005;
L3007:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3016;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3016;
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3015;
L3016:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3015:
	goto L3005;
L3008:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3018;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3019;
	goto L3020;
L3018:
	R1 = 65535;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L3017;
L3019:
	R1 = 4294967295;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L3017;
L3020:
L3017:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L3022;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L3022;
	asu64(R1) = bx;
	ax = asu64(R1);
	goto L3021;
L3022:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3021:
	goto L3005;
L3009:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3005;
L3010:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R2), asi64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L3005;
L3011:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L3005;
L3012:
// mc_stackmcl.getopnd.error:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = a;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("getopnd");
	pc_api_merror(asu64(R2), asu64(R1));
L3005:
	asu64(R1) = ax;
	goto L3000;
L3000:
	return asu64(R1);
}

static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3026;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3028;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L3028:
L3026:
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	goto L3024;
L3024:
	return asu64(R1);
}

static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg_m(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	goto L3029;
L3029:
	return asu64(R1);
}

static void mc_stackmcl_pushopnd(i64 n, i64 mode, i64 size) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3032;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3034;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3035;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3036;
	goto L3037;
L3034:
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3039;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3040;
L3039:
	goto L3033;
L3035:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L3042;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L3042;
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3040;
L3042:
	goto L3033;
L3036:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L3040;
	goto L3033;
L3037:
L3033:
L3032:
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3044;
	asi64(R1) = n;
	asi64(R2) = size;
	asu64(R3) = ax;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	mode = asi64(R1);
L3044:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3046;
	asu64(R1) = ax;
	bx = asu64(R1);
	asi64(R1) = mode;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3048;
	R1 = 5;
	goto L3047;
L3048:
	R1 = 6;
L3047:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3046:
// mc_stackmcl.pushopnd.pushit:
L3040:
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&mc_decls_mstackdepth;
	(*toi64p(R1)) += 1;
	return;
}

static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3052;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3051;
L3052:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3055;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L3054;
L3055:
	asu64(R1) = ax;
	goto L3049;
L3054:
L3051:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3049;
L3049:
	return asu64(R1);
}

static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3059;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3058;
L3059:
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L3061;
	asu64(R1) = ax;
	goto L3056;
L3061:
L3058:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3056;
L3056:
	return asu64(R1);
}

static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3064;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3064;
	asu64(R1) = ax;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3064;
	R1 = 4;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	goto L3063;
L3064:
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3063:
	return;
}

static void mc_stackmcl_pushpcl(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L3067;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3067:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3069;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3069;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3069:
	return;
}

static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L3072;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3072:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3074;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L3074:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3076;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3075;
L3076:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3075:
	return;
}

static void mc_stackmcl_poppcl() {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L3079;
	R1 = tou64("");
	R2 = tou64("poppcl/underflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3079:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3081;
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	R1 += (i64)R2-1;
	(*tou8p(R1)) -=1;
	goto L3077;
L3081:
	R1 = (u64)&mc_decls_noperands;
	(*toi64p(R1)) -=1;
L3077:
	return;
}

static void mc_stackmcl_duplpcl() {
    u64 R1, R2, R3, R4; 
	i64 mode;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 0;
	asi64(R3) = mode;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_stackmcl_getworkireg() {
    u64 R1, R2, R3; 
	i64 r;
	i64 av_1;
	R1 = 10;
	av_1 = asi64(R1);
L3084:
	R1 = 1;
	r = asi64(R1);
L3087:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3091;
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3091;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L3083;
L3091:
	r += 1; if (r <= 14) goto L3087;
	mc_stackmcl_savenextopnd();
	if (--asi64(av_1)) goto L3084;
	R1 = tou64("");
	R2 = tou64("No more work regs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3083;
L3083:
	return asi64(R1);
}

static i64 mc_stackmcl_getworkxreg() {
    u64 R1, R2, R3; 
	i64 r;
	R1 = 5;
	r = asi64(R1);
L3093:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3097;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3097;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L3092;
L3097:
	r += 1; if (r <= 16) goto L3093;
	R1 = tou64("");
	R2 = tou64("No more work xregs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3092;
L3092:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkregm(i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R2) = mode;
	asi64(R2) = mc_stackmcl_getworkreg(asi64(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L3098;
L3098:
	return asu64(R1);
}

static i64 mc_stackmcl_getworkreg(i64 mode) {
    u64 R1, R2; 
	i64 reg;
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3101;
	asi64(R1) = mc_stackmcl_getworkxreg();
	goto L3100;
L3101:
	asi64(R1) = mc_stackmcl_getworkireg();
L3100:
	goto L3099;
L3099:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3105;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3104;
L3105:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L3102;
L3104:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3109;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L3108;
L3109:
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3107;
L3108:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L3102;
L3107:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L3102;
L3102:
	return asu64(R1);
}

static void mc_stackmcl_saveopnd(i64 n, i64 allregs) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 mode;
	u64 tx;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3112;
	goto L3110;
L3112:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3114;
	asi64(R1) = allregs;
	if (asi64(R1)) goto L3117;
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L3118;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L3116;
L3118:
L3117:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3116:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3113;
L3114:
	asi64(R1) = allregs;
	if (asi64(R1)) goto L3121;
	asi64(R1) = reg;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3120;
	R2 = 6;
	if (asi64(R1) > asi64(R2)) goto L3120;
L3121:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3120:
	R1 = 0;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3113:
	R1 = 3;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3110:
	return;
}

static void mc_stackmcl_saveopnds(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3125;
L3123:
	R1 = 0;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L3123;
L3125:
	return;
}

static void mc_stackmcl_savenextopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3129;
L3127:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3131;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3131;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L3126;
L3131:
	i += 1; if (i <= mc_decls_noperands) goto L3127;
L3129:
L3126:
	return;
}

static void mc_stackmcl_savenextxopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3135;
L3133:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3137;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3137;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L3132;
L3137:
	i += 1; if (i <= mc_decls_noperands) goto L3133;
L3135:
L3132:
	return;
}

static void mc_stackmcl_movetoreg(i64 newreg) {
    u64 R1, R2, R3; 
	i64 oldreg;
	i64 mode;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
// mc_stackmcl.movetoreg.retry:
L3139:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	oldreg = asi64(R1);
	asi64(R1) = oldreg;
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L3141;
	goto L3138;
L3141:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3143;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3145;
	R1 = tou64("");
	R2 = tou64("MOVE TO REG: XREG IN USE");
	pc_api_merror(asu64(R2), asu64(R1));
L3145:
	goto L3142;
L3143:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3147;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3150;
L3148:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3152;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L3152;
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 6;
	asi64(R2) = newreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asi64(R3) = oldreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L3139;
L3152:
	i += 1; if (i <= mc_decls_noperands) goto L3148;
L3150:
L3147:
L3142:
	asi64(R1) = mode;
	asi64(R2) = oldreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newreg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3154;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3153;
L3154:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3153:
L3138:
	return;
}

static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3157;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3159;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3162;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3161;
L3162:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	goto L3155;
L3161:
L3159:
L3157:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3164;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3164:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3155;
L3155:
	return asu64(R1);
}

static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3167;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3167:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3165;
L3165:
	return asu64(R1);
}

static void mc_stackmcl_swapopnds(i64 m, i64 n) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = m;
	R1 += (i64)R2*8-8;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	R2 += (i64)R3*8-8;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	return;
}

static u64 mc_stackmcl_isimmload(i64 n) {
    u64 R1, R2; 
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3171;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3171;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3171;
	asu64(R1) = p;
	goto L3170;
L3171:
	R1 = 0;
L3170:
	goto L3169;
L3169:
	return asu64(R1);
}

static void mc_stackmcl_setnewzz(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_stackmcl_freeworkregs(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 i;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3176;
L3174:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3178;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3180;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3179;
L3180:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3179:
L3178:
	i += 1; if (i <= mc_decls_noperands) goto L3174;
L3176:
	return;
}

static void mc_stackmcl_swapopndregs(i64 reg2) {
    u64 R1, R2, R3; 
	i64 reg1;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3183;
	R1 = tou64("");
	R2 = tou64("SOR1");
	pc_api_merror(asu64(R2), asu64(R1));
L3183:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg1 = asi64(R1);
	asi64(R1) = reg1;
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L3185;
	goto L3181;
L3185:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3189;
L3186:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3191;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L3191;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	goto L3181;
L3191:
	i += -1; if (i >= 1) goto L3186;
L3189:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg2;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3181:
	return;
}

static u64 mc_stackmcl_makeopndind(u64 a, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3194;
	R1 = tou64("");
	R2 = tou64("makeopndind");
	pc_api_merror(asu64(R2), asu64(R1));
L3194:
	R1 = 0;
	asi64(R2) = mode;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3192;
L3192:
	return asu64(R1);
}

static u64 mc_stackmcl_makesimpleaddr(u64 ax) {
    u64 R1, R2, R3; 
	u64 bx;
	i64 newreg;
	i64 reg;
	i64 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3197;
	R1 = 0;
	reg = asi64(R1);
L3197:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3199;
	R1 = tou64("");
	R2 = tou64("MSA");
	pc_api_merror(asu64(R2), asu64(R1));
L3199:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3201;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3201;
	asi64(R1) = mc_stackmcl_getworkireg();
	newreg = asi64(R1);
	goto L3200;
L3201:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3202;
	asu64(R1) = ax;
	goto L3195;
	goto L3200;
L3202:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3203;
	asi64(R1) = regix;
	newreg = asi64(R1);
	goto L3200;
L3203:
	asi64(R1) = regix;
	newreg = asi64(R1);
L3200:
	R1 = 0;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3195;
L3195:
	return asu64(R1);
}

static void mc_stackmcl_checkallloaded() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3207;
L3205:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3209;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3209;
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = i;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3209:
	i += 1; if (i <= mc_decls_noperands) goto L3205;
L3207:
	return;
}

static u64 mc_stackmcl_stropndstack(i64 indent) {
    u64 R1, R2, R3; 
	struct $B20 str2;
	u64 s;
	u64 t;
	i64 i;
	i64 r;
	R1 = (u64)&mc_stackmcl_stropndstack_str;
	s = asu64(R1);
	asi64(R1) = indent;
	if (!asi64(R1)) goto L3212;
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("========================================#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L3211;
L3212:
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3211:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3215;
L3213:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L3219;
	case 2: goto L3220;
	case 3: goto L3221;
	case 4: goto L3222;
	default: goto L3218;
    };
// SWITCH
L3219:
	R1 = tou64("Z:");
	goto L3216;
L3220:
	R1 = tou64("Y:");
	goto L3216;
L3221:
	R1 = tou64("X:");
	goto L3216;
L3222:
	R1 = tou64("W:");
	goto L3216;
L3218:
	R1 = tou64("");
L3216:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3224;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3224;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3225;
	goto L3226;
L3224:
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3228;
	R1 = (u64)&mc_decls_xregnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3227;
L3228:
	R1 = (u64)&mc_decls_regnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3227:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3230;
	R1 = tou64("*");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3230:
	goto L3223;
L3225:
	R1 = tou64("T");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = i;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3223;
L3226:
	R1 = tou64("(==");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3223:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3232;
	R1 = tou64("@");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3232:
	R1 = tou64("<");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pstdnames;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(">");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = mc_decls_noperands;
	if (asi64(R1) >= asi64(R2)) goto L3234;
	R1 = tou64(", ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3234:
	i += 1; if (i <= mc_decls_noperands) goto L3213;
L3215:
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 50;
	R3 = (u64)&mc_stackmcl_stropndstack_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("WR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
L3235:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3239;
	R1 = tou64("1 ");
	goto L3238;
L3239:
	R1 = tou64("0 ");
L3238:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= 10) goto L3235;
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("XWR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
	asi64(R1) = mc_decls_xregmax;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3242;
L3240:
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3244;
	R1 = tou64("1 ");
	goto L3243;
L3244:
	R1 = tou64("0 ");
L3243:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= mc_decls_xregmax) goto L3240;
L3242:
	R1 = tou64(") hwstack:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_mstackdepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" noperands:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ncalldepth:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_ncalldepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = s;
	goto L3210;
L3210:
	return asu64(R1);
}

static void mc_stackmcl_showopndstack() {
    u64 R1; 
	R1 = 1;
	asu64(R1) = mc_stackmcl_stropndstack(asi64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_optim_peephole() {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 m;
	u64 m2;
	u64 m3;
	i64 lab1;
	i64 lab2;
	asu8(R1) = pc_decls_fpeephole;
	if (asu8(R1)) goto L3248;
	goto L3246;
L3248:
	asu64(R1) = mc_decls_mccode;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L3252;
L3249:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m2 = asu64(R1);
	asu64(R1) = m2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m3 = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3254;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3255;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L3256;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3257;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L3258;
	goto L3259;
L3254:
	goto L3251;
	goto L3253;
L3255:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3261;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3262;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L3263;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L3264;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L3264;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L3265;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L3265;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L3266;
	goto L3267;
L3261:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3269;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3269;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3269;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L3271;
	goto L3270;
L3271:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (asi64(R1)) goto L3273;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3272;
L3273:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3272:
L3270:
	goto L3268;
L3269:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3274;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3274;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L3274;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L3274;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3274;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3274:
L3268:
	goto L3260;
L3262:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3276;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L3277;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3277;
	R1 = 1;
	goto L3278;
L3277:
	R1 = 0;
L3278:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3276;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3276;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3276;
	R1 = 41;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3276:
	goto L3260;
L3263:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3280;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3280;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3280;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3280;
	R1 = 42;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3280:
	goto L3260;
L3264:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3282;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3282;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3282;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isconst(asu64(R1));
	if (!asi64(R1)) goto L3282;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 28;
	if (asi64(R4) != asi64(R5)) goto L3284;
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	goto L3283;
L3284:
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	asi64(R4) = -asi64(R4);
L3283:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3282:
	goto L3260;
L3265:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3286;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3286;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3286;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 52;
	if (asi64(R4) != asi64(R5)) goto L3288;
	R4 = 1;
	goto L3287;
L3288:
	R4 = -1;
L3287:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3286:
	goto L3260;
L3266:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3290;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3290;
	R1 = 25;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3290:
	goto L3260;
L3267:
L3260:
	goto L3253;
L3256:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L3292;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3294;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L3295;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3295;
	R1 = 1;
	goto L3296;
L3295:
	R1 = 0;
L3296:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3294;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3294;
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3294:
L3292:
	goto L3253;
L3257:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3298;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3300;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3300;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3300;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3300;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3300;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = m;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3300:
L3298:
	goto L3253;
L3258:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L3302;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L3302;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = m3;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L3302;
	asu64(R1) = m;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3302;
	R1 = (u64)&mc_decls_asmrevcond;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = m;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3302:
	goto L3253;
L3259:
L3253:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3252:
	asu64(R1) = m;
	if (asu64(R1)) goto L3249;
L3251:
L3246:
	return;
}

static i64 mc_optim_isreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3303;
L3303:
	return asi64(R1);
}

static i64 mc_optim_isreg0(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3306;
	R1 = 0;
	goto L3304;
L3306:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3308;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3308;
	R1 = 1;
	goto L3304;
L3308:
	R1 = 0;
	goto L3304;
L3304:
	return asi64(R1);
}

static i64 mc_optim_isreg10(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3311;
	R1 = 0;
	goto L3309;
L3311:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3313;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3313;
	R1 = 1;
	goto L3309;
L3313:
	R1 = 0;
	goto L3309;
L3309:
	return asi64(R1);
}

static i64 mc_optim_isreg00(u64 m) {
    u64 R1, R2, R3; 
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3316;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3316;
	R1 = 1;
	goto L3314;
L3316:
	R1 = 0;
	goto L3314;
L3314:
	return asi64(R1);
}

static i64 mc_optim_isconst(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3319;
	R1 = 0;
	goto L3317;
L3319:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3321;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3321;
	R1 = 1;
	goto L3317;
L3321:
	R1 = 0;
	goto L3317;
L3317:
	return asi64(R1);
}

static i64 mc_optim_sameoperand(u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 16;
	asu64(R2) = b;
	asu64(R3) = a;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3322;
L3322:
	return asi64(R1);
}

static i64 mc_optim_sameregopnd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3326;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3325;
L3326:
	R1 = 0;
	goto L3323;
L3325:
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3323;
L3323:
	return asi64(R1);
}

static u64 mc_optim_deletemcl(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3330;
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3329;
L3330:
	R1 = tou64("");
	R2 = tou64("delmcl?");
	pc_api_merror(asu64(R2), asu64(R1));
L3329:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	goto L3327;
L3327:
	return asu64(R1);
}

static i64 mc_optim_endr0(u64 m) {
    u64 R1, R2; 
	asu64(R1) = m;
	R2 = 48;
	R1 += (i64)R2;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L3331;
L3331:
	return asi64(R1);
}

static void mc_genss_genss(i64 obj) {
    u64 R1, R2, R3; 
	i64 index;
	u64 m;
	u64 pr;
	u64 codeaddr;
	u64 offsetptr;
	asu8(R1) = pc_decls_ssdone;
	if (!asu8(R1)) goto L3334;
	goto L3332;
L3334:
	asi64(R1) = mlinux_os_clock();
	pc_decls_sstime = asi64(R1);
	asi64(R1) = pc_api_mlabelno;
	mc_genss_initlib(asi64(R1));
	R1 = 0;
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_zdata = asu64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_idata = asu64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_code = asu64(R1);
	R1 = 0;
	mc_decls_ss_idatarelocs = asu64(R1);
	R1 = 0;
	mc_decls_ss_coderelocs = asu64(R1);
	R1 = 0;
	mc_decls_ss_nsymbols = asi64(R1);
	R1 = 1;
	mc_genss_switchseg(asi64(R1));
	R1 = 9999;
	mc_decls_aaseqno = asi64(R1);
	R1 = 0;
	mc_genss_extraparam = asu64(R1);
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 0;
	index = asi64(R1);
	goto L3336;
L3335:
	R1 = (u64)&index;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	mc_genss_doinstr(asu64(R2), asi64(R1));
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3336:
	asu64(R1) = m;
	if (asu64(R1)) goto L3335;
	R1 = 0;
	mc_genss_switchseg(asi64(R1));
	asu64(R1) = mc_decls_ss_zdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	if (!asi64(R1)) goto L3339;
	R1 = tou64("Zdata contains code or data");
	mc_libmcl_axerror(asu64(R1));
L3339:
	asi64(R1) = obj;
	if (!asi64(R1)) goto L3341;
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codeaddr = asu64(R1);
	asu64(R1) = mc_decls_riplist;
	pr = asu64(R1);
	goto L3345;
L3342:
	asu64(R1) = codeaddr;
	asu64(R2) = pr;
	R3 = 8;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	offsetptr = asu64(R1);
	asu64(R1) = pr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offsetptr;
	*tou32p(R2) -= asu32(R1);
	asu64(R1) = pr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pr = asu64(R1);
L3345:
	asu64(R1) = pr;
	if (asu64(R1)) goto L3342;
L3341:
	R1 = 1;
	pc_decls_ssdone = asu8(R1);
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = pc_decls_sstime;
	asi64(R1) -= asi64(R2);
	pc_decls_sstime = asi64(R1);
L3332:
	return;
}

static void mc_genss_doinstr(u64 m, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	u64 d;
	u64 e;
	i64 x;
	i64 offset;
	i64 shortjmp;
	i64 n;
	i64 av_1;
	i64 av_2;
	asu64(R1) = mc_genss_currdata;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1024;
	if (asi64(R1) >= asi64(R2)) goto L3348;
	asu64(R1) = mc_genss_currdata;
	mc_genss_bufferexpand(asu64(R1));
L3348:
	R1 = 0;
	R2 = R1;
	mc_genss_usesizeb = asu8(R2);
	R2 = R1;
	mc_genss_nowmask = asu8(R2);
	R2 = R1;
	mc_genss_f3override = asu8(R2);
	R2 = R1;
	mc_genss_f2override = asu8(R2);
	R2 = R1;
	mc_genss_addroverride = asu8(R2);
	R2 = R1;
	mc_genss_sizeoverride = asu8(R2);
	mc_genss_rex = asu8(R1);
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = m;
	R2 = 36;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	mc_decls_aaseqno = asi64(R1);
	asu64(R1) = m;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	mc_decls_aapos = asi64(R1);
	R1 = 0;
	mc_genss_ripentry = asu64(R1);
	asu64(R1) = m;
	mc_genss_currmcl = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L3352;
	case 2: goto L3353;
	case 3: case 8: goto L3475;
	case 4: goto L3356;
	case 5: goto L3354;
	case 6: goto L3355;
	case 7: case 23: case 35: case 92: case 93: case 151: goto L3351;
	case 9: goto L3363;
	case 10: case 152: goto L3384;
	case 11: goto L3398;
	case 12: goto L3393;
	case 13: goto L3394;
	case 14: goto L3399;
	case 15: goto L3457;
	case 16: goto L3441;
	case 17: goto L3442;
	case 18: goto L3400;
	case 19: goto L3401;
	case 20: goto L3402;
	case 21: goto L3368;
	case 22: goto L3389;
	case 24: goto L3390;
	case 25: goto L3369;
	case 26: goto L3370;
	case 27: goto L3403;
	case 28: case 29: case 30: case 31: case 38: case 39: case 40: case 42: goto L3397;
	case 32: case 33: case 36: case 37: case 50: case 51: goto L3396;
	case 34: goto L3404;
	case 41: goto L3435;
	case 43: case 44: case 45: case 46: case 47: case 48: case 49: goto L3434;
	case 52: case 53: goto L3395;
	case 54: goto L3385;
	case 55: goto L3386;
	case 56: goto L3387;
	case 57: goto L3388;
	case 58: goto L3440;
	case 59: case 60: goto L3471;
	case 61: case 62: goto L3474;
	case 63: case 65: case 67: case 69: case 71: case 112: case 113: goto L3443;
	case 64: case 66: case 68: case 70: case 72: case 114: case 115: goto L3444;
	case 73: goto L3447;
	case 74: case 75: goto L3448;
	case 76: case 78: goto L3445;
	case 77: case 79: case 80: case 81: goto L3446;
	case 82: goto L3451;
	case 83: goto L3452;
	case 84: goto L3453;
	case 85: goto L3454;
	case 86: goto L3455;
	case 87: goto L3456;
	case 88: goto L3450;
	case 89: goto L3449;
	case 90: case 91: goto L3467;
	case 94: case 95: case 96: goto L3459;
	case 97: case 98: case 99: goto L3460;
	case 100: case 101: case 102: case 103: goto L3461;
	case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: goto L3458;
	case 116: case 120: goto L3377;
	case 117: goto L3378;
	case 118: goto L3379;
	case 119: goto L3380;
	case 121: goto L3382;
	case 122: goto L3383;
	case 123: goto L3381;
	case 124: goto L3418;
	case 125: case 126: case 127: case 128: goto L3405;
	case 129: goto L3439;
	case 130: case 131: case 132: goto L3436;
	case 133: goto L3437;
	case 134: goto L3438;
	case 135: goto L3462;
	case 136: goto L3463;
	case 137: goto L3464;
	case 138: goto L3465;
	case 139: goto L3466;
	case 140: goto L3470;
	case 141: goto L3473;
	case 142: goto L3468;
	case 143: case 144: case 145: case 146: case 147: case 148: case 149: goto L3469;
	case 150: goto L3472;
	default: goto L3351;
    };
// SWITCH
L3352:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	goto L3349;
L3353:
	goto L3349;
L3354:
	goto L3349;
L3355:
	goto L3349;
L3356:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3358;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3359;
	goto L3360;
L3358:
	goto L3357;
L3359:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 2;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mc_genss_currseg;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3362;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
L3362:
	asu64(R1) = d;
	mc_genss_dofwdrefs(asu64(R1));
	goto L3357;
L3360:
L3357:
	goto L3349;
L3363:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3365;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L3364;
L3365:
	asu64(R1) = mc_decls_labeldeftable;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
L3364:
	R1 = 2;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mc_genss_currseg;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3367;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
L3367:
	asu64(R1) = d;
	mc_genss_dofwdrefs(asu64(R1));
	goto L3349;
L3368:
	asu64(R1) = a;
	mc_genss_do_call(asu64(R1));
	goto L3349;
L3369:
	asu64(R1) = m;
	asu64(R2) = a;
	mc_genss_do_jmp(asu64(R2), asu64(R1));
	goto L3349;
L3370:
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 7;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3372;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3374;
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	R2 = 4;
	asi64(R1) -= asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3373;
L3374:
	R1 = 112;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3373:
	goto L3371;
L3372:
	asu64(R1) = d;
	asu64(R2) = m;
	asi64(R1) = mc_genss_checkshortjump(asu64(R2), asu64(R1));
	shortjmp = asi64(R1);
	asi64(R1) = shortjmp;
	if (asi64(R1)) goto L3376;
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3375;
L3376:
	R1 = 112;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel8(asu64(R1));
L3375:
L3371:
	goto L3349;
L3377:
	R1 = 1;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3349;
L3378:
	R1 = 2;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3349;
L3379:
	R1 = 4;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3349;
L3380:
	R1 = 8;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3349;
L3381:
	R1 = 1;
	mc_genss_switchseg(asi64(R1));
	goto L3349;
L3382:
	R1 = 2;
	mc_genss_switchseg(asi64(R1));
	goto L3349;
L3383:
	R1 = 3;
	mc_genss_switchseg(asi64(R1));
	goto L3349;
L3384:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3385:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 152;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3386:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3387:
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3388:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3389:
	R1 = 195;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3390:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3392;
	R1 = tou64("retn?");
	mc_libmcl_axerror(asu64(R1));
L3392:
	R1 = 194;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genword(asi64(R1));
	goto L3349;
L3393:
	asu64(R1) = a;
	mc_genss_do_push(asu64(R1));
	goto L3349;
L3394:
	asu64(R1) = a;
	mc_genss_do_pop(asu64(R1));
	goto L3349;
L3395:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_inc(asu64(R2), asi64(R1));
	goto L3349;
L3396:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_neg(asu64(R2), asi64(R1));
	goto L3349;
L3397:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_arith(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3398:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_mov(asu64(R2), asu64(R1));
	goto L3349;
L3399:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_lea(asu64(R2), asu64(R1));
	goto L3349;
L3400:
	R1 = 190;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movsx(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3401:
	R1 = 182;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movsx(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3402:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_movsxd(asu64(R2), asu64(R1));
	goto L3349;
L3403:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_exch(asu64(R2), asu64(R1));
	goto L3349;
L3404:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_imul2(asu64(R2), asu64(R1));
	goto L3349;
L3405:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3407;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	n = asi64(R1);
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3409;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3410;
	goto L3411;
L3409:
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3414;
L3412:
	R1 = 144;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L3412;
L3414:
	goto L3408;
L3410:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3417;
L3415:
	R1 = 0;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_2)) goto L3415;
L3417:
	goto L3408;
L3411:
	asi64(R1) = n;
	R2 = (u64)&mc_decls_ss_zdatalen;
	*toi64p(R2) += asi64(R1);
L3408:
	goto L3406;
L3407:
	R1 = tou64("resb?");
	mc_libmcl_axerror(asu64(R1));
L3406:
	goto L3349;
L3418:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3420;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	asi64(R1) = x;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3423;
	asi64(R1) = x;
	R2 = 16384;
	if (asi64(R1) <= asi64(R2)) goto L3422;
L3423:
	R1 = tou64("align2");
	mc_libmcl_axerror(asu64(R1));
L3422:
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = mc_genss_currseg;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3425;
	goto L3427;
L3426:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3430;
	R1 = 144;
	goto L3429;
L3430:
	R1 = 0;
L3429:
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3427:
	asu64(R1) = mc_genss_currdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	asi64(R2) = x;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L3426;
	goto L3424;
L3425:
	goto L3432;
L3431:
	R1 = (u64)&mc_decls_ss_zdatalen;
	(*toi64p(R1)) += 1;
L3432:
	asi64(R1) = mc_decls_ss_zdatalen;
	asi64(R2) = x;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L3431;
L3424:
	goto L3419;
L3420:
	R1 = tou64("align?");
	mc_libmcl_axerror(asu64(R1));
L3419:
	goto L3349;
L3434:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_shift(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3435:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_test(asu64(R2), asu64(R1));
	goto L3349;
L3436:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_loop(asu64(R2), asi64(R1));
	goto L3349;
L3437:
	R1 = 4;
	asu64(R2) = a;
	mc_genss_do_jcxz(asu64(R2), asi64(R1));
	goto L3349;
L3438:
	R1 = 8;
	asu64(R2) = a;
	mc_genss_do_jcxz(asu64(R2), asi64(R1));
	goto L3349;
L3439:
	R1 = 215;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3440:
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_genss_do_setcc(asi64(R2), asu64(R1));
	goto L3349;
L3441:
	R1 = 4;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movxmm(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3442:
	R1 = 8;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movxmm(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3443:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3444:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3445:
	R1 = 4;
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_logicxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3446:
	R1 = 8;
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_logicxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3447:
	R1 = 47;
	R2 = 0;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3448:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 102;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3449:
	R1 = 243;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_convertfloat(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3450:
	R1 = 242;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_convertfloat(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3451:
	R1 = 45;
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3452:
	R1 = 45;
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3453:
	R1 = 44;
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3454:
	R1 = 44;
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3455:
	R1 = 243;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_float(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3456:
	R1 = 242;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_float(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3457:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = m;
	R4 = 34;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_genss_do_cmovcc(asi64(R3), asu64(R2), asu64(R1));
	goto L3349;
L3458:
	R1 = 217;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3459:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asu64(R3) = a;
	mc_genss_do_fmem(asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3460:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R3) = a;
	mc_genss_do_fmem(asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3461:
	R1 = 222;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3462:
	R1 = 166;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3463:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3464:
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3465:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3466:
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3467:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movdqx(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3468:
	R1 = 219;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 227;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3469:
	R1 = 217;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3470:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_popcnt(asu64(R2), asu64(R1));
	goto L3349;
L3471:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_bsf(asu64(R3), asu64(R2), asi64(R1));
	goto L3349;
L3472:
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 162;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3349;
L3473:
	asu64(R1) = a;
	mc_genss_do_bswap(asu64(R1));
	goto L3349;
L3474:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = m;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_dshift(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3349;
L3475:
	goto L3349;
L3351:
	msysc_m$print_startcon();
	R1 = tou64("*** Can't do opcode");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mc_decls_mclnames;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M.OPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M_HALT=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 152;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("STOPPING");
	mc_libmcl_axerror(asu64(R1));
L3349:
	return;
}

static void mc_genss_start() {
    u64 R1, R2, R3; 
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genss_genword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_addword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_gendword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_adddword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_genqword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_addqword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_genopnd(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 s;
	i64 x;
	i64 length;
	r32 x32;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3482;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	size = asi64(R1);
L3482:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3484;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L3485;
	goto L3486;
L3484:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 100;
	if (asi64(R1) <= asi64(R2)) goto L3488;
	R1 = 1024;
	asi64(R2) = length;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = mc_genss_currdata;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
L3488:
	goto L3490;
L3489:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3490:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L3489;
	goto L3480;
	goto L3483;
L3485:
	msysc_m$print_startcon();
	R1 = tou64("GENSS/NAME OPND");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3483;
L3486:
L3483:
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3493;
	asi64(R1) = size;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3493;
	R1 = tou64("8/16-BIT RELOC");
	mc_libmcl_axerror(asu64(R1));
L3493:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3495;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3496;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3497;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3498;
	goto L3499;
L3495:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3494;
L3496:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genword(asi64(R1));
	goto L3494;
L3497:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3501;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3502;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3503;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3503;
	goto L3504;
L3501:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3500;
L3502:
	asu64(R1) = a;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	x32 = asr32(R1);
	asr32(R1) = x32;
	asi32(R1) = asi32(R1);
	mc_genss_gendword(asi64(R1));
	goto L3500;
L3503:
	asu64(R1) = a;
	mc_genss_genabs32(asu64(R1));
	goto L3500;
L3504:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("OPND/4/VALTYPE?");
	mc_libmcl_axerror(asu64(R1));
L3500:
	goto L3494;
L3498:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3506;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3507;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3508;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3508;
	goto L3509;
L3506:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genqword(asi64(R1));
	goto L3505;
L3507:
	asu64(R1) = a;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	mc_genss_genqword(asi64(R1));
	goto L3505;
L3508:
	asu64(R1) = a;
	mc_genss_genabs64(asu64(R1));
	goto L3505;
L3509:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("OPND/8/VALTYPE?");
	mc_libmcl_axerror(asu64(R1));
L3505:
	goto L3494;
L3499:
L3494:
L3480:
	return;
}

static void mc_genss_addrelocitem(i64 reloctype, u64 d) {
    u64 R1, R2, R3; 
	u64 r;
	i64 stindex;
	i64 adjust;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
	stindex = asi64(R1);
	R1 = 4;
	adjust = asi64(R1);
	asi64(R1) = reloctype;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3512;
	R1 = 8;
	adjust = asi64(R1);
L3512:
	R1 = 32;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	r = asu64(R1);
	asu64(R1) = mc_genss_currrelocs;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = reloctype;
	asu64(R2) = r;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asi64(R2) = adjust;
	asi64(R1) -= asi64(R2);
	asu64(R2) = r;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = stindex;
	asu64(R2) = r;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_genss_nrelocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	mc_genss_currrelocs = asu64(R1);
	return;
}

static i64 mc_genss_getstindex(u64 d) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = d;
	R2 = 96;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3515;
	asi64(R1) = mc_decls_ss_nsymbols;
	asi64(R2) = mc_decls_ss_symboltablesize;
	if (asi64(R1) < asi64(R2)) goto L3517;
	mc_genss_extendsymboltable();
L3517:
	R1 = (u64)&mc_decls_ss_nsymbols;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 96;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = d;
	asu64(R2) = mc_decls_ss_symboltable;
	asu64(R3) = d;
	R4 = 96;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3519;
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3521;
	R1 = 1;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3521:
L3519:
L3515:
	asu64(R1) = d;
	R2 = 96;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L3513;
L3513:
	return asi64(R1);
}

static void mc_genss_genrel32(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3524;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3522;
L3524:
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3526;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3527;
	goto L3528;
L3526:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R1 = tou64("Rel label across segments");
	mc_libmcl_axerror(asu64(R1));
L3530:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R2) = mc_genss_getcurrdatalen(asi64(R2));
	R3 = 4;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3525;
L3527:
	R1 = 0;
	R2 = 4;
	R3 = 3;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	goto L3525;
L3528:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 4;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3525:
L3522:
	return;
}

static u64 mc_genss_getdef(u64 a, i64 dneeded) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3534;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3533;
L3534:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3536;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3537;
	goto L3538;
L3536:
	asu64(R1) = mc_decls_labeldeftable;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L3531;
	goto L3535;
L3537:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3540;
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3542;
	R1 = 1;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3542:
L3540:
	asu64(R1) = d;
	goto L3531;
	goto L3535;
L3538:
L3535:
L3533:
	asi64(R1) = dneeded;
	if (!asi64(R1)) goto L3544;
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("getdef/no def");
	mc_libmcl_axerror(asu64(R1));
L3544:
	R1 = 0;
	goto L3531;
L3531:
	return asu64(R1);
}

static void mc_genss_genabs32(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3547;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3548;
	goto L3549;
L3547:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
	goto L3546;
L3548:
	asi64(R1) = mc_genss_currseg;
	R2 = 2;
	R3 = 4;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3552;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3551;
L3552:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3550;
L3551:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3550:
	goto L3546;
L3549:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3546:
	return;
}

static void mc_genss_genabs64(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3555;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3556;
	goto L3557;
L3555:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
	goto L3554;
L3556:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	R3 = 5;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3560;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3559;
L3560:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_genqword(asi64(R1));
	goto L3558;
L3559:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3558:
	goto L3554;
L3557:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3554:
	return;
}

static i64 mc_genss_getrel32(u64 d, i64 offset) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3563;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) == asi64(R2)) goto L3565;
	R1 = tou64("Rel label across segments2");
	mc_libmcl_axerror(asu64(R1));
L3565:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	goto L3562;
L3563:
	R1 = 2147483647;
L3562:
	goto L3561;
L3561:
	return asi64(R1);
}

static void mc_genss_dofwdrefs(u64 d) {
    u64 R1, R2, R3; 
	u64 f;
	i64 offset;
	i64 seg;
	u64 p8;
	u64 p32;
	u64 p64;
	u64 data;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3568;
	goto L3566;
L3568:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L3570;
L3569:
	asu64(R1) = f;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	asu64(R1) = f;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3573;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3574;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3574;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3575;
	goto L3576;
L3573:
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p32 = asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = 4;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p32;
	*toi32p(R2) = asi32(R1);
	goto L3572;
L3574:
	asu64(R1) = f;
	R2 = 14;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3578;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3579;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3580;
	goto L3581;
L3578:
	asu64(R1) = mc_decls_ss_code;
	data = asu64(R1);
	goto L3577;
L3579:
	R1 = tou64("Fwd ref in zdata");
	mc_libmcl_axerror(asu64(R1));
	goto L3577;
L3580:
	asu64(R1) = mc_decls_ss_idata;
	data = asu64(R1);
	goto L3577;
L3581:
L3577:
	asi64(R1) = offset;
	asu64(R2) = data;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p32 = asu64(R1);
	asu64(R1) = f;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3583;
	asu64(R1) = p32;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = p32;
	*toi32p(R2) = asi32(R1);
	goto L3582;
L3583:
	asu64(R1) = p32;
	p64 = asu64(R1);
	asu64(R1) = p64;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = p64;
	*toi64p(R2) = asi64(R1);
L3582:
	goto L3572;
L3575:
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p8 = asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p8;
	*tou8p(R2) = asu8(R1);
	goto L3572;
L3576:
	msysc_m$print_startcon();
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = f;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("DOFWDREFS/CAN'T DO RELTYPE");
	mc_libmcl_axerror(asu64(R1));
L3572:
	asu64(R1) = f;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
L3570:
	asu64(R1) = f;
	if (asu64(R1)) goto L3569;
L3566:
	return;
}

static void mc_genss_genrex() {
    u64 R1, R2, R3; 
	asu8(R1) = mc_genss_f2override;
	if (!asu8(R1)) goto L3586;
	R1 = 242;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3586:
	asu8(R1) = mc_genss_f3override;
	if (!asu8(R1)) goto L3588;
	R1 = 243;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3588:
	asu8(R1) = mc_genss_sizeoverride;
	if (!asu8(R1)) goto L3590;
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3590:
	asu8(R1) = mc_genss_addroverride;
	if (!asu8(R1)) goto L3592;
	R1 = 103;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3592:
	asu8(R1) = mc_genss_nowmask;
	if (!asu8(R1)) goto L3594;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L3594:
	asu8(R1) = mc_genss_rex;
	if (!asu8(R1)) goto L3596;
	asu8(R1) = mc_genss_rex;
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = 64;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3596:
	return;
}

static i64 mc_genss_isbytesized(i64 x) {
    u64 R1, R2; 
	R1 = -128;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3598;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3598;
	R1 = 1;
	goto L3599;
L3598:
	R1 = 0;
L3599:
	goto L3597;
L3597:
	return asi64(R1);
}

static i64 mc_genss_isdwordsized(i64 x) {
    u64 R1, R2; 
	R1 = -2147483648;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3601;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L3601;
	R1 = 1;
	goto L3602;
L3601:
	R1 = 0;
L3602:
	goto L3600;
L3600:
	return asi64(R1);
}

static void mc_genss_genamode(u64 a, u64 am) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 pr;
	R1 = (u64)&am;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&am;
	R2 = 2;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3605;
	R1 = (u64)&am;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3605:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3607;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3608;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3609;
	goto L3610;
L3607:
	goto L3606;
L3608:
	R1 = (u64)&am;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3606;
L3609:
	R1 = (u64)&am;
	R2 = 2;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L3612;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pr = asu64(R1);
	asu64(R1) = mc_decls_riplist;
	asu64(R2) = pr;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_genss_currdata;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pr;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pr;
	R2 = R1;
	mc_decls_riplist = asu64(R2);
	mc_genss_ripentry = asu64(R1);
L3612:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3614;
	goto L3615;
L3614:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3617;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3617;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3618;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3618;
	goto L3619;
L3617:
	asu64(R1) = a;
	mc_genss_genabs32(asu64(R1));
	goto L3616;
L3618:
	R1 = (u64)&am;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	goto L3616;
L3619:
	R1 = tou64("genam/3");
	mc_libmcl_axerror(asu64(R1));
L3616:
	goto L3613;
L3615:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("GENAMODE/MODE?");
	mc_libmcl_axerror(asu64(R1));
L3613:
	goto L3606;
L3610:
	R1 = tou64("genamode size 2/8");
	mc_libmcl_axerror(asu64(R1));
L3606:
	return;
}

static void mc_genss_setopsize(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3622;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3623;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3624;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3625;
	goto L3626;
L3622:
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	goto L3621;
L3623:
	goto L3621;
L3624:
	goto L3621;
L3625:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	goto L3621;
L3626:
	R1 = tou64("Operand size not set");
	mc_libmcl_axerror(asu64(R1));
L3621:
	return;
}

static i64 mc_genss_getdispsize(u64 a, u64 offset) {
    u64 R1, R2; 
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L3629;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3632;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3631;
L3632:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offset;
	*toi32p(R2) += asi32(R1);
	goto L3630;
L3631:
	R1 = 4;
	goto L3627;
L3630:
L3629:
	asu64(R1) = offset;
	asi32(R1) = *toi32p(R1);
	if (!asi32(R1)) goto L3634;
	asu64(R1) = offset;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_genss_isbytesized(asi64(R1));
	if (!asi64(R1)) goto L3636;
	R1 = 1;
	goto L3635;
L3636:
	R1 = 4;
L3635:
	goto L3633;
L3634:
	R1 = 0;
L3633:
	goto L3627;
L3627:
	return asi64(R1);
}

static void mc_genss_checkhighreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3639;
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3639:
	return;
}

static void mc_genss_do_loop(u64 a, i64 opc) {
    u64 R1, R2, R3; 
	i64 offset;
	R1 = 9;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asu64(R3) = a;
	asu64(R2) = mc_genss_getdef(asu64(R3), asi64(R2));
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3642;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3644;
	R1 = tou64("loop jmp out of range");
	mc_libmcl_axerror(asu64(R1));
L3644:
	asi64(R1) = opc;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3641;
L3642:
	R1 = tou64("Can't do loopxx fwd jump");
	mc_libmcl_axerror(asu64(R1));
L3641:
	return;
}

static void mc_genss_do_jcxz(u64 a, i64 opsize) {
    u64 R1, R2, R3; 
	i64 offset;
	R1 = 10;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asu64(R3) = a;
	asu64(R2) = mc_genss_getdef(asu64(R3), asi64(R2));
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3647;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3649;
	R1 = tou64("jcxz jmp out of range");
	mc_libmcl_axerror(asu64(R1));
L3649:
	asi64(R1) = opsize;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3651;
	R1 = 103;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3651:
	R1 = 227;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3646;
L3647:
	R1 = tou64("Can't do jcxz fwd jump");
	mc_libmcl_axerror(asu64(R1));
L3646:
	return;
}

static void mc_genss_do_call(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3654;
	goto L3655;
L3654:
	R1 = 232;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3653;
L3655:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3657;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3658;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3658;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3658;
	goto L3659;
L3657:
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L3656;
L3658:
	R1 = tou64("call[]size");
	mc_libmcl_axerror(asu64(R1));
	goto L3656;
L3659:
L3656:
	asu64(R1) = a;
	R2 = 2;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
L3653:
	return;
}

static void mc_genss_do_jmp(u64 a, u64 m) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	i64 offset;
	i64 shortjmp;
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3662;
	goto L3663;
L3662:
	R1 = 11;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3665;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) <= asi64(R2)) goto L3665;
	R1 = 235;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3664;
L3665:
	R1 = 0;
	shortjmp = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3667;
	asu64(R1) = d;
	asu64(R2) = m;
	asi64(R1) = mc_genss_checkshortjump(asu64(R2), asu64(R1));
	shortjmp = asi64(R1);
L3667:
	asi64(R1) = shortjmp;
	if (asi64(R1)) goto L3669;
	R1 = 233;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3668;
L3669:
	R1 = 235;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel8(asu64(R1));
L3668:
L3664:
	goto L3661;
L3663:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3671;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3672;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3672;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3672;
	goto L3673;
L3671:
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L3670;
L3672:
	R1 = tou64("jmp[]size");
	mc_libmcl_axerror(asu64(R1));
	goto L3670;
L3673:
L3670:
	asu64(R1) = a;
	R2 = 4;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
L3661:
	return;
}

static i64 mc_genss_getcurrdatalen(i64 id) {
    u64 R1, R2; 
	asi64(R1) = mc_genss_currseg;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3676;
	asi64(R1) = mc_decls_ss_zdatalen;
	goto L3674;
L3676:
	asu64(R1) = mc_genss_currdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	goto L3674;
L3674:
	return asi64(R1);
}

static void mc_genss_do_cmovcc(i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3679;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3679;
	R1 = tou64("1:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3679:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3681;
	R1 = tou64("cmov/byte");
	mc_libmcl_axerror(asu64(R1));
L3681:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3904;
	asi64(R4) = cond;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_fmem(u64 a, i64 freal, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	i64 am;
	i64 regcode;
	i64 mf;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3684;
	R1 = tou64("fmem/not mem");
	mc_libmcl_axerror(asu64(R1));
L3684:
	asi64(R1) = freal;
	if (!asi64(R1)) goto L3686;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3688;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3689;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3690;
	R2 = 16;
	if (asu64(R1) == asu64(R2)) goto L3690;
	goto L3691;
L3688:
	R1 = 0;
	mf = asi64(R1);
	goto L3687;
L3689:
	R1 = 2;
	mf = asi64(R1);
	goto L3687;
L3690:
	R1 = 1;
	mf = asi64(R1);
	asi64(R1) = code;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3693;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3694;
	goto L3695;
L3693:
	R1 = 5;
	code = asi64(R1);
	goto L3692;
L3694:
	R1 = 7;
	code = asi64(R1);
	goto L3692;
L3695:
	R1 = tou64("r80 not allowed");
	mc_libmcl_axerror(asu64(R1));
L3692:
	goto L3687;
L3691:
	msysc_m$print_startcon();
	R1 = tou64("SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("fmem size");
	mc_libmcl_axerror(asu64(R1));
L3687:
	goto L3685;
L3686:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3697;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3698;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3699;
	goto L3700;
L3697:
	R1 = 3;
	mf = asi64(R1);
	goto L3696;
L3698:
	R1 = 1;
	mf = asi64(R1);
	goto L3696;
L3699:
	R1 = 3;
	mf = asi64(R1);
	asi64(R1) = code;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3702;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3703;
	goto L3704;
L3702:
	R1 = 5;
	code = asi64(R1);
	goto L3701;
L3703:
	R1 = 7;
	code = asi64(R1);
	goto L3701;
L3704:
	R1 = tou64("fst i64?");
	mc_libmcl_axerror(asu64(R1));
L3701:
	goto L3696;
L3700:
	R1 = tou64("fmem int size");
	mc_libmcl_axerror(asu64(R1));
L3696:
L3685:
	asu64(R1) = a;
	asi64(R2) = code;
	R3 = 217;
	asi64(R4) = mf;
	R5 = 1;
	asi64(R4) <<= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void mc_genss_genrel8(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3707;
	R1 = 0;
	R2 = 6;
	R3 = 3;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3706;
L3707:
	R1 = tou64("genrel8");
	mc_libmcl_axerror(asu64(R1));
L3706:
	return;
}

static i64 mc_genss_checkshortjump(u64 m, u64 d) {
    u64 R1, R2, R3; 
	i64 n;
	u64 a;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L3710;
L3709:
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3713;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3714;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3714;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L3715;
	goto L3716;
L3713:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3718;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3719;
	goto L3720;
L3718:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 100;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L3722;
	R1 = 1;
	goto L3708;
L3722:
	goto L3717;
L3719:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L3724;
	R1 = 1;
	goto L3708;
L3724:
	goto L3717;
L3720:
L3717:
	goto L3712;
L3714:
	goto L3712;
L3715:
	R1 = 0;
	goto L3708;
	goto L3712;
L3716:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L3712:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3710:
	asu64(R1) = m;
	if (!asu64(R1)) goto L3725;
	asi64(R1) = n;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L3709;
L3725:
	R1 = 0;
	goto L3708;
L3708:
	return asi64(R1);
}

static u64 mc_genss_addfwdref(u64 p, i64 offset, i64 reltype, i64 seg) {
    u64 R1, R2, R3; 
	u64 q;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = q;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = reltype;
	asu64(R2) = q;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = seg;
	asu64(R2) = q;
	R3 = 14;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	goto L3726;
L3726:
	return asu64(R1);
}

static void mc_genss_switchseg(i64 newseg) {
    u64 R1, R2; 
	asi64(R1) = newseg;
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) != asi64(R2)) goto L3729;
	goto L3727;
L3729:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3731;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3732;
	goto L3733;
L3731:
	asu64(R1) = mc_genss_currrelocs;
	mc_decls_ss_coderelocs = asu64(R1);
	asi64(R1) = mc_genss_nrelocs;
	mc_decls_ss_ncoderelocs = asi64(R1);
	goto L3730;
L3732:
	asu64(R1) = mc_genss_currrelocs;
	mc_decls_ss_idatarelocs = asu64(R1);
	asi64(R1) = mc_genss_nrelocs;
	mc_decls_ss_nidatarelocs = asi64(R1);
	goto L3730;
L3733:
L3730:
	asi64(R1) = newseg;
	mc_genss_currseg = asi64(R1);
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3735;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3736;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3737;
	goto L3738;
L3735:
	asu64(R1) = mc_decls_ss_code;
	mc_genss_currdata = asu64(R1);
	asu64(R1) = mc_decls_ss_coderelocs;
	mc_genss_currrelocs = asu64(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	mc_genss_nrelocs = asi64(R1);
	goto L3734;
L3736:
	asu64(R1) = mc_decls_ss_idata;
	mc_genss_currdata = asu64(R1);
	asu64(R1) = mc_decls_ss_idatarelocs;
	mc_genss_currrelocs = asu64(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	mc_genss_nrelocs = asi64(R1);
	goto L3734;
L3737:
	asu64(R1) = mc_decls_ss_zdata;
	mc_genss_currdata = asu64(R1);
	goto L3734;
L3738:
L3734:
L3727:
	return;
}

static void mc_genss_do_popcnt(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3741;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3743;
	R1 = 8;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3743:
L3741:
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 4024;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_bsf(u64 a, u64 b, i64 opc) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3746;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3748;
	R1 = 8;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3748:
L3746:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3750;
	R1 = tou64("bsf size");
	mc_libmcl_axerror(asu64(R1));
L3750:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_extendsymboltable() {
    u64 R1, R2, R3; 
	u64 oldsymboltable;
	i64 oldsymboltablesize;
	i64 i;
	asi64(R1) = mc_decls_ss_symboltablesize;
	oldsymboltablesize = asi64(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	oldsymboltable = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_ss_symboltablesize;
	*toi64p(R2) *= asi64(R1);
	R1 = 8;
	asi64(R2) = mc_decls_ss_symboltablesize;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_ss_symboltable = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3754;
L3752:
	asu64(R1) = oldsymboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = mc_decls_ss_symboltable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L3752;
L3754:
	R1 = 8;
	asi64(R2) = oldsymboltablesize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = oldsymboltable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_initlib(i64 nlabels) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	u64 d;
	i64 i;
	R1 = 262144;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_ss_symboltable = asu64(R1);
	R1 = 32768;
	mc_decls_ss_symboltablesize = asi64(R1);
	R1 = 0;
	mc_decls_ss_nsymbols = asi64(R1);
	asi64(R1) = nlabels;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_labeldeftable = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlabels;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3758;
L3756:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	R2 = R1;
	asu64(R3) = mc_decls_labeldeftable;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	d = asu64(R1);
	asi64(R1) = i;
	asu64(R2) = d;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("l#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= nlabels) goto L3756;
L3758:
	return;
}

static u64 mc_genss_buffercreate(i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	a = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = a;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	goto L3759;
L3759:
	return asu64(R1);
}

static void mc_genss_bufferexpand(u64 a) {
    u64 R1, R2, R3; 
	i64 newalloc;
	i64 usedbytes;
	u64 p;
	asu64(R1) = a;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newalloc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	usedbytes = asi64(R1);
	asi64(R1) = usedbytes;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L3762;
	msysc_m$print_startcon();
	R1 = tou64("dbuffer error");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
L3762:
	asi64(R1) = newalloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = usedbytes;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asi64(R2) = usedbytes;
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newalloc;
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	asi64(R2) = newalloc;
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mc_genss_buffercheck(u64 a, i64 n) {
    u64 R1, R2, R3; 
	goto L3765;
L3764:
	asu64(R1) = a;
	mc_genss_bufferexpand(asu64(R1));
L3765:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L3764;
	return;
}

static i64 mc_genss_bufferlength(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	goto L3767;
L3767:
	return asi64(R1);
}

static u64 mc_genss_bufferelemptr(u64 a, i64 offset) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	R1 += (i64)R2;
	goto L3768;
L3768:
	return asu64(R1);
}

static void mc_genss_addword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou16p(R2) = asu16(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 2;
	return;
}

static void mc_genss_adddword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou32p(R2) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 4;
	return;
}

static void mc_genss_addqword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou64p(R2) = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 8;
	return;
}

static void mc_genss_genxrm(i64 opcode, i64 code, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 am;
	asu64(R1) = b;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	asi64(R3) = code;
	R4 = 0;
	asu64(R1) = mc_genss_genrm(asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	am = asu64(R1);
	asu64(R1) = mc_genss_currmcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3774;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3774;
	goto L3775;
L3774:
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L3773;
L3775:
L3773:
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3777;
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 24;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3777:
	mc_genss_genrex();
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3779;
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3779:
	asi64(R1) = opcode;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = am;
	asu64(R2) = b;
	mc_genss_genamode(asu64(R2), asu64(R1));
	return;
}

static void mc_genss_genrrm(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3782;
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3782:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu8(R1) = mc_genss_usesizeb;
	if (!asu8(R1)) goto L3784;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3786;
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3786:
L3784:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu64(R4) = a;
	R5 = 10;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R1) = mc_genss_genrm(asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	am = asu64(R1);
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3788;
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 24;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3788:
	mc_genss_genrex();
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3790;
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3790:
	asi64(R1) = opcode;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = am;
	asu64(R2) = b;
	mc_genss_genamode(asu64(R2), asu64(R1));
	return;
}

static i64 mc_genss_getregcode(i64 reg, i64 mask, i64 isxreg) {
    u64 R1, R2; 
	i64 regcode;
	asi64(R1) = isxreg;
	if (asi64(R1)) goto L3793;
	R1 = (u64)&mc_decls_regcodes;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regcode = asi64(R1);
	goto L3792;
L3793:
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	regcode = asi64(R1);
L3792:
	asi64(R1) = regcode;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L3795;
	R1 = 8;
	R2 = (u64)&regcode;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mask;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3795:
	asi64(R1) = regcode;
	goto L3791;
L3791:
	return asi64(R1);
}

static void mc_genss_checkimmrange(i64 value, i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3798;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3799;
	goto L3800;
L3798:
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3803;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3802;
L3803:
	R1 = tou64("exceeding byte value");
	mc_libmcl_axerror(asu64(R1));
L3802:
	goto L3797;
L3799:
	R1 = -32768;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3806;
	R2 = 65535;
	if (asi64(R1) <= asi64(R2)) goto L3805;
L3806:
	R1 = tou64("exceeding u16 value");
	mc_libmcl_axerror(asu64(R1));
L3805:
	goto L3797;
L3800:
	R1 = -2147483648;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3809;
	R2 = 4294967295;
	if (asi64(R1) <= asi64(R2)) goto L3808;
L3809:
	R1 = tou64("2:exceeding u32 value");
	mc_libmcl_axerror(asu64(R1));
L3808:
L3797:
	return;
}

static u64 mc_genss_genrm(i64 reg, i64 opc, u64 b, i64 isxreg) {
    u64 R1, R2, R3, R4; 
	i64 mode;
	i64 rm;
	i64 scale;
	i64 index;
	i64 base;
	i64 regix;
	i64 code;
	i64 ismem;
	u64 am;
// PROC LOCAL STATICS GO HERE
	static struct $B31 mc_genss_genrm_scaletable = {{
	0,
	1,
	0,
	2,
	0,
	0,
	0,
	3    }};
	R1 = (u64)&am;
	memset(R1, 0, 8);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3812;
	asi64(R1) = isxreg;
	R2 = 4;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	opc = asi64(R1);
L3812:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3814;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3814;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3815;
	goto L3816;
L3814:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = 1;
	asu64(R3) = b;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	rm = asi64(R1);
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	R1 = 192;
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = rm;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = am;
	goto L3810;
	goto L3813;
L3815:
	R1 = 1;
	ismem = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3818;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3819;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3820;
	goto L3821;
L3818:
	asu64(R1) = b;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3823;
	R1 = 2;
	ismem = asi64(R1);
L3823:
	goto L3817;
L3819:
	R1 = 2;
	ismem = asi64(R1);
	goto L3817;
L3820:
	R1 = 2;
	ismem = asi64(R1);
	goto L3817;
L3821:
L3817:
	goto L3813;
L3816:
	R1 = tou64("genrm not mem");
	mc_libmcl_axerror(asu64(R1));
L3813:
	R1 = 0;
	R2 = R1;
	rm = asi64(R2);
	mode = asi64(R1);
	R1 = 0;
	scale = asi64(R1);
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = b;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	asi64(R2) = regix;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3825;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3825;
	R1 = 0;
	mode = asi64(R1);
	R1 = 4;
	rm = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
	R1 = 4;
	index = asi64(R1);
	R1 = 5;
	base = asi64(R1);
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3824;
L3825:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L3826;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3826;
// mc_genss.genrm.simple:
L3827:
	R1 = (u64)&am;
	R2 = 4;
	R1 += (i64)R2;
	asu64(R2) = b;
	asi64(R1) = mc_genss_getdispsize(asu64(R2), asu64(R1));
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3829;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3831;
	R1 = 1;
	goto L3830;
L3831:
	R1 = 2;
L3830:
	mode = asi64(R1);
L3829:
	R1 = 0;
	R2 = 1;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	base = asi64(R2);
	rm = asi64(R1);
	asi64(R1) = rm;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3833;
	asi64(R1) = rm;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3835;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3835;
	R1 = 1;
	mode = asi64(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3835:
	R1 = 0;
	index = asi64(R1);
	goto L3832;
L3833:
	R1 = 4;
	index = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
L3832:
	goto L3824;
L3826:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3836;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3836;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L3838;
	R1 = (u64)&reg;
	R2 = (u64)&regix;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	goto L3827;
L3838:
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	mode = asi64(R1);
	R1 = 4;
	rm = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3840;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3839;
L3840:
	R1 = 1;
L3839:
	scale = asi64(R1);
	R1 = 5;
	base = asi64(R1);
	R1 = 0;
	R2 = 2;
	asi64(R3) = regix;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	index = asi64(R1);
	asi64(R1) = regix;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3842;
	R1 = tou64("Scaled rstack?");
	mc_libmcl_axerror(asu64(R1));
L3842:
	goto L3824;
L3836:
	R1 = (u64)&am;
	R2 = 4;
	R1 += (i64)R2;
	asu64(R2) = b;
	asi64(R1) = mc_genss_getdispsize(asu64(R2), asu64(R1));
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3844;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3846;
	R1 = 1;
	goto L3845;
L3846:
	R1 = 2;
L3845:
	mode = asi64(R1);
L3844:
	R1 = 4;
	rm = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3848;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3847;
L3848:
	R1 = 1;
L3847:
	scale = asi64(R1);
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3850;
	R1 = 5;
	base = asi64(R1);
	goto L3849;
L3850:
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3853;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3852;
L3853:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3852;
	R1 = 1;
	mode = asi64(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3852:
	R1 = 0;
	R2 = 1;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	base = asi64(R1);
L3849:
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3855;
	R1 = 4;
	index = asi64(R1);
	goto L3854;
L3855:
	R1 = 0;
	R2 = 2;
	asi64(R3) = regix;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	index = asi64(R1);
	asi64(R1) = reg;
	if (asi64(R1)) goto L3857;
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3857:
	asi64(R1) = regix;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3859;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3859;
	R1 = tou64("Can't scale rstack");
	mc_libmcl_axerror(asu64(R1));
L3859:
L3854:
L3824:
	asi64(R1) = scale;
	if (!asi64(R1)) goto L3861;
	R1 = (u64)&mc_genss_genrm_scaletable;
	asi64(R2) = scale;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 6;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = index;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = base;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 2;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L3861:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3863;
	asi64(R1) = ismem;
	if (!asi64(R1)) goto L3863;
	asi64(R1) = reg;
	if (asi64(R1)) goto L3866;
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3865;
L3866:
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3868;
	asi64(R1) = ismem;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3868;
	msysc_m$print_startcon();
	R1 = tou64("Addr32 can't use RIP, line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = mc_genss_currmcl;
	asu64(R1) = mc_writeasm_strmclstr(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3868:
	goto L3864;
L3865:
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L3869;
	R1 = -1;
	R2 = (u64)&am;
	R3 = 2;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
	R1 = 0;
	mode = asi64(R1);
	R1 = 5;
	rm = asi64(R1);
L3869:
L3864:
L3863:
	asi64(R1) = mode;
	R2 = 6;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = rm;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = am;
	goto L3810;
L3810:
	return asu64(R1);
}

static void mc_genss_do_arith(u64 a, u64 b, i64 code) {
    u64 R1, R2, R3, R4; 
	u64 d;
	i64 opc;
	i64 dispsize;
	i64 x;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3872;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3873;
	goto L3874;
L3872:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3876;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3876;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3877;
	goto L3878;
L3876:
	asi64(R1) = code;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R3 = 1;
	if (asi64(R2) != asi64(R3)) goto L3880;
	R2 = 2;
	goto L3879;
L3880:
	R2 = 3;
L3879:
	asi64(R1) |= asi64(R2);
	opc = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3875;
L3877:
// mc_genss.do_arith.doregimm:
L3881:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L3883;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L3885;
	R1 = tou64("add imm/size");
	mc_libmcl_axerror(asu64(R1));
L3885:
	asu64(R1) = a;
	asi64(R2) = code;
	R3 = 129;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3870;
L3883:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	R1 = 1;
	dispsize = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3887;
	R1 = 128;
	opc = asi64(R1);
	R1 = 1;
	asi64(R2) = x;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
	asi64(R1) = x;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L3890;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3889;
L3890:
	R1 = tou64("Exceeding i8/u8 range");
	mc_libmcl_axerror(asu64(R1));
L3889:
	goto L3886;
L3887:
	R1 = -128;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3891;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3891;
	R1 = 131;
	opc = asi64(R1);
	goto L3886;
L3891:
	R1 = 4;
	asi64(R2) = x;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
	R1 = 129;
	opc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3893;
	R1 = 2;
	goto L3892;
L3893:
	R1 = 4;
L3892:
	dispsize = asi64(R1);
L3886:
	asu64(R1) = a;
	asi64(R2) = code;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = dispsize;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3895;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3896;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3897;
	goto L3898;
L3895:
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3894;
L3896:
	asi64(R1) = x;
	mc_genss_genword(asi64(R1));
	goto L3894;
L3897:
	asi64(R1) = x;
	mc_genss_gendword(asi64(R1));
	goto L3894;
L3898:
L3894:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3875;
L3878:
	R1 = tou64("ADD reg,???");
	mc_libmcl_axerror(asu64(R1));
L3875:
	goto L3871;
L3873:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3900;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3901;
	goto L3902;
L3900:
	asi64(R1) = code;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R3 = 1;
	if (asi64(R2) != asi64(R3)) goto L3904;
	R2 = 0;
	goto L3903;
L3904:
	R2 = 1;
L3903:
	asi64(R1) |= asi64(R2);
	opc = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3899;
L3901:
	goto L3881;
	goto L3899;
L3902:
	R1 = tou64("ADD mem,???");
	mc_libmcl_axerror(asu64(R1));
L3899:
	goto L3871;
L3874:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asi64(R2) = code;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("CODE=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = code;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1:Can't add to this opnd");
	mc_libmcl_axerror(asu64(R1));
L3871:
L3870:
	return;
}

static void mc_genss_do_mov(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 regcode;
	i64 opc;
	i64 dispsize;
	i64 value;
	u64 d;
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3907;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3908;
	goto L3909;
L3907:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3911;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3911;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3912;
	goto L3913;
L3911:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3915;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3915;
	R1 = tou64("2:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3915:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3917;
	R3 = 138;
	goto L3916;
L3917:
	R3 = 139;
L3916:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3910;
L3912:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	regcode = asi64(R1);
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L3919;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3919;
	R1 = tou64("mov imm?");
	mc_libmcl_axerror(asu64(R1));
L3919:
	asu64(R1) = a;
	mc_genss_checkhighreg(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3921;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3922;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3923;
	goto L3924;
L3921:
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3927;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3926;
L3927:
	R1 = tou64("exceeding byte value");
	mc_libmcl_axerror(asu64(R1));
L3926:
	mc_genss_genrex();
	R1 = 176;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3920;
L3922:
	R1 = -32768;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3930;
	R2 = 65535;
	if (asi64(R1) <= asi64(R2)) goto L3929;
L3930:
	R1 = tou64("exceeding u16 value");
	mc_libmcl_axerror(asu64(R1));
L3929:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3920;
L3923:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3932;
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3931;
L3932:
	R1 = -2147483648;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3935;
	R2 = 4294967295;
	asi64(R2) = toi64(tou32(R2));
	if (asi64(R1) <= asi64(R2)) goto L3934;
L3935:
	msysc_m$print_startcon();
	asi64(R1) = value;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = value;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1:exceeding u32 value");
	mc_libmcl_axerror(asu64(R1));
L3934:
// mc_genss.do_mov.doreg32:
L3936:
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L3931:
	goto L3920;
L3924:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3938;
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 8;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3937;
L3938:
	asi64(R1) = value;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3940;
	asi64(R1) = value;
	R2 = 4294967295;
	if (asi64(R1) > asi64(R2)) goto L3940;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L3936;
L3940:
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genqword(asi64(R1));
L3937:
L3920:
	goto L3910;
L3913:
	R1 = tou64("MOV REG/??");
	mc_libmcl_axerror(asu64(R1));
L3910:
	goto L3906;
L3908:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3942;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3943;
	goto L3944;
L3942:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3946;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3946:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3948;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3948;
	R1 = tou64("3:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3948:
	asu64(R1) = a;
	asu64(R2) = b;
	asu64(R3) = b;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3950;
	R3 = 136;
	goto L3949;
L3950:
	R3 = 137;
L3949:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3941;
L3943:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3952;
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3952:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3954;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3954;
	R1 = tou64("mov imm?");
	mc_libmcl_axerror(asu64(R1));
L3954:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3956;
	R1 = 198;
	goto L3955;
L3956:
	R1 = 199;
L3955:
	opc = asi64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L3958;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = value;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
L3958:
	asu64(R1) = a;
	R2 = 0;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	dispsize = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3960;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3961;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3962;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3962;
	goto L3963;
L3960:
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3959;
L3961:
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3959;
L3962:
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	R1 = 4;
	dispsize = asi64(R1);
	goto L3959;
L3963:
L3959:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3941;
L3944:
	R1 = tou64("MOV MEM/?");
	mc_libmcl_axerror(asu64(R1));
L3941:
	goto L3906;
L3909:
	R1 = tou64("MOV ?/..");
	mc_libmcl_axerror(asu64(R1));
L3906:
	return;
}

static void mc_genss_do_push(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3966;
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3966:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3968;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3969;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3970;
	goto L3971;
L3968:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3973;
	R1 = tou64("pushreg not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3973:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	mc_genss_genrex();
	R1 = 80;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3967;
L3969:
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3975;
	R1 = 104;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3974;
L3975:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_genss_isbytesized(asi64(R1));
	if (!asi64(R1)) goto L3976;
	R1 = 106;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3974;
L3976:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_genss_isdwordsized(asi64(R1));
	if (!asi64(R1)) goto L3977;
	R1 = 104;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3974;
L3977:
	R1 = tou64("push imm value too large");
	mc_libmcl_axerror(asu64(R1));
L3974:
	goto L3967;
L3970:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3979;
	R1 = tou64("push not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3979:
	asu64(R1) = a;
	R2 = 6;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3967;
L3971:
	R1 = tou64("push opnd?");
	mc_libmcl_axerror(asu64(R1));
L3967:
	return;
}

static void mc_genss_do_pop(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3982;
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3982:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3984;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3985;
	goto L3986;
L3984:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3988;
	R1 = tou64("popreg not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3988:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	mc_genss_genrex();
	R1 = 88;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3983;
L3985:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3990;
	R1 = tou64("pop not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3990:
	asu64(R1) = a;
	R2 = 0;
	R3 = 143;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3983;
L3986:
	R1 = tou64("pop opnd?");
	mc_libmcl_axerror(asu64(R1));
L3983:
	return;
}

static void mc_genss_do_inc(u64 a, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3993;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3993;
	goto L3994;
L3993:
	asu64(R1) = a;
	asi64(R2) = code;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3996;
	R3 = 254;
	goto L3995;
L3996:
	R3 = 255;
L3995:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3992;
L3994:
	R1 = tou64("inc/opnd?");
	mc_libmcl_axerror(asu64(R1));
L3992:
	return;
}

static void mc_genss_do_neg(u64 a, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3999;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3999;
	goto L4000;
L3999:
	asu64(R1) = a;
	asi64(R2) = code;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4002;
	R3 = 246;
	goto L4001;
L4002:
	R3 = 247;
L4001:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3998;
L4000:
	R1 = tou64("neg/div/etc opnd?");
	mc_libmcl_axerror(asu64(R1));
L3998:
	return;
}

static void mc_genss_do_lea(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4006;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4005;
L4006:
	R1 = tou64("LEA not reg/mem");
	mc_libmcl_axerror(asu64(R1));
L4005:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L4008;
	msysc_m$print_startcon();
	R1 = tou64("A.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("LEA size error");
	mc_libmcl_axerror(asu64(R1));
L4008:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 141;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_movsx(u64 a, u64 b, i64 opc) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4011;
	R1 = tou64("movsx not reg");
	mc_libmcl_axerror(asu64(R1));
L4011:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4013;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4013;
	asi64(R1) = opc;
	R2 = 190;
	if (asi64(R1) != asi64(R2)) goto L4015;
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_movsxd(asu64(R2), asu64(R1));
	goto L4014;
L4015:
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	R2 = 4;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_mov(asu64(R2), asu64(R1));
L4014:
	goto L4009;
L4013:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4018;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) > asu64(R2)) goto L4017;
L4018:
	R1 = tou64("movsx size error");
	mc_libmcl_axerror(asu64(R1));
L4017:
	asi64(R1) = opc;
	R2 = 182;
	if (asi64(R1) != asi64(R2)) goto L4020;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4020;
	R1 = tou64("movsx 4=>8 bytes?");
	mc_libmcl_axerror(asu64(R1));
L4020:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4022;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4023;
	goto L4024;
L4022:
	goto L4021;
L4023:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4026;
	R1 = tou64("movsx need size prefix");
	mc_libmcl_axerror(asu64(R1));
L4026:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4028;
	R1 = tou64("movsx size 8");
	mc_libmcl_axerror(asu64(R1));
L4028:
	goto L4021;
L4024:
	R1 = tou64("movsx not reg/mem");
	mc_libmcl_axerror(asu64(R1));
L4021:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asu64(R4) = b;
	R5 = 8;
	asu16(R4) = *tou16p(((i64)R4+(i64)R5));
	R4 = toi64(tou16(R4));
	R5 = 0;
	R6 = 4;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	if (asi64(R4) != asi64(R5)) goto L4030;
	asi64(R4) = opc;
	goto L4029;
L4030:
	asi64(R4) = opc;
	R5 = 1;
	asi64(R4) += asi64(R5);
L4029:
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4009:
	return;
}

static void mc_genss_do_exch(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 regcode;
	i64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4033;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4033;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4034;
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4033;
L4034:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4033;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4036;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L4036:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L4038;
	R1 = tou64("exch size");
	mc_libmcl_axerror(asu64(R1));
L4038:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	regcode = asi64(R1);
	mc_genss_genrex();
	R1 = 144;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L4031;
L4033:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4040;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L4040:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4043;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4042;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4042;
L4043:
	R1 = tou64("exch opnds");
	mc_libmcl_axerror(asu64(R1));
L4042:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4045;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4045;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4045:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L4047;
	R1 = tou64("exch size");
	mc_libmcl_axerror(asu64(R1));
L4047:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4049;
	R3 = 134;
	goto L4048;
L4049:
	R3 = 135;
L4048:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4031:
	return;
}

static void mc_genss_do_movsxd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4052;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4052;
	R1 = 4;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4052:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4055;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L4054;
L4055:
	R1 = tou64("movsxd size");
	mc_libmcl_axerror(asu64(R1));
L4054:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4058;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4057;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4057;
L4058:
	R1 = tou64("movsxd opnds");
	mc_libmcl_axerror(asu64(R1));
L4057:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 99;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_imul2(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	i64 opc;
	i64 dispsize;
	i64 value;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4061;
	R1 = tou64("imul2 opnds");
	mc_libmcl_axerror(asu64(R1));
L4061:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4063;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4063:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4065;
	R1 = tou64("imul2 byte");
	mc_libmcl_axerror(asu64(R1));
L4065:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4067;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4067;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4068;
	goto L4069;
L4067:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L4071;
	R1 = tou64("imul2 size");
	mc_libmcl_axerror(asu64(R1));
L4071:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 4015;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4066;
L4068:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L4073;
	R1 = tou64("mul/label");
	mc_libmcl_axerror(asu64(R1));
L4073:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L4075;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L4075;
	R1 = 107;
	opc = asi64(R1);
	goto L4074;
L4075:
	R1 = 105;
	opc = asi64(R1);
L4074:
	asu64(R1) = a;
	asu64(R2) = a;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L4077;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L4077;
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	dispsize = asi64(R1);
	goto L4076;
L4077:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4078;
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	R1 = 2;
	dispsize = asi64(R1);
	goto L4076;
L4078:
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
	R1 = 4;
	dispsize = asi64(R1);
L4076:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L4066;
L4069:
	R1 = tou64("imul2 opnds");
	mc_libmcl_axerror(asu64(R1));
L4066:
	return;
}

static void mc_genss_do_shift(u64 a, u64 b, i64 code) {
    u64 R1, R2, R3; 
	i64 w;
	i64 opc;
	i64 needdisp;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4081;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4081;
	R1 = tou64("shift opnds1?");
	mc_libmcl_axerror(asu64(R1));
L4081:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L4083;
	R1 = tou64("shift/label");
	mc_libmcl_axerror(asu64(R1));
L4083:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4085;
	R1 = 0;
	goto L4084;
L4085:
	R1 = 1;
L4084:
	w = asi64(R1);
	R1 = 0;
	needdisp = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4087;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4088;
	goto L4089;
L4087:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4091;
	R1 = 208;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4090;
L4091:
	R1 = 192;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	R1 = 1;
	needdisp = asi64(R1);
L4090:
	goto L4086;
L4088:
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4094;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4093;
L4094:
	R1 = tou64("cl or b10 needed");
	mc_libmcl_axerror(asu64(R1));
L4093:
	R1 = 210;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4086;
L4089:
	R1 = tou64("shift opnds2?");
	mc_libmcl_axerror(asu64(R1));
L4086:
	asu64(R1) = a;
	asi64(R2) = code;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = needdisp;
	if (!asi64(R1)) goto L4096;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_fixrip(asi64(R1));
L4096:
	return;
}

static void mc_genss_do_test(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 value;
	i64 opc;
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4099;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4099;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4099;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4101;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4102;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4103;
	goto L4104;
L4101:
	R1 = 168;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L4100;
L4102:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L4100;
L4103:
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
	goto L4100;
L4104:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L4100:
	goto L4098;
L4099:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4106;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4105;
L4106:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4105;
	asu64(R1) = a;
	R2 = 0;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4108;
	R3 = 246;
	goto L4107;
L4108:
	R3 = 247;
L4107:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4110;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4111;
	goto L4112;
L4110:
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L4109;
L4111:
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L4109;
L4112:
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L4109:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	mc_genss_fixrip(asi64(R1));
	goto L4098;
L4105:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4114;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4113;
L4114:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4113;
// mc_genss.do_test.domemreg:
L4115:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4117;
	R3 = 132;
	goto L4116;
L4117:
	R3 = 133;
L4116:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4098;
L4113:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4118;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4118;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	goto L4115;
	goto L4098;
L4118:
	R1 = tou64("test opnds");
	mc_libmcl_axerror(asu64(R1));
L4098:
	return;
}

static void mc_genss_do_setcc(i64 cond, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4123;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4122;
L4123:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4121;
L4122:
	R1 = tou64("setcc opnd/size");
	mc_libmcl_axerror(asu64(R1));
L4121:
	asu64(R1) = b;
	R2 = 0;
	R3 = 3984;
	asi64(R4) = cond;
	asi64(R3) += asi64(R4);
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void mc_genss_checksize(u64 a, i64 size1, i64 size2) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4126;
	R1 = tou64("Need size");
	mc_libmcl_axerror(asu64(R1));
L4126:
	asi64(R1) = size1;
	if (!asi64(R1)) goto L4128;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size1;
	if (asi64(R1) == asi64(R2)) goto L4128;
	asi64(R2) = size2;
	if (asi64(R1) == asi64(R2)) goto L4128;
	msysc_m$print_startcon();
	R1 = tou64("A.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Wrong size");
	mc_libmcl_axerror(asu64(R1));
L4128:
	return;
}

static void mc_genss_do_arithxmm(u64 a, u64 b, i64 prefix, i64 opc) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4132;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4131;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4131;
L4132:
	R1 = tou64("arithxmm opnds");
	mc_libmcl_axerror(asu64(R1));
L4131:
	asi64(R1) = prefix;
	if (!asi64(R1)) goto L4134;
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4134:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_logicxmm(u64 a, u64 b, i64 opc, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4138;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4137;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4137;
L4138:
	R1 = tou64("logicxmm opnds");
	mc_libmcl_axerror(asu64(R1));
L4137:
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4140;
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4140:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_convertfloat(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4144;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4143;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4143;
L4144:
	R1 = tou64("convertfloat opnds");
	mc_libmcl_axerror(asu64(R1));
L4143:
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3930;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_fix(u64 a, u64 b, i64 prefix, i64 opc) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4148;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4147;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4147;
L4148:
	R1 = tou64("fix opnds");
	mc_libmcl_axerror(asu64(R1));
L4147:
	R1 = 8;
	R2 = 4;
	asu64(R3) = a;
	mc_genss_checksize(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = prefix;
	R2 = 243;
	if (asi64(R1) != asi64(R2)) goto L4150;
	R1 = 4;
	goto L4149;
L4150:
	R1 = 8;
L4149:
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_float(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4154;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4153;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4153;
L4154:
	R1 = tou64("float opnds");
	mc_libmcl_axerror(asu64(R1));
L4153:
	R1 = 8;
	R2 = 4;
	asu64(R3) = b;
	mc_genss_checksize(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = prefix;
	R2 = 243;
	if (asi64(R1) != asi64(R2)) goto L4156;
	R1 = 4;
	goto L4155;
L4156:
	R1 = 8;
L4155:
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_usesizeb = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3882;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_movxmm(u64 a, u64 b, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	i64 regcode1;
	i64 regcode2;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4159;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4160;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4161;
	goto L4162;
L4159:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4164;
	goto L4165;
L4164:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4167;
	R1 = tou64("1:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4167:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4163;
L4165:
	R1 = tou64("movdq reg,?");
	mc_libmcl_axerror(asu64(R1));
L4163:
	goto L4158;
L4160:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4169;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4170;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4171;
	goto L4172;
L4169:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4174;
	R1 = tou64("3:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4174:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3950;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4168;
L4170:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4168;
L4171:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4176;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4176:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4178;
	R1 = tou64("31:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4178:
	asi64(R1) = size;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4180;
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3950;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4179;
L4180:
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4179:
	goto L4168;
L4172:
	R1 = tou64("movdq xreg,?");
	mc_libmcl_axerror(asu64(R1));
L4168:
	goto L4158;
L4161:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4182;
	goto L4183;
L4182:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L4185;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4185;
	R1 = tou64("5:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4185:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = size;
	R4 = 4;
	if (asi64(R3) != asi64(R4)) goto L4187;
	R3 = 3966;
	goto L4186;
L4187:
	R3 = 4054;
L4186:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4181;
L4183:
	R1 = tou64("movdq mem,?");
	mc_libmcl_axerror(asu64(R1));
L4181:
	goto L4158;
L4162:
	R1 = tou64("movdq opnds");
	mc_libmcl_axerror(asu64(R1));
L4158:
	return;
}

static void mc_genss_fixrip(i64 dispsize) {
    u64 R1, R2, R3; 
	u64 codeaddr;
	u64 offsetptr;
	asu64(R1) = mc_genss_ripentry;
	if (asu64(R1)) goto L4190;
	goto L4188;
L4190:
	asi64(R1) = dispsize;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4192;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4193;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4193;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4193;
	goto L4194;
L4192:
	goto L4188;
	goto L4191;
L4193:
	goto L4191;
L4194:
	msysc_m$print_startcon();
	R1 = tou64("DISPSIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = dispsize;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("fixrip disp?");
	mc_libmcl_axerror(asu64(R1));
L4191:
	asi64(R1) = dispsize;
	asu64(R2) = mc_genss_ripentry;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4188:
	return;
}

static void mc_genss_do_bswap(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4198;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L4197;
L4198:
	R1 = tou64("bswap reg>");
	mc_libmcl_axerror(asu64(R1));
L4197:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	mc_genss_genrex();
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 200;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_genss_do_movdqx(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = prefix;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	R2 = 3840;
	asi64(R1) += asi64(R2);
	prefix = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4201;
	R1 = 16;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4201:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4203;
	R1 = 16;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4203:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4205;
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = prefix;
	R4 = 127;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4204;
L4205:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = prefix;
	R4 = 111;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4204:
	return;
}

static void mc_genss_do_dshift(u64 a, u64 b, i64 c, i64 opc) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4208;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4208:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L4211;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L4210;
L4211:
	R1 = tou64("dshift/size");
	mc_libmcl_axerror(asu64(R1));
L4210:
	R1 = 0;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = c;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_decls_start() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4215;
L4213:
	R1 = 10;
	R2 = (u64)&mc_decls_ploadop;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L4213;
L4215:
	R1 = 19;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 5;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 4;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 18;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 9;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 8;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 17;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 10;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mc_writeasm_writemcl(i64 index, u64 mcl) {
    u64 R1, R2; 
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4218;
	asu64(R1) = mcl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 63;
	if (asu64(R1) != asu64(R2)) goto L4218;
	goto L4217;
L4218:
	asu64(R1) = mcl;
	mc_writeasm_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
L4217:
	return;
}

static void mc_writeasm_strmcl(u64 mcl) {
    u64 R1, R2, R3, R4; 
	struct $B21 opcname;
	u64 a;
	u64 b;
	i64 opcode;
	i64 cond;
	i64 sizepref;
	u64 s;
	u64 comment;
	u64 d;
	u8 first;
	i64 r;
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeasm_strmcl_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = mcl;
	R2 = 34;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu64(R1) = mcl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = mcl;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	comment = asu64(R1);
	asi64(R1) = opcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4221;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4222;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4223;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4224;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4225;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4226;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4227;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4228;
	goto L4229;
L4221:
	R1 = tou64(";Proc ");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	R1 = (u64)&mc_writeasm_regvars;
	memset(R1, 0, 128);
	R1 = (u64)&mc_writeasm_xregvars;
	memset(R1, 0, 128);
	goto L4219;
	goto L4220;
L4222:
	R1 = tou64(";End\n");
	mc_writeasm_asmstr(asu64(R1));
	R1 = 0;
	mc_decls_currasmproc = asu64(R1);
	goto L4219;
	goto L4220;
L4223:
	R1 = 59;
	mc_writeasm_asmchar(asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writeasm_asmstr(asu64(R1));
	goto L4219;
	goto L4220;
L4224:
	goto L4219;
	goto L4220;
L4225:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4231;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4232;
	goto L4233;
L4231:
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	mc_writeasm_asmstr(asu64(R1));
	goto L4230;
L4232:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writeasm_asmstr(asu64(R1));
	goto L4219;
	goto L4230;
L4233:
	R1 = tou64("");
	R2 = tou64("strmcl/lab");
	pc_api_merror(asu64(R2), asu64(R1));
L4230:
	R1 = tou64(":");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4235;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4237;
	R1 = tou64(":");
	mc_writeasm_asmstr(asu64(R1));
	goto L4236;
L4237:
	R1 = tou64("\n`");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	mc_writeasm_asmstr(asu64(R1));
	R1 = tou64("::");
	mc_writeasm_asmstr(asu64(R1));
L4236:
L4235:
	goto L4219;
	goto L4220;
L4226:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4239;
	R1 = (u64)&mc_writeasm_strmcl_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("L#:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L4238;
L4239:
	goto L4225;
L4238:
	R1 = (u64)&mc_writeasm_strmcl_str;
	mc_writeasm_asmstr(asu64(R1));
	goto L4219;
	goto L4220;
L4227:
	R1 = tou64("    ");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writeasm_asmstr(asu64(R1));
	R1 = tou64(" = ");
	mc_writeasm_asmstr(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L4219;
	goto L4220;
L4228:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = tou64("    ");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L4241;
	asu64(R1) = d;
	R2 = (u64)&mc_writeasm_xregvars;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4240;
L4241:
	asu64(R1) = d;
	R2 = (u64)&mc_writeasm_regvars;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4240:
	R1 = tou64(" = ");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4243;
	goto L4244;
L4243:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_getregname(asi64(R2), asi64(R1));
	mc_writeasm_asmstr(asu64(R1));
	goto L4242;
L4244:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_getxregname(asi64(R2), asi64(R1));
	mc_writeasm_asmstr(asu64(R1));
L4242:
	goto L4219;
	goto L4220;
L4229:
L4220:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4246;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4247;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4248;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L4249;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4250;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4251;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L4252;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L4253;
	goto L4254;
L4246:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("j");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4245;
L4247:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("set");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4245;
L4248:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("cmov");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4245;
L4249:
	R1 = tou64("and");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4245;
L4250:
	R1 = tou64("or");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4245;
L4251:
	R1 = tou64("xor");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4245;
L4252:
	R1 = tou64("not");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4245;
L4253:
	R1 = tou64("dq");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4245;
L4254:
	asi64(R1) = opcode;
	R2 = 152;
	if (asi64(R1) <= asi64(R2)) goto L4256;
	R1 = 0;
	asi64(R2) = opcode;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4255;
L4256:
	R1 = (u64)&mc_decls_mclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 2;
	R1 += (i64)R2;
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L4255:
L4245:
	R1 = tou64(" ");
	asi64(R2) = opcode;
	R3 = 119;
	if (asi64(R2) != asi64(R3)) goto L4258;
	R2 = 4;
	goto L4257;
L4258:
	R2 = 10;
L4257:
	R3 = (u64)&opcname;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 4;
	R3 = (u64)&mc_writeasm_strmcl_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&opcname;
	R2 = (u64)&mc_writeasm_strmcl_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writeasm_strmcl_str;
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L4260;
	asu64(R1) = b;
	if (!asu64(R1)) goto L4260;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	asi64(R1) = mc_writeasm_needsizeprefix(asi64(R3), asu64(R2), asu64(R1));
	sizepref = asi64(R1);
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = a;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64(",\t");
	mc_writeasm_asmstr(asu64(R1));
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = b;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = mcl;
	R2 = 32;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4262;
	R1 = tou64(",");
	mc_writeasm_asmstr(asu64(R1));
	R1 = 0;
	asu64(R2) = mcl;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	mc_writeasm_asmstr(asu64(R1));
L4262:
	goto L4259;
L4260:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4263;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L4263;
	asi64(R1) = opcode;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4265;
	asi64(R1) = opcode;
	R2 = 0;
	asu64(R3) = a;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L4264;
L4265:
	asi64(R1) = opcode;
	R2 = 1;
	asu64(R3) = a;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
L4264:
L4263:
L4259:
L4219:
	return;
}

static u64 mc_writeasm_strmclstr(u64 m) {
    u64 R1, R2; 
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = m;
	mc_writeasm_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4266;
L4266:
	return asu64(R1);
}

static u64 mc_writeasm_mstropnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3, R4; 
	struct $B21 str2;
	u64 plus;
	u64 t;
	i64 offset;
	i64 tc;
	R1 = 0;
	R2 = (u64)&mc_writeasm_mstropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4269;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4270;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4271;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4272;
	goto L4273;
L4269:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_strreg(asi64(R2), asi64(R1));
	goto L4267;
	goto L4268;
L4270:
	asi64(R1) = opcode;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L4275;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4275;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4277;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L4277;
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4276;
L4277:
	R1 = tou64("0x");
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("H");
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4276:
	goto L4274;
L4275:
	asu64(R1) = a;
	asu64(R1) = mc_writeasm_strvalue(asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L4274:
	goto L4268;
L4271:
	asi64(R1) = sizeprefix;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = mc_writeasm_getsizeprefix(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("[");
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4279;
	R1 = 8;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
L4279:
	asu64(R1) = a;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4281;
	asu64(R1) = plus;
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = a;
	R3 = 11;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4283;
	R1 = tou64("*");
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 5;
	R4 = 8;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4283:
L4281:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4286;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4286;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4285;
L4286:
	asu64(R1) = plus;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L4288;
	asu64(R1) = plus;
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4288:
	asu64(R1) = a;
	asu64(R1) = mc_writeasm_strvalue(asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4284;
L4285:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L4289;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" + ");
	asi64(R2) = offset;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4289:
L4284:
	R1 = tou64("]");
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4268;
L4272:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_strxreg(asi64(R2), asi64(R1));
	goto L4267;
	goto L4268;
L4273:
	msysc_m$print_startcon();
	R1 = tou64("BAD OPND");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<BAD OPND>");
	goto L4267;
L4268:
	R1 = (u64)&mc_writeasm_mstropnd_str;
	goto L4267;
L4267:
	return asu64(R1);
}

static u64 mc_writeasm_strvalue(u64 a) {
    u64 R1, R2, R3; 
	struct $B21 str2;
	u64 def;
	i64 value;
	i64 offset;
	i64 length;
	u64 ss;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	def = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4292;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4293;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4294;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4295;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4296;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L4297;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L4298;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L4299;
	goto L4300;
L4292:
	asu64(R1) = def;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
// mc_writeasm.strvalue.addoffset:
L4301:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L4303;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4305;
	R1 = tou64("+");
	goto L4304;
L4305:
	R1 = tou64("");
L4304:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = offset;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4303:
	goto L4291;
L4293:
	R1 = 0;
	asi64(R2) = value;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4291;
L4294:
	R1 = (u64)&mc_writeasm_strvalue_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("20.20");
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4291;
L4295:
	R1 = tou64("M");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4291;
L4296:
	R1 = tou64("\"");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4291;
L4297:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4291;
L4298:
	R1 = tou64("L");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4301;
	goto L4291;
L4299:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_currasmproc;
	asu64(R1) = mc_writeasm_gettempname(asu64(R2), asi64(R1));
	goto L4290;
	goto L4291;
L4300:
	R1 = tou64("");
	R2 = tou64("Stropnd?");
	pc_api_merror(asu64(R2), asu64(R1));
L4291:
	R1 = (u64)&mc_writeasm_strvalue_str;
	goto L4290;
L4290:
	return asu64(R1);
}

static void mc_writeasm_asmopnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	asi64(R2) = sizeprefix;
	asu64(R3) = a;
	asu64(R1) = mc_writeasm_mstropnd(asu64(R3), asi64(R2), asi64(R1));
	mc_writeasm_asmstr(asu64(R1));
	return;
}

static u64 mc_writeasm_getregname(i64 reg, i64 size) {
    u64 R1, R2, R3; 
	struct $B3 str2;
	u64 rs;
	i64 size2;
// PROC LOCAL STATICS GO HERE
	static struct $B40 mc_writeasm_getregname_prefix = {{
	(u64)"B",
	(u64)"W",
	(u64)"",
	(u64)"A",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"D",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"Q",
	(u64)"N"    }};
	R1 = (u64)&mc_writeasm_nregnames;
	asi64(R2) = size;
	R1 += (i64)R2*128-128;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L4307;
	asi64(R1) = size;
	size2 = asi64(R1);
	asi64(R1) = size2;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L4309;
	R1 = 17;
	size2 = asi64(R1);
L4309:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4311;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4312;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4313;
	goto L4314;
L4311:
	R1 = tou64("-");
	goto L4307;
	goto L4310;
L4312:
	R1 = tou64("fp");
	rs = asu64(R1);
	goto L4310;
L4313:
	R1 = tou64("sp");
	rs = asu64(R1);
	goto L4310;
L4314:
	R1 = (u64)&str2;
	asi64(R2) = reg;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	msysc_getstrint(asi64(R2), asu64(R1));
	R1 = (u64)&str2;
	rs = asu64(R1);
L4310:
	R1 = (u64)&mc_writeasm_getregname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = (u64)&mc_writeasm_getregname_prefix;
	asi64(R2) = size2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = rs;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writeasm_getregname_str;
	goto L4307;
L4307:
	return asu64(R1);
}

static u64 mc_writeasm_getxregname(i64 reg, i64 size) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4317;
	R1 = tou64("-");
	goto L4315;
L4317:
	R1 = (u64)&mc_writeasm_getxregname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("XMM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writeasm_getxregname_str;
	goto L4315;
L4315:
	return asu64(R1);
}

static void mc_writeasm_asmstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mc_writeasm_asmchar(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_char(asu64(R2), asi64(R1));
	return;
}

static u64 mc_writeasm_getdispname(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4322;
	R1 = (u64)&mc_writeasm_getdispname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("##R.#");
	msysc_m$print_setfmt(asu64(R1));
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4324;
	R1 = tou64("");
	goto L4323;
L4324:
	R1 = tou64("`");
L4323:
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4326;
	R1 = tou64("X");
	goto L4325;
L4326:
	R1 = tou64("");
L4325:
	msysc_m$print_str_nf(asu64(R1));
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4328;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4327;
L4328:
	R1 = 0;
	asu64(R2) = d;
	asu64(R1) = pc_api_getfullname(asu64(R2), asi64(R1));
L4327:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writeasm_getdispname_str;
	goto L4320;
L4322:
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4330;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4329;
L4330:
	R1 = 1;
	asu64(R2) = d;
	asu64(R1) = pc_api_getfullname(asu64(R2), asi64(R1));
L4329:
	goto L4320;
L4320:
	return asu64(R1);
}

static u64 mc_writeasm_gettempname(u64 d, i64 n) {
    u64 R1, R2; 
	asu8(R1) = pc_api_fpshortnames;
	if (asu8(R1)) goto L4334;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4333;
L4334:
	R1 = (u64)&mc_writeasm_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L4332;
L4333:
	R1 = (u64)&mc_writeasm_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.$T#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L4332:
	R1 = (u64)&mc_writeasm_gettempname_str;
	goto L4331;
L4331:
	return asu64(R1);
}

static u64 mc_writeasm_strreg(i64 reg, i64 size) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = (u64)&mc_writeasm_regvars;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L4337;
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = size;
	if (asi64(R1) != asi64(R2)) goto L4337;
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	goto L4335;
L4337:
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_writeasm_getregname(asi64(R2), asi64(R1));
	goto L4335;
L4335:
	return asu64(R1);
}

static u64 mc_writeasm_strxreg(i64 reg, i64 size) {
    u64 R1, R2; 
	u64 d;
	R1 = (u64)&mc_writeasm_xregvars;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4340;
	asu64(R1) = d;
	if (!asu64(R1)) goto L4340;
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	goto L4339;
L4340:
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_writeasm_getxregname(asi64(R2), asi64(R1));
L4339:
	goto L4338;
L4338:
	return asu64(R1);
}

static u64 mc_writeasm_getassemstr() {
    u64 R1, R2; 
	u64 d;
	u64 e;
	u64 m;
	struct $B17 str2;
	struct $B17 str3;
	i64 i;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4343;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4344;
	goto L4345;
L4343:
	R1 = tou64("    $userip\n");
	mc_writeasm_asmstr(asu64(R1));
	goto L4342;
L4344:
	R1 = tou64("    $highmem\n");
	mc_writeasm_asmstr(asu64(R1));
	goto L4342;
L4345:
L4342:
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L4347;
L4346:
	asu64(R1) = m;
	asi64(R2) = i;
	mc_writeasm_writemcl(asi64(R2), asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L4347:
	asu64(R1) = m;
	if (asu64(R1)) goto L4346;
	asu64(R1) = pc_decls_pdest;
	goto L4341;
L4341:
	return asu64(R1);
}

static i64 mc_writeasm_needsizeprefix(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L4351;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4351;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4351;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4351;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L4352;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4352;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4352;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4352;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4353;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4353;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4353;
	goto L4354;
L4351:
	R1 = 1;
	goto L4349;
	goto L4350;
L4352:
	R1 = 1;
	goto L4349;
	goto L4350;
L4353:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4356;
	R1 = 1;
	goto L4349;
L4356:
	R1 = 0;
	goto L4349;
	goto L4350;
L4354:
L4350:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4359;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4359;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4359;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4358;
L4359:
	R1 = 0;
	goto L4349;
L4358:
	R1 = 1;
	goto L4349;
L4349:
	return asi64(R1);
}

static u64 mc_writeasm_getsizeprefix(i64 size, i64 enable) {
    u64 R1, R2; 
	asi64(R1) = enable;
	if (asi64(R1)) goto L4362;
	R1 = tou64("");
	goto L4360;
L4362:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4364;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4365;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4366;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4367;
	goto L4368;
L4364:
	R1 = tou64("byte ");
	goto L4360;
	goto L4363;
L4365:
	R1 = tou64("u16 ");
	goto L4360;
	goto L4363;
L4366:
	R1 = tou64("u32 ");
	goto L4360;
	goto L4363;
L4367:
	R1 = tou64("u64 ");
	goto L4360;
	goto L4363;
L4368:
L4363:
	R1 = tou64("");
	goto L4360;
L4360:
	return asu64(R1);
}

static void mc_writeasm_start() {
    u64 R1, R2, R3; 
	u8 flag;
	i64 av_1;
	i64 i;
	i64 r;
	i64 k;
	R1 = 16705;
	pc_decls_assemtype = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4370:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4375;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4375;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4375;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4374;
L4375:
	R1 = 1;
	r = asi64(R1);
L4376:
	R1 = 0;
	flag = asu8(R1);
	R1 = 1;
	k = asi64(R1);
	R1 = 137;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4381;
L4379:
	asu8(R1) = flag;
	if (!asu8(R1)) goto L4383;
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L4385;
	R1 = (u64)&mc_decls_regindices;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = r;
	if (asi64(R1) != asi64(R2)) goto L4385;
	R1 = (u64)&mc_decls_dregnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_writeasm_nregnames;
	asi64(R3) = i;
	R2 += (i64)R3*128-128;
	asi64(R3) = r;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4385:
	goto L4382;
L4383:
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4386;
	R1 = 1;
	flag = asu8(R1);
L4386:
L4382:
	k += 1; if (k <= av_1) goto L4379;
L4381:
	r += 1; if (r <= 16) goto L4376;
L4374:
	i += 1; if (i <= 8) goto L4370;
	return;
}

static void mc_writeexe_writeexe(u64 outfile, i64 dodll, u64 entrypoint) {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_exedone;
	if (!asu8(R1)) goto L4389;
	goto L4387;
L4389:
	asi64(R1) = dodll;
	asu64(R2) = outfile;
	asu64(R3) = entrypoint;
	mc_writeexe_genexe1(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = dodll;
	asu64(R2) = outfile;
	mc_writeexe_genexe2(asu64(R2), asi64(R1));
	R1 = 1;
	pc_decls_exedone = asu8(R1);
L4387:
	return;
}

static void mc_writeexe_genexe1(u64 entrypoint, u64 outfile, i64 dodll) {
    u64 R1, R2, R3, R4; 
	i64 offset;
	u64 codeaddr;
	u64 offsetptr;
	u64 pr;
	mc_writeexe_initsectiontable();
	asu64(R1) = outfile;
	asu64(R1) = mlib_extractfile(asu64(R1));
	mc_writeexe_dllfilename = asu64(R1);
	asi64(R1) = dodll;
	mc_writeexe_isdll = asi64(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4392;
	R1 = 268435456;
	goto L4391;
L4392:
	R1 = 4194304;
L4391:
	mc_writeexe_imagebase = asi64(R1);
	asu64(R1) = entrypoint;
	mc_writeexe_userentrypoint = asu64(R1);
	mc_writeexe_loadlibs();
	mc_writeexe_scanst();
	mc_writeexe_getoffsets();
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writeexe_relocdata(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writeexe_relocdata(asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codeaddr = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L4394;
	asu64(R1) = mc_decls_riplist;
	pr = asu64(R1);
	goto L4398;
L4395:
	asu64(R1) = codeaddr;
	asu64(R2) = pr;
	R3 = 8;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	offsetptr = asu64(R1);
	asu64(R1) = pr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offsetptr;
	asu32(R2) = *tou32p(R2);
	R2 = toi64(tou32(R2));
	asi64(R3) = mc_writeexe_imagebase;
	asi64(R2) -= asi64(R3);
	asu64(R3) = pr;
	R4 = 8;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asi64(R1) = mc_writeexe_getripoffset(asi64(R3), asi64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	asu64(R2) = offsetptr;
	*tou32p(R2) = asu32(R1);
	asu64(R1) = pr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pr = asu64(R1);
L4398:
	asu64(R1) = pr;
	if (asu64(R1)) goto L4395;
L4394:
	return;
}

static void mc_writeexe_genexe2(u64 outfile, i64 dodll) {
    u64 R1, R2, R3; 
	struct $B54 header;
	struct $B90 optheader;
	i64 offset;
	i64 i;
	i64 aa;
	asu64(R1) = outfile;
	asu64(R1) = mlib_extractfile(asu64(R1));
	mc_writeexe_dllfilename = asu64(R1);
	asi64(R1) = dodll;
	mc_writeexe_isdll = asi64(R1);
	asi64(R1) = mc_writeexe_filesize;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	R2 = R1;
	mc_writeexe_dataptr = asu64(R2);
	mc_writeexe_datastart = asu64(R1);
	mc_writeexe_writedosstub();
	mc_writeexe_writepesig();
	mc_writeexe_writefileheader();
	mc_writeexe_writeoptheader();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4402;
L4400:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	mc_writeexe_writesectionheader(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4400;
L4402:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_writeexe_writepadding(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4405;
L4403:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	mc_writeexe_writesectiondata(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4403;
L4405:
	asu8(R1) = pc_decls_pverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4407;
	msysc_m$print_startcon();
	R1 = tou64("EXE size:  ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_writeexe_dataptr;
	asu64(R3) = mc_writeexe_datastart;
	asi64(R2) -= asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L4407:
	asu64(R1) = mc_writeexe_dataptr;
	asu64(R2) = mc_writeexe_datastart;
	asi64(R1) -= asi64(R2);
	asu64(R2) = mc_writeexe_datastart;
	asu64(R3) = outfile;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4409;
	msysc_m$print_startcon();
	R1 = tou64("Error writing exe file (possibly still running)");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L4409:
	return;
}

static void mc_writeexe_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	i64 hinst;
	u64 file;
	struct $B15 filename;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4413;
L4411:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4415;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filename;
	asi64(R1) = mlinux_os_getdllinst(asu64(R1));
	hinst = asi64(R1);
	asi64(R1) = hinst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4417;
	msysc_m$print_startcon();
	R1 = tou64("File:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't load search lib");
	mc_libmcl_axerror(asu64(R1));
L4417:
	asi64(R1) = hinst;
	R2 = (u64)&mc_writeexe_libinsttable;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&filename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_libinstnames;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4415:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4411;
L4413:
	return;
}

static void mc_writeexe_initsectiontable() {
    u64 R1, R2, R3; 
	R1 = tou64(".text");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_code;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L4420;
	msysc_m$print_startcon();
	R1 = tou64("Code size: ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_code;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("bytes");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = pc_decls_pverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4422;
	msysc_m$print_startcon();
	R1 = tou64("Idata size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_idata;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Code+Idata:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_code;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	asu64(R3) = mc_decls_ss_idata;
	asi64(R3) = mc_genss_bufferlength(asu64(R3));
	asi64(R2) += asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Zdata size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asi64(R2) = mc_decls_ss_zdatalen;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4422:
L4420:
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4424;
	R1 = 0;
	asu64(R2) = mc_decls_ss_idata;
	mc_genss_addqword(asu64(R2), asi64(R1));
L4424:
	R1 = tou64(".data");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idata;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idatarelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4426;
	R1 = 16;
	mc_decls_ss_zdatalen = asi64(R1);
L4426:
	R1 = tou64(".bss");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 3;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_coderelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64(".idata");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 5;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	mc_writeexe_nsections = asi64(R1);
	return;
}

static u64 mc_writeexe_extractlibname(u64 name, u64 libno, i64 moduleno) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 name2;
	struct $B16 str;
	struct $B16 str2;
	i64 i;
	i64 n;
	R1 = 0;
	name2 = asu64(R1);
// mc_writeexe.extractlibname.reenter:
	asu64(R1) = name;
	s = asu64(R1);
	R1 = 0;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	goto L4430;
L4429:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L4433;
	asu64(R1) = s;
	asu64(R2) = name;
	asu64(R1) -= asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asu64(R4) = name;
	asi64(R3) -= asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = tou64(".dll");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4436;
L4434:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4438;
	asi64(R1) = i;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asu64(R2) = libno;
	asi64(R2) = *toi64p(R2);
	R1 += (i64)R2*48-40;
	(*toi64p(R1)) += 1;
	asu64(R1) = name2;
	if (!asu64(R1)) goto L4440;
	asu64(R1) = name2;
	goto L4439;
L4440:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
L4439:
	goto L4427;
L4438:
	i += 1; if (i <= mc_writeexe_ndlls) goto L4434;
L4436:
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4442;
	R1 = tou64("Too many libs");
	mc_libmcl_axerror(asu64(R1));
L4442:
	R1 = (u64)&mc_writeexe_ndlls;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = name2;
	if (!asu64(R1)) goto L4444;
	asu64(R1) = name2;
	goto L4443;
L4444:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
L4443:
	goto L4427;
L4433:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L4430:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L4429;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4448;
L4445:
	R1 = (u64)&mc_writeexe_libinsttable;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L4450;
	asu64(R1) = name;
	R2 = (u64)&mc_writeexe_libinsttable;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlinux_os_getdllprocaddr(asi64(R2), asu64(R1));
	if (!asu64(R1)) goto L4452;
	asi64(R1) = i;
	n = asi64(R1);
	goto L4447;
L4452:
L4450:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4445;
L4448:
	msysc_m$print_startcon();
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find external function");
	mc_libmcl_axerror(asu64(R1));
L4447:
	R1 = (u64)&mc_writeexe_libnotable;
	asi64(R2) = n;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	asu64(R3) = libno;
	*toi64p(R3) = asi64(R2);
	if (!asi64(R1)) goto L4454;
	R1 = (u64)&mc_writeexe_dlltable;
	asu64(R2) = libno;
	asi64(R2) = *toi64p(R2);
	R1 += (i64)R2*48-40;
	(*toi64p(R1)) += 1;
	asu64(R1) = name;
	goto L4427;
L4454:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".dll");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4456;
	R1 = tou64("2:Too many libs");
	mc_libmcl_axerror(asu64(R1));
L4456:
	R1 = (u64)&mc_writeexe_ndlls;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = libno;
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&mc_writeexe_libnotable;
	asi64(R3) = n;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = name;
	goto L4427;
L4427:
	return asu64(R1);
}

static void mc_writeexe_scanst() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 libno;
	u64 d;
	u64 name;
	u64 libname;
	u64 basename;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4460;
L4458:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4462;
	asi64(R1) = mc_writeexe_nimports;
	R2 = 3000;
	if (asi64(R1) < asi64(R2)) goto L4464;
	R1 = tou64("genexe: Too many imports");
	mc_libmcl_axerror(asu64(R1));
L4464:
	R1 = (u64)&mc_writeexe_nimports;
	(*toi64p(R1)) += 1;
	R1 = 1;
	R2 = (u64)&libno;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mc_writeexe_extractlibname(asu64(R3), asu64(R2), asi64(R1));
	name = asu64(R1);
	asi64(R1) = libno;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = name;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mc_writeexe_nimports;
	asu64(R2) = d;
	R3 = 98;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L4461;
L4462:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4465;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	basename = asu64(R1);
	asu64(R1) = mc_writeexe_userentrypoint;
	if (!asu64(R1)) goto L4467;
	asu64(R1) = mc_writeexe_userentrypoint;
	asu64(R2) = basename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4469;
	asu64(R1) = d;
	mc_writeexe_stentrypoint = asu64(R1);
L4469:
	goto L4466;
L4467:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4471;
	asi64(R1) = mc_writeexe_isdll;
	if (asi64(R1)) goto L4471;
	asu64(R1) = d;
	mc_writeexe_stentrypoint = asu64(R1);
L4471:
L4466:
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L4473;
	R1 = tou64("gendll: Too many exports");
	mc_libmcl_axerror(asu64(R1));
L4473:
	R1 = (u64)&mc_writeexe_nexports;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = (u64)&mc_writeexe_exporttable;
	asi64(R3) = mc_writeexe_nexports;
	R2 += (i64)R3*16-16;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	R2 = (u64)&mc_writeexe_exporttable;
	asi64(R3) = mc_writeexe_nexports;
	R2 += (i64)R3*16-16;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4465:
L4461:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4458;
L4460:
	return;
}

static void mc_writeexe_relocdata(u64 s) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 r;
	u64 p;
	u64 p32;
	u64 p64;
	u64 d;
	i64 offset;
	i64 index;
	i64 thunkoffset;
	i64 iatoffset;
	R1 = 0;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = s;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L4476;
L4475:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 98;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = index;
	R1 += (i64)R2*48;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	thunkoffset = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4479;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4480;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4480;
	goto L4481;
L4479:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4483;
	R1 = tou64("rel32/not imported");
	mc_libmcl_axerror(asu64(R1));
L4483:
	asi64(R1) = thunkoffset;
	asu64(R2) = r;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 4;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4478;
L4480:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4485;
	asi64(R1) = mc_writeexe_imagebase;
	asi64(R2) = thunkoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4484;
L4485:
	R1 = 0;
	u = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4487;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4488;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4489;
	goto L4490;
L4487:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 144;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4486;
L4488:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4486;
L4489:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4486;
L4490:
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("RELOCDATA/SEG?");
	mc_libmcl_axerror(asu64(R1));
L4486:
	asu64(R1) = p;
	asu64(R2) = r;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	p32 = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4492;
	asu64(R1) = p32;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R2) = u;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_writeexe_imagebase;
	asi64(R1) += asi64(R2);
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	goto L4491;
L4492:
	asu64(R1) = p32;
	p64 = asu64(R1);
	asu64(R1) = p64;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = u;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_writeexe_imagebase;
	asu64(R1) += asu64(R2);
	asu64(R2) = p64;
	*tou64p(R2) = asu64(R1);
L4491:
L4484:
	goto L4478;
L4481:
	msysc_m$print_startcon();
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't do this rel type");
	mc_libmcl_axerror(asu64(R1));
L4478:
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4476:
	asu64(R1) = r;
	if (asu64(R1)) goto L4475;
	return;
}

static void mc_writeexe_getbaserelocs(u64 s) {
    u64 R1, R2, R3, R4; 
	u64 r;
	u64 p;
	u64 d;
	i64 index;
	R1 = 0;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = s;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L4495;
L4494:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4498;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4498;
	goto L4499;
L4498:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4501;
	goto L4500;
L4501:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4503;
	goto L4502;
L4503:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	mc_writeexe_newbasereloc(asi64(R2), asi64(R1));
L4502:
L4500:
	goto L4497;
L4499:
L4497:
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4495:
	asu64(R1) = r;
	if (asu64(R1)) goto L4494;
	return;
}

static void mc_writeexe_writerecordx(u64 r, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = r;
	asu64(R3) = mc_writeexe_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&mc_writeexe_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeexe_writedosstub() {
    u64 R1, R2; 
// PROC LOCAL STATICS GO HERE
	static struct $B21 mc_writeexe_writedosstub_stubdata = {{
12894362189,
	281470681743364,
	184,
	64,
	0,
	0,
	0,
	549755813888,
	-3672206108803850482,
	7517670843615393825,
	8243680180223112041,
	8029476550202125665,
	7959393399912669300,
	2329292586301155616,
	724249607997255533,
	36    }};
	R1 = 128;
	R2 = (u64)&mc_writeexe_writedosstub_stubdata;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writepesig() {
    u64 R1, R2, R3; 
	R1 = 80;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 69;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_writeexe_writepadding(i64 offset) {
    u64 R1, R2; 
	asu64(R1) = mc_writeexe_datastart;
	asi64(R2) = offset;
	R1 += (i64)R2;
	mc_writeexe_dataptr = asu64(R1);
	return;
}

static void mc_writeexe_writefileheader() {
    u64 R1, R2, R3; 
	struct $B54 header;
	R1 = (u64)&header;
	memset(R1, 0, 20);
	R1 = 34404;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = (u64)&header;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 240;
	R2 = (u64)&header;
	R3 = 16;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 559;
	R2 = (u64)&header;
	R3 = 18;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4510;
	R1 = 8750;
	R2 = (u64)&header;
	R3 = 18;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L4510:
	R1 = 20;
	R2 = (u64)&header;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writeoptheader() {
    u64 R1, R2, R3; 
	struct $B90 header;
	R1 = (u64)&header;
	memset(R1, 0, 240);
	R1 = 523;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&header;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&header;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 2;
	R1 += (i64)R2*72-72;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	R2 = (u64)&header;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&header;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = mc_writeexe_stentrypoint;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4513;
	asu64(R1) = mc_writeexe_stentrypoint2;
	mc_writeexe_stentrypoint = asu64(R1);
L4513:
	asu64(R1) = mc_writeexe_stentrypoint;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4515;
	asu64(R1) = mc_writeexe_userentrypoint;
	if (!asu64(R1)) goto L4517;
	msysc_m$print_startcon();
	asu64(R1) = mc_writeexe_userentrypoint;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("User entry point not found");
	mc_libmcl_axerror(asu64(R1));
	goto L4516;
L4517:
	asi64(R1) = mc_writeexe_isdll;
	if (asi64(R1)) goto L4519;
	R1 = tou64("Entry point not found: main");
	mc_libmcl_axerror(asu64(R1));
L4519:
L4516:
	goto L4514;
L4515:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_writeexe_stentrypoint;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = (u64)&header;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4514:
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&header;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 32;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 512;
	R2 = (u64)&header;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 4;
	R2 = (u64)&header;
	R3 = 40;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 0;
	R2 = (u64)&header;
	R3 = 42;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&header;
	R3 = 48;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 2;
	R2 = (u64)&header;
	R3 = 50;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_imagesize;
	R2 = (u64)&header;
	R3 = 56;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 60;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = (u64)&header;
	R3 = 68;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 4194304;
	R2 = (u64)&header;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2097152;
	R2 = (u64)&header;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1048576;
	R2 = (u64)&header;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 16;
	R2 = (u64)&header;
	R3 = 108;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeexe_exportdirvirtsize;
	asi64(R1) -= asi64(R2);
	asi64(R2) = mc_writeexe_blockdirvirtsize;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&header;
	R3 = 124;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4521;
	R1 = 64;
	R2 = (u64)&header;
	R3 = 70;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_exportdirvirtaddr;
	R2 = (u64)&header;
	R3 = 112;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_exportdirvirtsize;
	R2 = (u64)&header;
	R3 = 116;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_blockdirvirtaddr;
	R2 = (u64)&header;
	R3 = 152;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_blockdirvirtsize;
	R2 = (u64)&header;
	R3 = 156;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4521:
	asi64(R1) = mc_writeexe_fileiatoffset;
	R2 = (u64)&header;
	R3 = 208;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_fileiatsize;
	R2 = (u64)&header;
	R3 = 212;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 240;
	R2 = (u64)&header;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writesectionheader(u64 s) {
    u64 R1, R2, R3; 
	struct $B73 sheader;
	i64 aa;
	R1 = (u64)&sheader;
	memset(R1, 0, 40);
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4524;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4525;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4526;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4527;
	goto L4528;
L4524:
	R1 = 3226468480;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4523;
L4525:
	R1 = 3226468416;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4523;
L4526:
	R1 = 1615855648;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4523;
L4527:
	R1 = 3224371264;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4523;
L4528:
L4523:
	R1 = 40;
	R2 = (u64)&sheader;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writesectiondata(u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = s;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4531;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4532;
	goto L4533;
L4531:
	asu64(R1) = s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L4535;
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mc_writeexe_dataptr;
	*tou64p(R2) += asu64(R1);
L4535:
	goto L4530;
L4532:
	goto L4530;
L4533:
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R3) = s;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
L4530:
	return;
}

static void mc_writeexe_writeexporttable(u64 pstart) {
    u64 R1, R2, R3; 
	struct $B50 sortindex;
	u64 phdr;
	u64 paddrtable;
	u64 pnametable;
	u64 pordtable;
	u64 pdllname;
	u64 pnames;
	i64 addrtableoffset;
	i64 nametableoffset;
	i64 ordtableoffset;
	i64 dllnameoffset;
	i64 namesoffset;
	i64 virtoffset;
	i64 sectionno;
	u64 d;
	u64 basename;
	i64 i;
	asu64(R1) = pstart;
	phdr = asu64(R1);
	R1 = 1602876664;
	asu64(R2) = phdr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = phdr;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_nexports;
	asu64(R2) = phdr;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_nexports;
	asu64(R2) = phdr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 40;
	addrtableoffset = asi64(R1);
	asi64(R1) = addrtableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 4;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	nametableoffset = asi64(R1);
	asi64(R1) = nametableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 4;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	ordtableoffset = asi64(R1);
	asi64(R1) = ordtableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	dllnameoffset = asi64(R1);
	asi64(R1) = dllnameoffset;
	asu64(R2) = mc_writeexe_dllfilename;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	namesoffset = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeexe_exportdiroffset;
	asi64(R1) += asi64(R2);
	virtoffset = asi64(R1);
	asu64(R1) = pstart;
	asi64(R2) = addrtableoffset;
	R1 += (i64)R2;
	paddrtable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = nametableoffset;
	R1 += (i64)R2;
	pnametable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = ordtableoffset;
	R1 += (i64)R2;
	pordtable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = dllnameoffset;
	R1 += (i64)R2;
	pdllname = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = namesoffset;
	R1 += (i64)R2;
	pnames = asu64(R1);
	asi64(R1) = dllnameoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = addrtableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 28;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = nametableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 32;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = ordtableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = mc_writeexe_dllfilename;
	asu64(R2) = pdllname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mc_writeexe_nexports;
	R2 = 2000;
	if (asi64(R1) <= asi64(R2)) goto L4538;
	R1 = tou64("Too many exports - can't sort");
	mc_libmcl_axerror(asu64(R1));
L4538:
	R1 = (u64)&sortindex;
	mc_writeexe_sortexports(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4541;
L4539:
	R1 = (u64)&mc_writeexe_exporttable;
	R2 = (u64)&sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&mc_writeexe_exporttable;
	R2 = (u64)&sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	basename = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R1) = mc_writeexe_getsectionno(asi64(R1));
	sectionno = asi64(R1);
	asu64(R1) = basename;
	asu64(R2) = pnames;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = namesoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = pnametable;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&pnametable;
	(*tou64p(R1)) += 4;
	asu64(R1) = basename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&namesoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = basename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&pnames;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = sectionno;
	R2 += (i64)R3*72-72;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = paddrtable;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&paddrtable;
	(*tou64p(R1)) += 4;
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pordtable;
	*tou16p(R2) = asu16(R1);
	R1 = (u64)&pordtable;
	(*tou64p(R1)) += 2;
	i += 1; if (i <= mc_writeexe_nexports) goto L4539;
L4541:
	return;
}

static i64 mc_writeexe_getexporttablesize() {
    u64 R1, R2; 
	i64 size;
	i64 i;
	R1 = 40;
	size = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = mc_writeexe_dllfilename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4545;
L4543:
	R1 = (u64)&mc_writeexe_exporttable;
	asi64(R2) = i;
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_nexports) goto L4543;
L4545:
	asi64(R1) = size;
	goto L4542;
L4542:
	return asi64(R1);
}

static void mc_writeexe_newbasereloc(i64 addr, i64 reltype) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = addr;
	asu64(R2) = p;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = reltype;
	asu64(R2) = p;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	mc_writeexe_basereloclist = asu64(R1);
	R1 = (u64)&mc_writeexe_nbaserelocs;
	(*toi64p(R1)) += 1;
	asi64(R1) = addr;
	R2 = (u64)&mc_writeexe_maxrelocaddr;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	return;
}

static void mc_writeexe_scanbaserelocs() {
    u64 R1, R2, R3; 
	i64 baseaddr;
	i64 addr;
	i64 nextblock;
	u64 p;
	i64 i;
	R1 = 4096;
	baseaddr = asi64(R1);
	R1 = 0;
	mc_writeexe_nbaseblocks = asi64(R1);
L4548:
	asi64(R1) = baseaddr;
	R2 = 4096;
	asi64(R1) += asi64(R2);
	nextblock = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 500;
	if (asi64(R1) < asi64(R2)) goto L4552;
	R1 = tou64("Too many blocks");
	mc_libmcl_axerror(asu64(R1));
L4552:
	R1 = (u64)&mc_writeexe_nbaseblocks;
	(*toi64p(R1)) += 1;
	asi64(R1) = baseaddr;
	R2 = (u64)&mc_writeexe_blockbases;
	asi64(R3) = mc_writeexe_nbaseblocks;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_blockcounts;
	asi64(R3) = mc_writeexe_nbaseblocks;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	p = asu64(R1);
	goto L4554;
L4553:
	asu64(R1) = p;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	addr = asi64(R1);
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	if (asi64(R1) < asi64(R2)) goto L4557;
	asi64(R1) = addr;
	asi64(R2) = nextblock;
	if (asi64(R1) >= asi64(R2)) goto L4557;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = mc_writeexe_nbaseblocks;
	R1 += (i64)R2*4-4;
	(*toi32p(R1)) += 1;
L4557:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4554:
	asu64(R1) = p;
	if (asu64(R1)) goto L4553;
	asi64(R1) = nextblock;
	baseaddr = asi64(R1);
	asi64(R1) = baseaddr;
	asi64(R2) = mc_writeexe_maxrelocaddr;
	if (asi64(R1) <= asi64(R2)) goto L4548;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4560;
L4558:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	if (!asi32(R1)) goto L4562;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4564;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	R1 += (i64)R2*4-4;
	(*toi32p(R1)) += 1;
	R1 = (u64)&mc_writeexe_blockpadding;
	asi64(R2) = i;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L4564:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 8;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeexe_blockbytes;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&mc_writeexe_blockbytes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_writeexe_basetablesize;
	*toi64p(R2) += asi64(R1);
L4562:
	i += 1; if (i <= mc_writeexe_nbaseblocks) goto L4558;
L4560:
	return;
}

static void mc_writeexe_writebasereloctable(u64 pstart) {
    u64 R1, R2, R3; 
	u64 p32;
	u64 p16;
	i64 baseaddr;
	i64 addr;
	i64 nextblock;
	u64 q;
	i64 i;
	asu64(R1) = pstart;
	p32 = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4568;
L4566:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	if (!asi32(R1)) goto L4570;
	R1 = (u64)&mc_writeexe_blockbases;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&p32;
	(*tou64p(R1)) += 4;
	R1 = (u64)&mc_writeexe_blockbytes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&p32;
	(*tou64p(R1)) += 4;
	asu64(R1) = p32;
	p16 = asu64(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	q = asu64(R1);
	R1 = (u64)&mc_writeexe_blockbases;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	baseaddr = asi64(R1);
	asi64(R1) = baseaddr;
	R2 = 4096;
	asi64(R1) += asi64(R2);
	nextblock = asi64(R1);
	goto L4572;
L4571:
	asu64(R1) = q;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	addr = asi64(R1);
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	if (asi64(R1) < asi64(R2)) goto L4575;
	asi64(R1) = addr;
	asi64(R2) = nextblock;
	if (asi64(R1) >= asi64(R2)) goto L4575;
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = q;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 2;
	if (asi64(R2) != asi64(R3)) goto L4577;
	R2 = 3;
	goto L4576;
L4577:
	R2 = 10;
L4576:
	R3 = 12;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = p16;
	*tou16p(R2) = asu16(R1);
	R1 = (u64)&p16;
	(*tou64p(R1)) += 2;
L4575:
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L4572:
	asu64(R1) = q;
	if (asu64(R1)) goto L4571;
	R1 = (u64)&mc_writeexe_blockpadding;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4579;
	R1 = 0;
	R2 = (u64)&p16;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 2; asu64(R2) = asu64(R3);
	*tou16p(R2) = asu16(R1);
L4579:
	asu64(R1) = p16;
	p32 = asu64(R1);
L4570:
	i += 1; if (i <= mc_writeexe_nbaseblocks) goto L4566;
L4568:
	return;
}

static void mc_writeexe_sortexports(u64 sortindex) {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	i64 swapped;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4583;
L4581:
	asi64(R1) = i;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	i += 1; if (i <= mc_writeexe_nexports) goto L4581;
L4583:
L4584:
	R1 = 0;
	swapped = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4589;
L4587:
	R1 = (u64)&mc_writeexe_exporttable;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&mc_writeexe_exporttable;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4591;
	R1 = 1;
	swapped = asi64(R1);
	asu64(R1) = sortindex;
	asi64(R2) = i;
	R1 += (i64)R2*8-8;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	R2 += (i64)R3*8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L4591:
	i += 1; if (i <= av_1) goto L4587;
L4589:
	asi64(R1) = swapped;
	if (asi64(R1)) goto L4584;
	return;
}

static i64 mc_writeexe_getsectionno(i64 segment) {
    u64 R1, R2; 
	asi64(R1) = segment;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4594;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4595;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4596;
	goto L4597;
L4594:
	R1 = 3;
	goto L4593;
L4595:
	R1 = 2;
	goto L4593;
L4596:
	R1 = 1;
	goto L4593;
L4597:
	R1 = tou64("GSN");
	mc_libmcl_axerror(asu64(R1));
	R1 = 0;
L4593:
	goto L4592;
L4592:
	return asi64(R1);
}

static void mc_writeexe_getoffsets() {
    u64 R1, R2, R3, R4; 
	i64 fileoffset;
	i64 imageoffset;
	i64 i;
	i64 diroffset;
	i64 impdirno;
	i64 hinttableoffset;
	i64 j;
	i64 n;
	i64 codesize;
	i64 length;
	i64 thunkoffset;
	i64 offset;
	i64 dirstartoffset;
	u64 pcode;
	u64 pimpdir;
	u64 pdir;
	u64 paddr;
	u64 pname;
	i64 iatoffset;
	u64 phint;
	u64 pextra;
	i64 xxx;
	i64 av_1;
	u64 thunkptr;
	u64 codebase;
	i64 thunkaddr;
	R1 = 392;
	fileoffset = asi64(R1);
	R1 = 40;
	asi64(R2) = mc_writeexe_nsections;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&fileoffset;
	*toi64p(R2) += asi64(R1);
	R1 = 512;
	asi64(R2) = fileoffset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	fileoffset = asi64(R1);
	R1 = 4096;
	imageoffset = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	codesize = asi64(R1);
	asi64(R1) = codesize;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	pcode = asu64(R1);
	goto L4600;
L4599:
	R1 = 144;
	R2 = (u64)&pcode;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&codesize;
	(*toi64p(R1)) += 1;
L4600:
	asi64(R1) = codesize;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4599;
	asi64(R1) = codesize;
	thunkoffset = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&codesize;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = codesize;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = codesize;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = codesize;
	asi64(R2) = thunkoffset;
	asi64(R1) -= asi64(R2);
	R2 = 16;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_decls_ss_code;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4604;
L4602:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4606;
	asi64(R1) = fileoffset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = i;
	R2 += (i64)R3*72-72;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4606:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4608;
	R1 = 512;
	asi64(R2) = fileoffset;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = i;
	R3 += (i64)R4*72-72;
	R4 = 40;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	fileoffset = asi64(R1);
L4608:
	asi64(R1) = imageoffset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = i;
	R2 += (i64)R3*72-72;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4610;
	asi64(R1) = imageoffset;
	diroffset = asi64(R1);
	asi64(R1) = i;
	impdirno = asi64(R1);
L4610:
	R1 = 4096;
	asi64(R2) = imageoffset;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = i;
	R3 += (i64)R4*72-72;
	R4 = 40;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	imageoffset = asi64(R1);
	i += 1; if (i <= mc_writeexe_nsections) goto L4602;
L4604:
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4612;
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writeexe_getbaserelocs(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writeexe_getbaserelocs(asu64(R1));
L4612:
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 20;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4615;
L4613:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4613;
L4615:
	asi64(R1) = diroffset;
	mc_writeexe_fileiatoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4618;
L4616:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4616;
L4618:
	asi64(R1) = diroffset;
	asi64(R2) = mc_writeexe_fileiatoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_fileiatsize = asi64(R1);
	asi64(R1) = diroffset;
	hinttableoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4621;
L4619:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	R1 += (i64)R2*48;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 3;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4623;
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L4623:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_nimports) goto L4619;
L4621:
	R1 = 4;
	asi64(R2) = diroffset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	diroffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4626;
L4624:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4628;
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L4628:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4624;
L4626:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = impdirno;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	dirstartoffset = asi64(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4630;
	asi64(R1) = diroffset;
	mc_writeexe_exportdirvirtaddr = asi64(R1);
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_exportdiroffset = asi64(R1);
	asi64(R1) = mc_writeexe_getexporttablesize();
	mc_writeexe_exportdirvirtsize = asi64(R1);
	asi64(R1) = mc_writeexe_exportdirvirtsize;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	mc_writeexe_scanbaserelocs();
	asi64(R1) = diroffset;
	mc_writeexe_blockdirvirtaddr = asi64(R1);
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_blockdiroffset = asi64(R1);
	asi64(R1) = mc_writeexe_basetablesize;
	mc_writeexe_blockdirvirtsize = asi64(R1);
	asi64(R1) = mc_writeexe_blockdirvirtsize;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
L4630:
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = impdirno;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = offset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = impdirno;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = fileoffset;
	asi64(R3) = offset;
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_writeexe_filesize = asi64(R1);
	R1 = 4096;
	asi64(R2) = imageoffset;
	asi64(R3) = diroffset;
	asi64(R4) = dirstartoffset;
	asi64(R3) -= asi64(R4);
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_writeexe_imagesize = asi64(R1);
	asi64(R1) = offset;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	R2 = R1;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = impdirno;
	R3 += (i64)R4*72-72;
	R4 = 0;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	pimpdir = asu64(R1);
	asu64(R1) = pimpdir;
	pdir = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4633;
L4631:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pdir;
	(*tou64p(R1)) += 20;
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	iatoffset = asi64(R1);
	asu64(R1) = pimpdir;
	asi64(R2) = iatoffset;
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	paddr = asu64(R1);
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	pname = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4636;
L4634:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = j;
	R1 += (i64)R2*48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L4638;
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = j;
	R1 += (i64)R2*48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = paddr;
	*toi64p(R3) = asi64(R2);
	asu64(R2) = pname;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = iatoffset;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = j;
	R2 += (i64)R3*48;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	R2 = (u64)&iatoffset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&pname;
	(*tou64p(R1)) += 8;
	R1 = (u64)&paddr;
	(*tou64p(R1)) += 8;
L4638:
	j += 1; if (j <= mc_writeexe_nimports) goto L4634;
L4636:
	i += 1; if (i <= mc_writeexe_ndlls) goto L4631;
L4633:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4641;
L4639:
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	phint = asu64(R1);
	R1 = 2;
	R2 = (u64)&phint;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	R1 += (i64)R2*48;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = phint;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_writeexe_nimports) goto L4639;
L4641:
	asi64(R1) = dirstartoffset;
	xxx = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4644;
L4642:
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	pextra = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4647;
L4645:
	asi64(R1) = xxx;
	asu64(R2) = pextra;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&pextra;
	(*tou64p(R1)) += 4;
	j += 1; if (j <= av_1) goto L4645;
L4647:
	R1 = 20;
	R2 = (u64)&xxx;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	phint = asu64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = phint;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_writeexe_ndlls) goto L4642;
L4644:
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4649;
	asu64(R1) = pimpdir;
	asi64(R2) = mc_writeexe_exportdiroffset;
	R1 += (i64)R2;
	mc_writeexe_writeexporttable(asu64(R1));
	asu64(R1) = pimpdir;
	asi64(R2) = mc_writeexe_blockdiroffset;
	R1 += (i64)R2;
	mc_writeexe_writebasereloctable(asu64(R1));
L4649:
	asi64(R1) = thunkoffset;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	thunkptr = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codebase = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4652;
L4650:
	asu64(R1) = thunkptr;
	asu64(R2) = codebase;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4654;
	R1 = 72;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 36;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	thunkaddr = asi64(R1);
	asi64(R1) = thunkaddr;
	asu64(R2) = thunkptr;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&thunkptr;
	*tou64p(R2) += asu64(R1);
	goto L4653;
L4654:
	R1 = 72;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	thunkaddr = asi64(R1);
	R1 = 0;
	asi64(R2) = thunkaddr;
	asi64(R3) = mc_writeexe_imagebase;
	asi64(R2) -= asi64(R3);
	asu64(R3) = thunkptr;
	asu64(R4) = codebase;
	asi64(R3) -= asi64(R4);
	asi64(R1) = mc_writeexe_getripoffset(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = thunkptr;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&thunkptr;
	*tou64p(R2) += asu64(R1);
	R1 = 144;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4653:
	i += 1; if (i <= mc_writeexe_nimports) goto L4650;
L4652:
	return;
}

static i64 mc_writeexe_getripoffset(i64 addr, i64 dest, i64 extra) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&addr;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = dest;
	asi64(R2) = addr;
	R3 = 4;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) -= asi64(R2);
	goto L4655;
L4655:
	return asi64(R1);
}

static void mc_writeobj_writecoff(u64 outfile) {
    u64 R1, R2, R3; 
	struct $B54 header;
	struct $B73 zsection;
	struct $B73 isection;
	struct $B73 csection;
	i64 offset;
	i64 aa;
	asu8(R1) = pc_decls_objdone;
	if (!asu8(R1)) goto L4658;
	goto L4656;
L4658:
	R1 = (u64)&header;
	memset(R1, 0, 20);
	R1 = (u64)&zsection;
	memset(R1, 0, 40);
	R1 = (u64)&isection;
	memset(R1, 0, 40);
	R1 = (u64)&csection;
	memset(R1, 0, 40);
	R1 = 34404;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3;
	R2 = (u64)&header;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = tou64(".bss");
	R2 = (u64)&zsection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&zsection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3225419904;
	R2 = (u64)&zsection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = 65536;
	if (asi64(R1) >= asi64(R2)) goto L4661;
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L4660;
L4661:
	R1 = tou64("Too many relocs (exceeds 16-bit field)");
	mc_libmcl_axerror(asu64(R1));
L4660:
	R1 = tou64(".data");
	R2 = (u64)&isection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&isection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = (u64)&isection;
	R3 = 32;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3226468416;
	R2 = (u64)&isection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = tou64(".text");
	R2 = (u64)&csection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&csection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = (u64)&csection;
	R3 = 32;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1615855648;
	R2 = (u64)&csection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = outfile;
	mc_writeobj_initsymboltable(asu64(R1));
	mc_writeobj_convertsymboltable();
	R1 = 20;
	offset = asi64(R1);
	R1 = 120;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&isection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L4663;
	asi64(R1) = offset;
	R2 = (u64)&isection;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&isection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4663:
	R1 = (u64)&csection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L4665;
	asi64(R1) = offset;
	R2 = (u64)&csection;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&csection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4665:
	asi64(R1) = offset;
	R2 = (u64)&isection;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&isection;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&csection;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&csection;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&header;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 18;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = (u64)&header;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeobj_nextstringoffset;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	asu64(R1) = malloc(asu64(R1));
	R2 = R1;
	mc_writeobj_dataptr = asu64(R2);
	mc_writeobj_datastart = asu64(R1);
	R1 = 20;
	R2 = (u64)&header;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&zsection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&isection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&csection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asu64(R2) = mc_decls_ss_idatarelocs;
	mc_writeobj_writerelocs(asu64(R2), asi64(R1));
	asi64(R1) = mc_decls_ss_ncoderelocs;
	asu64(R2) = mc_decls_ss_coderelocs;
	mc_writeobj_writerelocs(asu64(R2), asi64(R1));
	asu64(R1) = mc_decls_ss_idata;
	mc_writeobj_writedata(asu64(R1));
	asu64(R1) = mc_decls_ss_code;
	mc_writeobj_writedata(asu64(R1));
	mc_writeobj_writesymboltable();
	mc_writeobj_writestringtable();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L4667;
	msysc_m$print_startcon();
	R1 = tou64("Writing file:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4667:
	asu64(R1) = mc_writeobj_dataptr;
	asu64(R2) = mc_writeobj_datastart;
	asi64(R1) -= asi64(R2);
	asu64(R2) = mc_writeobj_datastart;
	asu64(R3) = outfile;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	pc_decls_objdone = asu8(R1);
L4656:
	return;
}

static void mc_writeobj_writerecord(u64 r, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = r;
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeobj_writerelocs(u64 r, i64 nrelocs) {
    u64 R1, R2, R3; 
	u64 d;
	asi64(R1) = nrelocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4671;
	goto L4669;
L4671:
	goto L4673;
L4672:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4676;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4676;
	goto L4677;
L4676:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4679;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4680;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4681;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4682;
	goto L4683;
L4679:
	R1 = 2;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4678;
L4680:
	R1 = 4;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4678;
L4681:
	R1 = 6;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4678;
L4682:
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeobj_stoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4678;
L4683:
	R1 = tou64("wrelocs/bad seg");
	mc_libmcl_axerror(asu64(R1));
L4678:
	goto L4675;
L4677:
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeobj_stoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4675:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4685;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4686;
	goto L4687;
L4685:
	goto L4684;
L4686:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4689;
	R1 = 4;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 4;
	asu64(R2) = r;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4689:
	goto L4684;
L4687:
	R1 = tou64("OBJ/phighmem 1?");
	mc_libmcl_axerror(asu64(R1));
L4684:
	asu64(R1) = r;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4673:
	asu64(R1) = r;
	if (asu64(R1)) goto L4672;
L4669:
	return;
}

static void mc_writeobj_writedata(u64 data) {
    u64 R1, R2, R3; 
	asu64(R1) = data;
	asu64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = 0;
	asu64(R3) = data;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = data;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeobj_writesymboltable() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4694;
L4692:
	R1 = 18;
	R2 = (u64)&mc_writeobj_symboltable;
	asi64(R3) = i;
	R2 += (i64)R3*18;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	i += 1; if (i <= mc_writeobj_nsymbols) goto L4692;
L4694:
	return;
}

static void mc_writeobj_writestringtable() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	i64 n;
	asu64(R1) = mc_writeobj_dataptr;
	p = asu64(R1);
	asi64(R1) = mc_writeobj_nextstringoffset;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeobj_nstrings;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4698;
L4696:
	R1 = (u64)&mc_writeobj_stringlengths;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = (u64)&mc_writeobj_stringtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	i += 1; if (i <= mc_writeobj_nstrings) goto L4696;
L4698:
	return;
}

static u64 mc_writeobj_makesymbol(u64 name, i64 value, i64 sectionno, i64 symtype, i64 storage, i64 naux) {
    u64 R1, R2, R3, R4; 
	i64 length;
	i64 namelen;
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	namelen = asi64(R1);
	asi64(R1) = namelen;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L4701;
	asu64(R1) = name;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4700;
L4701:
	asi64(R1) = namelen;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4702;
	asi64(R1) = namelen;
	asu64(R2) = name;
	R3 = (u64)&mc_writeobj_makesymbol_r;
	R4 = 0;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L4700;
L4702:
	R1 = 0;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = namelen;
	asu64(R2) = name;
	asi64(R1) = mc_writeobj_addstringentry(asu64(R2), asi64(R1));
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4700:
	asi64(R1) = value;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = sectionno;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = symtype;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 14;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = storage;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = naux;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_writeobj_makesymbol_r;
	goto L4699;
L4699:
	return asu64(R1);
}

static void mc_writeobj_addsymbol(u64 r) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 13000;
	if (asi64(R1) < asi64(R2)) goto L4705;
	R1 = tou64("as:Too many symbols");
	mc_libmcl_axerror(asu64(R1));
L4705:
	R1 = 18;
	asu64(R2) = r;
	R3 = (u64)&mc_writeobj_symboltable;
	R4 = (u64)&mc_writeobj_nsymbols;
	asi64(R4) = *(toi64p(R4)) += 1;
	R3 += (i64)R4*18;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_writeobj_initsymboltable(u64 filename) {
    u64 R1, R2, R3, R4, R5, R6; 
	R1 = 0;
	mc_writeobj_nsymbols = asi64(R1);
	R1 = 1;
	R2 = 103;
	R3 = 0;
	R4 = -2;
	R5 = 0;
	R6 = tou64(".file");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asu64(R1) = filename;
	asu64(R1) = mc_writeobj_strtoaux(asu64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 1;
	R5 = 0;
	R6 = tou64(".bss");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 2;
	R5 = 0;
	R6 = tou64(".data");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asu64(R2) = mc_decls_ss_idata;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 3;
	R5 = 0;
	R6 = tou64(".text");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asi64(R1) = mc_decls_ss_ncoderelocs;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	return;
}

static u64 mc_writeobj_strtoaux(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	i64 n;
	R1 = (u64)&mc_writeobj_strtoaux_r;
	p = asu64(R1);
	R1 = 18;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 0;
	n = asi64(R1);
	goto L4709;
L4708:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L4709:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4711;
	asi64(R1) = n;
	R2 = 18;
	if (asi64(R1) < asi64(R2)) goto L4708;
L4711:
	R1 = (u64)&mc_writeobj_strtoaux_r;
	goto L4707;
L4707:
	return asu64(R1);
}

static u64 mc_writeobj_sectiontoaux(u64 data, i64 nrelocs) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_writeobj_sectiontoaux_r;
	memset(R1, 0, 18);
	asu64(R1) = data;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4714;
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4713;
L4714:
	asu64(R1) = data;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4713:
	asi64(R1) = nrelocs;
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 4;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mc_writeobj_sectiontoaux_r;
	goto L4712;
L4712:
	return asu64(R1);
}

static i64 mc_writeobj_addstringentry(u64 s, i64 length) {
    u64 R1, R2, R3; 
	i64 offset;
	asi64(R1) = mc_writeobj_nextstringoffset;
	offset = asi64(R1);
	asi64(R1) = mc_writeobj_nstrings;
	R2 = 5000;
	if (asi64(R1) <= asi64(R2)) goto L4717;
	R1 = tou64("W:too many strings");
	mc_libmcl_axerror(asu64(R1));
L4717:
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeobj_stringtable;
	R3 = (u64)&mc_writeobj_nstrings;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = length;
	R2 = (u64)&mc_writeobj_stringlengths;
	asi64(R3) = mc_writeobj_nstrings;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_nextstringoffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	goto L4715;
L4715:
	return asi64(R1);
}

static void mc_writeobj_convertsymboltable() {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 s;
	u64 name;
	i64 i;
	i64 sect;
	i64 scope;
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mc_writeobj_stoffset = asi64(R1);
	R1 = 0;
	mc_writeobj_nstrings = asi64(R1);
	R1 = 4;
	mc_writeobj_nextstringoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4721;
L4719:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = s;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4723;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4724;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4725;
	goto L4726;
L4723:
	R1 = 1;
	sect = asi64(R1);
	goto L4722;
L4724:
	R1 = 2;
	sect = asi64(R1);
	goto L4722;
L4725:
	R1 = 3;
	sect = asi64(R1);
	goto L4722;
L4726:
	R1 = 0;
	sect = asi64(R1);
L4722:
	asu64(R1) = s;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4728;
	R1 = 0;
	sect = asi64(R1);
L4728:
	R1 = 0;
	scope = asi64(R1);
	asu64(R1) = s;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4731;
	asu64(R1) = s;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4730;
L4731:
	R1 = 2;
	scope = asi64(R1);
	goto L4729;
L4730:
	R1 = 3;
	scope = asi64(R1);
L4729:
	asu64(R1) = s;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4733;
	asu64(R1) = name;
	asu64(R1) = pc_api_getbasename(asu64(R1));
	name = asu64(R1);
L4733:
	R1 = 0;
	asi64(R2) = scope;
	R3 = 0;
	asi64(R4) = sect;
	asu64(R5) = s;
	R6 = 76;
	asi32(R5) = *toi32p(((i64)R5+(i64)R6));
	R5 = toi64(toi32(R5));
	asu64(R6) = name;
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4719;
L4721:
	return;
}

static u64 mc_writess_writessdata(i64 fexe) {
    u64 R1, R2; 
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("HELLO/SS");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	asi64(R1) = fexe;
	mc_writess_showssdata(asi64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	goto L4734;
L4734:
	return asu64(R1);
}

static void mc_writess_showssdata(i64 fexe) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_ssdone;
	if (asu8(R1)) goto L4737;
	R1 = tou64("SS not done");
	pc_api_pclerror(asu64(R1));
L4737:
	asi64(R1) = fexe;
	if (!asi64(R1)) goto L4739;
	R1 = tou64("EXE FORMAT");
	goto L4738;
L4739:
	R1 = tou64("AFTER GENSS");
L4738:
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	R1 = tou64("proc Section Zdata: ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writess_showsectiondata(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writess_showsectioncode(asu64(R1));
	asi64(R1) = fexe;
	if (!asi64(R1)) goto L4741;
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 216;
	R1 += (i64)R2;
	mc_writess_showsectiondata(asu64(R1));
L4741:
	mc_writess_showsymboltable2();
	mc_writess_showimporttable();
	R1 = tou64("END OF GENSS");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	return;
}

static void mc_writess_showsectiondata(u64 d) {
    u64 R1, R2, R3; 
	i64 i;
	i64 k;
	i64 length;
	i64 bb;
	struct $B21 str;
	struct $B21 str2;
	u64 p;
	u64 baseaddr;
	i64 av_1;
	R1 = tou64("proc Section ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" Size:");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4744;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L4743;
L4744:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4743:
	asu64(R1) = d;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	asu64(R2) = d;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) += asu64(R2);
	baseaddr = asu64(R1);
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Z8H");
	asu64(R2) = baseaddr;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4747;
L4745:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	bb = asi64(R1);
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2H");
	asi64(R2) = bb;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 32;
	asi64(R2) = bb;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L4749;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L4749;
	asi64(R1) = bb;
	R2 = (u64)&str2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4748;
L4749:
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4748:
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4752;
	asi64(R1) = i;
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L4751;
L4752:
	asi64(R1) = k;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L4754;
	R1 = 16;
	asi64(R2) = k;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4757;
L4755:
	R1 = tou64("   ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L4755;
L4757:
L4754:
	R1 = tou64("\t[");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("]");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 0;
	k = asi64(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 16;
	R2 = (u64)&baseaddr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z8h");
	asu64(R2) = baseaddr;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
L4751:
	i += 1; if (i <= length) goto L4745;
L4747:
	asi64(R1) = k;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4759;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
L4759:
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	asi64(R1) = k;
	if (!asi64(R1)) goto L4761;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
L4761:
	return;
}

static void mc_writess_showsectioncode(u64 p) {
    u64 R1, R2, R3; 
	u64 codeptr;
	u64 codeend;
	u64 codestart;
	i64 length;
	i64 offset;
	u64 s;
	struct $B3 str;
	u64 baseaddr;
	R1 = tou64("proc Section Code");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = R1;
	codeptr = asu64(R2);
	codestart = asu64(R1);
	asu64(R1) = codeptr;
	asi64(R2) = length;
	R1 += (i64)R2;
	codeend = asu64(R1);
	asi64(R1) = mc_writeexe_imagebase;
	asu64(R2) = p;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) += asu64(R2);
	baseaddr = asu64(R1);
	goto L4764;
L4763:
	asu64(R1) = codeptr;
	asu64(R2) = codestart;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asu64(R1) = baseaddr;
	asi64(R2) = offset;
	R1 += (i64)R2;
	R2 = (u64)&codeptr;
	asu64(R1) = mc_disasm_decodeinstr(asu64(R2), asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4767;
	goto L4765;
L4767:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("4");
	asi64(R2) = offset;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
L4764:
	asu64(R1) = codeptr;
	asu64(R2) = codeend;
	if (asu64(R1) < asu64(R2)) goto L4763;
L4765:
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mc_writess_showsectionrelocs2(u64 caption, u64 relocs, i64 nrelocs) {
    u64 R1, R2, R3; 
	u64 r;
	R1 = tou64("proc Section Relocs: ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = caption;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asi64(R1) = nrelocs;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	asu64(R1) = relocs;
	r = asu64(R1);
	goto L4770;
L4769:
	R1 = tou64("Reloc: ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" Offset: ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = r;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ST Index: ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4770:
	asu64(R1) = r;
	if (asu64(R1)) goto L4769;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mc_writess_gs_value(u64 caption, i64 value) {
    u64 R1, R2, R3; 
	struct $B16 str;
	asu64(R1) = caption;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(":");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 20;
	R3 = (u64)&str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("0x# #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("H");
	asi64(R2) = value;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	asi64(R1) = value;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	return;
}

static void mc_writess_showsymboltable2() {
    u64 R1, R2; 
	i64 i;
	R1 = tou64("Proc Symbol Table");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4776;
L4774:
	asi64(R1) = i;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(": ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4774;
L4776:
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mc_writess_showimporttable() {
    u64 R1, R2, R3; struct $B12 R1_B12; 
	struct $B16 str;
	struct $B12 d;
	struct $B12 p;
	i64 i;
	R1 = tou64("Proc Dll List");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4780;
L4778:
	asi64(R1) = i;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(": ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("\t\tName Table Offset");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("\t\tAddr Table Offset");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("\t\tDLL Name Offset  ");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	i += 1; if (i <= mc_writeexe_ndlls) goto L4778;
L4780:
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	R1 = tou64("Proc Import List");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4783;
L4781:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	(R1_B12) = *(struct $B12*)(((i64)R1+(i64)R2*48));
	p = (R1_B12);
	asi64(R1) = i;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(": ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4785;
	R1 = (u64)&p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 16;
	R3 = (u64)&str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" (");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writeexe_dlltable;
	R2 = (u64)&p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = (u64)&p;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("\tIAT Offset        ");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&p;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("\tThunk Offset      ");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("\tHint/Name Offset  ");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	goto L4784;
L4785:
	R1 = (u64)&p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 20;
	R3 = (u64)&str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" (---)");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
L4784:
	i += 1; if (i <= mc_writeexe_nimports) goto L4781;
L4783:
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mc_writess_showsections() {
    u64 R1, R2, R3; struct $B11 R1_B11; 
	struct $B11 s;
	i64 i;
	R1 = tou64("proc Section Headersxxx");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4789;
L4787:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	(R1_B11) = *(struct $B11*)(((i64)R1+(i64)R2*72-72));
	s = (R1_B11);
	R1 = tou64("Section ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asi64(R1) = i;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(": ");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("  (");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_segmentnames;
	R2 = (u64)&s;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = pc_decls_pdest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = (u64)&s;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("    Raw Offset");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("    Raw Size");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&s;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("    Virtual Offset");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("    Virtual Size");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&s;
	R2 = 64;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("    Nrelocs");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	R1 = (u64)&s;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = tou64("    Data");
	mc_writess_gs_value(asu64(R2), asi64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4787;
L4789:
	return;
}

static u64 mc_disasm_decodeinstr(u64 cptr, u64 baseaddr) {
    u64 R1, R2, R3; 
	i64 n;
	i64 w;
	i64 opc;
	i64 reg;
	i64 op;
	i64 xxx;
	i64 oldopsize;
	i64 dispsize;
	u64 pstart;
	struct $B21 str2;
	u64 s;
	i64 av_1;
	i64 av_2;
	R1 = 0;
	R2 = (u64)&mc_disasm_deststr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = cptr;
	asu64(R1) = *tou64p(R1);
	R2 = R1;
	mc_disasm_codeptr = asu64(R2);
	pstart = asu64(R1);
	R1 = 0;
	mc_disasm_rex = asi64(R1);
	R1 = 1;
	mc_disasm_opsize = asi64(R1);
	R1 = 0;
	R2 = R1;
	mc_disasm_addroverride = asi64(R2);
	R2 = R1;
	mc_disasm_sizeoverride = asi64(R2);
	R2 = R1;
	mc_disasm_f3override = asi64(R2);
	mc_disasm_f2override = asi64(R1);
	R1 = 0;
	R2 = R1;
	mc_disasm_offset = asi64(R2);
	R2 = R1;
	mc_disasm_indexreg = asi64(R2);
	mc_disasm_basereg = asi64(R1);
// mc_disasm.decodeinstr.retry:
L4791:
	R1 = (u64)&mc_disasm_codeptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	switch (asi64(R1)) {
	case 0: case 1: case 8: case 9: case 16: case 17: case 24: case 25: case 32: case 33: case 40: case 41: case 48: case 49: case 56: case 57: goto L4795;
	case 2: case 3: case 10: case 11: case 18: case 19: case 26: case 27: case 34: case 35: case 42: case 43: case 50: case 51: case 58: case 59: goto L4796;
	case 4: case 5: case 12: case 13: case 20: case 21: case 28: case 29: case 36: case 37: case 44: case 45: case 52: case 53: case 60: case 61: goto L4797;
	case 6: case 7: case 14: case 22: case 23: case 30: case 31: case 38: case 39: case 46: case 47: case 54: case 55: case 62: case 63: case 96: case 97: case 98: case 100: case 101: case 108: case 109: case 110: case 111: case 140: case 142: case 154: case 160: case 161: case 162: case 163: case 196: case 197: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 212: case 213: case 214: case 228: case 229: case 230: case 231: case 234: case 236: case 237: case 238: case 239: case 240: case 241: case 245: case 248: case 249: case 250: case 251: case 252: case 253: goto L4794;
	case 15: goto L4804;
	case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: goto L4805;
	case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: goto L4806;
	case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: goto L4807;
	case 99: goto L4808;
	case 102: goto L4809;
	case 103: goto L4810;
	case 104: goto L4811;
	case 105: case 107: goto L4815;
	case 106: goto L4814;
	case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 123: case 124: case 125: case 126: case 127: goto L4820;
	case 128: case 129: case 130: case 131: goto L4821;
	case 132: case 133: goto L4824;
	case 134: case 135: goto L4825;
	case 136: case 137: goto L4826;
	case 138: case 139: goto L4827;
	case 141: goto L4828;
	case 143: goto L4829;
	case 144: goto L4830;
	case 145: case 146: case 147: case 148: case 149: case 150: case 151: goto L4834;
	case 152: goto L4841;
	case 153: goto L4844;
	case 155: goto L4848;
	case 156: goto L4849;
	case 157: goto L4850;
	case 158: goto L4851;
	case 159: goto L4852;
	case 164: case 165: case 166: case 167: case 170: case 171: case 172: case 173: case 174: case 175: goto L4853;
	case 168: case 169: goto L4869;
	case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: goto L4876;
	case 192: case 193: case 208: case 209: case 210: case 211: goto L4885;
	case 194: goto L4901;
	case 195: goto L4902;
	case 198: case 199: goto L4903;
	case 215: goto L4904;
	case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: goto L4905;
	case 224: goto L4906;
	case 225: goto L4907;
	case 226: goto L4908;
	case 227: goto L4909;
	case 232: goto L4912;
	case 233: goto L4913;
	case 235: goto L4914;
	case 242: goto L4915;
	case 243: goto L4918;
	case 244: goto L4921;
	case 246: case 247: goto L4922;
	case 254: goto L4938;
	case 255: goto L4940;
	default: goto L4794;
    };
// SWITCH
L4795:
	asi64(R1) = opc;
	R2 = 3;
	asi64(R1) >>= asi64(R2);
	op = asi64(R1);
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = (u64)&mc_disasm_rmreg;
	mc_disasm_getsil(asu64(R1));
	R1 = (u64)&mc_disasm_opnames;
	asi64(R2) = op;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4796:
	asi64(R1) = opc;
	R2 = 3;
	asi64(R1) >>= asi64(R2);
	op = asi64(R1);
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = (u64)&mc_disasm_opnames;
	asi64(R2) = op;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_rmreg;
	mc_disasm_getsil(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4792;
L4797:
	R1 = (u64)&mc_disasm_opnames;
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4799;
	R1 = 4;
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4801;
	R1 = 2;
	mc_disasm_opsize = asi64(R1);
L4801:
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4803;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
L4803:
L4799:
	asi64(R1) = mc_disasm_opsize;
	R2 = 1;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readimm();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4804:
	mc_disasm_decodetwobyteinstr();
	goto L4792;
L4805:
	asi64(R1) = opc;
	mc_disasm_rex = asi64(R1);
	goto L4791;
	goto L4792;
L4806:
	asi64(R1) = mc_disasm_rex;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	asi64(R2) = opc;
	R3 = 7;
	asi64(R2) &= asi64(R3);
	asi64(R1) = mc_disasm_getreg(asi64(R2), asi64(R1));
	reg = asi64(R1);
	R1 = tou64("push ");
	mc_disasm_genstr(asu64(R1));
	R1 = 8;
	asi64(R2) = reg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4807:
	asi64(R1) = mc_disasm_rex;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	asi64(R2) = opc;
	R3 = 7;
	asi64(R2) &= asi64(R3);
	asi64(R1) = mc_disasm_getreg(asi64(R2), asi64(R1));
	reg = asi64(R1);
	R1 = tou64("pop ");
	mc_disasm_genstr(asu64(R1));
	R1 = 8;
	asi64(R2) = reg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4808:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("movsxd ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 4;
	mc_disasm_opsize = asi64(R1);
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4792;
L4809:
	R1 = 1;
	mc_disasm_sizeoverride = asi64(R1);
	goto L4791;
	goto L4792;
L4810:
	R1 = 1;
	mc_disasm_addroverride = asi64(R1);
	goto L4791;
	goto L4792;
L4811:
	R1 = tou64("push ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4813;
	asi64(R1) = mc_disasm_readint16();
	mc_disasm_genintd(asi64(R1));
	goto L4812;
L4813:
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_genintd(asi64(R1));
L4812:
	goto L4792;
L4814:
	R1 = tou64("push ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4815:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_basereg;
	asi64(R2) = mc_disasm_rmreg;
	if (asi64(R1) == asi64(R2)) goto L4817;
	R1 = tou64("imul3");
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	goto L4816;
L4817:
	R1 = tou64("imul2");
	mc_disasm_genstr(asu64(R1));
L4816:
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4819;
	R1 = 1;
	goto L4818;
L4819:
	asi64(R1) = mc_disasm_opsize;
L4818:
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_readimm();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4820:
	R1 = tou64("j");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_condnames;
	asi64(R2) = opc;
	R3 = 15;
	asi64(R2) &= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4821:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = (u64)&mc_disasm_opnames;
	asi64(R2) = mc_disasm_rmopc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	R2 = 131;
	if (asi64(R1) == asi64(R2)) goto L4823;
	asi64(R1) = mc_disasm_readimm();
	mc_disasm_genintd(asi64(R1));
	goto L4822;
L4823:
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_genintd(asi64(R1));
L4822:
	goto L4792;
L4824:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = (u64)&mc_disasm_rmreg;
	mc_disasm_getsil(asu64(R1));
	R1 = tou64("test ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4825:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("exch2 ");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = (u64)&mc_disasm_rmreg;
	mc_disasm_getsil(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(",");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4792;
L4826:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("mov");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = (u64)&mc_disasm_rmreg;
	mc_disasm_getsil(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4827:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("mov ");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = (u64)&mc_disasm_rmreg;
	mc_disasm_getsil(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4792;
L4828:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("lea ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4792;
L4829:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = 1;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("pop");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4792;
L4830:
	asi64(R1) = mc_disasm_rex;
	if (!asi64(R1)) goto L4832;
	goto L4833;
L4832:
	R1 = tou64("nop");
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4834:
// mc_disasm.decodeinstr.doexch:
L4833:
	asi64(R1) = opc;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	reg = asi64(R1);
	asi64(R1) = mc_disasm_rex;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4836;
	R1 = 8;
	R2 = (u64)&reg;
	*toi64p(R2) += asi64(R1);
L4836:
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4838;
	R1 = 2;
	goto L4837;
L4838:
	R1 = 4;
L4837:
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4840;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
L4840:
	R1 = tou64("xchg ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	R2 = 1;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = reg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4841:
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4843;
	R1 = tou64("cbw");
	mc_disasm_genstr(asu64(R1));
	goto L4842;
L4843:
	R1 = tou64("cbw???");
	mc_disasm_genstr(asu64(R1));
L4842:
	goto L4792;
L4844:
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4846;
	R1 = tou64("cwd");
	mc_disasm_genstr(asu64(R1));
	goto L4845;
L4846:
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4847;
	R1 = tou64("cqo");
	mc_disasm_genstr(asu64(R1));
	goto L4845;
L4847:
	R1 = tou64("cdq");
	mc_disasm_genstr(asu64(R1));
L4845:
	goto L4792;
L4848:
	R1 = tou64("wait");
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4849:
	R1 = tou64("pushf");
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4850:
	R1 = tou64("popf");
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4851:
	R1 = tou64("sahf");
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4852:
	R1 = tou64("lahf");
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4853:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = 7;
	asi64(R1) &= asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L4857;
	case 2: goto L4858;
	case 3: goto L4859;
	case 4: goto L4860;
	case 5: goto L4861;
	case 6: goto L4862;
	case 7: goto L4863;
	default: goto L4856;
    };
// SWITCH
L4857:
	R1 = tou64("?");
	goto L4854;
L4858:
	R1 = tou64("movs");
	goto L4854;
L4859:
	R1 = tou64("cmps");
	goto L4854;
L4860:
	R1 = tou64("?");
	goto L4854;
L4861:
	R1 = tou64("stos");
	goto L4854;
L4862:
	R1 = tou64("lods");
	goto L4854;
L4863:
	R1 = tou64("scas");
	goto L4854;
L4856:
	R1 = tou64("?");
L4854:
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4865;
	R1 = tou64("b");
	mc_disasm_genstr(asu64(R1));
	goto L4864;
L4865:
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4867;
	R1 = tou64("q");
	mc_disasm_genstr(asu64(R1));
	goto L4866;
L4867:
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4868;
	R1 = tou64("w");
	mc_disasm_genstr(asu64(R1));
	goto L4866;
L4868:
	R1 = tou64("d");
	mc_disasm_genstr(asu64(R1));
L4866:
L4864:
	goto L4792;
L4869:
	R1 = tou64("test ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4871;
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4873;
	R1 = 2;
	goto L4872;
L4873:
	R1 = 4;
L4872:
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4875;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
L4875:
L4871:
	asi64(R1) = mc_disasm_opsize;
	R2 = 1;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readimm();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4876:
	asi64(R1) = opc;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	reg = asi64(R1);
	asi64(R1) = mc_disasm_rex;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4878;
	R1 = 8;
	R2 = (u64)&reg;
	*toi64p(R2) += asi64(R1);
L4878:
	asi64(R1) = opc;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4880;
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4882;
	R1 = 2;
	goto L4881;
L4882:
	R1 = 4;
L4881:
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4884;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
L4884:
L4880:
	R1 = tou64("mov ");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&reg;
	mc_disasm_getsil(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = reg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readimm8();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4885:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	asi64(R1) = mc_disasm_rmopc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L4889;
	case 2: goto L4890;
	case 3: goto L4891;
	case 4: goto L4892;
	case 5: goto L4893;
	case 6: goto L4894;
	case 7: goto L4895;
	case 8: goto L4896;
	default: goto L4888;
    };
// SWITCH
L4889:
	R1 = tou64("rol");
	goto L4886;
L4890:
	R1 = tou64("ror");
	goto L4886;
L4891:
	R1 = tou64("rcl");
	goto L4886;
L4892:
	R1 = tou64("rcr");
	goto L4886;
L4893:
	R1 = tou64("shl");
	goto L4886;
L4894:
	R1 = tou64("shr");
	goto L4886;
L4895:
	R1 = tou64("?");
	goto L4886;
L4896:
	R1 = tou64("sar");
	goto L4886;
L4888:
	R1 = tou64("?");
L4886:
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	asi64(R1) = opc;
	R2 = 193;
	if (asi64(R1) > asi64(R2)) goto L4898;
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readbyte();
	mc_disasm_genintd(asi64(R1));
	goto L4897;
L4898:
	asi64(R1) = opc;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4900;
	R1 = tou64(", cl");
	goto L4899;
L4900:
	R1 = tou64(", 1");
L4899:
	mc_disasm_genstr(asu64(R1));
L4897:
	goto L4792;
L4901:
	R1 = tou64("retn ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readword16();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4902:
	R1 = tou64("ret");
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4903:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("mov");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readimm();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4904:
	R1 = tou64("xlat");
	mc_disasm_genstr(asu64(R1));
	goto L4792;
L4905:
	asi64(R1) = opc;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	mc_disasm_decode8087(asi64(R1));
	goto L4792;
L4906:
	R1 = tou64("loopnz ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4907:
	R1 = tou64("loopz ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4908:
	R1 = tou64("loop ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4909:
	asi64(R1) = mc_disasm_addroverride;
	if (!asi64(R1)) goto L4911;
	R1 = tou64("jecxz ");
	mc_disasm_genstr(asu64(R1));
	goto L4910;
L4911:
	R1 = tou64("jrcxz ");
	mc_disasm_genstr(asu64(R1));
L4910:
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4912:
	R1 = tou64("call ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4913:
	R1 = tou64("[4] jmp ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4914:
	R1 = tou64("jmp ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_genintd(asi64(R1));
	goto L4792;
L4915:
	asu64(R1) = mc_disasm_codeptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4917;
	asu64(R1) = mc_disasm_codeptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) >= asi64(R2)) goto L4917;
	asu64(R1) = mc_disasm_codeptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 79;
	if (asi64(R1) <= asi64(R2)) goto L4917;
	R1 = tou64("repne");
	mc_disasm_genstr(asu64(R1));
	goto L4916;
L4917:
	R1 = 1;
	mc_disasm_f2override = asi64(R1);
	goto L4791;
L4916:
	goto L4792;
L4918:
	asu64(R1) = mc_disasm_codeptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4920;
	asu64(R1) = mc_disasm_codeptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) >= asi64(R2)) goto L4920;
	asu64(R1) = mc_disasm_codeptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 79;
	if (asi64(R1) <= asi64(R2)) goto L4920;
	R1 = tou64("repe");
	mc_disasm_genstr(asu64(R1));
	goto L4919;
L4920:
	R1 = 1;
	mc_disasm_f3override = asi64(R1);
	goto L4791;
L4919:
	goto L4792;
L4921:
	goto L4792;
L4922:
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	mc_disasm_decodeaddr(asi64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	asi64(R1) = mc_disasm_rmopc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L4926;
	case 2: goto L4927;
	case 3: goto L4928;
	case 4: goto L4929;
	case 5: goto L4930;
	case 6: goto L4931;
	case 7: goto L4932;
	case 8: goto L4933;
	default: goto L4925;
    };
// SWITCH
L4926:
	R1 = tou64("test");
	goto L4923;
L4927:
	R1 = tou64("?");
	goto L4923;
L4928:
	R1 = tou64("not");
	goto L4923;
L4929:
	R1 = tou64("neg");
	goto L4923;
L4930:
	R1 = tou64("mul");
	goto L4923;
L4931:
	R1 = tou64("imul");
	goto L4923;
L4932:
	R1 = tou64("div");
	goto L4923;
L4933:
	R1 = tou64("idiv");
	goto L4923;
L4925:
	R1 = tou64("?");
L4923:
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	asi64(R1) = mc_disasm_rmopc;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4935;
	asi64(R1) = mc_disasm_opsize;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4937;
	R1 = 4;
	mc_disasm_opsize = asi64(R1);
L4937:
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_readimm();
	mc_disasm_genintd(asi64(R1));
L4935:
	goto L4792;
L4938:
	R1 = 0;
	w = asi64(R1);
	goto L4939;
	goto L4792;
L4940:
	R1 = 1;
	w = asi64(R1);
// mc_disasm.decodeinstr.doff:
L4939:
	asi64(R1) = w;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_rmopc;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4942;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4943;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4944;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4945;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4946;
	goto L4947;
L4942:
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = tou64("inc");
	mc_disasm_genstr(asu64(R1));
	goto L4941;
L4943:
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = tou64("dec");
	mc_disasm_genstr(asu64(R1));
	goto L4941;
L4944:
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("icall");
	mc_disasm_genstr(asu64(R1));
	goto L4941;
L4945:
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("jmp");
	mc_disasm_genstr(asu64(R1));
	goto L4941;
L4946:
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("push");
	mc_disasm_genstr(asu64(R1));
	goto L4941;
L4947:
	msysc_m$print_startcon();
	R1 = tou64("FFxx?");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4941:
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4792;
L4794:
	R1 = tou64("Unknown opcode: ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	mc_disasm_genhex(asi64(R1));
L4792:
	R1 = (u64)&mc_disasm_decodeinstr_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z6h");
	asu64(R2) = baseaddr;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = mc_disasm_codeptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4950;
L4948:
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2H");
	R2 = (u64)&pstart;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_disasm_decodeinstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L4948;
L4950:
	R1 = 14;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4953;
L4951:
	R1 = tou64("-- ");
	R2 = (u64)&mc_disasm_decodeinstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_2)) goto L4951;
L4953:
	R1 = (u64)&mc_disasm_deststr;
	R2 = (u64)&mc_disasm_decodeinstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = mc_disasm_codeptr;
	asu64(R2) = cptr;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&mc_disasm_decodeinstr_str;
	goto L4790;
L4790:
	return asu64(R1);
}

static void mc_disasm_decodetwobyteinstr() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 rhssize;
	i64 third;
	i64 imm;
	u64 opcstr;
	R1 = (u64)&mc_disasm_codeptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	switch (asi64(R1)) {
	case 42: goto L4958;
	case 43: case 46: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 59: case 60: case 61: case 62: case 63: case 80: case 82: case 83: case 85: case 86: case 91: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 123: case 124: case 125: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 176: case 177: case 178: case 179: case 180: case 181: case 185: case 186: case 187: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 215: case 216: case 217: case 218: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: goto L4957;
	case 44: goto L4961;
	case 45: goto L4966;
	case 47: goto L4971;
	case 58: goto L4974;
	case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: goto L4979;
	case 81: goto L4980;
	case 84: goto L4985;
	case 87: goto L4990;
	case 88: goto L4995;
	case 89: goto L4999;
	case 90: goto L5000;
	case 92: goto L5003;
	case 93: goto L5004;
	case 94: goto L5005;
	case 95: goto L5006;
	case 110: goto L5007;
	case 111: goto L5014;
	case 126: goto L5018;
	case 127: goto L5024;
	case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: goto L5028;
	case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: goto L5031;
	case 175: goto L5032;
	case 182: case 183: case 190: case 191: goto L5033;
	case 184: goto L5038;
	case 188: case 189: goto L5039;
	case 214: goto L5042;
	case 219: goto L5043;
	case 239: goto L5044;
	default: goto L4957;
    };
// SWITCH
L4958:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_f3override;
	if (!asi64(R1)) goto L4960;
	R1 = tou64("cvtsi2ss ");
	mc_disasm_genstr(asu64(R1));
	goto L4959;
L4960:
	R1 = tou64("cvtsi2sd ");
	mc_disasm_genstr(asu64(R1));
L4959:
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4961:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_f3override;
	if (!asi64(R1)) goto L4963;
	R1 = tou64("cvttss2si ");
	mc_disasm_genstr(asu64(R1));
	R1 = 4;
	rhssize = asi64(R1);
	goto L4962;
L4963:
	R1 = tou64("cvttsd2si ");
	mc_disasm_genstr(asu64(R1));
	R1 = 8;
	rhssize = asi64(R1);
L4962:
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4965;
	R1 = 8;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4964;
L4965:
	R1 = 4;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
L4964:
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = rhssize;
	mc_disasm_opsize = asi64(R1);
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4966:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_f3override;
	if (!asi64(R1)) goto L4968;
	R1 = tou64("cvtss2si ");
	mc_disasm_genstr(asu64(R1));
	R1 = 4;
	rhssize = asi64(R1);
	goto L4967;
L4968:
	R1 = tou64("cvtsd2si ");
	mc_disasm_genstr(asu64(R1));
	R1 = 8;
	rhssize = asi64(R1);
L4967:
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4970;
	R1 = 8;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4969;
L4970:
	R1 = 4;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
L4969:
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = rhssize;
	mc_disasm_opsize = asi64(R1);
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4971:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4973;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("comisd ");
	mc_disasm_genstr(asu64(R1));
	goto L4972;
L4973:
	R1 = 4;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("comiss ");
	mc_disasm_genstr(asu64(R1));
L4972:
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4974:
	R1 = (u64)&mc_disasm_codeptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	third = asi64(R1);
	asi64(R1) = third;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L4976;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L4977;
	goto L4978;
L4976:
	R1 = tou64("pcmpistri ");
	mc_disasm_genstr(asu64(R1));
	goto L4975;
L4977:
	R1 = tou64("pcmpistrm ");
	mc_disasm_genstr(asu64(R1));
	goto L4975;
L4978:
	R1 = tou64("Unknown opcode 2-byte opcode: 0F ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	mc_disasm_genhex(asi64(R1));
	goto L4954;
L4975:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_codeptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	imm = asi64(R1);
	asi64(R1) = imm;
	mc_disasm_genintd(asi64(R1));
	goto L4955;
L4979:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("cmov");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_condnames;
	asi64(R2) = opc;
	R3 = 15;
	asi64(R2) &= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4980:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_f3override;
	if (!asi64(R1)) goto L4982;
	R1 = 4;
	goto L4981;
L4982:
	R1 = 8;
L4981:
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_opsize;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4984;
	R1 = tou64("sqrtss ");
	goto L4983;
L4984:
	R1 = tou64("sqrtsd ");
L4983:
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4985:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4987;
	R1 = tou64("andpd ");
	goto L4986;
L4987:
	R1 = tou64("andps ");
L4986:
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4989;
	R1 = 8;
	goto L4988;
L4989:
	R1 = 4;
L4988:
	mc_disasm_opsize = asi64(R1);
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4990:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4992;
	R1 = tou64("xorpd ");
	goto L4991;
L4992:
	R1 = tou64("xorps ");
L4991:
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L4994;
	R1 = 8;
	goto L4993;
L4994:
	R1 = 4;
L4993:
	mc_disasm_opsize = asi64(R1);
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4995:
	R1 = tou64("adds");
	opcstr = asu64(R1);
// mc_disasm.decodetwobyteinstr.doarith:
L4996:
	asu64(R1) = opcstr;
	mc_disasm_genstr(asu64(R1));
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_f2override;
	if (!asi64(R1)) goto L4998;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("d ");
	mc_disasm_genstr(asu64(R1));
	goto L4997;
L4998:
	R1 = 4;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("s ");
	mc_disasm_genstr(asu64(R1));
L4997:
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4999:
	R1 = tou64("muls");
	opcstr = asu64(R1);
	goto L4996;
	goto L4955;
L5000:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_f3override;
	if (!asi64(R1)) goto L5002;
	R1 = tou64("cvtss2sd ");
	mc_disasm_genstr(asu64(R1));
	R1 = 4;
	rhssize = asi64(R1);
	goto L5001;
L5002:
	R1 = tou64("cvtsd2ss ");
	mc_disasm_genstr(asu64(R1));
	R1 = 8;
	rhssize = asi64(R1);
L5001:
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = rhssize;
	mc_disasm_opsize = asi64(R1);
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5003:
	R1 = tou64("subs");
	opcstr = asu64(R1);
	goto L4996;
	goto L4955;
L5004:
	R1 = tou64("mins");
	opcstr = asu64(R1);
	goto L4996;
	goto L4955;
L5005:
	R1 = tou64("divs");
	opcstr = asu64(R1);
	goto L4996;
	goto L4955;
L5006:
	R1 = tou64("maxs");
	opcstr = asu64(R1);
	goto L4996;
	goto L4955;
L5007:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L5009;
	R1 = 8;
	goto L5008;
L5009:
	R1 = 4;
L5008:
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_opsize;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5011;
	R1 = tou64("movd ");
	goto L5010;
L5011:
	R1 = tou64("movq ");
L5010:
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L5013;
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5012;
L5013:
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strmmx(asi64(R1));
	mc_disasm_genstr(asu64(R1));
L5012:
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5014:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = 16;
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L5016;
	R1 = tou64("movdqa ");
	mc_disasm_genstr(asu64(R1));
	goto L5015;
L5016:
	asi64(R1) = mc_disasm_f3override;
	if (!asi64(R1)) goto L5017;
	R1 = tou64("movdqu ");
	mc_disasm_genstr(asu64(R1));
	goto L5015;
L5017:
	R1 = tou64("No 66/F3 ");
	mc_disasm_genstr(asu64(R1));
L5015:
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5018:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = mc_disasm_f3override;
	if (!asi64(R1)) goto L5020;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("movq ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L5019;
L5020:
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L5021;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("movq ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5019;
L5021:
	R1 = 4;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("movd ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L5023;
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5022;
L5023:
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strmmx(asi64(R1));
	mc_disasm_genstr(asu64(R1));
L5022:
L5019:
	goto L4955;
L5024:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = 16;
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L5026;
	R1 = tou64("movdqa ");
	mc_disasm_genstr(asu64(R1));
	goto L5025;
L5026:
	asi64(R1) = mc_disasm_f3override;
	if (!asi64(R1)) goto L5027;
	R1 = tou64("movdqu ");
	mc_disasm_genstr(asu64(R1));
	goto L5025;
L5027:
	R1 = tou64("No 66/F3 ");
	mc_disasm_genstr(asu64(R1));
L5025:
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4955;
L5028:
	R1 = tou64("[long] j");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_condnames;
	asi64(R2) = opc;
	R3 = 15;
	asi64(R2) &= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L5030;
	asi64(R1) = mc_disasm_readint16();
	mc_disasm_genintd(asi64(R1));
	goto L5029;
L5030:
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_genintd(asi64(R1));
L5029:
	goto L4955;
L5031:
	R1 = 0;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("set");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_condnames;
	asi64(R2) = opc;
	R3 = 15;
	asi64(R2) &= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5032:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("imul ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5033:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = opc;
	R2 = 190;
	if (asi64(R1) >= asi64(R2)) goto L5035;
	R1 = tou64("movzx ");
	goto L5034;
L5035:
	R1 = tou64("movsx ");
L5034:
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L5037;
	R1 = 2;
	goto L5036;
L5037:
	R1 = 1;
L5036:
	mc_disasm_opsize = asi64(R1);
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5038:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("popcnt ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5039:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = opc;
	R2 = 188;
	if (asi64(R1) != asi64(R2)) goto L5041;
	R1 = tou64("bsf ");
	goto L5040;
L5041:
	R1 = tou64("bsr ");
L5040:
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5042:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = tou64("movq ");
	mc_disasm_genstr(asu64(R1));
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	R1 = tou64(",");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L4955;
L5043:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("pand ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L5044:
	R1 = 1;
	mc_disasm_decodeaddr(asi64(R1));
	R1 = tou64("pxor ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_rmreg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", ");
	mc_disasm_genstr(asu64(R1));
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	R1 = 1;
	mc_disasm_printaddrmode(asi64(R1));
	goto L4955;
L4957:
// mc_disasm.decodetwobyteinstr.error:
	R1 = tou64("Unknown opcode 2-byte opcode: 0F ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = opc;
	mc_disasm_genhex(asi64(R1));
L4955:
L4954:
	return;
}

static void mc_disasm_decodeaddr(i64 w) {
    u64 R1, R2; 
	i64 modrm;
	i64 xxx;
	i64 mode;
	i64 sib;
	i64 rm;
	R1 = 0;
	R2 = R1;
	mc_disasm_indexreg = asi64(R2);
	mc_disasm_basereg = asi64(R1);
	R1 = 1;
	mc_disasm_scale = asi64(R1);
	R1 = 0;
	mc_disasm_offset = asi64(R1);
	R1 = 0;
	mc_disasm_ripmode = asi64(R1);
	asi64(R1) = w;
	if (!asi64(R1)) goto L5048;
	asi64(R1) = mc_disasm_sizeoverride;
	if (!asi64(R1)) goto L5050;
	R1 = 2;
	goto L5049;
L5050:
	R1 = 4;
L5049:
	mc_disasm_opsize = asi64(R1);
	asi64(R1) = mc_disasm_rex;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L5052;
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
L5052:
	goto L5047;
L5048:
	R1 = 1;
	mc_disasm_opsize = asi64(R1);
L5047:
	R1 = (u64)&mc_disasm_codeptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	modrm = asi64(R1);
	asi64(R1) = modrm;
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	mode = asi64(R1);
	asi64(R1) = modrm;
	R2 = 3;
	asi64(R1) >>= asi64(R2);
	R2 = 7;
	asi64(R1) &= asi64(R2);
	xxx = asi64(R1);
	asi64(R1) = modrm;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	rm = asi64(R1);
	asi64(R1) = mode;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5054;
	asi64(R1) = rm;
	R2 = 1;
	asi64(R1) += asi64(R2);
	mc_disasm_basereg = asi64(R1);
	R1 = 1;
	mc_disasm_addrmode = asi64(R1);
	goto L5053;
L5054:
	asi64(R1) = rm;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5055;
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5057;
	asi64(R1) = rm;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5057;
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_offset = asi64(R1);
	R1 = 1;
	mc_disasm_ripmode = asi64(R1);
	R1 = 2;
	mc_disasm_addrmode = asi64(R1);
	goto L5056;
L5057:
	asi64(R1) = rm;
	R2 = 1;
	asi64(R1) += asi64(R2);
	mc_disasm_basereg = asi64(R1);
	R1 = 2;
	mc_disasm_addrmode = asi64(R1);
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5059;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5060;
	goto L5061;
L5059:
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_offset = asi64(R1);
	goto L5058;
L5060:
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_offset = asi64(R1);
	goto L5058;
L5061:
L5058:
L5056:
	goto L5053;
L5055:
	R1 = 2;
	mc_disasm_addrmode = asi64(R1);
	asi64(R1) = mc_disasm_readbyte();
	sib = asi64(R1);
	asi64(R1) = sib;
	R2 = 3;
	asi64(R1) >>= asi64(R2);
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	mc_disasm_indexreg = asi64(R1);
	asi64(R1) = sib;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	mc_disasm_basereg = asi64(R1);
	asi64(R1) = sib;
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L5065;
	case 2: goto L5066;
	case 3: goto L5067;
	case 4: goto L5068;
	default: goto L5064;
    };
// SWITCH
L5065:
	R1 = 1;
	goto L5062;
L5066:
	R1 = 2;
	goto L5062;
L5067:
	R1 = 4;
	goto L5062;
L5068:
	R1 = 8;
	goto L5062;
L5064:
	R1 = 0;
L5062:
	mc_disasm_scale = asi64(R1);
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5070;
	asi64(R1) = mc_disasm_basereg;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5070;
	asi64(R1) = mc_disasm_indexreg;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5070;
	R1 = 0;
	R2 = R1;
	mc_disasm_basereg = asi64(R2);
	mc_disasm_indexreg = asi64(R1);
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_offset = asi64(R1);
	goto L5069;
L5070:
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5071;
	asi64(R1) = mc_disasm_basereg;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5071;
	R1 = 0;
	mc_disasm_basereg = asi64(R1);
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_offset = asi64(R1);
	goto L5069;
L5071:
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5072;
	asi64(R1) = mc_disasm_indexreg;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5072;
	R1 = 0;
	mc_disasm_indexreg = asi64(R1);
	goto L5069;
L5072:
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5074;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5075;
	goto L5076;
L5074:
	asi64(R1) = mc_disasm_readsbyte();
	mc_disasm_offset = asi64(R1);
	goto L5073;
L5075:
	asi64(R1) = mc_disasm_readint32();
	mc_disasm_offset = asi64(R1);
	goto L5073;
L5076:
L5073:
	asi64(R1) = mc_disasm_indexreg;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5078;
	R1 = 0;
	mc_disasm_indexreg = asi64(R1);
L5078:
L5069:
L5053:
	asi64(R1) = mc_disasm_basereg;
	if (!asi64(R1)) goto L5080;
	asi64(R1) = mc_disasm_rex;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L5080;
	R1 = 8;
	R2 = (u64)&mc_disasm_basereg;
	*toi64p(R2) += asi64(R1);
L5080:
	asi64(R1) = mc_disasm_indexreg;
	if (!asi64(R1)) goto L5082;
	asi64(R1) = mc_disasm_rex;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L5082;
	R1 = 8;
	R2 = (u64)&mc_disasm_indexreg;
	*toi64p(R2) += asi64(R1);
L5082:
	asi64(R1) = xxx;
	R2 = 1;
	asi64(R1) += asi64(R2);
	mc_disasm_rmreg = asi64(R1);
	asi64(R1) = mc_disasm_rex;
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L5084;
	R1 = 8;
	R2 = (u64)&mc_disasm_rmreg;
	*toi64p(R2) += asi64(R1);
L5084:
	asi64(R1) = xxx;
	mc_disasm_rmopc = asi64(R1);
	return;
}

static i64 mc_disasm_readbyte() {
    u64 R1, R2; 
	R1 = (u64)&mc_disasm_codeptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L5085;
L5085:
	return asi64(R1);
}

static i64 mc_disasm_readsbyte() {
    u64 R1, R2; 
	R1 = (u64)&mc_disasm_codeptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asi8(R1) = *toi8p(R1);
	R1 = toi64(toi8(R1));
	goto L5086;
L5086:
	return asi64(R1);
}

static u64 mc_disasm_readword16() {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = mc_disasm_codeptr;
	asu16(R1) = *tou16p(R1);
	R1 = tou64(tou16(R1));
	a = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_disasm_codeptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = a;
	goto L5087;
L5087:
	return asu64(R1);
}

static i64 mc_disasm_readint16() {
    u64 R1, R2; 
	i64 a;
	asu64(R1) = mc_disasm_codeptr;
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	R1 = 2;
	R2 = (u64)&mc_disasm_codeptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = a;
	goto L5088;
L5088:
	return asi64(R1);
}

static u64 mc_disasm_readword32() {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = mc_disasm_codeptr;
	asu32(R1) = *tou32p(R1);
	R1 = tou64(tou32(R1));
	a = asu64(R1);
	R1 = 4;
	R2 = (u64)&mc_disasm_codeptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = a;
	goto L5089;
L5089:
	return asu64(R1);
}

static i64 mc_disasm_readint32() {
    u64 R1, R2; 
	i64 a;
	asu64(R1) = mc_disasm_codeptr;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	a = asi64(R1);
	R1 = 4;
	R2 = (u64)&mc_disasm_codeptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = a;
	goto L5090;
L5090:
	return asi64(R1);
}

static i64 mc_disasm_readi64() {
    u64 R1, R2; 
	i64 a;
	asu64(R1) = mc_disasm_codeptr;
	asi64(R1) = *toi64p(R1);
	a = asi64(R1);
	R1 = 8;
	R2 = (u64)&mc_disasm_codeptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = a;
	goto L5091;
L5091:
	return asi64(R1);
}

static i64 mc_disasm_getreg(i64 regcode, i64 upper) {
    u64 R1, R2; 
	asi64(R1) = upper;
	if (!asi64(R1)) goto L5094;
	asi64(R1) = regcode;
	R2 = 8;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	goto L5092;
L5094:
	asi64(R1) = regcode;
	R2 = 1;
	asi64(R1) += asi64(R2);
	goto L5092;
L5092:
	return asi64(R1);
}

static u64 mc_disasm_strreg(i64 reg, i64 opsize) {
    u64 R1, R2; 
// PROC LOCAL STATICS GO HERE
	static struct $B30 mc_disasm_strreg_regnames8 = {{
	(u64)"al",
	(u64)"cl",
	(u64)"dl",
	(u64)"bl",
	(u64)"spl",
	(u64)"bpl",
	(u64)"sil",
	(u64)"dil",
	(u64)"r8b",
	(u64)"r9b",
	(u64)"r10b",
	(u64)"r11b",
	(u64)"r12b",
	(u64)"r13b",
	(u64)"r14b",
	(u64)"r15b",
	(u64)"ah",
	(u64)"bh",
	(u64)"ch",
	(u64)"dh"    }};
	static struct $B21 mc_disasm_strreg_regnames16 = {{
	(u64)"ax",
	(u64)"cx",
	(u64)"dx",
	(u64)"bx",
	(u64)"sp",
	(u64)"bp",
	(u64)"si",
	(u64)"di",
	(u64)"r8w",
	(u64)"r9w",
	(u64)"r10w",
	(u64)"r11w",
	(u64)"r12w",
	(u64)"r13w",
	(u64)"r14w",
	(u64)"r15w"    }};
	static struct $B21 mc_disasm_strreg_regnames32 = {{
	(u64)"eax",
	(u64)"ecx",
	(u64)"edx",
	(u64)"ebx",
	(u64)"esp",
	(u64)"ebp",
	(u64)"esi",
	(u64)"edi",
	(u64)"r8d",
	(u64)"r9d",
	(u64)"r10d",
	(u64)"r11d",
	(u64)"r12d",
	(u64)"r13d",
	(u64)"r14d",
	(u64)"r15d"    }};
	static struct $B21 mc_disasm_strreg_regnames64 = {{
	(u64)"rax",
	(u64)"rcx",
	(u64)"rdx",
	(u64)"rbx",
	(u64)"rsp",
	(u64)"rbp",
	(u64)"rsi",
	(u64)"rdi",
	(u64)"r8",
	(u64)"r9",
	(u64)"r10",
	(u64)"r11",
	(u64)"r12",
	(u64)"r13",
	(u64)"r14",
	(u64)"r15"    }};
	static struct $B30 mc_disasm_strreg_mregnames8 = {{
	(u64)"B0",
	(u64)"B10",
	(u64)"B11",
	(u64)"B4",
	(u64)"B15",
	(u64)"B14",
	(u64)"B5",
	(u64)"B3",
	(u64)"B12",
	(u64)"B13",
	(u64)"B1",
	(u64)"B2",
	(u64)"B6",
	(u64)"B7",
	(u64)"B8",
	(u64)"B9",
	(u64)"B16",
	(u64)"B18",
	(u64)"B19",
	(u64)"B17"    }};
	static struct $B21 mc_disasm_strreg_mregnames16 = {{
	(u64)"W0",
	(u64)"W10",
	(u64)"W11",
	(u64)"W4",
	(u64)"Wsp",
	(u64)"Wbp",
	(u64)"W5",
	(u64)"W3",
	(u64)"W12",
	(u64)"W13",
	(u64)"W1",
	(u64)"W2",
	(u64)"W6",
	(u64)"W7",
	(u64)"W8",
	(u64)"W9"    }};
	static struct $B21 mc_disasm_strreg_mregnames32 = {{
	(u64)"A0",
	(u64)"A10",
	(u64)"A11",
	(u64)"A4",
	(u64)"Astack",
	(u64)"Aframe",
	(u64)"A5",
	(u64)"A3",
	(u64)"A12",
	(u64)"A13",
	(u64)"A1",
	(u64)"A2",
	(u64)"A6",
	(u64)"A7",
	(u64)"A8",
	(u64)"A9"    }};
	static struct $B21 mc_disasm_strreg_mregnames64 = {{
	(u64)"D0",
	(u64)"D10",
	(u64)"D11",
	(u64)"D4",
	(u64)"Dstack",
	(u64)"Dframe",
	(u64)"D5",
	(u64)"D3",
	(u64)"D12",
	(u64)"D13",
	(u64)"D1",
	(u64)"D2",
	(u64)"D6",
	(u64)"D7",
	(u64)"D8",
	(u64)"D9"    }};
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5097;
	R1 = tou64("<>");
	goto L5095;
L5097:
	asi64(R1) = opsize;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5099;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5100;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5101;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5102;
	goto L5103;
L5099:
	R1 = (u64)&mc_disasm_strreg_regnames8;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5095;
	goto L5098;
L5100:
	R1 = (u64)&mc_disasm_strreg_regnames16;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5095;
	goto L5098;
L5101:
	R1 = (u64)&mc_disasm_strreg_regnames32;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5095;
	goto L5098;
L5102:
	R1 = (u64)&mc_disasm_strreg_regnames64;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5095;
	goto L5098;
L5103:
L5098:
	R1 = tou64("");
	goto L5095;
L5095:
	return asu64(R1);
}

static u64 mc_disasm_strfreg(i64 freg) {
    u64 R1, R2; 
// PROC LOCAL STATICS GO HERE
	static struct $B31 mc_disasm_strfreg_xxfregnames = {{
	(u64)"st0",
	(u64)"st1",
	(u64)"st2",
	(u64)"st3",
	(u64)"st4",
	(u64)"st5",
	(u64)"st6",
	(u64)"st7"    }};
	R1 = (u64)&mc_disasm_strfreg_xxfregnames;
	asi64(R2) = freg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5104;
L5104:
	return asu64(R1);
}

static void mc_disasm_printaddrmode(i64 xmm) {
    u64 R1, R2; 
	u64 plus;
	i64 addrsize;
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_addrmode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5107;
	goto L5108;
L5107:
	asi64(R1) = xmm;
	if (!asi64(R1)) goto L5110;
	asi64(R1) = mc_disasm_basereg;
	asu64(R1) = mc_disasm_strxmm(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5109;
L5110:
	R1 = (u64)&mc_disasm_basereg;
	mc_disasm_getsilx(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	asi64(R2) = mc_disasm_basereg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
L5109:
	goto L5105;
	goto L5106;
L5108:
L5106:
	asi64(R1) = mc_disasm_opsize;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5112;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5113;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5114;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5115;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5116;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5117;
	goto L5118;
L5112:
	R1 = tou64("byte ");
	mc_disasm_genstr(asu64(R1));
	goto L5111;
L5113:
	R1 = tou64("word ");
	mc_disasm_genstr(asu64(R1));
	goto L5111;
L5114:
	R1 = tou64("dword ");
	mc_disasm_genstr(asu64(R1));
	goto L5111;
L5115:
	R1 = tou64("qword ");
	mc_disasm_genstr(asu64(R1));
	goto L5111;
L5116:
	R1 = tou64("tword ");
	mc_disasm_genstr(asu64(R1));
	goto L5111;
L5117:
	R1 = tou64("oword ");
	mc_disasm_genstr(asu64(R1));
	goto L5111;
L5118:
	msysc_m$print_startcon();
	R1 = tou64("///OPSIZE");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_disasm_opsize;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5111:
	asi64(R1) = mc_disasm_ripmode;
	if (!asi64(R1)) goto L5120;
	R1 = tou64("rip:");
	mc_disasm_genstr(asu64(R1));
L5120:
	R1 = tou64("[");
	mc_disasm_genstr(asu64(R1));
	R1 = tou64("");
	plus = asu64(R1);
	asi64(R1) = mc_disasm_addroverride;
	if (!asi64(R1)) goto L5122;
	R1 = 4;
	goto L5121;
L5122:
	R1 = 8;
L5121:
	addrsize = asi64(R1);
	asi64(R1) = mc_disasm_basereg;
	if (!asi64(R1)) goto L5124;
	asi64(R1) = addrsize;
	asi64(R2) = mc_disasm_basereg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64("+");
	plus = asu64(R1);
L5124:
	asi64(R1) = mc_disasm_indexreg;
	if (!asi64(R1)) goto L5126;
	asu64(R1) = plus;
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = addrsize;
	asi64(R2) = mc_disasm_indexreg;
	asu64(R1) = mc_disasm_strreg(asi64(R2), asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64("<INDEX>");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L5128;
	R1 = tou64("*");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mc_disasm_scale;
	mc_disasm_genintd(asi64(R1));
L5128:
	R1 = tou64("+");
	plus = asu64(R1);
L5126:
	asi64(R1) = mc_disasm_offset;
	if (asi64(R1)) goto L5131;
	asi64(R1) = mc_disasm_basereg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5130;
	asi64(R1) = mc_disasm_indexreg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5130;
L5131:
	asi64(R1) = mc_disasm_basereg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5133;
	asi64(R1) = mc_disasm_indexreg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5133;
	asi64(R1) = mc_disasm_offset;
	mc_disasm_genhex(asi64(R1));
	goto L5132;
L5133:
	asi64(R1) = mc_disasm_offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5135;
	asu64(R1) = plus;
	mc_disasm_genstr(asu64(R1));
L5135:
	asi64(R1) = mc_disasm_offset;
	mc_disasm_genintd(asi64(R1));
L5132:
L5130:
	R1 = tou64("]");
	mc_disasm_genstr(asu64(R1));
L5105:
	return;
}

static void mc_disasm_genstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = (u64)&mc_disasm_deststr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	return;
}

static void mc_disasm_genintd(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	mc_disasm_genstr(asu64(R1));
	return;
}

static void mc_disasm_genhex(i64 a) {
    u64 R1, R2; 
	R1 = tou64("h");
	asi64(R2) = a;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	mc_disasm_genstr(asu64(R1));
	return;
}

static i64 mc_disasm_readimm() {
    u64 R1, R2; 
	asi64(R1) = mc_disasm_opsize;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5141;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5142;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5143;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5143;
	goto L5144;
L5141:
	asi64(R1) = mc_disasm_readsbyte();
	goto L5139;
	goto L5140;
L5142:
	asi64(R1) = mc_disasm_readint16();
	goto L5139;
	goto L5140;
L5143:
	asi64(R1) = mc_disasm_readint32();
	goto L5139;
	goto L5140;
L5144:
L5140:
	R1 = 0;
	goto L5139;
L5139:
	return asi64(R1);
}

static i64 mc_disasm_readimm8() {
    u64 R1, R2; 
	asi64(R1) = mc_disasm_opsize;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L5147;
	asi64(R1) = mc_disasm_readimm();
	goto L5145;
L5147:
	asi64(R1) = mc_disasm_readi64();
	goto L5145;
L5145:
	return asi64(R1);
}

static u64 mc_disasm_strxmm(i64 reg) {
    u64 R1, R2; 
	R1 = (u64)&mc_disasm_strxmm_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("xmm");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_disasm_strxmm_str;
	goto L5148;
L5148:
	return asu64(R1);
}

static u64 mc_disasm_strmmx(i64 reg) {
    u64 R1, R2; 
	R1 = (u64)&mc_disasm_strmmx_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("mmx");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_disasm_strmmx_str;
	goto L5149;
L5149:
	return asu64(R1);
}

static void mc_disasm_decode8087(i64 ttt) {
    u64 R1, R2, R3; 
	u8 bb;
	i64 longopc;
	i64 freg;
	i64 shortopc;
	i64 code;
	R1 = (u64)&mc_disasm_codeptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	bb = asu8(R1);
	asi64(R1) = ttt;
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	asu8(R2) = bb;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	longopc = asi64(R1);
	asu8(R1) = bb;
	R1 = toi64(tou8(R1));
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	freg = asi64(R1);
	asi64(R1) = longopc;
	R2 = 1753;
	if (asi64(R1) == asi64(R2)) goto L5152;
	R2 = 484;
	if (asi64(R1) == asi64(R2)) goto L5153;
	R2 = 485;
	if (asi64(R1) == asi64(R2)) goto L5154;
	R2 = 494;
	if (asi64(R1) == asi64(R2)) goto L5155;
	R2 = 488;
	if (asi64(R1) == asi64(R2)) goto L5156;
	R2 = 491;
	if (asi64(R1) == asi64(R2)) goto L5157;
	R2 = 489;
	if (asi64(R1) == asi64(R2)) goto L5158;
	R2 = 490;
	if (asi64(R1) == asi64(R2)) goto L5159;
	R2 = 492;
	if (asi64(R1) == asi64(R2)) goto L5160;
	R2 = 493;
	if (asi64(R1) == asi64(R2)) goto L5161;
	R2 = 506;
	if (asi64(R1) == asi64(R2)) goto L5162;
	R2 = 510;
	if (asi64(R1) == asi64(R2)) goto L5163;
	R2 = 511;
	if (asi64(R1) == asi64(R2)) goto L5164;
	R2 = 507;
	if (asi64(R1) == asi64(R2)) goto L5165;
	R2 = 509;
	if (asi64(R1) == asi64(R2)) goto L5166;
	R2 = 504;
	if (asi64(R1) == asi64(R2)) goto L5167;
	R2 = 508;
	if (asi64(R1) == asi64(R2)) goto L5168;
	R2 = 500;
	if (asi64(R1) == asi64(R2)) goto L5169;
	R2 = 481;
	if (asi64(R1) == asi64(R2)) goto L5170;
	R2 = 480;
	if (asi64(R1) == asi64(R2)) goto L5171;
	R2 = 498;
	if (asi64(R1) == asi64(R2)) goto L5172;
	R2 = 499;
	if (asi64(R1) == asi64(R2)) goto L5173;
	R2 = 496;
	if (asi64(R1) == asi64(R2)) goto L5174;
	R2 = 497;
	if (asi64(R1) == asi64(R2)) goto L5175;
	R2 = 505;
	if (asi64(R1) == asi64(R2)) goto L5176;
	R2 = 995;
	if (asi64(R1) == asi64(R2)) goto L5177;
	R2 = 992;
	if (asi64(R1) == asi64(R2)) goto L5178;
	R2 = 993;
	if (asi64(R1) == asi64(R2)) goto L5179;
	R2 = 994;
	if (asi64(R1) == asi64(R2)) goto L5180;
	R2 = 503;
	if (asi64(R1) == asi64(R2)) goto L5181;
	R2 = 502;
	if (asi64(R1) == asi64(R2)) goto L5182;
	R2 = 464;
	if (asi64(R1) == asi64(R2)) goto L5183;
	goto L5184;
L5152:
	R1 = tou64("fcompp");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5153:
	R1 = tou64("ftst");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5154:
	R1 = tou64("fxam");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5155:
	R1 = tou64("fldz");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5156:
	R1 = tou64("fld1");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5157:
	R1 = tou64("fldpi");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5158:
	R1 = tou64("fldl2t");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5159:
	R1 = tou64("fldl2e");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5160:
	R1 = tou64("fldlg2");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5161:
	R1 = tou64("fldln2");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5162:
	R1 = tou64("fsqrt");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5163:
	R1 = tou64("fsin");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5164:
	R1 = tou64("fcos");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5165:
	R1 = tou64("fsincos");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5166:
	R1 = tou64("fscale");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5167:
	R1 = tou64("fprem");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5168:
	R1 = tou64("frndint");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5169:
	R1 = tou64("fxtract");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5170:
	R1 = tou64("fabs");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5171:
	R1 = tou64("fchs");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5172:
	R1 = tou64("fptan");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5173:
	R1 = tou64("fpatan");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5174:
	R1 = tou64("f2xm1");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5175:
	R1 = tou64("fyl2x");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5176:
	R1 = tou64("fyl2xp1");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5177:
	R1 = tou64("finit");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5178:
	R1 = tou64("feni");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5179:
	R1 = tou64("fdisi");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5180:
	R1 = tou64("fclex");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5181:
	R1 = tou64("fincstp");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5182:
	R1 = tou64("fdecstp");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5183:
	R1 = tou64("fnop");
	mc_disasm_genstr(asu64(R1));
	goto L5151;
L5184:
	asi64(R1) = longopc;
	R2 = 2040;
	asi64(R1) &= asi64(R2);
	R2 = 448;
	if (asi64(R1) == asi64(R2)) goto L5186;
	R2 = 1488;
	if (asi64(R1) == asi64(R2)) goto L5187;
	R2 = 1496;
	if (asi64(R1) == asi64(R2)) goto L5188;
	R2 = 456;
	if (asi64(R1) == asi64(R2)) goto L5189;
	R2 = 208;
	if (asi64(R1) == asi64(R2)) goto L5190;
	R2 = 216;
	if (asi64(R1) == asi64(R2)) goto L5191;
	R2 = 1472;
	if (asi64(R1) == asi64(R2)) goto L5192;
	goto L5193;
L5186:
	R1 = tou64("fld ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5185;
L5187:
	R1 = tou64("fst ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5185;
L5188:
	R1 = tou64("fstp ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5185;
L5189:
	R1 = tou64("fxch ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5185;
L5190:
	R1 = tou64("fcom ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5185;
L5191:
	R1 = tou64("fcomp ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5185;
L5192:
	R1 = tou64("ffree ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5185;
L5193:
	asi64(R1) = longopc;
	R2 = 504;
	asi64(R1) &= asi64(R2);
	R2 = 192;
	if (asi64(R1) == asi64(R2)) goto L5195;
	R2 = 224;
	if (asi64(R1) == asi64(R2)) goto L5196;
	R2 = 232;
	if (asi64(R1) == asi64(R2)) goto L5197;
	R2 = 200;
	if (asi64(R1) == asi64(R2)) goto L5198;
	R2 = 240;
	if (asi64(R1) == asi64(R2)) goto L5199;
	R2 = 248;
	if (asi64(R1) == asi64(R2)) goto L5200;
	goto L5201;
L5195:
	asi64(R1) = freg;
	asi64(R2) = ttt;
	R3 = tou64("fadd");
	mc_disasm_do87arith(asu64(R3), asi64(R2), asi64(R1));
	goto L5194;
L5196:
	asi64(R1) = freg;
	asi64(R2) = ttt;
	R3 = tou64("fsub");
	mc_disasm_do87arith(asu64(R3), asi64(R2), asi64(R1));
	goto L5194;
L5197:
	asi64(R1) = freg;
	asi64(R2) = ttt;
	R3 = tou64("fsubr");
	mc_disasm_do87arith(asu64(R3), asi64(R2), asi64(R1));
	goto L5194;
L5198:
	asi64(R1) = freg;
	asi64(R2) = ttt;
	R3 = tou64("fmul");
	mc_disasm_do87arith(asu64(R3), asi64(R2), asi64(R1));
	goto L5194;
L5199:
	asi64(R1) = freg;
	asi64(R2) = ttt;
	R3 = tou64("fdiv");
	mc_disasm_do87arith(asu64(R3), asi64(R2), asi64(R1));
	goto L5194;
L5200:
	asi64(R1) = freg;
	asi64(R2) = ttt;
	R3 = tou64("fdivr");
	mc_disasm_do87arith(asu64(R3), asi64(R2), asi64(R1));
	goto L5194;
L5201:
	R1 = (u64)&mc_disasm_codeptr;
	(*tou64p(R1)) -=1;
	R1 = 0;
	mc_disasm_decodeaddr(asi64(R1));
	asi64(R1) = ttt;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = mc_disasm_rmopc;
	asi64(R1) += asi64(R2);
	shortopc = asi64(R1);
	asi64(R1) = shortopc;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L5203;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L5204;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L5205;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L5206;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L5207;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L5208;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5209;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5210;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5211;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5212;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5213;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5214;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L5215;
	goto L5216;
L5203:
	R1 = 4;
	R2 = tou64("fld");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5204:
	R1 = 5;
	R2 = tou64("fld");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5205:
	R1 = -1;
	R2 = tou64("fldbcd");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5206:
	R1 = 4;
	R2 = tou64("fstp");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5207:
	R1 = 5;
	R2 = tou64("fstp");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5208:
	R1 = -1;
	R2 = tou64("fstpbcd");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5209:
	R1 = -1;
	R2 = tou64("fldcw");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5210:
	R1 = -1;
	R2 = tou64("fstcw");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5211:
	R1 = -1;
	R2 = tou64("fstsw");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5212:
	R1 = -1;
	R2 = tou64("fstenv");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5213:
	R1 = -1;
	R2 = tou64("fldenv");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5214:
	R1 = -1;
	R2 = tou64("fsave");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5215:
	R1 = -1;
	R2 = tou64("frstor");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5202;
L5216:
	asi64(R1) = shortopc;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5218;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5219;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5220;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5221;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5222;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5223;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5224;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5225;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5226;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5227;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5228;
	goto L5229;
L5218:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fld");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5219:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fst");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5220:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fstp");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5221:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fcom");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5222:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fcomp");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5223:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fadd");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5224:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fsub");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5225:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fsubr");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5226:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fmul");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5227:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fdiv");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5228:
	asi64(R1) = ttt;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = tou64("fdivr");
	mc_disasm_do87mem(asu64(R2), asi64(R1));
	goto L5217;
L5229:
	R1 = tou64("UNKNOWN x87 OPCODE");
	mc_disasm_genstr(asu64(R1));
L5217:
L5202:
L5194:
L5185:
L5151:
	return;
}

static void mc_disasm_do87arith(u64 opcstr, i64 ttt, i64 freg) {
    u64 R1, R2; 
	i64 d;
	i64 p;
	asi64(R1) = ttt;
	R2 = 4;
	asi64(R1) &= asi64(R2);
	d = asi64(R1);
	asi64(R1) = ttt;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	p = asi64(R1);
	asu64(R1) = opcstr;
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = p;
	if (!asi64(R1)) goto L5232;
	R1 = tou64("p");
	mc_disasm_genstr(asu64(R1));
L5232:
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = d;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5234;
	R1 = tou64("st0, ");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	goto L5233;
L5234:
	asi64(R1) = freg;
	asu64(R1) = mc_disasm_strfreg(asi64(R1));
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(", st0");
	mc_disasm_genstr(asu64(R1));
L5233:
	return;
}

static void mc_disasm_do87mem(u64 opcstr, i64 mf) {
    u64 R1, R2; 
	R1 = tou64("f");
	mc_disasm_genstr(asu64(R1));
	asi64(R1) = mf;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5237;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5238;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5239;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5240;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5241;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5242;
	goto L5243;
L5237:
	R1 = 4;
	mc_disasm_opsize = asi64(R1);
	goto L5236;
L5238:
	R1 = tou64("i");
	mc_disasm_genstr(asu64(R1));
	R1 = 4;
	mc_disasm_opsize = asi64(R1);
	goto L5236;
L5239:
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	goto L5236;
L5240:
	R1 = tou64("i");
	mc_disasm_genstr(asu64(R1));
	R1 = 2;
	mc_disasm_opsize = asi64(R1);
	goto L5236;
L5241:
	R1 = tou64("i");
	mc_disasm_genstr(asu64(R1));
	R1 = 8;
	mc_disasm_opsize = asi64(R1);
	goto L5236;
L5242:
	R1 = 10;
	mc_disasm_opsize = asi64(R1);
	goto L5236;
L5243:
L5236:
	asu64(R1) = opcstr;
	R2 = 1;
	R1 += (i64)R2;
	mc_disasm_genstr(asu64(R1));
	R1 = tou64(" ");
	mc_disasm_genstr(asu64(R1));
	R1 = 0;
	mc_disasm_printaddrmode(asi64(R1));
	return;
}

static void mc_disasm_getsil(u64 reg) {
    u64 R1, R2; 
	asi64(R1) = mc_disasm_opsize;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5246;
	asi64(R1) = mc_disasm_rex;
	if (asi64(R1)) goto L5246;
	asu64(R1) = reg;
	asi64(R1) = *toi64p(R1);
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L5246;
	asu64(R1) = reg;
	asi64(R1) = *toi64p(R1);
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L5246;
	asu64(R1) = reg;
	asi64(R1) = *toi64p(R1);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5248;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5249;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5250;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5251;
	goto L5252;
L5248:
	R1 = 17;
	asu64(R2) = reg;
	*toi64p(R2) = asi64(R1);
	goto L5247;
L5249:
	R1 = 19;
	asu64(R2) = reg;
	*toi64p(R2) = asi64(R1);
	goto L5247;
L5250:
	R1 = 20;
	asu64(R2) = reg;
	*toi64p(R2) = asi64(R1);
	goto L5247;
L5251:
	R1 = 18;
	asu64(R2) = reg;
	*toi64p(R2) = asi64(R1);
	goto L5247;
L5252:
L5247:
L5246:
	return;
}

static void mc_disasm_getsilx(u64 reg) {
    u64 R1, R2; 
	asi64(R1) = mc_disasm_addrmode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5255;
	asi64(R1) = mc_disasm_opsize;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5255;
	asi64(R1) = mc_disasm_rex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5255;
	asu64(R1) = reg;
	asi64(R1) = *toi64p(R1);
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L5255;
	asu64(R1) = reg;
	asi64(R1) = *toi64p(R1);
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L5255;
	asu64(R1) = reg;
	asi64(R1) = *toi64p(R1);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5257;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5258;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5259;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5260;
	goto L5261;
L5257:
	R1 = 17;
	asu64(R2) = reg;
	*toi64p(R2) = asi64(R1);
	goto L5256;
L5258:
	R1 = 19;
	asu64(R2) = reg;
	*toi64p(R2) = asi64(R1);
	goto L5256;
L5259:
	R1 = 20;
	asu64(R2) = reg;
	*toi64p(R2) = asi64(R1);
	goto L5256;
L5260:
	R1 = 18;
	asu64(R2) = reg;
	*toi64p(R2) = asi64(R1);
	goto L5256;
L5261:
L5256:
L5255:
	return;
}

static u64 mx_run_writememlib(u64 filename) {
    u64 R1, R2, R3; 
	u64 plib;
	i64 n;
	i64 k;
	struct $B91 lib;
	i64 ndlls;
	i64 nlibs;
	i64 i;
	R1 = (u64)&lib;
	memset(R1, 0, 216);
	R1 = 8;
	asi64(R2) = mc_decls_ss_zdatalen;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 144;
	R2 = 8;
	asu64(R3) = mc_decls_ss_code;
	mx_run_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	asu64(R3) = mc_decls_ss_idata;
	mx_run_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("0.1234");
	R2 = (u64)&lib;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&lib;
	R3 = 184;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 192;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&lib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	mx_run_countsymbols();
	R1 = (u64)&lib;
	mx_run_writerelocs(asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&lib;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&lib;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&lib;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = (u64)&lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_idata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = (u64)&lib;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	ndlls = asi64(R1);
	R1 = 0;
	nlibs = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5265;
L5263:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5267;
	R1 = (u64)&ndlls;
	(*toi64p(R1)) += 1;
L5267:
	i += 1; if (i <= pc_decls_nplibfiles) goto L5263;
L5265:
	asi64(R1) = ndlls;
	R2 = (u64)&lib;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = nlibs;
	R2 = (u64)&lib;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = ndlls;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asi64(R2) = nlibs;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5270;
L5268:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5272;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&lib;
	R3 = 96;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5272:
	i += 1; if (i <= pc_decls_nplibfiles) goto L5268;
L5270:
	R1 = (u64)&lib;
	mx_run_addsymbols(asu64(R1));
	R1 = 216;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	plib = asu64(R1);
	R1 = 216;
	R2 = (u64)&lib;
	asu64(R3) = plib;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = plib;
	goto L5262;
L5262:
	return asu64(R1);
}

static void mx_run_roundsegment(u64 p, i64 align, i64 value) {
    u64 R1, R2, R3; 
	i64 length;
	i64 newlength;
	i64 av_1;
	asu64(R1) = p;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	length = asi64(R1);
	asi64(R1) = align;
	asi64(R2) = length;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newlength = asi64(R1);
	asi64(R1) = align;
	asu64(R2) = p;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = newlength;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5276;
L5274:
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L5274;
L5276:
	return;
}

static void mx_run_writerelocs(u64 lib) {
    u64 R1, R2, R3; 
	u64 oldr;
	u64 newr;
	i64 n;
	i64 k;
	u64 d;
	u64 baseptr64;
	i64 i;
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asi64(R2) = mc_decls_ss_ncoderelocs;
	asi64(R1) += asi64(R2);
	asu64(R2) = lib;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L5278:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5282;
	asu64(R1) = mc_decls_ss_idatarelocs;
	goto L5281;
L5282:
	asu64(R1) = mc_decls_ss_coderelocs;
L5281:
	oldr = asu64(R1);
	goto L5286;
L5283:
	R1 = (u64)&newr;
	memset(R1, 0, 8);
	asu64(R1) = oldr;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5288;
	R1 = 2;
	goto L5287;
L5288:
	R1 = 1;
L5287:
	R2 = (u64)&newr;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = oldr;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5290;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5291;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5291;
	goto L5292;
L5290:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5294;
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5293;
L5294:
	R1 = tou64("rel32/rel not imported");
	mc_libmcl_axerror(asu64(R1));
L5293:
	goto L5289;
L5291:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5296;
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5298;
	R1 = 3;
	goto L5297;
L5298:
	R1 = 4;
L5297:
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L5295;
L5296:
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5300;
	R1 = 1;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5299;
L5300:
	R1 = 2;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5299:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5295:
	goto L5289;
L5292:
	R1 = tou64("reloc?");
	mc_libmcl_axerror(asu64(R1));
L5289:
	asu64(R1) = newr;
	asu64(R2) = lib;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = oldr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	oldr = asu64(R1);
L5286:
	asu64(R1) = oldr;
	if (asu64(R1)) goto L5283;
	i += 1; if (i <= 2) goto L5278;
	return;
}

static void mx_run_addsymbols(u64 lib) {
    u64 R1, R2, R3; 
	u64 d;
	u64 stentry;
	u64 epoffset;
	i64 n;
	i64 k;
	u64 name;
	i64 i;
	R1 = 0;
	stentry = asu64(R1);
	R1 = -1;
	epoffset = asu64(R1);
	asi64(R1) = mx_decls_nsymimports;
	asu64(R2) = lib;
	R3 = 56;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mx_decls_nsymexports;
	asu64(R2) = lib;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mx_decls_nsymimports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 120;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5304;
L5302:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5306;
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 112;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5306:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5302;
L5304:
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5309;
L5307:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5311;
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5313;
	asu64(R1) = d;
	stentry = asu64(R1);
L5313:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 120;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 128;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = k;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5311:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5307;
L5309:
	asu64(R1) = stentry;
	if (!asu64(R1)) goto L5315;
	asu64(R1) = stentry;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5314;
L5315:
	msysc_m$print_startcon();
	R1 = tou64("NO MAIN FOUND");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = -1;
	asu64(R2) = lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5314:
	return;
}

static void mx_run_countsymbols() {
    u64 R1, R2, R3; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5319;
L5317:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5321;
	R1 = (u64)&mx_decls_nsymexports;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 118;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L5321:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5323;
	R1 = (u64)&mx_decls_nsymimports;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L5323:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5317;
L5319:
	return;
}

static void mx_run_runlibfile(u64 filename, i64 cmdskip) {
    u64 R1, R2; 
	u64 plib;
	asu64(R1) = filename;
	asu64(R1) = mx_run_writememlib(asu64(R1));
	plib = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadmemmcu(asu64(R1));
	asu64(R1) = plib;
	mx_lib_fixuplib(asu64(R1));
	asi64(R1) = cmdskip;
	asu64(R2) = plib;
	mx_lib_runprogram(asu64(R2), asi64(R1));
	return;
}

static u64 mx_lib_readlibfile(u64 filespec, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 plib;
	struct $B91 lib;
	u64 sig;
	i64 dir;
	i64 n;
	i64 tablesize;
	u64 q;
	i64 i;
	R1 = (u64)&lib;
	memset(R1, 0, 216);
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	sig = asu64(R1);
	asu64(R1) = sig;
	R2 = 441992013;
	if (asu64(R1) == asu64(R2)) goto L5327;
	msysc_m$print_startcon();
	R1 = tou64("Bad sig - not MCX file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L5327:
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 184;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 192;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5328:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readbyte(asu64(R1));
	R2 = R1;
	dir = asi64(R2);
	switch (asi64(R1)) {
	case 0: goto L5363;
	case 1: goto L5332;
	case 2: goto L5335;
	case 3: goto L5334;
	case 4: goto L5333;
	case 5: goto L5360;
	case 6: goto L5336;
	case 7: goto L5340;
	case 8: goto L5344;
	case 9: goto L5348;
	case 10: goto L5352;
	case 11: goto L5356;
	case 12: goto L5361;
	case 13: goto L5362;
	default: goto L5331;
    };
// SWITCH
L5332:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5328;
L5333:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5328;
L5334:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = (u64)&lib;
	R4 = 80;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L5328;
L5335:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L5328;
L5336:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5339;
L5337:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L5337;
L5339:
	goto L5328;
L5340:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5343;
L5341:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L5341;
L5343:
	goto L5328;
L5344:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 56;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5347;
L5345:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 112;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L5345;
L5347:
	goto L5328;
L5348:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 120;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5351;
L5349:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 120;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L5349;
L5351:
	goto L5328;
L5352:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5355;
L5353:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readbyte(asu64(R1));
	R2 = (u64)&lib;
	R3 = 128;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L5353;
L5355:
	goto L5328;
L5356:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	n = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5359;
L5357:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L5357;
L5359:
	goto L5328;
L5360:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = (u64)&lib;
	R4 = 88;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L5328;
L5361:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5328;
L5362:
	goto L5329;
	goto L5328;
L5363:
	goto L5328;
L5331:
	msysc_m$print_startcon();
	R1 = tou64("Unknown directive:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mx_decls_mcxdirnames;
	asi64(R2) = dir;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
	goto L5328;
L5329:
	R1 = 216;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	plib = asu64(R1);
	R1 = 216;
	R2 = (u64)&lib;
	asu64(R3) = plib;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = plib;
	goto L5325;
L5325:
	return asu64(R1);
}

static i64 mx_lib_readbyte(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L5364;
L5364:
	return asi64(R1);
}

static u64 mx_lib_readu32(u64 p) {
    u64 R1, R2; 
	u64 x;
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu32(R1) = *tou32p(R1);
	R1 = tou64(tou32(R1));
	x = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = x;
	goto L5365;
L5365:
	return asu64(R1);
}

static u64 mx_lib_readstring(u64 p) {
    u64 R1; 
	u64 s;
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	s = asu64(R1);
	goto L5368;
L5367:
L5368:
	asu64(R1) = p;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L5367;
	asu64(R1) = p;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	goto L5366;
L5366:
	return asu64(R1);
}

static void mx_lib_alloclibdata(u64 lib) {
    u64 R1, R2, R3, R4; 
	i64 tablesize;
	i64 n;
	u64 p;
	asu64(R1) = lib;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = lib;
	R3 = 152;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	tablesize = asi64(R1);
	asu64(R1) = lib;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = tablesize;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlinux_os_allocexecmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5372;
	R1 = tou64("");
	R2 = tou64("Can't alloc code memory");
	mx_lib_error(asu64(R2), asu64(R1));
L5372:
	asi64(R1) = n;
	asu64(R2) = lib;
	R3 = 72;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = tablesize;
	R2 = 0;
	asu64(R3) = p;
	asi64(R4) = n;
	R3 += (i64)R4;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = tablesize;
	asu64(R2) = lib;
	R3 = 160;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asu64(R2) = lib;
	R3 = 64;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 168;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = lib;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 176;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 144;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4294967295;
	if (asi64(R1) == asi64(R2)) goto L5374;
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 144;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = lib;
	R3 = 200;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5374:
	return;
}

static void mx_lib_error(u64 mess, u64 param) {
    u64 R1; 
	asu64(R1) = param;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L5377;
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5376;
L5377:
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5376:
	msysc_m$print_startcon();
	R1 = tou64("Aborting");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mx_lib_loadmemmcu(u64 lib) {
    u64 R1, R2, R3; 
	i64 newlib;
	u64 name;
	asu64(R1) = lib;
	R2 = 192;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = lib;
	R2 = 184;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asu64(R1) = lib;
	R2 = (u64)&mx_decls_libtable;
	asi64(R3) = newlib;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lib;
	mx_lib_loadimports(asu64(R1));
	return;
}

static void mx_lib_checknew(u64 name, u64 filename) {
    u64 R1, R2; 
	asu64(R1) = name;
	asi64(R1) = mx_lib_findlib(asu64(R1));
	if (!asi64(R1)) goto L5381;
	asu64(R1) = filename;
	R2 = tou64("Lib already exists:");
	mx_lib_error(asu64(R2), asu64(R1));
L5381:
	return;
}

static i64 mx_lib_findlib(u64 name) {
    u64 R1, R2; 
	i64 n;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5385;
L5383:
	R1 = (u64)&mx_decls_libnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5387;
	asi64(R1) = i;
	goto L5382;
L5387:
	i += 1; if (i <= mx_decls_nlibs) goto L5383;
L5385:
	R1 = 0;
	goto L5382;
L5382:
	return asi64(R1);
}

static i64 mx_lib_mxaddlib(u64 name) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mx_decls_nlibs;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L5390;
	R1 = tou64("");
	R2 = tou64("Too many libs");
	mx_lib_error(asu64(R2), asu64(R1));
L5390:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_libnametable;
	R3 = (u64)&mx_decls_nlibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mx_decls_nlibs;
	goto L5388;
L5388:
	return asi64(R1);
}

static void mx_lib_fixuplib(u64 lib) {
	mx_lib_loaddlls();
	mx_lib_checksymbols();
	mx_lib_dorelocations();
	return;
}

static void mx_lib_loaddlls() {
    u64 R1, R2, R3; 
	u64 inst;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5395;
L5393:
	R1 = (u64)&mx_decls_dllinsttable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L5397;
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mlinux_os_getdllinst(asu64(R1));
	inst = asu64(R1);
	asu64(R1) = inst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5399;
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't find DLL: #");
	mx_lib_error(asu64(R2), asu64(R1));
L5399:
	asu64(R1) = inst;
	R2 = (u64)&mx_decls_dllinsttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5397:
	i += 1; if (i <= mx_decls_ndlllibs) goto L5393;
L5395:
	return;
}

static u64 mx_lib_finddllsymbol(u64 name, u64 dllindex) {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	R1 = 0;
	asu64(R2) = dllindex;
	*toi64p(R2) = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5403;
L5401:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_dllinsttable;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlinux_os_getdllprocaddr(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L5405;
	asi64(R1) = i;
	asu64(R2) = dllindex;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	goto L5400;
L5405:
	i += 1; if (i <= mx_decls_ndlllibs) goto L5401;
L5403:
	R1 = 0;
	goto L5400;
L5400:
	return asu64(R1);
}

static void mx_lib_checksymbols() {
    u64 R1, R2, R3; 
	i64 dllindex;
	i64 undef;
	u64 p;
	i64 i;
	R1 = 0;
	undef = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5409;
L5407:
	R1 = (u64)&mx_decls_symboldefined;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L5411;
	R1 = (u64)&dllindex;
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mx_lib_finddllsymbol(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L5413;
	asu64(R1) = p;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = dllindex;
	R2 = (u64)&mx_decls_symboldllindex;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mx_decls_symboldefined;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L5412;
L5413:
	msysc_m$print_startcon();
	R1 = tou64("Undef");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mx_decls_symbolnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&undef;
	(*toi64p(R1)) += 1;
L5412:
L5411:
	i += 1; if (i <= mx_decls_nsymbols) goto L5407;
L5409:
	asi64(R1) = undef;
	if (!asi64(R1)) goto L5415;
L5415:
	return;
}

static void mx_lib_dorelocations() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5419;
L5417:
	R1 = (u64)&mx_decls_librelocated;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L5421;
	R1 = (u64)&mx_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_reloclib(asu64(R1));
L5421:
	i += 1; if (i <= mx_decls_nlibs) goto L5417;
L5419:
	return;
}

static void mx_lib_reloclib(u64 lib) {
    u64 R1, R2, R3, R4; 
	i64 index;
	i64 targetoffset;
	u64 name;
	u64 p;
	u64 q;
	u64 qaddr;
	u64 r;
	i64 av_1;
	i64 av_2;
	i64 i;
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = lib;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	qaddr = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5425;
L5423:
	asu64(R1) = lib;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 72;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 36;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = qaddr;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	R1 = 4;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&qaddr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*tou64p(R2) = asu64(R1);
	i += 1; if (i <= av_1) goto L5423;
L5425:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5428;
L5426:
	asu64(R1) = lib;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	r = asu64(R1);
	R1 = (u64)&r;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5430;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5431;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5432;
	goto L5433;
L5430:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L5429;
L5431:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L5429;
L5432:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L5429;
L5433:
L5429:
	R1 = (u64)&r;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5435;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5436;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5437;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5438;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5439;
	goto L5440;
L5435:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	targetoffset = asi64(R1);
	R1 = (u64)&r;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5442;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5443;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5444;
	goto L5445;
L5442:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L5441;
L5443:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L5441;
L5444:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L5441;
L5445:
L5441:
	goto L5434;
L5436:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	targetoffset = asi64(R1);
	R1 = (u64)&r;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5447;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5448;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5449;
	goto L5450;
L5447:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L5446;
L5448:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L5446;
L5449:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L5446;
L5450:
L5446:
	goto L5434;
L5437:
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 4;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
	goto L5434;
L5438:
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 4;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	*tou32p(R2) += asu32(R1);
	goto L5434;
L5439:
	R1 = (u64)&r;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5452;
	R1 = tou64("");
	R2 = tou64("imprel32?");
	mx_lib_error(asu64(R2), asu64(R1));
L5452:
	R1 = (u64)&r;
	R2 = 4;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	index = asi64(R1);
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = index;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L5434;
L5440:
L5434:
	i += 1; if (i <= av_2) goto L5426;
L5428:
	R1 = 1;
	R2 = (u64)&mx_decls_librelocated;
	asu64(R3) = lib;
	R4 = 208;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mx_lib_loadimports(u64 plib) {
    u64 R1, R2; 
	u64 qlib;
	u64 name;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = plib;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5456;
L5454:
	asu64(R1) = plib;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_dosublib(asu64(R1));
	i += 1; if (i <= av_1) goto L5454;
L5456:
	asu64(R1) = plib;
	mx_lib_alloclibdata(asu64(R1));
	asu64(R1) = plib;
	mx_lib_dosymbols(asu64(R1));
	return;
}

static void mx_lib_dosublib(u64 name) {
    u64 R1, R2, R3; 
	u64 qlib;
	i64 n;
	asu64(R1) = name;
	asi64(R1) = mx_lib_findlib(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (asi64(R1)) goto L5459;
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	n = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Loading sublib");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = n;
	R2 = tou64("ml");
	asu64(R3) = name;
	asu64(R2) = mlib_addext(asu64(R3), asu64(R2));
	asu64(R1) = mx_lib_loadlibfile(asu64(R2), asi64(R1));
	qlib = asu64(R1);
	asu64(R1) = qlib;
	mx_lib_loadimports(asu64(R1));
L5459:
	return;
}

static u64 mx_lib_loadlibfile(u64 filename, i64 libno) {
    u64 R1, R2, R3, R4; 
	u64 plib;
	u64 p;
	asu64(R1) = filename;
	asu64(R1) = mx_lib_readmxfile(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5462;
	asu64(R1) = filename;
	R2 = tou64("Can't find #");
	mx_lib_error(asu64(R2), asu64(R1));
L5462:
	asu64(R1) = p;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_readlibfile(asu64(R2), asu64(R1));
	plib = asu64(R1);
	asi64(R1) = libno;
	asu64(R2) = plib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = plib;
	R2 = R1;
	R3 = (u64)&mx_decls_libtable;
	asi64(R4) = libno;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	goto L5460;
L5460:
	return asu64(R1);
}

static void mx_lib_dosymbols(u64 lib) {
    u64 R1, R2, R3; 
	i64 ix;
	i64 libx;
	i64 dllx;
	u64 baseaddr;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5466;
L5464:
	asu64(R1) = lib;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_adddll(asu64(R1));
	i += 1; if (i <= av_1) goto L5464;
L5466:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5469;
L5467:
	asu64(R1) = lib;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mx_lib_addsymbol(asu64(R1));
	ix = asi64(R1);
	asi64(R1) = ix;
	asu64(R2) = lib;
	R3 = 176;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
	i += 1; if (i <= av_2) goto L5467;
L5469:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 64;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5472;
L5470:
	asu64(R1) = lib;
	R2 = 120;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mx_lib_addsymbol(asu64(R1));
	ix = asi64(R1);
	R1 = (u64)&mx_decls_symboldefined;
	asi64(R2) = ix;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L5474;
	msysc_m$print_startcon();
	R1 = tou64("Dupl symbol:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = lib;
	R2 = 120;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5471;
L5474:
	R1 = 1;
	R2 = (u64)&mx_decls_symboldefined;
	asi64(R3) = ix;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = lib;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5476;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5477;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5478;
	goto L5479;
L5476:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L5475;
L5477:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L5475;
L5478:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L5475;
L5479:
	R1 = 0;
	baseaddr = asu64(R1);
L5475:
	asu64(R1) = baseaddr;
	asu64(R2) = lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = ix;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mx_decls_symbollibindex;
	asi64(R3) = ix;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
L5471:
	i += 1; if (i <= av_3) goto L5470;
L5472:
	return;
}

static u64 mx_lib_readmxfile(u64 filename) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = filename;
	asu64(R1) = mlib_readfile(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5482;
	R1 = 0;
	goto L5480;
L5482:
	R1 = 13;
	asu64(R2) = p;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L5480;
L5480:
	return asu64(R1);
}

static void mx_lib_adddll(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5486;
L5484:
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5488;
	goto L5483;
L5488:
	i += 1; if (i <= mx_decls_ndlllibs) goto L5484;
L5486:
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L5490;
	R1 = tou64("");
	R2 = tou64("Too many DLLs");
	mx_lib_error(asu64(R2), asu64(R1));
L5490:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_dllnametable;
	R3 = (u64)&mx_decls_ndlllibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5483:
	return;
}

static i64 mx_lib_addsymbol(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5494;
L5492:
	R1 = (u64)&mx_decls_symbolnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5496;
	asi64(R1) = i;
	goto L5491;
L5496:
	i += 1; if (i <= mx_decls_nsymbols) goto L5492;
L5494:
	asi64(R1) = mx_decls_nsymbols;
	R2 = 3000;
	if (asi64(R1) < asi64(R2)) goto L5498;
	R1 = tou64("");
	R2 = tou64("Too many Imports");
	mx_lib_error(asu64(R2), asu64(R1));
L5498:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_symbolnametable;
	R3 = (u64)&mx_decls_nsymbols;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mx_decls_nsymbols;
	goto L5491;
L5491:
	return asi64(R1);
}

static void mx_lib_setspecialglobals(i64 cmdskip) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5502;
L5500:
	R1 = tou64("msys.$cmdskip");
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L5505;
	R1 = tou64("$cmdskip");
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5504;
L5505:
	asi64(R1) = cmdskip;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	*tou8p(R2) = asu8(R1);
L5504:
	i += 1; if (i <= mx_decls_nsymbols) goto L5500;
L5502:
	return;
}

static void mx_lib_runprogram(u64 lib, i64 cmdskip) {
    u64 R1, R2, R3; 
	u64 fnptr;
	i64 libno;
	i64 i;
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	libno = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5509;
L5507:
	asi64(R1) = i;
	asi64(R2) = libno;
	if (asi64(R1) == asi64(R2)) goto L5511;
	R1 = (u64)&mx_decls_libinitdone;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L5511;
	R1 = (u64)&mx_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_calllibinit(asu64(R1));
L5511:
	i += 1; if (i <= mx_decls_nlibs) goto L5507;
L5509:
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5513;
	R1 = tou64("");
	R2 = tou64("No entry point found");
	mx_lib_error(asu64(R2), asu64(R1));
L5513:
	asi64(R1) = cmdskip;
	mx_lib_setspecialglobals(asi64(R1));
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = fnptr;
	((F20)R1)();
	R1 = 1;
	R2 = (u64)&mx_decls_libinitdone;
	asi64(R3) = libno;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mx_lib_calllibinit(u64 lib) {
    u64 R1, R2, R3, R4; 
	u64 fnptr;
	i64 libno;
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	libno = asi64(R1);
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5516;
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = fnptr;
	((F20)R1)();
L5516:
	R1 = 1;
	R2 = (u64)&mx_decls_libinitdone;
	asu64(R3) = lib;
	R4 = 208;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static u64 mx_lib_findsymbol(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5520;
L5518:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5522;
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5517;
L5522:
	i += 1; if (i <= mx_decls_nsymbols) goto L5518;
L5520:
	R1 = 0;
	goto L5517;
L5517:
	return asu64(R1);
}

static u64 mx_lib_loadmx(u64 filename) {
    u64 R1, R2; 
	u64 plib;
	i64 newlib;
	u64 name;
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = filename;
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asi64(R1) = newlib;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_loadlibfile(asu64(R2), asi64(R1));
	plib = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadimports(asu64(R1));
	asu64(R1) = plib;
	goto L5523;
L5523:
	return asu64(R1);
}

static u64 mx_lib_loadmemmcb(u64 filename, u64 p) {
    u64 R1, R2, R3; 
	u64 plib;
	i64 newlib;
	u64 name;
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = filename;
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_readlibfile(asu64(R2), asu64(R1));
	plib = asu64(R1);
	asi64(R1) = newlib;
	asu64(R2) = plib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = plib;
	R2 = (u64)&mx_decls_libtable;
	asi64(R3) = newlib;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadimports(asu64(R1));
	asu64(R1) = plib;
	goto L5524;
L5524:
	return asu64(R1);
}

static void mx_write_writemcx(u64 filename) {
    u64 R1, R2, R3; 
	i64 n;
	i64 ndlls;
	i64 nlibs;
	i64 i;
	R1 = 8;
	asi64(R2) = mc_decls_ss_zdatalen;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 144;
	R2 = 8;
	asu64(R3) = mc_decls_ss_code;
	mx_write_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	asu64(R3) = mc_decls_ss_idata;
	mx_write_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mx_write_dest = asu64(R1);
	R1 = 441992013;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	mx_write_genbyte(asi64(R1));
	R1 = tou64("0.1234");
	mx_write_genstring(asu64(R1));
	mx_run_countsymbols();
	mx_write_writerelocs();
	R1 = 4;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	mx_write_genu32(asi64(R1));
	R1 = 2;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = mc_decls_ss_code;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mx_write_genblock(asu64(R2), asi64(R1));
	R1 = 3;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = mc_decls_ss_idata;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mx_write_genblock(asu64(R2), asi64(R1));
	R1 = 0;
	ndlls = asi64(R1);
	R1 = 0;
	nlibs = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5528;
L5526:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5530;
	R1 = (u64)&ndlls;
	(*toi64p(R1)) += 1;
L5530:
	i += 1; if (i <= pc_decls_nplibfiles) goto L5526;
L5528:
	R1 = 6;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = ndlls;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5533;
L5531:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5535;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_write_genstring(asu64(R1));
L5535:
	i += 1; if (i <= pc_decls_nplibfiles) goto L5531;
L5533:
	mx_write_writesymbols();
	R1 = 13;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mx_write_dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mx_write_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = mx_write_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mx_write_writerelocs() {
    u64 R1, R2, R3; 
	u64 oldr;
	u64 newr;
	i64 n;
	i64 count;
	u64 d;
	u64 baseptr64;
	i64 i;
	R1 = 5;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asi64(R2) = mc_decls_ss_ncoderelocs;
	asi64(R1) += asi64(R2);
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	R1 = 0;
	count = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L5537:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5541;
	asu64(R1) = mc_decls_ss_idatarelocs;
	goto L5540;
L5541:
	asu64(R1) = mc_decls_ss_coderelocs;
L5540:
	oldr = asu64(R1);
	goto L5545;
L5542:
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
	R1 = (u64)&newr;
	memset(R1, 0, 8);
	asu64(R1) = oldr;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5547;
	R1 = 2;
	goto L5546;
L5547:
	R1 = 1;
L5546:
	R2 = (u64)&newr;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = oldr;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5549;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5550;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5550;
	goto L5551;
L5549:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5553;
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5552;
L5553:
	R1 = tou64("rel32/rel not imported");
	mc_libmcl_axerror(asu64(R1));
L5552:
	goto L5548;
L5550:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5555;
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5557;
	R1 = 3;
	goto L5556;
L5557:
	R1 = 4;
L5556:
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L5554;
L5555:
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5559;
	R1 = 1;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5558;
L5559:
	R1 = 2;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5558:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5554:
	goto L5548;
L5551:
	R1 = tou64("reloc?");
	mc_libmcl_axerror(asu64(R1));
L5548:
	R1 = 8;
	R2 = (u64)&newr;
	mx_write_genblock(asu64(R2), asi64(R1));
	asu64(R1) = oldr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	oldr = asu64(R1);
L5545:
	asu64(R1) = oldr;
	if (asu64(R1)) goto L5542;
	i += 1; if (i <= 2) goto L5537;
	return;
}

static void mx_write_writesymbols() {
    u64 R1, R2; 
	u64 d;
	i64 n;
	u64 name;
	i64 i;
	R1 = 8;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymimports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5563;
L5561:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5565;
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mx_write_genstring(asu64(R1));
L5565:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5561;
L5563:
	R1 = 9;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5568;
L5566:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5570;
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5572;
	asu64(R1) = d;
	mx_write_entrypoint = asu64(R1);
L5572:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mx_write_genstring(asu64(R1));
L5570:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5566;
L5568:
	R1 = 10;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5575;
L5573:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5577;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mx_write_genbyte(asi64(R1));
L5577:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5573;
L5575:
	R1 = 11;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5580;
L5578:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5582;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mx_write_genu32(asi64(R1));
L5582:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5578;
L5580:
	R1 = 12;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mx_write_entrypoint;
	if (!asu64(R1)) goto L5584;
	asu64(R1) = mx_write_entrypoint;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mx_write_genu32(asi64(R1));
	goto L5583;
L5584:
	R1 = 4294967295;
	mx_write_genu32(asi64(R1));
L5583:
	return;
}

static void mx_write_roundsegment(u64 p, i64 align, i64 value) {
    u64 R1, R2, R3; 
	i64 length;
	i64 newlength;
	i64 av_1;
	asu64(R1) = p;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	length = asi64(R1);
	asi64(R1) = align;
	asi64(R2) = length;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newlength = asi64(R1);
	asi64(R1) = align;
	asu64(R2) = p;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = newlength;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5588;
L5586:
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L5586;
L5588:
	return;
}

static void mx_write_genbyte(i64 x) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = x;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mx_write_genu32(i64 x) {
    u64 R1, R2, R3; 
	R1 = 4;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = x;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 4; asu64(R2) = asu64(R3);
	*tou32p(R2) = asu32(R1);
	return;
}

static void mx_write_genstring(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = s;
	mx_write_genblock(asu64(R2), asi64(R1));
	return;
}

static void mx_write_genblock(u64 p, i64 length) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = length;
	asu64(R2) = p;
	asu64(R3) = mx_write_dest;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	return;
}

void cc_cli_main() {
    u64 R1, R2; 
	u64 file;
	pcl_start();
	asi64(R1) = mlinux_os_clock();
	cc_cli_startclock = asi64(R1);
	asi64(R1) = cc_cli_startclock;
	pc_decls_pstartclock = asi64(R1);
	cc_cli_starttiming();
	cc_cli_initdata();
	cc_cli_getinputoptions();
	cc_cli_initsearchdirs();
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5595;
	cc_cli_showsearchdirs();
L5595:
	cc_cli_initlogfile();
	asi64(R1) = cc_cli_gettiming();
	cc_cli_inittime = asi64(R1);
	asu8(R1) = cc_cli_fverbose;
	if (!asu8(R1)) goto L5597;
	msysc_m$print_startcon();
	R1 = tou64("Compiling # to #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_cli_outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5597:
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	pc_decls_$pmodulename = asu64(R1);
	cc_cli_do_loadmodule();
	cc_cli_do_preprocess();
	cc_cli_do_parsemodule();
	cc_cli_do_genpcl();
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5599;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5600;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5601;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5602;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5603;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5604;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5605;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5606;
	goto L5607;
L5599:
	pc_run_pcl_runpcl();
	goto L5598;
L5600:
	cc_cli_do_genmcl();
	goto L5598;
L5601:
	cc_cli_do_asm();
	goto L5598;
L5602:
	cc_cli_do_obj();
	goto L5598;
L5603:
	cc_cli_do_dll();
	goto L5598;
L5604:
	cc_cli_do_exe();
	goto L5598;
L5605:
	cc_cli_do_mx();
	goto L5598;
L5606:
	cc_cli_do_run();
	goto L5598;
L5607:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L5609;
	msysc_m$print_startcon();
	R1 = (u64)&cc_cli_passnames;
	asu8(R2) = cc_cli_cc_pass;
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("not ready");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5609:
L5598:
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L5611;
	msysc_m$print_startcon();
	R1 = tou64("Done.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5611:
	asu8(R1) = cc_cli_fshowtiming;
	if (!asu8(R1)) goto L5613;
	cc_cli_showtiming();
L5613:
	cc_cli_closelogfile();
	R1 = 0;
	exit(R1);
	R1 = 0;
	exit(R1);
	return;
}

static void cc_cli_do_preprocess() {
    u64 R1, R2, R3; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5616;
	asu8(R1) = cc_cli_fstdout;
	R1 = toi64(tou8(R1));
	asu64(R2) = cc_cli_outfile;
	asu64(R3) = cc_decls_inputfile;
	cc_lex_lex_preprocess_only(asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	exit(R1);
L5616:
	return;
}

static void cc_cli_do_loadmodule() {
    u64 R1, R2, R3; 
	u64 modulename;
	struct $B15 path;
	i64 status;
	i64 i;
	i64 flag;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5619;
	msysc_m$print_startcon();
	R1 = tou64("Loading:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5619:
	cc_cli_starttiming();
	R1 = tou64("<dummy file>");
	R2 = (u64)&cc_decls_sourcefilenames;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("<dummy path>");
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("<sourcefile0>");
	R2 = (u64)&cc_decls_sourcefiletext;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilesizes;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 2;
	R2 = tou64("$prog");
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	cc_decls_stprogram = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L5621;
	asu64(R1) = cc_decls_inputfile;
	R2 = tou64("Can't load main module: #");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5621:
	asu64(R1) = cc_decls_inputfile;
	asu64(R2) = cc_decls_inputfile;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	cc_decls_mainfileno = asi64(R1);
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	modulename = asu64(R1);
	R1 = 3;
	asu64(R2) = modulename;
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	asu64(R3) = cc_decls_stprogram;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	cc_decls_stmodule = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&path;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L5623;
	R1 = (u64)&cc_decls_nsearchdirs;
	(*toi64p(R1)) += 1;
	asi64(R1) = cc_decls_nsearchdirs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L5626;
L5624:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = (u64)&cc_decls_searchdirs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += -1; if (i >= 2) goto L5624;
L5626:
	R1 = (u64)&path;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5623:
	asi64(R1) = cc_cli_gettiming();
	cc_cli_loadtime = asi64(R1);
	return;
}

static void cc_cli_do_parsemodule() {
    u64 R1, R2; 
	i64 tt;
	cc_cli_starttiming();
	asi64(R1) = cc_parse_parsemodule();
	asi64(R1) = cc_cli_gettiming();
	R2 = R1;
	tt = asi64(R2);
	cc_cli_parsetime = asi64(R1);
	return;
}

static void cc_cli_do_genpcl() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) >= asi64(R2)) goto L5630;
	goto L5628;
L5630:
	cc_cli_starttiming();
	cc_genpcl_codegen_pcl();
	asi64(R1) = cc_cli_gettiming();
	cc_cli_pcltime = asi64(R1);
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L5633;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L5632;
L5633:
	pc_reduce_pcl_reducetest();
L5632:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5635;
	asu64(R1) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
L5635:
L5628:
	return;
}

static void cc_cli_do_genmcl() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) >= asi64(R2)) goto L5638;
	goto L5636;
L5638:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5640;
	R1 = 16705;
	asu64(R2) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L5640:
L5636:
	return;
}

static void cc_cli_do_asm() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L5643;
	goto L5641;
L5643:
	R1 = 16705;
	asu64(R2) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L5641:
	return;
}

static void cc_cli_do_obj() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5646;
	goto L5644;
L5646:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writeobj(asu64(R1));
L5644:
	return;
}

static void cc_cli_do_dll() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5649;
	goto L5647;
L5649:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writedll(asu64(R1));
L5647:
	return;
}

static void cc_cli_do_exe() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5652;
	goto L5650;
L5652:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writeexe(asu64(R1));
L5650:
	return;
}

static void cc_cli_do_mx() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5655;
	goto L5653;
L5655:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writemx(asu64(R1));
L5653:
	return;
}

static void cc_cli_do_run() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5658;
	goto L5656;
L5658:
	pc_api_pcl_exec();
L5656:
	return;
}

static void cc_cli_initlogfile() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_debugmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L5661;
	R1 = tou64("mcc.log");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("w");
	R2 = tou64("mcc.log");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	cc_decls_logdev = asu64(R1);
L5661:
	return;
}

static void cc_cli_closelogfile() {
    u64 R1, R2, R3; 
	struct $B5 str;
	i64 pos;
	asu8(R1) = cc_cli_debugmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L5664;
	goto L5662;
L5664:
	asu8(R1) = cc_cli_fshowmcl;
	if (!asu8(R1)) goto L5666;
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L5666;
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC ASM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 16705;
	R2 = 0;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5666:
	asu8(R1) = cc_cli_fshowpcl;
	if (!asu8(R1)) goto L5668;
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L5668;
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("!PROC PCL");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = cc_cli_fshowpst;
	if (!asu8(R1)) goto L5670;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
	asu64(R1) = cc_decls_logdev;
	R2 = tou64("PSYMTAB");
	cc_lib_addtolog(asu64(R2), asu64(R1));
L5670:
L5668:
	cc_cli_showast();
	asu8(R1) = cc_cli_fshowst;
	if (!asu8(R1)) goto L5672;
	R1 = tou64("ST");
	cc_cli_showst(asu64(R1));
L5672:
	asu8(R1) = cc_cli_fshowstflat;
	if (!asu8(R1)) goto L5674;
	R1 = tou64("STFLAT");
	cc_cli_showstflat(asu64(R1));
L5674:
	asu8(R1) = cc_cli_fshowtypes;
	if (!asu8(R1)) goto L5676;
	asu64(R1) = cc_decls_logdev;
	cc_show_printmodelist(asu64(R1));
L5676:
	asu64(R1) = cc_decls_logdev;
	asi32(R1) = fclose(asu64(R1));
	R1 = tou64("cc.m");
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L5678;
	msysc_m$print_startcon();
	R1 = tou64("PRESS KEY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mlinux_os_getch();
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L5680;
	R1 = 0;
	exit(R1);
L5680:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\m\\scripts\\med.bat ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mcc.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&str;
	asi64(R1) = mlinux_os_execwait(asu64(R3), asi64(R2), asu64(R1));
	goto L5677;
L5678:
	msysc_m$print_startcon();
	R1 = tou64("Diagnostic outputs written to");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mcc.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5677:
L5662:
	return;
}

static void cc_cli_initdata() {
    u64 R1, R2, R3; 
	mlib_pcm_init();
	cc_lex_lexsetup();
	cc_lib_inittypetables();
	cc_lib_initcclib();
	R1 = 0;
	cc_decls_nlibfiles = asi64(R1);
	R1 = tou64("msvcrt");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("gdi32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("user32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("kernel32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_cli_cgetsourceinfo;
	pc_decls_igetmsourceinfo = asu64(R1);
	asu8(R1) = pcl_pdcc;
	if (!asu8(R1)) goto L5683;
	R1 = 2;
	cc_cli_highmem = asu8(R1);
L5683:
	asu8(R1) = pcl_pdcc;
	if (!asu8(R1)) goto L5685;
	R1 = 0;
	cc_cli_fwriteerrors = asu8(R1);
L5685:
	return;
}

static i64 cc_cli_cgetsourceinfo(i64 pos, u64 filename, u64 sourceline) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = pos;
	R3 = 24;
	R4 = 32;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = filename;
	*tou64p(R2) = asu64(R1);
	R1 = tou64("<line>");
	asu64(R2) = sourceline;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pos;
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L5686;
L5686:
	return asi64(R1);
}

static void cc_cli_initsearchdirs() {
    u64 R1, R2, R3; 
	struct $B15 str1;
	struct $B15 str2;
	i64 i;
	R1 = tou64("");
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = tou64("c:/cx/headers/");
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mlinux_os_gethostname();
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5690;
L5688:
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L5692;
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5692:
	i += 1; if (i <= cc_decls_nincludepaths) goto L5688;
L5690:
	return;
}

static void cc_cli_showsearchdirs() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Include search paths:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = cc_cli_dointheaders;
	if (!asu8(R1)) goto L5695;
	msysc_m$print_startcon();
	R1 = tou64("0: Internal standard headers (disable with -ext)");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5695:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsearchdirs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5698;
L5696:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L5700;
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5699;
L5700:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": .");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5699:
	i += 1; if (i <= cc_decls_nsearchdirs) goto L5696;
L5698:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showast() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_fshowast;
	if (!asu8(R1)) goto L5703;
	R1 = tou64("PROC AST");
	asu64(R2) = cc_decls_logdev;
	cc_show_printcode(asu64(R2), asu64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5703:
	return;
}

static void cc_cli_showstflat(u64 caption) {
    u64 R1; 
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	cc_show_printstflat(asu64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showst(u64 caption) {
    u64 R1, R2, R3; 
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = cc_decls_stmodule;
	asu64(R3) = cc_decls_logdev;
	cc_show_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showfiles() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Sourcefiles:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5709;
L5707:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilesizes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nsourcefiles) goto L5707;
L5709:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showtime(u64 caption, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("# # ms # %");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = caption;
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("5");
	asi64(R2) = t;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("5.1jr");
	asi64(R2) = t;
	asr64(R2) = tor64(asi64(R2));
	asr64(R3) = 1.000000000000000000e+002;
	asr64(R2) *= asr64(R3);
	asi64(R3) = cc_cli_compiletime;
	asr64(R3) = tor64(asi64(R3));
	asr64(R2) /= asr64(R3);
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showtiming() {
    u64 R1, R2; 
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = cc_cli_startclock;
	asi64(R1) -= asi64(R2);
	cc_cli_compiletime = asi64(R1);
	asi64(R1) = cc_cli_inittime;
	R2 = tou64("Init:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_loadtime;
	R2 = tou64("Load:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_parsetime;
	R2 = tou64("Parse:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_pcltime;
	R2 = tou64("PCL:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_mcltime;
	R2 = tou64("MCL:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_sstime;
	R2 = tou64("SS:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_exetime;
	R2 = tou64("EXE:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("-----------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = cc_cli_compiletime;
	R2 = tou64("Total:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	return;
}

static void cc_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 j;
	i64 k;
	i64 paramno;
	i64 pmtype;
	i64 sw;
	i64 ncolons;
	u64 name;
	u64 value;
	u64 ext;
	i64 av_1;
	R1 = 1;
	paramno = asi64(R1);
	R1 = 0;
	ncolons = asi64(R1);
	asu8(R1) = pcl_pc_userunpcl;
	if (!asu8(R1)) goto L5714;
	R1 = 6;
	cc_cli_cc_pass = asu8(R1);
	R1 = 0;
	cc_cli_fverbose = asu8(R1);
L5714:
	R1 = tou64("cs.exe");
	asu64(R2) = mlinux_os_gethostname();
	asu64(R2) = mlib_extractfile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5716;
	R1 = 0;
	cc_cli_fverbose = asu8(R1);
	R1 = tou64("");
	R2 = 17;
	cc_cli_do_option(asi64(R2), asu64(R1));
L5716:
L5717:
	R1 = tou64(".c");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	pmtype = asi64(R1);
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5720;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5721;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5722;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5723;
	goto L5724;
L5720:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 53;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5728;
L5725:
	R1 = (u64)&cc_cli_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5730;
	asu64(R1) = value;
	asi64(R2) = sw;
	cc_cli_do_option(asi64(R2), asu64(R1));
	goto L5727;
L5730:
	sw += 1; if (sw <= av_1) goto L5725;
L5728:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L5727:
	goto L5719;
L5721:
	asu64(R1) = cc_decls_inputfile;
	if (!asu64(R1)) goto L5732;
	R1 = tou64("");
	R2 = tou64("One input file only");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5732:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_decls_inputfile = asu64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5735;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5734;
L5735:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	cc_cli_cmdskip = asi64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 6;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	cc_decls_pci_target = asu8(R1);
	goto L5718;
L5734:
	goto L5719;
L5722:
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 200;
	if (asi64(R1) < asi64(R2)) goto L5737;
	R1 = tou64("");
	R2 = tou64("Too many lib files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5737:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L5719;
L5723:
	goto L5718;
	goto L5719;
L5724:
L5719:
	goto L5717;
L5718:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5739;
	R1 = 12;
	cc_cli_cc_pass = asu8(R1);
	asu8(R1) = pcl_asmonly;
	if (!asu8(R1)) goto L5741;
	R1 = 8;
	cc_cli_cc_pass = asu8(R1);
L5741:
L5739:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5744;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5743;
L5744:
	R1 = 2;
	cc_cli_highmem = asu8(R1);
	goto L5742;
L5743:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5746;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5745;
L5746:
	R1 = 0;
	cc_cli_highmem = asu8(R1);
L5745:
L5742:
	R1 = (u64)&cc_cli_extnames;
	asu8(R2) = cc_cli_cc_pass;
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	cc_cli_outext = asu64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5749;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5748;
L5749:
	asu64(R1) = mc_writeasm_asmext;
	cc_cli_outext = asu64(R1);
L5748:
	asu64(R1) = cc_decls_inputfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5751;
	asu8(R1) = cc_cli_fwriteheaders;
	if (asu8(R1)) goto L5751;
	cc_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("   prog[.c]          Compile prog.c to prog.exe");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-r prog[.c]          Compile prog.c and run");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-i prog[.c]          Compile prog.c and interpret");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-help                Show all options");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L5751:
	asu8(R1) = cc_cli_fwriteheaders;
	if (!asu8(R1)) goto L5753;
	cc_headers_writeheaders();
	R1 = 20;
	exit(R1);
L5753:
	asu64(R1) = cc_cli_outfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5755;
	asu64(R1) = cc_cli_outext;
	asu64(R2) = cc_decls_inputfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_cli_outfile = asu64(R1);
L5755:
	asu8(R1) = cc_cli_fshortnames;
	R1 = toi64(tou8(R1));
	R2 = -1;
	asu8(R3) = cc_cli_highmem;
	R3 = toi64(tou8(R3));
	pc_api_pcl_setflags(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cc_cli_cmdskip;
	pc_api_pcl_cmdskip(asi64(R2), asu64(R1));
	return;
}

static void cc_cli_do_option(i64 sw, u64 value) {
    u64 R1, R2, R3; 
	struct $B15 str;
	i64 length;
	u64 p;
	i64 av_1;
	i64 i;
	R1 = (u64)&cc_cli_optvars;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L5758;
	R1 = (u64)&cc_cli_optvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sw;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5760;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L5760;
	R1 = 1;
	R2 = (u64)&cc_cli_debugmode;
	*tou8p(R2) |= asu8(R1);
L5760:
	asi64(R1) = sw;
	R2 = 26;
	if (asi64(R1) < asi64(R2)) goto L5762;
	R2 = 34;
	if (asi64(R1) > asi64(R2)) goto L5762;
	R1 = 2;
	R2 = (u64)&cc_cli_debugmode;
	*tou8p(R2) |= asu8(R1);
L5762:
	asi64(R1) = sw;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5764;
	asu64(R1) = cc_decls_inputfile;
	if (!asu64(R1)) goto L5764;
	R1 = tou64("");
	R2 = tou64("-RUNP OUT OF ORDER");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5764:
	asi64(R1) = sw;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5767;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5766;
L5767:
	R1 = 1;
	cc_decls_pci_target = asu8(R1);
L5766:
	goto L5756;
L5758:
	asi64(R1) = sw;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L5769;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5770;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5770;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5771;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5772;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5773;
	goto L5774;
L5769:
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L5776;
	R1 = tou64("");
	R2 = tou64("Too many include paths");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5776:
	asu64(R1) = value;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = value;
	asi64(R2) = length;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L5778;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L5778;
	goto L5779;
L5778:
	goto L5777;
L5779:
	asu64(R1) = value;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	value = asu64(R1);
L5777:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_includepaths;
	R3 = (u64)&cc_decls_nincludepaths;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L5768;
L5770:
	cc_cli_showhelp();
	goto L5768;
L5771:
	asu64(R1) = cc_cli_outext;
	asu64(R2) = value;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_cli_outfile = asu64(R1);
	goto L5768;
L5772:
	R1 = 0;
	R2 = R1;
	pc_decls_fpeephole = asu8(R2);
	pc_decls_fregoptim = asu8(R1);
	goto L5768;
L5773:
	R1 = 1;
	i = asi64(R1);
	R1 = 53;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5782;
L5780:
	msysc_m$print_startcon();
	R1 = tou64("   ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_cli_optionnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= av_1) goto L5780;
L5782:
	goto L5768;
L5774:
L5768:
L5756:
	return;
}

static void cc_cli_showincludepaths() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Include paths");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nincludepaths;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5786;
L5784:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nincludepaths) goto L5784;
L5786:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showhelp() {
    u64 R1; 
	cc_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("C Subset Compiler for 64-bit Windows\n\nNormal use:           Compiles prog.c to:\n\n    cc      prog      prog.exe (default)\n    cc -r   prog      in-memory native code then execute\n    cc -i   prog      in-memory IL then interpret\n\n    cc -exe prog      prog.exe\n    cc -dll prog      prog.dll\n    cc -obj prog      prog.obj\n    cc -s   prog      prog.asm (also -a)\n    cc -mx  prog      prog.mx\n    cc -p   prog      prog.pcl (textual IL)\n    cc -e   prog      prog.i   (preprocess only)\n\nOther options:\n\n    -incl:path        Add path to search for includes\n    -ext              Used std headers external to compiler\n    -opt              Optimise native code\n    -o:file           Name output file (extension can be added)\n    -norip            Don't use RIP address modes\n    -himem            Generate PIC code (automatic with -obj/-dll)\n    @file             Read files and options from a file\n    -c                Same as -obj\n    -s                Same as -asm\n    -ei               Same as -e, but when result is interpreted\n\nNotes:\n\n    * Compiles single module only\n    * For -i and -r, options\n    * .c extension is optional on input file\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 23;
	exit(R1);
	return;
}

static void cc_cli_showextrainfo() {
    u64 R1; 
// PROC LOCAL STATICS GO HERE
	static u64 cc_cli_showextrainfo_infotext = (u64)"    The 'MCC' C Compiler comprises:\n\n    mcc.exe            Compiles to .asm files\n    aa.exe             Assembles .asm files to .obj files\n                       Assemblers and links .asm/.dll files to .exe\n    Standard headers   A minimal set inside mcc.exe\n    windows.h          As a standalone file\n\n    Input files:\n\n      prog             This is prog.c as the extension is optional\n      prog.c\n      lib.dll          Include .dll library when generating .exe\n      @file            Read parameters and optons from given file\n\n    Options:\n\n      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files\n      -e               Preprocess each module to .i file\n      -s               Compile each module to .asm file\n      -c               Compile each module .obj via .asm\n\n      -out:file        Specify output file for -exe only\n\n    For .exe output, it will be named based on the first input file. Otherwise\n    use -out option\n\n    .obj files can be linked using gcc on Windows. This option is\n    needed to be able to generate .dll files. However, this will not\n    work on newer gcc versions because mcc's generated code is not position\n    independent, and will only work loaded in the low 2GB of address space.\n\n    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are\n    automatically included as search libraries for imported functions.\n\n    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported.\n\n    Omissions, Restrictions and Bugs (highlights only as there are dozens):\n\n      * No VLAs, compound literals, designated initialisers\n      * Restrictions on complexity of data initialisers\n";
	msysc_m$print_startcon();
	asu64(R1) = cc_cli_showextrainfo_infotext;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 24;
	exit(R1);
	return;
}

static void cc_cli_showcaption() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("CC C Compiler 7.x");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_starttiming() {
    u64 R1; 
	asi64(R1) = mlinux_os_clock();
	cc_cli_ttt = asi64(R1);
	return;
}

static i64 cc_cli_gettiming() {
    u64 R1, R2; 
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = cc_cli_ttt;
	asi64(R1) -= asi64(R2);
	goto L5791;
L5791:
	return asi64(R1);
}

static void cc_lex_lex_preprocess_only(u64 infile, u64 outfile, i64 toconsole) {
    u64 R1, R2, R3; 
	u64 psource;
	i64 ntokens;
	i64 nlines;
	i64 fileno;
	i64 size;
	i64 length;
	i64 nchars;
	i64 t;
	i64 hashtot;
	i64 symtot;
	r64 tsecs;
	u64 f;
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_lex_preprocess_only_dest = (u64)&cc_lex_lex_preprocess_only_sbuffer;
	R1 = 1;
	cc_lex_dowhitespace = asi64(R1);
	asu64(R1) = infile;
	asu64(R2) = infile;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	fileno = asi64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	psource = asu64(R1);
	R1 = (u64)&cc_decls_sourcefilesizes;
	asi64(R2) = fileno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	R1 = 0;
	R2 = R1;
	ntokens = asi64(R2);
	nlines = asi64(R1);
	R1 = 0;
	R2 = R1;
	symtot = asi64(R2);
	hashtot = asi64(R1);
	asi64(R1) = mlinux_os_clock();
	t = asi64(R1);
	asu64(R1) = cc_lex_lex_preprocess_only_dest;
	cc_lex_destcopy = asu64(R1);
	asu64(R1) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = psource;
	cc_lex_lxsptr = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	cc_lex_lxstart = asu64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	cc_lex_setfileno(asi64(R1));
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 1;
	R2 = tou64("mcc.h");
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5793:
	cc_lex_lexm();
	R1 = (u64)&ntokens;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	R3 = (u64)&cc_decls_nextlx;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L5793;
	asi64(R1) = cc_lex_ifcondlevel;
	if (!asi64(R1)) goto L5797;
	R1 = tou64("#endif missing");
	cc_lex_lxerror(asu64(R1));
L5797:
	R1 = (u64)&cc_lex_showtokens;
	if (!asu64(R1)) goto L5799;
	asi64(R1) = toconsole;
	if (!asi64(R1)) goto L5801;
	R1 = 0;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	goto L5800;
L5801:
	R1 = tou64("wb");
	asu64(R2) = outfile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L5800:
L5799:
	return;
}

static void cc_lex_lexreadtoken() {
    u64 R1, R2, R3, R4, R5; 
	u64 c;
	u64 csum;
	u64 hsum;
	u64 dodir;
	u64 p;
	u64 ss;
	u64 searchstr;
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5804;
L5803:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L5804:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L5803;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5803;
L5806:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L5943;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 96: case 127: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: goto L5809;
	case 9: case 32: goto L5928;
	case 10: goto L5929;
	case 12: goto L5947;
	case 13: goto L5937;
	case 33: goto L5938;
	case 34: goto L5927;
	case 35: goto L5836;
	case 36: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L5810;
	case 37: goto L5900;
	case 38: goto L5921;
	case 39: goto L5926;
	case 40: goto L5866;
	case 41: goto L5867;
	case 42: goto L5891;
	case 43: goto L5880;
	case 44: goto L5860;
	case 45: goto L5885;
	case 46: goto L5852;
	case 47: goto L5894;
	case 48: goto L5827;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5823;
	case 58: goto L5862;
	case 59: goto L5861;
	case 60: goto L5907;
	case 61: goto L5903;
	case 62: goto L5914;
	case 63: goto L5878;
	case 64: goto L5942;
	case 91: goto L5868;
	case 92: goto L5840;
	case 93: goto L5869;
	case 94: goto L5875;
	case 123: goto L5850;
	case 124: goto L5870;
	case 125: goto L5851;
	case 126: goto L5879;
	case 239: goto L5948;
	default: goto L5809;
    };
// SWITCH
L5810:
// cc_lex.lexreadtoken.doname:
L5811:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_lxsvalue = asu64(R1);
	asu64(R1) = cc_lex_lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	hsum = asu64(R1);
	goto L5813;
L5812:
	asu64(R1) = hsum;
	R2 = 4;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	asu64(R2) = c;
	asu64(R1) += asu64(R2);
	hsum = asu64(R1);
L5813:
	R1 = (u64)&cc_lex_alphamap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = R2;
	c = asu64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5812;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = c;
	R2 = 39;
	if (asu64(R1) == asu64(R2)) goto L5816;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L5816;
	goto L5817;
L5816:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5819;
	asu64(R1) = cc_lex_lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L5821;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L5821;
	R2 = 117;
	if (asu64(R1) == asu64(R2)) goto L5821;
	R2 = 85;
	if (asu64(R1) == asu64(R2)) goto L5821;
	goto L5822;
L5821:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	asu64(R2) = c;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L5802;
	goto L5820;
L5822:
L5820:
L5819:
	goto L5815;
L5817:
L5815:
	asu64(R1) = hsum;
	R2 = 5;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	cc_lex_lxhashvalue = asi64(R1);
	asi64(R1) = cc_lex_lookup();
	goto L5802;
	goto L5806;
L5823:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5825;
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L5825;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L5825;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L5825;
	R2 = 59;
	if (asu64(R1) == asu64(R2)) goto L5825;
	goto L5826;
L5825:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	goto L5824;
L5826:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readdecimal(asu64(R1));
L5824:
	goto L5802;
	goto L5806;
L5827:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 10: case 13: case 32: case 38: case 41: case 44: case 58: case 59: case 61: case 63: case 93: case 125: goto L5835;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 33: case 34: case 35: case 36: case 37: case 39: case 40: case 42: case 43: case 45: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 60: case 62: case 64: case 65: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 89: case 90: case 91: case 92: case 94: case 95: case 96: case 97: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 118: case 119: case 121: case 122: case 123: case 124: goto L5830;
	case 46: goto L5833;
	case 66: case 98: goto L5832;
	case 76: case 85: case 108: case 117: goto L5834;
	case 88: case 120: goto L5831;
	default: goto L5830;
    };
// SWITCH
L5831:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	cc_lex_readhex(asu64(R1));
	goto L5802;
	goto L5828;
L5832:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	cc_lex_readbinary(asu64(R1));
	goto L5802;
	goto L5828;
L5833:
	R1 = 10;
	R2 = 1;
	asu64(R3) = cc_lex_lxsptr;
	R4 = 1;
	R3 -= (i64)R4;
	asu64(R4) = cc_lex_lxsptr;
	R5 = 1;
	R4 -= (i64)R5;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5802;
	goto L5828;
L5834:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readdecimal(asu64(R1));
	goto L5802;
	goto L5828;
L5835:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	goto L5802;
	goto L5828;
L5830:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readoctal(asu64(R1));
	goto L5802;
L5828:
	goto L5806;
L5836:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L5838;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5837;
L5838:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) != asu64(R2)) goto L5839;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 7;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5837;
L5839:
	R1 = 5;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
L5837:
	goto L5806;
L5840:
L5841:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L5843;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L5843;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5844;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L5844;
	goto L5845;
L5843:
	goto L5842;
	goto L5841;
L5844:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5841;
L5845:
	R1 = 22;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5841;
L5842:
	R1 = 32;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L5847;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L5848;
	goto L5849;
L5847:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 32;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L5846;
L5848:
	R1 = 32;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L5846;
L5849:
L5846:
	goto L5806;
L5850:
	R1 = 17;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5851:
	R1 = 18;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5852:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 46: goto L5856;
	case 47: goto L5855;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5859;
	default: goto L5855;
    };
// SWITCH
L5856:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L5858;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 21;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5857;
L5858:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
L5857:
	goto L5802;
	goto L5853;
L5859:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	R2 = 0;
	asu64(R3) = cc_lex_lxsptr;
	asu64(R4) = cc_lex_lxsptr;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5802;
	goto L5853;
L5855:
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
L5853:
	goto L5806;
L5860:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5861:
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5862:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5864;
	goto L5865;
L5864:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5863;
L5865:
	R1 = 10;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5863:
	goto L5802;
	goto L5806;
L5866:
	R1 = 13;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5867:
	R1 = 14;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5868:
	R1 = 15;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5869:
	R1 = 16;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5870:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 124;
	if (asu64(R1) == asu64(R2)) goto L5872;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5873;
	goto L5874;
L5872:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 31;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5871;
L5873:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 51;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5871;
L5874:
	R1 = 28;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5871:
	goto L5802;
	goto L5806;
L5875:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5877;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 53;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5876;
L5877:
	R1 = 30;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5876:
	goto L5802;
	goto L5806;
L5878:
	R1 = 19;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5879:
	R1 = 35;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5880:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L5882;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5883;
	goto L5884;
L5882:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 37;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5881;
L5883:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 46;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5881;
L5884:
	R1 = 23;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5881:
	goto L5802;
	goto L5806;
L5885:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L5887;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L5888;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5889;
	goto L5890;
L5887:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 38;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5886;
L5888:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5886;
L5889:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 47;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5886;
L5890:
	R1 = 24;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5886:
	goto L5802;
	goto L5806;
L5891:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5893;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 48;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5892;
L5893:
	R1 = 25;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5892:
	goto L5802;
	goto L5806;
L5894:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L5896;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L5897;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5898;
	goto L5899;
L5896:
	cc_lex_readlinecomment();
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5802;
	goto L5895;
L5897:
	cc_lex_readblockcomment();
	goto L5895;
L5898:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 49;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5895;
L5899:
	R1 = 26;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
L5895:
	goto L5806;
L5900:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5902;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 50;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5901;
L5902:
	R1 = 27;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5901:
	goto L5802;
	goto L5806;
L5903:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5905;
	goto L5906;
L5905:
	R1 = 40;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5904;
L5906:
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5904:
	goto L5802;
	goto L5806;
L5907:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5909;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L5910;
	goto L5911;
L5909:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 43;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5908;
L5910:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5913;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 54;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5912;
L5913:
	R1 = 33;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5912:
	goto L5908;
L5911:
	R1 = 42;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5908:
	goto L5802;
	goto L5806;
L5914:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5916;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L5917;
	goto L5918;
L5916:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 44;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5915;
L5917:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5920;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 55;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5919;
L5920:
	R1 = 34;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5919:
	goto L5915;
L5918:
	R1 = 45;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5915:
	goto L5802;
	goto L5806;
L5921:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L5923;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5924;
	goto L5925;
L5923:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 32;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5922;
L5924:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 52;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5922;
L5925:
	R1 = 29;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5922:
	goto L5802;
	goto L5806;
L5926:
	R1 = 0;
	R2 = 39;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L5802;
	goto L5806;
L5927:
	R1 = 0;
	R2 = 34;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L5802;
	goto L5806;
L5928:
	goto L5806;
L5929:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_dowhitespace;
	if (!asi64(R1)) goto L5931;
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5932:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 9: case 32: goto L5936;
	case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: goto L5935;
	default: goto L5935;
    };
// SWITCH
L5936:
	goto L5932;
L5935:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5933;
	goto L5932;
L5933:
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5931:
	goto L5802;
	goto L5806;
L5937:
	goto L5806;
L5938:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5940;
	goto L5941;
L5940:
	R1 = 41;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5939;
L5941:
	R1 = 36;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5939:
	goto L5802;
	goto L5806;
L5942:
	msysc_m$print_startcon();
	R1 = tou64("@ SEEN");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_lex_lx_stackindex;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5806;
L5943:
// cc_lex.lexreadtoken.doeof:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = cc_lex_lx_stackindex;
	if (!asi64(R1)) goto L5946;
	cc_lex_unstacksourcefile();
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5945;
L5946:
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5945:
	goto L5802;
	goto L5806;
L5947:
	goto L5806;
L5948:
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	goto L5806;
L5809:
	R1 = 128;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L5950;
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L5950;
	goto L5811;
L5950:
	msysc_m$print_startcon();
	R1 = tou64("ERROR CHAR");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = cc_lex_lx_stackindex;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("ERROR CHAR");
	cc_lex_lxerror(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5802;
	goto L5806;
L5802:
	return;
}

static void cc_lex_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base) {
    u64 R1, R2, R3, R4; 
	u64 fractstart;
	i64 fractlen;
	i64 expon;
	i64 i;
	i64 c;
	i64 badexpon;
	i64 n;
	i64 adj;
	r64 basex;
	r64 x;
	r64 expbase;
	r64 f;
	r64 y;
	r64 y2;
	r64 g;
	i64 aa;
	i64 cc;
	i64 pref;
	struct $B20 realstr;
	u64 rs;
	struct $B17 expstr;
	u64 xx1;
	u64 xx2;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5953;
	asi64(R1) = base;
	asi64(R2) = intlen;
	asu64(R3) = intstart;
	asu64(R4) = pstart;
	cc_lex_old_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5951;
L5953:
	R1 = 0;
	fractstart = asu64(R1);
	R1 = 0;
	fractlen = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L5955;
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	fractstart = asu64(R1);
	asi64(R1) = base;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = fractstart;
	asi64(R1) -= asi64(R2);
	fractlen = asi64(R1);
L5955:
	R1 = 0;
	badexpon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 101;
	if (asu64(R1) == asu64(R2)) goto L5957;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L5957;
	R2 = 112;
	if (asu64(R1) == asu64(R2)) goto L5958;
	R2 = 80;
	if (asu64(R1) == asu64(R2)) goto L5958;
	goto L5959;
L5957:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5961;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L5961:
	goto L5956;
L5958:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L5963;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L5963:
	goto L5956;
L5959:
L5956:
	asi64(R1) = badexpon;
	if (!asi64(R1)) goto L5965;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L5951;
L5965:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 102;
	if (asu64(R1) == asu64(R2)) goto L5967;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L5967;
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L5967;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L5967;
	goto L5968;
L5967:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5966;
L5968:
	R1 = (u64)&cc_lex_alphamap;
	asu64(R2) = cc_lex_lxsptr;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5970;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L5951;
L5970:
L5966:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L5972;
	R1 = 48;
	R2 = (u64)&realstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 120;
	R2 = (u64)&realstr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&realstr;
	R2 = 2;
	R1 += (i64)R2;
	rs = asu64(R1);
	R1 = 2;
	pref = asi64(R1);
	goto L5971;
L5972:
	R1 = (u64)&realstr;
	R2 = 0;
	R1 += (i64)R2;
	rs = asu64(R1);
	R1 = 0;
	pref = asi64(R1);
L5971:
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L5974;
	R1 = tou64("Real too long");
	cc_lex_lxerror(asu64(R1));
L5974:
	asi64(R1) = intlen;
	if (!asi64(R1)) goto L5976;
	asi64(R1) = intlen;
	asu64(R2) = intstart;
	asu64(R3) = rs;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5976:
	asi64(R1) = fractlen;
	if (!asi64(R1)) goto L5978;
	asi64(R1) = fractlen;
	asu64(R2) = fractstart;
	asu64(R3) = rs;
	asi64(R4) = intlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5978:
	asi64(R1) = base;
	asr64(R1) = tor64(asi64(R1));
	R2 = R1;
	basex = asr64(R2);
	expbase = asr64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5980;
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	goto L5979;
L5980:
	asi64(R1) = fractlen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 2.000000000000000000e+000;
	expbase = asr64(R1);
L5979:
	R1 = 0;
	R2 = (u64)&realstr;
	asi64(R3) = pref;
	asi64(R4) = intlen;
	asi64(R3) += asi64(R4);
	asi64(R4) = fractlen;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&expstr;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5982;
	R1 = tou64("e");
	goto L5981;
L5982:
	R1 = tou64("p");
L5981:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = expon;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&expstr;
	R2 = (u64)&realstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5984;
	R1 = tou64("Non-base-10 floats temporarily unavailable");
	cc_lex_lxerror(asu64(R1));
L5984:
	R1 = 0;
	R2 = (u64)&realstr;
	asr64(R1) = strtod(asu64(R2), asu64(R1));
	x = asr64(R1);
	R1 = 60;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = intstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = intstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5951:
	return;
}

static i64 cc_lex_readexponent(u64 badexpon) {
    u64 R1, R2; 
	u64 numstart;
	i64 length;
	i64 neg;
	i64 c;
	i64 a;
	i64 av_1;
	R1 = 0;
	neg = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L5987;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L5988;
	goto L5989;
L5987:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5986;
L5988:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	neg = asi64(R1);
	goto L5986;
L5989:
L5986:
	asu64(R1) = cc_lex_lxsptr;
	numstart = asu64(R1);
	R1 = 10;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = numstart;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5991;
	R1 = 1;
	asu64(R2) = badexpon;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	goto L5985;
L5991:
	R1 = 0;
	a = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5994;
L5992:
	R1 = (u64)&numstart;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	if (--asi64(av_1)) goto L5992;
L5994:
	asi64(R1) = neg;
	if (!asi64(R1)) goto L5996;
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	goto L5995;
L5996:
	asi64(R1) = a;
L5995:
	goto L5985;
L5985:
	return asi64(R1);
}

static void cc_lex_lxerror(u64 mess) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("\nLex error");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = cc_lex_getfileno();
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 11;
	exit(R1);
	return;
}

static void cc_lex_printsymbol(u64 lp) {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	struct $B17 l;
	asu64(R1) = lp;
	(R1_B17) = *(struct $B17*)(R1);
	l = (R1_B17);
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("%-18s");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = (u64)&l;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6000;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6001;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6002;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6003;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6004;
	goto L6005;
L6000:
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 106;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	goto L5999;
L6001:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = lp;
	cc_lex_shownumberstr(asu64(R2), asu64(R1));
	goto L5999;
L6002:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = lp;
	cc_lex_shownumberstr(asu64(R2), asu64(R1));
	goto L5999;
L6003:
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L5999;
L6004:
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L5999;
L6005:
	R1 = (u64)&l;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6007;
	msysc_m$print_startcon();
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&l;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6007:
L5999:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_lex_lexsetup() {
    u64 R1, R2, R3; 
	i64 i;
	cc_lex_inithashtable();
	cc_lex_fillhashtable();
	R1 = 0;
	i = asi64(R1);
L6009:
	asi64(R1) = i;
	switch (asi64(R1)) {
	case 36: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: case 239: case 240: case 241: case 242: case 243: case 244: case 245: case 246: case 247: case 248: case 249: case 250: case 251: case 252: case 253: case 254: case 255: goto L6015;
	case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 91: case 92: case 93: case 94: case 96: case 123: case 124: case 125: case 126: case 127: goto L6014;
	default: goto L6014;
    };
// SWITCH
L6015:
	R1 = 1;
	R2 = (u64)&cc_lex_alphamap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6012;
L6014:
L6012:
	asi64(R1) = i;
	switch (asi64(R1)) {
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L6019;
	default: goto L6018;
    };
// SWITCH
L6019:
	R1 = 1;
	R2 = (u64)&cc_lex_digitmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6016;
L6018:
L6016:
	R1 = 1;
	R2 = (u64)&cc_lex_commentmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_linecommentmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_spacemap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 255) goto L6009;
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 42;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_spacemap;
	R3 = 32;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_spacemap;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 56;
	R2 = (u64)&cc_lex_normaltkx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	cc_lex_npastedtokens = asi64(R1);
	return;
}

static void cc_lex_printstrn(u64 s, i64 length, u64 f) {
    u64 R1, R2; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L6022;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6024;
	msysc_m$print_startcon();
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	goto L6023;
L6024:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
L6023:
L6022:
	return;
}

static u64 cc_lex_scannumber(i64 base) {
    u64 R1, R2, R3; 
	u64 dest;
	i64 c;
	asu64(R1) = cc_lex_lxsptr;
	dest = asu64(R1);
L6026:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 39: case 95: case 96: goto L6036;
	case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: goto L6029;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L6030;
	case 65: case 66: case 67: case 68: case 69: case 70: case 97: case 98: case 99: case 100: case 101: case 102: goto L6033;
	default: goto L6029;
    };
// SWITCH
L6030:
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 48;
	asi64(R3) = base;
	asi64(R2) += asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L6032;
	R1 = tou64("Digit out of range");
	cc_lex_lxerror(asu64(R1));
L6032:
	goto L6026;
L6033:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6035;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6034;
L6035:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6027;
L6034:
	goto L6026;
L6036:
	goto L6026;
L6029:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6027;
	goto L6026;
L6027:
	asu64(R1) = dest;
	goto L6025;
L6025:
	return asu64(R1);
}

static i64 cc_lex_lookup() {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 length;
// cc_lex.lookup.retry:
L6038:
	asi64(R1) = cc_lex_lxhashvalue;
	asi64(R2) = cc_decls_hstmask;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L6039:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	length = asi64(R1);
	asi64(R1) = length;
	if (asi64(R1)) goto L6042;
	goto L6040;
L6042:
	asi64(R1) = length;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L6044;
	asi64(R1) = length;
	asu64(R2) = cc_lex_lxsvalue;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6046;
	R1 = 1;
	goto L6037;
L6046:
L6044:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = cc_decls_hstsize;
	if (asi64(R1) < asi64(R2)) goto L6048;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L6050;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L6050:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L6048:
	goto L6039;
L6040:
	asi64(R1) = cc_lex_nhstsymbols;
	asi64(R2) = cc_lex_hstthreshold;
	if (asi64(R1) < asi64(R2)) goto L6052;
	cc_lex_newhashtable();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	goto L6038;
L6052:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 106;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_nhstsymbols;
	(*toi64p(R1)) += 1;
	R1 = 0;
	goto L6037;
L6037:
	return asi64(R1);
}

static u64 cc_lex_gethashvalue(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 c;
	u64 hsum;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L6055;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L6055:
	R1 = 0;
	hsum = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6058;
L6056:
	asu64(R1) = hsum;
	R2 = 4;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asu64(R1) += asu64(R2);
	hsum = asu64(R1);
	if (--asi64(av_1)) goto L6056;
L6058:
	asu64(R1) = hsum;
	R2 = 5;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	goto L6053;
L6053:
	return asu64(R1);
}

static void cc_lex_inithashtable() {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = cc_decls_hstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_decls_hashtable = asu64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cc_decls_hstmask = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6062;
L6060:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= cc_decls_hstmask) goto L6060;
L6062:
	R1 = 0;
	cc_lex_nhstsymbols = asi64(R1);
	R1 = 6;
	asi64(R2) = cc_decls_hstsize;
	asi64(R1) *= asi64(R2);
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	cc_lex_hstthreshold = asi64(R1);
	return;
}

static void cc_lex_fillhashtable() {
    u64 R1, R2, R3; 
	i64 i;
	i64 av_1;
	R1 = 1;
	i = asi64(R1);
	R1 = 66;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6066;
L6064:
	R1 = (u64)&cc_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	cc_lex_lxsvalue = asu64(R1);
	R1 = (u64)&cc_tables_stsymbols;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L6068;
	asu64(R1) = cc_lex_lxsvalue;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_lex_lxsvalue = asu64(R1);
L6068:
	asu64(R1) = cc_lex_lxsvalue;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	asi64(R1) = cc_lex_lookup();
	if (!asi64(R1)) goto L6070;
	msysc_m$print_startcon();
	R1 = (u64)&cc_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Duplicate symbol table entry");
	mlib_abortprogram(asu64(R1));
L6070:
	R1 = (u64)&cc_tables_stsymbols;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_tables_stsubcodes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 100;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	i += 1; if (i <= av_1) goto L6064;
L6066:
	return;
}

static i64 cc_lex_dolexdirective() {
    u64 R1, R2, R3; 
	u64 symptr;
	u64 d;
	u64 p;
	u64 pstart;
	u64 s;
	i64 i;
	i64 cond;
	i64 c;
	i64 syshdr;
	i64 dir;
	i64 length;
	i64 allowmacros;
	struct $B15 filename;
	asu64(R1) = cc_lex_lxsptr;
	pstart = asu64(R1);
	asi64(R1) = cc_lex_getlexdirective();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6073;
	R1 = 0;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = pstart;
	asi64(R2) -= asi64(R3);
	asu64(R3) = pstart;
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Invalid # directive");
	cc_lex_lxerror(asu64(R1));
L6073:
	asi64(R1) = dir;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6075;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6076;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6077;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6078;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6079;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6080;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6081;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6081;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6082;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6083;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6084;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6085;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6086;
	goto L6087;
L6075:
	R1 = 1;
	cc_lex_isincludefile = asi64(R1);
	goto L6089;
L6088:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L6089:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6088;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6088;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 60;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	allowmacros = asi64(R1);
	cc_lex_lexm();
	R1 = 0;
	cc_lex_isincludefile = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L6092;
	R1 = 1;
	syshdr = asi64(R1);
	R1 = (u64)&filename;
	p = asu64(R1);
	asi64(R1) = allowmacros;
	if (!asi64(R1)) goto L6094;
L6095:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6098;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6098;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6099;
	goto L6100;
L6098:
	R1 = tou64("Bad include file");
	cc_lex_lxerror(asu64(R1));
	goto L6097;
L6099:
	goto L6096;
	goto L6097;
L6100:
	R1 = (u64)&length;
	R2 = (u64)&cc_decls_nextlx;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
L6097:
	goto L6095;
L6096:
	goto L6093;
L6094:
L6101:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6104;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6105;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6105;
	goto L6106;
L6104:
	goto L6102;
	goto L6103;
L6105:
	R1 = tou64("include: > expected");
	cc_lex_lxerror(asu64(R1));
	goto L6103;
L6106:
	asi64(R1) = c;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6103:
	goto L6101;
L6102:
L6093:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L6091;
L6092:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L6107;
	R1 = 0;
	syshdr = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6091;
L6107:
	R1 = tou64("include?");
	cc_lex_lxerror(asu64(R1));
L6091:
	cc_lex_lexm();
	asu8(R1) = cc_cli_fshowincludes;
	if (!asu8(R1)) goto L6109;
	msysc_m$print_startcon();
	R1 = tou64("INCLUDE");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("FROM");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = cc_lex_getfileno();
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("NSOURCEFILES=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6109:
	R1 = (u64)&cc_lex_nincludes;
	(*toi64p(R1)) += 1;
	asi64(R1) = syshdr;
	R2 = (u64)&filename;
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	goto L6074;
L6076:
	cc_lex_dodefine();
	goto L6074;
L6077:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6111;
	R1 = tou64("undef: name expected");
	cc_lex_lxerror(asu64(R1));
L6111:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6113;
	goto L6112;
L6113:
	R1 = 0;
	asu64(R2) = d;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L6112:
	goto L6074;
L6078:
	asi64(R1) = cc_lex_getifdef();
	cond = asi64(R1);
	goto L6114;
	goto L6074;
L6079:
	asi64(R1) = cc_lex_getifdef();
	asi64(R1) = !asi64(R1);
	cond = asi64(R1);
	goto L6114;
	goto L6074;
L6080:
	asi64(R1) = cc_lex_getifexpr();
	cond = asi64(R1);
// cc_lex.dolexdirective.doif:
L6114:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) += 1;
	asi64(R1) = cond;
	if (!asi64(R1)) goto L6116;
	R1 = 0;
	goto L6071;
	goto L6115;
L6116:
// cc_lex.dolexdirective.doskipcode:
L6117:
	asi64(R1) = cc_lex_skipcode();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6119;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6120;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6121;
	goto L6122;
L6119:
	asi64(R1) = cc_lex_getifexpr();
	cond = asi64(R1);
	asi64(R1) = cond;
	if (!asi64(R1)) goto L6124;
	R1 = 0;
	goto L6071;
L6124:
	goto L6117;
	goto L6118;
L6120:
	goto L6118;
L6121:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L6118;
L6122:
L6118:
L6115:
	goto L6074;
L6081:
	asi64(R1) = cc_lex_ifcondlevel;
	if (asi64(R1)) goto L6126;
	R1 = tou64("#if missing/elif/else");
	cc_lex_lxerror(asu64(R1));
L6126:
L6127:
	asi64(R1) = cc_lex_skipcode();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6127;
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L6074;
L6082:
	asi64(R1) = cc_lex_ifcondlevel;
	if (asi64(R1)) goto L6131;
	R1 = tou64("#if missing/endif");
	cc_lex_lxerror(asu64(R1));
L6131:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L6074;
L6083:
	goto L6074;
L6084:
L6132:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L6132;
	goto L6074;
L6085:
	cc_lex_lexm();
	msysc_m$print_startcon();
	R1 = tou64("#ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_showtoken(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("ABORTING");
	cc_lex_lxerror(asu64(R1));
	goto L6074;
L6086:
	cc_lex_dopragmadir();
	goto L6074;
L6087:
// cc_lex.dolexdirective.skip:
	msysc_m$print_startcon();
	R1 = tou64("DIRECTIVE NOT IMPL:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_sourcedirnames;
	asi64(R2) = dir;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pstart;
	cc_lex_lxsptr = asu64(R1);
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	goto L6071;
	R1 = tou64("Directive not implemented");
	cc_lex_lxerror(asu64(R1));
L6074:
	R1 = 0;
	goto L6071;
L6071:
	return asi64(R1);
}

static i64 cc_lex_getlexdirective() {
    u64 R1, R2; 
	u64 d;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6138;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6139;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6140;
	goto L6141;
L6138:
	goto L6137;
L6139:
	R1 = 13;
	goto L6136;
	goto L6137;
L6140:
L6142:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6145;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L6142;
L6145:
	R1 = 13;
	goto L6136;
	goto L6137;
L6141:
	R1 = 0;
	goto L6136;
L6137:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L6147;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L6148;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L6149;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6150;
	goto L6151;
L6147:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L6136;
	goto L6146;
L6148:
	R1 = 3;
	goto L6136;
	goto L6146;
L6149:
	R1 = 5;
	goto L6136;
	goto L6146;
L6150:
	R1 = 13;
	goto L6136;
	goto L6146;
L6151:
L6146:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6153;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L6155;
	asu64(R1) = d;
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L6136;
L6155:
L6153:
	R1 = 0;
	goto L6136;
L6136:
	return asi64(R1);
}

static void cc_lex_startlex(u64 caption, i64 fileno) {
    u64 R1, R2, R3; 
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	R1 = (u64)&cc_lex_normaltkx;
	cc_lex_normaltk = asu64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 1;
	cc_lex_firstsymbol = asi64(R1);
	R1 = 0;
	cc_lex_npastedtokens = asi64(R1);
	R1 = 0;
	cc_lex_isincludefile = asi64(R1);
	R1 = 0;
	cc_lex_tkptr = asu64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	cc_lex_lxsptr = asu64(R2);
	cc_lex_lxstart = asu64(R1);
	asi64(R1) = fileno;
	cc_lex_setfileno(asi64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	return;
}

static void cc_lex_endlex() {
    u64 R1; 
	asi64(R1) = cc_lex_ifcondlevel;
	if (!asi64(R1)) goto L6159;
	msysc_m$print_startcon();
	asi64(R1) = cc_lex_ifcondlevel;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("#endif missing");
	cc_lex_lxerror(asu64(R1));
L6159:
	return;
}

static void cc_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":::");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	cc_lex_printsymbol(asu64(R1));
	return;
}

static void cc_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":##");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_printsymbol(asu64(R1));
	return;
}

static i64 cc_lex_gethashtablesize() {
    u64 R1, R2; 
	i64 i;
	i64 n;
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6165;
L6163:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6167;
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L6167:
	i += 1; if (i <= cc_decls_hstmask) goto L6163;
L6165:
	asi64(R1) = n;
	goto L6162;
L6162:
	return asi64(R1);
}

static void cc_lex_readlinecomment() {
    u64 R1, R2; 
L6169:
	goto L6172;
L6171:
L6172:
	R1 = (u64)&cc_lex_linecommentmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6171;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6175;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L6176;
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L6177;
	goto L6178;
L6175:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6170;
	goto L6174;
L6176:
	goto L6170;
	goto L6174;
L6177:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L6180;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6181;
	goto L6182;
L6180:
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L6179;
L6181:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L6179;
L6182:
L6179:
	goto L6174;
L6178:
L6174:
	goto L6169;
L6170:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	return;
}

static void cc_lex_readblockcomment() {
    u64 R1, R2; 
L6184:
	goto L6187;
L6186:
L6187:
	R1 = (u64)&cc_lex_commentmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6186;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6190;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L6191;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L6192;
	goto L6193;
L6190:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L6189;
L6191:
	R1 = tou64("block comment eof");
	cc_lex_lxerror(asu64(R1));
	goto L6189;
L6192:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) != asu64(R2)) goto L6195;
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	goto L6185;
L6195:
	goto L6189;
L6193:
L6189:
	goto L6184;
L6185:
	return;
}

static void cc_lex_readhex(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	u64 c;
	i64 length;
	i64 leading;
	i64 ll;
	i64 usigned;
	u64 p;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asi64(R2);
	ll = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L6197:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = R1;
	c = asu64(R2);
	switch (asi64(R1)) {
	case 46: case 80: case 112: goto L6207;
	case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 113: case 114: case 115: case 116: goto L6200;
	case 48: goto L6202;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L6201;
	case 65: case 66: case 67: case 68: case 69: case 70: goto L6205;
	case 76: case 108: goto L6208;
	case 85: case 117: goto L6211;
	case 97: case 98: case 99: case 100: case 101: case 102: goto L6206;
	default: goto L6200;
    };
// SWITCH
L6201:
	R1 = 0;
	leading = asi64(R1);
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L6197;
L6202:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L6204;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L6203;
L6204:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asu64(R1) *= asu64(R2);
	aa = asu64(R1);
L6203:
	goto L6197;
L6205:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 65;
	asi64(R2) -= asi64(R3);
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	goto L6197;
L6206:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 97;
	asi64(R2) -= asi64(R3);
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	goto L6197;
L6207:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 16;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6196;
	goto L6197;
L6208:
	R1 = (u64)&ll;
	(*toi64p(R1)) += 1;
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L6210;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L6210:
	goto L6197;
L6211:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L6213;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L6213:
	R1 = 1;
	usigned = asi64(R1);
	goto L6197;
L6200:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6198;
	goto L6197;
L6198:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L6215;
	R1 = tou64("Overflow in hex number");
	cc_lex_lxerror(asu64(R1));
L6215:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 9223372036854775807;
	if (asu64(R1) <= asu64(R2)) goto L6217;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6216;
L6217:
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) <= asu64(R2)) goto L6218;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6216;
L6218:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) <= asu64(R2)) goto L6219;
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6216;
L6219:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6216:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6222;
	asi64(R1) = ll;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6221;
	asu8(R1) = pc_decls_flong64;
	if (!asu8(R1)) goto L6221;
L6222:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6224;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6225;
	goto L6226;
L6224:
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6223;
L6225:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6223;
L6226:
L6223:
L6221:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L6228;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6230;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6231;
	goto L6232;
L6230:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6229;
L6231:
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6229;
L6232:
L6229:
L6228:
	asi64(R1) = cc_lex_checknumbersuffix();
L6196:
	return;
}

static void cc_lex_readbinary(u64 pstart) {
    u64 R1, R2, R3; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
L6234:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: goto L6243;
	case 47: goto L6237;
	case 48: goto L6239;
	case 49: goto L6238;
	case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L6242;
	default: goto L6237;
    };
// SWITCH
L6238:
	R1 = 0;
	leading = asi64(R1);
	goto L6234;
L6239:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L6241;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L6241:
	goto L6234;
L6242:
	R1 = tou64("Binary bad digit");
	cc_lex_lxerror(asu64(R1));
	goto L6234;
L6243:
	R1 = tou64("Binary fp");
	cc_lex_lxerror(asu64(R1));
	goto L6234;
L6237:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6235;
	goto L6234;
L6235:
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L6245;
	R1 = tou64("Overflow in binary number");
	cc_lex_lxerror(asu64(R1));
L6245:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6248;
L6246:
	asu64(R1) = aa;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L6246;
L6248:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L6250;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6250:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
	return;
}

static void cc_lex_readoctal(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	i64 ll;
	i64 usigned;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asi64(R2);
	ll = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L6252:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: goto L6260;
	case 47: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L6255;
	case 48: goto L6257;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L6256;
	case 76: case 108: goto L6261;
	case 85: case 117: goto L6264;
	default: goto L6255;
    };
// SWITCH
L6256:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L6252;
L6257:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L6259;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L6258;
L6259:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L6258:
	goto L6252;
L6260:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6251;
	goto L6252;
L6261:
	R1 = (u64)&ll;
	(*toi64p(R1)) += 1;
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L6263;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L6263:
	goto L6252;
L6264:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L6266;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L6266:
	R1 = 1;
	usigned = asi64(R1);
	goto L6252;
L6255:
	R1 = (u64)&cc_lex_alphamap;
	asi64(R2) = c;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6268;
// cc_lex.readoctal.doalpha:
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L6251;
L6268:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6253;
	goto L6252;
L6253:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 22;
	if (asi64(R1) > asi64(R2)) goto L6272;
	asi64(R1) = length;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L6271;
	R1 = 22;
	R2 = tou64("1777777777777777777777");
	asu64(R3) = p;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6271;
L6272:
	R1 = tou64("Overflow in octal number");
	cc_lex_lxerror(asu64(R1));
L6271:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6275;
L6273:
	asu64(R1) = aa;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L6273;
L6275:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L6277;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6277:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
L6251:
	return;
}

static void cc_lex_readdecimal(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	u8 ll;
	u8 usigned;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asu8(R2);
	ll = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) -= 1;
	p = asu64(R1);
	goto L6280;
L6279:
L6280:
	R1 = (u64)&cc_lex_digitmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6279;
	goto L6283;
L6282:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L6283:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L6282;
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
L6285:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: case 69: case 101: goto L6289;
	case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L6288;
	case 76: case 108: goto L6290;
	case 85: case 117: goto L6293;
	default: goto L6288;
    };
// SWITCH
L6289:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6278;
	goto L6285;
L6290:
	R1 = (u64)&ll;
	(*tou8p(R1)) += 1;
	asu8(R1) = ll;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L6292;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L6292:
	goto L6285;
L6293:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L6295;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L6295:
	R1 = 1;
	usigned = asu8(R1);
	goto L6285;
L6288:
	R1 = (u64)&cc_lex_alphamap;
	asi64(R2) = c;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6297;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L6278;
L6297:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6286;
	goto L6285;
L6286:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L6300;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6299;
	R1 = 20;
	R2 = tou64("18446744073709551615");
	asu64(R3) = p;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6299;
L6300:
	R1 = tou64("Overflow in decimal number");
	cc_lex_lxerror(asu64(R1));
L6299:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6303;
L6301:
	asu64(R1) = aa;
	R2 = 10;
	asu64(R1) *= asu64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = 48;
	asu64(R2) -= asu64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L6301;
L6303:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu8(R1) = ll;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6305;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6306;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6307;
	goto L6308;
L6305:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asi64(R1) < asi64(R2)) goto L6310;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6309;
L6310:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6309:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L6312;
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) < asu64(R2)) goto L6314;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6313;
L6314:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6313:
	goto L6311;
L6312:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L6316;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6316:
L6311:
	goto L6304;
L6306:
	asu8(R1) = pc_decls_flong64;
	if (!asu8(R1)) goto L6318;
	goto L6307;
L6318:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L6320;
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) < asu64(R2)) goto L6322;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6321;
L6322:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6321:
	goto L6319;
L6320:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L6324;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6323;
L6324:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6323:
L6319:
	goto L6304;
L6307:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L6326;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6325;
L6326:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6325:
	goto L6304;
L6308:
L6304:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L6278:
	return;
}

static i64 cc_lex_checknumbersuffix() {
    u64 R1, R2; 
	u8 c;
L6328:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = R1;
	c = asu8(R2);
	switch (asi64(R1)) {
	case 76: case 85: case 108: case 117: goto L6332;
	case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L6331;
	default: goto L6331;
    };
// SWITCH
L6332:
	goto L6328;
L6331:
	R1 = (u64)&cc_lex_alphamap;
	asu8(R2) = c;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6334;
L6334:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6329;
	goto L6328;
L6329:
	R1 = 3;
	goto L6327;
L6327:
	return asi64(R1);
}

static void cc_lex_stacksourcefile(u64 file, i64 syshdr) {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	u64 sptr;
	i64 fileno;
	struct $B8 info;
	struct $B47 fullpath;
	asi64(R1) = syshdr;
	asu64(R2) = file;
	asi64(R1) = cc_lex_getsourcefile(asu64(R2), asi64(R1));
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6337;
	msysc_m$print_startcon();
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	asi64(R1) = strlen(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find include file");
	cc_lex_lxerror(asu64(R1));
L6337:
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L6339;
	R1 = tou64("Too many nested includes");
	cc_lex_lxerror(asu64(R1));
L6339:
	R1 = (u64)&cc_lex_lx_stackindex;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&fullpath;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6341;
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = cc_lex_lx_stackindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = (u64)&fullpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6341:
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L6343;
	R1 = (u64)&cc_lex_headerpath;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&fullpath;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6343:
	R1 = (u64)&fullpath;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_lex_headerpathlist;
	asi64(R3) = cc_lex_lx_stackindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = cc_lex_lxstart;
	R2 = (u64)&info;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&info;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&info;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_getfileno();
	R2 = (u64)&info;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	(R1_B8) = info;
	R2 = (u64)&cc_lex_lx_stack;
	asi64(R3) = cc_lex_lx_stackindex;
	*(struct $B8*)(((i64)R2+(i64)R3*24-24)) = (R1_B8);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	cc_lex_lxsptr = asu64(R2);
	cc_lex_lxstart = asu64(R1);
	asi64(R1) = fileno;
	cc_lex_setfileno(asi64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void cc_lex_unstacksourcefile() {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	u64 path;
	struct $B8 info;
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = cc_lex_lx_stackindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	path = asu64(R1);
	asu64(R1) = path;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = path;
	mlib_pcm_free(asu64(R2), asi64(R1));
	R1 = (u64)&cc_lex_lx_stack;
	R2 = (u64)&cc_lex_lx_stackindex;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	(R1_B8) = *(struct $B8*)(((i64)R1+(i64)R2*24-24));
	info = (R1_B8);
	R1 = (u64)&info;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_lxstart = asu64(R1);
	R1 = (u64)&info;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_lxsptr = asu64(R1);
	R1 = (u64)&info;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&info;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_lex_setfileno(asi64(R1));
	return;
}

static i64 cc_lex_getsourcefile(u64 file, i64 syshdr) {
    u64 R1, R2, R3; 
	struct $B15 filespec2;
	u64 hdrtext;
	i64 i;
	R1 = 0;
	R2 = (u64)&cc_lex_headerpath;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6348;
L6346:
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6350;
	asi64(R1) = i;
	goto L6345;
L6350:
	i += 1; if (i <= cc_decls_nsourcefiles) goto L6346;
L6348:
	asu8(R1) = cc_cli_dointheaders;
	if (!asu8(R1)) goto L6352;
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = cc_headers_findheader(asu64(R1));
	hdrtext = asu64(R1);
	asu64(R1) = hdrtext;
	if (!asu64(R1)) goto L6354;
	asu64(R1) = hdrtext;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadbuiltin(asu64(R2), asu64(R1));
	goto L6345;
L6354:
L6352:
	R1 = tou64("mcc.h");
	asu64(R2) = file;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6356;
	R1 = tou64("#define __attribute__(x)\n#define _WIN32\n#define WIN32\n#define __WIN32__\n#define __inline\n#define __dllimport(x)\n//#define __declspec(x)\n#define __stdcall\n#define CALLBACK $callback\n#define __cdecl\n#define EXTERN_C extern\n#define DECLSPEC_IMPORT\n#define __32BIT__\n#define register\n#define __MCCC__\n\n//typedef signed char\t\ti8;\n//typedef short\t\t\ti16;\n//typedef int\t\t\t\ti32;\n//typedef long long int\ti64;\n//typedef unsigned char\t\t\tu8;\n//typedef unsigned short\t\t\tu16;\n//typedef unsigned int\t\t\tu32;\n//typedef unsigned long long int\tu64;\n//\n//typedef unsigned char byte;\n//\n//typedef float r32;\n//typedef double r64;\n\n");
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadbuiltin(asu64(R2), asu64(R1));
	goto L6345;
L6356:
	asu64(R1) = file;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&cc_lex_headerpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L6358;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L6361;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L6360;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) != asu64(R2)) goto L6360;
L6361:
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L6363;
	asu64(R1) = file;
	asu64(R2) = file;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L6345;
L6363:
	R1 = 0;
	goto L6345;
L6360:
L6358:
	asi64(R1) = cc_lex_lx_stackindex;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6366;
L6364:
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L6368;
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L6345;
L6368:
	i += -1; if (i >= 1) goto L6364;
L6366:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsearchdirs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6371;
L6369:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L6373;
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&cc_lex_headerpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L6345;
L6373:
	i += 1; if (i <= cc_decls_nsearchdirs) goto L6369;
L6371:
	R1 = 0;
	goto L6345;
L6345:
	return asi64(R1);
}

static void cc_lex_lex() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
// cc_lex.lex.reenter:
	(R1_B17) = cc_decls_nextlx;
	cc_decls_lx = (R1_B17);
	cc_lex_lexm();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6377;
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6377;
	R1 = 0;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&cc_decls_lx;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6377:
L6378:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6380;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6381;
	goto L6382;
L6380:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L6384;
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6384:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6374;
	goto L6378;
L6381:
	cc_lex_lexm();
	goto L6378;
L6382:
	goto L6374;
	goto L6378;
L6374:
	return;
}

static void cc_lex_shownumberstr(u64 l, u64 f) {
    u64 R1, R2, R3; 
	u64 s;
	asu64(R1) = l;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	if (!asi64(R1)) goto L6387;
	R1 = (u64)&cc_decls_sourcefiletext;
	asu64(R2) = l;
	asi64(R2) = cc_lex_getfilenox(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = l;
	asi64(R2) = cc_lex_getnumberoffsetx(asu64(R2));
	R1 += (i64)R2;
	s = asu64(R1);
	goto L6386;
L6387:
	R1 = (u64)&cc_lex_pastedtokenlist;
	asu64(R2) = l;
	R3 = 28;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	s = asu64(R1);
L6386:
	asu64(R1) = f;
	asu64(R2) = l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = s;
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static u64 cc_lex_addnamestr(u64 name) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	struct $B17 oldlx;
	u64 symptr;
	(R1_B17) = cc_decls_nextlx;
	oldlx = (R1_B17);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = name;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_lex_lxsvalue = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R2) = name;
	asu64(R3) = cc_lex_lxsvalue;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cc_lex_lookup();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B17) = oldlx;
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = symptr;
	goto L6388;
L6388:
	return asu64(R1);
}

static void cc_lex_lxreadstring(i64 termchar, i64 fwide) {
    u64 R1, R2, R3, R4; 
	struct $B41 str;
	u64 dest;
	u64 ws;
	u64 wd;
	u64 wd0;
	i64 c;
	i64 d;
	i64 length;
	i64 useheap;
	i64 av_1;
	i64 av_2;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L6391;
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L6393;
	R1 = 64;
	goto L6392;
L6393:
	R1 = 63;
L6392:
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6390;
L6391:
	R1 = 61;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6390:
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6395;
	asi64(R1) = fwide;
	if (asi64(R1)) goto L6395;
	asu64(R1) = cc_lex_lxsptr;
	dest = asu64(R1);
	asu64(R1) = dest;
	ws = asu64(R1);
	R1 = 0;
	useheap = asi64(R1);
	goto L6394;
L6395:
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	ws = asu64(R1);
	R1 = 1;
	useheap = asi64(R1);
L6394:
	R1 = 0;
	length = asi64(R1);
L6396:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6399;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6400;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6400;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6401;
	goto L6402;
L6399:
	asi64(R1) = cc_lex_isincludefile;
	if (!asi64(R1)) goto L6404;
	R1 = 47;
	c = asi64(R1);
	goto L6405;
L6404:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
// cc_lex.lxreadstring.reenter:
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 10: goto L6439;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 93: case 94: case 95: case 96: case 99: case 100: case 101: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 111: case 112: case 113: case 115: case 117: case 119: goto L6409;
	case 13: goto L6436;
	case 34: goto L6433;
	case 39: goto L6435;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L6426;
	case 92: goto L6434;
	case 97: goto L6410;
	case 98: goto L6411;
	case 102: goto L6412;
	case 110: goto L6413;
	case 114: goto L6414;
	case 116: goto L6415;
	case 118: goto L6416;
	case 120: goto L6417;
	default: goto L6409;
    };
// SWITCH
L6410:
	R1 = 7;
	c = asi64(R1);
	goto L6407;
L6411:
	R1 = 8;
	c = asi64(R1);
	goto L6407;
L6412:
	R1 = 12;
	c = asi64(R1);
	goto L6407;
L6413:
	R1 = 10;
	c = asi64(R1);
	goto L6407;
L6414:
	R1 = 13;
	c = asi64(R1);
	goto L6407;
L6415:
	R1 = 9;
	c = asi64(R1);
	goto L6407;
L6416:
	R1 = 11;
	c = asi64(R1);
	goto L6407;
L6417:
	R1 = 0;
	c = asi64(R1);
L6418:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	d = asi64(R2);
	switch (asi64(R1)) {
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L6425;
	case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: goto L6422;
	case 65: case 66: case 67: case 68: case 69: case 70: goto L6423;
	case 97: case 98: case 99: case 100: case 101: case 102: goto L6424;
	default: goto L6422;
    };
// SWITCH
L6423:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L6420;
L6424:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L6420;
L6425:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L6420;
L6422:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6419;
L6420:
	goto L6418;
L6419:
	goto L6407;
L6426:
	R1 = 48;
	R2 = (u64)&c;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	av_1 = asi64(R1);
L6427:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	d = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L6431;
	goto L6432;
L6431:
	asi64(R1) = c;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L6430;
L6432:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6429;
L6430:
	if (--asi64(av_1)) goto L6427;
L6429:
	goto L6407;
L6433:
	R1 = 34;
	c = asi64(R1);
	goto L6407;
L6434:
	R1 = 92;
	c = asi64(R1);
	goto L6407;
L6435:
	R1 = 39;
	c = asi64(R1);
	goto L6407;
L6436:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6438;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L6438:
	goto L6396;
	goto L6407;
L6439:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L6396;
	goto L6407;
L6409:
L6407:
	goto L6398;
L6400:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L6441;
	goto L6397;
L6441:
	goto L6398;
L6401:
	msysc_m$print_startcon();
	R1 = tou64("NEXTLX.LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("String not terminated");
	cc_lex_lxerror(asu64(R1));
	goto L6398;
L6402:
L6398:
// cc_lex.lxreadstring.normalchar:
L6405:
	asi64(R1) = useheap;
	if (asi64(R1)) goto L6443;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6442;
L6443:
	R1 = (u64)&length;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L6444;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6442;
L6444:
	R1 = tou64("Local str too long");
	cc_lex_lxerror(asu64(R1));
L6442:
	goto L6396;
L6397:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L6446;
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 2;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	wd = asu64(R2);
	wd0 = asu64(R1);
	asi64(R1) = length;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6449;
L6447:
	R1 = (u64)&ws;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = (u64)&wd;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 2; asu64(R2) = asu64(R3);
	*tou16p(R2) = asu16(R1);
	if (--asi64(av_2)) goto L6447;
L6449:
	R1 = 0;
	asu64(R2) = wd;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = wd0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6445;
L6446:
	asi64(R1) = useheap;
	if (!asi64(R1)) goto L6450;
	asi64(R1) = length;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	R2 = 1;
	asu64(R1) += asu64(R2);
	R2 = (u64)&str;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L6445;
L6450:
	asu64(R1) = dest;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6445:
	return;
}

static void cc_lex_addlisttoken(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6453;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6452;
L6453:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6452:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlisttoken_copy(u64 ulist, u64 ulistx, u64 q) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 p;
	asu64(R1) = cc_lex_alloctoken();
	p = asu64(R1);
	asu64(R1) = q;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = p;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6456;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6455;
L6456:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6455:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlist_nextlx(u64 ulist, u64 ulistx) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 p;
	asu64(R1) = cc_lex_alloctoken();
	p = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	asu64(R2) = p;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6459;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6458;
L6459:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6458:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlisttoken_seq(u64 ulist, u64 ulistx, u64 seq) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 tk;
	goto L6462;
L6461:
	asu64(R1) = cc_lex_alloctoken();
	tk = asu64(R1);
	asu64(R1) = seq;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6465;
	asu64(R1) = tk;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6464;
L6465:
	asu64(R1) = tk;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6464:
	R1 = 0;
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L6462:
	asu64(R1) = seq;
	if (asu64(R1)) goto L6461;
	return;
}

static void cc_lex_addlistmparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6468;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6467;
L6468:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6467:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_dodefine() {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 stlist;
	u64 stlistx;
	u64 p;
	u64 q;
	u64 stname;
	u64 d;
	u64 tklist;
	u64 tklistx;
	u64 tk;
	i64 nparams;
	i64 ntokens;
	i64 paramno;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6471;
	R1 = tou64("define: name expected");
	cc_lex_lxerror(asu64(R1));
L6471:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 92;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = stname;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	nparams = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) != asu64(R2)) goto L6473;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 0;
	R2 = R1;
	stlistx = asu64(R2);
	stlist = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	cc_lex_lexreadtoken();
L6474:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6477;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6478;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6479;
	goto L6480;
L6477:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = stlist;
	p = asu64(R1);
	goto L6482;
L6481:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L6485;
	R1 = tou64("Dupl macro param");
	cc_lex_lxerror(asu64(R1));
L6485:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6482:
	asu64(R1) = p;
	if (asu64(R1)) goto L6481;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	cc_lex_addlistmparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L6487;
	cc_lex_lexreadtoken();
L6487:
	goto L6476;
L6478:
	goto L6475;
	goto L6476;
L6479:
	R1 = tou64("__VA_ARGS__");
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	d = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6489;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L6489:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	cc_lex_addlistmparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	goto L6475;
	goto L6476;
L6480:
	R1 = tou64("macro params?");
	cc_lex_lxerror(asu64(R1));
L6476:
	goto L6474;
L6475:
	asu64(R1) = stlist;
	asu64(R2) = stname;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6473:
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	R1 = 0;
	ntokens = asi64(R1);
L6490:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6493;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6493;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6494;
	goto L6495;
L6493:
	goto L6491;
	goto L6492;
L6494:
	asu64(R1) = stname;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = 1;
	paramno = asi64(R1);
	goto L6497;
L6496:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L6500;
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	asi64(R1) = paramno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6498;
L6500:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&paramno;
	(*toi64p(R1)) += 1;
L6497:
	asu64(R1) = p;
	if (asu64(R1)) goto L6496;
L6498:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	if (asu64(R1) != asu64(R2)) goto L6502;
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
L6502:
	goto L6492;
L6495:
L6492:
	R1 = (u64)&ntokens;
	(*toi64p(R1)) += 1;
	asu64(R1) = cc_lex_alloctoken();
	tk = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
	asu64(R1) = tk;
	R2 = (u64)&tklistx;
	R3 = (u64)&tklist;
	cc_lex_addlisttoken(asu64(R3), asu64(R2), asu64(R1));
	goto L6490;
L6491:
	asu64(R1) = tklist;
	asu64(R2) = stname;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nparams;
	asu64(R2) = stname;
	R3 = 111;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void cc_lex_readalphanumeric(u64 pstart) {
    u64 R1, R2, R3; 
	goto L6505;
L6504:
L6505:
	R1 = (u64)&cc_lex_alphamap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6504;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 58;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 cc_lex_inmacrostack(u64 d, u64 macrostack) {
    u64 R1, R2; 
	goto L6509;
L6508:
	asu64(R1) = macrostack;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L6512;
	R1 = 1;
	goto L6507;
L6512:
	asu64(R1) = macrostack;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	macrostack = asu64(R1);
L6509:
	asu64(R1) = macrostack;
	if (asu64(R1)) goto L6508;
	R1 = 0;
	goto L6507;
L6507:
	return asi64(R1);
}

static void cc_lex_showtokens(u64 caption, u64 tk) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("<");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6515;
L6514:
	asu64(R1) = tk;
	cc_lex_showtoken(asu64(R1));
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L6515:
	asu64(R1) = tk;
	if (asu64(R1)) goto L6514;
	msysc_m$print_startcon();
	R1 = tou64(">");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_lex_lexa(u64 tk) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = cc_lex_normaltk;
	if (asu64(R1) != asu64(R2)) goto L6519;
	cc_lex_lexreadtoken();
	goto L6517;
L6519:
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6521;
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6517;
L6521:
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	(R1_B17) = *(struct $B17*)(R1);
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	*tou64p(R2) = asu64(R1);
L6517:
	return;
}

static void cc_lex_lexm() {
    u64 R1, R2, R3, R4, R5; struct $B17 R1_B17; 
	u64 d;
	i64 newlineno;
// PROC LOCAL STATICS GO HERE
	static i64 cc_lex_lexm_doreset = 0;
L6523:
	asu64(R1) = cc_lex_tkptr;
	if (!asu64(R1)) goto L6526;
	asu64(R1) = cc_lex_tkptr;
	(R1_B17) = *(struct $B17*)(R1);
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = cc_lex_tkptr;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_tkptr = asu64(R1);
	asu64(R1) = cc_lex_tkptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6528;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6530;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6530;
	asi64(R1) = cc_lex_peeklb();
	if (!asi64(R1)) goto L6530;
	asi64(R1) = cc_decls_sfileno;
	cc_lex_setfileno(asi64(R1));
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	cc_lex_lexm_doreset = asi64(R1);
	goto L6531;
L6530:
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
L6528:
	goto L6522;
L6526:
	asi64(R1) = cc_lex_lexm_doreset;
	if (!asi64(R1)) goto L6533;
	asi64(R1) = cc_decls_sfileno;
	cc_lex_setfileno(asi64(R1));
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	cc_lex_lexm_doreset = asi64(R1);
L6533:
	asi64(R1) = cc_lex_firstsymbol;
	if (!asi64(R1)) goto L6535;
	R1 = 0;
	cc_lex_firstsymbol = asi64(R1);
	cc_lex_dospecialinclude();
L6535:
	cc_lex_lexreadtoken();
// cc_lex.lexm.test1:
L6531:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6537;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6538;
	goto L6539;
L6537:
	asi64(R1) = cc_lex_dolexdirective();
	if (!asi64(R1)) goto L6541;
	goto L6522;
L6541:
	goto L6523;
	goto L6536;
L6538:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L6543;
	goto L6544;
L6543:
	asi64(R1) = cc_lex_getfileno();
	cc_decls_sfileno = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_slineno = asi64(R1);
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	asu64(R3) = d;
	R4 = 100;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	cc_lex_expandpredefmacro(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
	goto L6522;
	goto L6542;
L6544:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6547;
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L6546;
L6547:
	goto L6522;
L6546:
L6542:
	goto L6536;
L6539:
	goto L6522;
L6536:
	asi64(R1) = cc_lex_getfileno();
	cc_decls_sfileno = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_slineno = asi64(R1);
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6549;
	asi64(R1) = cc_lex_peeklb();
	if (asi64(R1)) goto L6551;
	goto L6522;
L6551:
	R1 = (u64)&newlineno;
	R2 = 1;
	R3 = (u64)&cc_lex_normaltk;
	R4 = 0;
	asu64(R5) = d;
	asu64(R1) = cc_lex_expandfnmacro(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	cc_lex_tkptr = asu64(R1);
	asi64(R1) = newlineno;
	cc_decls_slineno = asi64(R1);
	goto L6548;
L6549:
	R1 = 1;
	R2 = (u64)&cc_lex_normaltk;
	R3 = 0;
	asu64(R4) = d;
	asu64(R1) = cc_lex_expandobjmacro(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	cc_lex_tkptr = asu64(R1);
L6548:
	asu64(R1) = cc_lex_tkptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6553;
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
L6553:
	goto L6523;
L6522:
	return;
}

static i64 cc_lex_peeklb() {
    u64 R1, R2; 
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) == asu64(R2)) goto L6557;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) != asu64(R2)) goto L6556;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) != asu64(R2)) goto L6556;
L6557:
	R1 = 1;
	goto L6554;
L6556:
	R1 = 0;
	goto L6554;
L6554:
	return asi64(R1);
}

static i64 cc_lex_peektk(u64 tk) {
    u64 R1, R2; 
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6560;
	R1 = 0;
	goto L6558;
L6560:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6562;
	R1 = 1;
	goto L6558;
L6562:
	R1 = 0;
	goto L6558;
L6558:
	return asi64(R1);
}

static u64 cc_lex_expandobjmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel) {
    u64 R1, R2, R3, R4, R5; 
	u64 tk;
	u64 p;
	u64 repl;
	struct $B17 newmacro;
	i64 iscomplex;
	i64 useshh;
	i64 expanded;
	u64 d;
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	tk = asu64(R2);
	p = asu64(R1);
	R1 = 0;
	R2 = R1;
	useshh = asi64(R2);
	iscomplex = asi64(R1);
	goto L6565;
L6564:
	asu64(R1) = p;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6568;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6571;
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L6570;
L6571:
	R1 = 1;
	iscomplex = asi64(R1);
	goto L6566;
L6570:
	goto L6567;
L6568:
	asu64(R1) = p;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L6572;
	R1 = 1;
	R2 = R1;
	useshh = asi64(R2);
	iscomplex = asi64(R1);
	goto L6566;
L6572:
L6567:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6565:
	asu64(R1) = p;
	if (asu64(R1)) goto L6564;
L6566:
	asi64(R1) = iscomplex;
	if (asi64(R1)) goto L6574;
	asu64(R1) = tk;
	goto L6563;
L6574:
	asu64(R1) = m;
	R2 = (u64)&newmacro;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = macrostack;
	R2 = (u64)&newmacro;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = useshh;
	if (!asi64(R1)) goto L6576;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asu64(R5) = m;
	asu64(R1) = cc_lex_substituteargs(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	repl = asu64(R1);
	goto L6575;
L6576:
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	repl = asu64(R1);
L6575:
	R1 = (u64)&expanded;
	R2 = (u64)&newmacro;
	asu64(R3) = repl;
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	tk = asu64(R1);
	asu64(R1) = tk;
	goto L6563;
L6563:
	return asu64(R1);
}

static u64 cc_lex_expandfnmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel, u64 endlineno) {
    u64 R1, R2, R3, R4, R5; 
	struct $B87 args;
	struct $B87 expargs;
	u64 repl;
	u64 tk;
	struct $B17 newmacro;
	i64 nargs;
	i64 i;
	i64 expanded;
	asu64(R1) = tksource;
	R2 = (u64)&args;
	asu64(R3) = m;
	asi64(R1) = cc_lex_readmacrocall(asu64(R3), asu64(R2), asu64(R1));
	nargs = asi64(R1);
	asi64(R1) = frombaselevel;
	if (!asi64(R1)) goto L6579;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = endlineno;
	*toi64p(R2) = asi64(R1);
L6579:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6582;
L6580:
	R1 = 0;
	R2 = (u64)&expargs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nargs) goto L6580;
L6582:
	asu64(R1) = macrostack;
	asi64(R2) = nargs;
	R3 = (u64)&expargs;
	R4 = (u64)&args;
	asu64(R5) = m;
	asu64(R1) = cc_lex_substituteargs(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	repl = asu64(R1);
	asu64(R1) = m;
	R2 = (u64)&newmacro;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = macrostack;
	R2 = (u64)&newmacro;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&expanded;
	R2 = (u64)&newmacro;
	asu64(R3) = repl;
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	repl = asu64(R1);
	asu64(R1) = repl;
	goto L6577;
L6577:
	return asu64(R1);
}

static u64 cc_lex_scantokenseq(u64 tk, u64 macrostack, u64 expanded) {
    u64 R1, R2, R3, R4, R5; 
	u64 newtk;
	u64 newtkx;
	u64 expandtk;
	u64 oldtk;
	u64 m;
	struct $B17 newmacro;
	i64 noexpandflag;
	i64 simple;
	i64 dummy;
// cc_lex.scantokenseq.reenter:
L6584:
	R1 = 0;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = R1;
	newtkx = asu64(R2);
	newtk = asu64(R1);
	R1 = 0;
	noexpandflag = asi64(R1);
	R1 = 1;
	simple = asi64(R1);
	asu64(R1) = tk;
	oldtk = asu64(R1);
	goto L6586;
L6585:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6589;
	goto L6590;
L6589:
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6593;
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L6592;
L6593:
	R1 = 0;
	simple = asi64(R1);
	goto L6587;
L6592:
	goto L6588;
L6590:
L6588:
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6595;
	goto L6587;
L6595:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L6586:
	asu64(R1) = tk;
	if (asu64(R1)) goto L6585;
L6587:
	asi64(R1) = simple;
	if (!asi64(R1)) goto L6597;
	asu64(R1) = oldtk;
	goto L6583;
L6597:
	asu64(R1) = oldtk;
	tk = asu64(R1);
	goto L6599;
L6598:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6602;
	goto L6603;
L6602:
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6605;
	asi64(R1) = noexpandflag;
	if (asi64(R1)) goto L6605;
	asu64(R1) = tk;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L6608;
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L6607;
L6608:
	goto L6609;
L6607:
	asu64(R1) = macrostack;
	asu64(R2) = m;
	asi64(R1) = cc_lex_inmacrostack(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6611;
	asu64(R1) = tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	asu64(R2) = newtkx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	goto L6612;
L6611:
	R1 = 0;
	simple = asi64(R1);
	asu64(R1) = m;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6614;
	asu64(R1) = tk;
	asi64(R1) = cc_lex_peektk(asu64(R1));
	if (asi64(R1)) goto L6616;
	goto L6609;
L6616:
	R1 = (u64)&tk;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&dummy;
	R2 = 1;
	R3 = (u64)&tk;
	asu64(R4) = macrostack;
	asu64(R5) = m;
	asu64(R1) = cc_lex_expandfnmacro(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	expandtk = asu64(R1);
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	goto L6599;
	goto L6613;
L6614:
	R1 = 0;
	R2 = (u64)&tk;
	asu64(R3) = macrostack;
	asu64(R4) = m;
	asu64(R1) = cc_lex_expandobjmacro(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	expandtk = asu64(R1);
	R1 = 1;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
L6613:
	goto L6604;
L6605:
	asu64(R1) = m;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 93;
	if (asi64(R1) != asi64(R2)) goto L6617;
	R1 = 1;
	noexpandflag = asi64(R1);
	goto L6609;
	goto L6604;
L6617:
	asu64(R1) = m;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L6618;
	asu64(R1) = cc_lex_alloctokenz();
	expandtk = asu64(R1);
	asi64(R1) = cc_decls_slineno;
	asu64(R2) = expandtk;
	asu64(R3) = m;
	R4 = 100;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	cc_lex_expandpredefmacro(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	goto L6619;
	goto L6604;
L6618:
	R1 = 0;
	noexpandflag = asi64(R1);
	goto L6609;
L6604:
	goto L6601;
L6603:
// cc_lex.scantokenseq.simpletoken:
L6609:
	asu64(R1) = tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
L6601:
// cc_lex.scantokenseq.skip:
L6612:
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6621;
	goto L6600;
L6621:
// cc_lex.scantokenseq.skip2:
L6619:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L6599:
	asu64(R1) = tk;
	if (asu64(R1)) goto L6598;
L6600:
	asu64(R1) = expanded;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L6623;
	asu64(R1) = newtk;
	tk = asu64(R1);
	goto L6584;
L6623:
	asu64(R1) = newtk;
	goto L6583;
L6583:
	return asu64(R1);
}

static i64 cc_lex_readmacrocall(u64 d, u64 args, u64 tksource) {
    u64 R1, R2, R3; 
	i64 nparams;
	i64 lbcount;
	i64 paramno;
	i64 nargs;
	i64 usesvargs;
	i64 varg;
	u64 tklist;
	u64 tklistx;
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6626;
	R1 = tou64("rmc: no '('");
	cc_lex_lxerror(asu64(R1));
L6626:
	asu64(R1) = d;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nparams = asi64(R1);
	R1 = 0;
	nargs = asi64(R1);
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6628;
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6630;
	R1 = tou64("rmc: ')' expected");
	cc_lex_lxerror(asu64(R1));
L6630:
	R1 = 0;
	goto L6624;
L6628:
	R1 = 1;
	paramno = asi64(R1);
	R1 = 1;
	lbcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	usesvargs = asi64(R1);
	R1 = 0;
	varg = asi64(R1);
L6631:
	asi64(R1) = paramno;
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L6634;
	asi64(R1) = usesvargs;
	if (!asi64(R1)) goto L6634;
	R1 = 1;
	varg = asi64(R1);
L6634:
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6636;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6637;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6638;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6639;
	goto L6640;
L6636:
	asi64(R1) = lbcount;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6642;
	asi64(R1) = varg;
	if (asi64(R1)) goto L6642;
	asu64(R1) = tklist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6644;
	asu64(R1) = cc_lex_alloctokenz();
	tklist = asu64(R1);
	asi64(R1) = cc_lex_getfileno();
	asu64(R2) = tklist;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	R1 = 66;
	asu64(R2) = tklist;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6644:
	asu64(R1) = tklist;
	asu64(R2) = args;
	asi64(R3) = paramno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	R1 = (u64)&paramno;
	(*toi64p(R1)) += 1;
	goto L6641;
L6642:
	goto L6645;
L6641:
	goto L6635;
L6637:
	R1 = tou64("EOS in macro call");
	cc_lex_lxerror(asu64(R1));
	goto L6635;
L6638:
	R1 = (u64)&lbcount;
	(*toi64p(R1)) += 1;
	goto L6645;
	goto L6635;
L6639:
	asi64(R1) = lbcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6647;
	R1 = (u64)&lbcount;
	(*toi64p(R1)) -=1;
	R1 = (u64)&tklistx;
	R2 = (u64)&tklist;
	cc_lex_addlist_nextlx(asu64(R2), asu64(R1));
	goto L6646;
L6647:
	asu64(R1) = tklist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6649;
	asu64(R1) = cc_lex_alloctokenz();
	tklist = asu64(R1);
	asi64(R1) = cc_lex_getfileno();
	asu64(R2) = tklist;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	R1 = 66;
	asu64(R2) = tklist;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6649:
	asu64(R1) = tklist;
	asu64(R2) = args;
	asi64(R3) = paramno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6632;
L6646:
	goto L6635;
L6640:
// cc_lex.readmacrocall.addtoken:
L6645:
	R1 = (u64)&tklistx;
	R2 = (u64)&tklist;
	cc_lex_addlist_nextlx(asu64(R2), asu64(R1));
L6635:
	goto L6631;
L6632:
	asi64(R1) = paramno;
	asi64(R2) = nparams;
	if (asi64(R1) == asi64(R2)) goto L6651;
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L6653;
	asi64(R1) = usesvargs;
	if (!asi64(R1)) goto L6653;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6652;
L6653:
	R1 = tou64("Wrong # macro params");
	cc_lex_lxerror(asu64(R1));
L6652:
L6651:
	asi64(R1) = nparams;
	goto L6624;
L6624:
	return asi64(R1);
}

static u64 cc_lex_substituteargs(u64 m, u64 args, u64 expargs, i64 nargs, u64 macrostack) {
    u64 R1, R2, R3, R4; 
	u64 params;
	u64 seq;
	u64 seqstart;
	u64 lasttoken;
	u64 newtk;
	u64 newtkx;
	u64 niltk;
	u64 tkexp;
	struct $B17 tk;
	i64 n;
	i64 i;
	i64 expanded;
	struct $B46 hhpoints;
	i64 nhashhash;
	asu64(R1) = m;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	params = asu64(R1);
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	seqstart = asu64(R2);
	seq = asu64(R1);
	R1 = 0;
	R2 = R1;
	newtkx = asu64(R2);
	newtk = asu64(R1);
	R1 = 0;
	nhashhash = asi64(R1);
	R1 = 0;
	lasttoken = asu64(R1);
	goto L6656;
L6655:
	asu64(R1) = seq;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6659;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6660;
	goto L6661;
L6659:
	asi64(R1) = nargs;
	if (!asi64(R1)) goto L6663;
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
	asu64(R1) = seq;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6665;
	R1 = tou64("# at end");
	cc_lex_lxerror(asu64(R1));
L6665:
	asu64(R1) = seq;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L6667;
	R1 = tou64("# not followed by param");
	cc_lex_lxerror(asu64(R1));
L6667:
	asu64(R1) = seq;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	R1 = (u64)&tk;
	asu64(R2) = args;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	cc_lex_stringify(asu64(R2), asu64(R1));
	R1 = (u64)&tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	goto L6662;
L6663:
	asu64(R1) = seq;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken(asu64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = newtkx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6662:
	goto L6658;
L6660:
	asu64(R1) = seq;
	asu64(R2) = seqstart;
	if (asu64(R1) != asu64(R2)) goto L6669;
	R1 = tou64("## at start");
	cc_lex_lxerror(asu64(R1));
L6669:
	asi64(R1) = nhashhash;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L6671;
	R1 = tou64("Too many ##");
	cc_lex_lxerror(asu64(R1));
L6671:
	asu64(R1) = newtkx;
	R2 = (u64)&hhpoints;
	R3 = (u64)&nhashhash;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6658;
L6661:
	asu64(R1) = seq;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6673;
	asu64(R1) = seq;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L6673;
	asi64(R1) = nargs;
	if (!asi64(R1)) goto L6673;
	asu64(R1) = seq;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6677;
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6676;
L6677:
	asu64(R1) = lasttoken;
	if (!asu64(R1)) goto L6675;
	asu64(R1) = lasttoken;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L6675;
L6676:
	asu64(R1) = args;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
	goto L6674;
L6675:
	asu64(R1) = expargs;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	tkexp = asu64(R1);
	asu64(R1) = tkexp;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6679;
	R1 = (u64)&expanded;
	asu64(R2) = macrostack;
	asu64(R3) = args;
	asi64(R4) = n;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	asu64(R3) = expargs;
	asi64(R4) = n;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	tkexp = asu64(R1);
L6679:
	asu64(R1) = tkexp;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
L6674:
	goto L6672;
L6673:
// cc_lex.substituteargs.doother:
	asu64(R1) = seq;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
L6672:
L6658:
	asu64(R1) = seq;
	lasttoken = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L6656:
	asu64(R1) = seq;
	if (asu64(R1)) goto L6655;
	asi64(R1) = nhashhash;
	if (!asi64(R1)) goto L6682;
	R1 = 0;
	niltk = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nhashhash;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6685;
L6683:
	asi64(R1) = i;
	asi64(R2) = nhashhash;
	if (asi64(R1) >= asi64(R2)) goto L6687;
	R1 = (u64)&hhpoints;
	asi64(R2) = i;
	R1 += (i64)R2*8;
	goto L6686;
L6687:
	R1 = (u64)&niltk;
L6686:
	R2 = (u64)&hhpoints;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	cc_lex_pastetokens(asu64(R2), asu64(R1));
	i += 1; if (i <= nhashhash) goto L6683;
L6685:
L6682:
	asu64(R1) = newtk;
	goto L6654;
L6654:
	return asu64(R1);
}

static u64 cc_lex_strtoken(u64 lp, u64 length) {
    u64 R1, R2, R3, R4, R5; struct $B17 R1_B17; 
	u64 name;
	u64 s;
	struct $B17 l;
	asu64(R1) = lp;
	(R1_B17) = *(struct $B17*)(R1);
	l = (R1_B17);
	R1 = (u64)&l;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6690;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6691;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6691;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L6692;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6693;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L6693;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6694;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6695;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6696;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L6697;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L6697;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L6697;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L6697;
	goto L6698;
L6690:
// cc_lex.strtoken.doname:
L6699:
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6688;
	goto L6689;
L6691:
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	if (!asi64(R1)) goto L6701;
	R1 = (u64)&cc_decls_sourcefiletext;
	R2 = (u64)&l;
	asi64(R2) = cc_lex_getfilenox(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&l;
	asi64(R2) = cc_lex_getnumberoffsetx(asu64(R2));
	R1 += (i64)R2;
	goto L6688;
	goto L6700;
L6701:
	R1 = (u64)&cc_lex_pastedtokenlist;
	R2 = (u64)&l;
	R3 = 28;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L6688;
L6700:
	goto L6689;
L6692:
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6688;
	goto L6689;
L6693:
	R1 = 34;
	asu64(R2) = length;
	R3 = (u64)&l;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&l;
	R5 = 0;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = cc_lex_strstring(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	goto L6688;
	goto L6689;
L6694:
	R1 = 39;
	asu64(R2) = length;
	R3 = (u64)&l;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&l;
	R5 = 0;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = cc_lex_strstring(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	goto L6688;
	goto L6689;
L6695:
	asi64(R1) = cc_lex_dowhitespace;
	if (!asi64(R1)) goto L6703;
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = length;
	asi64(R1) = *toi64p(R1);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	R1 = 10;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	R4 = 1;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L6702;
L6703:
	R1 = 1;
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = tou64("\n");
	goto L6688;
L6702:
	asu64(R1) = s;
	goto L6688;
	goto L6689;
L6696:
	R1 = 0;
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = tou64("");
	goto L6688;
	goto L6689;
L6697:
	goto L6699;
	goto L6689;
L6698:
	R1 = (u64)&cc_tables_shortsymbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	asu64(R3) = length;
	*toi64p(R3) = asi64(R2);
	if (!asi64(R1)) goto L6705;
	asu64(R1) = name;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L6707;
	asu64(R1) = name;
	goto L6688;
	goto L6706;
L6707:
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2;
	goto L6688;
L6706:
	goto L6704;
L6705:
	R1 = tou64("");
	goto L6688;
L6704:
L6689:
	R1 = tou64("");
	goto L6688;
L6688:
	return asu64(R1);
}

static u64 cc_lex_strstring(u64 s, i64 length, u64 newlength, i64 quotechar) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 4;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	asi64(R1) = quotechar;
	if (!asi64(R1)) goto L6710;
	asi64(R1) = quotechar;
	asu64(R2) = u;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&u;
	(*tou64p(R1)) += 1;
L6710:
	asi64(R1) = length;
	asu64(R2) = u;
	asu64(R3) = s;
	asi64(R1) = cc_lib_convertstringc(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = newlength;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = quotechar;
	if (!asi64(R1)) goto L6712;
	asi64(R1) = quotechar;
	asu64(R2) = t;
	asu64(R3) = newlength;
	asi64(R3) = *toi64p(R3);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newlength;
	(*toi64p(R1)) += 1;
L6712:
	asu64(R1) = t;
	goto L6708;
L6708:
	return asu64(R1);
}

static void cc_lex_emittoken(u64 lp, u64 dest, i64 forcespace) {
    u64 R1, R2, R3; 
	i64 length;
	u64 s;
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L6715;
	asi64(R1) = cc_lex_lasttoken;
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L6715;
	goto L6713;
L6715:
	R1 = (u64)&length;
	asu64(R2) = lp;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = forcespace;
	if (asi64(R1)) goto L6718;
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = cc_lex_lasttoken;
	asi64(R1) = cc_lex_needspace(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L6717;
L6718:
	R1 = 32;
	asu64(R2) = dest;
	mlib_gs_char(asu64(R2), asi64(R1));
L6717:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_gs_strn(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_lex_lasttoken = asi64(R1);
L6713:
	return;
}

static void cc_lex_showtoken(u64 lp) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_showtoken_dest = (u64)&cc_lex_showtoken_buffer;
	asu64(R1) = cc_lex_showtoken_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	asu64(R2) = cc_lex_showtoken_dest;
	asu64(R3) = lp;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("v");
	asu64(R2) = cc_lex_showtoken_dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = cc_lex_showtoken_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static void cc_lex_stringify(u64 seq, u64 dest) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	i64 addspace;
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_stringify_deststr = (u64)&cc_lex_stringify_buffer;
	R1 = 63;
	asu64(R2) = dest;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6722;
	R1 = (u64)&length;
	asu64(R2) = seq;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6720;
L6722:
	asu64(R1) = cc_lex_stringify_deststr;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	cc_lex_lasttoken = asi64(R1);
	R1 = 0;
	addspace = asi64(R1);
	goto L6724;
L6723:
	asi64(R1) = addspace;
	asu64(R2) = cc_lex_stringify_deststr;
	asu64(R3) = seq;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	addspace = asi64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L6724:
	asu64(R1) = seq;
	if (asu64(R1)) goto L6723;
	asi64(R1) = length;
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_stringify_deststr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = cc_lex_stringify_deststr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6720:
	return;
}

static void cc_lex_pastetokens(u64 tk, u64 tknext) {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	u64 tk2;
	i64 length1;
	i64 length2;
	u64 s;
	u64 t;
	u64 u;
	struct $B17 oldtoken;
	struct $B17 token;
	u64 oldlxsptr;
	i64 oldlx_stackindex;
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk2 = asu64(R1);
	asu64(R1) = tk2;
	asu64(R2) = tknext;
	asu64(R2) = *tou64p(R2);
	if (asu64(R1) != asu64(R2)) goto L6728;
	asu64(R1) = tk;
	asu64(R2) = tknext;
	*tou64p(R2) = asu64(R1);
L6728:
	asu64(R1) = tk2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L6730;
	asu64(R1) = tk2;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L6732;
	goto L6731;
L6732:
	asu64(R1) = tk2;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
L6731:
	goto L6729;
L6730:
	asu64(R1) = tk2;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L6733;
	goto L6729;
L6733:
	R1 = (u64)&length1;
	asu64(R2) = tk;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	R1 = (u64)&length2;
	asu64(R2) = tk2;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	t = asu64(R1);
	asi64(R1) = length1;
	asi64(R2) = length2;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
	asi64(R1) = length1;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length2;
	asu64(R2) = t;
	asu64(R3) = u;
	asi64(R4) = length1;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = u;
	asi64(R3) = length1;
	R2 += (i64)R3;
	asi64(R3) = length2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_lex_npastedtokens;
	R2 = 87000;
	if (asi64(R1) < asi64(R2)) goto L6735;
	R1 = tou64("Too many pasted tokens");
	cc_lex_lxerror(asu64(R1));
L6735:
	asu64(R1) = u;
	R2 = (u64)&cc_lex_pastedtokenlist;
	R3 = (u64)&cc_lex_npastedtokens;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	oldtoken = (R1_B17);
	asu64(R1) = cc_lex_lxsptr;
	oldlxsptr = asu64(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	oldlx_stackindex = asi64(R1);
	asu64(R1) = u;
	cc_lex_lxsptr = asu64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_setfileno(asi64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	cc_lex_lexreadtoken();
	(R1_B17) = cc_decls_nextlx;
	token = (R1_B17);
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6737;
L6737:
	(R1_B17) = oldtoken;
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = oldlxsptr;
	cc_lex_lxsptr = asu64(R1);
	asi64(R1) = oldlx_stackindex;
	cc_lex_lx_stackindex = asi64(R1);
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&token;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&token;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	asi64(R1) = cc_lex_npastedtokens;
	R2 = (u64)&token;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 8;
	R2 = (u64)&token;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	(R1_B17) = token;
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
L6729:
	return;
}

static i64 cc_lex_getifexpr() {
    u64 R1, R2; 
	i64 sx;
	i64 x;
	cc_lex_lexm();
	R1 = (u64)&sx;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	x = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6740;
	R1 = tou64("#if:eol expected");
	cc_lex_lxerror(asu64(R1));
L6740:
	asi64(R1) = x;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L6738;
L6738:
	return asi64(R1);
}

static i64 cc_lex_evalcondexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 z;
	i64 sy;
	i64 sz;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalorexpr(asu64(R1));
	x = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L6743;
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	y = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6745;
	R1 = tou64(": expected");
	cc_lex_lxerror(asu64(R1));
L6745:
	cc_lex_lexm();
	R1 = (u64)&sz;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	z = asi64(R1);
	asi64(R1) = x;
	if (!asi64(R1)) goto L6747;
	asi64(R1) = sy;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = y;
	x = asi64(R1);
	goto L6746;
L6747:
	asi64(R1) = sz;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = z;
	x = asi64(R1);
L6746:
L6743:
	asi64(R1) = x;
	goto L6741;
L6741:
	return asi64(R1);
}

static i64 cc_lex_evalorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalandexpr(asu64(R1));
	x = asi64(R1);
	goto L6750;
L6749:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalandexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L6754;
	asi64(R1) = y;
	if (!asi64(R1)) goto L6753;
L6754:
	R1 = 1;
	goto L6752;
L6753:
	R1 = 0;
L6752:
	x = asi64(R1);
L6750:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L6749;
	asi64(R1) = x;
	goto L6748;
L6748:
	return asi64(R1);
}

static i64 cc_lex_evalandexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaliorexpr(asu64(R1));
	x = asi64(R1);
	goto L6757;
L6756:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaliorexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (!asi64(R1)) goto L6760;
	asi64(R1) = y;
	if (!asi64(R1)) goto L6760;
	R1 = 1;
	goto L6759;
L6760:
	R1 = 0;
L6759:
	x = asi64(R1);
L6757:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L6756;
	asi64(R1) = x;
	goto L6755;
L6755:
	return asi64(R1);
}

static i64 cc_lex_evaliorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalixorexpr(asu64(R1));
	x = asi64(R1);
	goto L6763;
L6762:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalixorexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) |= asi64(R1);
L6763:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6762;
	asi64(R1) = x;
	goto L6761;
L6761:
	return asi64(R1);
}

static i64 cc_lex_evalixorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaliandexpr(asu64(R1));
	x = asi64(R1);
	goto L6767;
L6766:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaliandexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
L6767:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L6766;
	asi64(R1) = x;
	goto L6765;
L6765:
	return asi64(R1);
}

static i64 cc_lex_evaliandexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaleqexpr(asu64(R1));
	x = asi64(R1);
	goto L6771;
L6770:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaleqexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) &= asi64(R1);
L6771:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L6770;
	asi64(R1) = x;
	goto L6769;
L6769:
	return asi64(R1);
}

static i64 cc_lex_evaleqexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalcmpexpr(asu64(R1));
	x = asi64(R1);
	goto L6775;
L6774:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalcmpexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6778;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6779;
	goto L6780;
L6778:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	x = asi64(R1);
	goto L6777;
L6779:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	x = asi64(R1);
	goto L6777;
L6780:
L6777:
L6775:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6774;
	asi64(R1) = opc;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6774;
	asi64(R1) = x;
	goto L6773;
L6773:
	return asi64(R1);
}

static i64 cc_lex_evalcmpexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalshiftexpr(asu64(R1));
	x = asi64(R1);
	goto L6783;
L6782:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalshiftexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6786;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6787;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6788;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6789;
	goto L6790;
L6786:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	x = asi64(R1);
	goto L6785;
L6787:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	x = asi64(R1);
	goto L6785;
L6788:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	x = asi64(R1);
	goto L6785;
L6789:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	x = asi64(R1);
	goto L6785;
L6790:
L6785:
L6783:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6782;
	asi64(R1) = opc;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6782;
	asi64(R1) = opc;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6782;
	asi64(R1) = opc;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6782;
	asi64(R1) = x;
	goto L6781;
L6781:
	return asi64(R1);
}

static i64 cc_lex_evalshiftexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaladdexpr(asu64(R1));
	x = asi64(R1);
	goto L6793;
L6792:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaladdexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6796;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6797;
	goto L6798;
L6796:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) >>= asi64(R2);
	x = asi64(R1);
	goto L6795;
L6797:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) <<= asi64(R2);
	x = asi64(R1);
	goto L6795;
L6798:
L6795:
L6793:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6792;
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6792;
	asi64(R1) = x;
	goto L6791;
L6791:
	return asi64(R1);
}

static i64 cc_lex_evaladdexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalmulexpr(asu64(R1));
	x = asi64(R1);
	goto L6801;
L6800:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalmulexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6804;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6805;
	goto L6806;
L6804:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) += asi64(R1);
	goto L6803;
L6805:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) -= asi64(R1);
	goto L6803;
L6806:
L6803:
L6801:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6800;
	asi64(R1) = opc;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6800;
	asi64(R1) = x;
	goto L6799;
L6799:
	return asi64(R1);
}

static i64 cc_lex_evalmulexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	x = asi64(R1);
	goto L6809;
L6808:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6812;
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6812;
	R1 = tou64("#if:div by zero");
	cc_lex_lxerror(asu64(R1));
L6812:
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6814;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6815;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6816;
	goto L6817;
L6814:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) *= asi64(R1);
	goto L6813;
L6815:
	asi64(R1) = x;
	asi64(R2) = y;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	x = asi64(R1);
	goto L6813;
L6816:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) %= asi64(R2);
	x = asi64(R1);
	goto L6813;
L6817:
L6813:
L6809:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6808;
	asi64(R1) = opc;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6808;
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6808;
	asi64(R1) = x;
	goto L6807;
L6807:
	return asi64(R1);
}

static i64 cc_lex_evalunaryexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 opc;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6820;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6820;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6820;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6820;
	goto L6821;
L6820:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lexm();
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	x = asi64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6823;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6824;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6825;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6826;
	goto L6827;
L6823:
	asi64(R1) = x;
	goto L6818;
	goto L6822;
L6824:
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L6818;
	goto L6822;
L6825:
	asi64(R1) = x;
	asi64(R1) = !asi64(R1);
	goto L6818;
	goto L6822;
L6826:
	asi64(R1) = x;
	asi64(R1) = ~asi64(R1);
	goto L6818;
	goto L6822;
L6827:
L6822:
	goto L6819;
L6821:
L6819:
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalterm(asu64(R1));
	goto L6818;
L6818:
	return asi64(R1);
}

static i64 cc_lex_evalterm(u64 sx) {
    u64 R1, R2, R3, R4; 
	i64 res;
	i64 lb;
	R1 = 1;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6830;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6831;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6832;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6833;
	goto L6834;
L6830:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 93;
	if (asi64(R1) == asi64(R2)) goto L6836;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6837;
	goto L6838;
L6836:
	R1 = 1;
	cc_lex_noexpand = asi64(R1);
	R1 = 0;
	lb = asi64(R1);
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6840;
	R1 = 1;
	lb = asi64(R1);
	cc_lex_lexm();
L6840:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6842;
	R1 = tou64("defined?");
	cc_lex_lxerror(asu64(R1));
L6842:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	res = asi64(R1);
	cc_lex_lexm();
	asi64(R1) = lb;
	if (!asi64(R1)) goto L6844;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6846;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L6846:
	cc_lex_lexm();
L6844:
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	goto L6835;
L6837:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6848;
	R1 = tou64("'(' expected");
	cc_lex_lxerror(asu64(R1));
L6848:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6850;
	R1 = tou64("name expected");
	cc_lex_lxerror(asu64(R1));
L6850:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L6852;
	goto L6853;
L6852:
	R1 = (u64)&cc_tables_typespecsizes;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 100;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	res = asi64(R1);
	goto L6851;
L6853:
	R1 = tou64("sizeof2");
	cc_lex_lxerror(asu64(R1));
L6851:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6855;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L6855:
	cc_lex_lexm();
	goto L6835;
L6838:
	cc_lex_lexm();
	R1 = 0;
	goto L6828;
L6835:
	goto L6829;
L6831:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	res = asi64(R1);
	cc_lex_lexm();
	goto L6829;
L6832:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6857;
	R1 = 0;
	res = asi64(R1);
	goto L6856;
L6857:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	res = asi64(R1);
L6856:
	cc_lex_lexm();
	goto L6829;
L6833:
	cc_lex_lexm();
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	res = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6859;
	R1 = tou64(") expected");
	cc_lex_lxerror(asu64(R1));
L6859:
	cc_lex_lexm();
	goto L6829;
L6834:
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_printsymbol(asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("evalterm?");
	cc_lex_lxerror(asu64(R1));
L6829:
	asi64(R1) = res;
	goto L6828;
L6828:
	return asi64(R1);
}

static i64 cc_lex_getifdef() {
    u64 R1, R2; 
	i64 res;
	u64 d;
	R1 = 1;
	cc_lex_noexpand = asi64(R1);
	cc_lex_lexreadtoken();
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6862;
	R1 = tou64("Name expected");
	cc_lex_lxerror(asu64(R1));
L6862:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	res = asi64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6864;
	R1 = 1;
	res = asi64(R1);
	goto L6863;
L6864:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L6865;
	R1 = 1;
	res = asi64(R1);
L6865:
L6863:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6867;
	R1 = tou64("EOL expected");
	cc_lex_lxerror(asu64(R1));
L6867:
	asi64(R1) = res;
	goto L6860;
L6860:
	return asi64(R1);
}

static i64 cc_lex_skipcode() {
    u64 R1, R2; 
	i64 level;
	i64 dir;
	u64 pp;
	R1 = 0;
	level = asi64(R1);
L6869:
	cc_lex_fastreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6872;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6873;
	goto L6874;
L6872:
	asi64(R1) = cc_lex_getlexdirective();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6876;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6876;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6876;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6877;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6877;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6878;
	goto L6879;
L6876:
	R1 = (u64)&level;
	(*toi64p(R1)) += 1;
	goto L6875;
L6877:
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6881;
	asi64(R1) = dir;
	goto L6868;
L6881:
	goto L6875;
L6878:
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6883;
	asi64(R1) = dir;
	goto L6868;
L6883:
	R1 = (u64)&level;
	(*toi64p(R1)) -=1;
	goto L6875;
L6879:
L6875:
	goto L6871;
L6873:
	R1 = tou64("#if:Unexpected eof");
	cc_lex_lxerror(asu64(R1));
	goto L6871;
L6874:
L6871:
	goto L6869;
	R1 = 0;
	goto L6868;
L6868:
	return asi64(R1);
}

static void cc_lex_freetokens(u64 tk) {
    u64 R1, R2; 
	u64 nexttk;
	goto L6886;
L6885:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nexttk = asu64(R1);
	asu64(R1) = nexttk;
	tk = asu64(R1);
L6886:
	asu64(R1) = tk;
	if (asu64(R1)) goto L6885;
	return;
}

static void cc_lex_fastreadtoken() {
    u64 R1, R2, R3; 
	i64 c;
	i64 csum;
	i64 hsum;
	i64 commentseen;
	i64 dodir;
	i64 j;
	u64 pstart;
	u64 p;
	u64 ss;
L6889:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 0: goto L6914;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: goto L6892;
	case 10: goto L6913;
	case 12: goto L6917;
	case 13: goto L6912;
	case 34: goto L6911;
	case 35: goto L6893;
	case 39: goto L6910;
	case 47: goto L6905;
	default: goto L6892;
    };
// SWITCH
L6893:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	dodir = asi64(R1);
	goto L6895;
L6894:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6898;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L6899;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6899;
	goto L6900;
L6898:
	R1 = 1;
	dodir = asi64(R1);
	goto L6896;
	goto L6897;
L6899:
	goto L6897;
L6900:
	goto L6896;
L6897:
	R1 = (u64)&p;
	(*tou64p(R1)) -=1;
L6895:
	asu64(R1) = p;
	asu64(R2) = cc_lex_lxstart;
	if (asu64(R1) >= asu64(R2)) goto L6894;
L6896:
	asi64(R1) = dodir;
	if (asi64(R1)) goto L6903;
	asu64(R1) = p;
	asu64(R2) = cc_lex_lxstart;
	if (asu64(R1) >= asu64(R2)) goto L6902;
L6903:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6888;
	goto L6901;
L6902:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) != asu64(R2)) goto L6904;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L6904:
L6901:
	goto L6889;
L6905:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L6907;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L6908;
	goto L6909;
L6907:
	cc_lex_readlinecomment();
	goto L6906;
L6908:
	cc_lex_readblockcomment();
	goto L6906;
L6909:
L6906:
	goto L6889;
L6910:
	R1 = 0;
	R2 = 39;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L6889;
L6911:
	R1 = 0;
	R2 = 34;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L6889;
L6912:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6889;
L6913:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6889;
L6914:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = cc_lex_lx_stackindex;
	if (!asi64(R1)) goto L6916;
	cc_lex_unstacksourcefile();
	goto L6915;
L6916:
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6888;
L6915:
	goto L6889;
L6917:
	goto L6889;
L6892:
	goto L6889;
L6888:
	return;
}

static u64 cc_lex_alloctoken() {
    u64 R1; 
	u64 tk;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	tk = asu64(R1);
	asu64(R1) = tk;
	goto L6918;
L6918:
	return asu64(R1);
}

static u64 cc_lex_alloctokenz() {
    u64 R1, R2, R3; 
	u64 tk;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	tk = asu64(R1);
	R1 = 0;
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	goto L6919;
L6919:
	return asu64(R1);
}

static void cc_lex_expandpredefmacro(i64 pdmcode, u64 tk, i64 lineno) {
    u64 R1, R2, R3; 
	struct $B16 str;
	struct $B13 tm;
	u64 s;
	i64 fileno;
// PROC LOCAL STATICS GO HERE
	static struct $B29 cc_lex_expandpredefmacro_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L6922;
	goto L6920;
L6922:
	asi64(R1) = pdmcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6924;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6925;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6926;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6927;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6928;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6929;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6930;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6931;
	goto L6932;
L6924:
	R1 = (u64)&tm;
	mlinux_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_lex_expandpredefmacro_monthnames;
	R2 = (u64)&tm;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6923;
L6925:
	R1 = (u64)&tm;
	mlinux_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("2");
	R2 = (u64)&tm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6923;
L6926:
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = tk;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6934;
	asi64(R1) = cc_decls_sfileno;
	fileno = asi64(R1);
L6934:
	asi64(R1) = cc_decls_sfileno;
	if (!asi64(R1)) goto L6936;
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = cc_decls_sfileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6935;
L6936:
	R1 = tou64("(File not available)");
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6935:
	goto L6923;
L6927:
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L6938;
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6937;
L6938:
	R1 = tou64("???");
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6937:
	goto L6923;
L6928:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = lineno;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6923;
L6929:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6923;
L6930:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6923;
L6931:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu8(R1) = cc_decls_pci_target;
	R1 = toi64(tou8(R1));
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6923;
L6932:
	msysc_m$print_startcon();
	asi64(R1) = pdmcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PDM");
	cc_lex_lxerror(asu64(R1));
L6923:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L6940;
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = tk;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = tk;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6939;
L6940:
	R1 = 3;
	asu64(R2) = tk;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = tk;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = tk;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_npastedtokens;
	R2 = 87000;
	if (asi64(R1) < asi64(R2)) goto L6942;
	R1 = tou64("2:Too many pasted tokens");
	cc_lex_lxerror(asu64(R1));
L6942:
	asu64(R1) = s;
	R2 = (u64)&cc_lex_pastedtokenlist;
	R3 = (u64)&cc_lex_npastedtokens;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = tk;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	asi64(R1) = cc_lex_npastedtokens;
	asu64(R2) = tk;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L6939:
L6920:
	return;
}

static void cc_lex_dopragmadir() {
    u64 R1, R2, R3, R4; 
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6945;
	R1 = 4;
	R2 = tou64("pack");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6947;
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6949;
	R1 = tou64("'(' expected");
	cc_lex_lxerror(asu64(R1));
L6949:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L6951;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6953;
	goto L6954;
L6953:
	R1 = 0;
	cc_decls_structpadding = asi64(R1);
	goto L6952;
L6954:
	goto L6955;
	R1 = tou64("Only pack(1) or () allowed");
	cc_lex_lxerror(asu64(R1));
L6952:
	cc_lex_lexm();
	goto L6950;
L6951:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6956;
	R1 = 1;
	cc_decls_structpadding = asi64(R1);
L6956:
L6950:
	goto L6946;
L6947:
	R1 = 6;
	R2 = tou64("module");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6957;
	R1 = 77;
	cc_lex_addbuildinfo(asi64(R1));
	goto L6946;
L6957:
	R1 = 6;
	R2 = tou64("header");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6958;
	R1 = 72;
	cc_lex_addbuildinfo(asi64(R1));
	goto L6946;
L6958:
	R1 = 4;
	R2 = tou64("link");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6959;
	R1 = 76;
	cc_lex_addbuildinfo(asi64(R1));
L6959:
L6946:
L6945:
// cc_lex.dopragmadir.finish:
L6955:
	goto L6961;
L6960:
	cc_lex_lexm();
L6961:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6963;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L6960;
L6963:
	return;
}

static void cc_lex_addbuildinfo(i64 code) {
    u64 R1, R2, R3; 
	u64 file;
	i64 j;
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6966;
	R1 = tou64("Str expected");
	cc_lex_lxerror(asu64(R1));
L6966:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file = asu64(R1);
	asi64(R1) = code;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L6968;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L6969;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L6970;
	goto L6971;
L6968:
	asi64(R1) = cc_decls_npmodules;
	R2 = 199;
	if (asi64(R1) < asi64(R2)) goto L6973;
	R1 = tou64("TMM");
	cc_lex_lxerror(asu64(R1));
L6973:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pmodulelist;
	R3 = (u64)&cc_decls_npmodules;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6967;
L6969:
	asi64(R1) = cc_decls_npheaders;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L6975;
	R1 = tou64("TMH");
	cc_lex_lxerror(asu64(R1));
L6975:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pheaderlist;
	R3 = (u64)&cc_decls_npheaders;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6967;
L6970:
	asi64(R1) = cc_decls_nplibs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L6977;
	R1 = tou64("TMLM");
	cc_lex_lxerror(asu64(R1));
L6977:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pliblist;
	R3 = (u64)&cc_decls_nplibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6967;
L6971:
L6967:
	cc_lex_lexm();
	return;
}

static i64 cc_lex_needspace(i64 a, i64 b) {
    u64 R1, R2; 
	u64 aname;
	u64 bname;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6980;
	R1 = 0;
	goto L6978;
L6980:
	R1 = (u64)&cc_tables_shortsymbolnames;
	asi64(R2) = a;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	aname = asu64(R1);
	R1 = (u64)&cc_tables_shortsymbolnames;
	asi64(R2) = b;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	bname = asu64(R1);
	asu64(R1) = bname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L6982;
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L6982;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L6983;
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L6983;
	goto L6984;
L6982:
	asu64(R1) = aname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L6986;
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L6986;
	goto L6987;
L6986:
	R1 = 1;
	goto L6978;
	goto L6985;
L6987:
L6985:
	goto L6981;
L6983:
	asu64(R1) = aname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L6989;
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L6989;
	goto L6990;
L6989:
	R1 = 1;
	goto L6978;
	goto L6988;
L6990:
L6988:
	goto L6981;
L6984:
L6981:
	R1 = 0;
	goto L6978;
L6978:
	return asi64(R1);
}

static void cc_lex_dospecialinclude() {
    u64 R1, R2; 
	R1 = 1;
	R2 = tou64("mcc.h");
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_dheaderfile;
	if (!asu64(R1)) goto L6993;
	R1 = 1;
	asu64(R2) = cc_decls_dheaderfile;
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
L6993:
	return;
}

static void cc_lex_setnumberoffset(i64 offset) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4278190080;
	asi64(R1) &= asi64(R2);
	asi64(R2) = offset;
	R3 = 16777215;
	asi64(R2) &= asi64(R3);
	asi64(R1) |= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void cc_lex_setfileno(i64 fileno) {
    u64 R1, R2, R3; 
	asi64(R1) = fileno;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asi64(R2) = fileno;
	R3 = 65280;
	asi64(R2) &= asi64(R3);
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void cc_lex_setfilenox(u64 tk, i64 fileno) {
    u64 R1, R2, R3; 
	asi64(R1) = fileno;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	asu64(R2) = tk;
	R3 = 20;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asi64(R2) = fileno;
	R3 = 65280;
	asi64(R2) &= asi64(R3);
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = tk;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 cc_lex_getfileno() {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	asi64(R1) >>= asi64(R2);
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	goto L6997;
L6997:
	return asi64(R1);
}

static i64 cc_lex_getfilenox(u64 tk) {
    u64 R1, R2, R3; 
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	asi64(R1) >>= asi64(R2);
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = tk;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	goto L6998;
L6998:
	return asi64(R1);
}

static i64 cc_lex_getnumberoffsetx(u64 tk) {
    u64 R1, R2; 
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	goto L6999;
L6999:
	return asi64(R1);
}

static void cc_lex_freehashtable() {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	u64 f;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7003;
L7001:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7005;
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L7005;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7007;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_freetokens(asu64(R1));
L7007:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L7009;
L7008:
	asu64(R1) = f;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 128;
	asu64(R2) = f;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = e;
	f = asu64(R1);
L7009:
	asu64(R1) = f;
	if (asu64(R1)) goto L7008;
	R1 = 128;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	goto L7004;
L7005:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7011;
	R1 = 0;
	asu64(R2) = d;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7011:
L7004:
	i += 1; if (i <= cc_decls_hstmask) goto L7001;
L7003:
	return;
}

static void cc_lex_regenlookup(u64 d) {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 length;
	u64 e;
	asu64(R1) = d;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	asi64(R2) = cc_decls_hstmask;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L7013:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	length = asi64(R1);
	asi64(R1) = length;
	if (asi64(R1)) goto L7016;
	R1 = 128;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = j;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = d;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_lex_nhstsymbols;
	(*toi64p(R1)) += 1;
	goto L7012;
L7016:
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 106;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L7018;
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = e;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7020;
	R1 = tou64("regenhst dupl?");
	cc_lex_lxerror(asu64(R1));
L7020:
L7018:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = cc_decls_hstsize;
	if (asi64(R1) < asi64(R2)) goto L7022;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L7024;
	R1 = tou64("REGENHST FULL?");
	mlib_abortprogram(asu64(R1));
L7024:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L7022:
	goto L7013;
L7012:
	return;
}

static void cc_lex_newhashtable() {
    u64 R1, R2, R3; 
	u64 oldhashtable;
	i64 oldhstsize;
	u64 d;
	i64 av_1;
	i64 i;
	asu64(R1) = cc_decls_hashtable;
	oldhashtable = asu64(R1);
	asi64(R1) = cc_decls_hstsize;
	oldhstsize = asi64(R1);
	R1 = 2;
	R2 = (u64)&cc_decls_hstsize;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cc_decls_hstmask = asi64(R1);
	R1 = 0;
	cc_lex_nhstsymbols = asi64(R1);
	R1 = 6;
	asi64(R2) = cc_decls_hstsize;
	asi64(R1) *= asi64(R2);
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	cc_lex_hstthreshold = asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_decls_hashtable = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7028;
L7026:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= cc_decls_hstmask) goto L7026;
L7028:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = oldhstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7031;
L7029:
	asu64(R1) = oldhashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7033;
	asu64(R1) = d;
	cc_lex_regenlookup(asu64(R1));
L7033:
	i += 1; if (i <= av_1) goto L7029;
L7031:
	asi64(R1) = oldhstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = oldhashtable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void cc_lex_old_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base) {
    u64 R1, R2, R3, R4; 
	u64 fractstart;
	i64 fractlen;
	i64 expon;
	i64 i;
	i64 c;
	i64 badexpon;
	r64 basex;
	r64 x;
	r64 expbase;
	struct $B47 realstr;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	R1 = 0;
	fractstart = asu64(R1);
	R1 = 0;
	fractlen = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L7036;
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	fractstart = asu64(R1);
	asi64(R1) = base;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = fractstart;
	asi64(R1) -= asi64(R2);
	fractlen = asi64(R1);
L7036:
	R1 = 0;
	badexpon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 101;
	if (asu64(R1) == asu64(R2)) goto L7038;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L7038;
	R2 = 112;
	if (asu64(R1) == asu64(R2)) goto L7039;
	R2 = 80;
	if (asu64(R1) == asu64(R2)) goto L7039;
	goto L7040;
L7038:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7042;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L7042:
	goto L7037;
L7039:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L7044;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L7044:
	goto L7037;
L7040:
L7037:
	asi64(R1) = badexpon;
	if (!asi64(R1)) goto L7046;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L7034;
L7046:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 102;
	if (asu64(R1) == asu64(R2)) goto L7048;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L7048;
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L7048;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L7048;
	goto L7049;
L7048:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L7047;
L7049:
	R1 = (u64)&cc_lex_alphamap;
	asu64(R2) = cc_lex_lxsptr;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7051;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L7034;
L7051:
L7047:
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L7053;
	R1 = tou64("Real too long");
	cc_lex_lxerror(asu64(R1));
L7053:
	asi64(R1) = intlen;
	if (!asi64(R1)) goto L7055;
	asi64(R1) = intlen;
	asu64(R2) = intstart;
	R3 = (u64)&realstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7055:
	asi64(R1) = fractlen;
	if (!asi64(R1)) goto L7057;
	asi64(R1) = fractlen;
	asu64(R2) = fractstart;
	R3 = (u64)&realstr;
	R4 = 0;
	R3 += (i64)R4;
	asi64(R4) = intlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7057:
	asi64(R1) = base;
	asr64(R1) = tor64(asi64(R1));
	R2 = R1;
	basex = asr64(R2);
	expbase = asr64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L7059;
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	goto L7058;
L7059:
	asi64(R1) = fractlen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 2.000000000000000000e+000;
	expbase = asr64(R1);
L7058:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7062;
L7060:
	R1 = (u64)&realstr;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7064;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7064;
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	x = asr64(R1);
	goto L7063;
L7064:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) <= asi64(R2)) goto L7065;
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 97;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) += asr64(R2);
	x = asr64(R1);
	goto L7063;
L7065:
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 65;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) += asr64(R2);
	x = asr64(R1);
L7063:
	i += 1; if (i <= av_1) goto L7060;
L7062:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7067;
	asi64(R1) = expon;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7070;
L7068:
	asr64(R1) = expbase;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_2)) goto L7068;
L7070:
	goto L7066;
L7067:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7073;
L7071:
	asr64(R1) = expbase;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_3)) goto L7071;
L7073:
L7066:
	R1 = 60;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = intstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = intstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7034:
	return;
}

static i64 cc_lex_issimpleconstmacro(u64 m) {
    u64 R1, R2, R3; 
	u64 tk;
	i64 av_1;
	i64 i;
// PROC LOCAL STATICS GO HERE
	static struct $B8 cc_lex_issimpleconstmacro_specialnames = {{
	(u64)"stdin",
	(u64)"stdout",
	(u64)"stderr"    }};
	R1 = 1;
	i = asi64(R1);
	R1 = 3;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7077;
L7075:
	asu64(R1) = m;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_lex_issimpleconstmacro_specialnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7079;
	R1 = 2;
	goto L7074;
L7079:
	i += 1; if (i <= av_1) goto L7075;
L7077:
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
	asu64(R1) = tk;
	if (!asu64(R1)) goto L7081;
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7081;
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L7084;
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) != asi64(R2)) goto L7083;
L7084:
	R1 = 1;
	goto L7074;
L7083:
L7081:
	R1 = 0;
	goto L7074;
L7074:
	return asi64(R1);
}

static void cc_parse_readmodule() {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 linkage;
	i64 m;
	i64 mbase;
	i64 commaseen;
	i64 wasdef;
	u64 p;
	u64 d;
	u64 pm;
	i64 t;
	i64 nitems;
	i64 wasenum;
	i64 exported;
	goto L7087;
L7086:
	R1 = 0;
	nitems = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7090;
	goto L7091;
L7090:
	R1 = tou64("Extra semicolon 2");
	cc_support_serror(asu64(R1));
	goto L7089;
L7091:
L7089:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	wasenum = asi64(R1);
	R1 = 0;
	exported = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L7093;
	asi64(R1) = cc_parse_readdllexport();
	exported = asi64(R1);
L7093:
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_stmodule;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L7095;
	asi64(R1) = cc_parse_readdllexport();
	exported = asi64(R1);
L7095:
	R1 = 0;
	commaseen = asi64(R1);
L7096:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7098;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7098;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7098;
	goto L7099;
L7098:
	R1 = (u64)&nitems;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_stmodule;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7101;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L7101:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7103;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7105;
	asu64(R1) = pm;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	m = asi64(R1);
L7105:
	asi64(R1) = m;
	asu64(R2) = d;
	asu64(R3) = cc_decls_stmodule;
	asu64(R1) = cc_parse_createtypedef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L7102;
L7103:
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7106;
// cc_parse.readmodule.readfn:
L7107:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7109;
	asi64(R1) = commaseen;
	if (!asi64(R1)) goto L7109;
	R1 = tou64("fn def after comma");
	cc_support_serror(asu64(R1));
L7109:
	asi64(R1) = exported;
	R2 = (u64)&wasdef;
	asu64(R3) = pm;
	asi64(R4) = linkage;
	asi64(R5) = m;
	asu64(R6) = d;
	asu64(R1) = cc_parse_readfunction(asu64(R6), asi64(R5), asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = wasdef;
	if (!asi64(R1)) goto L7111;
	goto L7097;
L7111:
	goto L7102;
L7106:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L7112;
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	goto L7107;
	goto L7102;
L7112:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readmodulevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
L7102:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7114;
	goto L7115;
L7114:
	R1 = 1;
	commaseen = asi64(R1);
	cc_lex_lex();
	goto L7113;
L7115:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7097;
L7113:
	goto L7096;
L7099:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7117;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7117;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7117;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7118;
	goto L7119;
L7117:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7097;
	goto L7116;
L7118:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7097;
	goto L7116;
L7119:
	asi64(R1) = mbase;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7116:
	goto L7096;
L7097:
L7087:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L7086;
	return;
}

static i64 cc_parse_parsemodule() {
    u64 R1, R2, R3; 
	i64 size;
	i64 t;
	u64 owner;
	r64 tsecs;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7122;
	msysc_m$print_startcon();
	R1 = tou64("Parsing:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7122:
	R1 = 0;
	R2 = R1;
	cc_parse_ingeneric = asu8(R2);
	cc_parse_loopindex = asi64(R1);
	R1 = 0;
	cc_parse_ist_symptr = asu64(R1);
	R1 = 512;
	R2 = 0;
	R3 = (u64)&cc_parse_casevaluestack;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asi64(R1) = cc_decls_mainfileno;
	R2 = tou64("PARSETEST");
	cc_lex_startlex(asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	R1 = 0;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	cc_parse_loopindex = asi64(R1);
	cc_lex_lex();
	cc_parse_readmodule();
	cc_lex_endlex();
	R1 = 1;
	goto L7120;
L7120:
	return asi64(R1);
}

static i64 cc_parse_readdeclspec(u64 owner, u64 linkage) {
    u64 R1, R2, R3; 
	struct $B76 d;
	u64 p;
	i64 t;
	i64 mod;
	i64 m;
	i64 fstruct;
	u64 pm;
	u64 e;
	R1 = 15;
	R2 = 0;
	R3 = (u64)&d;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 20;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	mod = asi64(R2);
	fstruct = asi64(R1);
L7124:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 67: goto L7177;
	case 68: case 69: case 70: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 90: goto L7127;
	case 71: goto L7129;
	case 84: case 85: goto L7171;
	case 86: goto L7164;
	case 87: goto L7156;
	case 88: goto L7128;
	case 89: goto L7167;
	case 91: goto L7174;
	default: goto L7127;
    };
// SWITCH
L7128:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	cc_lex_lex();
	goto L7124;
L7129:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: case 2: case 5: case 6: case 7: case 10: goto L7133;
	case 3: goto L7139;
	case 4: goto L7143;
	case 8: goto L7148;
	case 9: goto L7152;
	default: goto L7132;
    };
// SWITCH
L7133:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7135;
	asi64(R1) = fstruct;
	if (!asi64(R1)) goto L7137;
	R1 = 9;
	cc_lib_checksymbol(asi64(R1));
	goto L7136;
L7137:
	goto L7138;
L7136:
L7135:
	R1 = (u64)&cc_tables_typespectypes;
	R2 = (u64)&cc_decls_lx;
	R3 = 22;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L7130;
L7139:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7142;
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7142;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7141;
L7142:
	goto L7138;
L7141:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7130;
L7143:
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7146;
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7145;
L7146:
	goto L7138;
	goto L7144;
L7145:
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7147;
	R1 = 0;
	R2 = (u64)&d;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7144;
L7147:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7144:
	R1 = 1;
	mod = asi64(R1);
	goto L7130;
L7148:
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7151;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7150;
L7151:
	goto L7138;
L7150:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7130;
L7152:
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7155;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7154;
L7155:
	goto L7138;
L7154:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7130;
L7132:
// cc_parse.readdeclspec.tserror:
L7138:
	R1 = (u64)&cc_tables_typespecnames;
	R2 = (u64)&cc_decls_lx;
	R3 = 22;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("declspec/ts #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7130:
	cc_lex_lex();
	goto L7124;
L7156:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7158;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7159;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7160;
	goto L7161;
L7158:
	asu8(R1) = pc_decls_fnoconst;
	if (asu8(R1)) goto L7163;
	R1 = 1;
	R2 = (u64)&d;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7163:
	goto L7157;
L7159:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7157;
L7160:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7157;
L7161:
L7157:
	cc_lex_lex();
	goto L7124;
L7164:
	R1 = (u64)&d;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7166;
	R1 = tou64("Dual storage spec");
	cc_support_serror(asu64(R1));
L7166:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&d;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	goto L7124;
L7167:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7169;
	goto L7170;
L7169:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7168;
L7170:
L7168:
	cc_lex_lex();
	goto L7124;
L7171:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7173;
	R1 = tou64("struct?");
	cc_support_serror(asu64(R1));
L7173:
	asu64(R1) = owner;
	asi64(R1) = cc_parse_readstructdecl(asu64(R1));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	fstruct = asi64(R1);
	goto L7124;
L7174:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7176;
	R1 = tou64("enum?");
	cc_support_serror(asu64(R1));
L7176:
	asu64(R1) = owner;
	asi64(R1) = cc_parse_readenumdecl(asu64(R1));
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7124;
L7177:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7179;
	asu64(R1) = owner;
	asi64(R1) = cc_parse_isusertype(asu64(R1));
	R2 = R1;
	m = asi64(R2);
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7179;
	asi64(R1) = mod;
	if (!asi64(R1)) goto L7181;
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L7125;
L7181:
	asi64(R1) = m;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	goto L7178;
L7179:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7183;
	asi64(R1) = mod;
	if (asi64(R1)) goto L7183;
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Implicit decls not allowed: #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7183:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7185;
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7185:
	goto L7125;
L7178:
	goto L7124;
L7127:
	goto L7125;
	goto L7124;
L7125:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7187;
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L7186;
L7187:
	R1 = 3;
L7186:
	t = asi64(R1);
	R1 = (u64)&d;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7189;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7191;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7192;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7193;
	goto L7194;
L7191:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7196;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7198;
	R1 = 7;
	goto L7197;
L7198:
	R1 = 2;
L7197:
	t = asi64(R1);
	goto L7195;
L7196:
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7199;
	asu8(R1) = pc_decls_flong64;
	if (!asu8(R1)) goto L7201;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7203;
	R1 = 9;
	goto L7202;
L7203:
	R1 = 4;
L7202:
	t = asi64(R1);
	goto L7200;
L7201:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7205;
	R1 = 8;
	goto L7204;
L7205:
	R1 = 3;
L7204:
	t = asi64(R1);
L7200:
	goto L7195;
L7199:
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7206;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7208;
	R1 = 9;
	goto L7207;
L7208:
	R1 = 4;
L7207:
	t = asi64(R1);
	goto L7195;
L7206:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7209;
	R1 = 8;
	t = asi64(R1);
L7209:
L7195:
	goto L7190;
L7192:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7212;
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7212;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7211;
L7212:
	R1 = tou64("char decl?");
	cc_support_serror(asu64(R1));
L7211:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7214;
	R1 = 6;
	goto L7213;
L7214:
	R1 = 1;
L7213:
	t = asi64(R1);
	goto L7190;
L7193:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7217;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7217;
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7217;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7216;
L7217:
	R1 = tou64("dbl decl?");
	cc_support_serror(asu64(R1));
L7216:
	goto L7190;
L7194:
	asi64(R1) = mod;
	if (!asi64(R1)) goto L7219;
	R1 = tou64("declspec/float");
	cc_support_serror(asu64(R1));
L7219:
L7190:
L7189:
	R1 = (u64)&d;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7221;
	asi64(R1) = t;
	asi64(R1) = cc_lib_createconstmode(asi64(R1));
	t = asi64(R1);
L7221:
	R1 = (u64)&d;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = linkage;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = t;
	goto L7123;
L7123:
	return asi64(R1);
}

static i64 cc_parse_istypestarter() {
    u64 R1, R2, R3, R4; 
	u64 d;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L7224;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L7224;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L7225;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7226;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L7227;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L7227;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L7227;
	goto L7228;
L7224:
	R1 = 1;
	goto L7222;
	goto L7223;
L7225:
	R1 = 1;
	goto L7222;
	goto L7223;
L7226:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L7230;
	asu64(R4) = cc_decls_currproc;
	goto L7229;
L7230:
	asu64(R4) = cc_decls_stmodule;
L7229:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7232;
	asu64(R1) = d;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L7222;
L7232:
	goto L7223;
L7227:
	R1 = 1;
	goto L7222;
	goto L7223;
L7228:
L7223:
	R1 = 0;
	goto L7222;
L7222:
	return asi64(R1);
}

static i64 cc_parse_istypestarter_next() {
    u64 R1, R2, R3, R4; 
	u64 d;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L7235;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L7235;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L7236;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7237;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L7238;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L7238;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L7238;
	goto L7239;
L7235:
	R1 = 1;
	goto L7233;
	goto L7234;
L7236:
	R1 = 1;
	goto L7233;
	goto L7234;
L7237:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L7241;
	asu64(R4) = cc_decls_currproc;
	goto L7240;
L7241:
	asu64(R4) = cc_decls_stmodule;
L7240:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7243;
	asu64(R1) = d;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L7233;
L7243:
	goto L7234;
L7238:
	R1 = 1;
	goto L7233;
	goto L7234;
L7239:
L7234:
	R1 = 0;
	goto L7233;
L7233:
	return asi64(R1);
}

static u64 cc_parse_readexpression() {
    u64 R1, R2, R3; 
	u64 p;
	u64 ulist;
	u64 ulistx;
	i64 t;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7246;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7246;
	goto L7247;
L7246:
	asu64(R1) = cc_parse_readterm();
	goto L7244;
	goto L7245;
L7247:
L7245:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7249;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L7250:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7253;
	goto L7251;
L7253:
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	goto L7250;
L7251:
	asu64(R1) = ulist;
	R2 = 29;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = ulistx;
	if (!asu64(R1)) goto L7255;
	asu64(R1) = ulistx;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7255:
	asu64(R1) = p;
	goto L7244;
L7249:
	asu64(R1) = p;
	goto L7244;
L7244:
	return asu64(R1);
}

static u64 cc_parse_readassignexpr() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 r;
	i64 opc;
	i64 oldpmode;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7258;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7258;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7258;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7259;
	goto L7260;
L7258:
	asu64(R1) = cc_parse_readterm();
	goto L7256;
	goto L7257;
L7259:
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L7261;
	goto L7257;
L7260:
L7257:
	asu64(R1) = cc_parse_readcondexpr();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	switch (asi64(R1)) {
	case 11: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L7265;
	case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: goto L7264;
	default: goto L7264;
    };
// SWITCH
L7265:
// cc_parse.readassignexpr.gotp:
L7261:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldpmode = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
	asu64(R1) = cc_parse_readassignexpr();
	q = asu64(R1);
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7267;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = opc;
	asu64(R1) = cc_parse_createassignopref(asi64(R3), asu64(R2), asu64(R1));
	goto L7256;
L7267:
	asi64(R1) = oldpmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = oldpmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7269;
	R1 = tou64("Modifying read-only var");
	cc_support_terror(asu64(R1));
L7269:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L7271;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7271;
	R1 = tou64("Modifying constant?");
	cc_support_terror(asu64(R1));
L7271:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	asi64(R1) = oldpmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L7256;
	goto L7262;
L7264:
L7262:
	asu64(R1) = p;
	goto L7256;
L7256:
	return asu64(R1);
}

static u64 cc_parse_readcondexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	u64 pcond;
	i64 s;
	i64 t;
	i64 u;
	asu64(R1) = cc_parse_readorlexpr();
	pcond = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L7274;
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	x = asu64(R1);
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readcondexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7276;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7278;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7278;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7278;
	asu64(R1) = pcond;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7280;
	asu64(R1) = x;
	goto L7279;
L7280:
	asu64(R1) = y;
L7279:
	goto L7272;
L7278:
	goto L7275;
L7276:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7281;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7281;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L7275;
L7281:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7282;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7282;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7282;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7282;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	goto L7275;
L7282:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7283;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7283;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7283;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7283;
	asu64(R1) = y;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	goto L7275;
L7283:
	asi64(R1) = s;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7284;
	asi64(R1) = t;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7284;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L7275;
L7284:
	asi64(R1) = s;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L7285;
	asi64(R1) = t;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L7285;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L7275;
L7285:
	asi64(R1) = s;
	asi64(R2) = t;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L7286;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7286;
	R1 = 0;
	u = asi64(R1);
	goto L7275;
L7286:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("?: incompatible types");
	cc_support_terror(asu64(R1));
L7275:
	asu64(R1) = y;
	asu64(R2) = x;
	asu64(R3) = pcond;
	R4 = 31;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	pcond = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = pcond;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7274:
	asu64(R1) = pcond;
	goto L7272;
L7272:
	return asu64(R1);
}

static u64 cc_parse_readorlexpr() {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = cc_parse_readandlexpr();
	x = asu64(R1);
	goto L7289;
L7288:
	cc_lex_lex();
	asu64(R1) = cc_parse_readandlexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = y;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7292;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7292;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L7295;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7294;
L7295:
	R1 = 1;
	goto L7293;
L7294:
	R1 = 0;
L7293:
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7289;
L7292:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 25;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7289:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L7288;
	asu64(R1) = x;
	goto L7287;
L7287:
	return asu64(R1);
}

static u64 cc_parse_readandlexpr() {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = cc_parse_readiorexpr();
	x = asu64(R1);
	goto L7298;
L7297:
	cc_lex_lex();
	asu64(R1) = cc_parse_readiorexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = y;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7301;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7301;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7303;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7303;
	R1 = 1;
	goto L7302;
L7303:
	R1 = 0;
L7302:
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7298;
L7301:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 24;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7298:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7297;
	asu64(R1) = x;
	goto L7296;
L7296:
	return asu64(R1);
}

static u64 cc_parse_readiorexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readixorexpr();
	x = asu64(R1);
	goto L7306;
L7305:
	cc_lex_lex();
	asu64(R1) = cc_parse_readixorexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7309;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L7311;
	R1 = tou64("float|float");
	cc_support_terror(asu64(R1));
L7311:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7308;
L7309:
	R1 = tou64("invalid | operands");
	cc_support_terror(asu64(R1));
L7308:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7313;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7313;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7315;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7315;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7315;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7315;
	goto L7316;
L7315:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) |= asi64(R1);
	goto L7306;
	goto L7314;
L7316:
L7314:
L7313:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 45;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7306:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7305;
	asu64(R1) = x;
	goto L7304;
L7304:
	return asu64(R1);
}

static u64 cc_parse_readixorexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readiandexpr();
	x = asu64(R1);
	goto L7319;
L7318:
	cc_lex_lex();
	asu64(R1) = cc_parse_readiandexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7322;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L7324;
	R1 = tou64("float^float");
	cc_support_terror(asu64(R1));
L7324:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7321;
L7322:
	R1 = tou64("invalid ^ operands");
	cc_support_terror(asu64(R1));
L7321:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7326;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7326;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7328;
	goto L7329;
L7328:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) ^= asi64(R1);
	goto L7319;
	goto L7327;
L7329:
L7327:
L7326:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 46;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7319:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L7318;
	asu64(R1) = x;
	goto L7317;
L7317:
	return asu64(R1);
}

static u64 cc_parse_readiandexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readeqexpr();
	x = asu64(R1);
	goto L7332;
L7331:
	cc_lex_lex();
	asu64(R1) = cc_parse_readeqexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7335;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L7337;
	R1 = tou64("float&float");
	cc_support_terror(asu64(R1));
L7337:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7334;
L7335:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("invalid & operands");
	cc_support_terror(asu64(R1));
L7334:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7339;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7339;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7341;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7341;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7341;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7341;
	goto L7342;
L7341:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) &= asi64(R1);
	goto L7332;
	goto L7340;
L7342:
L7340:
L7339:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 44;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7332:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L7331;
	asu64(R1) = x;
	goto L7330;
L7330:
	return asu64(R1);
}

static u64 cc_parse_readeqexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 s;
	i64 t;
	i64 u;
	i64 ss;
	i64 tt;
	asu64(R1) = cc_parse_readrelexpr();
	x = asu64(R1);
	goto L7345;
L7344:
	cc_lex_lex();
	asu64(R1) = cc_parse_readrelexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7348;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7347;
L7348:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7349;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7349;
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	ss = asi64(R2);
	R2 = (u64)&cc_decls_tttarget;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	tt = asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L7351;
	asi64(R1) = ss;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7353;
	asi64(R1) = tt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7353;
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (asi64(R1)) goto L7355;
	R1 = tou64("Comparing distinct pointers/eq");
	cc_support_terror(asu64(R1));
L7355:
L7353:
L7351:
	goto L7347;
L7349:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7356;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7356;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7359;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7358;
L7359:
	R1 = tou64("Can't compare pointer to int");
	cc_support_terror(asu64(R1));
L7358:
	goto L7347;
L7356:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7360;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7360;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7363;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7362;
L7363:
	R1 = tou64("Can't compare pointer to int2");
	cc_support_terror(asu64(R1));
L7362:
	goto L7347;
L7360:
	msysc_m$print_startcon();
	R1 = tou64("U=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = u;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("invalid == operands");
	cc_support_terror(asu64(R1));
L7347:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7365;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7365;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7367;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7367;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7367;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7367;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7367;
	goto L7368;
L7367:
	asi64(R1) = opc;
	R2 = 40;
	if (asi64(R1) != asi64(R2)) goto L7370;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7369;
L7370:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7369:
	goto L7345;
	goto L7366;
L7368:
L7366:
L7365:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7345:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L7344;
	asi64(R1) = opc;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L7344;
	asu64(R1) = x;
	goto L7343;
L7343:
	return asu64(R1);
}

static u64 cc_parse_readrelexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 s;
	i64 t;
	i64 u;
	i64 a;
	i64 b;
	i64 c;
	u64 aa;
	u64 bb;
	u64 cc;
	asu64(R1) = cc_parse_readshiftexpr();
	x = asu64(R1);
	goto L7373;
L7372:
	cc_lex_lex();
	asu64(R1) = cc_parse_readshiftexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7376;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7375;
L7376:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7377;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7377;
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (asi64(R1)) goto L7379;
	R1 = tou64("Comparing distinct pointers/rel");
	cc_support_terror(asu64(R1));
L7379:
	goto L7375;
L7377:
	R1 = tou64("invalid rel operands");
	cc_support_terror(asu64(R1));
L7375:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7381;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7381;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7383;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7383;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7384;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7384;
	goto L7385;
L7383:
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L7387;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L7388;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L7389;
	goto L7390;
L7387:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	c = asi64(R1);
	goto L7386;
L7388:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	c = asi64(R1);
	goto L7386;
L7389:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	c = asi64(R1);
	goto L7386;
L7390:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	c = asi64(R1);
L7386:
	asi64(R1) = c;
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7373;
	goto L7382;
L7384:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	aa = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	bb = asu64(R1);
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L7392;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L7393;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L7394;
	goto L7395;
L7392:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	cc = asu64(R1);
	goto L7391;
L7393:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	cc = asu64(R1);
	goto L7391;
L7394:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	cc = asu64(R1);
	goto L7391;
L7395:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  >  asu64(R2);
	cc = asu64(R1);
L7391:
	asu64(R1) = cc;
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7373;
	goto L7382;
L7385:
L7382:
L7381:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7373:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L7372;
	asi64(R1) = opc;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L7372;
	asi64(R1) = opc;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L7372;
	asi64(R1) = opc;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L7372;
	asu64(R1) = x;
	goto L7371;
L7371:
	return asu64(R1);
}

static u64 cc_parse_readshiftexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 u;
	asu64(R1) = cc_parse_readaddexpr();
	x = asu64(R1);
	goto L7398;
L7397:
	cc_lex_lex();
	asu64(R1) = cc_parse_readaddexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercebasetype(asu64(R1));
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	u = asi64(R2);
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7402;
	asi64(R1) = u;
	R2 = 9;
	if (asi64(R1) <= asi64(R2)) goto L7401;
L7402:
	R1 = tou64("shift:Not an int");
	cc_support_terror(asu64(R1));
L7401:
	R1 = 3;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7404;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7404;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7406;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7406;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7407;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7407;
	goto L7408;
L7406:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L7410;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) <<= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7409;
L7410:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) >>= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7409:
	goto L7398;
	goto L7405;
L7407:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L7412;
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) <<= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7411;
L7412:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) >>= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7411:
	goto L7398;
	goto L7405;
L7408:
L7405:
L7404:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	R4 = 33;
	if (asi64(R3) != asi64(R4)) goto L7414;
	R3 = 47;
	goto L7413;
L7414:
	R3 = 48;
L7413:
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7398:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L7397;
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L7397;
	asu64(R1) = x;
	goto L7396;
L7396:
	return asu64(R1);
}

static u64 cc_parse_readaddexpr() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	i64 opc;
	asu64(R1) = cc_parse_readmulexpr();
	p = asu64(R1);
	goto L7417;
L7416:
	cc_lex_lex();
	asu64(R1) = cc_parse_readmulexpr();
	q = asu64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L7420;
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createaddop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L7419;
L7420:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsubop(asu64(R2), asu64(R1));
	p = asu64(R1);
L7419:
L7417:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L7416;
	asi64(R1) = opc;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7416;
	asu64(R1) = p;
	goto L7415;
L7415:
	return asu64(R1);
}

static u64 cc_parse_readmulexpr() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	i64 opc;
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L7423;
L7422:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	q = asu64(R1);
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7426;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L7427;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7428;
	goto L7429;
L7426:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createmulop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L7425;
L7427:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createdivop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L7425;
L7428:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createremop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L7425;
L7429:
L7425:
L7423:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7422;
	asi64(R1) = opc;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L7422;
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7422;
	asu64(R1) = p;
	goto L7421;
L7421:
	return asu64(R1);
}

static u64 cc_parse_readterm() {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	i64 t;
	i64 u;
	i64 opc;
	i64 shift;
	i64 newlen;
	i64 slength;
	i64 tbase;
	i64 fwide;
	i64 newmode;
	i64 tag;
	u64 pbyte;
	i64 a;
	u64 d;
	u64 ss;
	u64 s;
	u64 pm;
	i64 av_1;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 13: goto L7480;
	case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 26: case 27: case 28: case 30: case 31: case 33: case 34: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 62: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 93: goto L7433;
	case 23: goto L7467;
	case 24: goto L7468;
	case 25: goto L7477;
	case 29: goto L7473;
	case 32: goto L7476;
	case 35: goto L7472;
	case 36: goto L7469;
	case 37: case 38: goto L7478;
	case 39: goto L7479;
	case 59: case 60: goto L7434;
	case 61: goto L7459;
	case 63: case 64: goto L7453;
	case 67: goto L7435;
	case 92: goto L7485;
	case 94: goto L7496;
	case 95: goto L7497;
	case 96: goto L7498;
	default: goto L7433;
    };
// SWITCH
L7434:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L7431;
L7435:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L7437;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L7439;
	asu64(R4) = cc_decls_currproc;
	goto L7438;
L7439:
	asu64(R4) = cc_decls_stmodule;
L7438:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7441;
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	R2 = tou64("Undefined name \"#\"");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7441:
	goto L7436;
L7437:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7436:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7443;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7444;
	goto L7445;
L7443:
	R1 = 3;
	asu64(R2) = d;
	R3 = 88;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = tou64(toi32(R2));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L7442;
L7444:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7447;
	R1 = 5;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L7446;
L7447:
	goto L7448;
L7446:
	goto L7442;
L7445:
// cc_parse.readterm.doname:
L7448:
	asu64(R1) = d;
	asu64(R1) = cc_lib_createname(asu64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = R1;
	t = asi64(R2);
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7450;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R1) = cc_parse_createaddrofop(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L7449;
L7450:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7451;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L7451;
	asu64(R1) = p;
	cc_parse_fixmemopnd(asu64(R1));
	goto L7449;
L7451:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L7452;
L7452:
L7449:
L7442:
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	cc_lex_lex();
	goto L7431;
L7453:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	fwide = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	slength = asi64(R1);
	goto L7455;
L7454:
	asi64(R1) = slength;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	ss = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R3) = ss;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = ss;
	asi64(R4) = slength;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ss;
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ss;
	s = asu64(R1);
	asi64(R1) = newlen;
	slength = asi64(R1);
	cc_lex_lex();
L7455:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L7454;
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L7458;
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R1) = cc_lib_createwstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefwchar;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L7457;
L7458:
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R1) = cc_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7457:
	cc_lex_lex();
	goto L7431;
L7459:
	R1 = 0;
	a = asi64(R1);
	R1 = 0;
	shift = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pbyte = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L7461;
	R1 = tou64("char const too long");
	cc_support_serror(asu64(R1));
L7461:
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7464;
L7462:
	asi64(R1) = a;
	asu64(R2) = pbyte;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	a = asi64(R1);
	R1 = 8;
	R2 = (u64)&shift;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&pbyte;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L7462;
L7464:
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L7466;
	R1 = 3;
	goto L7465;
L7466:
	R1 = 4;
L7465:
	asi64(R2) = a;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L7431;
L7467:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L7431;
L7468:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createnegop(asu64(R1));
	p = asu64(R1);
	goto L7431;
L7469:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	asu64(R1) = p;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = p;
	R2 = 26;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L7471;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L7471;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7471:
	goto L7431;
L7472:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createinotop(asu64(R1));
	p = asu64(R1);
	goto L7431;
L7473:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L7475;
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L7474;
L7475:
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createaddrofop(asu64(R1));
	p = asu64(R1);
L7474:
	goto L7431;
L7476:
	R1 = tou64("rt/&&label");
	cc_support_serror(asu64(R1));
	goto L7431;
L7477:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	p = asu64(R1);
	goto L7431;
L7478:
	R1 = (u64)&cc_tables_symboltojtag;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asi64(R2) = opc;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L7431;
L7479:
	cc_lex_lex();
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readexpression();
	asu64(R1) = cc_parse_createabsop(asu64(R1));
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	goto L7431;
L7480:
	cc_lex_lex();
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L7482;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7484;
	R1 = tou64("rt/compound lit");
	cc_support_serror(asu64(R1));
	goto L7483;
L7484:
	R1 = 0;
	R2 = 1;
	asi64(R3) = t;
	asu64(R4) = cc_parse_readterm();
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
L7483:
	goto L7481;
L7482:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
L7481:
	goto L7431;
L7485:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7487;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7489;
	cc_lex_lex();
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L7491;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 9;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L7490;
L7491:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L7490:
	goto L7488;
L7489:
	R1 = 1;
	asu64(R2) = cc_parse_readterm();
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L7488:
	goto L7486;
L7487:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7493;
	asi64(R1) = cc_parse_istypestarter_next();
	if (!asi64(R1)) goto L7495;
	cc_lex_lex();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 9;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = t;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L7494;
L7495:
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L7494:
	goto L7492;
L7493:
	R1 = 0;
	asu64(R2) = cc_parse_readterm();
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L7492:
L7486:
	goto L7431;
L7496:
	asu64(R1) = cc_parse_readgeneric();
	p = asu64(R1);
	goto L7431;
L7497:
	R1 = tou64("rt/alignof");
	cc_support_serror(asu64(R1));
	goto L7431;
L7498:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	tag = asi64(R1);
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = tag;
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L7500;
	R1 = 8;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	q = asu64(R1);
	goto L7499;
L7500:
	R1 = 0;
	q = asu64(R1);
L7499:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = tag;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	goto L7431;
L7433:
	R1 = tou64("RT");
	cc_lex_ps(asu64(R1));
	R1 = tou64("Readterm?");
	cc_support_serror(asu64(R1));
L7431:
L7501:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: case 3: goto L7506;
	case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 14: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: goto L7504;
	case 13: goto L7507;
	case 15: goto L7505;
	case 37: goto L7510;
	case 38: goto L7511;
	default: goto L7504;
    };
// SWITCH
L7505:
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	q = asu64(R1);
	R1 = 16;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createindexop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L7501;
L7506:
	R1 = (u64)&cc_tables_symboltojtag;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lex();
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	asu64(R1) = d;
	asu64(R2) = p;
	asi64(R3) = opc;
	asu64(R1) = cc_parse_createdotop(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L7501;
L7507:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L7509;
	R1 = 0;
	q = asu64(R1);
	cc_lex_lex();
	goto L7508;
L7509:
	R1 = 0;
	asu64(R1) = cc_parse_readexprlist(asu64(R1));
	q = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
L7508:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createcall(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L7501;
L7510:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 73;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L7501;
L7511:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 74;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L7501;
L7504:
	goto L7502;
	goto L7501;
L7502:
	asu64(R1) = p;
	goto L7430;
L7430:
	return asu64(R1);
}

static u64 cc_parse_readexprlist(u64 p) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L7513:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7516;
	goto L7514;
L7516:
	cc_lex_lex();
	goto L7513;
L7514:
	asu64(R1) = ulist;
	goto L7512;
L7512:
	return asu64(R1);
}

static u64 cc_parse_readmodulevar(u64 d, i64 m, i64 linkage) {
    u64 R1, R2, R3, R4; 
	u64 e;
	i64 scope;
	i64 emode;
	R1 = 0;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = cc_decls_stmodule;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7519;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7521;
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = e;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("var: name in use # #");
	cc_support_serror_ss(asu64(R3), asu64(R2), asu64(R1));
L7521:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	emode = asi64(R1);
	asi64(R1) = emode;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L7523;
	asi64(R1) = m;
	asi64(R2) = emode;
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L7525;
// cc_parse.readmodulevar.redef:
L7526:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("var: redefining #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7525:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = emode;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7528;
	goto L7529;
L7528:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = emode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7531;
	asi64(R1) = m;
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L7530;
L7531:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L7532;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = emode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) == asi64(R2)) goto L7532;
	goto L7526;
L7532:
L7530:
	goto L7527;
L7529:
L7527:
L7523:
	asu64(R1) = e;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L7536;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7535;
L7536:
	asi64(R1) = scope;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7537;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7535;
L7537:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7534;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7534;
L7535:
	goto L7533;
L7534:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7538;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7538;
	R1 = 4;
	scope = asi64(R1);
L7538:
L7533:
	goto L7518;
L7519:
	R1 = 7;
	asu64(R2) = d;
	asu64(R3) = cc_decls_stmodule;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7540;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7541;
	goto L7542;
L7540:
	R1 = 2;
	scope = asi64(R1);
	goto L7539;
L7541:
	R1 = 3;
	scope = asi64(R1);
	goto L7539;
L7542:
	R1 = 4;
	scope = asi64(R1);
L7539:
L7518:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7544;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7546;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7546:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7548;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init extern #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7548:
	cc_lex_lex();
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = cc_decls_stmodule;
	asu64(R1) = cc_parse_readinitexpr(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7544:
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	goto L7517;
L7517:
	return asu64(R1);
}

static u64 cc_parse_readframevar(u64 d, i64 m, i64 linkage) {
    u64 R1, R2, R3, R4; 
	u64 pm;
	u64 e;
	i64 scope;
	i64 id;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_checkdupl_inproc(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7551;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("var: name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
	asu64(R1) = e;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L7555;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7554;
L7555:
	asi64(R1) = scope;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7556;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7554;
L7556:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7553;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7553;
L7554:
	goto L7552;
L7553:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7557;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7557;
	R1 = 4;
	scope = asi64(R1);
L7557:
L7552:
	goto L7550;
L7551:
	R1 = 8;
	id = asi64(R1);
	R1 = 1;
	scope = asi64(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7559;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7560;
	goto L7561;
L7559:
	R1 = 7;
	id = asi64(R1);
	goto L7558;
L7560:
	R1 = 3;
	scope = asi64(R1);
	R1 = 7;
	id = asi64(R1);
	goto L7558;
L7561:
L7558:
	asi64(R1) = id;
	asu64(R2) = d;
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L7550:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7563;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7565;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7565:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7567;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init extern #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7567:
	cc_lex_lex();
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = cc_decls_currproc;
	asu64(R1) = cc_parse_readinitexpr(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7563:
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	goto L7549;
L7549:
	return asu64(R1);
}

static i64 cc_parse_readtype(u64 owner, u64 d, i64 m, u64 pm) {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 modtype;
	struct $B16 modvalue;
	u64 pmx;
	i64 nmodifiers;
	i64 i;
	R1 = 0;
	nmodifiers = asi64(R1);
	R1 = 0;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&nmodifiers;
	R2 = (u64)&modvalue;
	R3 = (u64)&modtype;
	asu64(R4) = d;
	asu64(R5) = owner;
	cc_parse_readnamedtype(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = nmodifiers;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7571;
L7569:
	R1 = (u64)&modtype;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L7573;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L7574;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7575;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L7576;
	goto L7577;
L7573:
	R1 = (u64)&modvalue;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = m;
	asi64(R1) = cc_lib_createarraymode(asi64(R2), asi64(R1));
	m = asi64(R1);
	goto L7572;
L7574:
	asi64(R1) = m;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L7572;
L7575:
	asi64(R1) = m;
	asi64(R1) = cc_lib_createconstmode(asi64(R1));
	m = asi64(R1);
	goto L7572;
L7576:
	R1 = (u64)&modvalue;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pmx = asu64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7579;
	asu64(R1) = pmx;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	goto L7578;
L7579:
	asu64(R1) = pmx;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	m = asi64(R1);
L7578:
	goto L7572;
L7577:
L7572:
	i += -1; if (i >= 1) goto L7569;
L7571:
	asi64(R1) = m;
	goto L7568;
L7568:
	return asi64(R1);
}

static void cc_parse_readnamedtype(u64 owner, u64 d, u64 modtype, u64 modvalue, u64 nmodifiers) {
    u64 R1, R2, R3, R4, R5; 
	i64 length;
	struct $B16 fconst;
	i64 nrefs;
	u64 pdim;
	R1 = 0;
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	nrefs = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 89;
	if (asi64(R1) != asi64(R2)) goto L7582;
	cc_lex_lex();
L7582:
	goto L7584;
L7583:
	R1 = (u64)&nrefs;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&fconst;
	asi64(R3) = nrefs;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	cc_lex_lex();
	goto L7587;
L7586:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7590;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7591;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7591;
	goto L7592;
L7590:
	R1 = 1;
	R2 = (u64)&fconst;
	asi64(R3) = nrefs;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L7589;
L7591:
	goto L7589;
L7592:
	R1 = tou64("rnt1");
	cc_support_serror(asu64(R1));
L7589:
	cc_lex_lex();
L7587:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L7586;
L7584:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7583;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7594;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7595;
	goto L7596;
L7594:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	cc_lex_lex();
	goto L7593;
L7595:
	cc_lex_lex();
	asu64(R1) = nmodifiers;
	asu64(R2) = modvalue;
	asu64(R3) = modtype;
	asu64(R4) = d;
	asu64(R5) = owner;
	cc_parse_readnamedtype(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	goto L7593;
L7596:
L7593:
L7597:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7599;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7600;
	goto L7601;
L7599:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L7603;
	R1 = 0;
	length = asi64(R1);
	goto L7602;
L7603:
	asu64(R1) = cc_parse_readassignexpr();
	pdim = asu64(R1);
	asu64(R1) = pdim;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7605;
	asu64(R1) = pdim;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	goto L7604;
L7605:
	R1 = tou64("Can't do VLAs");
	cc_support_serror(asu64(R1));
L7604:
	R1 = 16;
	cc_lib_checksymbol(asi64(R1));
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7607;
	R1 = tou64("ZERO LEN ARRAY");
	cc_support_serror(asu64(R1));
L7607:
L7602:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7609;
	R1 = tou64("Negative array dim");
	cc_support_terror(asu64(R1));
L7609:
	cc_lex_lex();
	R1 = 65;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = modvalue;
	asu64(R3) = nmodifiers;
	asi64(R3) = *toi64p(R3);
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L7597;
L7600:
	cc_lex_lex();
	R1 = 70;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = owner;
	asu64(R1) = cc_parse_readparams(asu64(R1));
	asu64(R2) = modvalue;
	asu64(R3) = nmodifiers;
	asi64(R3) = *toi64p(R3);
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L7597;
L7601:
	goto L7598;
	goto L7597;
L7598:
	goto L7611;
L7610:
	R1 = (u64)&fconst;
	asi64(R2) = nrefs;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L7614;
	R1 = 67;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L7614:
	R1 = 82;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&nrefs;
	(*toi64p(R1)) -=1;
L7611:
	asi64(R1) = nrefs;
	if (asi64(R1)) goto L7610;
	return;
}

static i64 cc_parse_readconstintexpr() {
    u64 R1, R2, R3; 
	u64 p;
	i64 val;
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7617;
	goto L7618;
L7617:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L7615;
	goto L7616;
L7618:
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("readconstint #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7616:
	R1 = 0;
	goto L7615;
L7615:
	return asi64(R1);
}

static u64 cc_parse_readinitexpr(u64 owner, i64 m) {
    u64 R1, R2, R3; 
	i64 count;
	u64 p;
	R1 = 1;
	asi64(R2) = m;
	asu64(R3) = owner;
	asu64(R1) = cc_parse_readinitexpr2(asu64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L7619;
L7619:
	return asu64(R1);
}

static u64 cc_parse_readinitexpr2(u64 owner, i64 m, i64 istop) {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 mbase;
	i64 melem;
	i64 mm;
	i64 dim;
	i64 count;
	u64 d;
	u64 e;
	i64 braces;
	u64 newstr;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7622;
	cc_lex_lex();
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7624;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7625;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7625;
	goto L7626;
L7624:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	dim = asi64(R1);
	asi64(R1) = istop;
	if (asi64(R1)) goto L7628;
	asi64(R1) = dim;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7628;
	R1 = tou64("init/0-size array");
	cc_support_terror(asu64(R1));
L7628:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	melem = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = melem;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7630;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L7630;
	R1 = 1;
	braces = asi64(R1);
	goto L7631;
L7630:
	goto L7623;
L7625:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7633;
	R1 = tou64("init/Empty struct");
	cc_support_terror(asu64(R1));
L7633:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	melem = asi64(R1);
	goto L7623;
L7626:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L7620;
L7623:
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L7634:
	R1 = 0;
	asi64(R2) = melem;
	asu64(R3) = owner;
	asu64(R1) = cc_parse_readinitexpr2(asu64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7637;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7638;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7639;
	goto L7640;
L7637:
	asi64(R1) = dim;
	if (!asi64(R1)) goto L7642;
	asi64(R1) = count;
	asi64(R2) = dim;
	if (asi64(R1) <= asi64(R2)) goto L7642;
	R1 = tou64("Too many array elems");
	cc_support_terror(asu64(R1));
L7642:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = melem;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7644;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = melem;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7644;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L7644;
	goto L7643;
L7644:
	asi64(R1) = melem;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L7643:
	goto L7636;
L7638:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	mm = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mm;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7646;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = mm;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7646;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L7646;
	goto L7645;
L7646:
	asi64(R1) = mm;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L7645:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7648;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7650;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7650;
	R1 = tou64("Too many struct elems");
	cc_support_terror(asu64(R1));
L7650:
	goto L7647;
L7648:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	melem = asi64(R1);
L7647:
	goto L7636;
L7639:
	asi64(R1) = melem;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	goto L7651;
	goto L7636;
L7640:
L7636:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7653;
	goto L7635;
L7653:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7655;
	cc_lex_lex();
	goto L7635;
L7655:
	cc_lex_lex();
	goto L7634;
L7635:
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7657;
	asi64(R1) = dim;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7657;
	asi64(R1) = count;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = count;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = melem;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L7657:
// cc_parse.readinitexpr2.donestruct:
L7651:
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = ulist;
	R2 = 28;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = count;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L7621;
L7622:
	R1 = 0;
	braces = asi64(R1);
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7659;
	goto L7660;
L7659:
// cc_parse.readinitexpr2.doarraystring:
L7631:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L7662;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L7662;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7662;
	R1 = tou64("{} initialiser expected");
	cc_support_terror(asu64(R1));
L7662:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) == asi64(R2)) goto L7664;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) == asi64(R2)) goto L7665;
	goto L7666;
L7664:
	goto L7663;
L7665:
	goto L7663;
L7666:
	R1 = tou64("Array init");
	cc_support_terror(asu64(R1));
L7663:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	dim = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7668;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	R3 = (u64)&cc_decls_ttsize;
	asi64(R4) = m;
	*toi64p(((i64)R3+(i64)R4*8)) = asi64(R2);
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L7667;
L7668:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = dim;
	if (asi64(R1) <= asi64(R2)) goto L7670;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = dim;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L7670;
	R1 = tou64("Init str too long");
	cc_support_terror(asu64(R1));
L7670:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = dim;
	if (asi64(R1) >= asi64(R2)) goto L7672;
	asi64(R1) = dim;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	newstr = asu64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newstr;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7672:
	asi64(R1) = dim;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7667:
	asi64(R1) = braces;
	if (!asi64(R1)) goto L7674;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
L7674:
	asu64(R1) = p;
	goto L7620;
	goto L7658;
L7660:
L7658:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L7621:
	asu64(R1) = p;
	goto L7620;
L7620:
	return asu64(R1);
}

static void cc_parse_pushblock() {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 m;
	asi64(R1) = cc_decls_blocklevel;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L7677;
	R1 = tou64("Too many block levels");
	cc_support_serror(asu64(R1));
L7677:
	asi64(R1) = cc_decls_nextblockno;
	R2 = 2100;
	if (asi64(R1) < asi64(R2)) goto L7679;
	R1 = tou64("Too many blocks");
	cc_support_serror(asu64(R1));
L7679:
	R1 = (u64)&cc_decls_blocklevel;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_nextblockno;
	(*toi64p(R1)) += 1;
	asi64(R1) = cc_decls_currblockno;
	n = asi64(R1);
	asi64(R1) = cc_decls_blocklevel;
	m = asi64(R1);
	goto L7681;
L7680:
	R1 = (u64)&m;
	(*toi64p(R1)) -=1;
	R1 = (u64)&cc_decls_blockstack;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
L7681:
	asi64(R1) = m;
	if (!asi64(R1)) goto L7683;
	R1 = (u64)&cc_decls_blockcounts;
	R2 = (u64)&cc_decls_blockstack;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7680;
L7683:
	asi64(R1) = n;
	R2 = (u64)&cc_decls_blockowner;
	asi64(R3) = cc_decls_nextblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cc_decls_nextblockno;
	R2 = R1;
	R3 = (u64)&cc_decls_blockstack;
	asi64(R4) = cc_decls_blocklevel;
	*toi32p(((i64)R3+(i64)R4*4)) = asi32(R2);
	cc_decls_currblockno = asi64(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	return;
}

static void cc_parse_popblock() {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_blockstack;
	R2 = (u64)&cc_decls_blocklevel;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	cc_decls_currblockno = asi64(R1);
	return;
}

static u64 cc_parse_readcompoundstmt(i64 params) {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	cc_lex_lex();
	cc_parse_pushblock();
	asi64(R1) = params;
	if (!asi64(R1)) goto L7687;
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	R3 = 1;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L7687:
	goto L7689;
L7688:
	asu64(R1) = cc_parse_readstatement();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7692;
	goto L7689;
L7692:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L7694;
L7695:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7699;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7699;
	R1 = 8;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L7699:
	asu64(R1) = q;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7695;
	goto L7693;
L7694:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L7693:
L7689:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7688;
	cc_lex_lex();
	cc_parse_popblock();
	asu64(R1) = ulistx;
	R2 = 0;
	asu64(R3) = ulist;
	R4 = 6;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L7685;
L7685:
	return asu64(R1);
}

static u64 cc_parse_readblock(i64 ifelse) {
    u64 R1, R2; 
	asu64(R1) = cc_parse_readstatement();
	goto L7700;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 72;
	if (asi64(R1) != asi64(R2)) goto L7702;
	asi64(R1) = ifelse;
	if (!asi64(R1)) goto L7702;
	asu64(R1) = cc_parse_readstatement();
	goto L7700;
L7702:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7704;
	R1 = tou64("{...} statement expected");
	cc_support_serror(asu64(R1));
L7704:
	R1 = 0;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	goto L7700;
L7700:
	return asu64(R1);
}

static u64 cc_parse_readstatement() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 ss;
	u64 d;
	i64 index;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 9: goto L7731;
	case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 70: case 73: case 90: case 92: case 93: case 94: case 95: case 96: goto L7708;
	case 17: goto L7715;
	case 67: goto L7732;
	case 71: case 84: case 85: case 86: case 87: case 88: case 89: case 91: goto L7748;
	case 72: goto L7709;
	case 74: goto L7729;
	case 75: goto L7730;
	case 76: goto L7710;
	case 77: goto L7711;
	case 78: goto L7712;
	case 79: goto L7713;
	case 80: goto L7717;
	case 81: goto L7722;
	case 82: goto L7716;
	case 83: goto L7714;
	case 97: goto L7749;
	default: goto L7708;
    };
// SWITCH
L7709:
	asu64(R1) = cc_parse_readifstmt();
	goto L7705;
	goto L7706;
L7710:
	asu64(R1) = cc_parse_readforstmt();
	goto L7705;
	goto L7706;
L7711:
	asu64(R1) = cc_parse_readwhilestmt();
	goto L7705;
	goto L7706;
L7712:
	asu64(R1) = cc_parse_readdostmt();
	goto L7705;
	goto L7706;
L7713:
	asu64(R1) = cc_parse_readreturnstmt();
	goto L7705;
	goto L7706;
L7714:
	asu64(R1) = cc_parse_readswitchstmt();
	goto L7705;
	goto L7706;
L7715:
	R1 = 0;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	goto L7705;
	goto L7706;
L7716:
	asu64(R1) = cc_parse_readgotostmt();
	goto L7705;
	goto L7706;
L7717:
	asi64(R1) = cc_parse_loopindex;
	if (!asi64(R1)) goto L7719;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = cc_parse_loopindex;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L7721;
	R1 = 20;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L7720;
L7721:
	R1 = 23;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
L7720:
	goto L7718;
L7719:
	R1 = tou64("break outside loop/sw");
	cc_support_serror(asu64(R1));
L7718:
	goto L7706;
L7722:
	asi64(R1) = cc_parse_loopindex;
	index = asi64(R1);
	goto L7724;
L7723:
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
L7724:
	asi64(R1) = index;
	if (!asi64(R1)) goto L7726;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L7723;
L7726:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7728;
	R1 = tou64("continue outside loop");
	cc_support_serror(asu64(R1));
L7728:
	R1 = 21;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L7706;
L7729:
	asu64(R1) = cc_parse_readcaselabel();
	goto L7705;
	goto L7706;
L7730:
	cc_lex_lex();
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readstatement();
	R2 = 19;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	goto L7705;
	goto L7706;
L7731:
	cc_lex_lex();
	R1 = 0;
	goto L7705;
	goto L7706;
L7732:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L7734;
	R1 = 0;
	R2 = 17;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 3;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7736;
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7738;
	msysc_m$print_startcon();
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("2:Duplicate label");
	cc_support_terror(asu64(R1));
L7738:
	goto L7735;
L7736:
	R1 = 14;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L7735:
	R1 = -1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_lex_lex();
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7740;
	goto L7739;
L7740:
	asi64(R1) = cc_parse_istypestarter();
	if (asi64(R1)) goto L7742;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) != asi64(R2)) goto L7741;
L7742:
	goto L7739;
L7741:
	asu64(R1) = cc_parse_readstatement();
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7739:
	asu64(R1) = p;
	goto L7705;
	goto L7733;
L7734:
	R1 = 0;
	cc_parse_ist_symptr = asu64(R1);
	asu64(R1) = cc_decls_currproc;
	asi64(R1) = cc_parse_isusertype(asu64(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7744;
	goto L7745;
L7744:
	asu64(R1) = cc_parse_ist_symptr;
	if (!asu64(R1)) goto L7747;
	asu64(R1) = cc_parse_ist_symptr;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7747:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
L7733:
	goto L7706;
L7748:
// cc_parse.readstatement.doreaddecl:
L7745:
	asu64(R1) = cc_parse_readlocaldecl();
	goto L7705;
	goto L7706;
L7749:
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = cc_show_strexpr(asu64(R1));
	ss = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Mode is:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ss;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7706;
L7708:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
L7706:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L7705;
L7705:
	return asu64(R1);
}

static u64 cc_parse_readifstmt() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 pcond;
	u64 pbody;
	u64 pelse;
	i64 lineno;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	lineno = asi64(R1);
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	pelse = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L7752;
	cc_lex_lex();
	R1 = 1;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pelse = asu64(R1);
L7752:
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	asu64(R3) = pcond;
	R4 = 12;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = lineno;
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L7754;
	asu64(R1) = pbody;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7756;
	R1 = 6;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pbody = asu64(R1);
L7756:
	asu64(R1) = pbody;
	asu64(R2) = p;
	cc_parse_deleteunit(asu64(R2), asu64(R1));
	goto L7753;
L7754:
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L7757;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7759;
	R1 = 6;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pelse = asu64(R1);
L7759:
	asu64(R1) = pelse;
	asu64(R2) = p;
	cc_parse_deleteunit(asu64(R2), asu64(R1));
L7757:
L7753:
	asu64(R1) = p;
	goto L7750;
L7750:
	return asu64(R1);
}

static i64 cc_parse_iscondtrue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7761;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7761;
	R1 = 1;
	goto L7762;
L7761:
	R1 = 0;
L7762:
	goto L7760;
L7760:
	return asi64(R1);
}

static i64 cc_parse_iscondfalse(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7764;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7764;
	R1 = 1;
	goto L7765;
L7764:
	R1 = 0;
L7765:
	goto L7763;
L7763:
	return asi64(R1);
}

static void cc_parse_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B31 R1_B31; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = p;
	*(struct $B31*)(R2) = (R1_B31);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_parse_readforstmt() {
    u64 R1, R2, R3, R4; 
	u64 pinit;
	u64 pcond;
	u64 pincr;
	u64 pbody;
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 linkage;
	i64 hasblock;
	i64 m;
	i64 mbase;
	u64 pm;
	u64 d;
	cc_lex_lex();
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 0;
	hasblock = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7769;
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L7771;
	R1 = 1;
	hasblock = asi64(R1);
	cc_parse_pushblock();
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_currproc;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L7772:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7774;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7774;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7774;
	goto L7775;
L7774:
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_currproc;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7777;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L7777:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7780;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7779;
L7780:
	R1 = tou64("Not allowed in for stmt");
	cc_support_serror(asu64(R1));
L7779:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readframevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7782;
	R1 = 8;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L7782:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7784;
	goto L7785;
L7784:
	cc_lex_lex();
	goto L7783;
L7785:
	goto L7773;
L7783:
	goto L7772;
L7775:
	R1 = tou64("For decl error");
	cc_support_serror(asu64(R1));
	goto L7772;
L7773:
	asu64(R1) = ulistx;
	R2 = 0;
	asu64(R3) = ulist;
	R4 = 6;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	pinit = asu64(R1);
	goto L7770;
L7771:
	asu64(R1) = cc_parse_readexpression();
	pinit = asu64(R1);
L7770:
	goto L7768;
L7769:
	R1 = 2;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pinit = asu64(R1);
L7768:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7787;
	asu64(R1) = cc_parse_readexpression();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	goto L7786;
L7787:
	R1 = 2;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pcond = asu64(R1);
L7786:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7789;
	asu64(R1) = cc_parse_readexprstmt();
	pincr = asu64(R1);
	goto L7788;
L7789:
	R1 = 0;
	pincr = asu64(R1);
L7788:
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	asi64(R1) = hasblock;
	if (!asi64(R1)) goto L7791;
	cc_parse_popblock();
L7791:
	asu64(R1) = pcond;
	asu64(R2) = pinit;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pincr;
	asu64(R2) = pcond;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pinit;
	R3 = 13;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L7767;
L7767:
	return asu64(R1);
}

static u64 cc_parse_readwhilestmt() {
    u64 R1, R2, R3; 
	u64 pcond;
	u64 pbody;
	cc_lex_lex();
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 14;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L7792;
L7792:
	return asu64(R1);
}

static u64 cc_parse_readdostmt() {
    u64 R1, R2, R3; 
	u64 pbody;
	u64 pcond;
	cc_lex_lex();
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	R1 = 77;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 15;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L7793;
L7793:
	return asu64(R1);
}

static u64 cc_parse_readreturnstmt() {
    u64 R1, R2; 
	u64 p;
	cc_lex_lex();
	R1 = 0;
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7796;
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7798;
	R1 = tou64("Can't return value in void function");
	cc_support_terror(asu64(R1));
L7798:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 9;
	cc_lib_checksymbol(asi64(R1));
	goto L7795;
L7796:
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7799;
	R1 = tou64("Return value needed");
	cc_support_terror(asu64(R1));
L7799:
L7795:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 9;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	goto L7794;
L7794:
	return asu64(R1);
}

static u64 cc_parse_readgotostmt() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 p;
	cc_lex_lex();
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 3;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7802;
	R1 = 14;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L7802:
	R1 = 0;
	R2 = 16;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_lex_lex();
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L7800;
L7800:
	return asu64(R1);
}

static u64 cc_parse_readswitchstmt() {
    u64 R1, R2, R3; 
	u64 pindex;
	u64 pstmt;
	u64 p;
	cc_lex_lex();
	asu64(R1) = cc_parse_readcond();
	pindex = asu64(R1);
	R1 = 3;
	asu64(R2) = pindex;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	R1 = 83;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pstmt = asu64(R1);
	asu64(R1) = pstmt;
	asu64(R2) = pindex;
	R3 = 22;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&cc_parse_casevaluestack;
	asi64(R2) = cc_parse_loopindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_parse_poploop();
	asu64(R1) = p;
	goto L7803;
L7803:
	return asu64(R1);
}

static u64 cc_parse_readcaselabel() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 value;
	cc_lex_lex();
	asi64(R1) = cc_parse_readconstintexpr();
	value = asi64(R1);
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readstatement();
	R2 = 18;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = value;
	cc_parse_addcasevalue(asi64(R1));
	asu64(R1) = p;
	goto L7804;
L7804:
	return asu64(R1);
}

static u64 cc_parse_readexprstmt() {
    u64 R1; 
	asu64(R1) = cc_parse_readexpression();
	goto L7805;
L7805:
	return asu64(R1);
}

static u64 cc_parse_readcond() {
    u64 R1; 
	u64 pcond;
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readexpression();
	pcond = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = pcond;
	goto L7806;
L7806:
	return asu64(R1);
}

static i64 cc_parse_isusertype(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7809;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7811;
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L7807;
L7811:
	asu64(R1) = d;
	cc_parse_ist_symptr = asu64(R1);
L7809:
	R1 = 20;
	goto L7807;
L7807:
	return asi64(R1);
}

static u64 cc_parse_readlocaldecl() {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 m;
	i64 mbase;
	i64 linkage;
	i64 nitems;
	i64 wasenum;
	i64 wasdef;
	u64 d;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 pm;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	wasenum = asi64(R1);
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_currproc;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	nitems = asi64(R1);
L7813:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7815;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7815;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7815;
	goto L7816;
L7815:
	R1 = (u64)&nitems;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_currproc;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7818;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L7818:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7820;
	asi64(R1) = m;
	asu64(R2) = d;
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_parse_createtypedef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L7819;
L7820:
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7821;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7823;
	R1 = tou64("Nested function");
	cc_support_serror(asu64(R1));
L7823:
	R1 = 0;
	R2 = (u64)&wasdef;
	asu64(R3) = pm;
	asi64(R4) = linkage;
	asi64(R5) = m;
	asu64(R6) = d;
	asu64(R1) = cc_parse_readfunction(asu64(R6), asi64(R5), asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L7819;
L7821:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readframevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 7;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L7819:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7825;
	goto L7826;
L7825:
	cc_lex_lex();
	goto L7824;
L7826:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7814;
L7824:
	goto L7813;
L7816:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7828;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7828;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7828;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7829;
	goto L7830;
L7828:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7814;
	goto L7827;
L7829:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7814;
	goto L7827;
L7830:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Local decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7827:
	goto L7813;
L7814:
	asu64(R1) = ulist;
	goto L7812;
L7812:
	return asu64(R1);
}

static u64 cc_parse_createtypedef(u64 owner, u64 symptr, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	asu64(R3) = symptr;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7833;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7835;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Typedef name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7835:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R2) = mode;
	if (asi64(R1) == asi64(R2)) goto L7837;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L7839;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Typedef redefined or can't match types #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7839:
L7837:
	asu64(R1) = d;
	goto L7831;
L7833:
	R1 = 5;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = d;
	R2 = (u64)&cc_decls_tttypedef;
	asi64(R3) = mode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = d;
	goto L7831;
L7831:
	return asu64(R1);
}

static u64 cc_parse_readparams(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	u64 ulist;
	u64 ulistx;
	u64 pm;
	u64 q;
	i64 m;
	i64 lastbasetype;
	i64 nparams;
	i64 variadic;
	i64 flags;
	i64 nnames;
	u64 d;
	i64 names;
	i64 nonames;
	i64 reported;
	R1 = 0;
	d = asu64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	R2 = R1;
	nnames = asi64(R2);
	R2 = R1;
	nparams = asi64(R2);
	variadic = asi64(R1);
	R1 = 0;
	lastbasetype = asi64(R1);
	R1 = 0;
	names = asi64(R1);
	R1 = 0;
	nonames = asi64(R1);
	R1 = 0;
	reported = asi64(R1);
	goto L7842;
L7841:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L7845;
	R1 = 1;
	variadic = asi64(R1);
	cc_lex_lex();
	goto L7843;
L7845:
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L7847;
	R1 = (u64)&lastbasetype;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 1;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7849;
	asu64(R1) = pm;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
L7849:
	goto L7846;
L7847:
	asi64(R1) = lastbasetype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7851;
	R1 = tou64("Param type missing or misspelt");
	cc_support_serror(asu64(R1));
L7851:
	R1 = 0;
	asi64(R2) = lastbasetype;
	R3 = (u64)&pm;
	R4 = 1;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
L7846:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7853;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7854;
	goto L7855;
L7853:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L7852;
L7854:
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L7852;
L7855:
L7852:
	R1 = 24;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pm;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	if (!asu64(R1)) goto L7857;
	R1 = 1;
	names = asi64(R1);
	goto L7856;
L7857:
	R1 = 1;
	nonames = asi64(R1);
L7856:
	asi64(R1) = names;
	if (!asi64(R1)) goto L7859;
	asi64(R1) = nonames;
	if (!asi64(R1)) goto L7859;
	asi64(R1) = reported;
	if (asi64(R1)) goto L7859;
	R1 = 1;
	reported = asi64(R1);
L7859:
	asu64(R1) = d;
	if (!asu64(R1)) goto L7861;
	R1 = (u64)&nnames;
	(*toi64p(R1)) += 1;
	asu64(R1) = ulist;
	q = asu64(R1);
	goto L7863;
L7862:
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L7866;
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Param name reused # #");
	cc_support_serror_ss(asu64(R3), asu64(R2), asu64(R1));
L7866:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7863:
	asu64(R1) = q;
	if (asu64(R1)) goto L7862;
L7861:
	asu64(R1) = pm;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7868;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L7869;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7869;
	goto L7870;
L7868:
	cc_lex_lex();
	goto L7867;
L7869:
	goto L7867;
L7870:
	R1 = tou64("bad symbol in paramlist");
	cc_support_serror(asu64(R1));
L7867:
L7842:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L7841;
L7843:
	R1 = 0;
	flags = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	asi64(R1) = variadic;
	if (!asi64(R1)) goto L7872;
	R1 = 3;
	flags = asi64(R1);
	goto L7871;
L7872:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7873;
	R1 = 1;
	flags = asi64(R1);
	goto L7871;
L7873:
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7874;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7874;
	R1 = 2;
	flags = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	asu64(R2) = ulist;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7874:
L7871:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7876;
	R1 = 24;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	ulist = asu64(R1);
L7876:
	asi64(R1) = nparams;
	asu64(R2) = ulist;
	R3 = 20;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = flags;
	asu64(R2) = ulist;
	R3 = 22;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = ulist;
	goto L7840;
L7840:
	return asu64(R1);
}

static i64 cc_parse_readcasttype(u64 d, i64 allowname, u64 pm, i64 m, u64 mbase) {
    u64 R1, R2, R3, R4; 
	u64 owner;
	i64 linkage;
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L7879;
	asu64(R1) = cc_decls_currproc;
	goto L7878;
L7879:
	asu64(R1) = cc_decls_stmodule;
L7878:
	owner = asu64(R1);
	R1 = 0;
	linkage = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7881;
	R1 = (u64)&linkage;
	asu64(R2) = owner;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = mbase;
	if (!asu64(R1)) goto L7883;
	asi64(R1) = m;
	asu64(R2) = mbase;
	*toi64p(R2) = asi64(R1);
L7883:
L7881:
	R1 = 0;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7885;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7885;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7885;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7885;
	goto L7886;
L7885:
	asu64(R1) = pm;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R4) = owner;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	asu64(R1) = *tou64p(R1);
	if (!asu64(R1)) goto L7888;
	asi64(R1) = allowname;
	if (asi64(R1)) goto L7888;
	asu64(R1) = d;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("NAME not allowed in cast type #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7888:
	goto L7884;
L7886:
L7884:
	asi64(R1) = m;
	goto L7877;
L7877:
	return asi64(R1);
}

static u64 cc_parse_readfunction(u64 d, i64 m, i64 linkage, u64 pm, u64 wasdef, i64 exported) {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 owner;
	i64 scope;
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	R1 = 0;
	asu64(R2) = wasdef;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L7891;
	asu64(R1) = f;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7893;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("fn: name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7893:
	asu64(R1) = f;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7895;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7895;
	R1 = 4;
	scope = asi64(R1);
	goto L7894;
L7895:
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7896;
	R1 = 2;
	scope = asi64(R1);
L7896:
L7894:
	goto L7890;
L7891:
	R1 = 6;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7898;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7899;
	goto L7900;
L7898:
	R1 = 2;
	scope = asi64(R1);
	goto L7897;
L7899:
	R1 = 3;
	scope = asi64(R1);
	goto L7897;
L7900:
	R1 = 4;
	scope = asi64(R1);
L7897:
L7890:
	asu64(R1) = pm;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = exported;
	if (!asi64(R1)) goto L7902;
	R1 = 1;
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L7902:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7904;
	R1 = 1;
	asu64(R2) = wasdef;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7906;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't define function twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7906:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7908;
	R1 = 4;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7908:
	asu64(R1) = d;
	cc_parse_readfunctionbody(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L7910;
	R1 = tou64("; after function def");
	cc_support_serror(asu64(R1));
L7910:
L7904:
	asu64(R1) = d;
	goto L7889;
L7889:
	return asu64(R1);
}

static void cc_parse_readfunctionbody(u64 f) {
    u64 R1, R2, R3; 
	u64 e;
	u64 p;
	u64 pm;
	i64 pmcount;
	i64 av_1;
	asu64(R1) = f;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	R2 = R1;
	cc_decls_currblockno = asi64(R2);
	cc_decls_nextblockno = asi64(R1);
	R1 = 0;
	pmcount = asi64(R1);
	asu64(R1) = f;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7914;
L7912:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7916;
	goto L7915;
L7916:
	R1 = 9;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = f;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) != asu64(R2)) goto L7918;
	R1 = 1;
	asu64(R2) = e;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7918:
	R1 = 1;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = pm;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L7915:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 1;
	pmcount = asi64(R1);
	if (--asi64(av_1)) goto L7912;
L7914:
	asi64(R1) = pmcount;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = cc_decls_currproc;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	cc_decls_currproc = asu64(R1);
	return;
}

static u64 cc_parse_createnegop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7921;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7923;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7923;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7923;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7924;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7925;
	goto L7926;
L7923:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L7919;
	goto L7922;
L7924:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	R2 = 4294967295;
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L7919;
	goto L7922;
L7925:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R1) = -asr64(R1);
	asu64(R2) = p;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = p;
	goto L7919;
	goto L7922;
L7926:
L7922:
L7921:
// cc_parse.createnegop.retry:
L7927:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7929;
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L7929;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 58;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L7928;
L7929:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7930;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L7927;
	goto L7928;
L7930:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("neg bad type");
	cc_support_terror(asu64(R1));
L7928:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L7919;
L7919:
	return asu64(R1);
}

static u64 cc_parse_createabsop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7933;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7935;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7935;
	goto L7936;
L7935:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L7931;
	goto L7934;
L7936:
L7934:
L7933:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L7938;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 59;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L7937;
L7938:
	R1 = tou64("abs bad type");
	cc_support_terror(asu64(R1));
L7937:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L7931;
L7931:
	return asu64(R1);
}

static u64 cc_parse_createinotop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7941;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7943;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7943;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7943;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7943;
	goto L7944;
L7943:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = ~asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L7939;
	goto L7942;
L7944:
L7942:
L7941:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L7946;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 60;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L7945;
L7946:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("! bad type");
	cc_support_terror(asu64(R1));
L7945:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L7939;
L7939:
	return asu64(R1);
}

static u64 cc_parse_createptrop(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 t;
	i64 m;
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7949;
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("* not pointer");
	cc_support_terror(asu64(R1));
L7949:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7951;
	goto L7952;
L7951:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = q;
	goto L7947;
	goto L7950;
L7952:
L7950:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R1) = cc_parse_arraytopointer(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = q;
	goto L7947;
L7947:
	return asu64(R1);
}

static u64 cc_parse_createincrop(i64 opc, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L7956;
	asi64(R1) = t;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7955;
L7956:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7955;
	R1 = tou64("++ bad type");
	cc_support_terror(asu64(R1));
L7955:
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L7953;
L7953:
	return asu64(R1);
}

static u64 cc_parse_createaddrofop(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 q;
	i64 t;
	i64 u;
	i64 alength;
	R1 = 0;
	alength = asi64(R1);
// cc_parse.createaddrofop.restartx:
L7958:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7960;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
L7960:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7962;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7963;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7964;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L7965;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7966;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7967;
	goto L7968;
L7962:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 108;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7970;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	alength = asi64(R1);
L7970:
	goto L7961;
L7963:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7972;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7972;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7957;
L7972:
	goto L7961;
L7964:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L7974;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7974;
	R1 = 3;
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R2) += asu64(R3);
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L7957;
L7974:
	goto L7975;
	goto L7961;
L7965:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7977;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&cc_decls_tttarget;
	asu64(R3) = p;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = cc_lib_createarraymode(asi64(R2), asi64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7957;
L7977:
	goto L7961;
L7966:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L7958;
	goto L7961;
L7967:
	asu64(R1) = p;
	goto L7957;
	goto L7961;
L7968:
// cc_parse.createaddrofop.cad1:
L7975:
	R1 = 0;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
L7961:
	asu64(R1) = p;
	R2 = 55;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = alength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7957;
L7957:
	return asu64(R1);
}

static u64 cc_parse_createaddop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	i64 elemsize;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 39;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7980;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7979;
L7980:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7981;
// cc_parse.createaddop.doaddref:
L7982:
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = u;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7984;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7984;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L7978;
L7984:
	R1 = 4;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 53;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemsize;
	asu64(R2) = z;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7978;
	goto L7979;
L7981:
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7985;
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	goto L7982;
	R1 = tou64("Sub bad types");
	cc_support_terror(asu64(R1));
L7985:
L7979:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7987;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7989;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_add(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7978;
	goto L7988;
L7989:
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L7988:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7991;
	asu64(R1) = x;
	goto L7978;
L7991:
L7987:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7978;
L7978:
	return asu64(R1);
}

static u64 cc_parse_createsubop(u64 x, u64 y) {
    u64 R1, R2, R3, R4, R5; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	i64 elemsize;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 40;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7994;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7993;
L7994:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7995;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7997;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = u;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	R1 = 4;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 54;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemsize;
	asu64(R2) = z;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7992;
	goto L7996;
L7997:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7999;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7999;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asu64(R4) = x;
	R5 = 52;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) -= asi64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = x;
	goto L7992;
	goto L7998;
L7999:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	R1 = 4;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = z;
	asu64(R1) = cc_parse_divunit(asu64(R2), asi64(R1));
	z = asu64(R1);
	R1 = 4;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7992;
L7998:
L7996:
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = y;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7993;
L7995:
	R1 = tou64("Sub bad types");
	cc_support_terror(asu64(R1));
L7993:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8001;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8001;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_sub(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7992;
L8001:
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8003;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8003;
L8003:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7992;
L7992:
	return asu64(R1);
}

static u64 cc_parse_createmulop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 41;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L8006;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L8005;
L8006:
	R1 = tou64("Mul bad types");
	cc_support_terror(asu64(R1));
L8005:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8008;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8010;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_mul(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L8004;
	goto L8009;
L8010:
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L8009:
L8008:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L8004;
L8004:
	return asu64(R1);
}

static u64 cc_parse_createdivop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 42;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L8013;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L8012;
L8013:
	R1 = tou64("Div bad types");
	cc_support_terror(asu64(R1));
L8012:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8015;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8015;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_div(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L8011;
	goto L8014;
L8015:
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8016;
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8016;
	R1 = 41;
	opc = asi64(R1);
	asr64(R1) = 1.000000000000000000e+000;
	asu64(R2) = y;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) /= asr64(R2);
	asu64(R2) = y;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
L8016:
L8014:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L8011;
L8011:
	return asu64(R1);
}

static u64 cc_parse_createremop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 43;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L8019;
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8022;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8021;
L8022:
	R1 = 3;
	u = asi64(R1);
L8021:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L8018;
L8019:
	R1 = tou64("Rem bad types");
	cc_support_terror(asu64(R1));
L8018:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8024;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8024;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_rem(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L8017;
L8024:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L8017;
L8017:
	return asu64(R1);
}

static void cc_parse_insertunit(u64 p, i64 tag) {
    u64 R1, R2, R3, R4; struct $B31 R1_B31; 
	u64 q;
	R1 = 0;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = q;
	*(struct $B31*)(R2) = (R1_B31);
	asi64(R1) = tag;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 56;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_parse_eval_add(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8028;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8028;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8028;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8028;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8029;
	goto L8030;
L8028:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L8026;
	goto L8027;
L8029:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) += asr64(R1);
	asu64(R1) = x;
	goto L8026;
	goto L8027;
L8030:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L8032;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L8026;
L8032:
L8027:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L8026;
L8026:
	return asu64(R1);
}

static u64 cc_parse_eval_sub(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8035;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8035;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8035;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8035;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8036;
	goto L8037;
L8035:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = x;
	goto L8033;
	goto L8034;
L8036:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) -= asr64(R1);
	asu64(R1) = x;
	goto L8033;
	goto L8034;
L8037:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L8039;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L8041;
	R1 = tou64("EVALSUB/REF");
	cc_support_terror(asu64(R1));
L8041:
	asu64(R1) = x;
	goto L8033;
L8039:
L8034:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L8033;
L8033:
	return asu64(R1);
}

static u64 cc_parse_eval_mul(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8044;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8044;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8044;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8044;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8045;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8045;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8045;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8045;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8046;
	goto L8047;
L8044:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) *= asi64(R1);
	asu64(R1) = x;
	goto L8042;
	goto L8043;
L8045:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) *= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = x;
	goto L8042;
	goto L8043;
L8046:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) *= asr64(R1);
	asu64(R1) = x;
	goto L8042;
	goto L8043;
L8047:
L8043:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L8042;
L8042:
	return asu64(R1);
}

static u64 cc_parse_eval_div(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8050;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8050;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8051;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8051;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8052;
	goto L8053;
L8050:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8055;
	R1 = tou64("div 0");
	cc_support_serror(asu64(R1));
L8055:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	goto L8048;
	goto L8049;
L8051:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8057;
	R1 = tou64("div 0");
	cc_support_serror(asu64(R1));
L8057:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = x;
	goto L8048;
	goto L8049;
L8052:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) /= asr64(R1);
	asu64(R1) = x;
	goto L8048;
	goto L8049;
L8053:
L8049:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L8048;
L8048:
	return asu64(R1);
}

static u64 cc_parse_eval_rem(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8060;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8060;
	goto L8061;
L8060:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8063;
	R1 = tou64("rem 0");
	cc_support_serror(asu64(R1));
L8063:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) %= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	goto L8058;
	goto L8059;
L8061:
L8059:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L8058;
L8058:
	return asu64(R1);
}

static i64 cc_parse_eval_convert(u64 p, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	i64 s;
	asi64(R1) = opc;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8066;
// cc_parse.eval_convert.dosoft:
L8067:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
L8066:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L8069;
	R1 = 1;
	goto L8064;
L8069:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8071;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8071;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8071;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8071;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8072;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8072;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8072;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8072;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8073;
	goto L8074;
L8071:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8076;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8076;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8077;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8077;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8077;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8077;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8077;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8077;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8077;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8077;
	goto L8078;
L8076:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = p;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
	goto L8075;
L8077:
// cc_parse.eval_convert.dotrunc:
L8079:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8081;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8082;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8083;
	goto L8084;
L8081:
	R1 = 255;
	asu64(R2) = p;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8086;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi8(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L8086:
	goto L8080;
L8082:
	R1 = 65535;
	asu64(R2) = p;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8088;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi16(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L8088:
	goto L8080;
L8083:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4294967295;
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8090;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L8090:
	goto L8080;
L8084:
L8080:
	goto L8067;
	goto L8075;
L8078:
L8075:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8092;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
L8092:
	goto L8070;
L8072:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8094;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8094;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8095;
	goto L8096;
L8094:
	R1 = 0;
	goto L8064;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
	goto L8093;
L8095:
	goto L8079;
	goto L8093;
L8096:
L8093:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8098;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
L8098:
	goto L8070;
L8073:
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8100;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8100;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8101;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8101;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8102;
	goto L8103;
L8100:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
	goto L8099;
L8101:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
	goto L8099;
L8102:
	R1 = 10;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
	goto L8099;
L8103:
L8099:
	goto L8070;
L8074:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8105;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8107;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8109;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8109;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8109;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8109;
	goto L8110;
L8109:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L8064;
	goto L8108;
L8110:
L8108:
L8107:
L8105:
L8070:
	R1 = 0;
	goto L8064;
L8064:
	return asi64(R1);
}

static void cc_parse_coercecond(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8113;
	goto L8111;
L8113:
// cc_parse.coercecond.retry:
L8114:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8116;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8116;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8116;
	goto L8117;
L8116:
	goto L8118;
	goto L8115;
L8117:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L8120;
// cc_parse.coercecond.doint:
L8118:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8122;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L8122;
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8121;
L8122:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8123;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L8123;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8121;
L8123:
	R1 = 27;
	asu64(R2) = p;
	cc_parse_insertunit(asu64(R2), asi64(R1));
L8121:
	goto L8119;
L8120:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8124;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L8114;
	goto L8119;
L8124:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	R2 = tou64("Invalid condition #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8119:
L8115:
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8111:
	return;
}

static void cc_parse_coercebasetype(u64 p) {
    u64 R1, R2; 
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8127;
	asi64(R1) = t;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L8127;
	R1 = 3;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L8126;
L8127:
	asi64(R1) = t;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L8128;
	asi64(R1) = t;
	R2 = 7;
	if (asi64(R1) > asi64(R2)) goto L8128;
	R1 = 8;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L8128:
L8126:
	return;
}

static void cc_parse_checklvalue(u64 p, i64 assign) {
    u64 R1, R2, R3, R4; struct $B31 R1_B31; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8131;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8132;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8133;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8134;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L8135;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8136;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L8137;
	goto L8138;
L8131:
	goto L8130;
L8132:
	goto L8130;
L8133:
	asi64(R1) = assign;
	if (!asi64(R1)) goto L8140;
	goto L8141;
L8140:
	goto L8130;
L8134:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8143;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8143;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L8143;
	goto L8144;
L8143:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = p;
	*(struct $B31*)(R2) = (R1_B31);
	goto L8142;
L8144:
	R1 = tou64("CHECKLV/WIDEN");
	cc_support_terror(asu64(R1));
L8142:
	goto L8130;
L8135:
	goto L8130;
L8136:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8146;
	goto L8141;
L8146:
	goto L8130;
L8137:
	asi64(R1) = assign;
	if (!asi64(R1)) goto L8148;
	goto L8141;
L8148:
	goto L8130;
L8138:
// cc_parse.checklvalue.notlv:
L8141:
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("value: #");
	cc_support_terror_s(asu64(R2), asu64(R1));
L8130:
	return;
}

static u64 cc_parse_createcall(u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	u64 r;
	u64 s;
	u64 u;
	u64 d;
	u64 pm;
	i64 i;
	i64 nparams;
	i64 aparams;
	i64 retmode;
	i64 mproc;
	i64 m;
	i64 c;
	struct $B42 str;
	u64 ss;
	u64 tt;
	u64 uu;
	u64 exprstr;
	R1 = 0;
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8151;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8152;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8152;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L8153;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L8153;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L8153;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L8153;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L8153;
	goto L8154;
L8151:
// cc_parse.createcall.doptr:
L8155:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mproc = asi64(R1);
	goto L8157;
L8156:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mproc = asi64(R1);
	asi64(R1) = mproc;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	p = asu64(R1);
L8157:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8156;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8160;
	asi64(R1) = mproc;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Not function pointer: #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8160:
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = mproc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	retmode = asi64(R1);
	goto L8150;
L8152:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8162;
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	retmode = asi64(R1);
	goto L8161;
L8162:
	goto L8155;
L8161:
	goto L8150;
L8153:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	p = asu64(R1);
	goto L8155;
	goto L8150;
L8154:
	msysc_m$print_startcon();
	R1 = tou64("JTAGNAMES[P.TAG]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("ccall?");
	cc_support_serror(asu64(R1));
L8150:
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nparams = asi64(R1);
	R1 = 0;
	aparams = asi64(R1);
	asu64(R1) = q;
	s = asu64(R1);
	goto L8164;
L8163:
	R1 = (u64)&aparams;
	(*toi64p(R1)) += 1;
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
L8164:
	asu64(R1) = s;
	if (asu64(R1)) goto L8163;
	asi64(R1) = aparams;
	asi64(R2) = nparams;
	if (asi64(R1) >= asi64(R2)) goto L8167;
	R1 = tou64("1:Too few args");
	cc_support_terror(asu64(R1));
	goto L8166;
L8167:
	asi64(R1) = aparams;
	asi64(R2) = nparams;
	if (asi64(R1) <= asi64(R2)) goto L8168;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8168;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8168;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8170;
	msysc_m$print_startcon();
	asi64(R1) = aparams;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many args");
	cc_support_terror(asu64(R1));
L8170:
L8168:
L8166:
	asu64(R1) = q;
	s = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = aparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8173;
L8171:
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L8175;
	asu64(R1) = pm;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	cc_parse_coercemode_inplace(asu64(R2), asi64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	goto L8174;
L8175:
	asu64(R1) = s;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8177;
	R1 = tou64("Variadic param is void");
	cc_support_terror(asu64(R1));
L8177:
	asu64(R1) = s;
	cc_parse_coercebasetype(asu64(R1));
L8174:
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	i += 1; if (i <= aparams) goto L8171;
L8173:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 30;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	asi64(R1) = retmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	cc_parse_fixmemopnd(asu64(R1));
	asi64(R1) = aparams;
	asu64(R2) = r;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L8149;
L8149:
	return asu64(R1);
}

static u64 cc_parse_arraytopointer(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 offset;
	i64 t;
	i64 elemmode;
	i64 refmode;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8180;
	asi64(R1) = elemmode;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	refmode = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8182;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L8183;
	goto L8184;
L8182:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L8181;
L8183:
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	R1 = 53;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 55;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = refmode;
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8181;
L8184:
	msysc_m$print_startcon();
	R1 = tou64("ATP:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("ATP?");
	cc_support_terror(asu64(R1));
L8181:
	asi64(R1) = refmode;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8180:
	asu64(R1) = p;
	goto L8178;
L8178:
	return asu64(R1);
}

static u64 cc_parse_createindexop(u64 p, u64 q) {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createaddop(asu64(R2), asu64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	goto L8185;
L8185:
	return asu64(R1);
}

static i64 cc_parse_readstructdecl(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 currrecord;
	u64 ulist;
	u64 ulistx;
	u64 tagowner;
	i64 funion;
	i64 linkage;
	i64 mbase;
	i64 m;
	i64 offset;
	i64 recsize;
	i64 maxsize;
	i64 maxalignment;
	i64 alignment;
	i64 size;
	u64 pm;
	u64 fieldlist;
	u64 fl;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 85;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	funion = asi64(R1);
	cc_lex_lex();
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L8188;
	asu64(R1) = cc_decls_currproc;
	goto L8187;
L8188:
	asu64(R1) = cc_decls_stmodule;
L8187:
	tagowner = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8190;
	asu64(R1) = cc_lib_nextautotype();
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	d = asu64(R1);
	goto L8189;
L8190:
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8192;
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = tagowner;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L8194;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8196;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Struct tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8196:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L8186;
L8194:
	R1 = 13;
	asu64(R2) = d;
	asu64(R3) = tagowner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = funion;
	if (!asi64(R1)) goto L8198;
	R1 = 19;
	goto L8197;
L8198:
	R1 = 18;
L8197:
	asu64(R2) = e;
	asi64(R1) = cc_lib_createstructmode(asu64(R2), asi64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L8186;
L8192:
L8189:
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = tagowner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L8200;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8202;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Struct tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8202:
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8204;
	msysc_m$print_startcon();
	R1 = tou64("Prev");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1677215;
	asi64(R1) &= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asu64(R2) = e;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asu64(R2) = e;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Redefining struct #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8204:
	goto L8199;
L8200:
	R1 = 13;
	asu64(R2) = d;
	asu64(R3) = tagowner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = funion;
	if (!asi64(R1)) goto L8206;
	R1 = 19;
	goto L8205;
L8206:
	R1 = 18;
L8205:
	asu64(R2) = e;
	asi64(R1) = cc_lib_createstructmode(asu64(R2), asi64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8199:
	cc_lex_lex();
	asu64(R1) = e;
	currrecord = asu64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	R2 = R1;
	recsize = asi64(R2);
	R2 = R1;
	maxsize = asi64(R2);
	offset = asi64(R1);
	R1 = 1;
	maxalignment = asi64(R1);
	R1 = 0;
	fieldlist = asu64(R1);
	R1 = -1;
	m = asi64(R1);
	goto L8208;
L8207:
	R1 = (u64)&linkage;
	asu64(R2) = currrecord;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
L8210:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8212;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L8212;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8212;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8213;
	goto L8214;
L8212:
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = currrecord;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8216;
	R1 = tou64("Field name expected");
	cc_support_serror(asu64(R1));
L8216:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8219;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L8218;
L8219:
	R1 = tou64("typedef or function inside struct");
	cc_support_serror(asu64(R1));
L8218:
	R1 = 0;
	R2 = 4;
	asu64(R3) = d;
	asu64(R4) = currrecord;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L8221;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("member name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8221:
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8223;
	R1 = tou64("Can't use ss in struct");
	cc_support_serror(asu64(R1));
L8223:
// cc_parse.readstructdecl.addanonfield:
L8224:
	R1 = 10;
	asu64(R2) = d;
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = d;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistdef(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ulist;
	asu64(R2) = currrecord;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulistx;
	asu64(R2) = currrecord;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = currrecord;
	asu64(R2) = d;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asi64(R2) = maxalignment;
	if (asi64(R1) <= asi64(R2)) goto L8226;
	asi64(R1) = alignment;
	maxalignment = asi64(R1);
L8226:
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = cc_parse_roundoffset(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&recsize;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	asu64(R2) = d;
	R3 = (u64)&fieldlist;
	cc_parse_addnewfield(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = funion;
	if (!asi64(R1)) goto L8228;
	asi64(R1) = maxsize;
	asi64(R2) = size;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxsize = asi64(R1);
	goto L8227;
L8228:
	asi64(R1) = size;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&recsize;
	*toi64p(R2) += asi64(R1);
L8227:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8230;
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
L8230:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8232;
	goto L8233;
L8232:
	cc_lex_lex();
	goto L8231;
L8233:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L8211;
L8231:
	goto L8210;
L8213:
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L8211;
	goto L8210;
L8214:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8235;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8235;
	goto L8236;
L8235:
	asu64(R1) = cc_lib_getautofieldname();
	d = asu64(R1);
	asi64(R1) = mbase;
	m = asi64(R1);
	goto L8224;
	goto L8234;
L8236:
	asi64(R1) = m;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L8238;
	R1 = tou64("Struct decl error");
	cc_support_serror(asu64(R1));
	goto L8237;
L8238:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Struct decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8237:
L8234:
	goto L8210;
L8211:
L8208:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L8207;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = fieldlist;
	asu64(R2) = currrecord;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = maxalignment;
	asi64(R2) = funion;
	if (!asi64(R2)) goto L8240;
	asi64(R2) = maxsize;
	goto L8239;
L8240:
	asi64(R2) = recsize;
L8239:
	asi64(R1) = cc_parse_roundoffset(asi64(R2), asi64(R1));
	R2 = (u64)&cc_decls_ttsize;
	asu64(R3) = currrecord;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = maxalignment;
	asu64(R2) = currrecord;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = currrecord;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	m = asi64(R1);
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L8242;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_ttconsttype;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L8242:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = currrecord;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8245;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8245;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8245;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L8244;
L8245:
	R1 = 0;
	R2 = (u64)&cc_decls_ttisblock;
	asu64(R3) = currrecord;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8244:
	asu64(R1) = currrecord;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L8186;
L8186:
	return asi64(R1);
}

static i64 cc_parse_checkpointertypes(i64 s, i64 t, i64 hard) {
    u64 R1, R2, R3; 
	i64 starget;
	i64 ttarget;
	i64 sbase;
	i64 tbase;
	i64 sconst;
	i64 tconst;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	R1 = 0;
	sconst = asi64(R1);
	R1 = 0;
	tconst = asi64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = starget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8248;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = starget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = 1;
	sconst = asi64(R1);
L8248:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = ttarget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8250;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = ttarget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	R1 = 1;
	tconst = asi64(R1);
L8250:
	asi64(R1) = hard;
	if (asi64(R1)) goto L8252;
	asi64(R1) = sconst;
	if (!asi64(R1)) goto L8252;
	asi64(R1) = tconst;
	if (asi64(R1)) goto L8252;
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("const to non-const pointer");
	cc_support_terror(asu64(R1));
L8252:
	asi64(R1) = starget;
	asi64(R2) = ttarget;
	if (asi64(R1) != asi64(R2)) goto L8254;
	R1 = 1;
	goto L8246;
L8254:
	asi64(R1) = starget;
	s = asi64(R1);
	asi64(R1) = ttarget;
	t = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	sbase = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8256;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L8256;
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8256;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L8256;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = sbase;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = tbase;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) != asi64(R2)) goto L8258;
	R1 = 1;
	goto L8246;
L8258:
L8256:
	asi64(R1) = sbase;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8261;
	asi64(R1) = tbase;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8260;
L8261:
	R1 = 1;
	goto L8246;
L8260:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8263;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8263;
	asi64(R1) = hard;
	asi64(R2) = t;
	asi64(R3) = s;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L8246;
	goto L8262;
L8263:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8264;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8264;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) == asi64(R2)) goto L8266;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L8268;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L8268;
	msysc_m$print_startcon();
	R1 = tou64("BAD REF[]");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	goto L8246;
	R1 = 0;
	goto L8246;
L8268:
L8266:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	asi64(R1) = starget;
	asi64(R2) = ttarget;
	if (asi64(R1) != asi64(R2)) goto L8270;
	R1 = 1;
	goto L8246;
L8270:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = starget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8272;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = ttarget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8272;
	asi64(R1) = hard;
	asi64(R2) = ttarget;
	asi64(R3) = starget;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L8246;
L8272:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = starget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8274;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = ttarget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8274;
	asi64(R1) = hard;
	asi64(R2) = ttarget;
	asi64(R3) = starget;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L8246;
L8274:
	goto L8262;
L8264:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8275;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8275;
	R1 = 1;
	goto L8246;
L8275:
L8262:
	R1 = 0;
	goto L8246;
L8246:
	return asi64(R1);
}

static i64 cc_parse_comparemode(i64 s, i64 t) {
    u64 R1, R2, R3; 
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L8278;
	R1 = 1;
	goto L8276;
L8278:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8280;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8280;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = s;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8282;
	R1 = 0;
	goto L8276;
L8282:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8285;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8285;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) != asi64(R2)) goto L8284;
L8285:
	R1 = 1;
	goto L8276;
L8284:
L8280:
	R1 = 0;
	goto L8276;
L8276:
	return asi64(R1);
}

static i64 cc_parse_readenumdecl(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8288;
	asu64(R1) = owner;
	cc_parse_readenumnames(asu64(R1));
	R1 = 12;
	goto L8286;
L8288:
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8290;
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L8292;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8294;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Enum tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8294:
L8292:
	R1 = 12;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asi64(R1) = cc_lib_createenummode(asu64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L8286;
L8290:
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L8296;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8298;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Enum tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8298:
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8300;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Redefining enum #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8300:
	goto L8295;
L8296:
	R1 = 12;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asi64(R1) = cc_lib_createenummode(asu64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8295:
	asu64(R1) = owner;
	cc_parse_readenumnames(asu64(R1));
	asu64(R1) = e;
	R2 = (u64)&cc_decls_ttnamedef;
	asu64(R3) = e;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L8286;
L8286:
	return asi64(R1);
}

static void cc_parse_readenumnames(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 ulist;
	u64 ulistx;
	i64 enumseq;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	enumseq = asi64(R1);
	cc_lex_lex();
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8303;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8303;
	goto L8304;
L8303:
	goto L8302;
L8304:
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L8306;
	asu64(R1) = cc_decls_currproc;
	goto L8305;
L8306:
	asu64(R1) = cc_decls_stmodule;
L8305:
	owner = asu64(R1);
L8302:
	goto L8308;
L8307:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L8311;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("enum name reused #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L8311:
	R1 = 11;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8313;
	cc_lex_lex();
	asi64(R1) = cc_parse_readconstintexpr();
	enumseq = asi64(R1);
L8313:
	asi64(R1) = enumseq;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&enumseq;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L8315;
	cc_lex_lex();
L8315:
L8308:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8307;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	return;
}

static u64 cc_parse_createdotop(i64 opc, u64 p, u64 d) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 poffset;
	u64 pb;
	u64 pc;
	u64 e;
	u64 f;
	u64 prec;
	u64 panon;
	u64 pfield;
	u64 gend;
	i64 m;
	i64 offset;
	i64 scale;
	u64 fl;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = opc;
	R2 = 50;
	if (asi64(R1) != asi64(R2)) goto L8318;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8320;
	R1 = tou64("-> needs pointer");
	cc_support_serror(asu64(R1));
L8320:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
L8318:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8322;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8322;
	goto L8323;
L8322:
	goto L8321;
L8323:
	R1 = tou64(". -> not a struct");
	cc_support_serror(asu64(R1));
L8321:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	prec = asu64(R1);
	asu64(R1) = d;
	f = asu64(R1);
	goto L8325;
L8324:
	asu64(R1) = f;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = prec;
	if (asu64(R1) != asu64(R2)) goto L8328;
	asu64(R1) = f;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	goto L8326;
L8328:
L8325:
	asu64(R1) = f;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L8324;
L8326:
	asu64(R1) = f;
	if (asu64(R1)) goto L8330;
	asu64(R1) = d;
	gend = asu64(R1);
	goto L8332;
L8331:
	asu64(R1) = gend;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	gend = asu64(R1);
L8332:
	asu64(R1) = gend;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L8331;
	asu64(R1) = prec;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fl = asu64(R1);
	goto L8335;
L8334:
	asu64(R1) = fl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = gend;
	if (asu64(R1) != asu64(R2)) goto L8338;
	asu64(R1) = fl;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	asu64(R1) = fl;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	offset = asi64(R1);
	goto L8336;
L8338:
	asu64(R1) = fl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fl = asu64(R1);
L8335:
	asu64(R1) = fl;
	if (asu64(R1)) goto L8334;
L8336:
L8330:
	asu64(R1) = f;
	if (asu64(R1)) goto L8340;
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field of struct # #");
	cc_support_terror_ss(asu64(R3), asu64(R2), asu64(R1));
L8340:
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	poffset = asu64(R1);
	asi64(R1) = opc;
	R2 = 50;
	if (asi64(R1) != asi64(R2)) goto L8342;
	asu64(R1) = p;
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	p = asu64(R1);
L8342:
	asu64(R1) = p;
	R2 = 49;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = f;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R1) = cc_parse_arraytopointer(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = p;
	goto L8316;
L8316:
	return asu64(R1);
}

static u64 cc_parse_mulunit(u64 p, i64 elemtype) {
    u64 R1, R2, R3; 
	i64 elemsize;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8345;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8347;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8346;
L8347:
	asu64(R1) = p;
	R2 = 57;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = elemsize;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8346:
L8345:
	asu64(R1) = p;
	goto L8343;
L8343:
	return asu64(R1);
}

static u64 cc_parse_divunit(u64 p, i64 elemtype) {
    u64 R1, R2, R3; 
	i64 elemsize;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8350;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8352;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8351;
L8352:
	asu64(R1) = p;
	R2 = 57;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = elemsize;
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8351:
L8350:
	asu64(R1) = p;
	goto L8348;
L8348:
	return asu64(R1);
}

static u64 cc_parse_createassignopref(i64 opc, u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	i64 pmode;
	i64 qmode;
	i64 rmode;
	i64 elemmode;
	u64 r;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	rmode = asi64(R2);
	pmode = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = pmode;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	asu64(R1) = q;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qmode = asi64(R1);
	asi64(R1) = opc;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8355;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L8356;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L8357;
	goto L8358;
L8355:
	asi64(R1) = pmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 11;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	goto L8354;
L8356:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = qmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8360;
	R1 = tou64("ptr+=ptr");
	cc_support_serror(asu64(R1));
L8360:
	R1 = 4;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 61;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	goto L8354;
L8357:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = qmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8362;
	asi64(R1) = qmode;
	asi64(R2) = pmode;
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L8364;
	R1 = tou64("-= refs don't match");
	cc_support_serror(asu64(R1));
L8364:
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R3) = p;
	R4 = 40;
	asu64(R2) = cc_lib_createunit2(asi64(R4), asu64(R3), asu64(R2));
	asu64(R1) = cc_parse_divunit(asu64(R2), asi64(R1));
	r = asu64(R1);
	R1 = 3;
	rmode = asi64(R1);
	goto L8361;
L8362:
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 62;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
L8361:
	goto L8354;
L8358:
	R1 = tou64("Not allowed on ptrs");
	cc_support_serror(asu64(R1));
L8354:
	asi64(R1) = rmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L8353;
L8353:
	return asu64(R1);
}

static void cc_parse_addnewfield(u64 flist, u64 d, i64 offset) {
    u64 R1, R2, R3; 
	u64 e;
	u64 f;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L8367;
	R1 = 32;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	f = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = f;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8369;
L8368:
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L8369:
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L8368;
	asu64(R1) = d;
	asu64(R2) = f;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = f;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = flist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = f;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = flist;
	*tou64p(R2) = asu64(R1);
	goto L8366;
L8367:
	R1 = (u64)&cc_decls_ttnamedef;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L8372;
L8371:
	asi64(R1) = offset;
	asu64(R2) = e;
	R3 = 88;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	asu64(R3) = flist;
	cc_parse_addnewfield(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L8372:
	asu64(R1) = e;
	if (asu64(R1)) goto L8371;
L8366:
	return;
}

static void cc_parse_pushloop(i64 looptype) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_parse_loopindex;
	R2 = 64;
	if (asi64(R1) < asi64(R2)) goto L8376;
	R1 = tou64("Too many nested loop or switch");
	cc_support_serror(asu64(R1));
L8376:
	R1 = (u64)&cc_parse_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = looptype;
	R2 = (u64)&cc_parse_looptypestack;
	asi64(R3) = cc_parse_loopindex;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_parse_casevaluestack;
	asi64(R3) = cc_parse_loopindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void cc_parse_poploop() {
    u64 R1; 
	asi64(R1) = cc_parse_loopindex;
	if (!asi64(R1)) goto L8379;
	R1 = (u64)&cc_parse_loopindex;
	(*toi64p(R1)) -=1;
	goto L8378;
L8379:
	R1 = tou64("poploop?");
	cc_support_serror(asu64(R1));
L8378:
	return;
}

static void cc_parse_addcasevalue(i64 value) {
    u64 R1, R2, R3; 
	u64 p;
	i64 index;
	asi64(R1) = cc_parse_loopindex;
	index = asi64(R1);
	goto L8382;
L8381:
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
L8382:
	asi64(R1) = index;
	if (!asi64(R1)) goto L8384;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L8381;
L8384:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8386;
	R1 = tou64("case not inside switch stmt");
	cc_support_serror(asu64(R1));
L8386:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&cc_parse_casevaluestack;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&cc_parse_casevaluestack;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static i64 cc_parse_roundoffset(i64 offset, i64 alignment) {
    u64 R1, R2; 
	i64 mask;
	asi64(R1) = cc_decls_structpadding;
	if (!asi64(R1)) goto L8389;
	asi64(R1) = alignment;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8391;
	asi64(R1) = offset;
	goto L8387;
L8391:
	asi64(R1) = alignment;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mask = asi64(R1);
	goto L8393;
L8392:
	R1 = (u64)&offset;
	(*toi64p(R1)) += 1;
L8393:
	asi64(R1) = offset;
	asi64(R2) = mask;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L8392;
L8389:
	asi64(R1) = offset;
	goto L8387;
L8387:
	return asi64(R1);
}

static void cc_parse_fixmemopnd(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	asu8(R1) = cc_parse_ingeneric;
	if (!asu8(R1)) goto L8397;
	goto L8395;
L8397:
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8399;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8399;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8399;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8399;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8399;
	goto L8400;
L8399:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 56;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L8398;
L8400:
L8398:
L8395:
	return;
}

static u64 cc_parse_docast(u64 p, i64 t, i64 hard, i64 inplace) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 s;
	i64 opc;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
// cc_parse.docast.retry:
L8402:
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L8404;
	asu64(R1) = p;
	goto L8401;
L8404:
	R1 = 0;
	opc = asi64(R1);
	asi64(R1) = s;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L8406;
	asi64(R1) = t;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L8406;
	R1 = (u64)&cc_tables_conversionops;
	asi64(R2) = s;
	R1 += (i64)R2*16;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L8405;
L8406:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8407;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8407;
	asi64(R1) = hard;
	asi64(R2) = t;
	asi64(R3) = s;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L8409;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L8401;
L8409:
	goto L8405;
L8407:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8410;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	goto L8402;
	goto L8405;
L8410:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8411;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L8402;
	goto L8405;
L8411:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8412;
	asi64(R1) = s;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L8412;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8412;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8412;
	R1 = 1;
	opc = asi64(R1);
L8412:
L8405:
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8414;
	asi64(R1) = hard;
	if (asi64(R1)) goto L8416;
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = t;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asi64(R2) = s;
	asu64(R2) = cc_lib_typename(asi64(R2));
	R3 = tou64("Can't do conversion # => #");
	cc_support_terror_ss(asu64(R3), asu64(R2), asu64(R1));
L8416:
	R1 = 2;
	opc = asi64(R1);
L8414:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8418;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8419;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L8420;
	goto L8421;
L8418:
	asi64(R1) = opc;
	asi64(R2) = t;
	asu64(R3) = p;
	asi64(R1) = cc_parse_eval_convert(asu64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L8423;
	asu64(R1) = p;
	goto L8401;
L8423:
	goto L8417;
L8419:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L8401;
	goto L8417;
L8420:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8425;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8425;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L8401;
L8425:
	goto L8417;
L8421:
L8417:
	asi64(R1) = inplace;
	if (!asi64(R1)) goto L8427;
	R1 = 56;
	asu64(R2) = p;
	cc_parse_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 58;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = t;
	asi64(R1) = cc_parse_getpromotedtype(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	goto L8401;
	goto L8426;
L8427:
	asu64(R1) = p;
	R2 = 56;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = q;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asu64(R2) = q;
	R3 = 58;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = t;
	asi64(R1) = cc_parse_getpromotedtype(asi64(R1));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8426:
	asu64(R1) = q;
	goto L8401;
L8401:
	return asu64(R1);
}

static u64 cc_parse_coercemode(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 s;
	i64 opc;
	u64 q;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L8430;
	asu64(R1) = p;
	goto L8428;
L8430:
	R1 = 1;
	R2 = 0;
	asi64(R3) = t;
	asu64(R4) = p;
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	goto L8428;
L8428:
	return asu64(R1);
}

static void cc_parse_coercemode_inplace(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 s;
	i64 opc;
	u64 q;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L8433;
	goto L8431;
L8433:
	R1 = 1;
	R2 = 0;
	asi64(R3) = t;
	asu64(R4) = p;
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L8431:
	return;
}

static u64 cc_parse_createsizeofop(u64 p, i64 islength) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 t;
	i64 size;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L8436;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L8436;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L8436;
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("Not array");
	cc_support_serror(asu64(R1));
L8436:
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8438;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8439;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8440;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L8441;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L8442;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8443;
	goto L8444;
L8438:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L8446;
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	goto L8445;
L8446:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L8445:
	goto L8437;
L8439:
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) == asi64(R2)) goto L8448;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) == asi64(R2)) goto L8449;
	goto L8450;
L8448:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L8447;
L8449:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	goto L8447;
L8450:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L8447:
	goto L8437;
L8440:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8452;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L8452;
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	goto L8451;
L8452:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L8451:
	goto L8437;
L8441:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L8454;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L8456;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L8455;
L8456:
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
L8455:
	goto L8453;
L8454:
	goto L8457;
L8453:
	goto L8437;
L8442:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8459;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L8459;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L8461;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L8460;
L8461:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L8460:
	goto L8458;
L8459:
	R1 = 8;
	size = asi64(R1);
L8458:
	goto L8437;
L8443:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	goto L8434;
	goto L8437;
L8444:
// cc_parse.createsizeofop.cad1:
L8457:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L8437:
	R1 = 9;
	asi64(R2) = size;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	goto L8434;
L8434:
	return asu64(R1);
}

static u64 cc_parse_readgeneric() {
    u64 R1, R2, R3, R4, R5; 
	u64 pexpr;
	u64 pmatch;
	u64 p;
	u64 pm;
	i64 m;
	i64 t;
	i64 def;
	i64 oldingeneric;
	i64 count;
	u64 d;
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu8(R1) = cc_parse_ingeneric;
	R1 = toi64(tou8(R1));
	oldingeneric = asi64(R1);
	R1 = 1;
	cc_parse_ingeneric = asu8(R1);
	asu64(R1) = cc_parse_readassignexpr();
	pexpr = asu64(R1);
	asi64(R1) = oldingeneric;
	cc_parse_ingeneric = asu8(R1);
	asu64(R1) = pexpr;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = 0;
	pmatch = asu64(R1);
	R1 = 0;
	def = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	R1 = 8;
	cc_lib_checksymbol(asi64(R1));
L8463:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) != asi64(R2)) goto L8467;
	asi64(R1) = def;
	if (!asi64(R1)) goto L8469;
	R1 = tou64("generic/default twice");
	cc_support_serror(asu64(R1));
L8469:
	R1 = 1;
	def = asi64(R1);
	asi64(R1) = count;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8471;
	R1 = -1;
	t = asi64(R1);
	goto L8470;
L8471:
	R1 = -2;
	t = asi64(R1);
L8470:
	cc_lex_lex();
	goto L8466;
L8467:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
L8466:
	R1 = 10;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = t;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L8474;
	asi64(R1) = t;
	asi64(R2) = m;
	if (asi64(R1) != asi64(R2)) goto L8473;
L8474:
	asu64(R1) = p;
	pmatch = asu64(R1);
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
L8473:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8463;
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = pmatch;
	if (asu64(R1)) goto L8476;
	R1 = tou64("Generic: no type match");
	cc_support_serror(asu64(R1));
L8476:
	asi64(R1) = count;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L8478;
	R1 = tou64("Generic: multiple types match");
	cc_support_serror(asu64(R1));
L8478:
	asu64(R1) = pmatch;
	goto L8462;
L8462:
	return asu64(R1);
}

static i64 cc_parse_getmemmode(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L8481;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L8480;
L8481:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
L8480:
	goto L8479;
L8479:
	return asi64(R1);
}

static i64 cc_parse_getpromotedtype(i64 t) {
    u64 R1, R2; 
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8484;
	R1 = 0;
	goto L8482;
L8484:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L8486;
	R1 = 3;
	goto L8482;
L8486:
	asi64(R1) = t;
	goto L8482;
L8482:
	return asi64(R1);
}

static i64 cc_parse_readdllexport() {
    u64 R1, R2, R3; 
	i64 exported;
	R1 = 0;
	exported = asi64(R1);
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8489;
	R1 = tou64("dllexport");
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8489;
	R1 = 1;
	exported = asi64(R1);
L8489:
	cc_lex_lex();
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asi64(R1) = exported;
	goto L8487;
L8487:
	return asi64(R1);
}

static void cc_genpcl_codegen_pcl() {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	u64 pp;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8492;
	msysc_m$print_startcon();
	R1 = tou64("GenPCL:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L8492:
	asi64(R1) = cc_decls_nunits;
	R2 = 0;
	asu64(R1) = pc_api_pcl_start(asu64(R2), asi64(R1));
	cc_genpcl_dolibs();
	R1 = tou64("1:Start of code");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L8494;
L8493:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8497;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8498;
	goto L8499;
L8497:
	asu64(R1) = d;
	cc_genpcl_dostaticvar(asu64(R1));
	goto L8496;
L8498:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8501;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8502;
	goto L8503;
L8501:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8505;
	R1 = 3;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8505:
	goto L8500;
L8502:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8507;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Static fn not defined: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L8507:
	goto L8500;
L8503:
L8500:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L8509;
L8508:
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8512;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8513;
	goto L8514;
L8512:
	asu64(R1) = e;
	cc_genpcl_dostaticvar(asu64(R1));
	goto L8511;
L8513:
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8516;
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8519;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = e;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8518;
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8518;
L8519:
	asu64(R1) = e;
	cc_genpcl_dostaticvar(asu64(R1));
L8518:
L8516:
	goto L8511;
L8514:
L8511:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L8509:
	asu64(R1) = e;
	if (asu64(R1)) goto L8508;
	goto L8496;
L8499:
L8496:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L8494:
	asu64(R1) = d;
	if (asu64(R1)) goto L8493;
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L8521;
L8520:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8524;
	goto L8525;
L8524:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8527;
	asu64(R1) = d;
	cc_genpcl_genprocdef(asu64(R1));
L8527:
	goto L8523;
L8525:
L8523:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L8521:
	asu64(R1) = d;
	if (asu64(R1)) goto L8520;
	pc_api_pcl_end();
	return;
}

static void cc_genpcl_genprocdef(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	u64 e;
	u64 pm;
	i64 ismain;
	R1 = 0;
	ismain = asi64(R1);
	R1 = tou64("main");
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8530;
	R1 = 1;
	ismain = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8530:
	asu64(R1) = p;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	asi64(R2) = ismain;
	R3 = 0;
	asu64(R4) = p;
	asu64(R4) = cc_libpcl_getpsymbol(asu64(R4));
	R5 = R4;
	e = asu64(R5);
	pc_api_pc_defproc(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = e;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L8534;
L8531:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8536;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8537;
	goto L8538;
L8536:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	goto L8535;
L8537:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addlocal(asu64(R1));
	goto L8535;
L8538:
L8535:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L8534:
	asu64(R1) = d;
	if (asu64(R1)) goto L8531;
	asi64(R1) = cc_libpcl_createfwdlabel();
	cc_genpcl_retindex = asi64(R1);
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_stmt(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = ismain;
	if (!asi64(R1)) goto L8540;
	asu8(R1) = pcl_pdcc;
	if (!asu8(R1)) goto L8540;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = cc_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
L8540:
	asi64(R1) = cc_genpcl_retindex;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = ismain;
	if (!asi64(R1)) goto L8542;
	asu8(R1) = pcl_pdcc;
	if (asu8(R1)) goto L8542;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8542:
	R1 = 0;
	asu64(R2) = p;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	if (asi64(R2) == asi64(R3)) goto L8544;
	R2 = 23;
	goto L8543;
L8544:
	R2 = 20;
L8543:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	pc_api_pc_endproc();
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	return;
}

static void cc_genpcl_dostaticvar(u64 d) {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 str;
	i64 align;
	u64 e;
	u64 p;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8547;
	goto L8545;
L8547:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	align = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8549;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L8551;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$#.#.#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 7;
	R2 = (u64)&str;
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = d;
	R3 = 114;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8550;
L8551:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8550:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = align;
	pc_api_pc_setalign(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 1;
	asu64(R4) = d;
	R5 = 72;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8548;
L8549:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 124;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = align;
	pc_api_pc_setalign(asi64(R1));
L8548:
L8545:
	return;
}

static void cc_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset) {
    u64 R1, R2, R3, R4, R5; 
	i64 t;
	i64 length;
	i64 n;
	i64 i;
	i64 j;
	i64 nwords;
	i64 offset1;
	i64 offset2;
	i64 size;
	i64 padding;
	i64 isunion;
	u64 q;
	u64 a;
	u64 b;
	u64 d;
	r32 sx;
	struct $B16 str;
	struct $B3 str2;
	i64 av_1;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8554;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8555;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8556;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8556;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L8557;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L8558;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L8559;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L8559;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L8560;
	goto L8561;
L8554:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8563;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8566;
L8564:
	R1 = 0;
	R2 = 1;
	R3 = 1;
	asu64(R4) = q;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= n) goto L8564;
L8566:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L8568;
	asi64(R1) = length;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
L8568:
	goto L8562;
L8563:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 19;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isunion = asi64(R1);
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	R1 = 0;
	R2 = R1;
	offset2 = asi64(R2);
	offset1 = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8571;
L8569:
	R1 = 0;
	R2 = 1;
	R3 = 0;
	asu64(R4) = q;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = q;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&offset1;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L8573;
	asi64(R1) = isunion;
	if (asi64(R1)) goto L8573;
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset2 = asi64(R1);
	goto L8572;
L8573:
	asi64(R1) = size;
	offset2 = asi64(R1);
L8572:
	asi64(R1) = offset2;
	asi64(R2) = offset1;
	asi64(R1) -= asi64(R2);
	padding = asi64(R1);
	asi64(R1) = padding;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8575;
	asi64(R1) = offset2;
	asi64(R2) = offset1;
	asi64(R1) -= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
	asi64(R1) = offset2;
	offset1 = asi64(R1);
L8575:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= n) goto L8569;
L8571:
	asi64(R1) = offset2;
	asi64(R2) = size;
	if (asi64(R1) >= asi64(R2)) goto L8577;
	asi64(R1) = size;
	asi64(R2) = offset2;
	asi64(R1) -= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
L8577:
L8562:
	goto L8552;
	goto L8553;
L8555:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (asi64(R1)) goto L8580;
	asi64(R1) = t;
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L8579;
L8580:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8582;
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	sx = asr32(R1);
	R1 = (u64)&sx;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8581;
L8582:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8581:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	goto L8578;
L8579:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L8583;
	R1 = 0;
	padding = asi64(R1);
// cc_genpcl.genidata.doref:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8586;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8585;
L8586:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8587;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genstring(asu64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8585;
L8587:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8588;
	R1 = 0;
	R2 = tou64("GENIDATA/WSTRING2");
	cc_support_gerror(asu64(R2), asu64(R1));
	asi64(R1) = padding;
	cc_genpcl_doresb(asi64(R1));
	goto L8585;
L8588:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8585:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	goto L8578;
L8583:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8589;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	padding = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8592;
L8590:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 6;
	cc_libpcl_setmode(asi64(R1));
	i += 1; if (i <= av_1) goto L8590;
L8592:
	asi64(R1) = padding;
	cc_genpcl_doresb(asi64(R1));
	goto L8578;
L8589:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("IDATA/SCALAR");
	cc_support_gerror(asu64(R2), asu64(R1));
L8578:
	goto L8552;
	goto L8553;
L8556:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8594;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8594;
	goto L8595;
L8594:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L8593;
L8595:
	asu64(R1) = p;
	R2 = tou64("Idata &frame");
	cc_support_gerror(asu64(R2), asu64(R1));
L8593:
	goto L8552;
	goto L8553;
L8557:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8597;
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8597;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8599;
	goto L8600;
L8599:
	R1 = tou64("`");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8602;
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(",");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L8602:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("+");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	asu64(R2) = b;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = pc_api_genname(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8598;
L8600:
	R1 = 0;
	R2 = tou64("Add/Idata &frame");
	cc_support_gerror(asu64(R2), asu64(R1));
L8598:
	goto L8596;
L8597:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8603;
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8603;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L8603;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64("+");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = pc_api_genname(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8596;
L8603:
	R1 = 0;
	R2 = tou64("1:Runtime or unsupported expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L8596:
	goto L8552;
	goto L8553;
L8558:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L8605;
	asi64(R1) = offset;
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8604;
L8605:
	asi64(R1) = offset;
	R2 = 0;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L8604:
	goto L8553;
L8559:
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8607;
	R1 = 0;
	R2 = tou64("Complex ptr expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L8607:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8553;
L8560:
	asi64(R1) = offset;
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8553;
L8561:
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = tou64("2:Runtime expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L8553:
L8552:
	return;
}

static void cc_genpcl_doresb(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	goto L8610;
L8609:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
L8610:
	asi64(R1) = n;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L8609;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8614;
L8612:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 6;
	cc_libpcl_setmode(asi64(R1));
	if (--asi64(av_1)) goto L8612;
L8614:
	return;
}

static void cc_genpcl_pushint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_genpcl_dolibs() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8619;
L8617:
	R1 = (u64)&cc_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pc_api_pc_addplib(asu64(R1));
	i += 1; if (i <= cc_decls_nlibfiles) goto L8617;
L8619:
	return;
}

static void cc_blockpcl_do_stmt(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 oldclineno;
	u64 a;
	u64 b;
	u64 d;
	asu64(R1) = p;
	if (asu64(R1)) goto L8622;
	goto L8620;
L8622:
	asi64(R1) = cc_decls_clineno;
	oldclineno = asi64(R1);
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_clineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_decls_cfileno = asi64(R1);
	asi64(R1) = cc_decls_cfileno;
	R2 = 24;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = cc_decls_clineno;
	asi64(R1) += asi64(R2);
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 6: goto L8626;
	case 7: case 10: case 24: case 25: case 26: case 27: case 28: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: goto L8625;
	case 8: goto L8630;
	case 9: goto L8632;
	case 11: goto L8633;
	case 12: case 31: goto L8634;
	case 13: goto L8635;
	case 14: goto L8636;
	case 15: goto L8637;
	case 16: goto L8638;
	case 17: goto L8639;
	case 18: goto L8640;
	case 19: goto L8641;
	case 20: goto L8643;
	case 21: goto L8644;
	case 22: goto L8645;
	case 23: goto L8642;
	case 29: goto L8660;
	case 30: goto L8631;
	case 61: goto L8646;
	case 62: goto L8647;
	case 63: goto L8648;
	case 64: goto L8649;
	case 65: goto L8652;
	case 66: goto L8653;
	case 67: goto L8654;
	case 68: goto L8655;
	case 69: goto L8656;
	case 70: goto L8657;
	case 71: case 73: goto L8658;
	case 72: case 74: goto L8659;
	default: goto L8625;
    };
// SWITCH
L8626:
	goto L8628;
L8627:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L8628:
	asu64(R1) = a;
	if (asu64(R1)) goto L8627;
	goto L8623;
L8630:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_decl(asu64(R1));
	goto L8623;
L8631:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_call(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L8623;
L8632:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_do_return(asu64(R2), asu64(R1));
	goto L8623;
L8633:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_assign(asu64(R3), asu64(R2), asi64(R1));
	goto L8623;
L8634:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_if(asu64(R3), asu64(R2), asu64(R1));
	goto L8623;
L8635:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_for(asu64(R2), asu64(R1));
	goto L8623;
L8636:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_while(asu64(R2), asu64(R1));
	goto L8623;
L8637:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_dowhile(asu64(R2), asu64(R1));
	goto L8623;
L8638:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_goto(asu64(R1));
	goto L8623;
L8639:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_labeldef(asu64(R1));
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L8623;
L8640:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_do_casestmt(asu64(R2), asu64(R1));
	goto L8623;
L8641:
	R1 = 1;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = cc_blockpcl_sw_defaultlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L8623;
L8642:
	asi64(R1) = cc_blockpcl_sw_breaklabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L8623;
L8643:
	R1 = (u64)&cc_blockpcl_breakstack;
	asi64(R2) = cc_blockpcl_loopindex;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	cc_blockpcl_genjumpl(asi64(R1));
	goto L8623;
L8644:
	R1 = (u64)&cc_blockpcl_continuestack;
	asi64(R2) = cc_blockpcl_loopindex;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	cc_blockpcl_genjumpl(asi64(R1));
	goto L8623;
L8645:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_do_switch(asu64(R3), asu64(R2), asu64(R1));
	goto L8623;
L8646:
	R1 = 0;
	R2 = 90;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8647:
	R1 = 0;
	R2 = 91;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8648:
	R1 = 0;
	R2 = 92;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8649:
	R1 = 0;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = cc_lib_isrealcc(asi64(R2));
	if (!asi64(R2)) goto L8651;
	R2 = 93;
	goto L8650;
L8651:
	R2 = 94;
L8650:
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8652:
	R1 = 0;
	R2 = 95;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8653:
	R1 = 0;
	R2 = 96;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8654:
	R1 = 0;
	R2 = 97;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8655:
	R1 = 0;
	R2 = 98;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8656:
	R1 = 0;
	R2 = 99;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8657:
	R1 = 0;
	R2 = 100;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8623;
L8658:
	R1 = 84;
	asu64(R2) = a;
	cc_blockpcl_do_preincr(asu64(R2), asi64(R1));
	goto L8623;
L8659:
	R1 = 85;
	asu64(R2) = a;
	cc_blockpcl_do_preincr(asu64(R2), asi64(R1));
	goto L8623;
L8660:
	goto L8662;
L8661:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L8662:
	asu64(R1) = a;
	if (asu64(R1)) goto L8661;
	goto L8623;
L8625:
	R1 = 0;
	asu64(R2) = p;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L8665;
	asu64(R1) = a;
	goto L8664;
L8665:
	asu64(R1) = p;
L8664:
	cc_libpcl_setmode_u(asu64(R1));
L8623:
L8620:
	return;
}

static void cc_blockpcl_dx_expr(u64 p, i64 am) {
    u64 R1, R2, R3, R4, R5; 
	i64 oldclineno;
	i64 value;
	i64 m;
	u64 a;
	u64 b;
	struct $B16 str;
	u64 d;
	asu64(R1) = p;
	if (asu64(R1)) goto L8668;
	goto L8666;
L8668:
	asi64(R1) = cc_decls_clineno;
	oldclineno = asi64(R1);
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_clineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_decls_cfileno = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 1: goto L8672;
	case 2: case 6: case 7: case 8: case 9: case 10: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 28: case 32: case 50: case 51: case 59: goto L8671;
	case 3: goto L8673;
	case 4: goto L8674;
	case 5: goto L8675;
	case 11: goto L8676;
	case 24: case 25: goto L8677;
	case 26: goto L8678;
	case 27: goto L8685;
	case 29: goto L8688;
	case 30: goto L8699;
	case 31: goto L8700;
	case 33: case 34: case 35: case 36: case 37: case 38: goto L8701;
	case 39: goto L8702;
	case 40: goto L8705;
	case 41: goto L8706;
	case 42: goto L8707;
	case 43: goto L8710;
	case 44: goto L8711;
	case 45: goto L8712;
	case 46: goto L8713;
	case 47: goto L8714;
	case 48: goto L8715;
	case 49: goto L8740;
	case 52: goto L8716;
	case 53: goto L8717;
	case 54: goto L8718;
	case 55: goto L8739;
	case 56: goto L8719;
	case 57: goto L8722;
	case 58: goto L8723;
	case 60: goto L8724;
	case 61: goto L8727;
	case 62: goto L8728;
	case 63: goto L8729;
	case 64: goto L8730;
	case 65: goto L8733;
	case 66: goto L8734;
	case 67: goto L8735;
	case 68: goto L8736;
	case 69: goto L8737;
	case 70: goto L8738;
	case 71: case 72: goto L8725;
	case 73: case 74: goto L8726;
	case 75: goto L8741;
	case 76: goto L8742;
	default: goto L8671;
    };
// SWITCH
L8672:
	asu64(R1) = p;
	cc_blockpcl_dx_const(asu64(R1));
	goto L8669;
L8673:
	asi64(R1) = am;
	asu64(R2) = p;
	cc_blockpcl_dx_name(asu64(R2), asi64(R1));
	goto L8669;
L8674:
	asi64(R1) = am;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	goto L8669;
L8675:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L8669;
L8676:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_assign(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8677:
	asu64(R1) = p;
	cc_blockpcl_dx_andorl(asu64(R1));
	goto L8669;
L8678:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L8680;
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = cc_blockpcl_isboolexpr(asu64(R1));
	if (asi64(R1)) goto L8682;
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode2(asi64(R1));
L8682:
	goto L8679;
L8680:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_blockpcl_isboolexpr(asu64(R1));
	if (asi64(R1)) goto L8684;
	R1 = 0;
	R2 = 65;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8683;
L8684:
	R1 = 0;
	R2 = 63;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8683:
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
L8679:
	goto L8669;
L8685:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_blockpcl_isboolexpr(asu64(R1));
	if (asi64(R1)) goto L8687;
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode2(asi64(R1));
L8687:
	goto L8669;
L8688:
	goto L8692;
L8689:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L8694;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8695;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L8695;
	R2 = 31;
	if (asi64(R1) != asi64(R2)) goto L8694;
L8695:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L8693;
L8694:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L8697;
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8698;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L8697;
L8698:
	R1 = 0;
	R2 = 134;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8697:
L8693:
	asu64(R1) = b;
	a = asu64(R1);
L8692:
	asu64(R1) = a;
	if (asu64(R1)) goto L8689;
	goto L8669;
L8699:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_call(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8700:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_ifx(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L8669;
L8701:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_eq(asu64(R3), asu64(R2), asu64(R1));
	goto L8669;
L8702:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8704;
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = b;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L8704;
	R1 = 9;
	asu64(R2) = b;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8704:
	R1 = 43;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8705:
	R1 = 44;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8706:
	R1 = 45;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8707:
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L8709;
	R1 = 46;
	goto L8708;
L8709:
	R1 = 47;
L8708:
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8710:
	R1 = 48;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8711:
	R1 = 50;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8712:
	R1 = 51;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8713:
	R1 = 52;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8714:
	R1 = 53;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8715:
	R1 = 54;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8716:
	asi64(R1) = am;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_ptr(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8717:
	asi64(R1) = am;
	R2 = 57;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	cc_blockpcl_dx_addptr(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8718:
	asi64(R1) = am;
	R2 = 58;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	cc_blockpcl_dx_addptr(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8719:
	asu64(R1) = p;
	R2 = 58;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8721;
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	goto L8720;
L8721:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 58;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_convert(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L8720:
	goto L8669;
L8722:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_scale(asu64(R3), asu64(R2), asu64(R1));
	goto L8669;
L8723:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 60;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	goto L8669;
L8724:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 62;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	goto L8669;
L8725:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_dx_preincrx(asu64(R2), asu64(R1));
	goto L8669;
L8726:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_dx_postincrx(asu64(R2), asu64(R1));
	goto L8669;
L8727:
	R1 = 1;
	R2 = 90;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8728:
	R1 = 1;
	R2 = 91;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8729:
	R1 = 1;
	R2 = 92;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8730:
	R1 = 1;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = cc_lib_isrealcc(asi64(R2));
	if (!asi64(R2)) goto L8732;
	R2 = 93;
	goto L8731;
L8732:
	R2 = 94;
L8731:
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8733:
	R1 = 1;
	R2 = 95;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8734:
	R1 = 1;
	R2 = 96;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8735:
	R1 = 1;
	R2 = 97;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8736:
	R1 = 1;
	R2 = 98;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8737:
	R1 = 1;
	R2 = 99;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8738:
	R1 = 1;
	R2 = 100;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8669;
L8739:
	asi64(R1) = am;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_addrof(asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8740:
	asi64(R1) = am;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_dot(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L8669;
L8741:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 129;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8669;
L8742:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 130;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8669;
L8671:
	R1 = 0;
	R2 = (u64)&cc_tables_jtagnames;
	asu64(R3) = p;
	R4 = 40;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("DX-EXPR: can't do tag: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L8669:
	asi64(R1) = oldclineno;
	cc_decls_clineno = asi64(R1);
L8666:
	return;
}

static void cc_blockpcl_dx_const(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8745;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L8745;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8744;
L8745:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8747;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8748;
	goto L8749;
L8747:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8746;
L8748:
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8746;
L8749:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L8751;
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L8751;
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8750;
L8751:
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L8752;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8754;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genstring(asu64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8753;
L8754:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8755;
	R1 = 0;
	R2 = tou64("CONST/WSTRING");
	cc_support_gerror(asu64(R2), asu64(R1));
	goto L8753;
L8755:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8753:
	goto L8750;
L8752:
	R1 = 0;
	R2 = tou64("const?");
	cc_support_gerror(asu64(R2), asu64(R1));
L8750:
L8746:
L8744:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_name(u64 p, i64 am) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8758;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8758;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8758;
	goto L8759;
L8758:
	asi64(R1) = am;
	if (!asi64(R1)) goto L8761;
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L8760;
L8761:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L8760:
	goto L8757;
L8759:
	R1 = 0;
	R2 = tou64("dxname");
	cc_support_gerror(asu64(R2), asu64(R1));
L8757:
	return;
}

static void cc_blockpcl_dx_bin(u64 a, u64 b, i64 opc) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_binto(u64 a, u64 b, i64 opc, i64 res) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = res;
	if (asi64(R1)) goto L8765;
	asi64(R1) = opc;
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L8765;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L8765;
	cc_blockpcl_do_setinplace();
L8765:
	asi64(R1) = res;
	if (!asi64(R1)) goto L8767;
	R1 = 0;
	R2 = 8;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 3;
	R3 = 2;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
L8767:
	R1 = 0;
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = res;
	if (!asi64(R1)) goto L8769;
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
L8769:
	return;
}

static void cc_blockpcl_do_assign(u64 a, u64 b, i64 res) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = res;
	if (!asi64(R1)) goto L8772;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8772:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8774;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8775;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L8776;
	goto L8777;
L8774:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8773;
L8775:
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 5;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8773;
L8776:
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 5;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8773;
L8777:
	R1 = 0;
	R2 = (u64)&cc_tables_jtagnames;
	asu64(R3) = a;
	R4 = 40;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("DOASSIGN not ready: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L8773:
	return;
}

static void cc_blockpcl_dx_ptr(u64 p, u64 a, i64 am) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = am;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8780;
	R1 = 0;
	R2 = 1;
	R3 = 2;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L8780:
	return;
}

static void cc_blockpcl_dx_addptr(u64 p, u64 a, u64 b, i64 opc, i64 am) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asi64(R3) = opc;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_addrof(u64 p, u64 a, i64 am) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	return;
}

static void cc_blockpcl_dx_convert(u64 p, u64 a, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	i64 s;
	i64 ssize;
	i64 tsize;
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	ssize = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	tsize = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8785;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8786;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8787;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8787;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8788;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8788;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8789;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8789;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8790;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8791;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8792;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8792;
	goto L8793;
L8785:
	goto L8783;
	goto L8784;
L8786:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8796;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8795;
L8796:
	R1 = 0;
	R2 = tou64("Bad cast");
	cc_support_gerror(asu64(R2), asu64(R1));
L8795:
	asi64(R1) = tsize;
	asi64(R2) = ssize;
	if (asi64(R1) <= asi64(R2)) goto L8798;
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8797;
L8798:
	asi64(R1) = tsize;
	asi64(R2) = ssize;
	if (asi64(R1) >= asi64(R2)) goto L8799;
	goto L8800;
	goto L8783;
L8799:
L8797:
	goto L8784;
L8787:
	asi64(R1) = ssize;
	asi64(R2) = tsize;
	if (asi64(R1) != asi64(R2)) goto L8802;
	goto L8783;
L8802:
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8784;
L8788:
	R1 = 0;
	R2 = 111;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8784;
L8789:
	R1 = 0;
	R2 = 112;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8784;
L8790:
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8784;
L8791:
	R1 = 0;
	R2 = 116;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8784;
L8792:
// cc_blockpcl.dx_convert.dotruncate:
L8800:
	R1 = 0;
	R2 = 113;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = t;
	cc_libpcl_setmode2(asi64(R1));
	goto L8783;
	goto L8784;
L8793:
	R1 = 0;
	R2 = (u64)&cc_tables_convnames;
	asi64(R3) = opc;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Convert op not implem: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L8784:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = s;
	cc_libpcl_setmode2(asi64(R1));
L8783:
	return;
}

static void cc_blockpcl_do_if(u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = b;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = c;
	if (!asu64(R1)) goto L8805;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = c;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L8804;
L8805:
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
L8804:
	return;
}

static void cc_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	i64 lab2;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 24: goto L8810;
	case 25: goto L8815;
	case 26: goto L8820;
	case 27: goto L8825;
	case 28: case 30: case 31: case 32: goto L8809;
	case 29: goto L8827;
	case 33: case 34: case 35: case 36: case 37: case 38: goto L8826;
	default: goto L8809;
    };
// SWITCH
L8810:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8812;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L8813;
	goto L8814;
L8812:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8811;
L8813:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L8811;
L8814:
L8811:
	goto L8807;
L8815:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8817;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L8818;
	goto L8819;
L8817:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L8816;
L8818:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8816;
L8819:
L8816:
	goto L8807;
L8820:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8822;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L8823;
	goto L8824;
L8822:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8821;
L8823:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8821;
L8824:
L8821:
	goto L8807;
L8825:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8807;
L8826:
	asi64(R1) = lab;
	asu64(R2) = r;
	asu64(R3) = q;
	asu64(R4) = p;
	asi64(R5) = opc;
	cc_blockpcl_gcomparejump(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L8807;
L8827:
	goto L8829;
L8828:
	asu64(R1) = q;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L8829:
	asu64(R1) = q;
	if (!asu64(R1)) goto L8831;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	r = asu64(R2);
	if (asu64(R1)) goto L8828;
L8831:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8807;
L8809:
	R1 = 0;
	asu64(R2) = p;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L8807:
	return;
}

static void cc_blockpcl_gcomparejump(i64 jumpopc, u64 p, u64 lhs, u64 rhs, i64 lab) {
    u64 R1, R2, R3; 
	i64 cond;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_blockpcl_getpclcond(asi64(R1));
	cond = asi64(R1);
	asi64(R1) = jumpopc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L8834;
	asi64(R1) = cond;
	asi64(R1) = cc_blockpcl_reversecond(asi64(R1));
	cond = asi64(R1);
L8834:
	asu64(R1) = rhs;
	asu64(R2) = lhs;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lhs;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = rhs;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 26;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = lhs;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static i64 cc_blockpcl_getpclcond(i64 op) {
    u64 R1, R2; 
	asi64(R1) = op;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8837;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L8838;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L8839;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L8840;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L8841;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L8842;
	goto L8843;
L8837:
	R1 = 1;
	goto L8835;
	goto L8836;
L8838:
	R1 = 2;
	goto L8835;
	goto L8836;
L8839:
	R1 = 3;
	goto L8835;
	goto L8836;
L8840:
	R1 = 4;
	goto L8835;
	goto L8836;
L8841:
	R1 = 5;
	goto L8835;
	goto L8836;
L8842:
	R1 = 6;
	goto L8835;
	goto L8836;
L8843:
L8836:
	R1 = 0;
	goto L8835;
L8835:
	return asi64(R1);
}

static i64 cc_blockpcl_reversecond(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8846;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8847;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8848;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8849;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8850;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8851;
	goto L8852;
L8846:
	R1 = 2;
	cc = asi64(R1);
	goto L8845;
L8847:
	R1 = 1;
	cc = asi64(R1);
	goto L8845;
L8848:
	R1 = 5;
	cc = asi64(R1);
	goto L8845;
L8849:
	R1 = 6;
	cc = asi64(R1);
	goto L8845;
L8850:
	R1 = 3;
	cc = asi64(R1);
	goto L8845;
L8851:
	R1 = 4;
	cc = asi64(R1);
	goto L8845;
L8852:
L8845:
	asi64(R1) = cc;
	goto L8844;
L8844:
	return asi64(R1);
}

static void cc_blockpcl_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_do_while(u64 pcond, u64 pbody) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8856;
	asu64(R1) = pcond;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L8856;
	asu64(R1) = pbody;
	cc_blockpcl_do_while1(asu64(R1));
	goto L8854;
L8856:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = lab_c;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
L8854:
	return;
}

static void cc_blockpcl_do_while1(u64 pbody) {
    u64 R1, R2; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_do_dowhile(u64 pbody, u64 pcond) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondfalse(asu64(R1));
	if (asi64(R1)) goto L8860;
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
L8860:
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_stacklooplabels(i64 a, i64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = a;
	R2 = (u64)&cc_blockpcl_continuestack;
	R3 = (u64)&cc_blockpcl_loopindex;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&cc_blockpcl_breakstack;
	asi64(R3) = cc_blockpcl_loopindex;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static void cc_blockpcl_do_return(u64 p, u64 a) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = a;
	if (!asu64(R1)) goto L8864;
	asu64(R1) = cc_decls_currproc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L8866;
	asu8(R1) = pcl_pdcc;
	if (asu8(R1)) goto L8866;
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8865;
L8866:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = cc_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
L8865:
	goto L8863;
L8864:
	asi64(R1) = cc_genpcl_retindex;
	cc_blockpcl_genjumpl(asi64(R1));
L8863:
	return;
}

static void cc_blockpcl_dx_call(u64 p, u64 a, u64 b, i64 res) {
    u64 R1, R2, R3, R4; 
	u64 pm;
	i64 isfnptr;
	i64 variadic;
	i64 nparams;
	i64 retmode;
	i64 nbytes;
	i64 retsize;
	i64 m;
	i64 nvariadics;
	i64 nfixedparams;
	i64 isfn;
	i64 blockret;
	struct $B16 paramlist;
	struct $B17 paramconst;
	struct $B17 argattr;
	i64 iparams;
	i64 fparams;
	u64 dblock;
	u64 dtemp;
	u64 q;
	i64 i;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	retmode = asi64(R1);
	asi64(R1) = retmode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8869;
	R1 = 3;
	retmode = asi64(R1);
L8869:
	R1 = 0;
	isfn = asi64(R1);
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8871;
	goto L8872;
L8871:
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	goto L8874;
L8873:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
L8874:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8873;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = 1;
	isfnptr = asi64(R1);
	goto L8870;
L8872:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	isfnptr = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
L8870:
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	variadic = asi64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nfixedparams = asi64(R1);
	R1 = 0;
	R2 = R1;
	nvariadics = asi64(R2);
	nparams = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	goto L8879;
L8876:
	asi64(R1) = nparams;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L8881;
	R1 = 0;
	R2 = tou64("maxparams");
	cc_support_gerror(asu64(R2), asu64(R1));
L8881:
	asu64(R1) = q;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&paramconst;
	asi64(R3) = nparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = variadic;
	if (!asi64(R1)) goto L8883;
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) <= asi64(R2)) goto L8883;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L8883;
	asi64(R1) = nvariadics;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8883;
	asi64(R1) = nparams;
	nvariadics = asi64(R1);
L8883:
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) > asi64(R2)) goto L8885;
	R1 = (u64)&cc_decls_ttconst;
	asu64(R2) = pm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&paramconst;
	asi64(R3) = nparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L8885:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L8879:
	asu64(R1) = q;
	if (asu64(R1)) goto L8876;
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	fparams = asi64(R2);
	iparams = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8888;
L8886:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8891;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8890;
L8891:
	R1 = (u64)&fparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R1) = -asi64(R1);
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	goto L8889;
L8890:
	R1 = (u64)&iparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L8889:
	i += 1; if (i <= nparams) goto L8886;
L8888:
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8894;
L8892:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L8896;
	asi64(R1) = i;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L8896;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8896;
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 2;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L8896:
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = i;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	R1 = toi64(toi8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += -1; if (i >= 1) goto L8892;
L8894:
	asi64(R1) = isfnptr;
	if (asi64(R1)) goto L8898;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L8900;
	R2 = 21;
	goto L8899;
L8900:
	R2 = 18;
L8899:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8897;
L8898:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L8902;
	R2 = 22;
	goto L8901;
L8902:
	R2 = 19;
L8901:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8897:
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = nvariadics;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L8904;
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = res;
	if (asi64(R1)) goto L8906;
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8905;
L8906:
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L8905:
L8904:
	return;
}

static void cc_blockpcl_do_decl(u64 d) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8909;
	R1 = 1;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8909:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8911;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8913;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8913;
	goto L8914;
L8913:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8907;
L8911:
// cc_blockpcl.do_decl.copyl:
L8914:
	asu64(R1) = d;
	R2 = 114;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
L8907:
	return;
}

static void cc_blockpcl_do_for(u64 pinit, u64 pbody) {
    u64 R1, R2, R3; 
	u64 pcond;
	u64 pincr;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_cond;
	asu64(R1) = pinit;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcond = asu64(R1);
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pincr = asu64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_cond = asi64(R1);
	asu64(R1) = pinit;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8917;
	asu64(R1) = pinit;
	cc_blockpcl_do_stmt(asu64(R1));
L8917:
	asi64(R1) = lab_cond;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_cond;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8919;
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8918;
L8919:
	asi64(R1) = lab_b;
	cc_blockpcl_genjumpl(asi64(R1));
L8918:
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_do_preincr(u64 a, i64 incrop) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asi64(R2) = incrop;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	return;
}

static void cc_blockpcl_setincrstep(i64 m) {
    u64 R1, R2, R3; 
	R1 = 1;
	pc_api_pc_setincr(asi64(R1));
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8923;
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	pc_api_pc_setincr(asi64(R1));
L8923:
	return;
}

static void cc_blockpcl_dx_preincrx(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 71;
	if (asi64(R2) != asi64(R3)) goto L8926;
	R2 = 86;
	goto L8925;
L8926:
	R2 = 87;
L8925:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	asu64(R1) = a;
	cc_blockpcl_widen(asu64(R1));
	return;
}

static void cc_blockpcl_dx_postincrx(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 73;
	if (asi64(R2) != asi64(R3)) goto L8929;
	R2 = 88;
	goto L8928;
L8929:
	R2 = 89;
L8928:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	asu64(R1) = a;
	cc_blockpcl_widen(asu64(R1));
	return;
}

static void cc_blockpcl_dx_dot(u64 p, u64 a, u64 b, i64 am) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = am;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8932;
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 2;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
	goto L8931;
L8932:
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L8931:
	return;
}

static void cc_blockpcl_dx_eq(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 31;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_blockpcl_getpclcond(asi64(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static void cc_blockpcl_do_labeldef(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L8936;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8936:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_api_gencomment(asu64(R1));
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_do_goto(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8939;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Label not defined: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L8938;
L8939:
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L8940;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8940:
L8938:
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_dx_ifx(u64 p, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	i64 ismult;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	ismult = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L8943;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8943:
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L8945;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L8945:
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = c;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L8947;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L8947:
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	return;
}

static void cc_blockpcl_do_casestmt(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 value;
	i64 i;
	asi64(R1) = cc_blockpcl_sw_ncases;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8950;
	asu64(R1) = cc_blockpcl_sw_labeltable;
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = cc_blockpcl_sw_lower;
	asi64(R2) -= asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8949;
L8950:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8954;
L8951:
	asu64(R1) = cc_blockpcl_sw_valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asi64(R2) = value;
	if (asi64(R1) != asi64(R2)) goto L8956;
	asu64(R1) = cc_blockpcl_sw_labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8953;
L8956:
	i += 1; if (i <= cc_blockpcl_sw_ncases) goto L8951;
L8954:
	R1 = 0;
	R2 = tou64("case: serial switch not found");
	cc_support_gerror(asu64(R2), asu64(R1));
L8953:
L8949:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	return;
}

static void cc_blockpcl_do_switch(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	struct $B46 labeltable;
	struct $B46 valuetable;
	struct $B47 flags;
	i64 defaultlabel;
	i64 breakswlabel;
	i64 switchlabel;
	i64 lower;
	i64 upper;
	i64 length;
	i64 value;
	i64 ncases;
	u8 serialsw;
	i64 i;
	i64 index;
	u64 pcase;
	u64 old_labeltable;
	u64 old_valuetable;
	i64 old_ncases;
	i64 old_lower;
	u8 old_defaultseen;
	i64 old_defaultlabel;
	i64 old_breaklabel;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcase = asu64(R1);
	R1 = 0;
	R2 = R1;
	length = asi64(R2);
	ncases = asi64(R1);
	goto L8959;
L8958:
	R1 = (u64)&ncases;
	(*toi64p(R1)) += 1;
	asi64(R1) = ncases;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L8962;
	R1 = 0;
	R2 = tou64("Too many cases on one switch");
	cc_support_gerror(asu64(R2), asu64(R1));
L8962:
	asu64(R1) = pcase;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	value = asi64(R2);
	R2 = (u64)&valuetable;
	asi64(R3) = ncases;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8964;
	asi64(R1) = value;
	R2 = R1;
	upper = asi64(R2);
	lower = asi64(R1);
	goto L8963;
L8964:
	asi64(R1) = lower;
	asi64(R2) = value;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	lower = asi64(R1);
	asi64(R1) = upper;
	asi64(R2) = value;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	upper = asi64(R1);
L8963:
	asu64(R1) = pcase;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcase = asu64(R1);
L8959:
	asu64(R1) = pcase;
	if (asu64(R1)) goto L8958;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8966;
	asi64(R1) = upper;
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	goto L8965;
L8966:
	R1 = 0;
	length = asi64(R1);
L8965:
	asi64(R1) = cc_libpcl_createfwdlabel();
	defaultlabel = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	breakswlabel = asi64(R1);
	asi64(R1) = length;
	R2 = 500;
	if (asi64(R1) > asi64(R2)) goto L8969;
	asi64(R1) = ncases;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L8968;
L8969:
	R1 = 1;
	serialsw = asu8(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8972;
L8970:
	asi64(R1) = cc_libpcl_createfwdlabel();
	R2 = (u64)&labeltable;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = (u64)&labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 26;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = i;
	asi64(R2) = ncases;
	if (asi64(R1) >= asi64(R2)) goto L8974;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8974:
	i += 1; if (i <= ncases) goto L8970;
L8972:
	asi64(R1) = defaultlabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L8967;
L8968:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8975;
	asi64(R1) = defaultlabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L8967;
L8975:
	R1 = 0;
	serialsw = asu8(R1);
	asi64(R1) = length;
	R2 = 0;
	R3 = (u64)&flags;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8978;
L8976:
	asi64(R1) = defaultlabel;
	R2 = (u64)&labeltable;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	i += 1; if (i <= length) goto L8976;
L8978:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8981;
L8979:
	R1 = (u64)&valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	value = asi64(R1);
	asi64(R1) = value;
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	index = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	R2 = (u64)&labeltable;
	asi64(R3) = index;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&flags;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8983;
	R1 = 0;
	R2 = 0;
	asi64(R3) = value;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Dupl case value: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L8983:
	R1 = 1;
	R2 = (u64)&flags;
	asi64(R3) = index;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= ncases) goto L8979;
L8981:
	asi64(R1) = cc_libpcl_createfwdlabel();
	switchlabel = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = switchlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 37;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = lower;
	asi64(R2) = length;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = lower;
	pc_api_pc_setxy(asi64(R2), asi64(R1));
	asi64(R1) = defaultlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = switchlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8986;
L8984:
	R1 = (u64)&labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	i += 1; if (i <= length) goto L8984;
L8986:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8967:
	asu64(R1) = cc_blockpcl_sw_labeltable;
	old_labeltable = asu64(R1);
	asu64(R1) = cc_blockpcl_sw_valuetable;
	old_valuetable = asu64(R1);
	asi64(R1) = cc_blockpcl_sw_lower;
	old_lower = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_ncases;
	old_ncases = asi64(R1);
	asu8(R1) = cc_blockpcl_sw_defaultseen;
	old_defaultseen = asu8(R1);
	asi64(R1) = cc_blockpcl_sw_defaultlabel;
	old_defaultlabel = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_breaklabel;
	old_breaklabel = asi64(R1);
	R1 = (u64)&labeltable;
	cc_blockpcl_sw_labeltable = asu64(R1);
	R1 = (u64)&valuetable;
	cc_blockpcl_sw_valuetable = asu64(R1);
	asi64(R1) = lower;
	cc_blockpcl_sw_lower = asi64(R1);
	asu8(R1) = serialsw;
	if (!asu8(R1)) goto L8988;
	asi64(R1) = ncases;
	goto L8987;
L8988:
	R1 = 0;
L8987:
	cc_blockpcl_sw_ncases = asi64(R1);
	R1 = 0;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = defaultlabel;
	cc_blockpcl_sw_defaultlabel = asi64(R1);
	asi64(R1) = breakswlabel;
	cc_blockpcl_sw_breaklabel = asi64(R1);
	asu64(R1) = b;
	cc_blockpcl_do_stmt(asu64(R1));
	asu8(R1) = cc_blockpcl_sw_defaultseen;
	if (asu8(R1)) goto L8990;
	asi64(R1) = defaultlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
L8990:
	asi64(R1) = breakswlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = old_labeltable;
	cc_blockpcl_sw_labeltable = asu64(R1);
	asu64(R1) = old_valuetable;
	cc_blockpcl_sw_valuetable = asu64(R1);
	asi64(R1) = old_lower;
	cc_blockpcl_sw_lower = asi64(R1);
	asi64(R1) = old_ncases;
	cc_blockpcl_sw_ncases = asi64(R1);
	asu8(R1) = old_defaultseen;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = old_defaultlabel;
	cc_blockpcl_sw_defaultlabel = asi64(R1);
	asi64(R1) = old_breaklabel;
	cc_blockpcl_sw_breaklabel = asi64(R1);
	return;
}

static void cc_blockpcl_dx_andorl(u64 p) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = lab1;
	asu64(R2) = p;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	R1 = 1;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	return;
}

static void cc_blockpcl_dx_scale(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	i64 opc;
	i64 scale;
	i64 n;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8994;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 45;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8993;
L8994:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 47;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8993:
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static void cc_blockpcl_widen(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8997;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8995;
L8997:
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	cc_libpcl_setmode(asi64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L8999;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9000;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9000;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9000;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L9000;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L9000;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L9000;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L9000;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8999;
L9000:
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9003;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9002;
L9003:
	R1 = 3;
	goto L9001;
L9002:
	R1 = 8;
L9001:
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = mode;
	cc_libpcl_setmode2(asi64(R1));
L8999:
L8995:
	return;
}

static void cc_blockpcl_do_setinplace() {
    u64 R1, R2, R3; 
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9006;
	asu64(R1) = pc_api_pccurr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9006;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9006:
	return;
}

static void cc_blockpcl_do_fixwiden(u64 a, u64 b) {
	goto L9007;
L9007:
	return;
}

static i64 cc_blockpcl_isboolexpr(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L9010;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L9010;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L9010;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L9010;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L9010;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L9010;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L9010;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L9010;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L9010;
	goto L9011;
L9010:
	R1 = 1;
	goto L9009;
L9011:
	R1 = 0;
L9009:
	goto L9008;
L9008:
	return asi64(R1);
}

static u64 cc_libpcl_getpsymbol(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 e;
	u64 name;
	struct $B16 str;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9014;
	R1 = 0;
	goto L9012;
L9014:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9016;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L9012;
L9016:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9019;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L9018;
L9019:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L9021;
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L9021:
	goto L9017;
L9018:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9022;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9022;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9022;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L9024;
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L9024:
	goto L9017;
L9022:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L9017:
	R1 = (u64)&cc_tables_name2pid;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	R2 = R1;
	p = asu64(R2);
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9026;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9026;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9026:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L9028;
	R1 = 1;
	asu64(R2) = p;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9028:
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9030;
	R1 = 1;
	asu64(R2) = p;
	R3 = 104;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L9030:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9032;
	R1 = 1;
	asu64(R2) = p;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9032:
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9034;
	R1 = tou64("main");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9034;
	R1 = 1;
	R2 = R1;
	asu64(R3) = p;
	R4 = 110;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L9034:
	asu64(R1) = p;
	goto L9012;
L9012:
	return asu64(R1);
}

static void cc_libpcl_setmode(i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = mode;
	asi64(R2) = cc_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static void cc_libpcl_setmode2(i64 mode) {
    u64 R1; 
	asi64(R1) = mode;
	asi64(R1) = cc_lib_getpclmode(asi64(R1));
	pc_api_pc_setmode2(asi64(R1));
	return;
}

static void cc_libpcl_setmode_u(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = mode;
	asi64(R2) = cc_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static u64 cc_libpcl_genmem_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L9038;
L9038:
	return asu64(R1);
}

static u64 cc_libpcl_genmemaddr_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L9039;
L9039:
	return asu64(R1);
}

static i64 cc_libpcl_definelabel() {
    u64 R1, R2; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = pc_api_mlabelno;
	goto L9040;
L9040:
	return asi64(R1);
}

static i64 cc_libpcl_createfwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L9041;
L9041:
	return asi64(R1);
}

static void cc_libpcl_definefwdlabel(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static u64 cc_lib_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 128;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	memset(R1, 0, 128);
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L9043;
L9043:
	return asu64(R1);
}

static void cc_lib_initcclib() {
	return;
}

static u64 cc_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 3;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L9045;
L9045:
	return asu64(R1);
}

static u64 cc_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = u;
	goto L9046;
L9046:
	return asu64(R1);
}

static u64 cc_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L9047;
L9047:
	return asu64(R1);
}

static u64 cc_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L9048;
L9048:
	return asu64(R1);
}

static u64 cc_lib_createunit3(i64 tag, u64 p, u64 q, u64 r) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = u;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L9049;
L9049:
	return asu64(R1);
}

static u64 cc_lib_createconstunit(u64 a, i64 t) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	asu64(R2) = u;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = u;
	goto L9050;
L9050:
	return asu64(R1);
}

static u64 cc_lib_createstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L9053;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9052;
L9053:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9052:
	R1 = 1;
	asu64(R2) = u;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L9051;
L9051:
	return asu64(R1);
}

static u64 cc_lib_createwstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_decls_trefwchar;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L9054;
L9054:
	return asu64(R1);
}

static i64 cc_lib_getoptocode(i64 opc) {
    u64 R1, R2, R3; 
	i64 n;
	i64 opcto;
	i64 i;
	struct $B54 str;
	i64 av_1;
	R1 = (u64)&cc_lib_getoptocode_opctotable;
	asi64(R2) = opc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	opcto = asi64(R1);
	asi64(R1) = opcto;
	if (!asi64(R1)) goto L9057;
	asi64(R1) = opcto;
	goto L9055;
L9057:
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("to");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	i = asi64(R1);
	R1 = 77;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L9060;
L9058:
	R1 = (u64)&str;
	R2 = (u64)&cc_tables_jtagnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9062;
	asi64(R1) = i;
	R2 = (u64)&cc_lib_getoptocode_opctotable;
	asi64(R3) = opc;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = i;
	goto L9055;
L9062:
	i += 1; if (i <= av_1) goto L9058;
L9060:
	msysc_m$print_startcon();
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find -to version");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L9055;
L9055:
	return asi64(R1);
}

static i64 cc_lib_getconstvalue(u64 p, i64 id) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L9065;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9065;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L9063;
L9065:
	R1 = tou64("GCV Not constant");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L9063;
L9063:
	return asi64(R1);
}

static u64 cc_lib_nextautotype() {
    u64 R1; 
	R1 = (u64)&cc_lib_nextautotype_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_lib_autotypeno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_lib_nextautotype_str;
	goto L9066;
L9066:
	return asu64(R1);
}

static i64 cc_lib_createconstmode(i64 m) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9069;
	asi64(R1) = m;
	goto L9067;
L9069:
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L9071;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	goto L9067;
L9071:
	asi64(R1) = m;
	asi64(R1) = cc_lib_copymode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = newm;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttconst;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = newm;
	goto L9067;
L9067:
	return asi64(R1);
}

static i64 cc_lib_createrefmode(i64 m) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L9074;
	R1 = (u64)&cc_decls_ttshared;
	R2 = (u64)&cc_decls_ttreftype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*4;
	(*toi32p(R1)) += 1;
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	goto L9072;
L9074:
	R1 = 13;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = newm;
	R2 = (u64)&cc_decls_ttreftype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisref;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L9072;
L9072:
	return asi64(R1);
}

static i64 cc_lib_createprocmode(i64 m, u64 pm) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 14;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = pm;
	R2 = (u64)&cc_decls_ttparams;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = newm;
	goto L9075;
L9075:
	return asi64(R1);
}

static i64 cc_lib_createarraymode(i64 m, i64 length) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 17;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = length;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = newm;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = newm;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L9076;
L9076:
	return asi64(R1);
}

static i64 cc_lib_createenummode(u64 e) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 12;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = e;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = newm;
	goto L9077;
L9077:
	return asi64(R1);
}

static i64 cc_lib_createstructmode(u64 s, i64 smode) {
    u64 R1, R2, R3; 
	i64 newm;
	asi64(R1) = smode;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L9078;
L9078:
	return asi64(R1);
}

static void cc_lib_setnameptr(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_lib_getautofieldname() {
    u64 R1; 
	struct $B17 str;
	u64 name;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$F");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_lib_nextafindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	goto L9080;
L9080:
	return asu64(R1);
}

static i64 cc_lib_convertstringc(u64 s, u64 t, i64 length) {
    u64 R1, R2, R3; 
	i64 c;
	struct $B54 str;
	u64 t0;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L9083;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L9083:
	asu64(R1) = t;
	t0 = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L9086;
L9084:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 7: goto L9096;
	case 8: goto L9097;
	case 9: goto L9094;
	case 10: goto L9092;
	case 11: goto L9099;
	case 12: goto L9098;
	case 13: goto L9093;
	case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: goto L9089;
	case 34: goto L9090;
	case 39: goto L9091;
	case 92: goto L9095;
	default: goto L9089;
    };
// SWITCH
L9090:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9091:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 39;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9092:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9093:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9094:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9095:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9096:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 97;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9097:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 98;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9098:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 102;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9099:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 118;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9087;
L9089:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L9102;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) < asi64(R2)) goto L9101;
L9102:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\#o");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("z3");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9100;
L9101:
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L9100:
L9087:
	if (--asi64(av_1)) goto L9084;
L9086:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L9081;
L9081:
	return asi64(R1);
}

static u64 cc_lib_getopcjname(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	name = asu64(R1);
	R1 = 32;
	asu64(R2) = name;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (!asu64(R1)) goto L9105;
	asu64(R1) = s;
	asu64(R2) = name;
	asu64(R1) -= asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&cc_lib_getopcjname_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_lib_getopcjname_str;
	asu64(R3) = s;
	asu64(R4) = name;
	asi64(R3) -= asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lib_getopcjname_str;
	goto L9104;
L9105:
	asu64(R1) = name;
L9104:
	goto L9103;
L9103:
	return asu64(R1);
}

static u64 cc_lib_strmode(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_lib_strmode_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_lib_strmode_str;
	goto L9106;
L9106:
	return asu64(R1);
}

static u64 cc_lib_strmode2(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_lib_strmode2_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_lib_strmode2_str;
	goto L9107;
L9107:
	return asu64(R1);
}

static void cc_lib_istrmode(i64 m, i64 expand, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 q;
	i64 value;
	i64 needcomma;
	i64 x;
	i64 i;
	i64 target;
	i64 t;
	i64 n;
	struct $B3 sxx;
	u64 xx;
	u64 sdim;
	u64 slength;
	struct $B5 strdim;
	struct $B5 strlength;
	u64 pm;
	R1 = (u64)&sxx;
	xx = asu64(R1);
	asi64(R1) = m;
	R2 = 21;
	if (asi64(R1) >= asi64(R2)) goto L9110;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9108;
L9110:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L9112;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9113;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9114;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9115;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9115;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9116;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9117;
	goto L9118;
L9112:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9120;
	R1 = tou64("const ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9119;
L9120:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L9119:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	target = asi64(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L9122;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L9122;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L9121;
L9122:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L9121:
	goto L9111;
L9113:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L9124;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9123;
L9124:
	R1 = tou64("[]");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L9123:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L9111;
L9114:
	R1 = tou64("enum ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L9111;
L9115:
	asi64(R1) = expand;
	if (asi64(R1)) goto L9126;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9108;
L9126:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L9128;
L9127:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L9131;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L9131:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9128:
	asu64(R1) = q;
	if (asu64(R1)) goto L9127;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L9111;
L9116:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9111;
L9117:
	R1 = tou64("proc(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9134;
L9132:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = pm;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = n;
	if (asi64(R1) == asi64(R2)) goto L9136;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L9136:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	i += 1; if (i <= n) goto L9132;
L9134:
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L9111;
L9118:
	asi64(R1) = t;
	R2 = 21;
	if (asi64(R1) >= asi64(R2)) goto L9138;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9108;
	goto L9137;
L9138:
	msysc_m$print_startcon();
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("NEWSTRMODE");
	cc_support_mcerror(asu64(R1));
L9137:
L9111:
L9108:
	return;
}

static u64 cc_lib_typename(i64 m) {
    u64 R1, R2, R3; 
	i64 basem;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	basem = asi64(R1);
	asi64(R1) = basem;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9141;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9141;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9142;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9143;
	goto L9144;
L9141:
	asi64(R1) = basem;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L9146;
	R1 = tou64("struct ");
	goto L9145;
L9146:
	R1 = tou64("union ");
L9145:
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L9148;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L9148:
	R1 = (u64)&cc_lib_typename_str;
	goto L9139;
	goto L9140;
L9142:
	R1 = tou64("<array>");
	goto L9139;
	goto L9140;
L9143:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L9150;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L9139;
L9150:
	R1 = tou64("<enum>");
	goto L9139;
	goto L9140;
L9144:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9152;
	R1 = tou64("const ");
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_tables_stdtypenames;
	asi64(R2) = basem;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lib_typename_str;
	goto L9139;
L9152:
	R1 = (u64)&cc_tables_stdtypenames;
	asi64(R2) = basem;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L9139;
L9140:
	R1 = tou64("");
	goto L9139;
L9139:
	return asu64(R1);
}

static u64 cc_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 nwords;
	R1 = (u64)&cc_decls_nunits;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_lib_remainingunits;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) -= 1; asi64(R1) = asi64(R2);
	if (!asi64(R1)) goto L9155;
	asu64(R1) = cc_lib_unitheapptr;
	p = asu64(R1);
	R1 = (u64)&cc_lib_unitheapptr;
	(*tou64p(R1)) += 64;
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L9157;
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9157:
	asu64(R1) = p;
	goto L9153;
L9155:
	R1 = 3200000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	cc_lib_unitheapptr = asu64(R2);
	p = asu64(R1);
	R1 = 3200000;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 49999;
	cc_lib_remainingunits = asi64(R1);
	R1 = (u64)&cc_lib_unitheapptr;
	(*tou64p(R1)) += 64;
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L9159;
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9159:
	asu64(R1) = p;
	goto L9153;
L9153:
	return asu64(R1);
}

static i64 cc_lib_copymode(i64 m) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_decls_ntypes;
	R2 = 80000;
	if (asi64(R1) < asi64(R2)) goto L9162;
	R1 = tou64("Too many types");
	cc_support_serror(asu64(R1));
L9162:
	R1 = (u64)&cc_decls_ntypes;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = cc_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttconst;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttparams;
	asi64(R3) = cc_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttisref;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_decls_ntypes;
	goto L9160;
L9160:
	return asi64(R1);
}

static i64 cc_lib_createnewmode(i64 m) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_decls_ntypes;
	R2 = 80000;
	if (asi64(R1) < asi64(R2)) goto L9165;
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(M)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many types/cnm");
	cc_support_serror(asu64(R1));
L9165:
	R1 = (u64)&cc_decls_ntypes;
	(*toi64p(R1)) += 1;
	asi64(R1) = m;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = cc_decls_ntypes;
	goto L9163;
L9163:
	return asi64(R1);
}

static void cc_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9168;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L9167;
L9168:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9167:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_addlistdef(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9171;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L9170;
L9171:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9170:
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_addlistparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9174;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L9173;
L9174:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9173:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_checksymbol(i64 symbol) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L9177;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asi64(R2) = symbol;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L9179;
	R1 = tou64(" \"");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L9179:
	R1 = (u64)&str;
	cc_support_serror(asu64(R1));
L9177:
	return;
}

static void cc_lib_skipsymbol(i64 symbol) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L9182;
	asi64(R1) = symbol;
	cc_lib_checksymbol(asi64(R1));
L9182:
	cc_lex_lex();
	return;
}

static void cc_lib_inittypetables() {
    u64 R1, R2, R3; 
	i64 i;
	i64 j;
	i64 size;
	i64 bitsize;
	i64 s;
	i64 t;
	i64 u;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	R1 = 0;
	i = asi64(R1);
	R1 = 20;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L9186;
L9184:
	asi64(R1) = i;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_tables_stdtypewidths;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = i;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9189;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L9188;
L9189:
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9188:
	i += 1; if (i <= av_1) goto L9184;
L9186:
	R1 = 20;
	cc_decls_ntypes = asi64(R1);
	R1 = 1;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	cc_decls_trefchar = asi64(R1);
	R1 = 7;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	cc_decls_trefwchar = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 121;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9192;
L9190:
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = (u64)&cc_tables_dominantmode;
	asi64(R3) = s;
	R2 += (i64)R3*32;
	asi64(R3) = t;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_2) goto L9190;
L9192:
	R1 = 1;
	i = asi64(R1);
	R1 = 121;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9195;
L9193:
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = (u64)&cc_tables_conversionops;
	asi64(R3) = s;
	R2 += (i64)R3*16;
	asi64(R3) = t;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_3) goto L9193;
L9195:
	return;
}

static u64 cc_lib_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	asu64(R1) = cc_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 106;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_tables_namespaces;
	asi64(R2) = id;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 98;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (!asu64(R1)) goto L9198;
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9198:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	asu64(R2) = p;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L9200;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9202;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L9201;
L9202:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9201:
L9200:
	asu64(R1) = p;
	goto L9196;
L9196:
	return asu64(R1);
}

static u64 cc_lib_createnewmoduledef(u64 owner, u64 symptr) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	R1 = 3;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L9203;
L9203:
	return asu64(R1);
}

static u64 cc_lib_createnewproc(u64 owner, u64 symptr) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	R1 = 6;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	q = asu64(R1);
	goto L9206;
L9205:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L9209;
	msysc_m$print_startcon();
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Dupl proc name");
	cc_support_serror(asu64(R1));
L9209:
L9206:
	asu64(R1) = q;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (asu64(R1)) goto L9205;
	asu64(R1) = p;
	goto L9204;
L9204:
	return asu64(R1);
}

static u64 cc_lib_resolvename(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L9212;
	asu64(R1) = symptr;
	goto L9210;
L9212:
	asi64(R1) = ns;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9214;
	asu64(R1) = symptr;
	asu64(R2) = owner;
	asu64(R1) = cc_lib_resolvelabel(asu64(R2), asu64(R1));
	goto L9210;
L9214:
	asi64(R1) = blockno;
	if (!asi64(R1)) goto L9216;
	R1 = (u64)&cc_decls_blockcounts;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9216;
	R1 = (u64)&cc_decls_blockowner;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	blockno = asi64(R1);
L9216:
L9217:
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	asu64(R1) = symptr;
	d = asu64(R1);
	goto L9220;
L9219:
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9223;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L9223;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9223;
	goto L9221;
L9223:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L9225;
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L9225;
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) >= asi64(R2)) goto L9227;
	asu64(R1) = d;
	R2 = 122;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
L9227:
	asu64(R1) = d;
	goto L9210;
L9225:
L9220:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L9219;
L9221:
	asi64(R1) = blockno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9229;
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9231;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L9232;
	goto L9233;
L9231:
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	goto L9217;
	goto L9230;
L9232:
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9235;
	R1 = 0;
	goto L9210;
L9235:
	goto L9230;
L9233:
	R1 = 0;
	goto L9210;
L9230:
	goto L9228;
L9229:
	R1 = (u64)&cc_decls_blockowner;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	blockno = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9236;
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
L9236:
L9228:
	goto L9217;
	R1 = 0;
	goto L9210;
L9210:
	return asu64(R1);
}

static u64 cc_lib_resolvelabel(u64 owner, u64 symptr) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	goto L9239;
L9238:
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9242;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L9242;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9242;
	goto L9240;
L9242:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L9244;
	asu64(R1) = d;
	R2 = 98;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9244;
	asu64(R1) = d;
	goto L9237;
L9244:
L9239:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L9238;
L9240:
	R1 = 0;
	goto L9237;
L9237:
	return asu64(R1);
}

static u64 cc_lib_checkdupl(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	goto L9247;
L9246:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L9250;
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L9250;
	asu64(R1) = d;
	goto L9245;
L9250:
L9247:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L9246;
	R1 = 0;
	goto L9245;
L9245:
	return asu64(R1);
}

static u64 cc_lib_checkdupl_inproc(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	goto L9253;
L9252:
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L9256;
	asu64(R1) = d;
	goto L9251;
L9256:
L9253:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (!asu64(R1)) goto L9257;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L9252;
L9257:
	R1 = 0;
	goto L9251;
L9251:
	return asu64(R1);
}

static i64 cc_lib_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9260;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9261;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9261;
	goto L9262;
L9260:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	goto L9258;
	goto L9259;
L9261:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9264;
	R1 = 16;
	goto L9258;
L9264:
	asi64(R1) = a;
	goto L9258;
	goto L9259;
L9262:
L9259:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9266;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9266;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9266;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9266;
	goto L9267;
L9266:
	asi64(R1) = a;
	goto L9258;
	goto L9265;
L9267:
L9265:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = a;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("GETALIGN SIZE NOT 1248");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L9258;
L9258:
	return asi64(R1);
}

static i64 cc_lib_isexported(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9270;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9272;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9273;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L9272;
L9273:
	R1 = 1;
	goto L9268;
L9272:
	goto L9269;
L9270:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L9275;
	R1 = 1;
	goto L9268;
L9275:
L9269:
	R1 = 0;
	goto L9268;
L9268:
	return asi64(R1);
}

static i64 cc_lib_isimported(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9278;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9280;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9281;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L9280;
L9281:
	R1 = 1;
	goto L9276;
L9280:
	goto L9277;
L9278:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9283;
	R1 = 1;
	goto L9276;
L9283:
L9277:
	R1 = 0;
	goto L9276;
L9276:
	return asi64(R1);
}

static u64 cc_lib_getstname(u64 d) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = d;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&cc_lib_getstname_name;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_lib_getstname_name;
	asu64(R3) = d;
	R4 = 106;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lib_getstname_name;
	goto L9284;
L9284:
	return asu64(R1);
}

static i64 cc_lib_isrealcc(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	R1 = 10;
	asi64(R2) = m;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L9286;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L9286;
	R1 = 1;
	goto L9287;
L9286:
	R1 = 0;
L9287:
	goto L9285;
L9285:
	return asi64(R1);
}

static i64 cc_lib_isintcc(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	R1 = 1;
	asi64(R2) = m;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L9289;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L9289;
	R1 = 1;
	goto L9290;
L9289:
	R1 = 0;
L9290:
	goto L9288;
L9288:
	return asi64(R1);
}

static void cc_lib_writegsfile(u64 filename, u64 d) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	return;
}

static void cc_lib_pause(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asi64(R1) = mlinux_os_getch();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static i64 cc_lib_getpclmode(i64 t) {
    u64 R1, R2, R3; 
	i64 u;
	R1 = (u64)&cc_tables_stdpcl;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L9295;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9297;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9298;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9299;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9300;
	goto L9301;
L9297:
	R1 = 6;
	u = asi64(R1);
	goto L9296;
L9298:
	R1 = 5;
	u = asi64(R1);
	goto L9296;
L9299:
	R1 = 4;
	u = asi64(R1);
	goto L9296;
L9300:
	R1 = 3;
	u = asi64(R1);
	goto L9296;
L9301:
L9296:
L9295:
	asi64(R1) = u;
	goto L9293;
L9293:
	return asi64(R1);
}

static void cc_lib_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9304;
	msysc_m$print_startcon();
	R1 = tou64("ATL ERROR");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9302;
L9304:
L9305:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L9308;
	goto L9306;
L9308:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L9305;
L9306:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L9302:
	return;
}

static void cc_support_stopcompiler(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	asu8(R1) = cc_cli_fwriteerrors;
	if (!asu8(R1)) goto L9311;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L9311:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void cc_support_mcerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("\nMC Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 40;
	exit(R1);
	return;
}

static void cc_support_serror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_serror_gen(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L9316;
	msysc_m$print_startcon();
	R1 = tou64("\nIn function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L9315;
L9316:
	msysc_m$print_startcon();
	R1 = tou64("OUTSIDE PROC");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9315:
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	cc_support_showmacrolineno();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Syntax Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = (u64)&cc_decls_lx;
	R4 = 20;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_serror_ss(u64 mess, u64 a, u64 b) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_serror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_terror_gen(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L9321;
	msysc_m$print_startcon();
	R1 = tou64("\nIn function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9321:
	msysc_m$print_startcon();
	R1 = tou64("Type error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("on line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	cc_support_showmacrolineno();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = (u64)&cc_decls_lx;
	R4 = 20;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_terror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_terror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_terror_ss(u64 mess, u64 a, u64 b) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_gerror_gen(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	i64 lineno;
	i64 fileno;
	asu64(R1) = p;
	if (!asu64(R1)) goto L9327;
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	lineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	fileno = asi64(R1);
	goto L9326;
L9327:
	asi64(R1) = cc_decls_clineno;
	lineno = asi64(R1);
	asi64(R1) = cc_decls_cfileno;
	fileno = asi64(R1);
L9326:
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L9329;
	msysc_m$print_startcon();
	R1 = tou64("In function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9329:
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Code Gen Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = fileno;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_gerror(u64 mess, u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = mess;
	cc_support_gerror_gen(asu64(R2), asu64(R1));
	return;
}

static void cc_support_gerror_s(u64 mess, u64 s, u64 p) {
    u64 R1, R2; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	cc_support_gerror_gen(asu64(R2), asu64(R1));
	return;
}

static i64 cc_support_nextpoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9334;
	R1 = 0;
	goto L9332;
L9334:
	R1 = 1;
	a = asi64(R1);
	goto L9336;
L9335:
	R1 = 1;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
L9336:
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) < asi64(R2)) goto L9335;
	asi64(R1) = a;
	goto L9332;
L9332:
	return asi64(R1);
}

static void cc_support_loaderror(u64 mess, u64 mess2) {
    u64 R1; 
	struct $B20 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	exit(R1);
	return;
}

static i64 cc_support_loadsourcefile(u64 file, u64 shortfile) {
    u64 R1, R2, R3; 
	u64 s;
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L9341;
	R1 = tou64("");
	R2 = tou64("Too many source files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L9341:
	R1 = (u64)&cc_decls_nsourcefiles;
	(*toi64p(R1)) += 1;
	asu64(R1) = file;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = shortfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = file;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L9343;
	asu64(R1) = file;
	R2 = tou64("LSF can't load ");
	cc_support_loaderror(asu64(R2), asu64(R1));
L9343:
	asu64(R1) = s;
	R2 = (u64)&cc_decls_sourcefiletext;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	R2 = (u64)&cc_decls_sourcefilesizes;
	asi64(R3) = cc_decls_nsourcefiles;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	goto L9339;
L9339:
	return asi64(R1);
}

static u64 cc_support_splicelines(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	goto L9346;
L9345:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L9349;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9349;
	R1 = 2;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	goto L9348;
L9349:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L9350;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9350;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9350;
	R1 = 3;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	goto L9348;
L9350:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L9348:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L9346:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L9345;
	asu64(R1) = u;
	goto L9344;
L9344:
	return asu64(R1);
}

static i64 cc_support_loadbuiltin(u64 shortfile, u64 hdrtext) {
    u64 R1, R2, R3; 
	u64 s;
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L9353;
	R1 = tou64("");
	R2 = tou64("Too many source files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L9353:
	R1 = (u64)&cc_decls_nsourcefiles;
	(*toi64p(R1)) += 1;
	R1 = tou64("<builtin>");
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = shortfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = hdrtext;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefiletext;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = hdrtext;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilesizes;
	asi64(R3) = cc_decls_nsourcefiles;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	goto L9351;
L9351:
	return asi64(R1);
}

static void cc_support_gs_copytostr(u64 source, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9356;
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = source;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = s;
	asu64(R3) = source;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9355;
L9356:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L9355:
	return;
}

static void cc_support_gs_additem(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9359;
	asu64(R1) = d;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = cc_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L9361;
	asi64(R1) = nextchar;
	asi64(R1) = cc_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L9361;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L9361:
L9359:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 cc_support_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L9366;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L9365;
L9366:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L9367;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L9365;
L9367:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L9364;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L9364;
L9365:
	R1 = 1;
	goto L9362;
L9364:
	R1 = 0;
	goto L9362;
L9362:
	return asi64(R1);
}

static void cc_support_showmacrolineno() {
    u64 R1; 
	asi64(R1) = cc_decls_slineno;
	if (!asi64(R1)) goto L9370;
L9370:
	return;
}

static u64 cc_headers_findheader(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	struct $B16 newname;
	u64 s;
	u64 t;
	i64 av_1;
	R1 = 92;
	asu64(R2) = name;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	if (!asu64(R1)) goto L9373;
	asu64(R1) = name;
	s = asu64(R1);
	R1 = (u64)&newname;
	t = asu64(R1);
	goto L9375;
L9374:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L9378;
	R1 = 47;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L9377;
L9378:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L9377:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L9375:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L9374;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&newname;
	name = asu64(R1);
L9373:
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9381;
L9379:
	R1 = (u64)&cc_headers_stdhdrnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9383;
	R1 = (u64)&cc_headers_stdhdrtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = *tou64p(R1);
	goto L9371;
L9383:
	i += 1; if (i <= av_1) goto L9379;
L9381:
	R1 = 0;
	goto L9371;
L9371:
	return asu64(R1);
}

static void cc_headers_writeheaders() {
    u64 R1, R2, R3, R4, R5; 
	u64 f;
	u64 ifile;
	i64 i;
	i64 av_1;
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9387;
L9385:
	R1 = tou64("hdr");
	R2 = (u64)&cc_headers_stdhdrnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	ifile = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Writing internal");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_headers_stdhdrnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("as");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ifile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("wb");
	asu64(R2) = ifile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = (u64)&cc_headers_stdhdrtext;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R2) = *tou64p(R2);
	asu64(R2) = strlen(asu64(R2));
	R3 = 1;
	R4 = (u64)&cc_headers_stdhdrtext;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R4) = *tou64p(R4);
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	i += 1; if (i <= av_1) goto L9385;
L9387:
	return;
}

static i64 cc_headers_isheaderfile(u64 file) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9391;
L9389:
	asu64(R1) = file;
	R2 = (u64)&cc_headers_stdhdrnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9393;
	R1 = 1;
	goto L9388;
L9393:
	i += 1; if (i <= av_1) goto L9389;
L9391:
	R1 = 0;
	goto L9388;
L9388:
	return asi64(R1);
}

static void cc_show_printcode(u64 f, u64 caption) {
    u64 R1, R2, R3, R4; 
	i64 i;
	u64 p;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L9396;
L9395:
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9399;
	goto L9400;
L9399:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9402;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_scopenames;
	asu64(R2) = p;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	R2 = 0;
	asu64(R3) = p;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9402:
	goto L9398;
L9400:
L9398:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L9396:
	asu64(R1) = p;
	if (asu64(R1)) goto L9395;
	return;
}

static void cc_show_printunit(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	i64 t;
	i64 n;
	i64 lincr;
	u64 idname;
	u64 pc;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9405;
	goto L9403;
L9405:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 77;
	if (asi64(R1) < asi64(R2)) goto L9407;
	msysc_m$print_startcon();
	R1 = tou64("print unit: bad tag");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 30;
	exit(R1);
L9407:
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	if (!asu32(R1)) goto L9409;
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_show_currlineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_show_currfileno = asi64(R1);
L9409:
	R1 = 1;
	lincr = asi64(R1);
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L9411;
	R1 = -1;
	lincr = asi64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("             ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9411:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = prefix;
	asi64(R3) = level;
	if (asi64(R3) < 0) asi64(R3) = -asi64(R3);
	asu64(R1) = cc_show_getprefix(asi64(R3), asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	idname = asu64(R1);
	asu64(R1) = idname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 106;
	if (asu64(R1) != asu64(R2)) goto L9413;
	R1 = (u64)&idname;
	(*tou64p(R1)) += 1;
L9413:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = idname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9415;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9415;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9416;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9416;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9416;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9417;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9418;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9419;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9420;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L9421;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L9422;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L9423;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L9423;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L9424;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L9425;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L9426;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L9427;
	goto L9428;
L9415:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9430;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" {");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = d;
	R3 = 72;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("}");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9430:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = d;
	asu64(R1) = cc_show_getdottedname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9432;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Lastcall:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L9432:
	goto L9414;
L9416:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = d;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L9403;
	goto L9414;
L9417:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L9414;
L9418:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L9414;
L9419:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Value:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9414;
L9420:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L9434;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9436;
	goto L9437;
L9436:
// cc_show.printunit.dostring:
L9438:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 256;
	if (asi64(R1) <= asi64(R2)) goto L9440;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("(LONGSTR)");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9439;
L9440:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L9439:
	goto L9433;
L9434:
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) != asi64(R2)) goto L9441;
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9443;
	goto L9437;
L9443:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("(WSTRING)");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9433;
L9441:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9444;
	asi64(R1) = t;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L9444;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9433;
L9444:
	asi64(R1) = t;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L9445;
	asi64(R1) = t;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L9445;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L9433;
L9445:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L9446;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L9433;
L9446:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9447;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9449;
	goto L9438;
L9449:
// cc_show.printunit.doref:
L9437:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	goto L9433;
L9447:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L9450;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9452;
	goto L9438;
L9452:
	R1 = tou64("PRINTUNIT/CONST/aRRAY");
	cc_support_serror(asu64(R1));
	goto L9433;
L9450:
	msysc_m$print_startcon();
	asi64(R1) = t;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("PRINTUNIT BAD CONST");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9433:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9454;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<STRCONST>");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9454:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9456;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<WSTRCONST>");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9456:
	goto L9414;
L9421:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&cc_tables_convnames;
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" => ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 58;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L9414;
L9422:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Scale:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9414;
L9423:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Ptrscale:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9414;
L9424:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L9458;
L9457:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L9458:
	asu64(R1) = pc;
	if (asu64(R1)) goto L9457;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9414;
L9425:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Aparams:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9414;
L9426:
	goto L9414;
L9427:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Offset:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9414;
L9428:
L9414:
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L9461;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Widen from:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 56;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9461:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9463;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ALENGTH=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L9463:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("2");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9465;
	R1 = tou64("3");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 32;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L9465:
L9403:
	return;
}

static void cc_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9468;
	goto L9466;
L9468:
	goto L9470;
L9469:
	asu64(R1) = prefix;
	asi64(R2) = level;
	asu64(R3) = p;
	asu64(R4) = dev;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L9470:
	asu64(R1) = p;
	if (asu64(R1)) goto L9469;
L9466:
	return;
}

static u64 cc_show_getprefix(i64 level, u64 prefix, u64 p) {
    u64 R1, R2, R3; 
	struct $B20 indentstr;
	u64 modestr;
	i64 length;
	i64 av_1;
	R1 = 0;
	R2 = (u64)&indentstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = level;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L9474;
	R1 = 10;
	level = asi64(R1);
L9474:
	R1 = tou64("-----------------------");
	R2 = (u64)&indentstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	modestr = asu64(R1);
	asu64(R1) = modestr;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&indentstr;
	asi64(R2) = strlen(asu64(R2));
	if (asi64(R1) >= asi64(R2)) goto L9476;
	asi64(R1) = length;
	asu64(R2) = modestr;
	R3 = (u64)&indentstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L9475;
L9476:
	asu64(R1) = modestr;
	R2 = (u64)&indentstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L9475:
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L9479;
L9477:
	R1 = tou64("|---");
	R2 = (u64)&indentstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L9477;
L9479:
	asu64(R1) = cc_show_getlineinfok();
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&indentstr;
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L9481;
	R1 = tou64(" ");
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L9481:
	R1 = (u64)&cc_show_getprefix_str;
	goto L9472;
L9472:
	return asu64(R1);
}

static u64 cc_show_getdottedname(u64 p) {
    u64 R1, R2; 
	struct $B16 str2;
	u64 owner;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	goto L9484;
L9483:
	R1 = (u64)&cc_show_getdottedname_str;
	R2 = (u64)&str2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
L9484:
	asu64(R1) = owner;
	if (!asu64(R1)) goto L9486;
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9483;
L9486:
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L9488;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L9488:
	R1 = (u64)&cc_show_getdottedname_str;
	goto L9482;
L9482:
	return asu64(R1);
}

static u64 cc_show_getlineinfok() {
    u64 R1, R2; 
	R1 = (u64)&cc_show_getlineinfok_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = cc_show_currfileno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("z5");
	asi64(R2) = cc_show_currlineno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	R1 = (u64)&cc_show_getlineinfok_str;
	goto L9489;
L9489:
	return asu64(R1);
}

static void cc_show_printst(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = p;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L9492;
	R1 = tou64("PRINTST not name");
	cc_support_mcerror(asu64(R1));
L9492:
	asi64(R1) = level;
	asu64(R2) = p;
	asu64(R3) = f;
	cc_show_printstrec(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L9494;
L9493:
	asi64(R1) = level;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	asu64(R3) = f;
	cc_show_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9494:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9493;
	return;
}

static void cc_show_printstrec(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	struct $B3 v;
	u64 d;
	i64 col;
	i64 offset;
	struct $B16 str;
	i64 scope;
	u64 pm;
	i64 av_1;
	R1 = (u64)&v;
	d = asu64(R1);
	asu64(R1) = d;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L9499;
L9497:
	R1 = tou64("    ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L9497;
L9499:
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L9501;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 45;
	R2 = 28;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9500;
L9501:
	R1 = 45;
	R2 = 28;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L9500:
	R1 = 46;
	R2 = 12;
	R3 = (u64)&cc_tables_namenames;
	asu64(R4) = p;
	R5 = 109;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	asi64(R1) = mlib_gs_getcol(asu64(R1));
	col = asi64(R1);
	R1 = tou64("[");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_tables_scopenames;
	asu64(R2) = p;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 108;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 4;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9503;
	R1 = tou64("@@");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L9503:
	asu64(R1) = p;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9505;
	R1 = tou64("Var ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L9505:
	asu64(R1) = p;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9507;
	R1 = tou64("Used ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L9507:
	asu64(R1) = p;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9509;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Pm:# ");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L9509:
	R1 = tou64("]");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 61;
	asi64(R2) = col;
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R3) = d;
	mlib_gs_padto(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9511;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 32;
	R2 = 18;
	R3 = (u64)&str;
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9510;
L9511:
	R1 = 32;
	R2 = 18;
	R3 = tou64("()");
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L9510:
	asu64(R1) = p;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9513;
	goto L9514;
L9513:
	R1 = tou64("Void ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L9512;
L9514:
	R1 = 1;
	asu64(R2) = p;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	mlib_gs_strsp(asu64(R2), asu64(R1));
L9512:
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9516;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9517;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9517;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9518;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9519;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9520;
	goto L9521;
L9516:
	R1 = tou64("Offset:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L9515;
L9517:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9523;
	R1 = tou64("=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_show_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L9523:
	R1 = tou64(" Offset: ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L9515;
L9518:
	R1 = tou64("Index:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L9515;
L9519:
	R1 = tou64("Enum:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L9515;
L9520:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9525;
	R1 = tou64("=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_show_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L9525:
	R1 = tou64("STATIC********");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L9515;
L9521:
L9515:
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("Lineno:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 92;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asu64(R2) = p;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9527;
	asu64(R1) = d;
	mlib_gs_line(asu64(R1));
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	goto L9529;
L9528:
	R1 = tou64("\t\tParam: ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 45;
	R2 = 10;
	asu64(R3) = pm;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	if (!asu64(R3)) goto L9532;
	asu64(R3) = pm;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	goto L9531;
L9532:
	R3 = tou64("Anon");
L9531:
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&cc_tables_pmflagnames;
	asu64(R2) = pm;
	R3 = 22;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" Mode:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" Code:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = d;
	mlib_gs_line(asu64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L9529:
	asu64(R1) = pm;
	if (asu64(R1)) goto L9528;
L9527:
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9534;
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9536;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9536;
	goto L9537;
L9536:
	R1 = tou64("*");
	R2 = -3;
	asu64(R3) = p;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L9535;
L9537:
L9535:
L9534:
	return;
}

static void cc_show_printstflat(u64 f) {
    u64 R1, R2, R3; 
	i64 i;
	u64 p;
	u64 lx;
	i64 av_1;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("GLOBAL SYMBOL TABLE:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L9541;
L9539:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9543;
	asu64(R1) = p;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L9545;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L9545;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L9545;
	goto L9546;
L9545:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = cc_lib_getstname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asu64(R2) = p;
	R3 = 107;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = p;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L9548;
L9547:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = cc_lib_getstname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asu64(R2) = p;
	R3 = 107;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = p;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("(From");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9551;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	goto L9550;
L9551:
	R1 = tou64("-");
L9550:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(")");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L9548:
	asu64(R1) = p;
	if (asu64(R1)) goto L9547;
	goto L9544;
L9546:
L9544:
L9543:
	i += 1; if (i <= av_1) goto L9539;
L9541:
	return;
}

static u64 cc_show_strexpr(u64 p) {
    u64 R1, R2; 
	asu64(R1) = cc_show_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = cc_show_exprstr;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = cc_show_exprstr;
	goto L9552;
L9552:
	return asu64(R1);
}

static void cc_show_jeval(u64 dest, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B50 str;
	i64 lb;
	i64 t;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9555;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9556;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9557;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L9558;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L9559;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L9559;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L9559;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L9559;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L9559;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L9560;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L9561;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L9562;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L9563;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L9563;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9564;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L9565;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L9566;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L9567;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9568;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L9569;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L9570;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L9571;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L9572;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9573;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L9574;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L9575;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9576;
	goto L9577;
L9555:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L9579;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9581;
	goto L9582;
L9581:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9584;
	goto L9582;
L9584:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8000;
	if (asi64(R1) <= asi64(R2)) goto L9586;
	R1 = tou64("LONGSTR)");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9585;
L9586:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
L9585:
	R1 = tou64("\"");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9553;
	goto L9578;
L9579:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9587;
	asi64(R1) = t;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L9587;
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L9578;
L9587:
	asi64(R1) = t;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L9588;
	asi64(R1) = t;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L9588;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9578;
L9588:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9590;
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9589;
L9590:
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9578;
L9589:
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L9592;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9593;
	goto L9594;
L9592:
// cc_show.jeval.doref:
L9582:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	goto L9591;
L9593:
	R1 = tou64("ARRAY");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L9591;
L9594:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("EVAL/C");
	mlib_abortprogram(asu64(R1));
L9591:
L9578:
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9556:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9557:
	R1 = tou64("&");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9558:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_getopcjname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9559:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_getopcjname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9560:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L9596;
L9595:
	asu64(R1) = q;
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L9599;
	R1 = tou64(",");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
L9599:
L9596:
	asu64(R1) = q;
	if (asu64(R1)) goto L9595;
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9561:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("???");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L9554;
L9562:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("->");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L9554;
L9563:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 29;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	lb = asi64(R1);
	asi64(R1) = lb;
	if (!asi64(R1)) goto L9601;
	R1 = tou64("(");
	goto L9600;
L9601:
	R1 = tou64("{");
L9600:
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L9603;
L9602:
	asu64(R1) = q;
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L9606;
	R1 = tou64(",");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
L9606:
L9603:
	asu64(R1) = q;
	if (asu64(R1)) goto L9602;
	asi64(R1) = lb;
	if (!asi64(R1)) goto L9608;
	R1 = tou64(")");
	goto L9607;
L9608:
	R1 = tou64("}");
L9607:
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9564:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("=");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L9554;
L9565:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("?");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(":");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L9554;
L9566:
	R1 = 1;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9567:
	R1 = tou64("*(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9610;
	R1 = tou64("+");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
L9610:
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9568:
	R1 = tou64("<JBLOCK>");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9569:
	R1 = tou64("++");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L9554;
L9570:
	R1 = tou64("--");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L9554;
L9571:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("++");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9572:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("--");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L9554;
L9573:
	R1 = tou64("<nullunit>");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L9554;
L9574:
	R1 = tou64("scale((");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L9612;
	R1 = tou64(")*");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L9611;
L9612:
	R1 = tou64(")/");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R2) = dest;
	mlib_gs_strint(asu64(R2), asi64(R1));
L9611:
	R1 = tou64(")");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L9554;
L9575:
	R1 = tou64("(");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("+");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L9554;
L9576:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L9554;
L9577:
	R1 = tou64("<CAN'T DO JEVAL>");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L9554:
L9553:
	return;
}

static void cc_show_printfilelist(u64 f) {
    u64 R1, R2, R3; 
	i64 i;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Source files");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9616;
L9614:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# # (#)");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("12jl");
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nsourcefiles) goto L9614;
L9616:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\nInput file:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\nLibfiles");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nlibfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9619;
L9617:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nlibfiles) goto L9617;
L9619:
	return;
}

static void cc_show_printmodelist(u64 f) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mbase;
	u64 d;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC MODELIST");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	m = asi64(R1);
	asi64(R1) = cc_decls_ntypes;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L9623;
L9621:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("4");
	asi64(R2) = m;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	R1 = (u64)&cc_decls_tttypedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L9625;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Typedef:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_tttypedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9625:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Basetype:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mbase;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = 1;
	asi64(R2) = mbase;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Name:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("ttnamedef:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	if (!asu64(R1)) goto L9627;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L9626;
L9627:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9626:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Target:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Length:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isblock:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Const:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Signed:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttsigned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Ref:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Constver:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Shared:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttshared;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	m += 1; if (m <= cc_decls_ntypes) goto L9621;
L9623:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void pcl_start() {
	mc_genss_start();
	mc_decls_start();
	mc_writeasm_start();
	return;
}

static struct $B92 $procaddr = {{
(u64)&mc_genmcl_px_nop,
(u64)&mc_genmcl_px_dupl,
(u64)&mc_genmcl_px_double,
(u64)&mc_genmcl_px_opnd,
(u64)&mc_genmcl_px_type,
(u64)&mc_genmcl_px_comment,
(u64)&mc_genmcl_px_proc,
(u64)&mc_genmcl_px_endproc,
(u64)&mc_genmcl_px_endprog,
(u64)&mc_genmcl_px_istatic,
(u64)&mc_genmcl_px_zstatic,
(u64)&mc_genmcl_px_data,
(u64)&mc_genmcl_px_label,
(u64)&mc_genmcl_px_load,
(u64)&mc_genmcl_px_store,
(u64)&mc_genmcl_px_add,
(u64)&mc_genmcl_px_sub,
(u64)&mc_genmcl_px_mul,
(u64)&mc_genmcl_px_div,
(u64)&mc_genmcl_px_eval,
(u64)&mc_genmcl_px_widen,
(u64)&mc_genmcl_px_jump,
(u64)&mc_genmcl_px_ijump,
(u64)&mc_genmcl_px_neg,
(u64)&mc_genmcl_px_abs,
(u64)&mc_genmcl_px_bitnot,
(u64)&mc_genmcl_px_not,
(u64)&mc_genmcl_px_toboolt,
(u64)&mc_genmcl_px_sqr,
(u64)&mc_genmcl_px_sqrt,
(u64)&mc_genmcl_px_jumpcc,
(u64)&mc_genmcl_px_jumpt,
(u64)&mc_genmcl_px_jumpf,
(u64)&mc_genmcl_px_bitand,
(u64)&mc_genmcl_px_bitor,
(u64)&mc_genmcl_px_bitxor,
(u64)&mc_genmcl_px_shl,
(u64)&mc_genmcl_px_shr,
(u64)&mc_genmcl_px_retproc,
(u64)&mc_genmcl_px_retfn,
(u64)&mc_genmcl_px_setcall,
(u64)&mc_genmcl_px_setarg,
(u64)&mc_genmcl_px_callp,
(u64)&mc_genmcl_px_jumpret,
(u64)&mc_genmcl_px_jumpretm,
(u64)&mc_genmcl_px_startmx,
(u64)&mc_genmcl_px_resetmx,
(u64)&mc_genmcl_px_stop,
(u64)&mc_genmcl_px_incrto,
(u64)&mc_genmcl_px_decrto,
(u64)&mc_genmcl_px_incrload,
(u64)&mc_genmcl_px_decrload,
(u64)&mc_genmcl_px_loadincr,
(u64)&mc_genmcl_px_loaddecr,
(u64)&mc_genmcl_px_forup,
(u64)&mc_genmcl_px_fordown,
(u64)&mc_genmcl_px_iload,
(u64)&mc_genmcl_px_iloadx,
(u64)&mc_genmcl_px_istore,
(u64)&mc_genmcl_px_istorex,
(u64)&mc_genmcl_px_storem,
(u64)&mc_genmcl_px_addpx,
(u64)&mc_genmcl_px_subpx,
(u64)&mc_genmcl_px_to,
(u64)&mc_genmcl_px_iswap,
(u64)&mc_genmcl_px_swapstk,
(u64)&mc_genmcl_px_labeldef,
(u64)&mc_genmcl_px_addto,
(u64)&mc_genmcl_px_subto,
(u64)&mc_genmcl_px_multo,
(u64)&mc_genmcl_px_bitandto,
(u64)&mc_genmcl_px_bitorto,
(u64)&mc_genmcl_px_bitxorto,
(u64)&mc_genmcl_px_shlto,
(u64)&mc_genmcl_px_shrto,
(u64)&mc_genmcl_px_fix,
(u64)&mc_genmcl_px_float,
(u64)&mc_genmcl_px_idiv,
(u64)&mc_genmcl_px_irem,
(u64)&mc_genmcl_px_idivrem,
(u64)&mc_genmcl_px_clear,
(u64)&mc_genmcl_px_subp,
(u64)&mc_genmcl_px_switch,
(u64)&mc_genmcl_px_switchu,
(u64)&mc_genmcl_px_swlabel,
(u64)&mc_genmcl_px_endsw,
(u64)&mc_genmcl_px_fwiden,
(u64)&mc_genmcl_px_fnarrow,
(u64)&mc_genmcl_px_truncate,
(u64)&mc_genmcl_px_typepun,
(u64)&mc_genmcl_px_unload,
(u64)&mc_genmcl_px_loadbit,
(u64)&mc_genmcl_px_assem,
(u64)&mc_genmcl_px_sin,
(u64)&mc_genmcl_px_cos,
(u64)&mc_genmcl_px_tan,
(u64)&mc_genmcl_px_asin,
(u64)&mc_genmcl_px_acos,
(u64)&mc_genmcl_px_atan,
(u64)&mc_genmcl_px_log,
(u64)&mc_genmcl_px_log10,
(u64)&mc_genmcl_px_exp,
(u64)&mc_genmcl_px_round,
(u64)&mc_genmcl_px_floor,
(u64)&mc_genmcl_px_ceil,
(u64)&mc_genmcl_px_atan2,
(u64)&mc_genmcl_px_fmod,
(u64)&mc_genmcl_px_setcc,
(u64)&mc_genmcl_px_min,
(u64)&mc_genmcl_px_max,
(u64)&mc_genmcl_px_power,
(u64)&mc_genmcl_px_minto,
(u64)&mc_genmcl_px_maxto,
(u64)&mc_genmcl_px_negto,
(u64)&mc_genmcl_px_absto,
(u64)&mc_genmcl_px_addpxto,
(u64)&mc_genmcl_px_subpxto,
(u64)&mc_genmcl_px_divto,
(u64)&mc_genmcl_px_bitnotto,
(u64)&mc_genmcl_px_notto,
(u64)&mc_genmcl_px_toboolto,
(u64)&mc_genmcl_px_sign,
(u64)&mc_genmcl_px_loadbf,
(u64)&mc_genmcl_px_storebit,
(u64)&mc_genmcl_px_storebf,
(u64)&mc_genmcl_px_loadall,
(u64)&mc_genmcl_px_setjmp,
(u64)&mc_genmcl_px_longjmp,
(u64)&mc_genmcl_px_initdswx,
(u64)&mc_auxmcl_do_addrmode}};

static struct $B92 $procname = {{
(u64)"px_nop",
(u64)"px_dupl",
(u64)"px_double",
(u64)"px_opnd",
(u64)"px_type",
(u64)"px_comment",
(u64)"px_proc",
(u64)"px_endproc",
(u64)"px_endprog",
(u64)"px_istatic",
(u64)"px_zstatic",
(u64)"px_data",
(u64)"px_label",
(u64)"px_load",
(u64)"px_store",
(u64)"px_add",
(u64)"px_sub",
(u64)"px_mul",
(u64)"px_div",
(u64)"px_eval",
(u64)"px_widen",
(u64)"px_jump",
(u64)"px_ijump",
(u64)"px_neg",
(u64)"px_abs",
(u64)"px_bitnot",
(u64)"px_not",
(u64)"px_toboolt",
(u64)"px_sqr",
(u64)"px_sqrt",
(u64)"px_jumpcc",
(u64)"px_jumpt",
(u64)"px_jumpf",
(u64)"px_bitand",
(u64)"px_bitor",
(u64)"px_bitxor",
(u64)"px_shl",
(u64)"px_shr",
(u64)"px_retproc",
(u64)"px_retfn",
(u64)"px_setcall",
(u64)"px_setarg",
(u64)"px_callp",
(u64)"px_jumpret",
(u64)"px_jumpretm",
(u64)"px_startmx",
(u64)"px_resetmx",
(u64)"px_stop",
(u64)"px_incrto",
(u64)"px_decrto",
(u64)"px_incrload",
(u64)"px_decrload",
(u64)"px_loadincr",
(u64)"px_loaddecr",
(u64)"px_forup",
(u64)"px_fordown",
(u64)"px_iload",
(u64)"px_iloadx",
(u64)"px_istore",
(u64)"px_istorex",
(u64)"px_storem",
(u64)"px_addpx",
(u64)"px_subpx",
(u64)"px_to",
(u64)"px_iswap",
(u64)"px_swapstk",
(u64)"px_labeldef",
(u64)"px_addto",
(u64)"px_subto",
(u64)"px_multo",
(u64)"px_bitandto",
(u64)"px_bitorto",
(u64)"px_bitxorto",
(u64)"px_shlto",
(u64)"px_shrto",
(u64)"px_fix",
(u64)"px_float",
(u64)"px_idiv",
(u64)"px_irem",
(u64)"px_idivrem",
(u64)"px_clear",
(u64)"px_subp",
(u64)"px_switch",
(u64)"px_switchu",
(u64)"px_swlabel",
(u64)"px_endsw",
(u64)"px_fwiden",
(u64)"px_fnarrow",
(u64)"px_truncate",
(u64)"px_typepun",
(u64)"px_unload",
(u64)"px_loadbit",
(u64)"px_assem",
(u64)"px_sin",
(u64)"px_cos",
(u64)"px_tan",
(u64)"px_asin",
(u64)"px_acos",
(u64)"px_atan",
(u64)"px_log",
(u64)"px_log10",
(u64)"px_exp",
(u64)"px_round",
(u64)"px_floor",
(u64)"px_ceil",
(u64)"px_atan2",
(u64)"px_fmod",
(u64)"px_setcc",
(u64)"px_min",
(u64)"px_max",
(u64)"px_power",
(u64)"px_minto",
(u64)"px_maxto",
(u64)"px_negto",
(u64)"px_absto",
(u64)"px_addpxto",
(u64)"px_subpxto",
(u64)"px_divto",
(u64)"px_bitnotto",
(u64)"px_notto",
(u64)"px_toboolto",
(u64)"px_sign",
(u64)"px_loadbf",
(u64)"px_storebit",
(u64)"px_storebf",
(u64)"px_loadall",
(u64)"px_setjmp",
(u64)"px_longjmp",
(u64)"px_initdswx",
(u64)"do_addrmode"}};

static i64 $nprocs = 130;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

