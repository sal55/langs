// Generated C
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void cc_cli_main();
void (*entrypoint)(void) = cc_cli_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u64 a[4];};   // mem:32;
struct $B18 {u64 a[50];};   // mem:400;
struct $B19 {u64 a[143];};   // mem:1144;
struct $B20 {u64 a[64];};   // mem:512;
struct $B21 {u64 a[14];};   // mem:112;
struct $B22 {u16 a[7];};   // mem:14;
struct $B23 {u8 a[143];};   // mem:143;
struct $B24 {u64 a[7];};   // mem:56;
struct $B25 {u16 a[3];};   // mem:6;
struct $B26 {u16 a[9];};   // mem:18;
struct $B27 {u16 a[1];};   // mem:2;
struct $B28 {u64 a[12];};   // mem:96;
struct $B29 {u64 a[20];};   // mem:160;
struct $B30 {u64 a[152];};   // mem:1216;
struct $B31 {u64 a[19];};   // mem:152;
struct $B32 {u64 a[21];};   // mem:168;
struct $B33 {u8 a[21];};   // mem:21;
struct $B34 {u64 a[137];};   // mem:1096;
struct $B35 {u8 a[137];};   // mem:137;
struct $B36 {u64 a[16];};   // mem:128;
struct $B37 {u64 a[8];};   // mem:64;
struct $B38 {u64 a[18];};   // mem:144;
struct $B39 {u16 a[25];};   // mem:50;
struct $B40 {u64 a[17];};   // mem:136;
struct $B41 {u64 a[128];};   // mem:1024;
struct $B42 {u64 a[193];};   // mem:1544;
struct $B43 {u64 a[1];};   // mem:8;
struct $B44 {u64 a[13];};   // mem:104;
struct $B45 {u32 a[5];};   // mem:20;
struct $B46 {u64 a[49];};   // mem:392;
struct $B47 {u8 a[49];};   // mem:49;
struct $B48 {u64 a[80000];};   // mem:640000;
struct $B49 {u64 a[20000];};   // mem:160000;
struct $B50 {u64 a[10000];};   // mem:80000;
struct $B51 {u64 a[40000];};   // mem:320000;
struct $B52 {u64 a[201];};   // mem:1608;
struct $B53 {u32 a[201];};   // mem:804;
struct $B54 {u32 a[2101];};   // mem:8404;
struct $B55 {u32 a[101];};   // mem:404;
struct $B56 {u64 a[199];};   // mem:1592;
struct $B57 {u64 a[100];};   // mem:800;
struct $B58 {u64 a[22];};   // mem:176;
struct $B59 {u16 a[11];};   // mem:22;
struct $B60 {u64 a[5];};   // mem:40;
struct $B61 {u64 a[15];};   // mem:120;
struct $B62 {u32 a[15];};   // mem:60;
struct $B63 {u8 a[15];};   // mem:15;
struct $B64 {u64 a[78];};   // mem:624;
struct $B65 {u64 a[96];};   // mem:768;
struct $B66 {u64 a[63];};   // mem:504;
struct $B67 {u32 a[63];};   // mem:252;
struct $B68 {u8 a[363];};   // mem:363;
struct $B69 {u8 a[3];};   // mem:3;
struct $B70 {u64 a[34];};   // mem:272;
struct $B71 {u64 a[60];};   // mem:480;
struct $B72 {u64 a[87000];};   // mem:696000;
struct $B73 {u64 a[200];};   // mem:1600;
struct $B74 {u32 a[39];};   // mem:156;
struct $B75 {u64 a[2048];};   // mem:16384;
struct $B76 {u64 a[130];};   // mem:1040;
struct $B77 {u64 a[45];};   // mem:360;
struct $B78 {u64 a[320];};   // mem:2560;
struct $B79 {u64 a[157];};   // mem:1256;
struct $B80 {u32 a[125];};   // mem:500;
struct $B81 {u64 a[256];};   // mem:2048;
struct $B82 {u64 a[250];};   // mem:2000;
struct $B83 {u64 a[2000];};   // mem:16000;

// Function Ptr Types:
typedef i64 (*F1)();
typedef i64 (*F2)(i64);
typedef i64 (*F3)(i64, i64);
typedef i64 (*F4)(i64, i64, i64);
typedef i64 (*F5)(i64, i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F13)();
typedef r64 (*F14)(i64);
typedef r64 (*F15)(i64, i64);
typedef i64 (*F16)(i64, u64, u64);
typedef i64 (*F17)(u64);
typedef void (*F18)(u64);
typedef u64 (*F19)(i64);

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u8 pepcl_pc_userunpcl;
static u8 pepcl_asmonly;
static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc;
static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B17 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest;
static struct $B18 pc_decls_plibfiles;
static struct $B18 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype;
static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole;
static u8 pc_decls_fregoptim;
static i64 pc_decls_pcltime;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B19 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_decls_npcl;
static i64 pc_decls_npst;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest;
static i64 pc_diags_destlinestart;
static struct $B20 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static struct $B21 pc_tables_pstdnames;
static struct $B22 pc_tables_psize;
static struct $B22 pc_tables_psigned;
static struct $B22 pc_tables_pint;
static struct $B22 pc_tables_pfloat;
static struct $B22 pc_tables_pmin;
static struct $B22 pc_tables_xxpiwrb;
static struct $B21 pc_tables_opndnames;
static struct $B19 pc_tables_pclnames;
static struct $B23 pc_tables_pclhastype;
static struct $B23 pc_tables_pclextra;
static struct $B23 pc_tables_pclhasopnd;
static struct $B23 pc_tables_pclargs;
static struct $B24 pc_tables_ccnames;
static struct $B1 pc_tables_idnames;
static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B19 mc_genmcl_px_handlertable;
static struct $B25 mc_genmcl_scondcodes;
static struct $B25 mc_genmcl_ucondcodes;
static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B28 mc_libmcl_smallinttable;
static struct $B29 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B29 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B20 mc_stackmcl_stropndstack_str;
static i64 mc_genss_dummy_psstime;
static struct $B11 mc_decls_valtypenames;
static struct $B30 mc_decls_mclnames;
static struct $B31 mc_decls_mclnopnds;
static struct $B31 mc_decls_mclcodes;
static struct $B32 mc_decls_regnames;
static struct $B33 mc_decls_regcodes;
static struct $B29 mc_decls_condnames;
static struct $B29 mc_decls_asmcondnames;
static struct $B29 mc_decls_asmrevcond;
static struct $B34 mc_decls_dregnames;
static struct $B35 mc_decls_regsizes;
static struct $B35 mc_decls_regindices;
static struct $B36 mc_decls_xmmregnames;
static struct $B37 mc_decls_fregnames;
static struct $B37 mc_decls_mregnames;
static struct $B38 mc_decls_jmpccnames;
static struct $B26 mc_decls_jmpcccodes;
static struct $B36 mc_decls_setccnames;
static struct $B3 mc_decls_setcccodes;
static struct $B36 mc_decls_cmovccnames;
static struct $B3 mc_decls_cmovcccodes;
static struct $B12 mc_decls_segmentnames;
static struct $B8 mc_decls_reftypenames;
static struct $B12 mc_decls_opndnames_ma;
static struct $B18 mc_decls_pclopnd;
static struct $B39 mc_decls_pclreg;
static struct $B39 mc_decls_pclmode;
static struct $B39 mc_decls_pclcount;
static struct $B39 mc_decls_pclloc;
static struct $B39 mc_decls_pcltempflags;
static struct $B18 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B17 mc_decls_locnames;
static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames;
static struct $B17 mc_decls_callalign;
static struct $B17 mc_decls_callblockret;
static struct $B36 mc_decls_callblocksize;
static struct $B20 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used;
static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment;
static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B41 mc_decls_regtable;
static struct $B42 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes;
static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B18 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs;
static struct $B12 mc_decls_multxregs;
static struct $B22 mc_decls_ploadopx;
static struct $B22 mc_decls_ploadop;
static struct $B24 mc_objdecls_relocnames;
static u64 mc_writegas_asmext;
static struct $B41 mc_writegas_nregnames;
static u8 mc_writegas_currseg;
static struct $B20 mc_writegas_strmcl_str;
static struct $B20 mc_writegas_mstropnd_str;
static struct $B20 mc_writegas_strvalue_str;
static struct $B17 mc_writegas_getxregname_str;
static struct $B16 mc_writegas_getdispname_str;
static struct $B36 mc_writegas_gettempname_str;
static struct $B3 mc_writegas_strreg_str;
static struct $B44 cc_cli_passnames;
static struct $B44 cc_cli_extnames;
static u8 cc_cli_cc_pass;
static struct $B45 cc_cli_dummy;
static u8 cc_cli_debugmode;
static u64 cc_cli_outfile;
static u64 cc_cli_outext;
static i64 cc_cli_cmdskip;
static i64 cc_cli_ttt;
static u8 cc_cli_fverbose;
static u8 cc_cli_fshowincludes;
static u8 cc_cli_dointheaders;
static u8 cc_cli_highmem;
static u8 cc_cli_fshowst;
static u8 cc_cli_fshowstflat;
static u8 cc_cli_fshowast;
static u8 cc_cli_fshowpcl;
static u8 cc_cli_fshowpst;
static u8 cc_cli_fshowmcl;
static u8 cc_cli_fshowss;
static u8 cc_cli_fshowtypes;
static u8 cc_cli_fshowfiles;
static u8 cc_cli_fshowpaths;
static u8 cc_cli_fshowheaders;
static u8 cc_cli_fwriteheaders;
static u8 cc_cli_fshowlog;
static u8 cc_cli_fshowtiming;
static u8 cc_cli_fgendll;
static u8 cc_cli_fstdout;
static u8 cc_cli_fshortnames;
static u8 cc_cli_fwriteerrors;
static u64 cc_cli_entrypointname;
static struct $B46 cc_cli_optionnames;
static struct $B46 cc_cli_optvars;
static struct $B47 cc_cli_optvalues;
static i64 cc_cli_totallines;
static i64 cc_cli_nstringobjects;
static i64 cc_cli_startclock;
static i64 cc_cli_loadtime;
static i64 cc_cli_parsetime;
static i64 cc_cli_pcltime;
static i64 cc_cli_compiletime;
static i64 cc_cli_inittime;
static i64 cc_decls_ntypes;
static struct $B48 cc_decls_ttnamedef;
static struct $B49 cc_decls_ttbasetype;
static struct $B48 cc_decls_ttlength;
static struct $B50 cc_decls_ttconst;
static struct $B49 cc_decls_tttarget;
static struct $B49 cc_decls_ttreftype;
static struct $B49 cc_decls_ttconsttype;
static struct $B48 cc_decls_ttsize;
static struct $B50 cc_decls_ttisref;
static struct $B50 cc_decls_ttisblock;
static struct $B50 cc_decls_ttsigned;
static struct $B51 cc_decls_ttshared;
static struct $B48 cc_decls_ttparams;
static struct $B48 cc_decls_tttypedef;
static i64 cc_decls_trefchar;
static i64 cc_decls_trefwchar;
static u64 cc_decls_inputfile;
static i64 cc_decls_mainfileno;
static struct $B52 cc_decls_libfiles;
static struct $B52 cc_decls_sourcefilenames;
static struct $B52 cc_decls_sourcefilepaths;
static struct $B52 cc_decls_sourcefiletext;
static struct $B53 cc_decls_sourcefilesizes;
static i64 cc_decls_nsourcefiles;
static i64 cc_decls_nlibfiles;
static struct $B29 cc_decls_searchdirs;
static i64 cc_decls_nsearchdirs;
static struct $B29 cc_decls_includepaths;
static i64 cc_decls_nincludepaths;
static u64 cc_decls_stprogram;
static u64 cc_decls_stmodule;
static u64 cc_decls_logdev;
static u64 cc_decls_nullunit;
static i64 cc_decls_clineno;
static i64 cc_decls_cfileno;
static struct $B17 cc_decls_lx;
static struct $B17 cc_decls_nextlx;
static i64 cc_decls_debug;
static i64 cc_decls_hstsize;
static i64 cc_decls_hstmask;
static u64 cc_decls_hashtable;
static struct $B54 cc_decls_blockowner;
static struct $B54 cc_decls_blockcounts;
static struct $B55 cc_decls_blockstack;
static i64 cc_decls_currblockno;
static i64 cc_decls_nextblockno;
static i64 cc_decls_blocklevel;
static u64 cc_decls_currproc;
static u64 cc_decls_dheaderfile;
static i64 cc_decls_structpadding;
static i64 cc_decls_callbackflag;
static i64 cc_decls_slineno;
static i64 cc_decls_sfileno;
static u64 cc_decls_oemname;
static u64 cc_decls_mclstr;
static i64 cc_decls_mclstrlen;
static i64 cc_decls_nunits;
static struct $B56 cc_decls_pmodulelist;
static struct $B57 cc_decls_pheaderlist;
static struct $B57 cc_decls_pliblist;
static i64 cc_decls_npmodules;
static i64 cc_decls_npheaders;
static i64 cc_decls_nplibs;
static u8 cc_decls_pci_target;
static struct $B58 cc_tables_stdtypenames;
static struct $B59 cc_tables_stdtypewidths;
static struct $B59 cc_tables_stdsigned;
static struct $B59 cc_tables_stdpcl;
static struct $B59 cc_tables_stdsize;
static struct $B60 cc_tables_catnames;
static struct $B61 cc_tables_typespecnames;
static struct $B62 cc_tables_typespectypes;
static struct $B63 cc_tables_typespecsizes;
static struct $B17 cc_tables_pmflagnames;
static struct $B60 cc_tables_scopenames;
static struct $B12 cc_tables_cccnames;
static struct $B12 cc_tables_linkagenames;
static struct $B17 cc_tables_typequalnames;
static struct $B8 cc_tables_fnspecnames;
static struct $B64 cc_tables_jtagnames;
static struct $B65 cc_tables_symbolnames;
static struct $B65 cc_tables_shortsymbolnames;
static struct $B28 cc_tables_symboltojtag;
static struct $B61 cc_tables_sourcedirnames;
static struct $B60 cc_tables_namespacenames;
static struct $B61 cc_tables_namenames;
static struct $B62 cc_tables_namespaces;
static struct $B63 cc_tables_name2pid;
static struct $B66 cc_tables_stnames;
static struct $B67 cc_tables_stsymbols;
static struct $B67 cc_tables_stsubcodes;
static struct $B21 cc_tables_convnames;
static struct $B41 cc_tables_dominantmode;
static struct $B16 cc_tables_conversionops;
static struct $B68 cc_tables_dominantsetuptable;
static struct $B68 cc_tables_convsetuptable;
static struct $B70 cc_tables_badexprs;
static u64 cc_lex_tkptr;
static i64 cc_lex_dowhitespace;
static i64 cc_lex_nincludes;
static struct $B17 cc_lex_normaltkx;
static u64 cc_lex_normaltk;
static i64 cc_lex_noexpand;
static struct $B71 cc_lex_lx_stack;
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel;
static struct $B29 cc_lex_headerpathlist;
static struct $B15 cc_lex_headerpath;
static u64 cc_lex_lxstart;
static u64 cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static u64 cc_lex_lxsvalue;
static struct $B16 cc_lex_alphamap;
static struct $B16 cc_lex_digitmap;
static struct $B16 cc_lex_commentmap;
static struct $B16 cc_lex_linecommentmap;
static struct $B16 cc_lex_spacemap;
static u64 cc_lex_destcopy;
static struct $B72 cc_lex_pastedtokenlist;
static i64 cc_lex_npastedtokens;
static i64 cc_lex_isincludefile;
static i64 cc_lex_firstsymbol;
static u64 cc_lex_reallxsptr;
static i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static struct $B3 cc_lex_lex_preprocess_only_sbuffer;
static struct $B15 cc_lex_getsourcefile_filespec;
static i64 cc_lex_lasttoken;
static struct $B3 cc_lex_showtoken_buffer;
static struct $B3 cc_lex_stringify_buffer;
static u64 cc_parse_ist_symptr;
static struct $B37 cc_parse_looptypestack;
static i64 cc_parse_loopindex;
static struct $B20 cc_parse_casevaluestack;
static u8 cc_parse_ingeneric;
static i64 cc_genpcl_retindex;
static i64 cc_genpcl_initstaticsindex;
static struct $B73 cc_genpcl_loopstack;
static i64 cc_genpcl_loopindex;
static struct $B37 cc_genpcl_zero_unit;
static u64 cc_genpcl_pzero;
static i64 cc_genpcl_nvarlocals;
static i64 cc_genpcl_nvarparams;
static struct $B20 cc_blockpcl_continuestack;
static struct $B20 cc_blockpcl_breakstack;
static i64 cc_blockpcl_loopindex;
static u64 cc_blockpcl_sw_labeltable;
static u64 cc_blockpcl_sw_valuetable;
static i64 cc_blockpcl_sw_lower;
static i64 cc_blockpcl_sw_ncases;
static u8 cc_blockpcl_sw_defaultseen;
static i64 cc_blockpcl_sw_defaultlabel;
static i64 cc_blockpcl_sw_breaklabel;
static i64 cc_lib_autotypeno;
static i64 cc_lib_nextafindex;
static u64 cc_lib_unitheapptr;
static i64 cc_lib_remainingunits;
static struct $B74 cc_lib_getoptocode_opctotable;
static struct $B17 cc_lib_nextautotype_str;
static struct $B45 cc_lib_getopcjname_str;
static struct $B75 cc_lib_strmode_str;
static struct $B75 cc_lib_strmode2_str;
static struct $B15 cc_lib_typename_str;
static struct $B16 cc_lib_getstname_name;
static u64 cc_support_bytemasks;
static i64 cc_headers_builtinheaders;
static u64 cc_headers_h_assert;
static u64 cc_headers_h_ctype;
static u64 cc_headers_h_errno;
static u64 cc_headers_h_fenv;
static u64 cc_headers_h_float;
static u64 cc_headers_h_inttypes;
static u64 cc_headers_h_stdint;
static u64 cc_headers_h_limits;
static u64 cc_headers_h_locale;
static u64 cc_headers_h__ansi;
static u64 cc_headers_h_math;
static u64 cc_headers_h_setjmp;
static u64 cc_headers_h_signal;
static u64 cc_headers_h_stdarg;
static u64 cc_headers_h_stdbool;
static u64 cc_headers_h_stddef;
static u64 cc_headers_h_stdio;
static u64 cc_headers_h_stdlib;
static u64 cc_headers_h__syslist;
static u64 cc_headers_h_string;
static u64 cc_headers_h_time;
static u64 cc_headers_h_utime;
static u64 cc_headers_h_unistd;
static u64 cc_headers_h_safelib;
static u64 cc_headers_h_wchar;
static u64 cc_headers_h_wctype;
static u64 cc_headers_h_systypes;
static u64 cc_headers_h_sysstat;
static u64 cc_headers_h_systimeb;
static u64 cc_headers_h_sysutime;
static u64 cc_headers_h_memory;
static u64 cc_headers_h_fcntl;
static u64 cc_headers_h_io;
static u64 cc_headers_h_direct;
static u64 cc_headers_h_process;
static u64 cc_headers_h_malloc;
static u64 cc_headers_h_conio;
static u64 cc_headers_h_winsock2;
static u64 cc_headers_h__mingw;
static u64 cc_headers_h_windowsx;
static struct $B6 cc_headers_stdhdrnames;
static struct $B6 cc_headers_stdhdrtext;
static i64 cc_show_currfileno;
static i64 cc_show_currlineno;
static struct $B3 cc_show_sbuffer;
static u64 cc_show_dest;
static i64 cc_show_destlinestart;
static struct $B3 cc_show_exprstrvar;
static u64 cc_show_exprstr;
static struct $B20 cc_show_getprefix_str;
static struct $B16 cc_show_getdottedname_str;
static struct $B60 cc_show_getlineinfok_str;
static i64 $nprocs;
static struct $B76 $procname;
static struct $B76 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sqrt(r64 $1);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static u64 pc_api_strpmode(i64 mode, i64 size);
static u64 pc_api_getfullname(u64 d, i64 backtick);
static u64 pc_api_addstr(u64 s, u64 t);
static u64 pc_diags_stropnd(u64 p);
static void mc_genmcl_inithandlers();
static u64 mc_libmcl_mgenextname(u64 s);
static u64 mc_stackmcl_stropndstack(i64 indent);
static void mc_writegas_strmcl(u64 mcl);
static u64 mc_writegas_mstropnd(u64 a, i64 sizeprefix, i64 opcode);
static u64 mc_writegas_strvalue(u64 a);
static u64 mc_writegas_getxregname(i64 reg, i64 size);
static u64 mc_writegas_getdispname(u64 d);
static u64 mc_writegas_gettempname(u64 d, i64 n);
static u64 mc_writegas_strreg(i64 reg, i64 size);
static void cc_cli_showextrainfo();
static void cc_lex_lex_preprocess_only(u64 infile, u64 outfile, i64 toconsole);
static i64 cc_lex_getsourcefile(u64 file, i64 syshdr);
static void cc_lex_lexm();
static void cc_lex_showtoken(u64 lp);
static void cc_lex_stringify(u64 seq, u64 dest);
static void cc_lex_expandpredefmacro(i64 pdmcode, u64 tk, i64 lineno);
static i64 cc_lex_issimpleconstmacro(u64 m);
static i64 cc_lib_getoptocode(i64 opc);
static u64 cc_lib_nextautotype();
static u64 cc_lib_getopcjname(i64 opc);
static u64 cc_lib_strmode(i64 m, i64 expand);
static u64 cc_lib_strmode2(i64 m, i64 expand);
static u64 cc_lib_typename(i64 m);
static u64 cc_lib_getstname(u64 d);
static u64 cc_show_getprefix(i64 level, u64 prefix, u64 p);
static u64 cc_show_getdottedname(u64 p);
static u64 cc_show_getlineinfok();
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_startcon();
static void msysc_m$print_setfmt(u64 format);
static void msysc_m$print_end();
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_newline();
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mnoos_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mnoos_os_init();
static i64 mnoos_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mnoos_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mnoos_os_getch();
static i64 mnoos_os_kbhit();
static u64 mnoos_os_getdllinst(u64 name);
static u64 mnoos_os_getdllprocaddr(i64 hinst, u64 name);
static void mnoos_os_initwindows();
static void mnoos_os_gxregisterclass(u64 classname);
static void mnoos_os_setmesshandler(u64 addr);
static i64 mnoos_os_getchx();
static u64 mnoos_os_getos();
static i64 mnoos_os_gethostsize();
static i64 mnoos_os_shellexec(u64 opc, u64 file);
static void mnoos_os_sleep(i64 a);
static u64 mnoos_os_getstdout();
static u64 mnoos_os_gethostname();
static u64 mnoos_os_getmpath();
static i64 mnoos_os_clock();
static i64 mnoos_os_ticks();
static i64 mnoos_os_iswindows();
static void mnoos_os_getsystime(u64 $1);
static void mnoos_os_peek();
static u64 mnoos_os_allocexecmem(i64 n);
static i64 mnoos_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static i64 mnoos_os_hpcounter();
static i64 mnoos_os_hpfreq();
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
static u64 pc_api_pcl_start(u64 name, i64 nunits);
static void pc_api_pclerror(u64 mess);
static u64 pc_api_pc_makesymbol(u64 s, i64 id);
static void pc_api_pcl_end();
static void pc_api_pc_gen(i64 opcode, u64 p);
static u64 pc_api_pcl_writepcl(u64 filename);
static u64 pc_diags_writeallpcl();
static u64 pc_api_pcl_writepst(u64 filename);
static u64 pc_diags_writepst();
static void pc_api_pcl_genmcl();
static void mc_genmcl_genmcl(u64 dummy);
static void pc_api_pcl_genss(i64 obj);
static void mc_genss_dummy_genss(i64 obj);
static u64 pc_api_pcl_writess(u64 filename, i64 obj);
static u64 mc_writess_dummy_writessdata(i64 fexe);
static u64 pc_api_pcl_writeasm(u64 filename, i64 atype);
static u64 mc_writegas_getassemstr();
static void pc_api_pcl_writeobj(u64 filename);
static void mc_writeobj_dummy_writecoff(u64 outfile);
static void pc_api_pcl_writedll(u64 filename);
static void mc_writeexe_dummy_writeexe(u64 outfile, i64 dodll);
static void pc_api_pcl_writeexe(u64 filename);
static void pc_api_pcl_writemx(u64 filename);
static void mx_run_dummy_writemcx(u64 filename);
static void pc_api_pcl_exec();
static void mx_run_dummy_runlibfile(u64 filename, i64 cmdskip);
static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames);
static void pc_api_extendpclblock();
static u64 pc_api_newpcl();
static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset);
static void pc_api_pc_genx(i64 opcode, i64 x, u64 p);
static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p);
static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p);
static u64 pc_api_genint(i64 a);
static u64 pc_api_genreal(r64 x, i64 mode);
static u64 pc_api_genrealimm(r64 x, i64 mode);
static u64 pc_api_genstring(u64 s);
static u64 pc_api_genpcstrimm(u64 s);
static u64 pc_api_genlabel(i64 a);
static u64 pc_api_genmem(u64 d);
static u64 pc_api_genmemaddr(u64 d);
static u64 pc_api_gendata(u64 s, i64 length);
static void pc_api_gencomment(u64 s);
static u64 pc_api_genname(u64 s);
static u64 pc_api_gennameaddr(u64 s);
static u64 pc_api_genassem(u64 code);
static void pc_api_pc_setmode(i64 m, i64 size);
static void pc_api_pc_setmode2(i64 m);
static void pc_api_pc_setxy(i64 x, i64 y);
static void pc_api_pc_setscaleoff(i64 scale, i64 offset);
static void pc_api_pc_setoffset(i64 offset);
static void pc_api_pc_addoffset(i64 offset);
static void pc_api_pc_setincr(i64 n);
static void pc_api_pc_setnargs(i64 n);
static void pc_api_pc_setnvariadics(i64 n);
static void pc_api_pc_setalign(i64 n);
static void pc_api_perror(u64 mess);
static void pc_api_perror_s(u64 mess, u64 param);
static u64 pc_api_getbasename(u64 s);
static void pc_api_pc_addsymbol(u64 d);
static void pc_api_pcerrorstop(u64 filename, i64 lineno);
static void pc_api_pc_addplib(u64 name);
static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded);
static void pc_api_pc_setimport(u64 d);
static void pc_api_pc_addparam(u64 d);
static void pc_api_pc_addlocal(u64 d);
static void pc_api_pc_endproc();
static void pc_api_merror(u64 mess, u64 param);
static u64 pc_api_pc_duplpst(u64 d);
static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip);
static i64 pc_api_convertstring(u64 s, u64 t);
static void pc_diags_strpcl(u64 p);
static void pc_diags_strlabel(i64 labelno, i64 colon);
static void pc_diags_psstr(u64 s);
static void pc_diags_psname(u64 d);
static void pc_diags_psline();
static void pc_diags_psstrline(u64 s);
static void pc_diags_psdata(u64 p);
static void pc_diags_pstabto(i64 n);
static u64 pc_diags_strpclstr(u64 p, i64 buffsize);
static void pc_diags_writepcl(u64 p);
static void pc_diags_psint(i64 a);
static void pc_diags_psopnd(u64 p);
static void pc_diags_writepsymbol(u64 d, u64 fmt);
static void pc_diags_showprocinfo(u64 d);
static void pc_reduce_pcl_reducetest();
static void pc_run_dummy_pcl_runpcl();
static void mc_libmcl_mclinit(i64 bypass);
static void mc_libmcl_mgencomment(u64 s);
static void mc_genmcl_convertpcl(u64 p);
static void mc_stackmcl_showopndstack();
static void mc_auxmcl_genrealtable();
static void mc_auxmcl_genabsneg();
static void mc_auxmcl_genstringtable();
static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b);
static void mc_optim_peephole();
static void mc_genmcl_unimpl(u64 p);
static void mc_genmcl_doshowpcl(u64 p);
static void mc_genmcl_px_nop(u64 p);
static void mc_genmcl_px_dupl(u64 p);
static void mc_stackmcl_duplpcl();
static void mc_genmcl_px_double(u64 p);
static void mc_genmcl_px_opnd(u64 p);
static void mc_genmcl_px_type(u64 p);
static void mc_genmcl_px_comment(u64 p);
static void mc_genmcl_px_proc(u64 p);
static void mc_libmcl_setsegment(i64 seg, i64 align);
static u64 mc_libmcl_mgenmemaddr(u64 d);
static void mc_auxmcl_initproc(u64 d);
static void mc_auxmcl_fixmain();
static void mc_genmcl_px_endproc(u64 p);
static void mc_genmcl_px_endprog(u64 p);
static void mc_genmcl_px_istatic(u64 p);
static void mc_genmcl_px_zstatic(u64 p);
static u64 mc_libmcl_mgenint(i64 x, i64 mode);
static void mc_genmcl_px_data(u64 p);
static void mc_auxmcl_do_blockdata(u64 p);
static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode);
static i64 mc_libmcl_getstringindex(u64 s);
static u64 mc_libmcl_mgenlabel(i64 x);
static void mc_genmcl_px_label(u64 p);
static void mc_genmcl_px_load(u64 p);
static void mc_stackmcl_pushpcl(u64 p);
static void mc_genmcl_px_store(u64 p);
static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg);
static u64 mc_libmcl_mgenmem(u64 d, i64 mode);
static u64 mc_stackmcl_getworkregm(i64 mode);
static u64 mc_stackmcl_makeopndind(u64 a, i64 mode);
static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest);
static void mc_stackmcl_poppcl();
static void mc_genmcl_px_add(u64 p);
static u64 mc_stackmcl_isimmload(i64 n);
static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_sub(u64 p);
static void mc_genmcl_px_mul(u64 p);
static void mc_auxmcl_mulimm(u64 ax, i64 n);
static void mc_genmcl_px_div(u64 p);
static void mc_genmcl_px_eval(u64 p);
static void mc_genmcl_px_widen(u64 p);
static void mc_stackmcl_setnewzz(i64 reg, i64 mode);
static void mc_genmcl_px_jump(u64 p);
static void mc_genmcl_px_ijump(u64 p);
static void mc_genmcl_px_neg(u64 p);
static void mc_auxmcl_do_negreal(u64 ax, i64 mode);
static void mc_genmcl_px_abs(u64 p);
static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b);
static void mc_auxmcl_do_absreal(u64 ax, i64 mode);
static void mc_genmcl_px_bitnot(u64 p);
static void mc_genmcl_px_not(u64 p);
static u64 mc_libmcl_changeopndsize(u64 a, i64 size);
static void mc_genmcl_px_toboolt(u64 p);
static void mc_genmcl_px_sqr(u64 p);
static void mc_genmcl_px_sqrt(u64 p);
static void mc_genmcl_px_jumpcc(u64 p);
static void mc_genmcl_px_jumpt(u64 p);
static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond);
static void mc_genmcl_px_jumpf(u64 p);
static void mc_genmcl_px_bitand(u64 p);
static void mc_auxmcl_do_bitwise(u64 p, i64 opc);
static void mc_genmcl_px_bitor(u64 p);
static void mc_genmcl_px_bitxor(u64 p);
static void mc_genmcl_px_shl(u64 p);
static void mc_auxmcl_do_shift(u64 p, i64 opc);
static void mc_genmcl_px_shr(u64 p);
static void mc_genmcl_px_retproc(u64 p);
static void mc_auxmcl_do_procentry(u64 p);
static void mc_auxmcl_do_procexit();
static void mc_genmcl_px_retfn(u64 p);
static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset);
static u64 mc_libmcl_mgenreg(i64 reg, i64 mode);
static void mc_genmcl_px_setcall(u64 p);
static void mc_stackmcl_saveopnds(i64 n);
static void mc_libmcl_pushslots(i64 nslots);
static void mc_genmcl_px_setarg(u64 p);
static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno);
static void mc_stackmcl_pushopnd(i64 n, i64 mode);
static void mc_genmcl_px_callp(u64 p);
static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr);
static void mc_libmcl_popslots(i64 nslots);
static void mc_auxmcl_do_getretvalue(u64 p);
static void mc_genmcl_px_jumpret(u64 p);
static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_jumpretm(u64 p);
static void mc_stackmcl_movetoreg(i64 newreg);
static void mc_genmcl_px_startmx(u64 p);
static void mc_genmcl_px_resetmx(u64 p);
static void mc_genmcl_px_stop(u64 p);
static void mc_genmcl_px_incrto(u64 p);
static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrto(u64 p);
static void mc_genmcl_px_incrload(u64 p);
static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrload(u64 p);
static void mc_genmcl_px_loadincr(u64 p);
static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_loaddecr(u64 p);
static void mc_genmcl_px_forup(u64 p);
static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond);
static void mc_genmcl_px_fordown(u64 p);
static void mc_genmcl_px_iload(u64 p);
static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode);
static i64 mc_genmcl_getsharereg(u64 ax, i64 mode);
static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode);
static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode);
static void mc_auxmcl_dolea(u64 ax, u64 px);
static void mc_genmcl_px_iloadx(u64 p);
static u64 mc_auxmcl_do_addrmode(u64 p);
static void mc_genmcl_px_istore(u64 p);
static u64 mc_stackmcl_makesimpleaddr(u64 ax);
static void mc_genmcl_px_istorex(u64 p);
static void mc_genmcl_px_storem(u64 p);
static u64 mc_libmcl_newblocktemp(i64 size);
static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size);
static void mc_genmcl_px_addpx(u64 p);
static void mc_genmcl_px_subpx(u64 p);
static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale);
static void mc_genmcl_px_to(u64 p);
static void mc_genmcl_px_iswap(u64 p);
static void mc_genmcl_px_swapstk(u64 p);
static void mc_stackmcl_swapopnds(i64 m, i64 n);
static void mc_genmcl_px_labeldef(u64 p);
static void mc_genmcl_px_addto(u64 p);
static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc);
static void mc_genmcl_px_subto(u64 p);
static void mc_genmcl_px_multo(u64 p);
static void mc_auxmcl_do_binto_float(u64 p, i64 opc);
static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg);
static void mc_genmcl_px_bitandto(u64 p);
static void mc_genmcl_px_bitorto(u64 p);
static void mc_genmcl_px_bitxorto(u64 p);
static void mc_genmcl_px_shlto(u64 p);
static void mc_auxmcl_do_shiftnto(u64 p, i64 opc);
static void mc_genmcl_px_shrto(u64 p);
static void mc_genmcl_px_fix(u64 p);
static void mc_genmcl_px_float(u64 p);
static i64 mc_libmcl_mcreatefwdlabel();
static void mc_libmcl_mdefinefwdlabel(i64 lab);
static u64 mc_libmcl_mgenlabelmem(i64 x);
static void mc_genmcl_px_idiv(u64 p);
static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv);
static void mc_genmcl_px_irem(u64 p);
static void mc_genmcl_px_idivrem(u64 p);
static void mc_genmcl_px_clear(u64 p);
static void mc_auxmcl_clearblock(u64 ax, i64 n);
static void mc_genmcl_px_subp(u64 p);
static i64 mc_libmcl_ispoweroftwo(i64 x);
static void mc_genmcl_px_switch(u64 p);
static i64 mc_stackmcl_getworkireg();
static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def);
static void mc_genmcl_px_switchu(u64 p);
static void mc_genmcl_px_swlabel(u64 p);
static void mc_genmcl_px_endsw(u64 p);
static void mc_genmcl_px_fwiden(u64 p);
static void mc_genmcl_px_fnarrow(u64 p);
static void mc_genmcl_px_truncate(u64 p);
static void mc_genmcl_px_typepun(u64 p);
static void mc_genmcl_px_unload(u64 p);
static void mc_genmcl_px_loadbit(u64 p);
static void mc_genmcl_px_assem(u64 p);
static void mc_genmcl_px_sin(u64 p);
static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs);
static void mc_genmcl_px_cos(u64 p);
static void mc_genmcl_px_tan(u64 p);
static void mc_genmcl_px_asin(u64 p);
static void mc_genmcl_px_acos(u64 p);
static void mc_genmcl_px_atan(u64 p);
static void mc_genmcl_px_log(u64 p);
static void mc_genmcl_px_log10(u64 p);
static void mc_genmcl_px_exp(u64 p);
static void mc_genmcl_px_round(u64 p);
static void mc_genmcl_px_floor(u64 p);
static void mc_genmcl_px_ceil(u64 p);
static void mc_genmcl_px_atan2(u64 p);
static void mc_genmcl_px_fmod(u64 p);
static void mc_genmcl_px_setcc(u64 p);
static void mc_genmcl_px_min(u64 p);
static void mc_auxmcl_do_max_int(i64 cond);
static void mc_auxmcl_do_max_float(i64 opc);
static void mc_genmcl_px_max(u64 p);
static void mc_genmcl_px_power(u64 p);
static u64 mc_auxmcl_gethostfn(i64 opc);
static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs);
static void mc_genmcl_px_minto(u64 p);
static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode);
static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode);
static void mc_genmcl_px_maxto(u64 p);
static void mc_genmcl_px_negto(u64 p);
static void mc_genmcl_px_absto(u64 p);
static void mc_genmcl_px_addpxto(u64 p);
static void mc_genmcl_px_subpxto(u64 p);
static void mc_genmcl_px_divto(u64 p);
static void mc_genmcl_px_bitnotto(u64 p);
static void mc_genmcl_px_notto(u64 p);
static void mc_genmcl_px_toboolto(u64 p);
static void mc_genmcl_px_sign(u64 p);
static void mc_libmcl_clearreg(u64 ax);
static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode);
static void mc_genmcl_px_loadbf(u64 p);
static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j);
static void mc_auxmcl_do_loadbf_var(u64 p);
static void mc_genmcl_px_storebit(u64 p);
static void mc_auxmcl_do_storebit(u64 p);
static void mc_genmcl_px_storebf(u64 p);
static void mc_auxmcl_do_storebf(u64 p);
static void mc_genmcl_px_loadall(u64 p);
static void mc_stackmcl_checkallloaded();
static void mc_genmcl_px_setjmp(u64 p);
static void mc_stackmcl_freeworkregs(u64 p);
static void mc_genmcl_px_longjmp(u64 p);
static void mc_stackmcl_swapopndregs(i64 reg2);
static void mc_genmcl_px_initdswx(u64 p);
static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf);
static void mc_auxmcl_setmclentry(u64 p);
static u64 mc_libmcl_mgenname(u64 s);
static i64 mc_libmcl_roundsizetg(i64 size);
static u64 mc_auxmcl_resetmclentry();
static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size);
static void mc_auxmcl_spillparams();
static void mc_auxmcl_setmclentryf(u64 p);
static void mc_libmcl_pushstack(i64 n);
static u64 mc_auxmcl_resetmclentryf();
static void mc_libmcl_popstack(i64 n);
static i64 mc_auxmcl_ismemaddr(i64 n);
static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n);
static void mc_auxmcl_saverdx();
static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz);
static void mc_auxmcl_restorerdx();
static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype);
static void mc_auxmcl_gendb(i64 a);
static void mc_auxmcl_gendbstring(u64 s, i64 length);
static u64 mc_libmcl_mgenstring(u64 s, i64 length);
static void mc_auxmcl_gendq(i64 a);
static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs);
static u64 mc_libmcl_mgenreg0(i64 reg, i64 size);
static u64 mc_libmcl_newmclopnd();
static void mc_libmcl_initmcdest();
static u64 mc_libmcl_mgenint0(i64 x, i64 size);
static void mc_libmcl_genmc_str(i64 opcode, u64 s);
static u64 mc_libmcl_duplopnd(u64 a);
static i64 mc_libmcl_getrealindex(r64 x);
static i64 mc_libmcl_getr32index(r64 x);
static u64 mc_libmcl_mgenxregvar(u64 d);
static u64 mc_libmcl_mgenregvar(u64 d, i64 mode);
static u64 mc_libmcl_mgenregi(i64 reg, i64 mode);
static u64 mc_libmcl_mgentemp(i64 n, i64 mode);
static void mc_libmcl_merroropnd(u64 mess, i64 opndtype);
static u64 mc_libmcl_findnamesym(u64 s);
static void mc_libmcl_addnamesym(u64 d);
static i64 mc_libmcl_getprimreg(u64 ax);
static i64 mc_libmcl_addconst(u64 clist, i64 value);
static void mc_libmcl_axerror(u64 mess);
static void mc_libmcl_callproc(u64 cpname, u64 name, i64 lineno);
static u64 mc_libmcl_mgenstringx(u64 s);
static i64 mc_stackmcl_getworkreg(i64 mode);
static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg);
static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg);
static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax);
static void mc_stackmcl_savenextopnd();
static i64 mc_stackmcl_getworkxreg();
static void mc_stackmcl_saveopnd(i64 n, i64 allregs);
static void mc_stackmcl_savenextxopnd();
static i64 mc_optim_isreg0(u64 a);
static i64 mc_optim_endr0(u64 m);
static i64 mc_optim_isreg10(u64 a);
static i64 mc_optim_isreg(u64 a);
static u64 mc_optim_deletemcl(u64 p);
static i64 mc_optim_isconst(u64 a);
static i64 mc_optim_isreg00(u64 m);
static i64 mc_optim_sameoperand(u64 a, u64 b);
static i64 mc_optim_sameregopnd(u64 a, u64 b);
static void mc_decls_start();
static void mc_writegas_asmstr(u64 s);
static void mc_writegas_writemcl(i64 index, u64 mcl);
static void mc_writegas_start();
static void mc_writegas_asmchar(i64 c);
static void mc_writegas_asmopnd(u64 a, i64 sizeprefix, i64 opcode);
static i64 mc_writegas_needsizeprefix(i64 opcode, u64 a, u64 b);
static u64 mc_writegas_strmclstr(u64 m);
static u64 mc_writegas_getsizeprefix(i64 size, i64 enable);
static u64 mc_writegas_strxreg(i64 reg, i64 size);
static u64 mc_writegas_checkregvar(i64 reg, i64 ispfloat);
static void mc_writeexe_dummy_genexe(u64 entrypoint, u64 outfile, i64 dodll);
void cc_cli_main();
static void pepcl_start();
static void cc_cli_starttiming();
static void cc_cli_initdata();
static void cc_cli_getinputoptions();
static void cc_cli_initsearchdirs();
static void cc_cli_showsearchdirs();
static void cc_cli_initlogfile();
static i64 cc_cli_gettiming();
static void cc_cli_do_loadmodule();
static void cc_cli_do_preprocess();
static void cc_cli_do_parsemodule();
static void cc_cli_do_genpcl();
static void cc_cli_do_genmcl();
static void cc_cli_do_asm();
static void cc_cli_do_obj();
static void cc_cli_do_dll();
static void cc_cli_do_exe();
static void cc_cli_do_mx();
static void cc_cli_do_run();
static void cc_cli_showtiming();
static void cc_cli_closelogfile();
static u64 cc_lex_addnamestr(u64 name);
static u64 cc_lib_createdupldef(u64 owner, u64 symptr, i64 id);
static void cc_support_loaderror(u64 mess, u64 mess2);
static i64 cc_support_loadsourcefile(u64 file, u64 shortfile);
static i64 cc_parse_parsemodule();
static void cc_genpcl_codegen_pcl();
static void cc_lib_addtolog(u64 filename, u64 logdest);
static void cc_cli_showast();
static void cc_cli_showst(u64 caption);
static void cc_cli_showstflat(u64 caption);
static void cc_show_printmodelist(u64 f);
static void cc_lex_lexsetup();
static void cc_lib_inittypetables();
static void cc_lib_initcclib();
static i64 cc_cli_cgetsourceinfo(i64 pos, u64 filename, u64 sourceline);
static void cc_show_printcode(u64 f, u64 caption);
static void cc_show_printstflat(u64 f);
static void cc_show_printst(u64 f, u64 p, i64 level);
static void cc_cli_showfiles();
static void cc_cli_showtime(u64 caption, i64 t);
static void cc_cli_do_option(i64 sw, u64 value);
static void cc_cli_showcaption();
static void cc_headers_writeheaders();
static void cc_cli_showhelp();
static void cc_cli_showincludepaths();
static void cc_lex_setfileno(i64 fileno);
static void cc_lex_stacksourcefile(u64 file, i64 syshdr);
static void cc_lex_emittoken(u64 lp, u64 dest, i64 forcespace);
static void cc_lex_lxerror(u64 mess);
static void cc_lex_showtokens(u64 caption, u64 tk);
static void cc_lex_lexreadtoken();
static void cc_lex_lxreadstring(i64 termchar, i64 fwide);
static i64 cc_lex_lookup();
static void cc_lex_setnumberoffset(i64 offset);
static void cc_lex_readdecimal(u64 pstart);
static void cc_lex_readhex(u64 pstart);
static void cc_lex_readbinary(u64 pstart);
static void cc_lex_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base);
static void cc_lex_readoctal(u64 pstart);
static void cc_lex_readlinecomment();
static void cc_lex_readblockcomment();
static void cc_lex_unstacksourcefile();
static void cc_lex_old_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base);
static u64 cc_lex_scannumber(i64 base);
static i64 cc_lex_readexponent(u64 badexpon);
static void cc_lex_readalphanumeric(u64 pstart);
static i64 cc_lex_getfileno();
static void cc_lex_printsymbol(u64 lp);
static void cc_lex_printstrn(u64 s, i64 length, u64 f);
static void cc_lex_shownumberstr(u64 l, u64 f);
static void cc_lex_inithashtable();
static void cc_lex_fillhashtable();
static void cc_lex_newhashtable();
static u64 cc_lex_gethashvalue(u64 s, i64 length);
static i64 cc_lex_dolexdirective();
static i64 cc_lex_getlexdirective();
static u64 cc_lex_strtoken(u64 lp, u64 length);
static void cc_lex_dodefine();
static i64 cc_lex_getifdef();
static i64 cc_lex_getifexpr();
static i64 cc_lex_skipcode();
static void cc_lex_dopragmadir();
static void cc_lex_startlex(u64 caption, i64 fileno);
static void cc_lex_lex();
static void cc_lex_endlex();
static void cc_lex_ps(u64 caption);
static void cc_lex_psnext(u64 caption);
static i64 cc_lex_gethashtablesize();
static i64 cc_lex_checknumbersuffix();
static u64 cc_headers_findheader(u64 name);
static i64 cc_support_loadbuiltin(u64 shortfile, u64 hdrtext);
static i64 cc_lex_getfilenox(u64 tk);
static i64 cc_lex_getnumberoffsetx(u64 tk);
static void cc_lex_addlisttoken(u64 ulist, u64 ulistx, u64 p);
static void cc_lex_addlisttoken_copy(u64 ulist, u64 ulistx, u64 q);
static u64 cc_lex_alloctoken();
static void cc_lex_addlist_nextlx(u64 ulist, u64 ulistx);
static void cc_lex_addlisttoken_seq(u64 ulist, u64 ulistx, u64 seq);
static void cc_lex_addlistmparam(u64 ulist, u64 ulistx, u64 p);
static i64 cc_lex_inmacrostack(u64 d, u64 macrostack);
static void cc_lex_lexa(u64 tk);
static i64 cc_lex_peeklb();
static void cc_lex_dospecialinclude();
static u64 cc_lex_expandfnmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel, u64 endlineno);
static u64 cc_lex_expandobjmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel);
static i64 cc_lex_peektk(u64 tk);
static u64 cc_lex_substituteargs(u64 m, u64 args, u64 expargs, i64 nargs, u64 macrostack);
static u64 cc_lex_scantokenseq(u64 tk, u64 macrostack, u64 expanded);
static i64 cc_lex_readmacrocall(u64 d, u64 args, u64 tksource);
static u64 cc_lex_alloctokenz();
static void cc_lex_setfilenox(u64 tk, i64 fileno);
static void cc_lex_pastetokens(u64 tk, u64 tknext);
static u64 cc_lex_strstring(u64 s, i64 length, u64 newlength, i64 quotechar);
static i64 cc_lib_convertstringc(u64 s, u64 t, i64 length);
static i64 cc_lex_needspace(i64 a, i64 b);
static i64 cc_lex_evalcondexpr(u64 sx);
static i64 cc_lex_evalorexpr(u64 sx);
static i64 cc_lex_evalandexpr(u64 sx);
static i64 cc_lex_evaliorexpr(u64 sx);
static i64 cc_lex_evalixorexpr(u64 sx);
static i64 cc_lex_evaliandexpr(u64 sx);
static i64 cc_lex_evaleqexpr(u64 sx);
static i64 cc_lex_evalcmpexpr(u64 sx);
static i64 cc_lex_evalshiftexpr(u64 sx);
static i64 cc_lex_evaladdexpr(u64 sx);
static i64 cc_lex_evalmulexpr(u64 sx);
static i64 cc_lex_evalunaryexpr(u64 sx);
static i64 cc_lex_evalterm(u64 sx);
static void cc_lex_fastreadtoken();
static void cc_lex_freetokens(u64 tk);
static void cc_lex_addbuildinfo(i64 code);
static void cc_lex_freehashtable();
static void cc_lex_regenlookup(u64 d);
static void cc_parse_readmodule();
static void cc_support_serror(u64 mess);
static i64 cc_parse_readdeclspec(u64 owner, u64 linkage);
static i64 cc_parse_readtype(u64 owner, u64 d, i64 m, u64 pm);
static i64 cc_lib_createprocmode(i64 m, u64 pm);
static u64 cc_parse_createtypedef(u64 owner, u64 symptr, i64 mode);
static u64 cc_parse_readfunction(u64 d, i64 m, i64 linkage, u64 pm, u64 wasdef);
static u64 cc_parse_readmodulevar(u64 d, i64 m, i64 linkage);
static void cc_lib_skipsymbol(i64 symbol);
static void cc_support_serror_s(u64 mess, u64 a);
static void cc_lib_checksymbol(i64 symbol);
static i64 cc_parse_readstructdecl(u64 owner);
static i64 cc_parse_readenumdecl(u64 owner);
static i64 cc_parse_isusertype(u64 owner);
static i64 cc_lib_createconstmode(i64 m);
static i64 cc_parse_istypestarter();
static u64 cc_lib_resolvename(u64 owner, u64 symptr, i64 ns, i64 blockno);
static i64 cc_parse_istypestarter_next();
static u64 cc_parse_readexpression();
static u64 cc_parse_readterm();
static u64 cc_parse_readassignexpr();
static void cc_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static u64 cc_lib_createunit1(i64 tag, u64 p);
static u64 cc_parse_readcondexpr();
static void cc_parse_checklvalue(u64 p, i64 assign);
static u64 cc_parse_createassignopref(i64 opc, u64 p, u64 q);
static u64 cc_parse_coercemode(u64 p, i64 t);
static void cc_support_terror(u64 mess);
static u64 cc_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 cc_parse_readorlexpr();
static void cc_parse_coercecond(u64 p);
static u64 cc_lib_createunit3(i64 tag, u64 p, u64 q, u64 r);
static u64 cc_parse_readandlexpr();
static u64 cc_parse_readiorexpr();
static u64 cc_parse_readixorexpr();
static u64 cc_parse_readiandexpr();
static u64 cc_parse_readeqexpr();
static u64 cc_parse_readrelexpr();
static i64 cc_parse_checkpointertypes(i64 s, i64 t, i64 hard);
static u64 cc_parse_readshiftexpr();
static u64 cc_parse_readaddexpr();
static void cc_parse_coercebasetype(u64 p);
static u64 cc_parse_readmulexpr();
static u64 cc_parse_createaddop(u64 x, u64 y);
static u64 cc_parse_createsubop(u64 x, u64 y);
static u64 cc_parse_createmulop(u64 x, u64 y);
static u64 cc_parse_createdivop(u64 x, u64 y);
static u64 cc_parse_createremop(u64 x, u64 y);
static u64 cc_lib_createconstunit(u64 a, i64 t);
static u64 cc_lib_createunit0(i64 tag);
static i64 cc_lib_createrefmode(i64 m);
static u64 cc_lib_createname(u64 p);
static u64 cc_parse_createaddrofop(u64 p);
static void cc_parse_fixmemopnd(u64 p);
static u64 cc_lib_createwstringconstunit(u64 s, i64 length);
static u64 cc_lib_createstringconstunit(u64 s, i64 length);
static u64 cc_parse_createnegop(u64 p);
static u64 cc_parse_createinotop(u64 p);
static u64 cc_parse_createptrop(u64 p);
static u64 cc_parse_createincrop(i64 opc, u64 p);
static u64 cc_parse_createabsop(u64 p);
static i64 cc_parse_readcasttype(u64 d, i64 allowname, u64 pm, i64 m, u64 mbase);
static u64 cc_parse_docast(u64 p, i64 t, i64 hard, i64 inplace);
static u64 cc_parse_createsizeofop(u64 p, i64 islength);
static u64 cc_parse_readgeneric();
static u64 cc_parse_createindexop(u64 p, u64 q);
static u64 cc_parse_createdotop(i64 opc, u64 p, u64 d);
static u64 cc_parse_readexprlist(u64 p);
static u64 cc_parse_createcall(u64 p, u64 q);
static u64 cc_lib_checkdupl(u64 owner, u64 symptr, i64 ns, i64 blockno);
static void cc_support_serror_ss(u64 mess, u64 a, u64 b);
static i64 cc_parse_comparemode(i64 s, i64 t);
static u64 cc_parse_readinitexpr(u64 owner, i64 m);
static u64 cc_parse_readframevar(u64 d, i64 m, i64 linkage);
static u64 cc_lib_checkdupl_inproc(u64 owner, u64 symptr, i64 ns, i64 blockno);
static void cc_parse_readnamedtype(u64 owner, u64 d, u64 modtype, u64 modvalue, u64 nmodifiers);
static i64 cc_lib_createarraymode(i64 m, i64 length);
static u64 cc_parse_readparams(u64 owner);
static i64 cc_parse_readconstintexpr();
static u64 cc_parse_readinitexpr2(u64 owner, i64 m, i64 istop);
static void cc_parse_pushblock();
static void cc_parse_popblock();
static u64 cc_parse_readcompoundstmt(i64 params);
static u64 cc_parse_readstatement();
static u64 cc_parse_readblock(i64 ifelse);
static u64 cc_parse_readifstmt();
static u64 cc_parse_readforstmt();
static u64 cc_parse_readwhilestmt();
static u64 cc_parse_readdostmt();
static u64 cc_parse_readreturnstmt();
static u64 cc_parse_readswitchstmt();
static u64 cc_parse_readgotostmt();
static u64 cc_parse_readcaselabel();
static u64 cc_parse_readlocaldecl();
static u64 cc_parse_readcond();
static i64 cc_parse_iscondtrue(u64 p);
static void cc_parse_deleteunit(u64 p, u64 q);
static i64 cc_parse_iscondfalse(u64 p);
static u64 cc_parse_readexprstmt();
static void cc_parse_pushloop(i64 looptype);
static void cc_parse_poploop();
static void cc_parse_addcasevalue(i64 value);
static void cc_lib_addlistparam(u64 ulist, u64 ulistx, u64 p);
static void cc_parse_readfunctionbody(u64 f);
static i64 cc_lib_isintcc(i64 m);
static void cc_show_printunit(u64 dev, u64 p, i64 level, u64 prefix);
static u64 cc_parse_arraytopointer(u64 p);
static i64 cc_parse_getmemmode(u64 p);
static u64 cc_parse_eval_add(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_divunit(u64 p, i64 elemtype);
static u64 cc_parse_mulunit(u64 p, i64 elemtype);
static u64 cc_parse_eval_sub(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_mul(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_div(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_rem(i64 opc, u64 x, u64 y, i64 t);
static void cc_parse_insertunit(u64 p, i64 tag);
static i64 cc_parse_eval_convert(u64 p, i64 t, i64 opc);
static void cc_support_terror_s(u64 mess, u64 a);
static void cc_parse_coercemode_inplace(u64 p, i64 t);
static i64 cc_lib_createstructmode(u64 s, i64 smode);
static void cc_lib_addlistdef(u64 ulist, u64 ulistx, u64 p);
static i64 cc_lib_getalignment(i64 m);
static i64 cc_parse_roundoffset(i64 offset, i64 alignment);
static void cc_parse_addnewfield(u64 flist, u64 d, i64 offset);
static u64 cc_lib_getautofieldname();
static void cc_parse_readenumnames(u64 owner);
static i64 cc_lib_createenummode(u64 e);
static void cc_support_terror_ss(u64 mess, u64 a, u64 b);
static i64 cc_parse_getpromotedtype(i64 t);
static void cc_genpcl_dolibs();
static void cc_genpcl_dostaticvar(u64 d);
static void cc_support_gerror_s(u64 mess, u64 s, u64 p);
static void cc_genpcl_genprocdef(u64 p);
static u64 cc_libpcl_getpsymbol(u64 d);
static i64 cc_libpcl_createfwdlabel();
static void cc_blockpcl_do_stmt(u64 p);
static void cc_libpcl_definefwdlabel(i64 lab);
static void cc_libpcl_setmode(i64 mode);
static u64 cc_libpcl_genmem_d(u64 d);
static void cc_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset);
static void cc_genpcl_doresb(i64 n);
static i64 cc_lib_isrealcc(i64 m);
static void cc_support_gerror(u64 mess, u64 p);
static u64 cc_libpcl_genmemaddr_d(u64 d);
static void cc_genpcl_pushint(i64 a);
static void cc_blockpcl_do_decl(u64 d);
static void cc_blockpcl_dx_call(u64 p, u64 a, u64 b, i64 res);
static void cc_blockpcl_do_return(u64 p, u64 a);
static void cc_blockpcl_do_assign(u64 a, u64 b, i64 res);
static void cc_blockpcl_do_if(u64 a, u64 b, u64 c);
static void cc_blockpcl_do_for(u64 pinit, u64 pbody);
static void cc_blockpcl_do_while(u64 pcond, u64 pbody);
static void cc_blockpcl_do_dowhile(u64 pbody, u64 pcond);
static void cc_blockpcl_do_goto(u64 d);
static void cc_blockpcl_do_labeldef(u64 d);
static void cc_blockpcl_do_casestmt(u64 p, u64 a);
static void cc_blockpcl_genjumpl(i64 lab);
static void cc_blockpcl_do_switch(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_binto(u64 a, u64 b, i64 opc, i64 res);
static void cc_blockpcl_do_preincr(u64 a, i64 incrop);
static void cc_blockpcl_dx_expr(u64 p, i64 am);
static void cc_libpcl_setmode_u(u64 p);
static void cc_blockpcl_dx_const(u64 p);
static void cc_blockpcl_dx_name(u64 p, i64 am);
static void cc_blockpcl_dx_andorl(u64 p);
static void cc_libpcl_setmode2(i64 mode);
static void cc_blockpcl_dx_ifx(u64 p, u64 a, u64 b, u64 c);
static void cc_blockpcl_dx_eq(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_bin(u64 a, u64 b, i64 opc);
static void cc_blockpcl_dx_ptr(u64 p, u64 a, i64 am);
static void cc_blockpcl_dx_addptr(u64 p, u64 a, u64 b, i64 opc, i64 am);
static void cc_blockpcl_dx_convert(u64 p, u64 a, i64 t, i64 opc);
static void cc_blockpcl_dx_scale(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_preincrx(u64 p, u64 a);
static void cc_blockpcl_dx_postincrx(u64 p, u64 a);
static void cc_blockpcl_dx_addrof(u64 p, u64 a, i64 am);
static void cc_blockpcl_dx_dot(u64 p, u64 a, u64 b, i64 am);
static void cc_blockpcl_widen(u64 p);
static void cc_blockpcl_do_setinplace();
static void cc_blockpcl_do_fixwiden(u64 a, u64 b);
static void cc_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab);
static void cc_blockpcl_gcomparejump(i64 jumpopc, u64 p, u64 lhs, u64 rhs, i64 lab);
static i64 cc_blockpcl_getpclcond(i64 op);
static i64 cc_blockpcl_reversecond(i64 cc);
static void cc_blockpcl_do_while1(u64 pbody);
static void cc_blockpcl_stacklooplabels(i64 a, i64 b);
static i64 cc_libpcl_definelabel();
static void cc_blockpcl_setincrstep(i64 m);
static i64 cc_lib_getpclmode(i64 t);
static u64 cc_lib_newstrec();
static u64 cc_lib_allocunitrec();
static i64 cc_lib_getconstvalue(u64 p, i64 id);
static i64 cc_lib_copymode(i64 m);
static i64 cc_lib_createnewmode(i64 m);
static void cc_lib_setnameptr(u64 p);
static void cc_lib_istrmode(i64 m, i64 expand, u64 dest);
static void cc_support_mcerror(u64 mess);
static u64 cc_lib_createnewmoduledef(u64 owner, u64 symptr);
static u64 cc_lib_createnewproc(u64 owner, u64 symptr);
static u64 cc_lib_resolvelabel(u64 owner, u64 symptr);
static i64 cc_lib_isexported(u64 d);
static i64 cc_lib_isimported(u64 d);
static void cc_lib_writegsfile(u64 filename, u64 d);
static void cc_lib_pause(u64 mess);
static void cc_support_stopcompiler(u64 filename, i64 lineno);
static void cc_support_serror_gen(u64 mess);
static void cc_support_showmacrolineno();
static void cc_support_terror_gen(u64 mess);
static void cc_support_gerror_gen(u64 mess, u64 p);
static i64 cc_support_nextpoweroftwo(i64 x);
static u64 cc_support_splicelines(u64 s);
static void cc_support_gs_copytostr(u64 source, u64 s);
static void cc_support_gs_additem(u64 dest, u64 s);
static i64 cc_support_isalphanum(i64 c);
static i64 cc_headers_isheaderfile(u64 file);
static void cc_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix);
static void cc_show_printstrec(u64 f, u64 p, i64 level);
static u64 cc_show_strexpr(u64 p);
static void cc_show_jeval(u64 dest, u64 p);
static void cc_show_printfilelist(u64 f);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    cc_cli_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u8 pepcl_pc_userunpcl = 0;

static u8 pepcl_asmonly = 1;

static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc = 65536;

static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B17 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest = (u64)&pc_decls_sbuffer;

static struct $B18 pc_decls_plibfiles;
static struct $B18 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype = 16705;

static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole = 1;

static u8 pc_decls_fregoptim = 1;

static i64 pc_decls_pcltime;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B19 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_decls_npcl;
static i64 pc_decls_npst;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest = (u64)&pc_diags_sbuffer;

static i64 pc_diags_destlinestart;
static struct $B20 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static struct $B21 pc_tables_pstdnames = {{
(u64)"void",
(u64)"r32",
(u64)"r64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"mem",
(u64)"vec",
(u64)"$last"}};

static struct $B22 pc_tables_psize = {{
1024,
264,
1026,
264,
1026,
8,
0}};

static struct $B22 pc_tables_psigned = {{
0,
0,
0,
256,
257,
1,
0}};

static struct $B22 pc_tables_pint = {{
0,
256,
257,
257,
257,
1,
0}};

static struct $B22 pc_tables_pfloat = {{
256,
1,
0,
0,
0,
0,
0}};

static struct $B22 pc_tables_pmin = {{
256,
1282,
1285,
2310,
2313,
2826,
12}};

static struct $B22 pc_tables_xxpiwrb = {{
256,
1538,
1542,
2566,
2570,
10,
0}};

static struct $B21 pc_tables_opndnames = {{
(u64)"no_opnd",
(u64)"mem_opnd",
(u64)"memaddr_opnd",
(u64)"label_opnd",
(u64)"int_opnd",
(u64)"real_opnd",
(u64)"r32_opnd",
(u64)"string_opnd",
(u64)"strimm_opnd",
(u64)"assem_opnd",
(u64)"realimm_opnd",
(u64)"realimm32_opnd",
(u64)"data_opnd",
(u64)"any_opnd"}};

static struct $B19 pc_tables_pclnames = {{
(u64)"nop",
(u64)"load",
(u64)"iload",
(u64)"iloadx",
(u64)"store",
(u64)"istore",
(u64)"istorex",
(u64)"storem",
(u64)"dupl",
(u64)"double",
(u64)"swapstk",
(u64)"unload",
(u64)"opnd",
(u64)"type",
(u64)"loadbit",
(u64)"loadbf",
(u64)"storebit",
(u64)"storebf",
(u64)"callp",
(u64)"icallp",
(u64)"retproc",
(u64)"callf",
(u64)"icallf",
(u64)"retfn",
(u64)"jump",
(u64)"ijump",
(u64)"jumpcc",
(u64)"jumpt",
(u64)"jumpf",
(u64)"jumpret",
(u64)"jumpretm",
(u64)"setcc",
(u64)"stop",
(u64)"to",
(u64)"forup",
(u64)"fordown",
(u64)"iswap",
(u64)"switch",
(u64)"switchu",
(u64)"swlabel",
(u64)"endsw",
(u64)"clear",
(u64)"assem",
(u64)"add",
(u64)"sub",
(u64)"mul",
(u64)"div",
(u64)"idiv",
(u64)"irem",
(u64)"idivrem",
(u64)"bitand",
(u64)"bitor",
(u64)"bitxor",
(u64)"shl",
(u64)"shr",
(u64)"min",
(u64)"max",
(u64)"addpx",
(u64)"subpx",
(u64)"subp",
(u64)"neg",
(u64)"abs",
(u64)"bitnot",
(u64)"not",
(u64)"toboolt",
(u64)"toboolf",
(u64)"sqr",
(u64)"sqrt",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"sign",
(u64)"atan2",
(u64)"power",
(u64)"fmod",
(u64)"incrto",
(u64)"decrto",
(u64)"incrload",
(u64)"decrload",
(u64)"loadincr",
(u64)"loaddecr",
(u64)"addto",
(u64)"subto",
(u64)"multo",
(u64)"divto",
(u64)"idivto",
(u64)"iremto",
(u64)"bitandto",
(u64)"bitorto",
(u64)"bitxorto",
(u64)"shlto",
(u64)"shrto",
(u64)"minto",
(u64)"maxto",
(u64)"addpxto",
(u64)"subpxto",
(u64)"negto",
(u64)"absto",
(u64)"bitnotto",
(u64)"notto",
(u64)"toboolto",
(u64)"typepun",
(u64)"float",
(u64)"fix",
(u64)"truncate",
(u64)"widen",
(u64)"fwiden",
(u64)"fnarrow",
(u64)"startmx",
(u64)"resetmx",
(u64)"endmx",
(u64)"proc",
(u64)"tcproc",
(u64)"endproc",
(u64)"istatic",
(u64)"zstatic",
(u64)"data",
(u64)"initdswx",
(u64)"label",
(u64)"labeldef",
(u64)"setjmp",
(u64)"longjmp",
(u64)"setcall",
(u64)"setarg",
(u64)"loadall",
(u64)"eval",
(u64)"comment",
(u64)"endprog",
(u64)"param",
(u64)"local",
(u64)"rettype",
(u64)"variadic",
(u64)"addlib",
(u64)"extproc"}};

static struct $B23 pc_tables_pclhastype = {{
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
2,
2,
2,
2,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0}};

static struct $B23 pc_tables_pclextra = {{
0,
1,
0,
2,
0,
0,
2,
0,
0,
0,
2,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
2,
2,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B23 pc_tables_pclhasopnd = {{
0,
13,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
13,
0,
0,
0,
0,
0,
2,
0,
0,
2,
0,
0,
3,
0,
3,
3,
3,
3,
3,
0,
0,
3,
3,
3,
0,
3,
3,
3,
0,
0,
13,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
1,
1,
13,
0,
3,
2,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
7,
1}};

static struct $B23 pc_tables_pclargs = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
9,
9,
0,
9,
9,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B24 pc_tables_ccnames = {{
(u64)"xx",
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B1 pc_tables_idnames = {{
(u64)"--",
(u64)"Import",
(u64)"Proc",
(u64)"Static",
(u64)"Local",
(u64)"Param",
(u64)"Label",
(u64)"Export",
(u64)"Misc",
(u64)"Program"}};

static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B19 mc_genmcl_px_handlertable;
static struct $B25 mc_genmcl_scondcodes = {{
1284,
3596,
3853}};

static struct $B25 mc_genmcl_ucondcodes = {{
1284,
1538,
1795}};

// Istatic skipped:mc_genmcl.inithandlers.initdone

// Istatic skipped:mc_genmcl.inithandlers.dupltable

static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B28 mc_libmcl_smallinttable;
static struct $B29 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B29 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B20 mc_stackmcl_stropndstack_str;
static i64 mc_genss_dummy_psstime;
static struct $B11 mc_decls_valtypenames = {{
(u64)"no_val",
(u64)"intimm_val",
(u64)"realimm_val",
(u64)"realmem_val",
(u64)"stringimm_val",
(u64)"def_val",
(u64)"label_val",
(u64)"name_val",
(u64)"temp_val"}};

static struct $B30 mc_decls_mclnames = {{
(u64)"m_procstart",
(u64)"m_procend",
(u64)"m_comment",
(u64)"m_labelname",
(u64)"m_define",
(u64)"m_definereg",
(u64)"m_trace",
(u64)"m_endx",
(u64)"m_labelx",
(u64)"m_nop",
(u64)"m_mov",
(u64)"m_push",
(u64)"m_pop",
(u64)"m_lea",
(u64)"m_cmovcc",
(u64)"m_movd",
(u64)"m_movq",
(u64)"m_movsx",
(u64)"m_movzx",
(u64)"m_movsxd",
(u64)"m_call",
(u64)"m_ret",
(u64)"m_leave",
(u64)"m_retn",
(u64)"m_jmp",
(u64)"m_jmpcc",
(u64)"m_xchg",
(u64)"m_add",
(u64)"m_sub",
(u64)"m_adc",
(u64)"m_sbb",
(u64)"m_imul",
(u64)"m_mul",
(u64)"m_imul2",
(u64)"m_imul3",
(u64)"m_idiv",
(u64)"m_div",
(u64)"m_andx",
(u64)"m_orx",
(u64)"m_xorx",
(u64)"m_test",
(u64)"m_cmp",
(u64)"m_shl",
(u64)"m_sar",
(u64)"m_shr",
(u64)"m_rol",
(u64)"m_ror",
(u64)"m_rcl",
(u64)"m_rcr",
(u64)"m_neg",
(u64)"m_notx",
(u64)"m_inc",
(u64)"m_dec",
(u64)"m_cbw",
(u64)"m_cwd",
(u64)"m_cdq",
(u64)"m_cqo",
(u64)"m_setcc",
(u64)"m_bsf",
(u64)"m_bsr",
(u64)"m_shld",
(u64)"m_shrd",
(u64)"m_sqrtss",
(u64)"m_sqrtsd",
(u64)"m_addss",
(u64)"m_addsd",
(u64)"m_subss",
(u64)"m_subsd",
(u64)"m_mulss",
(u64)"m_mulsd",
(u64)"m_divss",
(u64)"m_divsd",
(u64)"m_comiss",
(u64)"m_comisd",
(u64)"m_ucomisd",
(u64)"m_xorps",
(u64)"m_xorpd",
(u64)"m_andps",
(u64)"m_andpd",
(u64)"m_pxor",
(u64)"m_pand",
(u64)"m_cvtss2si",
(u64)"m_cvtsd2si",
(u64)"m_cvttss2si",
(u64)"m_cvttsd2si",
(u64)"m_cvtsi2ss",
(u64)"m_cvtsi2sd",
(u64)"m_cvtsd2ss",
(u64)"m_cvtss2sd",
(u64)"m_movdqa",
(u64)"m_movdqu",
(u64)"m_pcmpistri",
(u64)"m_pcmpistrm",
(u64)"m_fld",
(u64)"m_fst",
(u64)"m_fstp",
(u64)"m_fild",
(u64)"m_fist",
(u64)"m_fistp",
(u64)"m_fadd",
(u64)"m_fsub",
(u64)"m_fmul",
(u64)"m_fdiv",
(u64)"m_fsqrt",
(u64)"m_fsin",
(u64)"m_fcos",
(u64)"m_fsincos",
(u64)"m_fptan",
(u64)"m_fpatan",
(u64)"m_fabs",
(u64)"m_fchs",
(u64)"m_minss",
(u64)"m_maxss",
(u64)"m_minsd",
(u64)"m_maxsd",
(u64)"m_db",
(u64)"m_dw",
(u64)"m_dd",
(u64)"m_dq",
(u64)"m_ascii",
(u64)"m_isegment",
(u64)"m_zsegment",
(u64)"m_csegment",
(u64)"m_align",
(u64)"m_resb",
(u64)"m_resw",
(u64)"m_resd",
(u64)"m_resq",
(u64)"m_xlat",
(u64)"m_loopnz",
(u64)"m_loopz",
(u64)"m_loopcx",
(u64)"m_jecxz",
(u64)"m_jrcxz",
(u64)"m_cmpsb",
(u64)"m_cmpsw",
(u64)"m_cmpsd",
(u64)"m_cmpsq",
(u64)"m_rdtsc",
(u64)"m_popcnt",
(u64)"m_bswap",
(u64)"m_finit",
(u64)"m_fldz",
(u64)"m_fld1",
(u64)"m_fldpi",
(u64)"m_fld2t",
(u64)"m_fld2e",
(u64)"m_fldlg2",
(u64)"m_fldln2",
(u64)"m_cpuid",
(u64)"m_xxxx",
(u64)"m_halt"}};

static struct $B31 mc_decls_mclnopnds = {{
0,
144680341364408321,
72057598366581250,
72622751638225153,
144680341364474369,
144680345676153346,
4311810306,
144680345676153088,
144680345676153346,
144680345676153346,
144680345676153346,
72340181461631490,
65793,
144115188075855872,
72340172838142466,
72340172838010880,
1103823438080,
4328521728,
0}};

static struct $B31 mc_decls_mclcodes = {{
0,
36864,
56791871518670848,
361134615617863913,
432631463138033668,
144396684645107456,
4295099139,
5859654413743554560,
6799970727712544856,
-1201242466499547392,
219,
216736154650895872,
-362036289223851520,
6764655078180388862,
6249823,
577588855528488960,
250567903535319,
-1662391212449923072,
-796010212255667733}};

static struct $B32 mc_decls_regnames = {{
(u64)"rnone",
(u64)"r0",
(u64)"r1",
(u64)"r2",
(u64)"r3",
(u64)"r4",
(u64)"r5",
(u64)"r6",
(u64)"r7",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"r16",
(u64)"r17",
(u64)"r18",
(u64)"r19"}};

static struct $B33 mc_decls_regcodes = {{
0,
0,
10,
11,
7,
3,
6,
12,
13,
14,
15,
1,
2,
8,
9,
5,
4,
4,
7,
5,
6}};

static struct $B29 mc_decls_condnames = {{
(u64)"ov",
(u64)"nov",
(u64)"ltu",
(u64)"geu",
(u64)"eq",
(u64)"ne",
(u64)"leu",
(u64)"gtu",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"lt",
(u64)"ge",
(u64)"le",
(u64)"gt",
(u64)"flt",
(u64)"fge",
(u64)"fle",
(u64)"fgt"}};

static struct $B29 mc_decls_asmcondnames = {{
(u64)"o",
(u64)"no",
(u64)"b",
(u64)"ae",
(u64)"z",
(u64)"nz",
(u64)"be",
(u64)"a",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"l",
(u64)"ge",
(u64)"le",
(u64)"g",
(u64)"b",
(u64)"ae",
(u64)"be",
(u64)"a"}};

static struct $B29 mc_decls_asmrevcond = {{
1,
0,
3,
2,
5,
4,
7,
6,
9,
8,
11,
10,
13,
12,
15,
14,
17,
16,
19,
18}};

static struct $B34 mc_decls_dregnames = {{
(u64)"d0",
(u64)"d1",
(u64)"d2",
(u64)"d3",
(u64)"d4",
(u64)"d5",
(u64)"d6",
(u64)"d7",
(u64)"d8",
(u64)"d9",
(u64)"d10",
(u64)"d11",
(u64)"d12",
(u64)"d13",
(u64)"d14",
(u64)"d15",
(u64)"a0",
(u64)"a1",
(u64)"a2",
(u64)"a3",
(u64)"a4",
(u64)"a5",
(u64)"a6",
(u64)"a7",
(u64)"a8",
(u64)"a9",
(u64)"a10",
(u64)"a11",
(u64)"a12",
(u64)"a13",
(u64)"a14",
(u64)"a15",
(u64)"w0",
(u64)"w1",
(u64)"w2",
(u64)"w3",
(u64)"w4",
(u64)"w5",
(u64)"w6",
(u64)"w7",
(u64)"w8",
(u64)"w9",
(u64)"w10",
(u64)"w11",
(u64)"w12",
(u64)"w13",
(u64)"w14",
(u64)"w15",
(u64)"b0",
(u64)"b1",
(u64)"b2",
(u64)"b3",
(u64)"b4",
(u64)"b5",
(u64)"b6",
(u64)"b7",
(u64)"b8",
(u64)"b9",
(u64)"b10",
(u64)"b11",
(u64)"b12",
(u64)"b13",
(u64)"b14",
(u64)"b15",
(u64)"b16",
(u64)"b17",
(u64)"b18",
(u64)"b19",
(u64)"_b20",
(u64)"rax",
(u64)"rbx",
(u64)"rcx",
(u64)"rdx",
(u64)"rsi",
(u64)"rdi",
(u64)"rbp",
(u64)"rsp",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"eax",
(u64)"ebx",
(u64)"ecx",
(u64)"edx",
(u64)"esi",
(u64)"edi",
(u64)"ebp",
(u64)"esp",
(u64)"r8d",
(u64)"r9d",
(u64)"r10d",
(u64)"r11d",
(u64)"r12d",
(u64)"r13d",
(u64)"r14d",
(u64)"r15d",
(u64)"ax",
(u64)"bx",
(u64)"cx",
(u64)"dx",
(u64)"si",
(u64)"di",
(u64)"bp",
(u64)"sp",
(u64)"r8w",
(u64)"r9w",
(u64)"r10w",
(u64)"r11w",
(u64)"r12w",
(u64)"r13w",
(u64)"r14w",
(u64)"r15w",
(u64)"al",
(u64)"bl",
(u64)"cl",
(u64)"dl",
(u64)"ah",
(u64)"bh",
(u64)"ch",
(u64)"dh",
(u64)"sil",
(u64)"dil",
(u64)"bpl",
(u64)"spl",
(u64)"r8b",
(u64)"r9b",
(u64)"r10b",
(u64)"r11b",
(u64)"r12b",
(u64)"r13b",
(u64)"r14b",
(u64)"r15b"}};

static struct $B35 mc_decls_regsizes = {{
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1}};

static struct $B35 mc_decls_regindices = {{
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
0,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
17,
18,
19,
20,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10}};

static struct $B36 mc_decls_xmmregnames = {{
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm14",
(u64)"xmm15"}};

static struct $B37 mc_decls_fregnames = {{
(u64)"st0",
(u64)"st1",
(u64)"st2",
(u64)"st3",
(u64)"st4",
(u64)"st5",
(u64)"st6",
(u64)"st7"}};

static struct $B37 mc_decls_mregnames = {{
(u64)"mmx0",
(u64)"mmx1",
(u64)"mmx2",
(u64)"mmx3",
(u64)"mmx4",
(u64)"mmx5",
(u64)"mmx6",
(u64)"mmx7"}};

static struct $B38 mc_decls_jmpccnames = {{
(u64)"jo",
(u64)"jno",
(u64)"jb",
(u64)"jae",
(u64)"jz",
(u64)"jnz",
(u64)"jbe",
(u64)"ja",
(u64)"js",
(u64)"jns",
(u64)"jp",
(u64)"jnp",
(u64)"jl",
(u64)"jge",
(u64)"jle",
(u64)"jg",
(u64)"jc",
(u64)"jnc"}};

static struct $B26 mc_decls_jmpcccodes = {{
256,
770,
1284,
1798,
2312,
2826,
3340,
3854,
770}};

static struct $B36 mc_decls_setccnames = {{
(u64)"seto",
(u64)"setno",
(u64)"setb",
(u64)"setae",
(u64)"setz",
(u64)"setnz",
(u64)"setbe",
(u64)"seta",
(u64)"sets",
(u64)"setns",
(u64)"setp",
(u64)"setnp",
(u64)"setl",
(u64)"setge",
(u64)"setle",
(u64)"setg"}};

static struct $B3 mc_decls_setcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B36 mc_decls_cmovccnames = {{
(u64)"cmovo",
(u64)"cmovno",
(u64)"cmovb",
(u64)"cmovae",
(u64)"cmovz",
(u64)"cmovnz",
(u64)"cmovbe",
(u64)"cmova",
(u64)"cmovs",
(u64)"cmovns",
(u64)"cmovp",
(u64)"cmovnp",
(u64)"cmovl",
(u64)"cmovge",
(u64)"cmovle",
(u64)"cmovg"}};

static struct $B3 mc_decls_cmovcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B12 mc_decls_segmentnames = {{
(u64)"no_seg",
(u64)"code_seg",
(u64)"idata_seg",
(u64)"zdata_seg",
(u64)"rodata_seg",
(u64)"impdata_seg"}};

static struct $B8 mc_decls_reftypenames = {{
(u64)"extern_ref",
(u64)"fwd_ref",
(u64)"back_ref"}};

static struct $B12 mc_decls_opndnames_ma = {{
(u64)"a_none",
(u64)"a_reg",
(u64)"a_imm",
(u64)"a_mem",
(u64)"a_cond",
(u64)"a_xreg"}};

static struct $B18 mc_decls_pclopnd;
static struct $B39 mc_decls_pclreg;
static struct $B39 mc_decls_pclmode;
static struct $B39 mc_decls_pclcount;
static struct $B39 mc_decls_pclloc;
static struct $B39 mc_decls_pcltempflags;
static struct $B18 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B17 mc_decls_locnames = {{
(u64)"pend",
(u64)"reg",
(u64)"regvar",
(u64)"temp"}};

static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames = {{
(u64)"-",
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm15",
(u64)"xmm15"}};

static struct $B17 mc_decls_callalign;
static struct $B17 mc_decls_callblockret;
static struct $B36 mc_decls_callblocksize;
static struct $B20 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used = 0;

static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment = 0;

static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B41 mc_decls_regtable;
static struct $B42 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes = 432345564311454723;

static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B18 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs = {{
1,
2,
3,
11,
12,
13}};

static struct $B12 mc_decls_multxregs = {{
1,
2,
3,
4,
5,
6}};

static struct $B22 mc_decls_ploadopx;
static struct $B22 mc_decls_ploadop;
static struct $B24 mc_objdecls_relocnames = {{
(u64)"abs_rel",
(u64)"addr64_rel",
(u64)"addr32_rel",
(u64)"addr32nb_rel",
(u64)"rel32_rel",
(u64)"rel321_rel",
(u64)"rel8_rel"}};

static u64 mc_writegas_asmext = (u64)"asm";

static struct $B41 mc_writegas_nregnames;
static u8 mc_writegas_currseg;
static struct $B20 mc_writegas_strmcl_str;
static struct $B20 mc_writegas_mstropnd_str;
static struct $B20 mc_writegas_strvalue_str;
static struct $B17 mc_writegas_getxregname_str;
static struct $B16 mc_writegas_getdispname_str;
static struct $B36 mc_writegas_gettempname_str;
static struct $B3 mc_writegas_strreg_str;
static struct $B44 cc_cli_passnames = {{
(u64)"load_pass",
(u64)"pp_pass",
(u64)"parse_pass",
(u64)"type_pass",
(u64)"pcl_pass",
(u64)"runpcl_pass",
(u64)"mcl_pass",
(u64)"asm_pass",
(u64)"mx_pass",
(u64)"obj_pass",
(u64)"dll_pass",
(u64)"exe_pass",
(u64)"run_pass"}};

static struct $B44 cc_cli_extnames = {{
(u64)"",
(u64)"i",
(u64)"",
(u64)"",
(u64)"pcl",
(u64)"(int)",
(u64)"asm",
(u64)"asm",
(u64)"mx",
(u64)"obj",
(u64)"dll",
(u64)"exe",
(u64)"(run)"}};

static u8 cc_cli_cc_pass;
static struct $B45 cc_cli_dummy;
static u8 cc_cli_debugmode;
static u64 cc_cli_outfile;
static u64 cc_cli_outext = (u64)"exe";

static i64 cc_cli_cmdskip;
static i64 cc_cli_ttt;
static u8 cc_cli_fverbose = 1;

static u8 cc_cli_fshowincludes = 0;

static u8 cc_cli_dointheaders = 1;

static u8 cc_cli_highmem = 1;

static u8 cc_cli_fshowst;
static u8 cc_cli_fshowstflat;
static u8 cc_cli_fshowast;
static u8 cc_cli_fshowpcl;
static u8 cc_cli_fshowpst;
static u8 cc_cli_fshowmcl;
static u8 cc_cli_fshowss;
static u8 cc_cli_fshowtypes;
static u8 cc_cli_fshowfiles;
static u8 cc_cli_fshowpaths;
static u8 cc_cli_fshowheaders;
static u8 cc_cli_fwriteheaders;
static u8 cc_cli_fshowlog;
static u8 cc_cli_fshowtiming;
static u8 cc_cli_fgendll;
static u8 cc_cli_fstdout;
static u8 cc_cli_fshortnames;
static u8 cc_cli_fwriteerrors = 1;

static u64 cc_cli_entrypointname;
static struct $B46 cc_cli_optionnames = {{
(u64)"load",
(u64)"e",
(u64)"ei",
(u64)"parse",
(u64)"type",
(u64)"p",
(u64)"pi",
(u64)"i",
(u64)"mcl",
(u64)"s",
(u64)"a",
(u64)"c",
(u64)"obj",
(u64)"mx",
(u64)"dll",
(u64)"exe",
(u64)"r",
(u64)"noregs",
(u64)"nopeep",
(u64)"no",
(u64)"paths",
(u64)"headers",
(u64)"incl",
(u64)"includes",
(u64)"showst",
(u64)"showstflat",
(u64)"showast",
(u64)"showpcl",
(u64)"showpst",
(u64)"showmcl",
(u64)"showss",
(u64)"showtypes",
(u64)"showfiles",
(u64)"time",
(u64)"time2",
(u64)"v",
(u64)"vv",
(u64)"q",
(u64)"cs",
(u64)"ss",
(u64)"h",
(u64)"help",
(u64)"ext",
(u64)"writeheaders",
(u64)"o",
(u64)"stdout",
(u64)"shortnames",
(u64)"norip",
(u64)"himem"}};

static struct $B46 cc_cli_optvars = {{
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&pc_decls_fregoptim,
(u64)&pc_decls_fpeephole,
0,
(u64)&cc_cli_fshowpaths,
(u64)&cc_cli_fshowheaders,
0,
(u64)&cc_cli_fshowincludes,
(u64)&cc_cli_fshowst,
(u64)&cc_cli_fshowstflat,
(u64)&cc_cli_fshowast,
(u64)&cc_cli_fshowpcl,
(u64)&cc_cli_fshowpst,
(u64)&cc_cli_fshowmcl,
(u64)&cc_cli_fshowss,
(u64)&cc_cli_fshowtypes,
(u64)&cc_cli_fshowfiles,
(u64)&cc_cli_fshowtiming,
(u64)&cc_cli_fshowtiming,
(u64)&cc_cli_fverbose,
(u64)&cc_cli_fverbose,
(u64)&cc_cli_fverbose,
(u64)&pc_decls_pverbose,
(u64)&pc_decls_pverbose,
0,
0,
(u64)&cc_cli_dointheaders,
(u64)&cc_cli_fwriteheaders,
0,
(u64)&cc_cli_fstdout,
(u64)&cc_cli_fshortnames,
(u64)&cc_cli_highmem,
(u64)&cc_cli_highmem}};

static struct $B47 cc_cli_optvalues = {{
1,
2,
2,
3,
4,
5,
5,
6,
7,
8,
8,
10,
10,
9,
11,
12,
13,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
3,
0,
1,
2,
0,
0,
0,
1,
0,
1,
1,
0,
2}};

static i64 cc_cli_totallines = 0;

static i64 cc_cli_nstringobjects = 0;

static i64 cc_cli_startclock;
static i64 cc_cli_loadtime;
static i64 cc_cli_parsetime;
static i64 cc_cli_pcltime;
static i64 cc_cli_compiletime;
static i64 cc_cli_inittime;
// Istatic skipped:cc_cli.showextrainfo.infotext

static i64 cc_decls_ntypes;
static struct $B48 cc_decls_ttnamedef;
static struct $B49 cc_decls_ttbasetype;
static struct $B48 cc_decls_ttlength;
static struct $B50 cc_decls_ttconst;
static struct $B49 cc_decls_tttarget;
static struct $B49 cc_decls_ttreftype;
static struct $B49 cc_decls_ttconsttype;
static struct $B48 cc_decls_ttsize;
static struct $B50 cc_decls_ttisref;
static struct $B50 cc_decls_ttisblock;
static struct $B50 cc_decls_ttsigned;
static struct $B51 cc_decls_ttshared;
static struct $B48 cc_decls_ttparams;
static struct $B48 cc_decls_tttypedef;
static i64 cc_decls_trefchar;
static i64 cc_decls_trefwchar;
static u64 cc_decls_inputfile;
static i64 cc_decls_mainfileno;
static struct $B52 cc_decls_libfiles;
static struct $B52 cc_decls_sourcefilenames;
static struct $B52 cc_decls_sourcefilepaths;
static struct $B52 cc_decls_sourcefiletext;
static struct $B53 cc_decls_sourcefilesizes;
static i64 cc_decls_nsourcefiles;
static i64 cc_decls_nlibfiles;
static struct $B29 cc_decls_searchdirs;
static i64 cc_decls_nsearchdirs = 0;

static struct $B29 cc_decls_includepaths;
static i64 cc_decls_nincludepaths = 0;

static u64 cc_decls_stprogram;
static u64 cc_decls_stmodule;
static u64 cc_decls_logdev;
static u64 cc_decls_nullunit;
static i64 cc_decls_clineno = 0;

static i64 cc_decls_cfileno = 0;

static struct $B17 cc_decls_lx;
static struct $B17 cc_decls_nextlx;
static i64 cc_decls_debug = 0;

static i64 cc_decls_hstsize = 65536;

static i64 cc_decls_hstmask;
static u64 cc_decls_hashtable;
static struct $B54 cc_decls_blockowner;
static struct $B54 cc_decls_blockcounts;
static struct $B55 cc_decls_blockstack;
static i64 cc_decls_currblockno;
static i64 cc_decls_nextblockno;
static i64 cc_decls_blocklevel;
static u64 cc_decls_currproc;
static u64 cc_decls_dheaderfile = 0;

static i64 cc_decls_structpadding = 1;

static i64 cc_decls_callbackflag = 0;

static i64 cc_decls_slineno;
static i64 cc_decls_sfileno;
static u64 cc_decls_oemname = (u64)"MCC";

static u64 cc_decls_mclstr;
static i64 cc_decls_mclstrlen;
static i64 cc_decls_nunits;
static struct $B56 cc_decls_pmodulelist;
static struct $B57 cc_decls_pheaderlist;
static struct $B57 cc_decls_pliblist;
static i64 cc_decls_npmodules;
static i64 cc_decls_npheaders;
static i64 cc_decls_nplibs;
static u8 cc_decls_pci_target;
static struct $B58 cc_tables_stdtypenames = {{
(u64)"void",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"bool",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"r32",
(u64)"r64",
(u64)"enum",
(u64)"ref",
(u64)"proc",
(u64)"label",
(u64)"block",
(u64)"array",
(u64)"struct",
(u64)"union",
(u64)"notset",
(u64)"tlast"}};

static struct $B59 cc_tables_stdtypewidths = {{
2048,
8208,
2112,
4104,
16416,
16416,
16384,
16448,
0,
0,
0}};

static struct $B59 cc_tables_stdsigned = {{
256,
257,
1,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B59 cc_tables_stdpcl = {{
1792,
2312,
778,
1027,
1541,
513,
1545,
0,
2827,
2827,
0}};

static struct $B59 cc_tables_stdsize = {{
256,
1026,
264,
513,
2052,
2052,
0,
0,
0,
0,
0}};

static struct $B60 cc_tables_catnames = {{
(u64)"voidcat",
(u64)"intcat",
(u64)"realcat",
(u64)"shortcat",
(u64)"blockcat"}};

static struct $B61 cc_tables_typespecnames = {{
(u64)"ts_void",
(u64)"ts_char",
(u64)"ts_short",
(u64)"ts_long",
(u64)"ts_int",
(u64)"ts_float",
(u64)"ts_double",
(u64)"ts_signed",
(u64)"ts_unsigned",
(u64)"ts_bool",
(u64)"ts_user",
(u64)"ts_struct",
(u64)"ts_union",
(u64)"ts_enum",
(u64)"ts_atomic"}};

static struct $B62 cc_tables_typespectypes = {{
0,
1,
0,
0,
3,
10,
11,
0,
0,
5,
0,
0,
0,
0,
0}};

static struct $B63 cc_tables_typespecsizes = {{
0,
1,
2,
4,
4,
4,
8,
0,
0,
1,
0,
0,
0,
4,
0}};

static struct $B17 cc_tables_pmflagnames = {{
(u64)"pm_normal",
(u64)"pm_notset",
(u64)"pm_empty",
(u64)"pm_variadic"}};

static struct $B60 cc_tables_scopenames = {{
(u64)"-",
(u64)"Fn",
(u64)"Loc",
(u64)"Imp",
(u64)"Exp"}};

static struct $B12 cc_tables_cccnames = {{
(u64)"open_cc",
(u64)"own_cc",
(u64)"clang_cc",
(u64)"stdcall_cc",
(u64)"callback_cc",
(u64)"dummy_cc"}};

static struct $B12 cc_tables_linkagenames = {{
(u64)"none_ss",
(u64)"static_ss",
(u64)"auto_ss",
(u64)"register_ss",
(u64)"extern_ss",
(u64)"typedef_ss"}};

static struct $B17 cc_tables_typequalnames = {{
(u64)"const_qual",
(u64)"volatile_qual",
(u64)"restrict_qual",
(u64)"atomic_qual"}};

static struct $B8 cc_tables_fnspecnames = {{
(u64)"inline_fnspec",
(u64)"noreturn_fnspec",
(u64)"callback_fnspec"}};

static struct $B64 cc_tables_jtagnames = {{
(u64)"jnone",
(u64)"jconst",
(u64)"jnull",
(u64)"jname",
(u64)"jwidenmem",
(u64)"jfuncname",
(u64)"jblock",
(u64)"jtempdecl",
(u64)"jdecl",
(u64)"jreturn",
(u64)"jreturnx",
(u64)"jassign",
(u64)"jif",
(u64)"jfor",
(u64)"jwhile",
(u64)"jdowhile",
(u64)"jgoto",
(u64)"jlabelstmt",
(u64)"jcasestmt",
(u64)"jdefaultstmt",
(u64)"jbreak",
(u64)"jcontinue",
(u64)"jswitch",
(u64)"jbreaksw",
(u64)"&& andl",
(u64)"|| orl",
(u64)"! notl",
(u64)"jistruel",
(u64)"jmakelist",
(u64)"jexprlist",
(u64)"jcallfn",
(u64)"jifx",
(u64)"&&",
(u64)"==",
(u64)"!=",
(u64)"<",
(u64)"<=",
(u64)">",
(u64)">=",
(u64)"+ add",
(u64)"- sub",
(u64)"* mul",
(u64)"/ div",
(u64)"% mod",
(u64)"& iand",
(u64)"| ior",
(u64)"^ ixor",
(u64)"<<",
(u64)">>",
(u64)"jdot",
(u64)"jidot",
(u64)"jindex",
(u64)"ptr",
(u64)"addptr",
(u64)"subptr",
(u64)"addrof &",
(u64)"jconvert",
(u64)"jscale",
(u64)"- neg",
(u64)"abs",
(u64)"~ inot",
(u64)"+=",
(u64)"-=",
(u64)"*=",
(u64)"/=",
(u64)"%=",
(u64)"&=",
(u64)"|=",
(u64)"^=",
(u64)"<<=",
(u64)">>=",
(u64)"++ preincr",
(u64)"-- preincr",
(u64)"++ postincr",
(u64)"-- postdecr",
(u64)"setjmp",
(u64)"longjmp",
(u64)"jdummy"}};

static struct $B65 cc_tables_symbolnames = {{
(u64)"errorsym",
(u64)"dotsym",
(u64)"idotsym",
(u64)"lexhashsym",
(u64)"hashsym",
(u64)"lithashsym",
(u64)"hashhashsym",
(u64)"commasym",
(u64)"semisym",
(u64)"colonsym",
(u64)"assignsym",
(u64)"assignsym2",
(u64)"lbracksym",
(u64)"rbracksym",
(u64)"lsqsym",
(u64)"rsqsym",
(u64)"lcurlysym",
(u64)"rcurlysym",
(u64)"questionsym",
(u64)"curlsym",
(u64)"ellipsissym",
(u64)"backslashsym",
(u64)"addsym",
(u64)"subsym",
(u64)"mulsym",
(u64)"divsym",
(u64)"remsym",
(u64)"iorsym",
(u64)"iandsym",
(u64)"ixorsym",
(u64)"orlsym",
(u64)"andlsym",
(u64)"shlsym",
(u64)"shrsym",
(u64)"inotsym",
(u64)"notlsym",
(u64)"incrsym",
(u64)"decrsym",
(u64)"abssym",
(u64)"eqsym",
(u64)"nesym",
(u64)"ltsym",
(u64)"lesym",
(u64)"gesym",
(u64)"gtsym",
(u64)"addtosym",
(u64)"subtosym",
(u64)"multosym",
(u64)"divtosym",
(u64)"remtosym",
(u64)"iortosym",
(u64)"iandtosym",
(u64)"ixortosym",
(u64)"shltosym",
(u64)"shrtosym",
(u64)"eolsym",
(u64)"eofsym",
(u64)"rawnumbersym",
(u64)"intconstsym",
(u64)"realconstsym",
(u64)"charconstsym",
(u64)"wcharconstsym",
(u64)"stringconstsym",
(u64)"wstringconstsym",
(u64)"whitespacesym",
(u64)"placeholdersym",
(u64)"namesym",
(u64)"ksourcedirsym",
(u64)"predefmacrosym",
(u64)"ktypespecsym",
(u64)"kifsym",
(u64)"kelsesym",
(u64)"kcasesym",
(u64)"kdefaultsym",
(u64)"kforsym",
(u64)"kwhilesym",
(u64)"kdosym",
(u64)"kreturnsym",
(u64)"kbreaksym",
(u64)"kcontinuesym",
(u64)"kgotosym",
(u64)"kswitchsym",
(u64)"kstructsym",
(u64)"kunionsym",
(u64)"klinkagesym",
(u64)"ktypequalsym",
(u64)"kstdtypesym",
(u64)"kfnspecsym",
(u64)"kalignassym",
(u64)"kenumsym",
(u64)"ksizeofsym",
(u64)"kdefinedsym",
(u64)"kgenericsym",
(u64)"kalignofsym",
(u64)"ksetjmpsym",
(u64)"kdummysym"}};

static struct $B65 cc_tables_shortsymbolnames = {{
(u64)"",
(u64)".",
(u64)"->",
(u64)"#",
(u64)"#",
(u64)"#",
(u64)"##",
(u64)",",
(u64)";",
(u64)":",
(u64)"=",
(u64)":=",
(u64)"(",
(u64)")",
(u64)"[",
(u64)"]",
(u64)"{",
(u64)"}",
(u64)"?",
(u64)"~",
(u64)"...",
(u64)"\\",
(u64)"+",
(u64)"-",
(u64)"*",
(u64)"/",
(u64)"%",
(u64)"|",
(u64)"&",
(u64)"^",
(u64)"||",
(u64)"&&",
(u64)"<<",
(u64)">>",
(u64)"~",
(u64)"!",
(u64)"++",
(u64)"--",
(u64)"abs",
(u64)"==",
(u64)"!=",
(u64)"<",
(u64)"<=",
(u64)">=",
(u64)">",
(u64)"+=",
(u64)"-=",
(u64)"*=",
(u64)"/=",
(u64)"%=",
(u64)"|=",
(u64)"&=",
(u64)"^=",
(u64)"<<=",
(u64)">>=",
(u64)"",
(u64)"",
(u64)"n",
(u64)"n",
(u64)"n",
(u64)"s",
(u64)"s",
(u64)"s",
(u64)"s",
(u64)"w",
(u64)"",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)""}};

static struct $B28 cc_tables_symboltojtag = {{
3289344,
185270272,
2893281285608833024,
1736469898599279145,
2394587097097580591,
4557147102708507426,
19779407841542464,
0,
0,
0,
0,
0}};

static struct $B61 cc_tables_sourcedirnames = {{
(u64)"definedir",
(u64)"emitdir",
(u64)"ifdir",
(u64)"elifdir",
(u64)"elsedir",
(u64)"endifdir",
(u64)"includedir",
(u64)"ifdefdir",
(u64)"ifndefdir",
(u64)"undefdir",
(u64)"errordir",
(u64)"messagedir",
(u64)"blankdir",
(u64)"linedir",
(u64)"pragmadir"}};

static struct $B60 cc_tables_namespacenames = {{
(u64)"ns_none",
(u64)"ns_general",
(u64)"ns_tags",
(u64)"ns_labels",
(u64)"ns_fields"}};

static struct $B61 cc_tables_namenames = {{
(u64)"nullid",
(u64)"macroid",
(u64)"programid",
(u64)"moduleid",
(u64)"extmoduleid",
(u64)"typeid",
(u64)"procid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"fieldid",
(u64)"enumid",
(u64)"enumtagid",
(u64)"structtagid",
(u64)"labelid"}};

static struct $B62 cc_tables_namespaces = {{
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
4,
1,
2,
2,
3}};

static struct $B63 cc_tables_name2pid = {{
0,
0,
0,
0,
0,
0,
2,
3,
4,
5,
0,
0,
0,
0,
6}};

static struct $B66 cc_tables_stnames = {{
(u64)"if",
(u64)"else",
(u64)"case",
(u64)"default",
(u64)"for",
(u64)"do",
(u64)"while",
(u64)"return",
(u64)"break",
(u64)"continue",
(u64)"goto",
(u64)"switch",
(u64)"struct",
(u64)"union",
(u64)"include",
(u64)"define",
(u64)"elif",
(u64)"ifdef",
(u64)"ifndef",
(u64)"endif",
(u64)"undef",
(u64)"error",
(u64)"pragma",
(u64)"line",
(u64)"auto",
(u64)"register",
(u64)"static",
(u64)"extern",
(u64)"typedef",
(u64)"const",
(u64)"volatile",
(u64)"restrict",
(u64)"_Atomic",
(u64)"inline",
(u64)"_Noreturn",
(u64)"_Alignas",
(u64)"enum",
(u64)"void",
(u64)"char",
(u64)"short",
(u64)"long",
(u64)"int",
(u64)"float",
(u64)"double",
(u64)"signed",
(u64)"unsigned",
(u64)"_Bool",
(u64)"__DATE__",
(u64)"__FILE__",
(u64)"__LINE__",
(u64)"__TIME__",
(u64)"__MCC__",
(u64)"__MCCI__",
(u64)"__func__",
(u64)"__FUNCTION__",
(u64)"sizeof",
(u64)"lengthof",
(u64)"defined",
(u64)"_Generic",
(u64)"_Alignof",
(u64)"$setjmp",
(u64)"$longjmp",
(u64)"$$dummy"}};

static struct $B67 cc_tables_stsymbols = {{
71,
72,
73,
74,
75,
77,
76,
78,
79,
80,
81,
82,
83,
84,
68,
68,
68,
68,
68,
68,
68,
68,
68,
68,
85,
85,
85,
85,
85,
86,
86,
86,
86,
88,
88,
89,
90,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
69,
69,
69,
69,
69,
69,
69,
69,
91,
91,
92,
93,
94,
95,
95,
0}};

static struct $B67 cc_tables_stsubcodes = {{
12,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
7,
1,
4,
8,
9,
6,
10,
11,
15,
14,
2,
3,
1,
4,
5,
1,
2,
3,
4,
1,
2,
0,
0,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
1,
3,
4,
2,
7,
8,
5,
5,
0,
1,
0,
0,
0,
75,
76,
0}};

static struct $B21 cc_tables_convnames = {{
(u64)"no_conv",
(u64)"soft_c",
(u64)"hard_c",
(u64)"swiden_c",
(u64)"uwiden_c",
(u64)"sfloat_c",
(u64)"ufloat_c",
(u64)"sfix_c",
(u64)"ufix_c",
(u64)"fwiden_c",
(u64)"fnarrow_c",
(u64)"narrow_c",
(u64)"truncate_c",
(u64)"bool_c"}};

static struct $B41 cc_tables_dominantmode;
static struct $B16 cc_tables_conversionops;
static struct $B68 cc_tables_dominantsetuptable = {{
1,
1,
3,
1,
2,
3,
1,
3,
3,
1,
4,
4,
1,
5,
3,
1,
6,
3,
1,
7,
3,
1,
8,
3,
1,
9,
4,
1,
10,
10,
1,
11,
11,
2,
1,
3,
2,
2,
3,
2,
3,
3,
2,
4,
4,
2,
5,
3,
2,
6,
3,
2,
7,
3,
2,
8,
3,
2,
9,
4,
2,
10,
10,
2,
11,
11,
3,
1,
3,
3,
2,
3,
3,
3,
3,
3,
4,
4,
3,
5,
3,
3,
6,
3,
3,
7,
3,
3,
8,
8,
3,
9,
4,
3,
10,
10,
3,
11,
11,
4,
1,
4,
4,
2,
4,
4,
3,
4,
4,
4,
4,
4,
5,
4,
4,
6,
4,
4,
7,
4,
4,
8,
4,
4,
9,
9,
4,
10,
10,
4,
11,
11,
5,
1,
3,
5,
2,
3,
5,
3,
3,
5,
4,
4,
5,
5,
8,
5,
6,
8,
5,
7,
8,
5,
8,
8,
5,
9,
9,
5,
10,
10,
5,
11,
11,
6,
1,
3,
6,
2,
3,
6,
3,
3,
6,
4,
4,
6,
5,
0,
6,
6,
8,
6,
7,
8,
6,
8,
8,
6,
9,
9,
6,
10,
10,
6,
11,
11,
7,
1,
3,
7,
2,
3,
7,
3,
3,
7,
4,
4,
7,
5,
8,
7,
6,
8,
7,
7,
8,
7,
8,
8,
7,
9,
9,
7,
10,
10,
7,
11,
11,
8,
1,
3,
8,
2,
3,
8,
3,
8,
8,
4,
4,
8,
5,
8,
8,
6,
8,
8,
7,
8,
8,
8,
8,
8,
9,
9,
8,
10,
10,
8,
11,
11,
9,
1,
9,
9,
2,
9,
9,
3,
9,
9,
4,
9,
9,
5,
9,
9,
6,
9,
9,
7,
9,
9,
8,
9,
9,
9,
9,
9,
10,
10,
9,
11,
11,
10,
1,
11,
10,
2,
11,
10,
3,
11,
10,
4,
11,
10,
5,
11,
10,
6,
11,
10,
7,
11,
10,
8,
11,
10,
9,
11,
10,
10,
10,
10,
11,
11,
11,
1,
11,
11,
2,
11,
11,
3,
11,
11,
4,
11,
11,
5,
11,
11,
6,
11,
11,
7,
11,
11,
8,
11,
11,
9,
11,
11,
10,
11,
11,
11,
11}};

static struct $B68 cc_tables_convsetuptable = {{
1,
1,
3,
1,
2,
3,
1,
3,
3,
1,
4,
3,
1,
5,
13,
1,
6,
1,
1,
7,
3,
1,
8,
3,
1,
9,
3,
1,
10,
5,
1,
11,
5,
2,
1,
12,
2,
2,
0,
2,
3,
3,
2,
4,
3,
2,
5,
13,
2,
6,
12,
2,
7,
1,
2,
8,
3,
2,
9,
3,
2,
10,
5,
2,
11,
5,
3,
1,
12,
3,
2,
12,
3,
3,
0,
3,
4,
3,
3,
5,
13,
3,
6,
12,
3,
7,
12,
3,
8,
1,
3,
9,
3,
3,
10,
5,
3,
11,
5,
4,
1,
12,
4,
2,
12,
4,
3,
12,
4,
4,
0,
4,
5,
13,
4,
6,
12,
4,
7,
12,
4,
8,
12,
4,
9,
1,
4,
10,
5,
4,
11,
5,
5,
1,
1,
5,
2,
4,
5,
3,
4,
5,
4,
4,
5,
5,
0,
5,
6,
1,
5,
7,
4,
5,
8,
4,
5,
9,
4,
5,
10,
6,
5,
11,
6,
6,
1,
1,
6,
2,
4,
6,
3,
4,
6,
4,
4,
6,
5,
13,
6,
6,
1,
6,
7,
4,
6,
8,
4,
6,
9,
4,
6,
10,
6,
6,
11,
6,
7,
1,
12,
7,
2,
1,
7,
3,
4,
7,
4,
4,
7,
5,
13,
7,
6,
12,
7,
7,
0,
7,
8,
4,
7,
9,
4,
7,
10,
6,
7,
11,
6,
8,
1,
12,
8,
2,
12,
8,
3,
1,
8,
4,
4,
8,
5,
13,
8,
6,
12,
8,
7,
12,
8,
8,
0,
8,
9,
4,
8,
10,
6,
8,
11,
6,
9,
1,
12,
9,
2,
12,
9,
3,
12,
9,
4,
1,
9,
5,
13,
9,
6,
12,
9,
7,
12,
9,
8,
12,
9,
9,
0,
9,
10,
6,
9,
11,
6,
10,
1,
7,
10,
2,
7,
10,
3,
7,
10,
4,
7,
10,
5,
8,
10,
6,
8,
10,
7,
8,
10,
8,
8,
10,
9,
8,
10,
10,
0,
10,
11,
9,
11,
1,
7,
11,
2,
7,
11,
3,
7,
11,
4,
7,
11,
5,
8,
11,
6,
8,
11,
7,
8,
11,
8,
8,
11,
9,
8,
11,
10,
10,
11,
11,
0}};

static struct $B70 cc_tables_badexprs = {{
1,
3,
31,
24,
25,
26,
27,
29,
32,
33,
34,
35,
36,
38,
37,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
58,
59,
60}};

static u64 cc_lex_tkptr = 0;

static i64 cc_lex_dowhitespace = 0;

static i64 cc_lex_nincludes;
static struct $B17 cc_lex_normaltkx;
static u64 cc_lex_normaltk = (u64)&cc_lex_normaltkx;

static i64 cc_lex_noexpand = 0;

static struct $B71 cc_lex_lx_stack;
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel = 0;

static struct $B29 cc_lex_headerpathlist;
static struct $B15 cc_lex_headerpath;
static u64 cc_lex_lxstart;
static u64 cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static u64 cc_lex_lxsvalue;
static struct $B16 cc_lex_alphamap;
static struct $B16 cc_lex_digitmap;
static struct $B16 cc_lex_commentmap;
static struct $B16 cc_lex_linecommentmap;
static struct $B16 cc_lex_spacemap;
static u64 cc_lex_destcopy;
static struct $B72 cc_lex_pastedtokenlist;
static i64 cc_lex_npastedtokens = 0;

static i64 cc_lex_isincludefile = 0;

static i64 cc_lex_firstsymbol = 1;

static u64 cc_lex_reallxsptr;
static i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static struct $B3 cc_lex_lex_preprocess_only_sbuffer;
// Istatic skipped:cc_lex.lex_preprocess_only.dest

static struct $B15 cc_lex_getsourcefile_filespec;
// Istatic skipped:cc_lex.lexm.doreset

static i64 cc_lex_lasttoken = 0;

static struct $B3 cc_lex_showtoken_buffer;
// Istatic skipped:cc_lex.showtoken.dest

static struct $B3 cc_lex_stringify_buffer;
// Istatic skipped:cc_lex.stringify.deststr

// Istatic skipped:cc_lex.expandpredefmacro.monthnames

// Istatic skipped:cc_lex.issimpleconstmacro.specialnames

static u64 cc_parse_ist_symptr;
static struct $B37 cc_parse_looptypestack;
static i64 cc_parse_loopindex;
static struct $B20 cc_parse_casevaluestack;
static u8 cc_parse_ingeneric = 0;

static i64 cc_genpcl_retindex;
static i64 cc_genpcl_initstaticsindex;
static struct $B73 cc_genpcl_loopstack;
static i64 cc_genpcl_loopindex;
static struct $B37 cc_genpcl_zero_unit;
static u64 cc_genpcl_pzero = (u64)&cc_genpcl_zero_unit;

static i64 cc_genpcl_nvarlocals;
static i64 cc_genpcl_nvarparams;
static struct $B20 cc_blockpcl_continuestack;
static struct $B20 cc_blockpcl_breakstack;
static i64 cc_blockpcl_loopindex;
static u64 cc_blockpcl_sw_labeltable;
static u64 cc_blockpcl_sw_valuetable;
static i64 cc_blockpcl_sw_lower;
static i64 cc_blockpcl_sw_ncases;
static u8 cc_blockpcl_sw_defaultseen;
static i64 cc_blockpcl_sw_defaultlabel;
static i64 cc_blockpcl_sw_breaklabel;
static i64 cc_lib_autotypeno = 0;

static i64 cc_lib_nextafindex = 0;

static u64 cc_lib_unitheapptr = 0;

static i64 cc_lib_remainingunits = 0;

static struct $B74 cc_lib_getoptocode_opctotable;
static struct $B17 cc_lib_nextautotype_str;
static struct $B45 cc_lib_getopcjname_str;
static struct $B75 cc_lib_strmode_str;
static struct $B75 cc_lib_strmode2_str;
static struct $B15 cc_lib_typename_str;
static struct $B16 cc_lib_getstname_name;
static u64 cc_support_bytemasks = -9205322385119247871;

static i64 cc_headers_builtinheaders = 1;

static u64 cc_headers_h_assert = (u64)"/* Header assert.h */\r\n\r\n//#define assert(x) 0\r\n#define assert(x)\r\n";

static u64 cc_headers_h_ctype = (u64)"/* Header ctype.h */\r\n\r\nint tolower(int);\r\nint toupper(int);\r\nint isalpha(int);\r\nint isdigit(int);\r\nint isspace(int);\r\nint isalnum(int);\r\nint isupper(int);\r\nint islower(int);\r\n\r\nint isxdigit(int);\r\nint iscntrl(int);\r\nint isgraph(int);\r\nint ispunct(int);\r\nint isprint(int);\r\nint __isascii(int);\r\n#define isascii __isascii\r\n\r\nint __toascii(int);\r\n#define toascii __toascii\r\n";

static u64 cc_headers_h_errno = (u64)"/* Header errno.h */\r\n\r\n#ifndef $errno\r\n#define $errno\r\n\r\nextern int* _errno(void);\r\n#define errno (*_errno())\r\n\r\n#define EPERM 1\r\n#define ENOENT 2\r\n#define ESRCH 3\r\n#define EINTR 4\r\n#define EIO 5\r\n#define ENXIO 6\r\n#define E2BIG 7\r\n#define ENOEXEC 8\r\n#define EBADF 9\r\n#define ECHILD 10\r\n#define EAGAIN 11\r\n#define ENOMEM 12\r\n#define EACCES 13\r\n#define EFAULT 14\r\n#define ENOTBLK 15\r\n#define EBUSY 16\r\n#define EEXIST 17\r\n#define EXDEV 18\r\n#define ENODEV 19\r\n#define ENOTDIR 20\r\n#define EISDIR 21\r\n#define EINVAL 22\r\n#define ENFILE 23\r\n#define EMFILE 24\r\n#define ENOTTY 25\r\n#define ETXTBSY 26\r\n#define EFBIG 27\r\n#define ENOSPC 28\r\n#define ESPIPE 29\r\n#define EROFS 30\r\n#define EMLINK 31\r\n#define EPIPE 32\r\n#define EDOM 33\r\n#define ERANGE 34\r\n#define ENOMSG 35\r\n#define EIDRM 36\r\n#define ECHRNG 37\r\n#define EL2NSYNC 38\r\n#define EL3HLT 39\r\n#define EL3RST 40\r\n#define ELNRNG 41\r\n#define EUNATCH 42\r\n#define ENOCSI 43\r\n#define EL2HLT 44\r\n#define EDEADLK 45\r\n#define ENOLCK 46\r\n#define EBADE 50\r\n#define EBADR 51\r\n#define EXFULL 52\r\n#define ENOANO 53\r\n#define EBADRQC 54\r\n#define EBADSLT 55\r\n#define EDEADLOCK 56\r\n#define EBFONT 57\r\n#define ENOSTR 60\r\n#define ENODATA 61\r\n#define ETIME 62\r\n#define ENOSR 63\r\n#define ENONET 64\r\n#define ENOPKG 65\r\n#define EREMOTE 66\r\n#define ENOLINK 67\r\n#define EADV 68\r\n#define ESRMNT 69\r\n#define ECOMM 70\r\n#define EPROTO 71\r\n#define EMULTIHOP 74\r\n#define ELBIN 75\r\n#define EOVERFLOW 76\r\n#define EBADMSG 77\r\n#define ENOTUNIQ 80\r\n#define EBADFD 81\r\n#define EREMCHG 82\r\n#define ELIBACC 83\r\n#define ELIBBAD 84\r\n#define ELIBSCN 85\r\n#define ELIBMAX 86\r\n#define ELIBEXEC 87\r\n#define ENOSYS 88\r\n#define ENMFILE 89\r\n#define ENOTEMPTY 90\r\n#define ENAMETOOLONG 91\r\n#define EILSEQ 92\r\n#define __ELASTERROR 2000\r\n\r\n#endif\r\n";

static u64 cc_headers_h_fenv = (u64)"/* Header fenv.h */\r\n\r\nint feclearexcept(int);\r\nint fetestexcept(int);\r\n\r\n#define FE_INVALID 1\r\n#define FE_DENORMAL 2\r\n#define FE_INEXACT 32\r\n#define FE_DIVBYZERO 4 \r\n#define FE_OVERFLOW 8\r\n#define FE_UNDERFLOW 16\r\n#define FE_STACKFAULT 64\r\n#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)\r\n";

static u64 cc_headers_h_float = (u64)"/* Header float.h */\r\n\r\n//#define DBL_MAX_10_EXP 308\r\n//#define DBL_MANT_DIG 53\r\n\r\n#define FLT_RADIX 2\r\n\r\n#define FLT_DIG 6\r\n#define FLT_MIN_EXP -125\r\n#define FLT_MIN 1.17549435E-38F // decimal constant\r\n#define FLT_MIN 0X1P-126F // hex constant\r\n#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant\r\n#define FLT_TRUE_MIN 0X1P-149F // hex constant\r\n#define FLT_HAS_SUBNORM 1\r\n#define FLT_MIN_10_EXP -37\r\n#define FLT_MAX_EXP +128\r\n#define FLT_MAX 3.40282347E+38F // decimal constant\r\n#define FLT_MAX 0X1.fffffeP127F // hex constant\r\n#define FLT_MAX_10_EXP +38\r\n#define FLT_EPSILON 1.19209290e-07F\r\n#define FLT_MANT_DIG 23\r\n\r\n#define DBL_MANT_DIG 53\r\n#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant\r\n//#define DBL_EPSILON 0X1P-52 // hex constant\r\n#define DBL_DECIMAL_DIG 17\r\n#define DBL_DIG 15\r\n#define DBL_MIN_EXP -1021\r\n#define DBL_MIN 2.2250738585072014E-308 // decimal constant\r\n//#define DBL_MIN 0X1P-1022 // hex constant\r\n#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant\r\n//#define DBL_TRUE_MIN 0X1P-1074 // hex constant\r\n#define DBL_HAS_SUBNORM 1\r\n#define DBL_MIN_10_EXP -307\r\n#define DBL_MAX_EXP +1024\r\n#define DBL_MAX 1.7976931348623157E+308 // decimal constant\r\n//#define DBL_MAX 0X1.fffffffffffffP1023 // h\r\n#define DBL_MAX_10_EXP +308\r\n\r\n#define LDBL_MIN DBL_MIN\r\n#define LDBL_MAX DBL_MAX\r\n#define LDBL_EPSILON 2.2204460492503131E-16\r\n#define LDBL_MANT_DIG 53\r\n#define LDBL_MIN_EXP -1021\r\n#define LDBL_MAX_EXP +1024\r\n\r\nint     _isnan(double);\r\n#define isnan _isnan\r\n";

static u64 cc_headers_h_inttypes = (u64)"/* Header inttypes.h */\r\n\r\n#include <stdint.h>\r\n\r\n/* fprintf macros for signed types */\r\n#define PRId8 \"d\"\r\n#define PRId16 \"d\"\r\n#define PRId32 \"d\"\r\n#define PRId64 \"I64d\"\r\n\r\n#define PRIdLEAST8 \"d\"\r\n#define PRIdLEAST16 \"d\"\r\n#define PRIdLEAST32 \"d\"\r\n#define PRIdLEAST64 \"I64d\"\r\n\r\n#define PRIdFAST8 \"d\"\r\n#define PRIdFAST16 \"d\"\r\n#define PRIdFAST32 \"d\"\r\n#define PRIdFAST64 \"I64d\"\r\n\r\n#define PRIdMAX \"I64d\"\r\n\r\n#define PRIi8 \"i\"\r\n#define PRIi16 \"i\"\r\n#define PRIi32 \"i\"\r\n#define PRIi64 \"I64i\"\r\n\r\n#define PRIiLEAST8 \"i\"\r\n#define PRIiLEAST16 \"i\"\r\n#define PRIiLEAST32 \"i\"\r\n#define PRIiLEAST64 \"I64i\"\r\n\r\n#define PRIiFAST8 \"i\"\r\n#define PRIiFAST16 \"i\"\r\n#define PRIiFAST32 \"i\"\r\n#define PRIiFAST64 \"I64i\"\r\n\r\n#define PRIiMAX \"I64i\"\r\n\r\n#define PRIo8 \"o\"\r\n#define PRIo16 \"o\"\r\n#define PRIo32 \"o\"\r\n#define PRIo64 \"I64o\"\r\n\r\n#define PRIoLEAST8 \"o\"\r\n#define PRIoLEAST16 \"o\"\r\n#define PRIoLEAST32 \"o\"\r\n#define PRIoLEAST64 \"I64o\"\r\n\r\n#define PRIoFAST8 \"o\"\r\n#define PRIoFAST16 \"o\"\r\n#define PRIoFAST32 \"o\"\r\n#define PRIoFAST64 \"I64o\"\r\n\r\n#define PRIoMAX \"I64o\"\r\n\r\n/* fprintf macros for unsigned types */\r\n#define PRIu8 \"u\"\r\n#define PRIu16 \"u\"\r\n#define PRIu32 \"u\"\r\n#define PRIu64 \"I64u\"\r\n\r\n\r\n#define PRIuLEAST8 \"u\"\r\n#define PRIuLEAST16 \"u\"\r\n#define PRIuLEAST32 \"u\"\r\n#define PRIuLEAST64 \"I64u\"\r\n\r\n#define PRIuFAST8 \"u\"\r\n#define PRIuFAST16 \"u\"\r\n#define PRIuFAST32 \"u\"\r\n#define PRIuFAST64 \"I64u\"\r\n\r\n#define PRIuMAX \"I64u\"\r\n\r\n#define PRIx8 \"x\"\r\n#define PRIx16 \"x\"\r\n#define PRIx32 \"x\"\r\n#define PRIx64 \"I64x\"\r\n\r\n#define PRIxLEAST8 \"x\"\r\n#define PRIxLEAST16 \"x\"\r\n#define PRIxLEAST32 \"x\"\r\n#define PRIxLEAST64 \"I64x\"\r\n\r\n#define PRIxFAST8 \"x\"\r\n#define PRIxFAST16 \"x\"\r\n#define PRIxFAST32 \"x\"\r\n#define PRIxFAST64 \"I64x\"\r\n\r\n#define PRIxMAX \"I64x\"\r\n\r\n#define PRIX8 \"X\"\r\n#define PRIX16 \"X\"\r\n#define PRIX32 \"X\"\r\n#define PRIX64 \"I64X\"\r\n\r\n#define PRIXLEAST8 \"X\"\r\n#define PRIXLEAST16 \"X\"\r\n#define PRIXLEAST32 \"X\"\r\n#define PRIXLEAST64 \"I64X\"\r\n\r\n#define PRIXFAST8 \"X\"\r\n#define PRIXFAST16 \"X\"\r\n#define PRIXFAST32 \"X\"\r\n#define PRIXFAST64 \"I64X\"\r\n\r\n#define PRIXMAX \"I64X\"\r\n\r\n";

static u64 cc_headers_h_stdint = (u64)"/* Header stdint.h */\r\n\r\n#ifndef $stdint\r\n#define $stdint\r\n\r\ntypedef signed char int8_t;\r\ntypedef short int16_t;\r\ntypedef int int32_t;\r\ntypedef long long int int64_t;\r\n\r\ntypedef unsigned char uint8_t;\r\ntypedef unsigned short uint16_t;\r\ntypedef unsigned int uint32_t;\r\ntypedef unsigned long long int uint64_t;\r\n\r\ntypedef long long int intptr_t;\r\ntypedef unsigned long long int uintptr_t;\r\ntypedef long long intmax_t;\r\ntypedef unsigned long long uintmax_t;\r\n\r\ntypedef char int_least8_t;\r\ntypedef unsigned char uint_least8_t;\r\ntypedef short int_least16_t;\r\ntypedef unsigned short uint_least16_t;\r\ntypedef int int_least32_t;\r\ntypedef unsigned int uint_least32_t;\r\ntypedef long long int_least64_t;\r\ntypedef unsigned long long uint_least64_t;\r\n\r\n#define INTMAX_C(a) (a##LL)\r\n#define UINTMAX_C(a) (a##ULL)\r\n\r\ntypedef char int_fast8_t;\r\ntypedef unsigned char uint_fast8_t;\r\ntypedef short int_fast16_t;\r\ntypedef unsigned short uint_fast16_t;\r\ntypedef int int_fast32_t;\r\ntypedef unsigned int uint_fast32_t;\r\ntypedef long long int_fast64_t;\r\ntypedef unsigned long long uint_fast64_t;\r\n\r\n\r\n#define INT8_MIN -128\r\n#define INT8_MAX 127\r\n#define INT16_MIN -32768\r\n#define INT16_MAX 32767\r\n#define INT32_MIN 0x80000000\r\n#define INT32_MAX 0x7FFFFFFF\r\n#define INT64_MIN 0x8000000000000000\r\n#define INT64_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define UINT8_MAX 255\r\n#define UINT16_MAX 65535\r\n#define UINT32_MAX 0xFFFFFFFF\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define INTPTR_MIN 0x8000000000000000\r\n#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF\r\n#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n#define SIZE_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define PTRDIFF_MIN 0x8000000000000000\r\n#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define WCHAR_MIN 0\r\n#define WCHAR_MAX 65535\r\n\r\n#define WINT_MIN 0\r\n#define WINT_MAX 65535\r\n\r\n#define UINT64_C(x) (x##ull)\r\n\r\n#endif\r\n";

static u64 cc_headers_h_limits = (u64)"/* Header limits.h */\n\n#define CHAR_BIT 8\n\n#define CHAR_MIN 0\n#define CHAR_MAX 255\n\n#define UCHAR_MIN 0\n#define UCHAR_MAX 255\n\n#define SCHAR_MIN -128\n#define SCHAR_MAX 127\n\n#define SHRT_MIN -32768\n#define SHRT_MAX 32767\n\n#define USHRT_MIN 0\n#define USHRT_MAX 65535\n\n#define INT_MIN -2147483648\n#define INT_MAX  2147483647\n\n#define UINT_MIN 0\n#define UINT_MAX 4294967295\n\n#define LONG_MIN -2147483648\n#define LONG_MAX  2147483647\n\n#define ULONG_MIN 0\n#define ULONG_MAX 4294967295\n\n#define LLONG_MIN -9223372036854775808LL\n#define LLONG_MAX  9223372036854775807LL\n\n#define ULLONG_MIN 0\n#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL\n\n#define SIZE_MAX ULLONG_MAX\n";

static u64 cc_headers_h_locale = (u64)"/* Header locale.h */\r\n\r\n#ifndef $locale\r\n#define $locale\r\n\r\n#define LC_ALL 0\r\n#define LC_COLLATE 1\r\n#define LC_CTYPE 2\r\n#define LC_MONETARY 3\r\n#define LC_NUMERIC 4\r\n#define LC_TIME 5\r\n\r\nstruct lconv {\r\n\tchar *decimal_point;\r\n\tchar *thousands_sep;\r\n\tchar *grouping;\r\n\tchar *int_curr_symbol;\r\n\tchar *currency_symbol;\r\n\tchar *mon_decimal_point;\r\n\tchar *mon_thousands_sep;\r\n\tchar *mon_grouping;\r\n\tchar *positive_sign;\r\n\tchar *negative_sign;\r\n\tchar int_frac_digits;\r\n\tchar frac_digits;\r\n\tchar p_cs_precedes;\r\n\tchar p_sep_by_space;\r\n\tchar n_cs_precedes;\r\n\tchar n_sep_by_space;\r\n\tchar p_sign_posn;\r\n\tchar n_sign_posn;\r\n};\r\nchar *setlocale(int category, const char *locale);\r\n\r\nstruct lconv *localeconv(void);\r\n\r\nchar * setlocale(int,const char *);\r\n#endif\r\n";

static u64 cc_headers_h__ansi = (u64)"/* Header _ansi.h */\r\n";

static u64 cc_headers_h_math = (u64)"/* Header math.h */\n\n#define HUGE_VAL 1.7976931348623156e+308\n\ndouble floor(double);\ndouble ceil(double);\ndouble sqrt(double);\ndouble sin(double);\ndouble cos(double);\ndouble tan(double);\ndouble fmod(double,double);\ndouble asin(double);\ndouble acos(double);\ndouble atan(double);\ndouble log(double);\ndouble log10(double);\ndouble exp(double);\ndouble modf(double,double*);\ndouble atan2(double,double);\ndouble pow(double,double);\ndouble fabs(double);\ndouble sinh(double);\ndouble cosh(double);\ndouble tanh(double);\ndouble frexp(double,int*);\ndouble ldexp(double,int);\nint isnan(double);\n\n#define ldexpl ldexp\n\nfloat sinf(float);\nfloat cosf(float);\nfloat tanf(float);\nfloat expf(float);\nfloat powf(float, float);\nfloat logf(float);\n\nfloat sqrtf(float);\nfloat acosf(float);\nfloat atan2f(float,float);\nfloat ceilf(float);\n\ndouble acosh (double);\nlong double acoshl(long double);\nlong double acoshl(long double);\nfloat acoshf(float);\n\ndouble asinh (double);\nlong double asinhl(long double);\nlong double sinhl(long double);\nfloat asinhf(float);\n\ndouble atanh(double);\nlong double atanhl(long double);\nfloat atanhf(float);\n\nlong double expm1l(long double);\ndouble expm1(double);\nfloat expm1f(float);\ndouble _expm1i(int);\n\ndouble cbrt(double);\nlong double cbrtl(long double);\nfloat cbrtf(float);\n\ndouble trunc(double x);\nlong double truncl(long double);\nfloat truncf(float);\n\ndouble round(double);\nfloat roundf(float);\nlong double roundl(long double);\ndouble _roundi(int);\n\nlong double fminl(long double,long double);\nfloat fminf(float ,float);\ndouble fmin(double,double);\n\n//float fabsf(float);\n#define fabsf fabs\n\ndouble lgamma (double);\nlong double lgammal(long double);\nfloat lgammaf(float);\n\nlong double tgammal(long double);\ndouble tgamma(double);\nfloat tgammaf(float);\n\ndouble log1p(double);\nlong double log1pl(long double);\nfloat log1pf(float);\n\nlong double log10l(long double);\nfloat log10f(float);\ndouble _log10i(int);\ndouble log10(double);\n\ndouble erf(double);\nlong double erfl(long double);\nfloat erff(float);\n\ndouble hypot (double, double);\ndouble _hypot(double,double);\nlong double hypotl(long double,long double);\nfloat hypotf(float,float);\n\ndouble nextafter (double, double);\nlong double nextafterl(long double,long double);\nfloat nextafterf(float,float);\n\ndouble nexttoward(double,long double);\nlong double nexttowardl(long double,long double);\nfloat nexttowardf(float,long double);\n\ndouble erfc(double);\nlong double erfcl(long double);\nfloat erfcf(float);\n\nint _finite(double);\n#define finite _finite\n\nfloat floorf(float);\n\ndouble _copysign(double,double);\n#define copysign _copysign\n\nlong double fmaxl(long double,long double);\ndouble fmax(double,double);\nfloat fmaxf(float,float);\nfloat fmodf(float,float);\n\n//long double exp2l(long double);\ndouble exp2(double);\nfloat exp2f(float);\n\n//double log2(double);\n#define log2(x) (log(x)*1.442695041)\n\n#define M_PI 3.1415926535897932384625433\n#define M_PI_2 (M_PI/2.0)\n#define M_2_PI 0.63661977236758134308\n\nint isinf(double);\n\nint _finite(double);\n\n#define isfinite _finite\n\nint isfinitef(float);\nint isfinitel(long double);\n\n";

static u64 cc_headers_h_setjmp = (u64)"/* Header setjmp.h */\n\n\n#ifndef $setjmphdr\n#define $setjmphdr 1\n\ntypedef int jmp_buf[128];\n\n//void $mcclongjmp(jmp_buf, int);\n//int $mccsetjmp(jmp_buf);\n\n#define setjmp $setjmp\n#define longjmp $longjmp\n\n#endif\n\n";

static u64 cc_headers_h_signal = (u64)"/* Header signal.h */\r\n\r\n#define SIGINT    2\r\n#define SIGILL    4\r\n#define SIGFPE    8\r\n#define SIGSEGV  11\r\n#define SIGTERM  15\r\n#define SIGBREAK 21\r\n#define SIGABRT  22\r\n\r\n#define SIG_DFL (void (*)(int))0\r\n#define SIG_IGN (void (*)(int))1\r\n#define SIG_SGE (void (*)(int))3\r\n#define SIG_ACK (void (*)(int))4\r\n\r\n#define SIG_ERR (void (*)(int))-1\r\n\r\nextern void (*signal(int, void (*)(int)))(int);\r\n\r\nextern int raise(int);\r\n\r\n\r\ntypedef int sig_atomic_t;\r\n";

static u64 cc_headers_h_stdarg = (u64)"/* Header stdarg.h */\n\n#ifndef $STDARG\n #define $STDARG\n\n//coded for x64 target as used by mcc (with first four params also on stack)\n\n typedef char *\tva_list;\n\n #if __MCCI__\n  #define va_start(ap,v) ap=((va_list)&v-8)\n  #define va_arg(ap,t) *(t*)((ap-=8)+8)\n  #define va_copy(dest,src) (dest=src)\n  #define va_end(ap)\t( ap = (va_list)0 )\n\n #else\n  #define va_start(ap,v) ap=((va_list)&v+8)\n  #define va_arg(ap,t) *(t*)((ap+=8)-8)\n  #define va_copy(dest,src) (dest=src)\n  #define va_end(ap)\t( ap = (va_list)0 )\n\n #endif\n\n#endif\n";

static u64 cc_headers_h_stdbool = (u64)"/* Header stdbool.h */\r\n\r\n#define bool unsigned char\r\n#define true 1\r\n#define false 0\r\n\r\n\r\n";

static u64 cc_headers_h_stddef = (u64)"/* Header stddef.h */\r\n\r\n#ifndef $stddef\r\n#define $stddef\r\n\r\ntypedef signed long long int ssize_t;\r\ntypedef unsigned long long int size_t;\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\n#define NULL ((void*)0)\r\n\r\n#define offsetof(a,b) (size_t) &( ((a*)0) -> b)\r\n\r\ntypedef long long int ptrdiff_t;\r\n\r\n#endif // stddef\r\n";

static u64 cc_headers_h_stdio = (u64)"/* Header stdio.h */\n\n#ifndef $stdio\n#define $stdio 1\n\n#define __attribute__(x)\n\n#ifndef $valist\n\ttypedef char* va_list;\n\t#define $valist\n#endif\n\n#include <stddef.h>\n\ntypedef long long int fpos_t;\n\n#define SEEK_SET 0\n#define SEEK_CUR 1\n#define SEEK_END 2\n\n#define\tSTDIN_FILENO\t0\n#define\tSTDOUT_FILENO\t1\n#define\tSTDERR_FILENO\t2\n\n#define EOF (-1)\n#define FILENAME_MAX 260\n\n#define L_tmpnam 10\n\ntypedef struct {\n\tchar *_ptr;\n\tint   _cnt;\n\tchar *_base;\n\tint   _flag;\n\tint   _file;\n\tint   _charbuf;\n\tint   _bufsiz;\n\tchar *_tmpfname;\n} FILE;\n\nextern char* __iob_func(void);\n\n#define stdin ((FILE*)(__iob_func()))\n#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))\n#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))\n\n#define _IOREAD 0x0001\n#define _IOWRT 0x0002\n\n#define _IOFBF 0x0000\n#define _IOLBF 0x0040\n#define _IONBF 0x0004\n\n#define _IOMYBUF 0x0008\n#define _IOEOF 0x0010\n#define _IOERR 0x0020\n#define _IOSTRG 0x0040\n#define _IORW 0x0080\n\n#define BUFSIZ 512\n\nFILE* fopen(const char*, const char*);\nint fclose(FILE*);\nlong ftell(FILE*);\n//long long int _ftelli64(FILE*);\nint fseek(FILE*,long,int);\nint _fseeki64(FILE*,long long int,int);\n\nsize_t fread(void*, size_t, size_t, FILE*);\nsize_t fwrite(const void*, size_t, size_t, FILE*);\nint remove(const char*);\nint rename(const char *,const char *);\nFILE* freopen(const char*, const char*, FILE*);\nFILE* _wfopen(const wchar_t*,const wchar_t *);\n\nint printf(const char*, ...);\nint sprintf(char*,const char*, ...);\nint fprintf(FILE*,const char*, ...);\nint sscanf(const char*, const char*, ...);\nint scanf(const char*, ...);\nint fscanf(FILE *,const char *, ...);\nint _snprintf(char *,size_t,const char*,...);\n#define snprintf _snprintf\nint _vsnprintf(char*, size_t, const char*, va_list);\nint vsnprintf(char*,size_t,const char*,va_list);\nint vsprintf(char*, const char*, va_list);\nint _wremove(const wchar_t*);\nint _wrename(const wchar_t*,const wchar_t*);\n\ntypedef char* va_list;\n\nint vfprintf(FILE*, const char*, va_list);\nint vprintf(const char*, va_list);\n\nint puts(const char*);\nchar* fgets(char*, int, FILE*);\nint fputs(const char*, FILE*);\nint fgetc(FILE*);\nint fputc(int, FILE*);\nint ungetc(int, FILE*);\nint getchar(void);\nint putchar(int);\nint fflush(FILE *);\nint getc(FILE *);\nint putc(int, FILE *);\n\nint feof(FILE*);\nint ferror(FILE*);\nvoid clearerr(FILE*);\n\nint fileno(FILE*);\nint _fileno(FILE*);\nint setvbuf(FILE*,char*,int,size_t);\nFILE* _popen(const char*, const char*);\nint _pclose(FILE*);\nint _unlink(const char *);\n#define unlink _unlink;\nFILE* _fdopen(int, const char *);\n#define fdopen _fdopen\nint fgetpos(FILE*, fpos_t*);\nint fsetpos(FILE*, const fpos_t*);\nvoid perror(char*);\nvoid setbuf(FILE*, char*);\n\nvoid rewind(FILE*);\n\nFILE* tmpfile(void);\n\nchar* tmpnam(char*);\nwchar_t getwc(FILE *);\n\nextern void* _wenviron;\n\n#endif\n\n";

static u64 cc_headers_h_stdlib = (u64)"/* Header stdlib.h */\n\n#ifndef $stdlib\n#define $stdlib 1\n\n#include <stddef.h>\n\n#define EXIT_FAILURE 1\n#define EXIT_SUCCESS 0\n\n#define RAND_MAX 32767\n\nvoid* malloc(size_t);\nvoid* realloc(void*, size_t);\nvoid* calloc(size_t, size_t);\n\nvoid free(void*);\n\nvoid exit(int);\n\nint system(const char*);\nint _wsystem(const wchar_t*);\n\nint abs(int);\nlong labs(long);\nlong long llabs(long);\nint rand(void);\nvoid srand(unsigned int);\nint atoi(const char*);\nlong atol(const char*);\nlong long atoll(const char*);\nlong long atoi64(const char*);\ndouble atof(const char *);\nint\tatexit(void (*)(void));\nchar *_itoa(int,char *,int);\n\n#define itoa _itoa\n\nvoid qsort(void*, size_t, size_t, int (*)(void*, void*));\n\ntypedef struct {\n\tlong long int quot;\n\tlong long int rem;\n} lldiv_t;\n\nlldiv_t lldiv(long long int, long long int);\n\nchar* getenv(const char*);\nwchar_t* _wgetenv(const wchar_t*);\nint _wputenv(const wchar_t*);\n\n\ndouble strtod(const char*, char**);\n\n//float strtof(const char *, char**);\n#define strtof strtod\n\nlong double strtold(const char*, char**);\nvoid abort(void);\nlong int strtol(const char*, char**, int);\n\nlong double strtold(const char *,char **);\n\nlong long int _strtoi64(const char *,char **,int);\n#define strtoll _strtoi64\n\nunsigned long long int _strtoui64(const char *,char **,int);\n\nunsigned long long int _strtoui64(const char*, char**, int);\n#define strtoull _strtoui64\nunsigned long strtoul(const char*, char**, int);\n\nsize_t _msize(void *);\n#define msize _msize\n\nvoid* bsearch(const void *,const void *, size_t, size_t,\n\t\tint (*_compar)(const void *,const void *));\n\n\nchar* _fullpath(char*, const char*, size_t);\n\n\n#endif\n";

static u64 cc_headers_h__syslist = (u64)"/* Header _syslist.h */\r\n";

static u64 cc_headers_h_string = (u64)"/* Header string.h */\n\n#include <stddef.h>\n\nvoid* memcpy(void*, const void*, size_t);\nvoid* memmove(const void*, const void*, size_t);\nvoid* memset(void*, int, size_t);\nint memcmp(const void*, const void*, size_t);\nvoid* memchr(const void *, int, size_t);\n\nsize_t strlen(const char*);\nchar* strcpy(char*, const char*);\nchar* strncpy(char*, const char*, size_t);\nchar* strcat(char*, const char*);\nint strcmp(const char*, const char*);\nint strncmp(const char*, const char*, size_t);\nchar* strchr(const char*, int);\nchar* strstr(const char*, const char*);\nchar* strrchr(const char*, int);\nint _stricmp(const char*, const char*);\n#define stricmp _stricmp\n#define strcasecmp _stricmp\n\n\n\nint _strnicmp(const char*, const char*, size_t);\n#define strnicmp _strnicmp\nchar* strncat(char*, const char*, size_t);\nchar* strtok(char*, const char*);\n\nsize_t strcspn(const char*, const char*);\nsize_t strspn(const char*, const char*);\nint strcoll(const char *, const char *);\n\nunsigned long strtoul(const char*, char**, int);\n\nchar* strerror(int);\nchar* strpbrk(const char*, const char*);\nsize_t strxfrm(char*, const char *, size_t);\n\nchar* _strupr(char*);\nchar* _strlwr(char*);\n#define strupr _strupr\n#define strlwr _strlwr\n\nchar*strnupr(char*,size_t);\nchar*strnlwr(char*,size_t);\nint strtrim(char*);\nchar*strrev(char*);\n\nchar* _strdup(const char*);\n#define strdup _strdup\n\nint _wcsicmp(const wchar_t *,const wchar_t *);\n\nwchar_t *wcspbrk(const wchar_t*,const wchar_t*);\n\nsize_t wcslen(const wchar_t*);\n";

static u64 cc_headers_h_time = (u64)"/* Header time.h */\r\n\r\n#ifndef $time\r\n#define $time\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long clock_t;\r\nclock_t clock(void);\r\n\r\n//typedef long time_t;\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\ntypedef long long int time_t;\r\n#endif\r\n\r\nstruct tm\r\n{\r\n  int\ttm_sec;\r\n  int\ttm_min;\r\n  int\ttm_hour;\r\n  int\ttm_mday;\r\n  int\ttm_mon;\r\n  int\ttm_year;\r\n  int\ttm_wday;\r\n  int\ttm_yday;\r\n  int\ttm_isdst;\r\n};\r\n\r\n//struct tm *localtime(time_t*);\r\nstruct tm* _localtime32(time_t*);\r\n#define localtime _localtime32\r\n\r\ntime_t _time64(time_t *_timer);\r\n#define time _time64\r\n\r\n#define CLOCKS_PER_SEC 1000\r\n\r\nstruct tm *gmtime(const time_t*);\r\nsize_t strftime(char *, size_t, const char *, const struct tm *);\r\ntime_t mktime(struct tm *);\r\ndouble difftime(time_t, time_t);\r\n\r\nchar* asctime(const struct tm*);\r\n//char* ctime(const time_t *_time);\r\nchar* _ctime64(const time_t *_time);\r\n#define ctime _ctime64\r\n\r\n#endif\r\n";

static u64 cc_headers_h_utime = (u64)"/* sys/utime.h header */\n\n#ifndef $utime\n#define $utime\n\nstruct _utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\n\nstruct utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\nstruct __utimbuf64 {\n  long long int actime;\n  long long int modtime;\n};\n\nint _utime64(const char *_Filename,struct __utimbuf64 *_Time);\n\nint utime(const char *_Filename,struct utimbuf *_Utimbuf) {\n  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);\n}\n\n#endif\n";

static u64 cc_headers_h_unistd = (u64)"/* unistd.h header */\r\n\r\nunsigned int _sleep(unsigned int);\r\n#define sleep _sleep\r\n\r\n#define alarm(x) {puts(\"ALARM\"); exit(1);}\r\n\r\nint _write(int,void*,unsigned int);\r\n#define write _write\r\n\r\nint _close(int);\r\n#define close _close\r\n";

static u64 cc_headers_h_safelib = (u64)"/* Header safelib.h */\r\n";

static u64 cc_headers_h_wchar = (u64)"/* Header wchar.h */\r\n\r\n#include <stddef.h>\r\n\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wint_t;\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\nsize_t wcslen(const wchar_t*);\r\nwchar_t* wcscpy(wchar_t*,const wchar_t*);\r\n//wchar_t* _wgetenv(constwchar_t*);\r\nwchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);\r\nwchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);\r\n\r\nwchar_t* wcschr(wchar_t*,wchar_t);\r\nwchar_t* wcsstr(const wchar_t*,const wchar_t*);\r\n\r\n\r\nint wcscmp(const wchar_t*,const wchar_t*);\r\ntypedef long _off_t;\r\n";

static u64 cc_headers_h_wctype = (u64)"/* Header wctype.h */\r\n";

static u64 cc_headers_h_systypes = (u64)"/* types.h */\r\n#ifndef $systypes\r\n#define $systypes 1\r\n\r\ntypedef long int off_t;\r\ntypedef long int ino_t;\r\ntypedef unsigned int dev_t;\r\n\r\ntypedef long long time_t;\r\n\r\n#endif\r\n";

static u64 cc_headers_h_sysstat = (u64)"/* stat.h */\r\n\r\n#ifndef $sysstat\r\n#define $sysstat\r\n\r\n#include <stddef.h>\r\n\r\nstruct _stat {\r\n\tunsigned int\tst_dev;\r\n\tunsigned short\tst_ino;\r\n\tunsigned short\tst_mode;\r\n\tshort\t\t\tst_nlink;\r\n\tshort\t\t\tst_uid;\r\n\tshort\t\t\tst_gid;\r\n\tunsigned long\tst_rdev;\r\n\tunsigned int\tst_size;\r\n\tunsigned long long int\tst_atime;\r\n\tunsigned long long int\tst_mtime;\r\n\tunsigned long long int\tst_ctime;\r\n};\r\n\r\n#define stat _stat\r\n#define _stati64 _stat\r\n\r\n#define _S_IFMT 0xF000\r\n#define _S_IFDIR 0x4000\r\n#define _S_IFCHR 0x2000\r\n#define _S_IFIFO 0x1000\r\n#define _S_IFREG 0x8000\r\n#define _S_IREAD 0x0100\r\n#define _S_IWRITE 0x0080\r\n#define _S_IEXEC 0x0040\r\n\r\n#define S_IFMT 0xF000\r\n#define S_IFDIR 0x4000\r\n#define S_IFCHR 0x2000\r\n#define S_IFIFO 0x1000\r\n#define S_IFREG 0x8000\r\n#define S_IREAD 0x0100\r\n#define S_IWRITE 0x0080\r\n#define S_IEXEC 0x0040\r\n\r\n#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)\r\n#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)\r\n#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)\r\n#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)\r\n\r\n\r\n#define\t_S_IRWXU\t(_S_IREAD | _S_IWRITE | _S_IEXEC)\r\n#define\t_S_IXUSR\t_S_IEXEC\r\n#define\t_S_IWUSR\t_S_IWRITE\r\n\r\n#define\tS_IRWXU\t\t_S_IRWXU\r\n#define\tS_IXUSR\t\t_S_IXUSR\r\n#define\tS_IWUSR\t\t_S_IWUSR\r\n#define\tS_IRUSR\t\t_S_IRUSR\r\n#define\t_S_IRUSR\t_S_IREAD\r\n\r\n#define S_IRGRP    (S_IRUSR >> 3)\r\n#define S_IWGRP    (S_IWUSR >> 3)\r\n#define S_IXGRP    (S_IXUSR >> 3)\r\n#define S_IRWXG    (S_IRWXU >> 3)\r\n\r\n#define S_IROTH    (S_IRGRP >> 3)\r\n#define S_IWOTH    (S_IWGRP >> 3)\r\n#define S_IXOTH    (S_IXGRP >> 3)\r\n#define S_IRWXO    (S_IRWXG >> 3)\r\n\r\n//#define\tS_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\r\n//#define\tS_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\r\n//#define\tS_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\r\n#define\tS_IFBLK\t0x3000\t/* Block: Is this ever set under w32? */\r\n#define\tS_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\r\n#define\tS_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\r\n\r\n\r\n\r\nint stat(const char *, struct stat*);\r\n\r\nint _fstati64(int, struct stat*);\r\n\r\nint fstat(int, struct stat *);\r\n#define _fstat fstat\r\n\r\nint _wstati64(const wchar_t,struct _stati64 *buffer);  \r\n\r\n\r\n\r\n#endif\r\n";

static u64 cc_headers_h_systimeb = (u64)"/* timeb.h */\r\n\r\n#ifndef $timeb\r\n#define $timeb\r\n\r\n#include <time.h>\r\n\r\nstruct _timeb {\r\n\ttime_t time;\r\n\tunsigned short millitm;\r\n\tshort timezone;\r\n\tshort dstflag;\r\n};\r\n#define timeb _timeb\r\n\r\nvoid _ftime64(struct _timeb*);\r\n#define _ftime _ftime64\r\n#define ftime _ftime64\r\n\r\n#endif\r\n";

static u64 cc_headers_h_sysutime = (u64)"/* sys/utime.h header */\n\n#ifndef $utime\n#define $utime\n\nstruct _utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\n\nstruct utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\nstruct __utimbuf64 {\n  long long int actime;\n  long long int modtime;\n};\n\nint _utime64(const char *_Filename,struct __utimbuf64 *_Time);\n\nint utime(const char *_Filename,struct utimbuf *_Utimbuf) {\n  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);\n}\n\n#endif\n";

static u64 cc_headers_h_memory = (u64)"#include <malloc.h>\r\n";

static u64 cc_headers_h_fcntl = (u64)"/* FCNTL.H */\r\n\r\nint _setmode(int,int);\r\n\r\n#ifndef _INC_FCNTL\r\n#define _INC_FCNTL\r\n\r\n#define _O_RDONLY 0x0000\r\n#define _O_WRONLY 0x0001\r\n#define _O_RDWR 0x0002\r\n#define _O_APPEND 0x0008\r\n#define _O_CREAT 0x0100\r\n#define _O_TRUNC 0x0200\r\n#define _O_EXCL 0x0400\r\n#define _O_TEXT 0x4000\r\n#define _O_BINARY 0x8000\r\n#define _O_WTEXT 0x10000\r\n#define _O_U16TEXT 0x20000\r\n#define _O_U8TEXT 0x40000\r\n#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)\r\n\r\n#define _O_RAW _O_BINARY\r\n#define _O_NOINHERIT 0x0080\r\n#define _O_TEMPORARY 0x0040\r\n#define _O_SHORT_LIVED 0x1000\r\n\r\n#define _O_SEQUENTIAL 0x0020\r\n#define _O_RANDOM 0x0010\r\n\r\n#if !defined(NO_OLDNAMES) || defined(_POSIX)\r\n#define O_RDONLY _O_RDONLY\r\n#define O_WRONLY _O_WRONLY\r\n#define O_RDWR _O_RDWR\r\n#define O_APPEND _O_APPEND\r\n#define O_CREAT _O_CREAT\r\n#define O_TRUNC _O_TRUNC\r\n#define O_EXCL _O_EXCL\r\n#define O_TEXT _O_TEXT\r\n#define O_BINARY _O_BINARY\r\n#define O_RAW _O_BINARY\r\n#define O_TEMPORARY _O_TEMPORARY\r\n#define O_NOINHERIT _O_NOINHERIT\r\n#define O_SEQUENTIAL _O_SEQUENTIAL\r\n#define O_RANDOM _O_RANDOM\r\n#define O_ACCMODE _O_ACCMODE\r\n#endif\r\n\r\n#endif\r\n";

static u64 cc_headers_h_io = (u64)"\r\n#ifndef $io\r\n#define $io\r\n\r\n#include <stdint.h>\r\n#include <wchar.h>\r\n#include <time.h>\r\n\r\n/* io.h */\r\n\r\n#define _A_NORMAL 0x00\r\n#define _A_RDONLY 0x01\r\n#define _A_HIDDEN 0x02\r\n#define _A_SYSTEM 0x04\r\n#define _A_SUBDIR 0x10\r\n#define _A_ARCH 0x20\r\n\r\n\r\n//#message \"IO included\"\r\nstruct _finddata_t {\r\n        unsigned    attrib;\r\n        time_t      time_create;\r\n        time_t      time_access;\r\n        time_t      time_write;\r\n        unsigned long    size;\r\n        char        name[260];\r\n};\r\n\r\nint _isatty(int);\r\n\r\nint _read(int, void*, unsigned int);\r\n#define read _read\r\n\r\nint _open(const char*, int, ...);\r\n#define open _open\r\n\r\nlong _lseek(int, long, int);\r\n#define lseek _lseek\r\n\r\nint _close(int);\r\n#define close _close\r\n\r\nintptr_t _get_osfhandle(int);\r\nint _open_osfhandle(intptr_t,int);\r\n\r\nint _setmode(int,int);\r\n#define setmode _setmode\r\n\r\nint _wchmod(const wchar_t*, int);\r\n\r\nint _chmod(const char *, int);\r\n#define chmod _chmod\r\n\r\nint _dup(int);\r\n#define dup _dup\r\n\r\nintptr_t _findfirst(const char*, struct _finddata_t*);\r\nint _findnext(intptr_t, struct _finddata_t*);\r\nint _findclose(intptr_t);\r\n\r\nint _access(const char*,int);\r\n#define access _access\r\n\r\nint _wunlink(const wchar_t*);\r\n\r\n\r\n#endif\r\n";

static u64 cc_headers_h_direct = (u64)"#ifndef $direct\r\n#define $direct\r\n\r\ntypedef struct {\r\n unsigned int total_clusters;\r\n unsigned int avail_clusters;\r\n unsigned int sectors_per_cluster;\r\n unsigned int bytes_per_sector;\r\n} diskfree_t;\r\n\r\nint chdir(const char *);\r\nchar* _getcwd(char *, int);\r\n#define getcwd _getcwd\r\nint _mkdir(const char *);\r\nint _rmdir(const char *);\r\nint _wrmdir(const wchar_t*);\r\nint _wmkdir(const wchar_t*);\r\n\r\n#define mkdir _mkdir\r\n#define rmdir _rmdir\r\n\r\nint _chdrive(int);\r\nchar* _getdcwd(int, char *, int);\r\nwchar_t* _wgetcwd(wchar_t*, int);\r\nint _wchdir(const wchar_t*);\r\nint _getdrive(void);\r\nint _chdir(const char*);\r\n#define chdir _chdir\r\n\r\nunsigned long _getdrives(void);\r\nunsigned int _getdiskfree(unsigned int, diskfree_t*);\r\n\r\n#endif\r\n\r\n";

static u64 cc_headers_h_process = (u64)"/* Header process.h */\r\n#ifndef $process\r\n#define $process\r\n\r\n#include <stdint.h>\r\n\r\n#define P_WAIT\t\t0\r\n#define P_NOWAIT\t1\r\n#define P_OVERLAY\t2\r\n#define P_DETACH\t4\r\n#define WAIT_CHILD 0\r\n#define _P_WAIT P_WAIT\r\n#define _P_NOWAIT P_NOWAIT\r\n#define _P_OVERLAY P_OVERLAY\r\n\r\nint _spawnvp(int, const char*, const char*const*);\r\n#define spawnvp _spawnvp\r\n\r\nvoid endthread(void);\r\nunsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);\r\nvoid _endthreadex(unsigned);\r\nint _cwait(int*, int, int);\r\n#define cwait _cwait\r\n//int _System(const char *cmd,int nCmdShow);\r\n\r\nintptr_t _execve(const char*, const char*const*, const char*const*);\r\n#define execve _execve\r\n\r\n//#define _WAIT_CHILD\t0\r\n//#endif\r\n#endif\r\n\r\n";

static u64 cc_headers_h_malloc = (u64)"#include <stddef.h>\n\nvoid* malloc(size_t);\nvoid* realloc(void *, size_t);\nvoid  free(void *);\nvoid *_alloca(size_t);\n\n#define alloca malloc\n";

static u64 cc_headers_h_conio = (u64)"/* conio.h */\r\n#include <stddef.h>\r\n#include <wchar.h>\r\n\r\nint _getch(void);\r\nint _kbhit(void);\r\nwint_t _getwch(void);\r\n\r\n#define getch _getch\r\n#define kbhit _kbhit\r\n\r\nint _putch(int);\r\nint _cprintf(char *, ...);\r\nint _getche(void);\r\nint _ungetch(int);\r\n\r\n#define putch _putch\r\n#define cprintf _cprintf\r\n#define getche _getche\r\n#define ungetch _ungetch\r\n";

static u64 cc_headers_h_winsock2 = (u64)"#ifndef _WINSOCK2_H\r\n#define _WINSOCK2_H\r\n\r\n#include <_mingw.h>\r\n#include <windows.h>\r\n\r\n#ifndef FD_SETSIZE\r\n#define FD_SETSIZE 64\r\n#endif\r\n\r\ntypedef unsigned int SOCKET;\r\n\r\ntypedef struct fd_set {\r\n  unsigned int   fd_count;\r\n  SOCKET  fd_array[FD_SETSIZE];\r\n} fd_set;\r\n\r\nextern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);\r\n\r\n#ifndef FD_CLR\r\n#define FD_CLR(fd,set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n    while (__i < ((fd_set *)(set))->fd_count-1) {\\\r\n        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\\\r\n        __i++;\\\r\n    }\\\r\n    ((fd_set*)(set))->fd_count--;\\\r\n    break;\\\r\n    }\\\r\n}\\\r\n} while (0)\r\n#endif\r\n\r\n#ifndef FD_SET\r\n/* this differs from the define in winsock.h and in cygwin sys/types.h */\r\n#define FD_SET(fd, set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n        break;\\\r\n    }\\\r\n}\\\r\nif (__i == ((fd_set *)(set))->fd_count) {\\\r\n    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\\\r\n        ((fd_set *)(set))->fd_array[__i] = (fd);\\\r\n        ((fd_set *)(set))->fd_count++;\\\r\n    }\\\r\n}\\\r\n} while(0)\r\n#endif\r\n\r\n#ifndef FD_ZERO\r\n#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)\r\n#endif\r\n\r\n#ifndef FD_ISSET\r\n#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))\r\n#endif\r\n\r\n#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */\r\n#define _TIMEVAL_DEFINED\r\nstruct timeval {\r\n    long tv_sec;\r\n    long tv_usec;\r\n};\r\n#endif\r\n\r\nstruct in_addr {\r\n    union {\r\n        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;\r\n        struct { unsigned short s_w1,s_w2; } S_un_w;\r\n        unsigned long S_addr;\r\n    } S_un;\r\n};\r\n#define s_addr  S_un.S_addr\r\n\r\nstruct sockaddr_in {\r\n    short sin_family;\r\n    unsigned short sin_port;\r\n    struct in_addr sin_addr;\r\n    char sin_zero[8];\r\n};\r\n\r\nstruct sockaddr {\r\n    unsigned short sa_family;\r\n    char sa_data[14];\r\n};\r\n\r\nstruct hostent {\r\n    char *h_name;\r\n    char **h_aliases;\r\n    short h_addrtype;\r\n    short h_length;\r\n    char **h_addr_list;\r\n};\r\n#define h_addr h_addr_list[0]\r\n\r\n#define WSADESCRIPTION_LEN  256\r\n#define WSASYS_STATUS_LEN   128\r\ntypedef struct WSAData {\r\n    WORD wVersion;\r\n    WORD wHighVersion;\r\n    char szDescription[WSADESCRIPTION_LEN+1];\r\n    char szSystemStatus[WSASYS_STATUS_LEN+1];\r\n    unsigned short iMaxSockets;\r\n    unsigned short iMaxUdpDg;\r\n    char *lpVendorInfo;\r\n} WSADATA;\r\ntypedef WSADATA *LPWSADATA;\r\n\r\n#define INVALID_SOCKET (SOCKET)(~0)\r\n#define SOCK_STREAM  1\r\n#define SO_REUSEADDR 4\r\n#define AF_INET 2\r\n#define MSG_PEEK 0x2\r\n#define INADDR_ANY (unsigned long)0x00000000\r\n#define INADDR_LOOPBACK 0x7f000001\r\n#define SOL_SOCKET 0xffff\r\n\r\n#define SD_RECEIVE  0x00\r\n#define SD_SEND     0x01\r\n#define SD_BOTH     0x02\r\n\r\n#define h_errno WSAGetLastError()\r\n\r\n#define WSABASEERR 10000\r\n#define TRY_AGAIN (WSABASEERR+1002)\r\n\r\nSOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);\r\nint __stdcall bind(SOCKET, const struct sockaddr *, int);\r\nint __stdcall closesocket(SOCKET);\r\nint __stdcall connect(SOCKET, const struct sockaddr *, int);\r\nstruct hostent *__stdcall gethostbyname(const char *);\r\nint __stdcall gethostname(char *, int);\r\nint __stdcall getpeername(SOCKET, struct sockaddr *, int *);\r\nint __stdcall getsockname(SOCKET, struct sockaddr *, int *);\r\nunsigned long __stdcall htonl(unsigned long);\r\nunsigned short __stdcall htons(unsigned short);\r\nint __stdcall listen(SOCKET, int);\r\nunsigned long __stdcall ntohl(unsigned long);\r\nunsigned short __stdcall ntohs(unsigned short);\r\nint __stdcall recv(SOCKET, char *, int, int);\r\nint __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);\r\nint __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);\r\nint __stdcall send(SOCKET, const char *, int, int);\r\nint __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);\r\nint __stdcall setsockopt(SOCKET, int, int, const char *, int);\r\nint __stdcall shutdown(SOCKET, int);\r\nint __stdcall WSACleanup(void);\r\nint __stdcall WSAGetLastError(void);\r\nint __stdcall WSAStartup(WORD, LPWSADATA);\r\n\r\nSOCKET __stdcall socket(int, int, int);\r\n\r\n#endif\r\n\r\n";

static u64 cc_headers_h__mingw = (u64)"/*\r\n * _mingw.h\r\n *\r\n *  This file is for TinyCC and not part of the Mingw32 package.\r\n *\r\n *  THIS SOFTWARE IS NOT COPYRIGHTED\r\n *\r\n *  This source code is offered for use in the public domain. You may\r\n *  use, modify or distribute it freely.\r\n *\r\n *  This code is distributed in the hope that it will be useful but\r\n *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY\r\n *  DISCLAIMED. This includes but is not limited to warranties of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n *\r\n */\r\n\r\n#ifndef __MINGW_H\r\n#define __MINGW_H\r\n\r\n/* some winapi files define these before including _mingw.h --> */\r\n#undef __cdecl\r\n#undef _X86_\r\n#undef WIN32\r\n/* <-- */\r\n\r\n#include <stddef.h>\r\n#include <stdarg.h>\r\n\r\n#define __int8 char\r\n#define __int16 short\r\n#define __int32 int\r\n#define __int64 long long\r\n#define _HAVE_INT64\r\n\r\n#define __cdecl\r\n#define __declspec(x) __attribute__((x))\r\n#define __unaligned __attribute__((packed))\r\n#define __fastcall __attribute__((fastcall))\r\n\r\n#define __MSVCRT__ 1\r\n#undef _MSVCRT_\r\n#define __MINGW_IMPORT extern __declspec(dllimport)\r\n#define __MINGW_ATTRIB_NORETURN\r\n#define __MINGW_ATTRIB_CONST\r\n#define __MINGW_ATTRIB_DEPRECATED\r\n#define __MINGW_ATTRIB_MALLOC\r\n#define __MINGW_ATTRIB_PURE\r\n#define __MINGW_ATTRIB_NONNULL(arg)\r\n#define __MINGW_NOTHROW\r\n#define __GNUC_VA_LIST\r\n\r\n#define _CRTIMP extern\r\n#define __CRT_INLINE extern __inline__\r\n\r\n#define _CRT_ALIGN(x) __attribute__((aligned(x)))\r\n#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))\r\n#define _CRT_PACKING 8\r\n#define __CRT_UNALIGNED\r\n#define _CONST_RETURN\r\n\r\n#ifndef _TRUNCATE\r\n#define _TRUNCATE ((size_t)-1)\r\n#endif\r\n\r\n#define __CRT_STRINGIZE(_Value) #_Value\r\n#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)\r\n#define __CRT_WIDE(_String) L ## _String\r\n#define _CRT_WIDE(_String) __CRT_WIDE(_String)\r\n\r\n#ifdef _WIN64\r\n#define __stdcall\r\n#define _AMD64_ 1\r\n#define __x86_64 1\r\n#define _M_X64 100 /* Visual Studio */\r\n#define _M_AMD64 100 /* Visual Studio */\r\n#define USE_MINGW_SETJMP_TWO_ARGS\r\n#define mingw_getsp tinyc_getbp\r\n#define __TRY__\r\n#else\r\n#define __stdcall __attribute__((__stdcall__))\r\n#define _X86_ 1\r\n#define _M_IX86 300 /* Visual Studio */\r\n#define WIN32 1\r\n#define _USE_32BIT_TIME_T\r\n#ifdef __arm__\r\n#define __TRY__\r\n#else\r\n#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);\r\n#endif\r\n#endif\r\n\r\n/* in stddef.h */\r\n#define _SIZE_T_DEFINED\r\n#define _SSIZE_T_DEFINED\r\n#define _PTRDIFF_T_DEFINED\r\n#define _WCHAR_T_DEFINED\r\n#define _UINTPTR_T_DEFINED\r\n#define _INTPTR_T_DEFINED\r\n#define _INTEGRAL_MAX_BITS 64\r\n\r\n#ifndef _TIME32_T_DEFINED\r\n#define _TIME32_T_DEFINED\r\ntypedef long __time32_t;\r\n#endif\r\n\r\n#ifndef _TIME64_T_DEFINED\r\n#define _TIME64_T_DEFINED\r\ntypedef long long __time64_t;\r\n#endif\r\n\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\n#ifdef _USE_32BIT_TIME_T\r\ntypedef __time32_t time_t;\r\n#else\r\ntypedef __time64_t time_t;\r\n#endif\r\n#endif\r\n\r\n#ifndef _WCTYPE_T_DEFINED\r\n#define _WCTYPE_T_DEFINED\r\ntypedef wchar_t wctype_t;\r\n#endif\r\n\r\n#ifndef _WINT_T\r\n#define _WINT_T\r\ntypedef short wint_t;\r\n#endif\r\n\r\ntypedef int errno_t;\r\n#define _ERRCODE_DEFINED\r\n\r\ntypedef struct threadlocaleinfostruct *pthreadlocinfo;\r\ntypedef struct threadmbcinfostruct *pthreadmbcinfo;\r\ntypedef struct localeinfo_struct _locale_tstruct,*_locale_t;\r\n\r\n/* for winapi */\r\n#define _ANONYMOUS_UNION\r\n#define _ANONYMOUS_STRUCT\r\n#define DECLSPEC_NORETURN\r\n#define DECLARE_STDCALL_P(type) __stdcall type\r\n#define NOSERVICE 1\r\n#define NOMCX 1\r\n#define NOIME 1\r\n#define __INTRIN_H_\r\n#ifndef DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME1\r\n#  define DUMMYUNIONNAME2\r\n#  define DUMMYUNIONNAME3\r\n#  define DUMMYUNIONNAME4\r\n#  define DUMMYUNIONNAME5\r\n#endif\r\n#ifndef DUMMYSTRUCTNAME\r\n#  define DUMMYSTRUCTNAME\r\n#endif\r\n#ifndef WINVER\r\n# define WINVER 0x0502\r\n#endif\r\n#ifndef _WIN32_WINNT\r\n# define _WIN32_WINNT 0x502\r\n#endif\r\n\r\n#define __C89_NAMELESS\r\n#define __MINGW_EXTENSION\r\n#define WINAPI_FAMILY_PARTITION(X) 1\r\n#define MINGW_HAS_SECURE_API\r\n\r\n#endif /* __MINGW_H */\r\n";

static u64 cc_headers_h_windowsx = (u64)"/* Header windowsx.h */\r\n\r\n#ifndef $windowsx\r\n#define $windowsx 1\r\n\r\n#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))\r\n#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))\r\n\r\n#endif // windowsx\r\n\r\n";

static struct $B6 cc_headers_stdhdrnames = {{
(u64)"assert.h",
(u64)"ctype.h",
(u64)"errno.h",
(u64)"fenv.h",
(u64)"float.h",
(u64)"inttypes.h",
(u64)"stdint.h",
(u64)"limits.h",
(u64)"locale.h",
(u64)"_ansi.h",
(u64)"math.h",
(u64)"setjmp.h",
(u64)"signal.h",
(u64)"stdarg.h",
(u64)"stdbool.h",
(u64)"stddef.h",
(u64)"stdio.h",
(u64)"stdlib.h",
(u64)"_syslist.h",
(u64)"string.h",
(u64)"time.h",
(u64)"utime.h",
(u64)"unistd.h",
(u64)"safelib.h",
(u64)"wchar.h",
(u64)"wctype.h",
(u64)"sys/types.h",
(u64)"sys/stat.h",
(u64)"sys/timeb.h",
(u64)"sys/utime.h",
(u64)"malloc.h",
(u64)"fcntl.h",
(u64)"io.h",
(u64)"direct.h",
(u64)"process.h",
(u64)"memory.h",
(u64)"conio.h",
(u64)"winsock2.h",
(u64)"_mingw.h",
(u64)"windowsx.h"}};

static struct $B6 cc_headers_stdhdrtext = {{
(u64)&cc_headers_h_assert,
(u64)&cc_headers_h_ctype,
(u64)&cc_headers_h_errno,
(u64)&cc_headers_h_fenv,
(u64)&cc_headers_h_float,
(u64)&cc_headers_h_inttypes,
(u64)&cc_headers_h_stdint,
(u64)&cc_headers_h_limits,
(u64)&cc_headers_h_locale,
(u64)&cc_headers_h__ansi,
(u64)&cc_headers_h_math,
(u64)&cc_headers_h_setjmp,
(u64)&cc_headers_h_signal,
(u64)&cc_headers_h_stdarg,
(u64)&cc_headers_h_stdbool,
(u64)&cc_headers_h_stddef,
(u64)&cc_headers_h_stdio,
(u64)&cc_headers_h_stdlib,
(u64)&cc_headers_h__syslist,
(u64)&cc_headers_h_string,
(u64)&cc_headers_h_time,
(u64)&cc_headers_h_utime,
(u64)&cc_headers_h_unistd,
(u64)&cc_headers_h_safelib,
(u64)&cc_headers_h_wchar,
(u64)&cc_headers_h_wctype,
(u64)&cc_headers_h_systypes,
(u64)&cc_headers_h_sysstat,
(u64)&cc_headers_h_systimeb,
(u64)&cc_headers_h_sysutime,
(u64)&cc_headers_h_malloc,
(u64)&cc_headers_h_fcntl,
(u64)&cc_headers_h_io,
(u64)&cc_headers_h_direct,
(u64)&cc_headers_h_process,
(u64)&cc_headers_h_memory,
(u64)&cc_headers_h_conio,
(u64)&cc_headers_h_winsock2,
(u64)&cc_headers_h__mingw,
(u64)&cc_headers_h_windowsx}};

static i64 cc_show_currfileno;
static i64 cc_show_currlineno;
static struct $B3 cc_show_sbuffer;
static u64 cc_show_dest = (u64)&cc_show_sbuffer;

static i64 cc_show_destlinestart;
static struct $B3 cc_show_exprstrvar;
static u64 cc_show_exprstr = (u64)&cc_show_exprstrvar;

static struct $B20 cc_show_getprefix_str;
static struct $B16 cc_show_getdottedname_str;
static struct $B60 cc_show_getlineinfok_str;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B60 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B60 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B77 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B17 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B45 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B77 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B77 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	struct $B77 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B20 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L447;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L446;
L447:
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L449;
	asu64(R1) = p;
	free(asu64(R1));
	goto L448;
L449:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L448:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L454;
	goto L452;
L454:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L455:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L459;
L458:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L459:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L458;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L455;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L461:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L465;
	asi64(R1) = i;
	k = asi64(R1);
	goto L463;
L465:
	i += 1; if (i <= 27) goto L461;
L463:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L468;
L466:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L470;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L469;
L470:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L468;
L469:
	i += 1; if (i <= av_1) goto L466;
L468:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L452:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L473;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L471;
L473:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L475;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L471;
L475:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L477;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L471;
L477:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L471;
L471:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L480;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L480:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L482;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L482:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L478;
L478:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L485;
	asi64(R1) = n;
	goto L484;
L485:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L484:
	goto L483;
L483:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L486;
L486:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L489;
	R1 = 0;
	goto L487;
L489:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L492;
	R1 = 0;
	goto L490;
L492:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L490;
L490:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L495;
	R1 = 0;
	goto L493;
L495:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L493;
L493:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L498;
	asu64(R1) = p;
	goto L496;
L498:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L496;
L496:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L501;
	asu64(R1) = p;
	goto L499;
L501:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L499;
L499:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L503;
L503:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L505;
L505:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L510;
	R1 = 0;
	goto L508;
L510:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L512;
	R1 = 0;
	goto L508;
L512:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L508;
L508:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L515;
	R1 = 0;
	goto L513;
L515:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L513;
L513:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L518;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L516;
L518:
	R1 = 0;
	goto L516;
L516:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L521;
	asu64(R1) = mnoos_os_getstdin();
	handlex = asu64(R1);
L521:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L523;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L524:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L527;
L528:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L527:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L530;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L530:
	goto L524;
L523:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L532;
	goto L519;
L532:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L534;
	goto L519;
L534:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L536;
L535:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L540;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L539;
L540:
	R1 = 1;
	crseen = asu8(R1);
L539:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L536:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L535;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L535;
L541:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L543;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L543;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L543:
L519:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L547;
L545:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L545;
L547:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L551;
L549:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L549;
L551:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L554;
L553:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L553;
	asu64(R1) = s0;
	goto L552;
L552:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L558;
L557:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L557;
	asu64(R1) = s0;
	goto L556;
L556:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B17 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L562;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L563;
	goto L564;
L562:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L561;
L563:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L561;
L564:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L561:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L566;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L567;
	goto L568;
L566:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L567:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L568:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L565:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L560;
L560:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L571;
	R1 = tou64("");
	goto L569;
L571:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L573;
L572:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L576;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L578;
	asi64(R1) = period;
	if (!asi64(R1)) goto L580;
	R1 = tou64(".");
	goto L579;
L580:
	R1 = tou64("");
L579:
	goto L569;
L578:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L569;
L576:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L573:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L572;
	R1 = tou64("");
	goto L569;
L569:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L583;
L582:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L586;
	goto L587;
L586:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L581;
	goto L585;
L587:
L585:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L583:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L582;
	R1 = tou64("");
	goto L581;
L581:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L590;
	asu64(R1) = s;
	goto L588;
L590:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L588;
L588:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L593;
	R1 = tou64("");
	goto L591;
L593:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L595;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L595:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L597;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L597:
	asu64(R1) = f;
	goto L591;
L591:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L600;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L598;
L600:
	asu64(R1) = s;
	goto L598;
L598:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L603;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L601;
L603:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L601;
L601:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L613;
	R1 = 1;
	goto L611;
L613:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L611;
L611:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L616;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L616:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L618;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L614;
L618:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L620;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L620:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L614:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L624;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L624:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L633;
L633:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B78 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L636;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L639;
L637:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L637;
L639:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L636:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B78 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L643;
	goto L641;
L643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L646;
L644:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L644;
L646:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L641:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L649;
	goto L647;
L649:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L651;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L650;
L651:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L650:
L647:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L653:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L655;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L657;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L657:
	goto L654;
L655:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L659;
	R1 = 0;
	goto L652;
L659:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L661;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L663;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L663:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L661:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L665;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L652;
L665:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L667;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L669;
	R2 = 0;
	goto L668;
L669:
	R2 = 1;
L668:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L671;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L671:
	asu64(R1) = q;
	if (!asu64(R1)) goto L673;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L673:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L675;
	R1 = 5;
	goto L674;
L675:
	R1 = 1;
L674:
	goto L652;
L667:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L677;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L679;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L679;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L679:
	goto L676;
L677:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L681;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L680;
L681:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L683;
	R1 = 5;
	goto L682;
L683:
	R1 = 3;
L682:
	goto L652;
L680:
L676:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L685;
	R1 = 5;
	goto L684;
L685:
	R1 = 2;
L684:
	goto L652;
L652:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L687:
L688:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L692;
	goto L693;
L691:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L690;
L692:
	R1 = 0;
	goto L686;
	goto L690;
L693:
	goto L689;
L690:
	goto L688;
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L695;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L695;
	goto L696;
L695:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L697:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L699;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L700;
	goto L701;
L699:
	goto L687;
	goto L697;
L700:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L686;
	goto L697;
L701:
	goto L697;
	goto L694;
L696:
L694:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L703;
	goto L704;
L703:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L705:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L709;
	goto L710;
L708:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L707;
L709:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L712;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L712:
	goto L706;
	goto L707;
L710:
L707:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L705;
L706:
	goto L702;
L704:
	asu64(R1) = p;
	pstart = asu64(R1);
L713:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L717;
	goto L718;
L716:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L714;
	goto L715;
L717:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L714;
	goto L715;
L718:
L715:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L713;
L714:
L702:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L720;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L720:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L686;
L686:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L724;
L722:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L722;
L724:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L725;
L725:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L726;
L726:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L729;
	R1 = -1;
	goto L728;
L729:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L730;
	R1 = 1;
	goto L728;
L730:
	R1 = 0;
L728:
	goto L727;
L727:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L733;
	R1 = -1;
	goto L732;
L733:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L734;
	R1 = 1;
	goto L732;
L734:
	R1 = 0;
L732:
	goto L731;
L731:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L735;
L735:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L738;
	R1 = -1;
	goto L737;
L738:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L739;
	R1 = 1;
	goto L737;
L739:
	R1 = 0;
L737:
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L740;
L740:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L743;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L742;
L743:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L742:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L744;
L744:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L745;
L745:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L749;
	R1 = 0;
	goto L747;
L749:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L751:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L751;
	asr64(R1) = x;
	goto L750;
L750:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L754;
L754:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L755;
L755:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L759;
L757:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L761;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L756;
L761:
	i += 1; if (i <= av_1) goto L757;
L759:
	R1 = 0;
	goto L756;
L756:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L764;
	asi64(R1) = n;
	goto L762;
L764:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L762;
L762:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L767;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L767:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L769;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L769:
	asu64(R1) = p;
	goto L765;
L765:
	return asu64(R1);
}

static void mnoos_os_init() {
	return;
}

static i64 mnoos_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1; 
	R1 = 0;
	goto L771;
L771:
	return asi64(R1);
}

static i64 mnoos_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1; 
	R1 = 0;
	goto L772;
L772:
	return asi64(R1);
}

static i64 mnoos_os_getch() {
    u64 R1; 
	R1 = 0;
	goto L773;
L773:
	return asi64(R1);
}

static i64 mnoos_os_kbhit() {
    u64 R1; 
	R1 = 0;
	goto L774;
L774:
	return asi64(R1);
}

static u64 mnoos_os_getdllinst(u64 name) {
    u64 R1; 
	R1 = 0;
	goto L775;
L775:
	return asu64(R1);
}

static u64 mnoos_os_getdllprocaddr(i64 hinst, u64 name) {
    u64 R1; 
	R1 = 0;
	goto L776;
L776:
	return asu64(R1);
}

static void mnoos_os_initwindows() {
	return;
}

static void mnoos_os_gxregisterclass(u64 classname) {
	return;
}

static void mnoos_os_setmesshandler(u64 addr) {
	return;
}

static i64 mnoos_os_getchx() {
    u64 R1; 
	R1 = 27;
	goto L780;
L780:
	return asi64(R1);
}

static u64 mnoos_os_getos() {
    u64 R1; 
	R1 = tou64("NOOS");
	goto L781;
L781:
	return asu64(R1);
}

static i64 mnoos_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L782;
L782:
	return asi64(R1);
}

static i64 mnoos_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L783;
L783:
	return asi64(R1);
}

static void mnoos_os_sleep(i64 a) {
	return;
}

static u64 mnoos_os_getstdin() {
    u64 R1, R2; 
	R1 = tou64("rb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L785;
L785:
	return asu64(R1);
}

static u64 mnoos_os_getstdout() {
    u64 R1, R2; 
	R1 = tou64("wb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L786;
L786:
	return asu64(R1);
}

static u64 mnoos_os_gethostname() {
    u64 R1; 
	R1 = tou64("?");
	goto L787;
L787:
	return asu64(R1);
}

static u64 mnoos_os_getmpath() {
    u64 R1; 
	R1 = tou64("C:\\m\\\"");
	goto L788;
L788:
	return asu64(R1);
}

static i64 mnoos_os_clock() {
    u64 R1; 
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L789;
L789:
	return asi64(R1);
}

static i64 mnoos_os_ticks() {
    u64 R1; 
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L790;
L790:
	return asi64(R1);
}

static i64 mnoos_os_iswindows() {
    u64 R1; 
	R1 = 1;
	goto L791;
L791:
	return asi64(R1);
}

static void mnoos_os_getsystime(u64 $1) {
	return;
}

static void mnoos_os_peek() {
	return;
}

static u64 mnoos_os_allocexecmem(i64 n) {
    u64 R1; 
	R1 = 0;
	goto L794;
L794:
	return asu64(R1);
}

static i64 mnoos_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1; 
	R1 = 0;
	goto L795;
L795:
	return asi64(R1);
}

static i64 mnoos_os_hpcounter() {
    u64 R1; 
	i64 a;
	R1 = 0;
	goto L796;
L796:
	return asi64(R1);
}

static i64 mnoos_os_hpfreq() {
    u64 R1; 
	i64 a;
	R1 = 0;
	goto L797;
L797:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L800;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L799;
L800:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L799:
	goto L798;
L798:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L803;
	R4 = 0;
	goto L802;
L803:
	R4 = 73;
L802:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L801;
L801:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L808;
	case 1: goto L809;
	case 2: goto L810;
	case 3: goto L811;
	case 4: goto L812;
	case 5: goto L813;
	case 6: goto L814;
	case 7: goto L807;
	case 8: goto L815;
	case 9: goto L816;
	case 10: goto L817;
	case 11: goto L818;
	case 12: goto L819;
	default: goto L807;
    };
// SWITCH
L808:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F1)R1)();
	goto L804;
	goto L805;
L809:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F2)R2)(asi64(R1));
	goto L804;
	goto L805;
L810:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F3)R3)(asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L811:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F4)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L812:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F5)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L813:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F6)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L814:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F7)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L815:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F8)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L816:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F9)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L817:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F10)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L818:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F11)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L819:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F12)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L807:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L805:
	R1 = 0;
	goto L804;
L804:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L822;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L823;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L824;
	goto L825;
L822:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F13)R1)();
	R1 = toi64(asr64(R1));
	goto L820;
	goto L821;
L823:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F14)R2)(asi64(R1));
	x = asr64(R1);
	goto L821;
L824:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F15)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L821;
L825:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L821:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L820;
L820:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

static u64 pc_api_pcl_start(u64 name, i64 nunits) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_pcldone;
	if (!asu8(R1)) goto L829;
	R1 = tou64("PCL start?");
	pc_api_pclerror(asu64(R1));
L829:
	asu64(R1) = name;
	if (!asu64(R1)) goto L831;
	R1 = 9;
	asu64(R2) = name;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	pc_decls_currprog = asu64(R1);
L831:
	asi64(R1) = pc_api_initpcalloc;
	pc_api_pcalloc = asi64(R1);
	asi64(R1) = nunits;
	if (!asi64(R1)) goto L833;
	asi64(R1) = nunits;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nunits = asi64(R1);
	goto L835;
L834:
	R1 = 2;
	R2 = (u64)&pc_api_pcalloc;
	*toi64p(R2) *= asi64(R1);
L835:
	asi64(R1) = pc_api_pcalloc;
	asi64(R2) = nunits;
	if (asi64(R1) < asi64(R2)) goto L834;
L833:
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pc_api_pcstart = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	asi64(R2) = pc_api_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	R1 = 0;
	pc_api_pcfixed = asu8(R1);
	R1 = 0;
	pc_api_pcseqno = asi64(R1);
	R1 = 0;
	pc_api_pcneedfntable = asi64(R1);
	R1 = 0;
	pc_api_mlabelno = asi64(R1);
	asu64(R1) = pc_decls_currprog;
	goto L827;
L827:
	return asu64(R1);
}

static void pc_api_pcl_end() {
    u64 R1, R2; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) < asu64(R2)) goto L839;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L839;
	R1 = 0;
	R2 = 136;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L839:
	R1 = 1;
	pc_decls_pcldone = asu8(R1);
	return;
}

static u64 pc_api_pcl_writepcl(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writeallpcl();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L842;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L844;
	msysc_m$print_startcon();
	R1 = tou64("Writing PCL");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L844:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L841;
L842:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L841:
	goto L840;
L840:
	return asu64(R1);
}

static u64 pc_api_pcl_writepst(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writepst();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L847;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L849;
	msysc_m$print_startcon();
	R1 = tou64("Writing PST");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L849:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L846;
L847:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L846:
	goto L845;
L845:
	return asu64(R1);
}

static void pc_api_pcl_genmcl() {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	return;
}

static void pc_api_pcl_genss(i64 obj) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_dummy_genss(asi64(R1));
	return;
}

static u64 pc_api_pcl_writess(u64 filename, i64 obj) {
    u64 R1, R2; 
	u64 ssstr;
	u64 f;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = obj;
	asi64(R1) = !asi64(R1);
	asu64(R1) = mc_writess_dummy_writessdata(asi64(R1));
	ssstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L854;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = ssstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = ssstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L853;
L854:
	asu64(R1) = ssstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L853:
	goto L852;
L852:
	return asu64(R1);
}

static u64 pc_api_pcl_writeasm(u64 filename, i64 atype) {
    u64 R1, R2; 
	u64 asmstr;
	u64 f;
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L857;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
L857:
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asu64(R1) = mc_writegas_getassemstr();
	asmstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L859;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L861;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L861:
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = asmstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = asmstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L858;
L859:
	asu64(R1) = asmstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L858:
	goto L855;
L855:
	return asu64(R1);
}

static void pc_api_pcl_writeobj(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 1;
	mc_genss_dummy_genss(asi64(R1));
	R1 = 0;
	pc_api_phighmem = asu8(R1);
	msysc_m$print_startcon();
	R1 = tou64("PHIGHMEM=");
	msysc_m$print_str_nf(asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mnoos_os_clock();
	tt = asi64(R1);
	asu64(R1) = filename;
	mc_writeobj_dummy_writecoff(asu64(R1));
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_objtime = asi64(R1);
	return;
}

static void pc_api_pcl_writedll(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = mnoos_os_clock();
	tt = asi64(R1);
	R1 = 1;
	asu64(R2) = filename;
	mc_writeexe_dummy_writeexe(asu64(R2), asi64(R1));
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writeexe(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = mnoos_os_clock();
	tt = asi64(R1);
	R1 = 0;
	asu64(R2) = filename;
	mc_writeexe_dummy_writeexe(asu64(R2), asi64(R1));
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writemx(u64 filename) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asu64(R1) = filename;
	mx_run_dummy_writemcx(asu64(R1));
	return;
}

static void pc_api_pcl_exec() {
    u64 R1, R2; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	R2 = tou64("dummy");
	mx_run_dummy_runlibfile(asu64(R2), asi64(R1));
	return;
}

static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames) {
    u64 R1, R2; 
	asi64(R1) = highmem;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L869;
	asi64(R1) = highmem;
	pc_api_phighmem = asu8(R1);
L869:
	asi64(R1) = verbose;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L871;
	asi64(R1) = verbose;
	pc_decls_pverbose = asu8(R1);
L871:
	asi64(R1) = shortnames;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L873;
	asi64(R1) = shortnames;
	pc_api_fpshortnames = asu8(R1);
L873:
	return;
}

static void pc_api_extendpclblock() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	i64 lengthused;
	u64 newpcstart;
	asi64(R1) = pc_api_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	lengthused = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	asi64(R1) = lengthused;
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pc_api_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newpcalloc;
	asi64(R2) = lengthused;
	asi64(R1) -= asi64(R2);
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newpcstart;
	asi64(R3) = lengthused;
	R2 += (i64)R3*32;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = pc_api_pccurr;
	asu64(R3) = pc_api_pcstart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 32;
	R1 += (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	pc_api_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	pc_api_pcalloc = asi64(R1);
	return;
}

static u64 pc_api_newpcl() {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcend;
	if (asu64(R1) < asu64(R2)) goto L877;
	pc_api_extendpclblock();
L877:
	R1 = (u64)&pc_api_pccurr;
	(*tou64p(R1)) += 32;
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = pc_api_pccurr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc_api_pclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_decls_npcl;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc_api_pccurr;
	goto L875;
L875:
	return asu64(R1);
}

static void pc_api_pc_gen(i64 opcode, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L880;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L880:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genx(i64 opcode, i64 x, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L884;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L884:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L887;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L887:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L890;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L890:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cond;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 pc_api_genint(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L891;
L891:
	return asu64(R1);
}

static u64 pc_api_genreal(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L894;
	R1 = 5;
	goto L893;
L894:
	R1 = 6;
L893:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L892;
L892:
	return asu64(R1);
}

static u64 pc_api_genrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L897;
	R1 = 10;
	goto L896;
L897:
	R1 = 11;
L896:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L895;
L895:
	return asu64(R1);
}

static u64 pc_api_genstring(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L898;
L898:
	return asu64(R1);
}

static u64 pc_api_genpcstrimm(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L899;
L899:
	return asu64(R1);
}

static u64 pc_api_genlabel(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L900;
L900:
	return asu64(R1);
}

static u64 pc_api_genmem(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L901;
L901:
	return asu64(R1);
}

static u64 pc_api_genmemaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L902;
L902:
	return asu64(R1);
}

static u64 pc_api_gendata(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 12;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L903;
L903:
	return asu64(R1);
}

static void pc_api_gencomment(u64 s) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L907;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L906;
L907:
	goto L904;
L906:
	asu64(R1) = s;
	asu64(R1) = pc_api_genpcstrimm(asu64(R1));
	R2 = 135;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L904:
	return;
}

static u64 pc_api_genname(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L908;
L908:
	return asu64(R1);
}

static u64 pc_api_gennameaddr(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L909;
L909:
	return asu64(R1);
}

static u64 pc_api_genassem(u64 code) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = code;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 9;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L910;
L910:
	return asu64(R1);
}

static u64 pc_api_strpmode(i64 mode, i64 size) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L913;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L914;
	goto L915;
L913:
	R1 = tou64("mem:");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = size;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_strpmode_str;
	goto L912;
L914:
	R1 = tou64("---");
	goto L912;
L915:
	R1 = (u64)&pc_tables_pstdnames;
	asi64(R2) = mode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L912:
	goto L911;
L911:
	return asu64(R1);
}

static void pc_api_pc_setmode(i64 m, i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L918;
	asi64(R1) = size;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L917;
L918:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L917:
	R1 = (u64)&pc_tables_pclhastype;
	asu64(R2) = pc_api_pccurr;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L920;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L920:
	return;
}

static void pc_api_pc_setmode2(i64 m) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void pc_api_pc_setxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setscaleoff(i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = scale;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_addoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	return;
}

static void pc_api_pc_setincr(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnargs(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnvariadics(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setalign(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_perror(u64 mess) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = mess;
	pc_api_perror_s(asu64(R2), asu64(R1));
	return;
}

static void pc_api_perror_s(u64 mess, u64 param) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = param;
	if (!asu64(R1)) goto L933;
	msysc_m$print_startcon();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L933:
	R1 = 1;
	exit(R1);
	return;
}

static u64 pc_api_getbasename(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L936;
L935:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L936:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) <= asu64(R2)) goto L938;
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L935;
L938:
	asu64(R1) = t;
	goto L934;
L934:
	return asu64(R1);
}

static void pc_api_pclerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addsymbol(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_psymboltable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L942;
	asu64(R1) = d;
	R2 = R1;
	pc_decls_psymboltablex = asu64(R2);
	pc_decls_psymboltable = asu64(R1);
	goto L941;
L942:
	asu64(R1) = d;
	asu64(R2) = pc_decls_psymboltablex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	pc_decls_psymboltablex = asu64(R1);
L941:
	return;
}

static u64 pc_api_pc_makesymbol(u64 s, i64 id) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = (u64)&pc_decls_npst;
	(*toi64p(R1)) += 1;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = id;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L945;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L946;
	goto L947;
L945:
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L944;
L946:
	R1 = 1;
	asu64(R2) = d;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	id = asi64(R1);
	goto L944;
L947:
L944:
	asi64(R1) = id;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L950;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L949;
L950:
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L948;
L949:
	asi64(R1) = id;
	if (!asi64(R1)) goto L951;
	asu64(R1) = d;
	pc_api_pc_addsymbol(asu64(R1));
L951:
L948:
	asu64(R1) = d;
	goto L943;
L943:
	return asu64(R1);
}

static u64 pc_api_getfullname(u64 d, i64 backtick) {
    u64 R1, R2, R3; 
	i64 n;
	u64 e;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	R2 = (u64)&pc_api_getfullname_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L954;
	R1 = tou64("`");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L954:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L956;
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L958;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L957;
L958:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L957:
	R1 = (u64)&pc_api_getfullname_str;
	goto L952;
L956:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L961;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L960;
L961:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_getfullname_str;
	goto L952;
L960:
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L963;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L962;
L963:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L962:
	goto L952;
L952:
	return asu64(R1);
}

static void pc_api_pcerrorstop(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addplib(u64 name) {
    u64 R1, R2, R3; 
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L967;
	R1 = tou64("Too many libs");
	pc_api_perror(asu64(R1));
L967:
	R1 = tou64("");
	asu64(R2) = name;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&pc_decls_plibfiles;
	R3 = (u64)&pc_decls_nplibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L970;
	R1 = tou64("Nested proc");
	pc_api_pclerror(asu64(R1));
L970:
	asu64(R1) = d;
	asu64(R1) = pc_api_genmem(asu64(R1));
	asi64(R2) = threaded;
	if (!asi64(R2)) goto L972;
	R2 = 121;
	goto L971;
L972:
	R2 = 120;
L971:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L974;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L974:
	R1 = 0;
	asi64(R2) = mode;
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L976;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl proc:");
	asu64(R1) = pc_api_addstr(asu64(R2), asu64(R1));
	pc_api_pclerror(asu64(R1));
L976:
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L978;
	asi64(R1) = isentry;
	if (!asi64(R1)) goto L978;
	asu64(R1) = d;
	pc_decls_entryproc = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 83;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L978:
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_setimport(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_addparam(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L982;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L982:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L984;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L983;
L984:
	goto L986;
L985:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L986:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L985;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L983:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L989;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L989:
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	return;
}

static void pc_api_pc_addlocal(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L992;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L992:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L994;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L993;
L994:
	goto L996;
L995:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L996:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L995;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L993:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L999;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L999:
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	return;
}

static void pc_api_pc_endproc() {
    u64 R1, R2; 
	asu64(R1) = pc_decls_currfunc;
	if (asu64(R1)) goto L1002;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1002:
	R1 = 0;
	R2 = 122;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_decls_currfunc = asu64(R1);
	return;
}

static u64 pc_api_addstr(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = t;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_addstr_str;
	goto L1003;
L1003:
	return asu64(R1);
}

static void pc_api_merror(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1006;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F16)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L1005;
L1006:
	R1 = 0;
	lineno = asi64(R1);
	R1 = tou64("?");
	filename = asu64(R1);
L1005:
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1008;
	msysc_m$print_startcon();
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1008:
	msysc_m$print_startcon();
	R1 = tou64("MCL Error: # (#) on Line: # in #, PCL:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pc_decls_ppseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	asu64(R2) = filename;
	pc_api_pcerrorstop(asu64(R2), asi64(R1));
	return;
}

static u64 pc_api_pc_duplpst(u64 d) {
    u64 R1, R2, R3; struct $B36 R1_B36; 
	u64 e;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	(R1_B36) = *(struct $B36*)(R1);
	asu64(R2) = e;
	*(struct $B36*)(R2) = (R1_B36);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = e;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L1009;
L1009:
	return asu64(R1);
}

static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip) {
    u64 R1; 
	asi64(R1) = cmdskip;
	pc_decls_pcmdskip = asi64(R1);
	return;
}

static i64 pc_api_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	asu64(R1) = t;
	t0 = asu64(R1);
	goto L1013;
L1012:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1016;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1017;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1018;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1019;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1020;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1021;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1021;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1021;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1021;
	goto L1022;
L1016:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1015;
L1017:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1015;
L1018:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1015;
L1019:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1015;
L1020:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1015;
L1021:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1015;
L1022:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1024;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1024;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1023;
L1024:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 120;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2h");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1023:
L1015:
L1013:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L1012;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1011;
L1011:
	return asi64(R1);
}

static void pc_diags_strpcl(u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	i64 opcode;
	i64 n;
	i64 x;
	i64 y;
	u64 d;
	u64 e;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asi64(R1) = opcode;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1027;
	R2 = 128;
	if (asi64(R1) == asi64(R2)) goto L1028;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1029;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1030;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1030;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1031;
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L1032;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1033;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1034;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1034;
	goto L1035;
L1027:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	pc_diags_strlabel(asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1037;
	R1 = tou64(" NOT USED");
	pc_diags_psstr(asu64(R1));
L1037:
	goto L1025;
	goto L1026;
L1028:
	R1 = tou64("! ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
	goto L1025;
	goto L1026;
L1029:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L1039;
	R1 = tou64("!");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	goto L1038;
L1039:
	R1 = tou64("! - - -");
	pc_diags_psstr(asu64(R1));
L1038:
	goto L1025;
	goto L1026;
L1030:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = opcode;
	R2 = 121;
	if (asi64(R1) != asi64(R2)) goto L1041;
	R1 = tou64("tcproc");
	pc_diags_psstr(asu64(R1));
	goto L1040;
L1041:
	R1 = tou64("proc");
	pc_diags_psstr(asu64(R1));
L1040:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	pc_diags_psname(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1043;
	R1 = tou64("::");
	goto L1042;
L1043:
	R1 = tou64(":");
L1042:
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1045;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1045:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1049;
L1046:
	R1 = tou64("    param    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1049:
	asu64(R1) = e;
	if (asu64(R1)) goto L1046;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1053;
L1050:
	R1 = tou64("    local    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1053:
	asu64(R1) = e;
	if (asu64(R1)) goto L1050;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1055;
	R1 = tou64("    rettype  ");
	pc_diags_psstr(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
L1055:
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1057;
	R1 = tou64("    variadic");
	pc_diags_psstrline(asu64(R1));
L1057:
	goto L1025;
	goto L1026;
L1031:
	R1 = tou64("endproc");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	goto L1025;
	goto L1026;
L1032:
	R1 = tou64("endprog");
	pc_diags_psstr(asu64(R1));
	goto L1025;
	goto L1026;
L1033:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1059;
	asu64(R1) = p;
	pc_diags_psdata(asu64(R1));
	goto L1025;
L1059:
	goto L1026;
L1034:
	goto L1060;
	goto L1026;
L1035:
L1026:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
// pc_diags.strpcl.skiptab:
L1060:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1062;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L1063;
	goto L1064;
L1062:
	R1 = tou64("jump");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1061;
L1063:
	R1 = tou64("set");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1061;
L1064:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L1061:
	R1 = 32;
	R2 = 9;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1066;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pclhastype;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1068;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1068:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1066:
	R1 = 32;
	R2 = 4;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_pclextra;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L1070;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	x = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L1073;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1072;
L1073:
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1072:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1075;
	asi64(R1) = y;
	if (!asi64(R1)) goto L1075;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = y;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1075:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1070:
	R1 = 32;
	R2 = 5;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1077;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	pc_diags_psstr(asu64(R1));
L1077:
	R1 = 40;
	pc_diags_pstabto(asi64(R1));
L1025:
	return;
}

static u64 pc_diags_stropnd(u64 p) {
    u64 R1, R2, R3; 
	i64 length;
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1080;
	R1 = tou64("");
	goto L1078;
L1080:
	R1 = 0;
	R2 = (u64)&pc_diags_stropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1082;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1083;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1083;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1083;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1083;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1084;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1085;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1086;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1087;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1088;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1089;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1090;
	goto L1091;
L1082:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1078;
	goto L1081;
L1083:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L1093;
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("infinity");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L1092;
L1093:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e16.16");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L1092:
	goto L1081;
L1084:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	length = asi64(R2);
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L1095;
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_diags_stropnd_str;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1094;
L1095:
	asu64(R1) = pc_diags_stropnd_longstring;
	if (!asu64(R1)) goto L1097;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_diags_stropnd_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1097:
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	pc_api_longstringlen = asi64(R1);
	asi64(R1) = pc_api_longstringlen;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_diags_stropnd_longstring = asu64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	length = asi64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+2)) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	goto L1078;
L1094:
	goto L1081;
L1085:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1100;
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L1099;
L1100:
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1102;
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1102:
L1099:
	goto L1081;
L1086:
	R1 = tou64("&");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L1085;
	goto L1081;
L1087:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L1081;
L1088:
	R1 = tou64("");
	goto L1078;
	goto L1081;
L1089:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1078;
	goto L1081;
L1090:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<Data * # (#)>");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L1081;
L1091:
	msysc_m$print_startcon();
	R1 = tou64("---------");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<PCLOPND?>");
	goto L1078;
L1081:
	R1 = (u64)&pc_diags_stropnd_str;
	goto L1078;
L1078:
	return asu64(R1);
}

static u64 pc_diags_strpclstr(u64 p, i64 buffsize) {
    u64 R1, R2; 
	asu64(R1) = pc_diags_dest;
	mlib_gs_free(asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	pc_diags_destlinestart = asi64(R1);
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	R1 = 0;
	asu64(R2) = pc_diags_dest;
	mlib_gs_char(asu64(R2), asi64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = buffsize;
	if (asi64(R1) < asi64(R2)) goto L1105;
	R1 = tou64("<BIGSTR>");
	goto L1103;
L1105:
	asu64(R1) = pc_diags_dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1103;
L1103:
	return asu64(R1);
}

static void pc_diags_writepcl(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1108;
	goto L1109;
L1108:
	goto L1107;
L1109:
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
L1107:
	return;
}

static u64 pc_diags_writeallpcl() {
    u64 R1, R2; 
	u64 p;
	u64 d;
	i64 i;
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = tou64("!PROC PCL");
	asu64(R2) = pc_diags_dest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1113;
L1111:
	R1 = tou64("addlib    \"");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("\"");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	i += 1; if (i <= pc_decls_nplibfiles) goto L1111;
L1113:
	asi64(R1) = pc_decls_nplibfiles;
	if (!asi64(R1)) goto L1115;
	pc_diags_psline();
L1115:
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1119;
L1116:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1121;
	R1 = tou64("extproc    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1123;
	R1 = tou64(" 1");
	pc_diags_psstr(asu64(R1));
L1123:
	pc_diags_psline();
L1121:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1119:
	asu64(R1) = d;
	if (asu64(R1)) goto L1116;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1125;
L1124:
	asu64(R1) = p;
	pc_diags_writepcl(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1125:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1124;
	pc_diags_psline();
	asu64(R1) = pc_api_longstring;
	if (!asu64(R1)) goto L1128;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_api_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1128:
	asu64(R1) = pc_diags_dest;
	goto L1110;
L1110:
	return asu64(R1);
}

static void pc_diags_psstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psstrline(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void pc_diags_psline() {
    u64 R1, R2; 
	R1 = tou64("\n");
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psint(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psname(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_pstabto(i64 n) {
    u64 R1, R2; 
	i64 col;
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = pc_diags_destlinestart;
	asi64(R1) -= asi64(R2);
	col = asi64(R1);
	goto L1136;
L1135:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&col;
	(*toi64p(R1)) += 1;
L1136:
	asi64(R1) = n;
	asi64(R2) = col;
	if (asi64(R1) > asi64(R2)) goto L1135;
	return;
}

static void pc_diags_strlabel(i64 labelno, i64 colon) {
    u64 R1; 
	R1 = tou64("#");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = labelno;
	pc_diags_psint(asi64(R1));
	asi64(R1) = colon;
	if (!asi64(R1)) goto L1140;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1140:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	return;
}

static void pc_diags_psopnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	pc_diags_psstr(asu64(R1));
	return;
}

static void pc_diags_psdata(u64 p) {
    u64 R1, R2; 
	i64 n;
	i64 m;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1144;
	goto L1142;
L1144:
	goto L1146;
L1145:
	asi64(R1) = n;
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L1149;
	R1 = 20;
	m = asi64(R1);
L1149:
	asi64(R1) = m;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = tou64("    data mem:");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	pc_diags_psint(asi64(R1));
	R1 = tou64("  ");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L1151;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
L1151:
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1154;
L1152:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L1152;
L1154:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1156;
	pc_diags_psline();
L1156:
L1146:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1145;
L1142:
	return;
}

static u64 pc_diags_writepst() {
    u64 R1, R2; 
	u8 localfile;
	i64 i;
	i64 j;
	u64 d;
	u64 e;
	R1 = 0;
	localfile = asu8(R1);
	R1 = 0;
	i = asi64(R1);
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("PROC PC Symbol table");
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1161;
L1158:
	R1 = tou64("H");
	asu64(R2) = d;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("25jl");
	asu64(R2) = d;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1164;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1163;
L1164:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1168;
L1165:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1168:
	asu64(R1) = e;
	if (asu64(R1)) goto L1165;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1172;
L1169:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1172:
	asu64(R1) = e;
	if (asu64(R1)) goto L1169;
L1163:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1161:
	asu64(R1) = d;
	if (asu64(R1)) goto L1158;
	pc_diags_psline();
	asu64(R1) = pc_diags_dest;
	goto L1157;
L1157:
	return asu64(R1);
}

static void pc_diags_writepsymbol(u64 d, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u8 localfile;
	struct $B16 str;
	i64 av_1;
	R1 = 0;
	localfile = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("4");
	asu64(R2) = d;
	R3 = 120;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = (u64)&pc_tables_idnames;
	asu64(R2) = d;
	R3 = 72;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	R1 = 8;
	R2 = (u64)&pc_tables_idnames;
	asu64(R3) = d;
	R4 = 72;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1176;
L1174:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	if (--asi64(av_1)) goto L1174;
L1176:
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmt;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1178;
	R1 = tou64(" Pm:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" Loc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	pc_diags_psint(asi64(R1));
L1178:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1180;
	R1 = tou64(" Exp");
	pc_diags_psstr(asu64(R1));
L1180:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1182;
	R1 = tou64(" Imp");
	pc_diags_psstr(asu64(R1));
L1182:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1184;
	R1 = tou64(" Var:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
L1184:
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1186;
	R1 = tou64(" TC");
	pc_diags_psstr(asu64(R1));
L1186:
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1188;
	R1 = tou64(" Dot");
	pc_diags_psstr(asu64(R1));
L1188:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1190;
	R1 = tou64(" ENTRY PT");
	pc_diags_psstr(asu64(R1));
L1190:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1192;
	R1 = tou64(" .PCADDR =");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
L1192:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1194;
	R1 = tou64(" (");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1194:
	R1 = 0;
	if (!asu16(R1)) goto L1196;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1196;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1196;
	R1 = tou64(" (Proc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(") (D:");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1196:
	R1 = 0;
	if (!asu16(R1)) goto L1198;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1198;
	asu64(R1) = d;
	R2 = 104;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1198;
	R1 = tou64(" Has statics");
	pc_diags_psstr(asu64(R1));
L1198:
	pc_diags_psline();
	return;
}

static void pc_diags_showprocinfo(u64 d) {
    u64 R1, R2; 
	struct $B16 str;
	u64 p;
	u64 e;
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1201;
	goto L1199;
L1201:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("PROC INFO FOR: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Params:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Locals:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Leaf:     #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Nmaxargs: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Assem:    #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  MCLdone:  #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Hasblocks:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1205;
L1202:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Pm: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1205:
	asu64(R1) = e;
	if (asu64(R1)) goto L1202;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1209;
L1206:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Loc: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1209:
	asu64(R1) = e;
	if (asu64(R1)) goto L1206;
	pc_diags_psline();
L1199:
	return;
}

static void pc_reduce_pcl_reducetest() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 nn;
	i64 seqno;
	i64 lab;
	i64 lab2;
	i64 nargs;
	u64 pc;
	u64 newpc;
	u64 pcnext;
	u64 pcnext2;
	u64 pcproc;
	u64 labelmap;
	u64 pdef;
	struct $B16 callstack;
	i64 ncall;
	i64 nprocs;
	i64 nleaf;
	i64 nallparams;
	i64 nalllocals;
	i64 offset;
	i64 av_1;
	R1 = 0;
	nprocs = asi64(R1);
	R1 = 0;
	nleaf = asi64(R1);
	R1 = 0;
	nallparams = asi64(R1);
	R1 = 0;
	nalllocals = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nn = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	goto L1214;
L1211:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1216;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1217;
	goto L1218;
L1216:
	goto L1215;
L1217:
	asu64(R1) = pc_api_icheckasmlabel;
	if (!asu64(R1)) goto L1220;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_icheckasmlabel;
	asi64(R1) = ((F17)R2)(asu64(R1));
	lab = asi64(R1);
	asi64(R1) = lab;
	if (!asi64(R1)) goto L1222;
	asu64(R1) = labelmap;
	asi64(R2) = lab;
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1222:
L1220:
	goto L1215;
L1218:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1224;
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1224:
L1215:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1214:
	asu64(R1) = pc;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1211;
// pc_reduce.pcl_reducetest.skip:
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	newpc = asu64(R1);
	R1 = 0;
	seqno = asi64(R1);
	asi64(R1) = nn;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1228;
L1226:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcnext = asu64(R1);
	R1 = (u64)&pc_tables_pclargs;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	nargs = asi64(R2);
	if (!asi64(R1)) goto L1230;
	asi64(R1) = nargs;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L1232;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	nargs = asi64(R1);
L1232:
	asu64(R1) = pc_decls_pinfo;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = nargs;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1230:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1234;
	asu64(R1) = pc_decls_pinfo;
	if (!asu64(R1)) goto L1234;
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1234;
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1234:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1236;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1237;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1238;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1238;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L1239;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L1239;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1239;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1239;
	R2 = 131;
	if (asi64(R1) == asi64(R2)) goto L1240;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1241;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1242;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1243;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1243;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L1244;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L1245;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1246;
	goto L1247;
L1236:
	goto L1235;
L1237:
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu16(R1) = *tou16p(((i64)R1+(i64)R2*2-2));
	if (!asu16(R1)) goto L1249;
	goto L1247;
	goto L1247;
L1249:
	goto L1235;
L1238:
	R1 = (u64)&nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdef = asu64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pdef;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	asu64(R2) = pdef;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&nallparams;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&nalllocals;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	ncall = asi64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcproc = asu64(R1);
	goto L1247;
	goto L1247;
	goto L1235;
L1239:
	R1 = 0;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&ncall;
	(*toi64p(R1)) -=1;
	goto L1247;
	goto L1247;
	goto L1235;
L1240:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = newpc;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = (u64)&callstack;
	R3 = (u64)&ncall;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1235;
L1241:
	asu64(R1) = pc_decls_pinfo;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1251;
	R1 = (u64)&nleaf;
	(*toi64p(R1)) += 1;
L1251:
	R1 = 0;
	pc_decls_pinfo = asu64(R1);
	goto L1247;
	goto L1247;
	goto L1235;
L1242:
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1247;
	goto L1247;
	goto L1235;
L1243:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1253;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1253;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = newpc;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1255;
	R1 = 3;
	goto L1254;
L1255:
	R1 = 6;
L1254:
	asu64(R2) = newpc;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1252;
L1253:
	goto L1247;
	goto L1247;
L1252:
	goto L1235;
L1244:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) != asi64(R2)) goto L1257;
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L1257;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1256;
L1257:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1259;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1258;
L1259:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1256;
L1258:
	goto L1247;
	goto L1247;
L1256:
	goto L1235;
L1245:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1262;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1262;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1261;
L1262:
	asu64(R1) = newpc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) != asi64(R2)) goto L1261;
	goto L1260;
L1261:
	goto L1247;
	goto L1247;
L1260:
	goto L1235;
L1246:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1264;
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = newpc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1265;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1265;
	R1 = 1;
	goto L1266;
L1265:
	R1 = 0;
L1266:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L1264;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pcnext;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = pcnext;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = newpc;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1263;
L1264:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1267;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1263;
L1267:
	goto L1247;
	goto L1247;
L1263:
	goto L1235;
L1247:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = newpc;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1269;
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1272;
	asu64(R1) = newpc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1271;
L1272:
	R1 = 1;
	asu64(R2) = newpc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1271:
L1269:
L1235:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	if (--asi64(av_1)) goto L1226;
L1228:
	asu64(R1) = newpc;
	pc_api_pccurr = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void pc_run_dummy_pcl_runpcl() {
	return;
}

static void mc_genmcl_genmcl(u64 dummy) {
    u64 R1, R2, R3; 
	i64 tt;
	i64 i;
	asu8(R1) = pc_decls_mcldone;
	if (!asu8(R1)) goto L1276;
	goto L1274;
L1276:
	R1 = 0;
	if (asu16(R1)) goto L1279;
	R1 = 0;
	if (!asu16(R1)) goto L1278;
L1279:
	msysc_m$print_startcon();
	R1 = tou64("********* ASM HAS PCL INFO *********");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1278:
	asi64(R1) = mnoos_os_clock();
	tt = asi64(R1);
	mc_genmcl_inithandlers();
	R1 = 0;
	mc_libmcl_mclinit(asi64(R1));
	asu64(R1) = pc_api_pcstart;
	mc_decls_currpcl = asu64(R1);
	R1 = tou64("MCL1");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	i = asi64(R1);
L1280:
	asu64(R1) = mc_decls_currpcl;
	mc_genmcl_convertpcl(asu64(R1));
	R1 = 0;
	if (!asu16(R1)) goto L1284;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1284;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1284;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1284;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1284;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1284;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1284;
	mc_stackmcl_showopndstack();
L1284:
	R1 = (u64)&mc_decls_currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = mc_decls_currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1285;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) != asi64(R2)) goto L1280;
L1285:
	mc_auxmcl_genrealtable();
	mc_auxmcl_genabsneg();
	mc_auxmcl_genstringtable();
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L1287;
	mc_optim_peephole();
L1287:
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
L1274:
	return;
}

static void mc_genmcl_convertpcl(u64 p) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 oldregset;
	i64 reg;
	i64 i;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	mc_decls_pmode = asu8(R1);
	asu64(R1) = p;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pc_decls_ppseqno = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	((F18)R2)(asu64(R1));
	(R1_B3) = mc_decls_regset;
	oldregset = (R1_B3);
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1291;
L1289:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L1293;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1295;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1294;
L1295:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1294:
L1293:
	i += 1; if (i <= mc_decls_noperands) goto L1289;
L1291:
	R1 = (u64)&oldregset;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 48;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	R1 = (u64)&oldregset;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 56;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	return;
}

static void mc_genmcl_inithandlers() {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	i64 n;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	i64 k;
// PROC LOCAL STATICS GO HERE
	static u8 mc_genmcl_inithandlers_initdone = 0;
	static struct $B26 mc_genmcl_inithandlers_dupltable = {{
22605,
	16449,
	4629,
	4627,
	4630,
	30327,
	30841,
	12126,
	12383    }};
	asu8(R1) = mc_genmcl_inithandlers_initdone;
	if (!asu8(R1)) goto L1298;
	goto L1296;
L1298:
	asi64(R1) = $nprocs;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1301;
L1299:
	R1 = (u64)&$procname;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 3;
	R2 = tou64("px_");
	asu64(R3) = name;
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L1303;
	R1 = 0;
	k = asi64(R1);
	R1 = 142;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1307;
L1304:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	s = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) != asu64(R2)) goto L1309;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L1309:
	asu64(R1) = name;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1311;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L1306;
L1311:
	k += 1; if (k <= av_1) goto L1304;
L1307:
	asu64(R1) = name;
	R2 = tou64("Invalid handler name:");
	pc_api_merror(asu64(R2), asu64(R1));
L1306:
L1303:
	i += 1; if (i <= n) goto L1299;
L1301:
	R1 = 1;
	i = asi64(R1);
	R1 = 9;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1314;
L1312:
	R1 = (u64)&mc_genmcl_px_handlertable;
	R2 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R3) = i;
	R2 += (i64)R3*2-2;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	R3 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R4) = i;
	R3 += (i64)R4*2-2;
	R4 = 1;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L1312;
L1314:
	R1 = 0;
	i = asi64(R1);
	R1 = 142;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1317;
L1315:
	R1 = (u64)&mc_genmcl_px_handlertable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (asu64(R1)) goto L1319;
	R1 = (u64)&mc_genmcl_unimpl;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L1319:
	i += 1; if (i <= av_3) goto L1315;
L1317:
	R1 = 1;
	mc_genmcl_inithandlers_initdone = asu8(R1);
L1296:
	return;
}

static void mc_genmcl_doshowpcl(u64 p) {
    u64 R1, R2; 
	struct $B79 str;
	goto L1320;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1322;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1322;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1322;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1322;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1322;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1322;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1322;
	goto L1323;
L1322:
	goto L1321;
L1323:
	R1 = tou64("                       ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1256;
	asu64(R2) = p;
	asu64(R1) = pc_diags_strpclstr(asu64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
L1321:
L1320:
	return;
}

static void mc_genmcl_unimpl(u64 p) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Unimpl: # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_nop(u64 p) {
	return;
}

static void mc_genmcl_px_dupl(u64 p) {
	mc_stackmcl_duplpcl();
	return;
}

static void mc_genmcl_px_double(u64 p) {
    u64 R1, R2; 
	asi64(R1) = mc_decls_ncalldepth;
	if (!asi64(R1)) goto L1329;
	mc_stackmcl_duplpcl();
	goto L1328;
L1329:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L1328:
	return;
}

static void mc_genmcl_px_opnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_type(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_comment(u64 p) {
	return;
}

static void mc_genmcl_px_proc(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_currfunc = asu64(R1);
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 1;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	mc_auxmcl_initproc(asu64(R1));
	R1 = tou64("?>>");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mclprocentry = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1335;
	asu64(R1) = pc_decls_currfunc;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1335;
	mc_auxmcl_fixmain();
L1335:
	return;
}

static void mc_genmcl_px_endproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1338;
	msysc_m$print_startcon();
	R1 = tou64("PCL STACK NOT EMPTY");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PCL STACK NOT EMPTY");
	mc_libmcl_mgencomment(asu64(R1));
L1338:
	R1 = 0;
	R2 = 0;
	R3 = 2;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endprog(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_istatic(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_zstatic(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_data(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 opc;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1344;
	asu64(R1) = p;
	mc_auxmcl_do_blockdata(asu64(R1));
	goto L1342;
L1344:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1346;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1347;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1348;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1349;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1350;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1351;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1352;
	goto L1353;
L1346:
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1345;
L1347:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1345;
L1348:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1345;
L1349:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1345;
L1350:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1345;
L1351:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1345;
L1352:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1345;
L1353:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("db/dq optype? #");
	pc_api_merror(asu64(R2), asu64(R1));
L1345:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1355;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1356;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1357;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1358;
	goto L1359;
L1355:
	R1 = 116;
	opc = asi64(R1);
	goto L1354;
L1356:
	R1 = 117;
	opc = asi64(R1);
	goto L1354;
L1357:
	R1 = 118;
	opc = asi64(R1);
	goto L1354;
L1358:
	R1 = 119;
	opc = asi64(R1);
	goto L1354;
L1359:
	msysc_m$print_startcon();
	R1 = tou64("P.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STRPMODE(P.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("DATA/not 1248");
	pc_api_merror(asu64(R2), asu64(R1));
L1354:
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1342:
	return;
}

static void mc_genmcl_px_label(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_load(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_stackmcl_pushpcl(asu64(R1));
	return;
}

static void mc_genmcl_px_store(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1364;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1363;
L1364:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L1363:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_add(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1367;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1369;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1369;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 52;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1368;
L1369:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1368:
	goto L1366;
L1367:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 65;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1366:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_sub(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1372;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1374;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1374;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1373;
L1374:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1373:
	goto L1371;
L1372:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 67;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1371:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_mul(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	i64 x;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1377;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1379;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1378;
L1379:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1378:
	goto L1376;
L1377:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 69;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1376:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_div(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 71;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_eval(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_widen(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1384;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1384;
	R1 = 0;
	R2 = 5;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1386;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1386:
	goto L1383;
L1384:
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = (u64)&pc_tables_psigned;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	if (!asu8(R3)) goto L1388;
	R3 = 18;
	goto L1387;
L1388:
	R3 = 19;
L1387:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1383:
	return;
}

static void mc_genmcl_px_jump(u64 p) {
    u64 R1, R2, R3; 
	i64 labno;
	u64 q;
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	goto L1391;
L1390:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
L1391:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1390;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1394;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1395;
	goto L1396;
L1394:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1398;
	goto L1389;
L1398:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) != asi64(R2)) goto L1400;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1400;
	goto L1389;
L1400:
	goto L1393;
L1395:
	R1 = 0;
	asu64(R2) = q;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1393;
L1396:
L1393:
	R1 = 0;
	asi64(R2) = labno;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1389:
	return;
}

static void mc_genmcl_px_ijump(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_neg(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1404;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1403;
L1404:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
L1403:
	return;
}

static void mc_genmcl_px_abs(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 lx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1407;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1406;
L1407:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L1406:
	return;
}

static void mc_genmcl_px_bitnot(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_not(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 cx;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1412;
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = cx;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1414;
	R3 = 5;
	goto L1413;
L1414:
	R3 = 4;
L1413:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1411;
L1412:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1416;
	R3 = 5;
	goto L1415;
L1416:
	R3 = 4;
L1415:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-3)) = asu8(R1);
L1411:
	return;
}

static void mc_genmcl_px_sqr(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1419;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1418;
L1419:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 69;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1418:
	return;
}

static void mc_genmcl_px_sqrt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 63;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_jumpcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 mcond;
	u64 ax;
	u64 bx;
	u64 lx;
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	lx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1423;
	R1 = tou64("");
	R2 = tou64("JUMPCC/BLOCK");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1422;
L1423:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1425;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1427;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1427;
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1428;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1427;
L1428:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1426;
L1427:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1430;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
L1430:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1426:
	goto L1424;
L1425:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1424:
	R1 = 0;
	asu64(R2) = lx;
	asi64(R3) = mcond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1432;
	mc_stackmcl_poppcl();
L1432:
L1422:
	return;
}

static void mc_genmcl_px_jumpt(u64 p) {
    u64 R1, R2; 
	R1 = 5;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_jumpf(u64 p) {
    u64 R1, R2; 
	R1 = 4;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitand(u64 p) {
    u64 R1, R2; 
	R1 = 38;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitor(u64 p) {
    u64 R1, R2; 
	R1 = 39;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxor(u64 p) {
    u64 R1, R2; 
	R1 = 40;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shl(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shr(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1441;
	R1 = 44;
	goto L1440;
L1441:
	R1 = 45;
L1440:
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_retproc(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mclprocentry;
	asu64(R2) = mc_decls_mccodex;
	if (asu64(R1) != asu64(R2)) goto L1444;
	R1 = tou64("---");
	mc_libmcl_mgencomment(asu64(R1));
L1444:
	asu64(R1) = p;
	mc_auxmcl_do_procentry(asu64(R1));
	mc_auxmcl_do_procexit();
	return;
}

static void mc_genmcl_px_retfn(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1447;
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 6;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1447:
	asu64(R1) = p;
	mc_genmcl_px_retproc(asu64(R1));
	return;
}

static void mc_genmcl_px_setcall(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	asi64(R1) = mc_decls_ncalldepth;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1450;
	R1 = tou64("");
	R2 = tou64("Too many nested calls");
	pc_api_merror(asu64(R2), asu64(R1));
L1450:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1452;
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1451;
L1452:
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asi64(R2) = mc_decls_mstackdepth;
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1451:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callblocksize;
	asi64(R3) = mc_decls_ncalldepth;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1454;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
L1454:
	return;
}

static void mc_genmcl_px_setarg(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L1457;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1459;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 0;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
L1459:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	mc_stackmcl_pushopnd(asi64(R2), asi64(R1));
	goto L1456;
L1457:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1460;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*16-16;
	asi64(R3) = n;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
L1460:
L1456:
	return;
}

static void mc_genmcl_px_callp(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 nargs;
	i64 nregargs;
	i64 slots;
	i64 isptr;
	i64 shadow;
	i64 blockret;
	i64 av_1;
	R1 = 0;
	isptr = asi64(R1);
	R1 = 0;
	shadow = asi64(R1);
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	nargs = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nregargs = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1464;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L1463;
L1464:
	R1 = 1;
	isptr = asi64(R1);
L1463:
	asi64(R1) = isptr;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = nregargs;
	mc_auxmcl_do_pushlowargs(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1466;
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L1468;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	goto L1467;
L1468:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L1467:
	goto L1465;
L1466:
	asi64(R1) = nargs;
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	slots = asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
L1465:
	asi64(R1) = isptr;
	if (!asi64(R1)) goto L1470;
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L1469;
L1470:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1469:
	asi64(R1) = nregargs;
	asi64(R2) = blockret;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1473;
L1471:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L1471;
L1473:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L1475;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L1475:
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1477;
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
L1477:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mc_genmcl_px_jumpret(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1480;
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1482;
	R1 = 1;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
L1482:
L1480:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_jumpretm(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	i64 reg;
	i64 av_1;
	i64 av_2;
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1486;
L1484:
	R1 = 0;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1484;
L1486:
	R1 = 1;
	reg = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1489;
L1487:
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1491;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1491;
	R1 = 11;
	reg = asi64(R1);
L1491:
	asi64(R1) = reg;
	mc_stackmcl_movetoreg(asi64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	if (--asi64(av_2)) goto L1487;
L1489:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_startmx(u64 p) {
    u64 R1; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	return;
}

static void mc_genmcl_px_resetmx(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L1495;
	mc_stackmcl_poppcl();
L1495:
	return;
}

static void mc_genmcl_px_stop(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 11;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = tou64("exit*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_incrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_incrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadincr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loaddecr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_forup(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 14;
	R2 = 28;
	R3 = 52;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fordown(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 13;
	R2 = 29;
	R3 = 53;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_iload(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 px;
	u64 nextpcl;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1507;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1509;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L1508;
L1509:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L1508:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L1511;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L1510;
L1511:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1510:
	goto L1506;
L1507:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
L1506:
	return;
}

static i64 mc_genmcl_getsharereg(u64 ax, i64 mode) {
    u64 R1, R2; 
	u8 reg;
	u8 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	reg = asu8(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	regix = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1514;
	R1 = 0;
	goto L1512;
L1514:
	asu8(R1) = reg;
	if (!asu8(R1)) goto L1516;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = reg;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1517;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L1516;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L1516;
L1517:
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	goto L1512;
	goto L1515;
L1516:
	asu8(R1) = regix;
	if (!asu8(R1)) goto L1518;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = regix;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1519;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L1518;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L1518;
L1519:
	asu8(R1) = regix;
	R1 = toi64(tou8(R1));
	goto L1512;
L1518:
L1515:
	R1 = 0;
	goto L1512;
L1512:
	return asi64(R1);
}

static void mc_genmcl_px_iloadx(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 z;
	u64 nextpcl;
	u64 ax;
	u64 bx;
	u64 px;
	u64 fx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1522;
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1521;
L1522:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L1524;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L1523;
L1524:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1523:
L1521:
	return;
}

static void mc_genmcl_px_istore(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 bx;
	u64 px;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1527;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L1526;
L1527:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L1526:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1529;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1528;
L1529:
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1528:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_istorex(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 px;
	u64 z;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1532;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	cx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = cx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1531;
L1532:
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1531:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_storem(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 z;
	u64 dblock;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1535;
	R1 = tou64("");
	R2 = tou64("Storem not 16");
	pc_api_merror(asu64(R2), asu64(R1));
L1535:
	R1 = 16;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	R2 = 0;
	R3 = 8;
	asu64(R4) = px;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = px;
	R2 = 6;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_addpx(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 cx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	cx = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subpx(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 scale;
	i64 extra;
	i64 offset;
	u64 ax;
	u64 bx;
	u64 z;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1539;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R3) = extra;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1538;
L1539:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = scale;
	asu64(R2) = bx;
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L1541;
	asi64(R1) = scale;
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
L1541:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = extra;
	if (!asi64(R1)) goto L1543;
	msysc_m$print_startcon();
	R1 = tou64("EXTRA=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = extra;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUBREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L1543:
L1538:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_to(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 ax;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	q = asu64(R1);
	R1 = 6;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_iswap(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 qx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	qx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1547;
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qx;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = qx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1546;
L1547:
	R1 = tou64("");
	R2 = tou64("swap/block");
	pc_api_merror(asu64(R2), asu64(R1));
L1546:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swapstk(u64 p) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_noperands;
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_labeldef(u64 p) {
    u64 R1, R2; 
	struct $B5 str;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(":");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_addto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 65;
	R2 = 28;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 67;
	R2 = 29;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_multo(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 cx;
	u64 x;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1554;
	R1 = 69;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L1552;
L1554:
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1556;
	R1 = tou64("");
	R2 = tou64("multo/byte");
	pc_api_merror(asu64(R2), asu64(R1));
L1556:
	R1 = 0;
	R2 = 10;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	x = asu64(R2);
	if (!asu64(R1)) goto L1558;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = cx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1557;
L1558:
	asu64(R1) = bx;
	asu64(R2) = cx;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1557:
	asu64(R1) = cx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L1552:
	return;
}

static void mc_genmcl_px_bitandto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 38;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 39;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 40;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shlto(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shrto(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1565;
	R1 = 44;
	goto L1564;
L1565:
	R1 = 45;
L1564:
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fix(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 fx;
	u64 ax;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&pc_tables_pmin;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = fx;
	asu64(R2) = ax;
	R3 = 84;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_float(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 fx;
	i64 lab;
	i64 lab2;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1569;
	R1 = tou64("");
	R2 = tou64("float/short");
	pc_api_merror(asu64(R2), asu64(R1));
L1569:
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1571;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 86;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L1570;
L1571:
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1572;
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab2 = asi64(R1);
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 12;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab2;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	asi64(R1) = mc_decls_labmask63;
	if (asi64(R1)) goto L1574;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_labmask63 = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_laboffset64 = asi64(R1);
L1574:
	asi64(R1) = mc_decls_labmask63;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_laboffset64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = fx;
	R3 = 66;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab2;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
// mc_genmcl.px_float.reduce:
L1575:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1577;
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1577:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L1570;
L1572:
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1575;
L1570:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_idiv(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_irem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_idivrem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 2;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_clear(u64 p) {
    u64 R1, R2; 
	u64 ax;
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = ax;
	mc_auxmcl_clearblock(asu64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 n;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L1584;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L1586;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1585;
L1586:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUB/REF NOT POWER OF xx");
	pc_api_merror(asu64(R2), asu64(R1));
L1585:
L1584:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_switch(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 elselab;
	i64 reg;
	u64 ax;
	u64 bx;
	u64 ax2;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = mc_decls_currpcl;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	elselab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L1589;
	asu64(R1) = ax;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	ax2 = asu64(R3);
	R3 = 18;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax2;
	ax = asu64(R1);
L1589:
	asi64(R1) = minlab;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1591;
	R1 = 10;
	asi64(R2) = minlab;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1591:
	R1 = 10;
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = elselab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 3;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1593;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	R1 = 6;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1592;
L1593:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1592:
	mc_stackmcl_poppcl();
	R1 = 1;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_switchu(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 reg;
	u64 ax;
	u64 bx;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1596;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1595;
L1596:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1595:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swlabel(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endsw(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fwiden(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 8;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 89;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_fnarrow(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_truncate(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = pmode2;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L1603;
	asu64(R1) = ax;
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = (u64)&mc_decls_ploadop;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1603:
	return;
}

static void mc_genmcl_px_typepun(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_unload(u64 p) {
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_loadbit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 z;
	i64 i;
	i64 m;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1608;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1610;
	R2 = 31;
	if (asi64(R1) > asi64(R2)) goto L1610;
	R1 = 5;
	goto L1609;
L1610:
	R1 = 6;
L1609:
	m = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = i;
	if (!asi64(R1)) goto L1612;
	asi64(R1) = m;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L1614;
	goto L1615;
L1614:
L1612:
	goto L1607;
L1608:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1617;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1617:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1619;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1619:
L1607:
	R1 = 5;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
// mc_genmcl.px_loadbit.skip:
L1615:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_assem(u64 p) {
    u64 R1, R2; 
	asu64(R1) = pc_api_idomcl_assem;
	if (!asu64(R1)) goto L1622;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_idomcl_assem;
	((F18)R2)(asu64(R1));
	goto L1621;
L1622:
	R1 = tou64("");
	R2 = tou64("No Assem handler");
	pc_api_merror(asu64(R2), asu64(R1));
L1621:
	return;
}

static void mc_genmcl_px_sin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("sin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_cos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("cos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_tan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("tan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_asin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("asin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_acos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("acos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("atan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log10(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log10*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_exp(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("exp*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_round(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("round*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_floor(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("floor*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_ceil(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("ceil*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan2(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("atan2*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fmod(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("fmod*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_setcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 cond;
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1639;
	R1 = tou64("");
	R2 = tou64("setcc/block");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1638;
L1639:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1640;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1642;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
L1642:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	cx = asu64(R1);
	goto L1638;
L1640:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	R1 = 10;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
L1638:
	R1 = 0;
	asu64(R2) = cx;
	asi64(R3) = cond;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_min(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1645;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1647;
	R1 = 15;
	goto L1646;
L1647:
	R1 = 7;
L1646:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L1644;
L1645:
	R1 = 112;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L1644:
	return;
}

static void mc_genmcl_px_max(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1650;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1652;
	R1 = 12;
	goto L1651;
L1652:
	R1 = 2;
L1651:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L1649;
L1650:
	R1 = 113;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L1649:
	return;
}

static void mc_genmcl_px_power(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 d;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1655;
	R1 = 82;
	asu64(R1) = mc_auxmcl_gethostfn(asi64(R1));
	d = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	asu64(R2) = d;
	asu64(R3) = p;
	mc_auxmcl_do_host(asu64(R3), asu64(R2), asi64(R1));
	goto L1654;
L1655:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("pow*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
L1654:
	return;
}

static void mc_genmcl_px_minto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1658;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L1660;
	R2 = 14;
	goto L1659;
L1660:
	R2 = 6;
L1659:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L1657;
L1658:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L1657:
	return;
}

static void mc_genmcl_px_maxto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1663;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L1665;
	R2 = 13;
	goto L1664;
L1665:
	R2 = 3;
L1664:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L1662;
L1663:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L1662:
	return;
}

static void mc_genmcl_px_negto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1668;
	R1 = 0;
	asu64(R2) = px;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1667;
L1668:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	fx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = fx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = fx;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
	asu64(R1) = fx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1667:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_absto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 lx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1671;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1670;
L1671:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L1670:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_addpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1674;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1673;
L1674:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1673:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1677;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1676;
L1677:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1679;
	R1 = tou64("");
	R2 = tou64("SUBTOREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L1679:
L1676:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_divto(u64 p) {
    u64 R1, R2; 
	R1 = 71;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitnotto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu64(R2) = px;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_notto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = px;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	R3 = 5;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_sign(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 lx1;
	u64 lx2;
	u64 lx3;
	u8 gtop;
	u8 ltop;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1686;
	R1 = 7;
	gtop = asu8(R1);
	R1 = 2;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asr64(R2) = 0.000000000000000000e+000;
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1685;
L1686:
	R1 = 15;
	gtop = asu8(R1);
	R1 = 12;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1685:
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx1 = asu64(R3);
	asu8(R3) = gtop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx2 = asu64(R3);
	asu8(R3) = ltop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx3 = asu64(R3);
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx1;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = bx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx2;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = bx;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadbf(u64 p) {
    u64 R1, R2, R3; 
	u64 y;
	u64 z;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	y = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	z = asu64(R1);
	asu64(R1) = y;
	if (!asu64(R1)) goto L1689;
	asu64(R1) = z;
	if (!asu64(R1)) goto L1689;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	mc_auxmcl_do_loadbf_const(asu64(R3), asi64(R2), asi64(R1));
	goto L1688;
L1689:
	asu64(R1) = p;
	mc_auxmcl_do_loadbf_var(asu64(R1));
L1688:
	return;
}

static void mc_genmcl_px_storebit(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebit(asu64(R1));
	return;
}

static void mc_genmcl_px_storebf(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebf(asu64(R1));
	return;
}

static void mc_genmcl_px_loadall(u64 p) {
	mc_stackmcl_checkallloaded();
	return;
}

static void mc_genmcl_px_setjmp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 lab;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = lab;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	R2 = 0;
	R3 = 8;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dframeopnd;
	R2 = 0;
	R3 = 16;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	asu64(R1) = p;
	mc_stackmcl_freeworkregs(asu64(R1));
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	return;
}

static void mc_genmcl_px_longjmp(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 16;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	R1 = 1;
	mc_stackmcl_swapopndregs(asi64(R1));
	R1 = 0;
	asu64(R2) = cx;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_initdswx(u64 p) {
	return;
}

static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf) {
    u64 R1, R2, R3; 
	struct $B17 params;
	struct $B17 xparams;
	struct $B17 leafparams;
	struct $B17 xleafparams;
	u32 leafparamno;
	u32 xleafparamno;
	struct $B16 locals;
	struct $B16 xlocals;
	i64 nparams;
	i64 nxparams;
	i64 nleafparams;
	i64 nxleafparams;
	i64 nlocals;
	i64 nxlocals;
	i64 n;
	i64 reg;
	i64 xreg;
	i64 nl;
	i64 np;
	i64 nlx;
	i64 npx;
	u64 d;
	i64 i;
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nxparams = asi64(R1);
	R1 = 0;
	nleafparams = asi64(R1);
	R1 = 0;
	nxleafparams = asi64(R1);
	R1 = 0;
	nlocals = asi64(R1);
	R1 = 0;
	nxlocals = asi64(R1);
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = mc_decls_maxxregvars;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1698;
	goto L1696;
L1698:
	asi64(R1) = skipparams;
	if (asi64(R1)) goto L1700;
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L1704;
L1701:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1706;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1706;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1706;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1706;
	asi64(R1) = isleaf;
	if (asi64(R1)) goto L1708;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1710;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1712;
	asu64(R1) = d;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1712:
	goto L1709;
L1710:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1713;
	asi64(R1) = nxparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1715;
	asu64(R1) = d;
	R2 = (u64)&xparams;
	R3 = (u64)&nxparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1715:
L1713:
L1709:
	goto L1707;
L1708:
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1717;
	asi64(R1) = nleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1719;
	asu64(R1) = d;
	R2 = (u64)&leafparams;
	R3 = (u64)&nleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&leafparamno;
	asi64(R3) = nleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1719:
	goto L1716;
L1717:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1720;
	asi64(R1) = nxleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1722;
	asu64(R1) = d;
	R2 = (u64)&xleafparams;
	R3 = (u64)&nxleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&xleafparamno;
	asi64(R3) = nxleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1722:
L1720:
L1716:
L1707:
L1706:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1704:
	asu64(R1) = d;
	if (asu64(R1)) goto L1701;
L1700:
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L1726;
L1723:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1728;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1728;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1728;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1730;
	asi64(R1) = nlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L1732;
	asu64(R1) = d;
	R2 = (u64)&locals;
	R3 = (u64)&nlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1732:
	goto L1729;
L1730:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1733;
	asi64(R1) = nxlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L1733;
	asu64(R1) = d;
	R2 = (u64)&xlocals;
	R3 = (u64)&nxlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1733:
L1729:
L1728:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1726:
	asu64(R1) = d;
	if (asu64(R1)) goto L1723;
	asi64(R1) = nlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1735;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	np = asi64(R1);
	R1 = 0;
	nl = asi64(R1);
	goto L1734;
L1735:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1736;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nl = asi64(R1);
	R1 = 0;
	np = asi64(R1);
	goto L1734;
L1736:
	asi64(R1) = nlocals;
	nl = asi64(R1);
	asi64(R1) = nparams;
	np = asi64(R1);
	asi64(R1) = np;
	asi64(R2) = nl;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1738;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1740;
	asi64(R1) = np;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1740;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L1740:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1742;
	asi64(R1) = n;
	R2 = (u64)&nl;
	*toi64p(R2) -= asi64(R1);
L1742:
L1738:
L1734:
	R1 = 4;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nl;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1745;
L1743:
	R1 = (u64)&locals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= nl) goto L1743;
L1745:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = np;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1748;
L1746:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= np) goto L1746;
L1748:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1751;
L1749:
	R1 = (u64)&leafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&leafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1753;
	R1 = 1;
	pc_decls_r10used = asu8(R1);
L1753:
	asi64(R1) = reg;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L1755;
	R1 = 1;
	pc_decls_r11used = asu8(R1);
L1755:
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nleafparams) goto L1749;
L1751:
	asi64(R1) = nxlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1757;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npx = asi64(R1);
	R1 = 0;
	nlx = asi64(R1);
	goto L1756;
L1757:
	asi64(R1) = nxparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1758;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nlx = asi64(R1);
	R1 = 0;
	npx = asi64(R1);
	goto L1756;
L1758:
	asi64(R1) = nxlocals;
	nlx = asi64(R1);
	asi64(R1) = nxparams;
	npx = asi64(R1);
	asi64(R1) = npx;
	asi64(R2) = nlx;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1760;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1762;
	asi64(R1) = npx;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1762;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L1762:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1764;
	asi64(R1) = n;
	R2 = (u64)&nlx;
	*toi64p(R2) -= asi64(R1);
L1764:
L1760:
L1756:
	R1 = 16;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1767;
L1765:
	R1 = (u64)&xlocals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= nlx) goto L1765;
L1767:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = npx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1770;
L1768:
	R1 = (u64)&xparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= npx) goto L1768;
L1770:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nxleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1773;
L1771:
	R1 = (u64)&xleafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&xleafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nxleafparams) goto L1771;
L1773:
L1696:
	return;
}

static void mc_auxmcl_initproc(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 e;
	u64 pinfi;
	i64 reg;
	i64 xreg;
	i64 n;
	i64 r;
	i64 npregs;
	i64 av_1;
	i64 av_2;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isregvar;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isxregvar;
	memset(R1, 0, 16);
	R1 = 3;
	mc_decls_nworkregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	mc_decls_maxxregvars = asi64(R2);
	mc_decls_maxregvars = asi64(R1);
	R1 = 0;
	npregs = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1776;
	R1 = 10;
	mc_decls_nworkregs = asi64(R1);
	R1 = 12;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 4;
	r = asi64(R1);
L1777:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 10) goto L1777;
	R1 = 7;
	r = asi64(R1);
L1780:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 16) goto L1780;
	goto L1775;
L1776:
	R1 = 4;
	asu64(R2) = pc_decls_currfunc;
	R3 = 112;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = pc_decls_pinfo;
	R4 = 4;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) = Max(asi64(R2), asi64(R3));
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npregs = asi64(R1);
	R1 = 4;
	mc_decls_nworkregs = asi64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1784;
	R1 = (u64)&mc_decls_nworkregs;
	(*toi64p(R1)) += 1;
L1784:
	R1 = 5;
	mc_decls_nworkxregs = asi64(R1);
	asi64(R1) = mc_decls_nworkregs;
	R2 = 3;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = npregs;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L1786;
	asi64(R1) = n;
	if (!asi64(R1)) goto L1786;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = npregs;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1788;
	asi64(R1) = n;
	if (!asi64(R1)) goto L1788;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L1788:
L1786:
	R1 = 10;
	r = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1791;
L1789:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_1)) goto L1789;
L1791:
	R1 = 7;
	r = asi64(R1);
	asi64(R1) = mc_decls_nworkxregs;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1794;
L1792:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_2)) goto L1792;
L1794:
L1775:
	R1 = 4;
	r = asi64(R1);
L1795:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1799;
	R1 = (u64)&mc_decls_maxregvars;
	(*toi64p(R1)) += 1;
L1799:
	r += 1; if (r <= 10) goto L1795;
	R1 = 7;
	r = asi64(R1);
L1800:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1804;
	R1 = (u64)&mc_decls_maxxregvars;
	(*toi64p(R1)) += 1;
L1804:
	r += 1; if (r <= 16) goto L1800;
	R1 = (u64)&mc_decls_usedregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_usedxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_pcltempflags;
	memset(R1, 0, 50);
	R1 = 0;
	R2 = R1;
	pc_decls_r11used = asu8(R2);
	pc_decls_r10used = asu8(R1);
	R1 = 0;
	mc_decls_mstackdepth = asi64(R1);
	R1 = 0;
	mc_decls_noperands = asi64(R1);
	R1 = 0;
	R2 = R1;
	mc_genmcl_framebytes = asi64(R2);
	R2 = R1;
	mc_genmcl_paramoffset = asi64(R2);
	mc_genmcl_frameoffset = asi64(R1);
	R1 = 0;
	pc_decls_localshadow = asu8(R1);
	R1 = 0;
	mc_decls_nblocktemps = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1806;
	R1 = 8;
	R2 = tou64("$1x");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	asu64(R2) = e;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = e;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = pc_decls_currfunc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	pc_decls_blockretname = asu64(R1);
L1806:
	asu8(R1) = pc_decls_fregoptim;
	if (!asu8(R1)) goto L1809;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1808;
L1809:
	goto L1774;
L1808:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1811;
	goto L1774;
L1811:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_decls_currfunc;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (asu8(R2)) goto L1812;
	asu64(R2) = pc_decls_currfunc;
	R3 = 113;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L1813;
L1812:
	R2 = 1;
	goto L1814;
L1813:
	R2 = 0;
L1814:
	mc_auxmcl_allocregvars(asi64(R2), asi64(R1));
L1774:
	return;
}

static void mc_auxmcl_do_procentry(u64 p) {
    u64 R1, R2, R3; 
	i64 retmode;
	i64 ntemps;
	i64 hasequiv;
	i64 offset;
	i64 size;
	i64 reg;
	u64 ax;
	u64 d;
	struct $B5 str;
	struct $B5 newname;
	i64 rr;
	i64 ff;
	i64 r;
	i64 i;
	asu64(R1) = mc_decls_mclprocentry;
	mc_auxmcl_setmclentry(asu64(R1));
	R1 = 0;
	R2 = R1;
	pc_decls_bxspill = asi64(R2);
	pc_decls_bspill = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1818;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1817;
L1818:
	R1 = 4;
	r = asi64(R1);
L1819:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1824;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1823;
L1824:
	R1 = (u64)&pc_decls_bspill;
	(*toi64p(R1)) += 1;
L1823:
	r += 1; if (r <= 10) goto L1819;
	R1 = 7;
	r = asi64(R1);
L1825:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1830;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1829;
L1830:
	R1 = (u64)&pc_decls_bxspill;
	(*toi64p(R1)) += 1;
L1829:
	r += 1; if (r <= 16) goto L1825;
L1817:
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L1834;
L1831:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1836;
	R1 = tou64("");
	R2 = tou64("@PARAM");
	pc_api_merror(asu64(R2), asu64(R1));
L1836:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1838;
	asi64(R1) = mc_genmcl_paramoffset;
	R2 = 16;
	asi64(R1) += asi64(R2);
	asi64(R2) = pc_decls_bspill;
	asi64(R3) = pc_decls_bxspill;
	asi64(R2) += asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writegas_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1837;
L1838:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1837:
	R1 = 8;
	R2 = (u64)&mc_genmcl_paramoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1834:
	asu64(R1) = d;
	if (asu64(R1)) goto L1831;
	asu64(R1) = pc_decls_currfunc;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	retmode = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L1842;
L1839:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1844;
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	size = asi64(R1);
L1844:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1846;
	goto L1840;
L1846:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1848;
	R1 = 1;
	hasequiv = asi64(R1);
	goto L1847;
L1848:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1849;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1847;
L1849:
	asi64(R1) = size;
	asi64(R1) = mc_libmcl_roundsizetg(asi64(R1));
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writegas_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1847:
L1840:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1842:
	asu64(R1) = d;
	if (asu64(R1)) goto L1839;
	R1 = 0;
	ntemps = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L1850:
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1854;
	R1 = (u64)&ntemps;
	(*toi64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&mc_decls_pcltempopnds;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ax = asu64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = ax;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asi64(R2) = i;
	asu64(R3) = pc_decls_currfunc;
	asu64(R2) = mc_writegas_gettempname(asu64(R3), asi64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1854:
	i += 1; if (i <= 50) goto L1850;
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1856;
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (asi16(R1)) goto L1859;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1858;
L1859:
	R1 = tou64("");
	R2 = tou64("Threaded proc has locals/params");
	pc_api_merror(asu64(R2), asu64(R1));
L1858:
	asi64(R1) = ntemps;
	if (!asi64(R1)) goto L1861;
	R1 = tou64("");
	R2 = tou64("Threaded proc has temps");
	pc_api_merror(asu64(R2), asu64(R1));
L1861:
	asu64(R1) = mc_auxmcl_resetmclentry();
	goto L1815;
L1856:
	asi64(R1) = mc_genmcl_frameoffset;
	asi64(R1) = -asi64(R1);
	mc_genmcl_framebytes = asi64(R1);
	asi64(R1) = pc_decls_bspill;
	asi64(R2) = pc_decls_bxspill;
	asi64(R1) += asi64(R2);
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1863;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L1865;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L1865:
	goto L1862;
L1863:
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L1867;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L1867:
L1862:
	asu8(R1) = pc_decls_localshadow;
	if (!asu8(R1)) goto L1869;
	R1 = 32;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L1869:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L1871;
	R1 = 4;
	r = asi64(R1);
L1872:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1877;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1876;
L1877:
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1876:
	r += 1; if (r <= 10) goto L1872;
L1871:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L1879;
	R1 = 6;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 7;
	r = asi64(R1);
L1880:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1885;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1884;
L1885:
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1884:
	r += 1; if (r <= 16) goto L1880;
L1879:
	R1 = tou64("?]]");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_auxmcl_mclframesetup = asu64(R1);
	mc_auxmcl_spillparams();
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_auxmcl_resetmclentry();
L1815:
	return;
}

static void mc_auxmcl_do_procexit() {
    u64 R1, R2, R3; 
	u64 ax;
	i64 offset;
	i64 r;
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1888;
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1886;
L1888:
	asu64(R1) = mc_auxmcl_mclframesetup;
	mc_auxmcl_setmclentryf(asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L1891;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1890;
L1891:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1893;
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_pushstack(asi64(R1));
	goto L1892;
L1893:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L1895;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
L1895:
L1892:
L1890:
	asu64(R1) = mc_auxmcl_resetmclentryf();
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L1898;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1897;
L1898:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1900;
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_popstack(asi64(R1));
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1899;
L1900:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L1902;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_popstack(asi64(R1));
L1902:
L1899:
L1897:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L1904;
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 16;
	r = asi64(R1);
L1905:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1909;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	R2 = 8;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1909:
	r += -1; if (r >= 7) goto L1905;
L1904:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L1911;
	R1 = 10;
	r = asi64(R1);
L1912:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1916;
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1916:
	r += -1; if (r >= 4) goto L1912;
L1911:
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1886:
	return;
}

static void mc_auxmcl_spillparams() {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 d;
	u64 ax;
	i64 offset;
	i64 regoffset;
	i64 xregoffset;
	i64 firstoffset;
	i64 i;
	R1 = 16;
	offset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1919;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	firstoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L1922;
L1920:
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asi64(R4) = i;
	R5 = 8;
	asi64(R4) *= asi64(R5);
	asi64(R5) = firstoffset;
	asi64(R4) += asi64(R5);
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = i;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	i += 1; if (i <= 3) goto L1920;
L1922:
L1919:
	goto L1926;
L1923:
	asi64(R1) = regoffset;
	R2 = 3;
	if (asi64(R1) <= asi64(R2)) goto L1928;
	goto L1925;
L1928:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1930;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1932;
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asu64(R4) = d;
	R5 = 76;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1934;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1935;
	goto L1936;
L1934:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1933;
L1935:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 16;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1933;
L1936:
	R1 = 10;
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1933:
	goto L1931;
L1932:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1937;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1939;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L1941;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 8;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1941:
	goto L1938;
L1939:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L1942;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1942:
L1938:
L1937:
L1931:
L1930:
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&regoffset;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1926:
	asu64(R1) = d;
	if (asu64(R1)) goto L1923;
L1925:
	return;
}

static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1945;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1944;
L1945:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1944:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_bitwise(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shift(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 y;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	y = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1949;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1949;
	R1 = 10;
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1948;
L1949:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1951;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1951:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1953;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1953:
L1948:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_setmclentry(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mce_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentry() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mce_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mce_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mce_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L1955;
L1955:
	return asu64(R1);
}

static void mc_auxmcl_setmclentryf(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mcf_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentryf() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mcf_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mcf_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mcf_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L1957;
L1957:
	return asu64(R1);
}

static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 j;
	i64 k;
	i64 nextireg;
	i64 nextxreg;
	i64 mode;
	i64 imode;
	i64 blockret;
	u64 dblock;
	i64 av_1;
	i64 i;
	asi64(R1) = nargs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1960;
	goto L1958;
L1960:
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	R1 = 11;
	nextireg = asi64(R1);
	R1 = 1;
	nextxreg = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = nargs;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) < asi64(R2)) goto L1963;
L1961:
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = k;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1965;
	asi64(R1) = blockret;
	if (!asi64(R1)) goto L1965;
	R1 = (u64)&mc_decls_callblocksize;
	asi64(R2) = mc_decls_ncalldepth;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1964;
L1965:
	asi64(R1) = i;
	asi64(R2) = isptr;
	asi64(R1) -= asi64(R2);
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = j;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1967;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1968;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1968;
	goto L1969;
L1967:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = k;
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*16-16;
	asi64(R3) = k;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(tou32(R2));
	asu64(R3) = ax;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
	goto L1966;
L1968:
	asi64(R1) = nextxreg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L1971;
	asi64(R1) = k;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L1971;
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1973;
	R1 = 5;
	goto L1972;
L1973:
	R1 = 6;
L1972:
	imode = asi64(R1);
	asi64(R1) = mode;
	asi64(R2) = nextxreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = imode;
	asi64(R3) = nextireg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1971:
	goto L1966;
L1969:
// mc_auxmcl.do_pushlowargs.doint:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
L1966:
L1964:
	R1 = (u64)&nextireg;
	(*toi64p(R1)) += 1;
	R1 = (u64)&nextxreg;
	(*toi64p(R1)) += 1;
	i += -1; if (i >= av_1) goto L1961;
L1963:
L1958:
	return;
}

static void mc_auxmcl_do_getretvalue(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 xreg;
	i64 i;
	i64 n;
	i64 m;
	struct $B1 modes;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L1977;
	R1 = 0;
	n = asi64(R1);
	goto L1979;
L1978:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&modes;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1979:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1978;
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1983;
L1981:
	R1 = (u64)&modes;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1985;
	R1 = (u64)&mc_decls_multxregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L1984;
L1985:
	R1 = (u64)&mc_decls_multregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
L1984:
	asi64(R2) = m;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	i += -1; if (i >= 1) goto L1981;
L1983:
	goto L1976;
L1977:
	R1 = 1;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
L1976:
	return;
}

static i64 mc_auxmcl_ismemaddr(i64 n) {
    u64 R1, R2; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1988;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1988;
	R1 = 1;
	goto L1986;
L1988:
	R1 = 0;
	goto L1986;
L1986:
	return asi64(R1);
}

static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 mx;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1991;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1990;
L1991:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1990:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1994;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1993;
L1994:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1993:
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1997;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1996;
L1997:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1996:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 r;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 mx;
	i64 reg;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	r = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2000;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2002;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2001;
L2002:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2001:
	asu64(R1) = mx;
	ax = asu64(R1);
	goto L1999;
L2000:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2004;
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2003;
L2004:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2003:
	asu64(R1) = ax;
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1999:
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2006;
	R1 = 10;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	goto L2005;
L2006:
	R1 = 6;
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	bx = asu64(R1);
L2005:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale) {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2010;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2010;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2010;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2009;
L2010:
	asi64(R1) = scale;
	goto L2007;
L2009:
	asi64(R1) = scale;
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	goto L2007;
L2007:
	return asi64(R1);
}

static void mc_auxmcl_mulimm(u64 ax, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 shifts;
	i64 m;
	u64 bx;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2013;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2014;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L2015;
	goto L2016;
L2013:
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	goto L2011;
	goto L2012;
L2014:
	goto L2011;
	goto L2012;
L2015:
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2011;
	goto L2012;
L2016:
L2012:
	R1 = 0;
	shifts = asi64(R1);
	asi64(R1) = n;
	m = asi64(R1);
	goto L2018;
L2017:
	R1 = 1;
	R2 = (u64)&m;
	*toi64p(R2) >>= asi64(R1);
	R1 = (u64)&shifts;
	(*toi64p(R1)) += 1;
L2018:
	asi64(R1) = m;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2017;
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2021;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2021:
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2023;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2024;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2024;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2024;
	goto L2025;
L2023:
	goto L2011;
	goto L2022;
L2024:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = m;
	R6 = 1;
	asi64(R5) -= asi64(R6);
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2022;
L2025:
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2027;
	R1 = 34;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_mccodex;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2026;
L2027:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2029;
	R1 = 9;
	goto L2028;
L2029:
	R1 = 10;
L2028:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2026:
L2022:
L2011:
	return;
}

static u64 mc_auxmcl_do_addrmode(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 px;
	u64 ax;
	u64 bx;
	i64 scale;
	i64 extra;
	i64 offset;
	i64 reg;
	i64 regix;
	u64 d;
	u64 q;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2032;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
L2032:
	R1 = 0;
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2034;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2036;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2035;
L2036:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2037;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2035;
L2037:
	asi64(R1) = scale;
	R2 = 0;
	R3 = (u64)&mc_decls_pclmode;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2035:
	goto L2033;
L2034:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R1) = mc_auxmcl_ismemaddr(asi64(R1));
	if (!asi64(R1)) goto L2038;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2042;
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2041;
L2042:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2040;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2040;
L2041:
	goto L2043;
L2040:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2045;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2044;
L2045:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2046;
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2044;
L2046:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 10;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2044:
	goto L2033;
L2038:
// mc_auxmcl.do_addrmode.skip:
L2043:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2048;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2047;
L2048:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2049;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2047;
L2049:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2047:
L2033:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = px;
	goto L2030;
L2030:
	return asu64(R1);
}

static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	i64 regix;
	u64 ax;
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2053;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2053;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2053;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2052;
L2053:
	asi64(R1) = reg;
	goto L2050;
L2052:
	asi64(R1) = mc_stackmcl_getworkireg();
	regix = asi64(R1);
	R1 = 10;
	asi64(R2) = regix;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2055;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 1;
	asi64(R6) = reg;
	asi64(R7) = reg;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
	goto L2054;
L2055:
	R1 = 10;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
L2054:
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = regix;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 10;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = regix;
	goto L2050;
L2050:
	return asi64(R1);
}

static void mc_auxmcl_dolea(u64 ax, u64 px) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = px;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2060;
	asu64(R2) = px;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2060;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2060;
	R1 = 1;
	goto L2061;
L2060:
	R1 = 0;
L2061:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2059;
	asu64(R1) = px;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2058;
L2059:
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2058:
	return;
}

static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 rx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2064;
	asi64(R1) = fopc;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2062;
L2064:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2062:
	return;
}

static void mc_auxmcl_do_binto_float(u64 p, i64 opc) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = cx;
	asi64(R3) = opc;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shiftnto(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 cx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2068;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2068;
	R1 = 10;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2067;
L2068:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2070;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2070:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2072;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2072:
L2067:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 q;
	i64 opc;
	i64 n;
	i64 shifts;
	u8 fdivto;
	i64 locyy;
	i64 loczz;
	R1 = 0;
	fdivto = asu8(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	locyy = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	loczz = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L2076;
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L2075;
L2076:
	R1 = (u64)&locyy;
	R2 = (u64)&loczz;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	fdivto = asu8(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2074;
L2075:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
L2074:
	asi64(R1) = loczz;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2078;
	asi64(R1) = isdiv;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2078;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2080;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2081;
	goto L2082;
L2080:
	R1 = tou64("");
	R2 = tou64("Divide by zero");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2079;
L2081:
	mc_stackmcl_poppcl();
	goto L2073;
	goto L2079;
L2082:
	asi64(R1) = n;
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	shifts = asi64(R1);
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2084;
	asu8(R1) = fdivto;
	if (asu8(R1)) goto L2084;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = issigned;
	if (!asi64(R3)) goto L2086;
	R3 = 44;
	goto L2085;
L2086:
	R3 = 45;
L2085:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L2073;
L2084:
L2079:
L2078:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	mc_auxmcl_saverdx();
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_auxmcl_fixdivopnds(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = issigned;
	if (!asi64(R1)) goto L2088;
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2090;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2091;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2092;
	goto L2093;
L2090:
	R1 = 57;
	goto L2089;
L2091:
	R1 = 56;
	goto L2089;
L2092:
	R1 = 55;
	goto L2089;
L2093:
	R1 = tou64("");
	R2 = tou64("div/u8");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
L2089:
	opc = asi64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 36;
	opc = asi64(R1);
	goto L2087;
L2088:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 37;
	opc = asi64(R1);
L2087:
	R1 = 0;
	asu64(R2) = bx;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = isdiv;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2095;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2096;
	goto L2097;
L2095:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2094;
L2096:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	mc_stackmcl_swapopndregs(asi64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2094;
L2097:
L2094:
	mc_auxmcl_restorerdx();
	asu8(R1) = fdivto;
	if (!asu8(R1)) goto L2099;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu64(R2) = bx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = bx;
	asu64(R2) = mc_stackmcl_makeopndind(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
L2099:
	asi64(R1) = isdiv;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2101;
	mc_stackmcl_poppcl();
L2101:
L2073:
	return;
}

static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz) {
    u64 R1, R2, R3; 
	i64 regx;
	i64 regy;
	i64 zop;
	u64 bx;
	u64 ax;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regx = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = loczz;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regy = asi64(R1);
	asi64(R1) = regx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2104;
	goto L2102;
L2104:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = regy;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2106;
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2102;
L2106:
	R1 = (u64)&mc_decls_regset;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2108;
	asu64(R1) = bx;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = regx;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = locyy;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2102;
L2108:
	asi64(R1) = mc_decls_noperands;
	zop = asi64(R1);
	asi64(R1) = zop;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2112;
L2109:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2114;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2114;
	goto L2111;
L2114:
	zop += -1; if (zop >= 1) goto L2109;
L2112:
	goto L2102;
L2111:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = zop;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
L2102:
	return;
}

static void mc_auxmcl_saverdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2117;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2117:
	return;
}

static void mc_auxmcl_restorerdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2120;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2120:
	return;
}

static void mc_auxmcl_clearblock(u64 ax, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 av_1;
	i64 i;
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2123;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L2123;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2126;
L2124:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2124;
L2126:
	goto L2122;
L2123:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2127;
	asi64(R1) = nwords;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2129;
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	goto L2128;
L2129:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	R3 = 4;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
L2130:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= 4) goto L2130;
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2128:
L2127:
L2122:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2134;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2136;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2136:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2138;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2138:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2140;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2140:
L2134:
	return;
}

static void mc_auxmcl_do_blockdata(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 d;
	i64 n;
	i64 nqwords;
	i64 nwords;
	i64 r;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2143;
	goto L2141;
L2143:
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2146;
L2144:
	R1 = 0;
	R2 = 10;
	R3 = (u64)&d;
	asu64(R4) = *tou64p(R3); *(tou64p(R3)) += 8; asu64(R3) = asu64(R4);
	asi64(R3) = *toi64p(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L2144;
L2146:
	asi64(R1) = n;
	asi64(R2) = nwords;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) -= asi64(R2);
	r = asi64(R1);
	asi64(R1) = r;
	if (!asi64(R1)) goto L2148;
	R1 = 66;
	asi64(R2) = r;
	asu64(R3) = d;
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
L2148:
	R1 = tou64("ENDDATA");
	mc_libmcl_mgencomment(asu64(R1));
L2141:
	return;
}

static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 axreg;
	u8 saved;
	i64 av_1;
	R1 = 0;
	saved = asu8(R1);
	asi64(R1) = n;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2151;
	R1 = 2;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2149;
L2151:
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2153;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2153;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 8;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2156;
L2154:
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2154;
L2156:
	goto L2152;
L2153:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2157;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asi64(R1) = savedest;
	if (!asi64(R1)) goto L2159;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	axreg = asi64(R1);
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	saved = asu8(R1);
L2159:
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	bx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2157:
L2152:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2161;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2163;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 4;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2163:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2165;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 2;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2165:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2167;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 1;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2167:
L2161:
	asu8(R1) = saved;
	if (!asu8(R1)) goto L2169;
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2169:
L2149:
	return;
}

static void mc_auxmcl_genstringtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_cstringlist;
	if (asu64(R1)) goto L2172;
	goto L2170;
L2172:
	R1 = tou64("String Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_kk0used;
	if (!asi64(R1)) goto L2174;
	R1 = 0;
	asi64(R2) = mc_decls_kk0used;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2174:
	asu64(R1) = mc_decls_cstringlist;
	p = asu64(R1);
	goto L2178;
L2175:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = -1;
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2178:
	asu64(R1) = p;
	if (asu64(R1)) goto L2175;
L2170:
	return;
}

static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype) {
    u64 R1, R2; 
	i64 i;
	i64 c;
	i64 seqlen;
	u64 seq;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L2181;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2181:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2183;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
	goto L2179;
L2183:
	R1 = 0;
	seqlen = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2186;
L2184:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L2189;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) >= asi64(R2)) goto L2189;
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2190;
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L2188;
L2190:
L2189:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2192;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
	R1 = 0;
	seqlen = asi64(R1);
L2192:
	asi64(R1) = c;
	mc_auxmcl_gendb(asi64(R1));
	goto L2187;
L2188:
	asi64(R1) = seqlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2194;
	R1 = 1;
	seqlen = asi64(R1);
	asu64(R1) = s;
	R2 = 1;
	R1 -= (i64)R2;
	seq = asu64(R1);
	goto L2193;
L2194:
	R1 = (u64)&seqlen;
	(*toi64p(R1)) += 1;
L2193:
L2187:
	if (--asi64(av_1)) goto L2184;
L2186:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2196;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
L2196:
	asi64(R1) = strtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2198;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2198:
L2179:
	return;
}

static void mc_auxmcl_gendb(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendbstring(u64 s, i64 length) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	R3 = 120;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendq(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_genrealtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_creallist;
	if (asu64(R1)) goto L2204;
	asu64(R1) = mc_decls_cr32list;
	if (asu64(R1)) goto L2204;
	goto L2202;
L2204:
	R1 = tou64("Real Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = mc_decls_creallist;
	p = asu64(R1);
	goto L2208;
L2205:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2210;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2209;
L2210:
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2209:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2208:
	asu64(R1) = p;
	if (asu64(R1)) goto L2205;
	R1 = tou64("Real32 Table");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_cr32list;
	p = asu64(R1);
	goto L2214;
L2211:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2216;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
    asr32(R3) = tor32(asr64(R3));
	asi32(R3) = asi32(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2215;
L2216:
	R1 = 0;
	R2 = 1;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2215:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2214:
	asu64(R1) = p;
	if (asu64(R1)) goto L2211;
L2202:
	return;
}

static void mc_auxmcl_genabsneg() {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_lababs32;
	asi64(R2) = mc_decls_lababs64;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg32;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg64;
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L2219;
	R1 = 16;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
L2219:
	asi64(R1) = mc_decls_lababs32;
	if (!asi64(R1)) goto L2221;
	R1 = tou64("lababs32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
L2221:
	asi64(R1) = mc_decls_lababs64;
	if (!asi64(R1)) goto L2223;
	R1 = tou64("lababs64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
L2223:
	asi64(R1) = mc_decls_labneg32;
	if (!asi64(R1)) goto L2225;
	R1 = tou64("labneg32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
L2225:
	asi64(R1) = mc_decls_labneg64;
	if (!asi64(R1)) goto L2227;
	R1 = tou64("labneg64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
L2227:
	asi64(R1) = mc_decls_labzero;
	if (!asi64(R1)) goto L2229;
	R1 = tou64("labzero");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labzero;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendq(asi64(R1));
L2229:
	asi64(R1) = mc_decls_labmask63;
	if (!asi64(R1)) goto L2231;
	R1 = tou64("mask63/offset64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labmask63;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_laboffset64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4890909195324358656;
	mc_auxmcl_gendq(asi64(R1));
L2231:
	return;
}

static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	R2 = 0;
	asu64(R3) = opname;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	asu64(R2) = d;
	R3 = 0;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs) {
    u64 R1, R2, R3; 
	i64 slots;
	i64 av_1;
	asi64(R1) = nargs;
	mc_stackmcl_saveopnds(asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2236;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
	R1 = 1;
	slots = asi64(R1);
L2236:
	R1 = 0;
	R2 = 0;
	asi64(R3) = nargs;
	mc_auxmcl_do_pushlowargs(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L2238;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	goto L2237;
L2238:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L2237:
	asu64(R1) = opname;
	if (!asu64(R1)) goto L2240;
	R1 = 0;
	asu64(R2) = opname;
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2239;
L2240:
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2239:
	asi64(R1) = nargs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2243;
L2241:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L2241;
L2243:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L2245;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L2245:
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
	return;
}

static void mc_auxmcl_do_max_int(i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = cond;
	R4 = 15;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_max_float(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asi64(R1) = mode;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asi64(R4) = mode;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_negreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2252;
	asi64(R1) = mc_decls_labneg64;
	if (asi64(R1)) goto L2254;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg64 = asi64(R1);
L2254:
	asi64(R1) = mc_decls_labneg64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 77;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2251;
L2252:
	asi64(R1) = mc_decls_labneg32;
	if (asi64(R1)) goto L2256;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg32 = asi64(R1);
L2256:
	asi64(R1) = mc_decls_labneg32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 76;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2251:
	return;
}

static void mc_auxmcl_do_absreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2259;
	asi64(R1) = mc_decls_lababs64;
	if (asi64(R1)) goto L2261;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs64 = asi64(R1);
L2261:
	asi64(R1) = mc_decls_lababs64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 79;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2258;
L2259:
	asi64(R1) = mc_decls_lababs32;
	if (asi64(R1)) goto L2263;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs32 = asi64(R1);
L2263:
	asi64(R1) = mc_decls_lababs32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 78;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2258:
	return;
}

static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 mx;
	u64 mask;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2266;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 44;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2265;
L2266:
	asi64(R1) = i;
	if (!asi64(R1)) goto L2268;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2268:
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	asu64(R1) = mask;
	R2 = 2147483647;
	if (asu64(R1) > asu64(R2)) goto L2270;
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2269;
L2270:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2269:
L2265:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_loadbf_var(u64 p) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = tou64("LOADBF_VAR");
	pc_api_merror(asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_do_storebit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 cx;
	u64 ix;
	u64 q;
	u64 r;
	i64 i;
	i64 offset;
	u8 mask1s;
	u8 mask0s;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2274;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	offset = asi64(R1);
	R1 = 7;
	R2 = (u64)&i;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = px;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	mask0s = asu8(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	mask1s = asu8(R1);
	asu64(R1) = r;
	if (!asu64(R1)) goto L2276;
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2278;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2277;
L2278:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask0s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2277:
	goto L2275;
L2276:
	R1 = 0;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2280;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2280:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2275:
	goto L2273;
L2274:
	asu64(R1) = r;
	if (!asu64(R1)) goto L2281;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2283;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2285;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2285:
	R1 = 11;
	R2 = 10;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ix = asu64(R1);
	R1 = 1;
	asu64(R2) = cx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2287;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2287:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2289;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2288;
L2289:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2288:
	goto L2282;
L2283:
	R1 = tou64("");
	R2 = tou64("STOREBIT/VAR");
	pc_api_merror(asu64(R2), asu64(R1));
L2282:
	goto L2273;
L2281:
	R1 = tou64("");
	R2 = tou64("Storebit: both vars");
	pc_api_merror(asu64(R2), asu64(R1));
L2273:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_storebf(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 rx;
	u64 mx;
	u64 mx4;
	u64 dx;
	i64 i;
	i64 j;
	u64 q;
	u64 r;
	u64 mask;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = r;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2292;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2292;
	R1 = tou64("");
	R2 = tou64("storebf not imm");
	pc_api_merror(asu64(R2), asu64(R1));
L2292:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 3;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	dx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	j = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	asi64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2294;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = dx;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2294:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = mx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dx;
	asu64(R2) = rx;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static u64 mc_auxmcl_gethostfn(i64 opc) {
    u64 R1, R2; 
	u64 d;
	u64 name;
	u64 namec;
	u64 ps;
	asu64(R1) = pc_api_igethostfn;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2297;
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2299;
	goto L2300;
L2299:
	R1 = tou64("msys.m$power_i64");
	name = asu64(R1);
	R1 = tou64("msysc.m$power_i64");
	namec = asu64(R1);
	goto L2298;
L2300:
	R1 = 0;
	name = asu64(R1);
L2298:
	asu64(R1) = name;
	if (!asu64(R1)) goto L2302;
	asu64(R1) = pc_decls_psymboltable;
	ps = asu64(R1);
	goto L2306;
L2303:
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L2309;
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = namec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2308;
L2309:
	asu64(R1) = ps;
	goto L2295;
L2308:
	asu64(R1) = ps;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ps = asu64(R1);
L2306:
	asu64(R1) = ps;
	if (asu64(R1)) goto L2303;
L2302:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("gethostfn?");
	pc_api_merror(asu64(R2), asu64(R1));
L2297:
	asi64(R1) = opc;
	asu64(R2) = pc_api_igethostfn;
	asu64(R1) = ((F19)R2)(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2311;
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("No host fn:");
	pc_api_merror(asu64(R2), asu64(R1));
L2311:
	asu64(R1) = d;
	goto L2295;
L2295:
	return asu64(R1);
}

static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 dblock;
	u64 ax;
	u64 bx;
	u64 axi;
	u64 bxi;
	asu64(R1) = px;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2314;
	msysc_m$print_startcon();
	R1 = tou64("High block arg not copied in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("()");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L2312;
L2314:
	asi64(R1) = size;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = px;
	if (!asu64(R1)) goto L2316;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2315;
L2316:
	R1 = 0;
	R2 = 11;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
L2315:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = size;
	R3 = 0;
	R4 = 10;
	asu64(R5) = bx;
	R6 = 10;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asu64(R3) = mc_libmcl_mgenireg(asi64(R5), asi64(R4), asi64(R3));
	R4 = 0;
	R5 = 10;
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R4) = mc_libmcl_mgenireg(asi64(R6), asi64(R5), asi64(R4));
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = px;
	if (!asu64(R1)) goto L2318;
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2318:
	R1 = 0;
	mc_stackmcl_freeworkregs(asu64(R1));
L2312:
	return;
}

static void mc_auxmcl_fixmain() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 dn;
	u64 dargs;
	u64 denv;
	u64 dinfo;
	u64 ax;
	asu64(R1) = pc_decls_currfunc;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dn = asu64(R1);
	asu64(R1) = dn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dargs = asu64(R1);
	R1 = 3;
	R2 = tou64("$env");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	denv = asu64(R1);
	R1 = 6;
	asu64(R2) = denv;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = denv;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = tou64("$info");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	dinfo = asu64(R1);
	R1 = 11;
	asu64(R2) = dinfo;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 128;
	asu64(R2) = dinfo;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 8;
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = dinfo;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 128;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = denv;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 8;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = denv;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dinfo;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = R1;
	asu64(R3) = d;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = dargs;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = dn;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dn;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = dn;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = dargs;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dn;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = R2;
	ax = asu64(R3);
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dinfo;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dinfo;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dn;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dn;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dargs;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dargs;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = denv;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 13;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = denv;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	R2 = 14;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	R2 = tou64("__getmainargs*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 48;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	if (!asi64(R1)) goto L2321;
	R1 = 9;
	asi64(R2) = pc_decls_pcmdskip;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dn;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dargs;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2321:
	return;
}

static void mc_libmcl_mclinit(i64 bypass) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 r;
	i64 s;
	i64 av_1;
	i64 av_2;
	i64 i;
	R1 = 64;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2324;
	R1 = tou64("MCLREC>64B");
	mlib_abortprogram(asu64(R1));
L2324:
	R1 = 1;
	r = asi64(R1);
L2325:
	R1 = 1;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 2;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 4;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 4;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	r += 1; if (r <= 16) goto L2325;
	R1 = -128;
	i = asi64(R1);
	R1 = 64;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L2330;
L2328:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = i;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_frameregtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+1024)) = asu64(R1);
	i += 1; if (i <= av_1) goto L2328;
L2330:
	R1 = 6;
	R2 = 15;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dframeopnd = asu64(R1);
	R1 = 6;
	R2 = 16;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dstackopnd = asu64(R1);
	mc_libmcl_initmcdest();
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	mc_decls_lab_funcnametable = asi64(R1);
	R1 = 0;
	mc_decls_lab_funcaddrtable = asi64(R1);
	R1 = -1;
	i = asi64(R1);
	R1 = 10;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2333;
L2331:
	R1 = 8;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_libmcl_smallinttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L2331;
L2333:
	asi64(R1) = bypass;
	if (!asi64(R1)) goto L2335;
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
L2335:
	return;
}

static void mc_libmcl_initmcdest() {
    u64 R1, R2; 
	R1 = 0;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
	return;
}

static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 m;
	u64 oldm;
	i64 labno;
	R1 = 64;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	m = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_libmcl_mclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = m;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opcode;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2339;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2340;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2341;
	goto L2342;
L2339:
	asu64(R1) = b;
	if (!asu64(R1)) goto L2344;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2344;
	R1 = 1;
	asu64(R2) = b;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2344:
	goto L2338;
L2340:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	goto L2338;
L2341:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2347;
	asu64(R1) = b;
	if (!asu64(R1)) goto L2346;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2346;
L2347:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2349;
	R1 = 17;
	goto L2348;
L2349:
	R1 = 16;
L2348:
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2346:
	goto L2338;
L2342:
L2338:
	asu64(R1) = mc_decls_mccode;
	if (!asu64(R1)) goto L2351;
	asu64(R1) = mc_decls_mccodex;
	asu64(R2) = m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	mc_decls_mccodex = asu64(R1);
	goto L2350;
L2351:
	asu64(R1) = m;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
L2350:
	return;
}

static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = mc_decls_mccodex;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mc_libmcl_genmc_str(i64 opcode, u64 s) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = -1;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_newmclopnd() {
    u64 R1; 
	u64 a;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	a = asu64(R1);
	R1 = (u64)&mc_libmcl_nmclopnd;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	goto L2354;
L2354:
	return asu64(R1);
}

static u64 mc_libmcl_duplopnd(u64 a) {
    u64 R1, R2; struct $B3 R1_B3; 
	u64 b;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	b = asu64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = b;
	goto L2355;
L2355:
	return asu64(R1);
}

static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = areg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = areg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2359;
	asi64(R1) = ireg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2358;
L2359:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2358:
	asi64(R1) = ireg;
	asu64(R2) = a;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 5;
	R4 = 8;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = labno;
	if (!asi64(R1)) goto L2361;
	asi64(R1) = labno;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2360;
L2361:
	asu64(R1) = def;
	if (!asu64(R1)) goto L2362;
	asu64(R1) = def;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = def;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = def;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2365;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2364;
L2365:
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2364:
L2362:
L2360:
	asu64(R1) = a;
	goto L2356;
L2356:
	return asu64(R1);
}

static void mc_libmcl_mgencomment(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = 3;
	mc_libmcl_genmc_str(asi64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenstring(u64 s, i64 length) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2369;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2369:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = a;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2367;
L2367:
	return asu64(R1);
}

static u64 mc_libmcl_mgenname(u64 s) {
    u64 R1, R2, R3, R4; 
	struct $B37 str;
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2370;
L2370:
	return asu64(R1);
}

static void mc_libmcl_setsegment(i64 seg, i64 align) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 oldalign;
	asi64(R1) = seg;
	asi64(R2) = mc_decls_currsegment;
	if (asi64(R1) == asi64(R2)) goto L2373;
	asi64(R1) = seg;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L2375;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L2376;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L2377;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2378;
	goto L2379;
L2375:
	R1 = 121;
	opc = asi64(R1);
	goto L2374;
L2376:
	R1 = 122;
	opc = asi64(R1);
	goto L2374;
L2377:
	R1 = 123;
	opc = asi64(R1);
	goto L2374;
L2378:
	R1 = tou64("");
	R2 = tou64("CAN'T DO RODATA SEG");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2374;
L2379:
	R1 = tou64("");
	R2 = tou64("BAD SEG CODE");
	pc_api_merror(asu64(R2), asu64(R1));
L2374:
	asu64(R1) = mc_decls_mccodex;
	if (!asu64(R1)) goto L2381;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2382;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L2382;
	R2 = 123;
	if (asi64(R1) != asi64(R2)) goto L2381;
L2382:
	asi64(R1) = opc;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2380;
L2381:
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2380:
	asi64(R1) = seg;
	mc_decls_currsegment = asi64(R1);
L2373:
	asi64(R1) = align;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2384;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L2386;
	asu64(R1) = mc_decls_mccodex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldalign = asi64(R1);
	asi64(R1) = oldalign;
	asi64(R2) = align;
	if (asi64(R1) < asi64(R2)) goto L2388;
	goto L2371;
L2388:
L2386:
	R1 = 0;
	R2 = 10;
	asi64(R3) = align;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2384:
L2371:
	return;
}

static u64 mc_libmcl_changeopndsize(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L2391;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2393;
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	b = asu64(R1);
	goto L2392;
L2393:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2392:
	asu64(R1) = b;
	goto L2389;
L2391:
	asu64(R1) = a;
	goto L2389;
L2389:
	return asu64(R1);
}

static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2396;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2396;
	asu64(R1) = a;
	goto L2394;
L2396:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = b;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L2398;
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2398:
	asu64(R1) = b;
	goto L2394;
L2394:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint(i64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = x;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2401;
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2401;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2401;
	R1 = (u64)&mc_libmcl_smallinttable;
	asi64(R2) = x;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8+8));
	goto L2399;
L2401:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2399;
L2399:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint0(i64 x, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2402;
L2402:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2405;
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getrealindex(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2404;
L2405:
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getr32index(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2404:
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2403;
L2403:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asr64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2406;
L2406:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabel(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2409;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	x = asi64(R1);
L2409:
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2407;
L2407:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabelmem(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asi64(R1) = x;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2410;
L2410:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmem(u64 d, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2413;
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2415;
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenxregvar(asu64(R1));
	goto L2411;
	goto L2414;
L2415:
	asi64(R1) = mode;
	asu64(R2) = d;
	asu64(R1) = mc_libmcl_mgenregvar(asu64(R2), asi64(R1));
	goto L2411;
L2414:
L2413:
	R1 = 0;
	reg = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2418;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2417;
L2418:
	R1 = 15;
	reg = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2417:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	if (!asi64(R1)) goto L2420;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2419;
L2420:
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asu64(R1) = Min(asu64(R1), asu64(R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2419:
	asu64(R1) = a;
	goto L2411;
L2411:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmemaddr(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2421;
L2421:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg0(i64 reg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2424;
	R1 = tou64("");
	R2 = tou64("1:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2424:
	asu64(R1) = a;
	goto L2422;
L2422:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = xreg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2427;
	R1 = tou64("");
	R2 = tou64("2:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2427:
	asu64(R1) = a;
	goto L2425;
L2425:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg(i64 reg, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2430;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedxregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2429;
L2430:
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2432;
	R1 = 8;
	size = asi64(R1);
L2432:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2434;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2434;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2434:
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2428;
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
L2429:
	goto L2428;
L2428:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregi(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	R2 = (u64)&pc_tables_psize;
	asi64(R3) = mode;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2435;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	goto L2435;
L2435:
	return asu64(R1);
}

static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	goto L2436;
L2436:
	return asu64(R1);
}

static u64 mc_libmcl_mgentemp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	i64 size;
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2439;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	goto L2437;
L2439:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pcltempflags;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2437;
L2437:
	return asu64(R1);
}

static i64 mc_libmcl_roundsizetg(i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2442;
	asi64(R1) = size;
	goto L2440;
L2442:
	asi64(R1) = size;
	R2 = 8;
	asi64(R3) = size;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L2440;
L2440:
	return asi64(R1);
}

static void mc_libmcl_merroropnd(u64 mess, i64 opndtype) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MCL Opnd not supported: # (#) [#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asi64(R2) = opndtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 mc_libmcl_mcreatefwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L2444;
L2444:
	return asi64(R1);
}

static void mc_libmcl_mdefinefwdlabel(i64 lab) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenextname(u64 s) {
    u64 R1, R2, R3; 
	struct $B37 str;
	u64 d;
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mc_libmcl_findnamesym(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L2448;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	mc_libmcl_addnamesym(asu64(R1));
L2448:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	goto L2446;
L2446:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregvar(u64 d, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	goto L2449;
L2449:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxregvar(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 8;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2450;
L2450:
	return asu64(R1);
}

static i64 mc_libmcl_getprimreg(u64 ax) {
    u64 R1, R2; 
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2453;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L2452;
L2453:
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
L2452:
	goto L2451;
L2451:
	return asi64(R1);
}

static void mc_libmcl_pushslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) += asi64(R1);
	return;
}

static void mc_libmcl_popslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_popstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) -= asi64(R1);
	return;
}

static void mc_libmcl_pushstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2458;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2458:
	return;
}

static void mc_libmcl_popstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2461;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2461:
	return;
}

static i64 mc_libmcl_getstringindex(u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2464;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_kk0used = asi64(R1);
	asi64(R1) = mc_decls_kk0used;
	goto L2462;
L2464:
	asu64(R1) = mc_decls_cstringlist;
	if (!asu64(R1)) goto L2466;
	asu64(R1) = s;
	asu64(R2) = mc_decls_cstringlist;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2466;
	asu64(R1) = mc_decls_cstringlist;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2462;
L2466:
	asu64(R1) = s;
	R2 = (u64)&mc_decls_cstringlist;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2462;
L2462:
	return asi64(R1);
}

static i64 mc_libmcl_addconst(u64 clist, i64 value) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 24;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = clist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = clist;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	goto L2467;
L2467:
	return asi64(R1);
}

static i64 mc_libmcl_getrealindex(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	R2 = (u64)&mc_decls_creallist;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2468;
L2468:
	return asi64(R1);
}

static i64 mc_libmcl_getr32index(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	R2 = (u64)&mc_decls_cr32list;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2469;
L2469:
	return asi64(R1);
}

static i64 mc_libmcl_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L2471:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L2475;
	asi64(R1) = n;
	goto L2470;
L2475:
	if (--asi64(av_1)) goto L2471;
	R1 = 0;
	goto L2470;
L2470:
	return asi64(R1);
}

static void mc_libmcl_axerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("AX ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aapos;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static u64 mc_libmcl_newblocktemp(i64 size) {
    u64 R1, R2, R3; 
	struct $B3 str;
	u64 d;
	asi64(R1) = mc_decls_nblocktemps;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L2479;
	R1 = tou64("");
	R2 = tou64("Too many block temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2479:
	R1 = (u64)&mc_decls_nblocktemps;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$B#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_nblocktemps;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 8;
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 11;
	asu64(R2) = d;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = d;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pc_decls_currfunc;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_decls_blockdefs;
	asi64(R3) = mc_decls_nblocktemps;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	goto L2477;
L2477:
	return asu64(R1);
}

static u64 mc_libmcl_findnamesym(u64 s) {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2483;
L2481:
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2485;
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2480;
L2485:
	i += 1; if (i <= mc_libmcl_nnametable) goto L2481;
L2483:
	R1 = 0;
	goto L2480;
L2480:
	return asu64(R1);
}

static void mc_libmcl_addnamesym(u64 d) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 20;
	if (asi64(R1) >= asi64(R2)) goto L2488;
	asu64(R1) = d;
	R2 = (u64)&mc_libmcl_nametable;
	R3 = (u64)&mc_libmcl_nnametable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L2487;
L2488:
	R1 = tou64("");
	R2 = tou64("Ext nametab overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2487:
	return;
}

static void mc_libmcl_callproc(u64 cpname, u64 name, i64 lineno) {
	goto L2489;
L2489:
	return;
}

static u64 mc_libmcl_mgenstringx(u64 s) {
    u64 R1; 
	asu64(R1) = s;
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	goto L2490;
L2490:
	return asu64(R1);
}

static void mc_libmcl_clearreg(u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2493;
	R1 = 4;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2493:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2496;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2496;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2497;
	goto L2498;
L2496:
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2494;
	goto L2495;
L2497:
	asi64(R1) = mode;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgentemp(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	goto L2494;
	goto L2495;
L2498:
L2495:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2500;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2501;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2502;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2503;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2503;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2504;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2505;
	goto L2506;
L2500:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2508;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2508;
	R1 = 6;
	mode = asi64(R1);
	goto L2501;
	goto L2507;
L2508:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2507:
	goto L2499;
L2501:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2510;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2510;
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2509;
L2510:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2509:
	goto L2499;
L2502:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2512;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2513;
	goto L2514;
L2512:
	R1 = 65535;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L2511;
L2513:
	R1 = 4294967295;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L2511;
L2514:
L2511:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2516;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L2516;
	asu64(R1) = bx;
	ax = asu64(R1);
	goto L2515;
L2516:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2515:
	goto L2499;
L2503:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2499;
L2504:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2499;
L2505:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2499;
L2506:
// mc_stackmcl.getopnd.error:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = a;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("getopnd");
	pc_api_merror(asu64(R2), asu64(R1));
L2499:
	asu64(R1) = ax;
	goto L2494;
L2494:
	return asu64(R1);
}

static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2520;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2522;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L2522:
L2520:
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	goto L2518;
L2518:
	return asu64(R1);
}

static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg_m(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	goto L2523;
L2523:
	return asu64(R1);
}

static void mc_stackmcl_pushopnd(i64 n, i64 mode) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2526;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L2526:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2528;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2530;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2531;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2532;
	goto L2533;
L2530:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2535;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2536;
L2535:
	goto L2529;
L2531:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2538;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L2538;
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2536;
L2538:
	goto L2529;
L2532:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2536;
	goto L2529;
L2533:
L2529:
L2528:
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2540;
	asu64(R1) = ax;
	bx = asu64(R1);
	asi64(R1) = mode;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2542;
	R1 = 5;
	goto L2541;
L2542:
	R1 = 6;
L2541:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2540:
// mc_stackmcl.pushopnd.pushit:
L2536:
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&mc_decls_mstackdepth;
	(*toi64p(R1)) += 1;
	return;
}

static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2546;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2545;
L2546:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L2549;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L2548;
L2549:
	asu64(R1) = ax;
	goto L2543;
L2548:
L2545:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L2543;
L2543:
	return asu64(R1);
}

static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2553;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2552;
L2553:
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L2555;
	asu64(R1) = ax;
	goto L2550;
L2555:
L2552:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L2550;
L2550:
	return asu64(R1);
}

static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2558;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2558;
	asu64(R1) = ax;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2558;
	R1 = 4;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	goto L2557;
L2558:
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2557:
	return;
}

static void mc_stackmcl_pushpcl(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L2561;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2561:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2563;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2563;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2563:
	return;
}

static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L2566;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2566:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2568;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L2568:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2570;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2569;
L2570:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2569:
	return;
}

static void mc_stackmcl_poppcl() {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L2573;
	R1 = tou64("");
	R2 = tou64("poppcl/underflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2573:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2575;
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	R1 += (i64)R2-1;
	(*tou8p(R1)) -=1;
	goto L2571;
L2575:
	R1 = (u64)&mc_decls_noperands;
	(*toi64p(R1)) -=1;
L2571:
	return;
}

static void mc_stackmcl_duplpcl() {
    u64 R1, R2, R3, R4; 
	i64 mode;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 0;
	asi64(R3) = mode;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_stackmcl_getworkireg() {
    u64 R1, R2, R3; 
	i64 r;
	i64 av_1;
	R1 = 10;
	av_1 = asi64(R1);
L2578:
	R1 = 1;
	r = asi64(R1);
L2581:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2585;
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2585;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L2577;
L2585:
	r += 1; if (r <= 14) goto L2581;
	mc_stackmcl_savenextopnd();
	if (--asi64(av_1)) goto L2578;
	R1 = tou64("");
	R2 = tou64("No more work regs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L2577;
L2577:
	return asi64(R1);
}

static i64 mc_stackmcl_getworkxreg() {
    u64 R1, R2, R3; 
	i64 r;
	R1 = 5;
	r = asi64(R1);
L2587:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2591;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2591;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L2586;
L2591:
	r += 1; if (r <= 16) goto L2587;
	R1 = tou64("");
	R2 = tou64("No more work xregs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L2586;
L2586:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkregm(i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R2) = mode;
	asi64(R2) = mc_stackmcl_getworkreg(asi64(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2592;
L2592:
	return asu64(R1);
}

static i64 mc_stackmcl_getworkreg(i64 mode) {
    u64 R1, R2; 
	i64 reg;
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2595;
	asi64(R1) = mc_stackmcl_getworkxreg();
	goto L2594;
L2595:
	asi64(R1) = mc_stackmcl_getworkireg();
L2594:
	goto L2593;
L2593:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2599;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2598;
L2599:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L2596;
L2598:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2603;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2602;
L2603:
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2601;
L2602:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L2596;
L2601:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2596;
L2596:
	return asu64(R1);
}

static void mc_stackmcl_saveopnd(i64 n, i64 allregs) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 mode;
	u64 tx;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2606;
	goto L2604;
L2606:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2608;
	asi64(R1) = allregs;
	if (asi64(R1)) goto L2611;
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2612;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L2610;
L2612:
L2611:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2610:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2607;
L2608:
	asi64(R1) = allregs;
	if (asi64(R1)) goto L2615;
	asi64(R1) = reg;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2614;
	R2 = 6;
	if (asi64(R1) > asi64(R2)) goto L2614;
L2615:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2614:
	R1 = 0;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2607:
	R1 = 3;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2604:
	return;
}

static void mc_stackmcl_saveopnds(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2619;
L2617:
	R1 = 0;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L2617;
L2619:
	return;
}

static void mc_stackmcl_savenextopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2623;
L2621:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2625;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2625;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L2620;
L2625:
	i += 1; if (i <= mc_decls_noperands) goto L2621;
L2623:
L2620:
	return;
}

static void mc_stackmcl_savenextxopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2629;
L2627:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2631;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2631;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L2626;
L2631:
	i += 1; if (i <= mc_decls_noperands) goto L2627;
L2629:
L2626:
	return;
}

static void mc_stackmcl_movetoreg(i64 newreg) {
    u64 R1, R2, R3; 
	i64 oldreg;
	i64 mode;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
// mc_stackmcl.movetoreg.retry:
L2633:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	oldreg = asi64(R1);
	asi64(R1) = oldreg;
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L2635;
	goto L2632;
L2635:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2637;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2639;
	R1 = tou64("");
	R2 = tou64("MOVE TO REG: XREG IN USE");
	pc_api_merror(asu64(R2), asu64(R1));
L2639:
	goto L2636;
L2637:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2641;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2644;
L2642:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2646;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L2646;
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 6;
	asi64(R2) = newreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asi64(R3) = oldreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2633;
L2646:
	i += 1; if (i <= mc_decls_noperands) goto L2642;
L2644:
L2641:
L2636:
	asi64(R1) = mode;
	asi64(R2) = oldreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newreg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2648;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2647;
L2648:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2647:
L2632:
	return;
}

static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2651;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2653;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2656;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2655;
L2656:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	goto L2649;
L2655:
L2653:
L2651:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2658;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L2658:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L2649;
L2649:
	return asu64(R1);
}

static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2661;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L2661:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L2659;
L2659:
	return asu64(R1);
}

static void mc_stackmcl_swapopnds(i64 m, i64 n) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = m;
	R1 += (i64)R2*8-8;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	R2 += (i64)R3*8-8;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	return;
}

static u64 mc_stackmcl_isimmload(i64 n) {
    u64 R1, R2; 
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2665;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2665;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2665;
	asu64(R1) = p;
	goto L2664;
L2665:
	R1 = 0;
L2664:
	goto L2663;
L2663:
	return asu64(R1);
}

static void mc_stackmcl_setnewzz(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_stackmcl_freeworkregs(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 i;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2670;
L2668:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2672;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2674;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2673;
L2674:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2673:
L2672:
	i += 1; if (i <= mc_decls_noperands) goto L2668;
L2670:
	return;
}

static void mc_stackmcl_swapopndregs(i64 reg2) {
    u64 R1, R2, R3; 
	i64 reg1;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2677;
	R1 = tou64("");
	R2 = tou64("SOR1");
	pc_api_merror(asu64(R2), asu64(R1));
L2677:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg1 = asi64(R1);
	asi64(R1) = reg1;
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L2679;
	goto L2675;
L2679:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2683;
L2680:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2685;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L2685;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	goto L2675;
L2685:
	i += -1; if (i >= 1) goto L2680;
L2683:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg2;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2675:
	return;
}

static u64 mc_stackmcl_makeopndind(u64 a, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2688;
	R1 = tou64("");
	R2 = tou64("makeopndind");
	pc_api_merror(asu64(R2), asu64(R1));
L2688:
	R1 = 0;
	asi64(R2) = mode;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L2686;
L2686:
	return asu64(R1);
}

static u64 mc_stackmcl_makesimpleaddr(u64 ax) {
    u64 R1, R2, R3; 
	u64 bx;
	i64 newreg;
	i64 reg;
	i64 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2691;
	R1 = 0;
	reg = asi64(R1);
L2691:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2693;
	R1 = tou64("");
	R2 = tou64("MSA");
	pc_api_merror(asu64(R2), asu64(R1));
L2693:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2695;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2695;
	asi64(R1) = mc_stackmcl_getworkireg();
	newreg = asi64(R1);
	goto L2694;
L2695:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L2696;
	asu64(R1) = ax;
	goto L2689;
	goto L2694;
L2696:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L2697;
	asi64(R1) = regix;
	newreg = asi64(R1);
	goto L2694;
L2697:
	asi64(R1) = regix;
	newreg = asi64(R1);
L2694:
	R1 = 0;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L2689;
L2689:
	return asu64(R1);
}

static void mc_stackmcl_checkallloaded() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2701;
L2699:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2703;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2703;
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = i;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L2703:
	i += 1; if (i <= mc_decls_noperands) goto L2699;
L2701:
	return;
}

static u64 mc_stackmcl_stropndstack(i64 indent) {
    u64 R1, R2, R3; 
	struct $B20 str2;
	u64 s;
	u64 t;
	i64 fs;
	i64 i;
	i64 r;
	R1 = (u64)&mc_stackmcl_stropndstack_str;
	s = asu64(R1);
	asi64(R1) = indent;
	if (!asi64(R1)) goto L2706;
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("========================================#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L2705;
L2706:
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L2705:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2709;
L2707:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L2713;
	case 2: goto L2714;
	case 3: goto L2715;
	case 4: goto L2716;
	default: goto L2712;
    };
// SWITCH
L2713:
	R1 = tou64("Z:");
	goto L2710;
L2714:
	R1 = tou64("Y:");
	goto L2710;
L2715:
	R1 = tou64("X:");
	goto L2710;
L2716:
	R1 = tou64("W:");
	goto L2710;
L2712:
	R1 = tou64("");
L2710:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2718;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2718;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2719;
	goto L2720;
L2718:
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2722;
	R1 = (u64)&mc_decls_xregnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2721;
L2722:
	R1 = (u64)&mc_decls_regnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2721:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2724;
	R1 = tou64("*");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2724:
	goto L2717;
L2719:
	R1 = tou64("T");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = i;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2717;
L2720:
	R1 = tou64("(==");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu8(R1) = pc_api_fpshortnames;
	R1 = toi64(tou8(R1));
	fs = asi64(R1);
	R1 = 1;
	pc_api_fpshortnames = asu8(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = fs;
	pc_api_fpshortnames = asu8(R1);
	R1 = tou64(")");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2717:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2726;
	R1 = tou64("@");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2726:
	R1 = tou64("<");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pstdnames;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(">");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = mc_decls_noperands;
	if (asi64(R1) >= asi64(R2)) goto L2728;
	R1 = tou64(", ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2728:
	i += 1; if (i <= mc_decls_noperands) goto L2707;
L2709:
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 50;
	R3 = (u64)&mc_stackmcl_stropndstack_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("WR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
L2729:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2733;
	R1 = tou64("1 ");
	goto L2732;
L2733:
	R1 = tou64("0 ");
L2732:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= 10) goto L2729;
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("XWR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
	asi64(R1) = mc_decls_xregmax;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2736;
L2734:
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2738;
	R1 = tou64("1 ");
	goto L2737;
L2738:
	R1 = tou64("0 ");
L2737:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= mc_decls_xregmax) goto L2734;
L2736:
	R1 = tou64(") hwstack:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_mstackdepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" noperands:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ncalldepth:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_ncalldepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = s;
	goto L2704;
L2704:
	return asu64(R1);
}

static void mc_stackmcl_showopndstack() {
    u64 R1; 
	R1 = 1;
	asu64(R1) = mc_stackmcl_stropndstack(asi64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_optim_peephole() {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 m;
	u64 m2;
	u64 m3;
	i64 lab1;
	i64 lab2;
	asu8(R1) = pc_decls_fpeephole;
	if (asu8(R1)) goto L2742;
	goto L2740;
L2742:
	asu64(R1) = mc_decls_mccode;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L2746;
L2743:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m2 = asu64(R1);
	asu64(R1) = m2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m3 = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2748;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2749;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L2750;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L2751;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L2752;
	goto L2753;
L2748:
	goto L2745;
	goto L2747;
L2749:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2755;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L2756;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L2757;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L2758;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L2758;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L2759;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L2759;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L2760;
	goto L2761;
L2755:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2763;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2763;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2763;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L2765;
	goto L2764;
L2765:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (asi64(R1)) goto L2767;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2766;
L2767:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2766:
L2764:
	goto L2762;
L2763:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2768;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2768;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L2768;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L2768;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2768;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2768:
L2762:
	goto L2754;
L2756:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2770;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2771;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2771;
	R1 = 1;
	goto L2772;
L2771:
	R1 = 0;
L2772:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2770;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2770;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2770;
	R1 = 41;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L2770:
	goto L2754;
L2757:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2774;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2774;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2774;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2774;
	R1 = 42;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2774:
	goto L2754;
L2758:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2776;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2776;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2776;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isconst(asu64(R1));
	if (!asi64(R1)) goto L2776;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 28;
	if (asi64(R4) != asi64(R5)) goto L2778;
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	goto L2777;
L2778:
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	asi64(R4) = -asi64(R4);
L2777:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2776:
	goto L2754;
L2759:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2780;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2780;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2780;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 52;
	if (asi64(R4) != asi64(R5)) goto L2782;
	R4 = 1;
	goto L2781;
L2782:
	R4 = -1;
L2781:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2780:
	goto L2754;
L2760:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2784;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2784;
	R1 = 25;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2784:
	goto L2754;
L2761:
L2754:
	goto L2747;
L2750:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L2786;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2788;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2789;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2789;
	R1 = 1;
	goto L2790;
L2789:
	R1 = 0;
L2790:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2788;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2788;
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L2788:
L2786:
	goto L2747;
L2751:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2792;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2794;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2794;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2794;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2794;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2794;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = m;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L2794:
L2792:
	goto L2747;
L2752:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L2796;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L2796;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = m3;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L2796;
	asu64(R1) = m;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2796;
	R1 = (u64)&mc_decls_asmrevcond;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = m;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L2796:
	goto L2747;
L2753:
L2747:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L2746:
	asu64(R1) = m;
	if (asu64(R1)) goto L2743;
L2745:
L2740:
	return;
}

static i64 mc_optim_isreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L2797;
L2797:
	return asi64(R1);
}

static i64 mc_optim_isreg0(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L2800;
	R1 = 0;
	goto L2798;
L2800:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2802;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2802;
	R1 = 1;
	goto L2798;
L2802:
	R1 = 0;
	goto L2798;
L2798:
	return asi64(R1);
}

static i64 mc_optim_isreg10(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L2805;
	R1 = 0;
	goto L2803;
L2805:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2807;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2807;
	R1 = 1;
	goto L2803;
L2807:
	R1 = 0;
	goto L2803;
L2803:
	return asi64(R1);
}

static i64 mc_optim_isreg00(u64 m) {
    u64 R1, R2, R3; 
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2810;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2810;
	R1 = 1;
	goto L2808;
L2810:
	R1 = 0;
	goto L2808;
L2808:
	return asi64(R1);
}

static i64 mc_optim_isconst(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L2813;
	R1 = 0;
	goto L2811;
L2813:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2815;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2815;
	R1 = 1;
	goto L2811;
L2815:
	R1 = 0;
	goto L2811;
L2811:
	return asi64(R1);
}

static i64 mc_optim_sameoperand(u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 16;
	asu64(R2) = b;
	asu64(R3) = a;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L2816;
L2816:
	return asi64(R1);
}

static i64 mc_optim_sameregopnd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2820;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2819;
L2820:
	R1 = 0;
	goto L2817;
L2819:
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L2817;
L2817:
	return asi64(R1);
}

static u64 mc_optim_deletemcl(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L2824;
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2823;
L2824:
	R1 = tou64("");
	R2 = tou64("delmcl?");
	pc_api_merror(asu64(R2), asu64(R1));
L2823:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	goto L2821;
L2821:
	return asu64(R1);
}

static i64 mc_optim_endr0(u64 m) {
    u64 R1, R2; 
	asu64(R1) = m;
	R2 = 48;
	R1 += (i64)R2;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L2825;
L2825:
	return asi64(R1);
}

static void mc_genss_dummy_genss(i64 obj) {
	return;
}

static void mc_decls_start() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2830;
L2828:
	R1 = 10;
	R2 = (u64)&mc_decls_ploadop;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L2828;
L2830:
	R1 = 19;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 5;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 4;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 18;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 9;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 8;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 17;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 10;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mc_writegas_getassemstr() {
    u64 R1, R2; 
	u64 d;
	u64 e;
	u64 m;
	struct $B17 str2;
	struct $B17 str3;
	i64 i;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("# GAS VERSION\n");
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("    .code64\n");
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("    .intel_syntax prefix\n");
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("    .global main\n");
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L2835;
L2832:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2837;
	R1 = tou64("    .global ");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
L2837:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2835:
	asu64(R1) = d;
	if (asu64(R1)) goto L2832;
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L2839;
L2838:
	asu64(R1) = m;
	asi64(R2) = i;
	mc_writegas_writemcl(asi64(R2), asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L2839:
	asu64(R1) = m;
	if (asu64(R1)) goto L2838;
	asu64(R1) = pc_decls_pdest;
	goto L2831;
L2831:
	return asu64(R1);
}

static void mc_writegas_writemcl(i64 index, u64 mcl) {
    u64 R1, R2; 
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2843;
	goto L2844;
L2843:
	goto L2842;
L2844:
	asu64(R1) = mcl;
	mc_writegas_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
L2842:
	return;
}

static void mc_writegas_start() {
    u64 R1, R2, R3; 
	u8 flag;
	i64 av_1;
	i64 i;
	i64 r;
	i64 k;
	R1 = 1297301838;
	pc_decls_assemtype = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L2846:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2851;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2851;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2851;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2850;
L2851:
	R1 = 1;
	r = asi64(R1);
L2852:
	R1 = 0;
	flag = asu8(R1);
	R1 = 1;
	k = asi64(R1);
	R1 = 137;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2857;
L2855:
	asu8(R1) = flag;
	if (!asu8(R1)) goto L2859;
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L2861;
	R1 = (u64)&mc_decls_regindices;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = r;
	if (asi64(R1) != asi64(R2)) goto L2861;
	R1 = (u64)&mc_decls_dregnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_writegas_nregnames;
	asi64(R3) = i;
	R2 += (i64)R3*128-128;
	asi64(R3) = r;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2861:
	goto L2858;
L2859:
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2862;
	R1 = 1;
	flag = asu8(R1);
L2862:
L2858:
	k += 1; if (k <= av_1) goto L2855;
L2857:
	r += 1; if (r <= 16) goto L2852;
L2850:
	i += 1; if (i <= 8) goto L2846;
	return;
}

static void mc_writegas_strmcl(u64 mcl) {
    u64 R1, R2, R3; 
	struct $B36 opcname;
	u64 a;
	u64 b;
	i64 opcode;
	i64 cond;
	i64 sizepref;
	u64 s;
	u64 comment;
	u64 d;
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asu64(R1) = mcl;
	R2 = 34;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu64(R1) = mcl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = mcl;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	comment = asu64(R1);
	asi64(R1) = opcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2865;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2866;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2867;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2868;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2869;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2870;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L2871;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2872;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L2873;
	goto L2874;
L2865:
	R1 = tou64("# Proc ");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	goto L2863;
	goto L2864;
L2866:
	R1 = tou64("# End ");
	mc_writegas_asmstr(asu64(R1));
	R1 = 0;
	mc_decls_currasmproc = asu64(R1);
	goto L2863;
	goto L2864;
L2867:
	R1 = 8227;
	mc_writegas_asmchar(asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	goto L2863;
	goto L2864;
L2868:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L2876;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L2877;
	goto L2878;
L2876:
	asu64(R1) = d;
	asu64(R1) = mc_writegas_getdispname(asu64(R1));
	mc_writegas_asmstr(asu64(R1));
	goto L2875;
L2877:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	goto L2863;
	goto L2875;
L2878:
	R1 = tou64("");
	R2 = tou64("strmcl/lab");
	pc_api_merror(asu64(R2), asu64(R1));
L2875:
	R1 = tou64(":");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2880;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2882;
	goto L2881;
L2882:
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64(":");
	mc_writegas_asmstr(asu64(R1));
L2881:
L2880:
	goto L2863;
	goto L2864;
L2869:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L2884;
	R1 = (u64)&mc_writegas_strmcl_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("L#:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L2883;
L2884:
	goto L2868;
L2883:
	R1 = (u64)&mc_writegas_strmcl_str;
	mc_writegas_asmstr(asu64(R1));
	goto L2863;
	goto L2864;
L2870:
	R1 = tou64("    .set ");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64(", ");
	mc_writegas_asmstr(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L2863;
	goto L2863;
	goto L2864;
L2871:
	R1 = tou64("    .text");
	mc_writegas_asmstr(asu64(R1));
	R1 = 1;
	mc_writegas_currseg = asu8(R1);
	goto L2863;
	goto L2864;
L2872:
	R1 = tou64("    .data");
	mc_writegas_asmstr(asu64(R1));
	R1 = 2;
	mc_writegas_currseg = asu8(R1);
	goto L2863;
	goto L2864;
L2873:
	R1 = tou64("    .bss");
	mc_writegas_asmstr(asu64(R1));
	R1 = 3;
	mc_writegas_currseg = asu8(R1);
	goto L2863;
	goto L2864;
L2874:
L2864:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L2886;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L2887;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2888;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L2889;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2890;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L2891;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L2892;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2893;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L2894;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L2895;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2896;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2897;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L2898;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L2899;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L2900;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L2901;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L2902;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L2903;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L2904;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2905;
	goto L2906;
L2886:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("j");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L2885;
L2887:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("set");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L2885;
L2888:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("cmov");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L2885;
L2889:
	R1 = tou64("and");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2890:
	R1 = tou64("or");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2891:
	R1 = tou64("xor");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2892:
	R1 = tou64("not");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2893:
	R1 = tou64("imul");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2894:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2908;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2908;
	R1 = 4;
	asu64(R2) = a;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	R2 = R1;
	a = asu64(R2);
	asu64(R2) = mcl;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 11;
	opcode = asi64(R1);
L2908:
	goto L2906;
	goto L2906;
	goto L2885;
L2895:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2910;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2910;
	R1 = tou64("movsxd");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2909;
L2910:
	goto L2906;
	goto L2906;
L2909:
	goto L2885;
L2896:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2912;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2912;
	R1 = 17;
	opcode = asi64(R1);
L2912:
	goto L2906;
	goto L2906;
	goto L2885;
L2897:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2914;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2914;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2914;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2915;
	R2 = 2147483647;
	if (asi64(R1) <= asi64(R2)) goto L2914;
L2915:
	R1 = 17;
	asu64(R2) = mcl;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2914:
	goto L2906;
	goto L2906;
	goto L2885;
L2898:
	R1 = tou64(".align");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2899:
	R1 = tou64(".space");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2900:
	R1 = tou64(".byte");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2901:
	R1 = tou64(".word");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2902:
	R1 = tou64(".long");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2903:
	R1 = tou64(".quad");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2904:
	R1 = tou64(".ascii");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2885;
L2905:
	goto L2863;
	goto L2885;
L2906:
	asi64(R1) = opcode;
	R2 = 152;
	if (asi64(R1) <= asi64(R2)) goto L2917;
	R1 = 0;
	asi64(R2) = opcode;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2916;
L2917:
	R1 = (u64)&mc_decls_mclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 2;
	R1 += (i64)R2;
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L2916:
L2885:
	R1 = tou64(" ");
	R2 = 10;
	R3 = (u64)&opcname;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("  ");
	R2 = (u64)&mc_writegas_strmcl_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 4;
	R3 = (u64)&mc_writegas_strmcl_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&opcname;
	R2 = (u64)&mc_writegas_strmcl_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writegas_strmcl_str;
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L2919;
	asu64(R1) = b;
	if (!asu64(R1)) goto L2919;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	asi64(R1) = mc_writegas_needsizeprefix(asi64(R3), asu64(R2), asu64(R1));
	sizepref = asi64(R1);
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = a;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64(",\t");
	mc_writegas_asmstr(asu64(R1));
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = b;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = mcl;
	R2 = 32;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2921;
	R1 = tou64(",");
	mc_writegas_asmstr(asu64(R1));
	R1 = 0;
	asu64(R2) = mcl;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	mc_writegas_asmstr(asu64(R1));
L2921:
	goto L2918;
L2919:
	asu64(R1) = a;
	if (!asu64(R1)) goto L2922;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L2922;
	asi64(R1) = opcode;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L2924;
	asi64(R1) = opcode;
	R2 = 0;
	asu64(R3) = a;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L2923;
L2924:
	asi64(R1) = opcode;
	R2 = 1;
	asu64(R3) = a;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
L2923:
L2922:
L2918:
L2863:
	return;
}

static u64 mc_writegas_strmclstr(u64 m) {
    u64 R1, R2; 
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = m;
	mc_writegas_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L2925;
L2925:
	return asu64(R1);
}

static u64 mc_writegas_mstropnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3, R4; 
	struct $B36 str2;
	u64 plus;
	u64 t;
	i64 offset;
	i64 tc;
	R1 = 0;
	R2 = (u64)&mc_writegas_mstropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L2928;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L2929;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L2930;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L2931;
	goto L2932;
L2928:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writegas_strreg(asi64(R2), asi64(R1));
	goto L2926;
	goto L2927;
L2929:
	asi64(R1) = opcode;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L2934;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2934;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2936;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L2936;
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2935;
L2936:
	R1 = tou64("0x");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("H");
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2935:
	goto L2933;
L2934:
	asu64(R1) = a;
	asu64(R1) = mc_writegas_strvalue(asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L2933:
	goto L2927;
L2930:
	asi64(R1) = sizeprefix;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = mc_writegas_getsizeprefix(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("[");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2938;
	R1 = 8;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writegas_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
L2938:
	asu64(R1) = a;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2940;
	asu64(R1) = plus;
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = a;
	R3 = 11;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writegas_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2942;
	R1 = tou64("*");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 5;
	R4 = 8;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2942:
L2940:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2945;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2945;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2944;
L2945:
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	R3 = 11;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2947;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2947;
	R1 = tou64("%rip+");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2947:
	asu64(R1) = plus;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L2949;
	asu64(R1) = plus;
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2949:
	asu64(R1) = a;
	asu64(R1) = mc_writegas_strvalue(asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2943;
L2944:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L2950;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" + ");
	asi64(R2) = offset;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2950:
L2943:
	R1 = tou64("]");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2927;
L2931:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writegas_strxreg(asi64(R2), asi64(R1));
	goto L2926;
	goto L2927;
L2932:
	msysc_m$print_startcon();
	R1 = tou64("BAD OPND");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<BAD OPND>");
	goto L2926;
L2927:
	R1 = (u64)&mc_writegas_mstropnd_str;
	goto L2926;
L2926:
	return asu64(R1);
}

static u64 mc_writegas_strvalue(u64 a) {
    u64 R1, R2, R3; 
	struct $B36 str2;
	u64 def;
	i64 value;
	i64 offset;
	i64 length;
	u64 ss;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	def = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L2953;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L2954;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L2955;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L2956;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L2957;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L2958;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L2959;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L2960;
	goto L2961;
L2953:
	asu64(R1) = def;
	asu64(R1) = mc_writegas_getdispname(asu64(R1));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
// mc_writegas.strvalue.addoffset:
L2962:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L2964;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2966;
	R1 = tou64("+");
	goto L2965;
L2966:
	R1 = tou64("");
L2965:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = offset;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2964:
	goto L2952;
L2954:
	R1 = 0;
	asi64(R2) = value;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2952;
L2955:
	R1 = (u64)&mc_writegas_strvalue_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("20.20");
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	goto L2952;
L2956:
	R1 = tou64("M");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2952;
L2957:
	R1 = tou64("\"");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2952;
L2958:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2952;
L2959:
	R1 = tou64("L");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2962;
	goto L2952;
L2960:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_currasmproc;
	asu64(R1) = mc_writegas_gettempname(asu64(R2), asi64(R1));
	goto L2951;
	goto L2952;
L2961:
	R1 = tou64("");
	R2 = tou64("Stropnd?");
	pc_api_merror(asu64(R2), asu64(R1));
L2952:
	R1 = (u64)&mc_writegas_strvalue_str;
	goto L2951;
L2951:
	return asu64(R1);
}

static void mc_writegas_asmopnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	asi64(R2) = sizeprefix;
	asu64(R3) = a;
	asu64(R1) = mc_writegas_mstropnd(asu64(R3), asi64(R2), asi64(R1));
	mc_writegas_asmstr(asu64(R1));
	return;
}

static u64 mc_writegas_getxregname(i64 reg, i64 size) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2970;
	R1 = tou64("-");
	goto L2968;
L2970:
	R1 = (u64)&mc_writegas_getxregname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("%XMM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writegas_getxregname_str;
	goto L2968;
L2968:
	return asu64(R1);
}

static void mc_writegas_asmstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mc_writegas_asmchar(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_char(asu64(R2), asi64(R1));
	return;
}

static u64 mc_writegas_getdispname(u64 d) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = d;
	asu64(R1) = pc_api_getfullname(asu64(R2), asi64(R1));
	goto L2973;
L2973:
	return asu64(R1);
}

static u64 mc_writegas_gettempname(u64 d, i64 n) {
    u64 R1; 
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L2976;
	R1 = (u64)&mc_writegas_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L2975;
L2976:
	R1 = (u64)&mc_writegas_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.$T#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writegas_getdispname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L2975:
	R1 = (u64)&mc_writegas_gettempname_str;
	goto L2974;
L2974:
	return asu64(R1);
}

static u64 mc_writegas_strreg(i64 reg, i64 size) {
    u64 R1, R2; 
	R1 = tou64("%");
	R2 = (u64)&mc_writegas_strreg_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writegas_nregnames;
	asi64(R2) = size;
	R1 += (i64)R2*128-128;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_writegas_strreg_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writegas_strreg_str;
	goto L2977;
L2977:
	return asu64(R1);
}

static u64 mc_writegas_strxreg(i64 reg, i64 size) {
    u64 R1, R2; 
	u64 d;
	R1 = 1;
	asi64(R2) = reg;
	asu64(R1) = mc_writegas_checkregvar(asi64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2980;
	asu64(R1) = d;
	if (!asu64(R1)) goto L2980;
	asu64(R1) = d;
	asu64(R1) = mc_writegas_getdispname(asu64(R1));
	goto L2979;
L2980:
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_writegas_getxregname(asi64(R2), asi64(R1));
L2979:
	goto L2978;
L2978:
	return asu64(R1);
}

static i64 mc_writegas_needsizeprefix(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L2983;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L2983;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L2983;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L2983;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2984;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L2984;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L2984;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L2984;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L2985;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L2985;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L2985;
	goto L2986;
L2983:
	R1 = 1;
	goto L2981;
	goto L2982;
L2984:
	R1 = 1;
	goto L2981;
	goto L2982;
L2985:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2988;
	R1 = 1;
	goto L2981;
L2988:
	R1 = 0;
	goto L2981;
	goto L2982;
L2986:
L2982:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2991;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2991;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2991;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2990;
L2991:
	R1 = 0;
	goto L2981;
L2990:
	R1 = 1;
	goto L2981;
L2981:
	return asi64(R1);
}

static u64 mc_writegas_getsizeprefix(i64 size, i64 enable) {
    u64 R1, R2; 
	asi64(R1) = enable;
	if (asi64(R1)) goto L2994;
	R1 = tou64("");
	goto L2992;
L2994:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2996;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2997;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2998;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2999;
	goto L3000;
L2996:
	R1 = tou64("byte ptr");
	goto L2992;
	goto L2995;
L2997:
	R1 = tou64("word ptr");
	goto L2992;
	goto L2995;
L2998:
	R1 = tou64("dword ptr");
	goto L2992;
	goto L2995;
L2999:
	R1 = tou64("qword ptr");
	goto L2992;
	goto L2995;
L3000:
L2995:
	R1 = tou64("");
	goto L2992;
L2992:
	return asu64(R1);
}

static u64 mc_writegas_checkregvar(i64 reg, i64 ispfloat) {
    u64 R1; 
	u64 d;
	R1 = 0;
	goto L3001;
L3001:
	return asu64(R1);
}

static void mc_writeexe_dummy_genexe(u64 entrypoint, u64 outfile, i64 dodll) {
	return;
}

static void mc_writeexe_dummy_writeexe(u64 outfile, i64 dodll) {
	return;
}

static void mc_writeobj_dummy_writecoff(u64 outfile) {
	return;
}

static u64 mc_writess_dummy_writessdata(i64 fexe) {
    u64 R1; 
	R1 = 0;
	goto L3005;
L3005:
	return asu64(R1);
}

static void mx_run_dummy_runlibfile(u64 filename, i64 cmdskip) {
    u64 R1; 
	R1 = tou64("No Run");
	mlib_abortprogram(asu64(R1));
	return;
}

static void mx_run_dummy_writemcx(u64 filename) {
	return;
}

void cc_cli_main() {
    u64 R1, R2; 
	u64 file;
	pepcl_start();
	asi64(R1) = mnoos_os_clock();
	cc_cli_startclock = asi64(R1);
	asi64(R1) = cc_cli_startclock;
	pc_decls_pstartclock = asi64(R1);
	cc_cli_starttiming();
	cc_cli_initdata();
	cc_cli_getinputoptions();
	cc_cli_initsearchdirs();
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3010;
	cc_cli_showsearchdirs();
L3010:
	cc_cli_initlogfile();
	asi64(R1) = cc_cli_gettiming();
	cc_cli_inittime = asi64(R1);
	asu8(R1) = cc_cli_fverbose;
	if (!asu8(R1)) goto L3012;
	msysc_m$print_startcon();
	R1 = tou64("Compiling # to #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_cli_outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3012:
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	pc_decls_$pmodulename = asu64(R1);
	cc_cli_do_loadmodule();
	cc_cli_do_preprocess();
	cc_cli_do_parsemodule();
	cc_cli_do_genpcl();
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3014;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3015;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3016;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3017;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3018;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3019;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3020;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3021;
	goto L3022;
L3014:
	pc_run_dummy_pcl_runpcl();
	goto L3013;
L3015:
	cc_cli_do_genmcl();
	goto L3013;
L3016:
	cc_cli_do_asm();
	goto L3013;
L3017:
	cc_cli_do_obj();
	goto L3013;
L3018:
	cc_cli_do_dll();
	goto L3013;
L3019:
	cc_cli_do_exe();
	goto L3013;
L3020:
	cc_cli_do_mx();
	goto L3013;
L3021:
	cc_cli_do_run();
	goto L3013;
L3022:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L3024;
	msysc_m$print_startcon();
	R1 = (u64)&cc_cli_passnames;
	asu8(R2) = cc_cli_cc_pass;
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("not ready");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3024:
L3013:
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3026;
	msysc_m$print_startcon();
	R1 = tou64("Done.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3026:
	asu8(R1) = cc_cli_fshowtiming;
	if (!asu8(R1)) goto L3028;
	cc_cli_showtiming();
L3028:
	cc_cli_closelogfile();
	R1 = 0;
	exit(R1);
	R1 = 0;
	exit(R1);
	return;
}

static void cc_cli_do_preprocess() {
    u64 R1, R2, R3; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3031;
	asu8(R1) = cc_cli_fstdout;
	R1 = toi64(tou8(R1));
	asu64(R2) = cc_cli_outfile;
	asu64(R3) = cc_decls_inputfile;
	cc_lex_lex_preprocess_only(asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	exit(R1);
L3031:
	return;
}

static void cc_cli_do_loadmodule() {
    u64 R1, R2, R3; 
	u64 modulename;
	struct $B15 path;
	i64 status;
	i64 i;
	i64 flag;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3034;
	msysc_m$print_startcon();
	R1 = tou64("Loading:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3034:
	cc_cli_starttiming();
	R1 = tou64("<dummy file>");
	R2 = (u64)&cc_decls_sourcefilenames;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("<dummy path>");
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("<sourcefile0>");
	R2 = (u64)&cc_decls_sourcefiletext;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilesizes;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 2;
	R2 = tou64("$prog");
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	cc_decls_stprogram = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L3036;
	asu64(R1) = cc_decls_inputfile;
	R2 = tou64("Can't load main module: #");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3036:
	asu64(R1) = cc_decls_inputfile;
	asu64(R2) = cc_decls_inputfile;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	cc_decls_mainfileno = asi64(R1);
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	modulename = asu64(R1);
	R1 = 3;
	asu64(R2) = modulename;
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	asu64(R3) = cc_decls_stprogram;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	cc_decls_stmodule = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&path;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3038;
	R1 = (u64)&cc_decls_nsearchdirs;
	(*toi64p(R1)) += 1;
	asi64(R1) = cc_decls_nsearchdirs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3041;
L3039:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = (u64)&cc_decls_searchdirs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += -1; if (i >= 2) goto L3039;
L3041:
	R1 = (u64)&path;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3038:
	asi64(R1) = cc_cli_gettiming();
	cc_cli_loadtime = asi64(R1);
	return;
}

static void cc_cli_do_parsemodule() {
    u64 R1, R2; 
	i64 tt;
	cc_cli_starttiming();
	asi64(R1) = cc_parse_parsemodule();
	asi64(R1) = cc_cli_gettiming();
	R2 = R1;
	tt = asi64(R2);
	cc_cli_parsetime = asi64(R1);
	return;
}

static void cc_cli_do_genpcl() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) >= asi64(R2)) goto L3045;
	goto L3043;
L3045:
	cc_cli_starttiming();
	cc_genpcl_codegen_pcl();
	asi64(R1) = cc_cli_gettiming();
	cc_cli_pcltime = asi64(R1);
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L3048;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L3047;
L3048:
	pc_reduce_pcl_reducetest();
L3047:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3050;
	asu64(R1) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
L3050:
L3043:
	return;
}

static void cc_cli_do_genmcl() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) >= asi64(R2)) goto L3053;
	goto L3051;
L3053:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L3055;
	R1 = 16705;
	asu64(R2) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L3055:
L3051:
	return;
}

static void cc_cli_do_asm() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L3058;
	goto L3056;
L3058:
	R1 = 16705;
	asu64(R2) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L3056:
	return;
}

static void cc_cli_do_obj() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3061;
	goto L3059;
L3061:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writeobj(asu64(R1));
L3059:
	return;
}

static void cc_cli_do_dll() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3064;
	goto L3062;
L3064:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writedll(asu64(R1));
L3062:
	return;
}

static void cc_cli_do_exe() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3067;
	goto L3065;
L3067:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writeexe(asu64(R1));
L3065:
	return;
}

static void cc_cli_do_mx() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3070;
	goto L3068;
L3070:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writemx(asu64(R1));
L3068:
	return;
}

static void cc_cli_do_run() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3073;
	goto L3071;
L3073:
	pc_api_pcl_exec();
L3071:
	return;
}

static void cc_cli_initlogfile() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_debugmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3076;
	R1 = tou64("mcc.log");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("w");
	R2 = tou64("mcc.log");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	cc_decls_logdev = asu64(R1);
L3076:
	return;
}

static void cc_cli_closelogfile() {
    u64 R1, R2, R3; 
	struct $B5 str;
	i64 pos;
	asu8(R1) = cc_cli_debugmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L3079;
	goto L3077;
L3079:
	asu8(R1) = cc_cli_fshowmcl;
	if (!asu8(R1)) goto L3081;
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L3081;
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC ASM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 16705;
	R2 = 0;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3081:
	asu8(R1) = cc_cli_fshowpcl;
	if (!asu8(R1)) goto L3083;
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L3083;
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("!PROC PCL");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = cc_cli_fshowpst;
	if (!asu8(R1)) goto L3085;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
	asu64(R1) = cc_decls_logdev;
	R2 = tou64("PSYMTAB");
	cc_lib_addtolog(asu64(R2), asu64(R1));
L3085:
L3083:
	cc_cli_showast();
	asu8(R1) = cc_cli_fshowst;
	if (!asu8(R1)) goto L3087;
	R1 = tou64("ST");
	cc_cli_showst(asu64(R1));
L3087:
	asu8(R1) = cc_cli_fshowstflat;
	if (!asu8(R1)) goto L3089;
	R1 = tou64("STFLAT");
	cc_cli_showstflat(asu64(R1));
L3089:
	asu8(R1) = cc_cli_fshowtypes;
	if (!asu8(R1)) goto L3091;
	asu64(R1) = cc_decls_logdev;
	cc_show_printmodelist(asu64(R1));
L3091:
	asu64(R1) = cc_decls_logdev;
	asi32(R1) = fclose(asu64(R1));
	R1 = tou64("cc.m");
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3093;
	msysc_m$print_startcon();
	R1 = tou64("PRESS KEY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mnoos_os_getch();
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L3095;
	R1 = 0;
	exit(R1);
L3095:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\m\\scripts\\med.bat ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mcc.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&str;
	asi64(R1) = mnoos_os_execwait(asu64(R3), asi64(R2), asu64(R1));
	goto L3092;
L3093:
	msysc_m$print_startcon();
	R1 = tou64("Diagnostic outputs written to");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mcc.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3092:
L3077:
	return;
}

static void cc_cli_initdata() {
    u64 R1, R2, R3; 
	mlib_pcm_init();
	cc_lex_lexsetup();
	cc_lib_inittypetables();
	cc_lib_initcclib();
	R1 = 0;
	cc_decls_nlibfiles = asi64(R1);
	R1 = tou64("msvcrt");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("gdi32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("user32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("kernel32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_cli_cgetsourceinfo;
	pc_decls_igetmsourceinfo = asu64(R1);
	return;
}

static i64 cc_cli_cgetsourceinfo(i64 pos, u64 filename, u64 sourceline) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = pos;
	R3 = 24;
	R4 = 32;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = filename;
	*tou64p(R2) = asu64(R1);
	R1 = tou64("<line>");
	asu64(R2) = sourceline;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pos;
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3097;
L3097:
	return asi64(R1);
}

static void cc_cli_initsearchdirs() {
    u64 R1, R2, R3; 
	struct $B15 str1;
	struct $B15 str2;
	i64 i;
	R1 = tou64("");
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = tou64("c:/cx/headers/");
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mnoos_os_gethostname();
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3101;
L3099:
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L3103;
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3103:
	i += 1; if (i <= cc_decls_nincludepaths) goto L3099;
L3101:
	return;
}

static void cc_cli_showsearchdirs() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Include search paths:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = cc_cli_dointheaders;
	if (!asu8(R1)) goto L3106;
	msysc_m$print_startcon();
	R1 = tou64("0: Internal standard headers (disable with -ext)");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3106:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsearchdirs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3109;
L3107:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L3111;
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3110;
L3111:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": .");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3110:
	i += 1; if (i <= cc_decls_nsearchdirs) goto L3107;
L3109:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showast() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_fshowast;
	if (!asu8(R1)) goto L3114;
	R1 = tou64("PROC AST");
	asu64(R2) = cc_decls_logdev;
	cc_show_printcode(asu64(R2), asu64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3114:
	return;
}

static void cc_cli_showstflat(u64 caption) {
    u64 R1; 
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	cc_show_printstflat(asu64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showst(u64 caption) {
    u64 R1, R2, R3; 
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = cc_decls_stmodule;
	asu64(R3) = cc_decls_logdev;
	cc_show_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showfiles() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Sourcefiles:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3120;
L3118:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilesizes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nsourcefiles) goto L3118;
L3120:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showtime(u64 caption, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("# # ms # %");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = caption;
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("5");
	asi64(R2) = t;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("5.1jr");
	asi64(R2) = t;
	asr64(R2) = tor64(asi64(R2));
	asr64(R3) = 1.000000000000000000e+002;
	asr64(R2) *= asr64(R3);
	asi64(R3) = cc_cli_compiletime;
	asr64(R3) = tor64(asi64(R3));
	asr64(R2) /= asr64(R3);
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showtiming() {
    u64 R1, R2; 
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = cc_cli_startclock;
	asi64(R1) -= asi64(R2);
	cc_cli_compiletime = asi64(R1);
	asi64(R1) = cc_cli_inittime;
	R2 = tou64("Init:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_loadtime;
	R2 = tou64("Load:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_parsetime;
	R2 = tou64("Parse:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_pcltime;
	R2 = tou64("PCL:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_mcltime;
	R2 = tou64("MCL:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_sstime;
	R2 = tou64("SS:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_exetime;
	R2 = tou64("EXE:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("-----------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = cc_cli_compiletime;
	R2 = tou64("Total:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	return;
}

static void cc_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 j;
	i64 k;
	i64 paramno;
	i64 pmtype;
	i64 sw;
	i64 ncolons;
	u64 name;
	u64 value;
	u64 ext;
	i64 av_1;
	R1 = 1;
	paramno = asi64(R1);
	R1 = 0;
	ncolons = asi64(R1);
	asu8(R1) = pepcl_pc_userunpcl;
	if (!asu8(R1)) goto L3125;
	R1 = 6;
	cc_cli_cc_pass = asu8(R1);
	R1 = 0;
	cc_cli_fverbose = asu8(R1);
L3125:
	R1 = tou64("cs.exe");
	asu64(R2) = mnoos_os_gethostname();
	asu64(R2) = mlib_extractfile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3127;
	R1 = 0;
	cc_cli_fverbose = asu8(R1);
	R1 = tou64("");
	R2 = 17;
	cc_cli_do_option(asi64(R2), asu64(R1));
L3127:
L3128:
	R1 = tou64(".c");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	pmtype = asi64(R1);
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3131;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3132;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3133;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3134;
	goto L3135;
L3131:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 49;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3139;
L3136:
	R1 = (u64)&cc_cli_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3141;
	asu64(R1) = value;
	asi64(R2) = sw;
	cc_cli_do_option(asi64(R2), asu64(R1));
	goto L3138;
L3141:
	sw += 1; if (sw <= av_1) goto L3136;
L3139:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L3138:
	goto L3130;
L3132:
	asu64(R1) = cc_decls_inputfile;
	if (!asu64(R1)) goto L3143;
	R1 = tou64("");
	R2 = tou64("One input file only");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3143:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_decls_inputfile = asu64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3146;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3145;
L3146:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	cc_cli_cmdskip = asi64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 6;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	cc_decls_pci_target = asu8(R1);
	goto L3129;
L3145:
	goto L3130;
L3133:
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 200;
	if (asi64(R1) < asi64(R2)) goto L3148;
	R1 = tou64("");
	R2 = tou64("Too many lib files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3148:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L3130;
L3134:
	goto L3129;
	goto L3130;
L3135:
L3130:
	goto L3128;
L3129:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3150;
	R1 = 12;
	cc_cli_cc_pass = asu8(R1);
	asu8(R1) = pepcl_asmonly;
	if (!asu8(R1)) goto L3152;
	R1 = 8;
	cc_cli_cc_pass = asu8(R1);
L3152:
L3150:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3155;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3154;
L3155:
	R1 = 2;
	cc_cli_highmem = asu8(R1);
	goto L3153;
L3154:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3157;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L3156;
L3157:
	R1 = 0;
	cc_cli_highmem = asu8(R1);
L3156:
L3153:
	R1 = (u64)&cc_cli_extnames;
	asu8(R2) = cc_cli_cc_pass;
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	cc_cli_outext = asu64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3160;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3159;
L3160:
	asu64(R1) = mc_writegas_asmext;
	cc_cli_outext = asu64(R1);
L3159:
	asu64(R1) = cc_decls_inputfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3162;
	asu8(R1) = cc_cli_fwriteheaders;
	if (asu8(R1)) goto L3162;
	cc_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("   prog[.c]          Compile prog.c to prog.exe");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-r prog[.c]          Compile prog.c and run");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-i prog[.c]          Compile prog.c and interpret");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-help                Show all options");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L3162:
	asu8(R1) = cc_cli_fwriteheaders;
	if (!asu8(R1)) goto L3164;
	cc_headers_writeheaders();
	R1 = 20;
	exit(R1);
L3164:
	asu64(R1) = cc_cli_outfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3166;
	asu64(R1) = cc_cli_outext;
	asu64(R2) = cc_decls_inputfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_cli_outfile = asu64(R1);
L3166:
	asu8(R1) = cc_cli_fshortnames;
	R1 = toi64(tou8(R1));
	R2 = -1;
	asu8(R3) = cc_cli_highmem;
	R3 = toi64(tou8(R3));
	pc_api_pcl_setflags(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cc_cli_cmdskip;
	pc_api_pcl_cmdskip(asi64(R2), asu64(R1));
	return;
}

static void cc_cli_do_option(i64 sw, u64 value) {
    u64 R1, R2, R3; 
	struct $B15 str;
	i64 length;
	u64 p;
	R1 = (u64)&cc_cli_optvars;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L3169;
	R1 = (u64)&cc_cli_optvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sw;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3171;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L3171;
	R1 = 1;
	R2 = (u64)&cc_cli_debugmode;
	*tou8p(R2) |= asu8(R1);
L3171:
	asi64(R1) = sw;
	R2 = 25;
	if (asi64(R1) < asi64(R2)) goto L3173;
	R2 = 33;
	if (asi64(R1) > asi64(R2)) goto L3173;
	R1 = 2;
	R2 = (u64)&cc_cli_debugmode;
	*tou8p(R2) |= asu8(R1);
L3173:
	asi64(R1) = sw;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3175;
	asu64(R1) = cc_decls_inputfile;
	if (!asu64(R1)) goto L3175;
	R1 = tou64("");
	R2 = tou64("-RUNP OUT OF ORDER");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3175:
	asi64(R1) = sw;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3178;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L3177;
L3178:
	R1 = 1;
	cc_decls_pci_target = asu8(R1);
L3177:
	goto L3167;
L3169:
	asi64(R1) = sw;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L3180;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3181;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L3181;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L3182;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L3183;
	goto L3184;
L3180:
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L3186;
	R1 = tou64("");
	R2 = tou64("Too many include paths");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3186:
	asu64(R1) = value;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = value;
	asi64(R2) = length;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L3188;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L3188;
	goto L3189;
L3188:
	goto L3187;
L3189:
	asu64(R1) = value;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	value = asu64(R1);
L3187:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_includepaths;
	R3 = (u64)&cc_decls_nincludepaths;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L3179;
L3181:
	cc_cli_showhelp();
	goto L3179;
L3182:
	asu64(R1) = cc_cli_outext;
	asu64(R2) = value;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_cli_outfile = asu64(R1);
	goto L3179;
L3183:
	R1 = 0;
	R2 = R1;
	pc_decls_fpeephole = asu8(R2);
	pc_decls_fregoptim = asu8(R1);
	goto L3179;
L3184:
L3179:
L3167:
	return;
}

static void cc_cli_showincludepaths() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Include paths");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nincludepaths;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3193;
L3191:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nincludepaths) goto L3191;
L3193:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showhelp() {
    u64 R1; 
	cc_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("C Subset Compiler for 64-bit Windows\n\nNormal use:           Compiles prog.c to:\n\n    cc      prog      prog.exe (default)\n    cc -r   prog      in-memory native code then execute\n    cc -i   prog      in-memory IL then interpret\n\n    cc -exe prog      prog.exe\n    cc -dll prog      prog.dll\n    cc -obj prog      prog.obj\n    cc -a   prog      prog.asm\n    cc -n   prog      prog.nasm\n    cc -mx  prog      prog.mx\n    cc -p   prog      prog.pcl (textual IL)\n    cc -e   prog      prog.i   (preprocess only)\n\nOther options:\n\n    -incl:path        Add path to search for includes\n    -ext              Used std headers external to compiler\n    -opt              Optimise native code\n    -out:file         Name output file (extension can be added)\n    -rip              Use RIP address modes\n    -himem            Generate PIC code (automatic with -obj/-dll)\n    @file             Read files and options from a file\n    file.dll          Include one or more extra dynamic libs\n    -c                Same as -obj\n    -s                Same as -asm\n    -ei               Same as -e, but when result is interpreted\n\nNotes:\n\n    * Compiles single module only (use bcc driver program for multiple-modules)\n    * For -i and -r, options and any .dlls must appear before the C source file\n    * .c extension is optional on input file\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 23;
	exit(R1);
	return;
}

static void cc_cli_showextrainfo() {
    u64 R1; 
// PROC LOCAL STATICS GO HERE
	static u64 cc_cli_showextrainfo_infotext = (u64)"    The 'MCC' C Compiler comprises:\n\n    mcc.exe            Compiles to .asm files\n    aa.exe             Assembles .asm files to .obj files\n                       Assemblers and links .asm/.dll files to .exe\n    Standard headers   A minimal set inside mcc.exe\n    windows.h          As a standalone file\n\n    Input files:\n\n      prog             This is prog.c as the extension is optional\n      prog.c\n      lib.dll          Include .dll library when generating .exe\n      @file            Read parameters and optons from given file\n\n    Options:\n\n      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files\n      -e               Preprocess each module to .i file\n      -s               Compile each module to .asm file\n      -c               Compile each module .obj via .asm\n\n      -out:file        Specify output file for -exe only\n\n    For .exe output, it will be named based on the first input file. Otherwise\n    use -out option\n\n    .obj files can be linked using gcc on Windows. This option is\n    needed to be able to generate .dll files. However, this will not\n    work on newer gcc versions because mcc's generated code is not position\n    independent, and will only work loaded in the low 2GB of address space.\n\n    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are\n    automatically included as search libraries for imported functions.\n\n    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported.\n\n    Omissions, Restrictions and Bugs (highlights only as there are dozens):\n\n      * No VLAs, compound literals, designated initialisers\n      * Restrictions on complexity of data initialisers\n";
	msysc_m$print_startcon();
	asu64(R1) = cc_cli_showextrainfo_infotext;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 24;
	exit(R1);
	return;
}

static void cc_cli_showcaption() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("CC C Compiler");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("28-Sep-2025");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("17:24:38");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_starttiming() {
    u64 R1; 
	asi64(R1) = mnoos_os_clock();
	cc_cli_ttt = asi64(R1);
	return;
}

static i64 cc_cli_gettiming() {
    u64 R1, R2; 
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = cc_cli_ttt;
	asi64(R1) -= asi64(R2);
	goto L3198;
L3198:
	return asi64(R1);
}

static void cc_lex_lex_preprocess_only(u64 infile, u64 outfile, i64 toconsole) {
    u64 R1, R2, R3; 
	u64 psource;
	i64 ntokens;
	i64 nlines;
	i64 fileno;
	i64 size;
	i64 length;
	i64 nchars;
	i64 t;
	i64 hashtot;
	i64 symtot;
	r64 tsecs;
	u64 f;
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_lex_preprocess_only_dest = (u64)&cc_lex_lex_preprocess_only_sbuffer;
	R1 = 1;
	cc_lex_dowhitespace = asi64(R1);
	asu64(R1) = infile;
	asu64(R2) = infile;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	fileno = asi64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	psource = asu64(R1);
	R1 = (u64)&cc_decls_sourcefilesizes;
	asi64(R2) = fileno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	R1 = 0;
	R2 = R1;
	ntokens = asi64(R2);
	nlines = asi64(R1);
	R1 = 0;
	R2 = R1;
	symtot = asi64(R2);
	hashtot = asi64(R1);
	asi64(R1) = mnoos_os_clock();
	t = asi64(R1);
	asu64(R1) = cc_lex_lex_preprocess_only_dest;
	cc_lex_destcopy = asu64(R1);
	asu64(R1) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = psource;
	cc_lex_lxsptr = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	cc_lex_lxstart = asu64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	cc_lex_setfileno(asi64(R1));
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 1;
	R2 = tou64("mcc.h");
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3200:
	cc_lex_lexm();
	R1 = (u64)&ntokens;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	R3 = (u64)&cc_decls_nextlx;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L3200;
	asi64(R1) = cc_lex_ifcondlevel;
	if (!asi64(R1)) goto L3204;
	R1 = tou64("#endif missing");
	cc_lex_lxerror(asu64(R1));
L3204:
	R1 = (u64)&cc_lex_showtokens;
	if (!asu64(R1)) goto L3206;
	asi64(R1) = toconsole;
	if (!asi64(R1)) goto L3208;
	R1 = 0;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	goto L3207;
L3208:
	R1 = tou64("wb");
	asu64(R2) = outfile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L3207:
L3206:
	return;
}

static void cc_lex_lexreadtoken() {
    u64 R1, R2, R3, R4, R5; 
	u64 c;
	u64 csum;
	u64 hsum;
	u64 dodir;
	u64 p;
	u64 ss;
	u64 searchstr;
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3211;
L3210:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L3211:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L3210;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3210;
L3213:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L3350;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 96: case 127: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: goto L3216;
	case 9: case 32: goto L3335;
	case 10: goto L3336;
	case 12: goto L3354;
	case 13: goto L3344;
	case 33: goto L3345;
	case 34: goto L3334;
	case 35: goto L3243;
	case 36: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L3217;
	case 37: goto L3307;
	case 38: goto L3328;
	case 39: goto L3333;
	case 40: goto L3273;
	case 41: goto L3274;
	case 42: goto L3298;
	case 43: goto L3287;
	case 44: goto L3267;
	case 45: goto L3292;
	case 46: goto L3259;
	case 47: goto L3301;
	case 48: goto L3234;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3230;
	case 58: goto L3269;
	case 59: goto L3268;
	case 60: goto L3314;
	case 61: goto L3310;
	case 62: goto L3321;
	case 63: goto L3285;
	case 64: goto L3349;
	case 91: goto L3275;
	case 92: goto L3247;
	case 93: goto L3276;
	case 94: goto L3282;
	case 123: goto L3257;
	case 124: goto L3277;
	case 125: goto L3258;
	case 126: goto L3286;
	case 239: goto L3355;
	default: goto L3216;
    };
// SWITCH
L3217:
// cc_lex.lexreadtoken.doname:
L3218:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_lxsvalue = asu64(R1);
	asu64(R1) = cc_lex_lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	hsum = asu64(R1);
	goto L3220;
L3219:
	asu64(R1) = hsum;
	R2 = 4;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	asu64(R2) = c;
	asu64(R1) += asu64(R2);
	hsum = asu64(R1);
L3220:
	R1 = (u64)&cc_lex_alphamap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = R2;
	c = asu64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3219;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = c;
	R2 = 39;
	if (asu64(R1) == asu64(R2)) goto L3223;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L3223;
	goto L3224;
L3223:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3226;
	asu64(R1) = cc_lex_lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L3228;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L3228;
	R2 = 117;
	if (asu64(R1) == asu64(R2)) goto L3228;
	R2 = 85;
	if (asu64(R1) == asu64(R2)) goto L3228;
	goto L3229;
L3228:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	asu64(R2) = c;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L3209;
	goto L3227;
L3229:
L3227:
L3226:
	goto L3222;
L3224:
L3222:
	asu64(R1) = hsum;
	R2 = 5;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	cc_lex_lxhashvalue = asi64(R1);
	asi64(R1) = cc_lex_lookup();
	goto L3209;
	goto L3213;
L3230:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3232;
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L3232;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3232;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L3232;
	R2 = 59;
	if (asu64(R1) == asu64(R2)) goto L3232;
	goto L3233;
L3232:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	goto L3231;
L3233:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readdecimal(asu64(R1));
L3231:
	goto L3209;
	goto L3213;
L3234:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 10: case 13: case 32: case 38: case 41: case 44: case 58: case 59: case 61: case 63: case 93: case 125: goto L3242;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 33: case 34: case 35: case 36: case 37: case 39: case 40: case 42: case 43: case 45: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 60: case 62: case 64: case 65: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 89: case 90: case 91: case 92: case 94: case 95: case 96: case 97: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 118: case 119: case 121: case 122: case 123: case 124: goto L3237;
	case 46: goto L3240;
	case 66: case 98: goto L3239;
	case 76: case 85: case 108: case 117: goto L3241;
	case 88: case 120: goto L3238;
	default: goto L3237;
    };
// SWITCH
L3238:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	cc_lex_readhex(asu64(R1));
	goto L3209;
	goto L3235;
L3239:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	cc_lex_readbinary(asu64(R1));
	goto L3209;
	goto L3235;
L3240:
	R1 = 10;
	R2 = 1;
	asu64(R3) = cc_lex_lxsptr;
	R4 = 1;
	R3 -= (i64)R4;
	asu64(R4) = cc_lex_lxsptr;
	R5 = 1;
	R4 -= (i64)R5;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3209;
	goto L3235;
L3241:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readdecimal(asu64(R1));
	goto L3209;
	goto L3235;
L3242:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	goto L3209;
	goto L3235;
L3237:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readoctal(asu64(R1));
	goto L3209;
L3235:
	goto L3213;
L3243:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L3245;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3244;
L3245:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) != asu64(R2)) goto L3246;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 7;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3244;
L3246:
	R1 = 5;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
L3244:
	goto L3213;
L3247:
L3248:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3250;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3250;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3251;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L3251;
	goto L3252;
L3250:
	goto L3249;
	goto L3248;
L3251:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3248;
L3252:
	R1 = 22;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3248;
L3249:
	R1 = 32;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3254;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3255;
	goto L3256;
L3254:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 32;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3253;
L3255:
	R1 = 32;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3253;
L3256:
L3253:
	goto L3213;
L3257:
	R1 = 17;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3258:
	R1 = 18;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3259:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 46: goto L3263;
	case 47: goto L3262;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3266;
	default: goto L3262;
    };
// SWITCH
L3263:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L3265;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 21;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3264;
L3265:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
L3264:
	goto L3209;
	goto L3260;
L3266:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	R2 = 0;
	asu64(R3) = cc_lex_lxsptr;
	asu64(R4) = cc_lex_lxsptr;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3209;
	goto L3260;
L3262:
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
L3260:
	goto L3213;
L3267:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3268:
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3269:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3271;
	goto L3272;
L3271:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3270;
L3272:
	R1 = 10;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3270:
	goto L3209;
	goto L3213;
L3273:
	R1 = 13;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3274:
	R1 = 14;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3275:
	R1 = 15;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3276:
	R1 = 16;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3277:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 124;
	if (asu64(R1) == asu64(R2)) goto L3279;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3280;
	goto L3281;
L3279:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 31;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3278;
L3280:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 51;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3278;
L3281:
	R1 = 28;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3278:
	goto L3209;
	goto L3213;
L3282:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3284;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 53;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3283;
L3284:
	R1 = 30;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3283:
	goto L3209;
	goto L3213;
L3285:
	R1 = 19;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3286:
	R1 = 35;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3287:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L3289;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3290;
	goto L3291;
L3289:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 37;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3288;
L3290:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 46;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3288;
L3291:
	R1 = 23;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3288:
	goto L3209;
	goto L3213;
L3292:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L3294;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L3295;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3296;
	goto L3297;
L3294:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 38;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3293;
L3295:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3293;
L3296:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 47;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3293;
L3297:
	R1 = 24;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3293:
	goto L3209;
	goto L3213;
L3298:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3300;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 48;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3299;
L3300:
	R1 = 25;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3299:
	goto L3209;
	goto L3213;
L3301:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L3303;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L3304;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3305;
	goto L3306;
L3303:
	cc_lex_readlinecomment();
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3209;
	goto L3302;
L3304:
	cc_lex_readblockcomment();
	goto L3302;
L3305:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 49;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3302;
L3306:
	R1 = 26;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
L3302:
	goto L3213;
L3307:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3309;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 50;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3308;
L3309:
	R1 = 27;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3308:
	goto L3209;
	goto L3213;
L3310:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3312;
	goto L3313;
L3312:
	R1 = 40;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3311;
L3313:
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3311:
	goto L3209;
	goto L3213;
L3314:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3316;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L3317;
	goto L3318;
L3316:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 43;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3315;
L3317:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3320;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 54;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3319;
L3320:
	R1 = 33;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3319:
	goto L3315;
L3318:
	R1 = 42;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3315:
	goto L3209;
	goto L3213;
L3321:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3323;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L3324;
	goto L3325;
L3323:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 44;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3322;
L3324:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3327;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 55;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3326;
L3327:
	R1 = 34;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3326:
	goto L3322;
L3325:
	R1 = 45;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3322:
	goto L3209;
	goto L3213;
L3328:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L3330;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3331;
	goto L3332;
L3330:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 32;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3329;
L3331:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 52;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3329;
L3332:
	R1 = 29;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3329:
	goto L3209;
	goto L3213;
L3333:
	R1 = 0;
	R2 = 39;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L3209;
	goto L3213;
L3334:
	R1 = 0;
	R2 = 34;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L3209;
	goto L3213;
L3335:
	goto L3213;
L3336:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_dowhitespace;
	if (!asi64(R1)) goto L3338;
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3339:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 9: case 32: goto L3343;
	case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: goto L3342;
	default: goto L3342;
    };
// SWITCH
L3343:
	goto L3339;
L3342:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3340;
	goto L3339;
L3340:
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3338:
	goto L3209;
	goto L3213;
L3344:
	goto L3213;
L3345:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3347;
	goto L3348;
L3347:
	R1 = 41;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3346;
L3348:
	R1 = 36;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3346:
	goto L3209;
	goto L3213;
L3349:
	msysc_m$print_startcon();
	R1 = tou64("@ SEEN");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_lex_lx_stackindex;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3213;
L3350:
// cc_lex.lexreadtoken.doeof:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = cc_lex_lx_stackindex;
	if (!asi64(R1)) goto L3353;
	cc_lex_unstacksourcefile();
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3352;
L3353:
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3352:
	goto L3209;
	goto L3213;
L3354:
	goto L3213;
L3355:
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	goto L3213;
L3216:
	R1 = 128;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3357;
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L3357;
	goto L3218;
L3357:
	msysc_m$print_startcon();
	R1 = tou64("ERROR CHAR");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = cc_lex_lx_stackindex;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("ERROR CHAR");
	cc_lex_lxerror(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3209;
	goto L3213;
L3209:
	return;
}

static void cc_lex_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base) {
    u64 R1, R2, R3, R4; 
	u64 fractstart;
	i64 fractlen;
	i64 expon;
	i64 i;
	i64 c;
	i64 badexpon;
	i64 n;
	i64 adj;
	r64 basex;
	r64 x;
	r64 expbase;
	r64 f;
	r64 y;
	r64 y2;
	r64 g;
	i64 aa;
	i64 cc;
	i64 pref;
	struct $B20 realstr;
	u64 rs;
	struct $B17 expstr;
	u64 xx1;
	u64 xx2;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3360;
	asi64(R1) = base;
	asi64(R2) = intlen;
	asu64(R3) = intstart;
	asu64(R4) = pstart;
	cc_lex_old_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3358;
L3360:
	R1 = 0;
	fractstart = asu64(R1);
	R1 = 0;
	fractlen = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L3362;
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	fractstart = asu64(R1);
	asi64(R1) = base;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = fractstart;
	asi64(R1) -= asi64(R2);
	fractlen = asi64(R1);
L3362:
	R1 = 0;
	badexpon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 101;
	if (asu64(R1) == asu64(R2)) goto L3364;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L3364;
	R2 = 112;
	if (asu64(R1) == asu64(R2)) goto L3365;
	R2 = 80;
	if (asu64(R1) == asu64(R2)) goto L3365;
	goto L3366;
L3364:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3368;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L3368:
	goto L3363;
L3365:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3370;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L3370:
	goto L3363;
L3366:
L3363:
	asi64(R1) = badexpon;
	if (!asi64(R1)) goto L3372;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L3358;
L3372:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 102;
	if (asu64(R1) == asu64(R2)) goto L3374;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L3374;
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L3374;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L3374;
	goto L3375;
L3374:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3373;
L3375:
	R1 = (u64)&cc_lex_alphamap;
	asu64(R2) = cc_lex_lxsptr;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3377;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L3358;
L3377:
L3373:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3379;
	R1 = 48;
	R2 = (u64)&realstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 120;
	R2 = (u64)&realstr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&realstr;
	R2 = 2;
	R1 += (i64)R2;
	rs = asu64(R1);
	R1 = 2;
	pref = asi64(R1);
	goto L3378;
L3379:
	R1 = (u64)&realstr;
	R2 = 0;
	R1 += (i64)R2;
	rs = asu64(R1);
	R1 = 0;
	pref = asi64(R1);
L3378:
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L3381;
	R1 = tou64("Real too long");
	cc_lex_lxerror(asu64(R1));
L3381:
	asi64(R1) = intlen;
	if (!asi64(R1)) goto L3383;
	asi64(R1) = intlen;
	asu64(R2) = intstart;
	asu64(R3) = rs;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L3383:
	asi64(R1) = fractlen;
	if (!asi64(R1)) goto L3385;
	asi64(R1) = fractlen;
	asu64(R2) = fractstart;
	asu64(R3) = rs;
	asi64(R4) = intlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L3385:
	asi64(R1) = base;
	asr64(R1) = tor64(asi64(R1));
	R2 = R1;
	basex = asr64(R2);
	expbase = asr64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3387;
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	goto L3386;
L3387:
	asi64(R1) = fractlen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 2.000000000000000000e+000;
	expbase = asr64(R1);
L3386:
	R1 = 0;
	R2 = (u64)&realstr;
	asi64(R3) = pref;
	asi64(R4) = intlen;
	asi64(R3) += asi64(R4);
	asi64(R4) = fractlen;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&expstr;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3389;
	R1 = tou64("e");
	goto L3388;
L3389:
	R1 = tou64("p");
L3388:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = expon;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&expstr;
	R2 = (u64)&realstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3391;
	R1 = tou64("Non-base-10 floats temporarily unavailable");
	cc_lex_lxerror(asu64(R1));
L3391:
	R1 = 0;
	R2 = (u64)&realstr;
	asr64(R1) = strtod(asu64(R2), asu64(R1));
	x = asr64(R1);
	R1 = 60;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = intstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = intstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3358:
	return;
}

static i64 cc_lex_readexponent(u64 badexpon) {
    u64 R1, R2; 
	u64 numstart;
	i64 length;
	i64 neg;
	i64 c;
	i64 a;
	i64 av_1;
	R1 = 0;
	neg = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L3394;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L3395;
	goto L3396;
L3394:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3393;
L3395:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	neg = asi64(R1);
	goto L3393;
L3396:
L3393:
	asu64(R1) = cc_lex_lxsptr;
	numstart = asu64(R1);
	R1 = 10;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = numstart;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3398;
	R1 = 1;
	asu64(R2) = badexpon;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	goto L3392;
L3398:
	R1 = 0;
	a = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3401;
L3399:
	R1 = (u64)&numstart;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	if (--asi64(av_1)) goto L3399;
L3401:
	asi64(R1) = neg;
	if (!asi64(R1)) goto L3403;
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	goto L3402;
L3403:
	asi64(R1) = a;
L3402:
	goto L3392;
L3392:
	return asi64(R1);
}

static void cc_lex_lxerror(u64 mess) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("\nLex error");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = cc_lex_getfileno();
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 11;
	exit(R1);
	return;
}

static void cc_lex_printsymbol(u64 lp) {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	struct $B17 l;
	asu64(R1) = lp;
	(R1_B17) = *(struct $B17*)(R1);
	l = (R1_B17);
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("%-18s");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = (u64)&l;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3407;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L3408;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L3409;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L3410;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L3411;
	goto L3412;
L3407:
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 106;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	goto L3406;
L3408:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = lp;
	cc_lex_shownumberstr(asu64(R2), asu64(R1));
	goto L3406;
L3409:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = lp;
	cc_lex_shownumberstr(asu64(R2), asu64(R1));
	goto L3406;
L3410:
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3406;
L3411:
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3406;
L3412:
	R1 = (u64)&l;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3414;
	msysc_m$print_startcon();
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&l;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3414:
L3406:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_lex_lexsetup() {
    u64 R1, R2, R3; 
	i64 i;
	cc_lex_inithashtable();
	cc_lex_fillhashtable();
	R1 = 0;
	i = asi64(R1);
L3416:
	asi64(R1) = i;
	switch (asi64(R1)) {
	case 36: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: case 239: case 240: case 241: case 242: case 243: case 244: case 245: case 246: case 247: case 248: case 249: case 250: case 251: case 252: case 253: case 254: case 255: goto L3422;
	case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 91: case 92: case 93: case 94: case 96: case 123: case 124: case 125: case 126: case 127: goto L3421;
	default: goto L3421;
    };
// SWITCH
L3422:
	R1 = 1;
	R2 = (u64)&cc_lex_alphamap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3419;
L3421:
L3419:
	asi64(R1) = i;
	switch (asi64(R1)) {
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3426;
	default: goto L3425;
    };
// SWITCH
L3426:
	R1 = 1;
	R2 = (u64)&cc_lex_digitmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3423;
L3425:
L3423:
	R1 = 1;
	R2 = (u64)&cc_lex_commentmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_linecommentmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_spacemap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 255) goto L3416;
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 42;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_spacemap;
	R3 = 32;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_spacemap;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 56;
	R2 = (u64)&cc_lex_normaltkx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	cc_lex_npastedtokens = asi64(R1);
	return;
}

static void cc_lex_printstrn(u64 s, i64 length, u64 f) {
    u64 R1, R2; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L3429;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3431;
	msysc_m$print_startcon();
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	goto L3430;
L3431:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
L3430:
L3429:
	return;
}

static u64 cc_lex_scannumber(i64 base) {
    u64 R1, R2, R3; 
	u64 dest;
	i64 c;
	asu64(R1) = cc_lex_lxsptr;
	dest = asu64(R1);
L3433:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 39: case 95: case 96: goto L3443;
	case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: goto L3436;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3437;
	case 65: case 66: case 67: case 68: case 69: case 70: case 97: case 98: case 99: case 100: case 101: case 102: goto L3440;
	default: goto L3436;
    };
// SWITCH
L3437:
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 48;
	asi64(R3) = base;
	asi64(R2) += asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L3439;
	R1 = tou64("Digit out of range");
	cc_lex_lxerror(asu64(R1));
L3439:
	goto L3433;
L3440:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3442;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3441;
L3442:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3434;
L3441:
	goto L3433;
L3443:
	goto L3433;
L3436:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3434;
	goto L3433;
L3434:
	asu64(R1) = dest;
	goto L3432;
L3432:
	return asu64(R1);
}

static i64 cc_lex_lookup() {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 length;
// cc_lex.lookup.retry:
L3445:
	asi64(R1) = cc_lex_lxhashvalue;
	asi64(R2) = cc_decls_hstmask;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L3446:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	length = asi64(R1);
	asi64(R1) = length;
	if (asi64(R1)) goto L3449;
	goto L3447;
L3449:
	asi64(R1) = length;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L3451;
	asi64(R1) = length;
	asu64(R2) = cc_lex_lxsvalue;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3453;
	R1 = 1;
	goto L3444;
L3453:
L3451:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = cc_decls_hstsize;
	if (asi64(R1) < asi64(R2)) goto L3455;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L3457;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L3457:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L3455:
	goto L3446;
L3447:
	asi64(R1) = cc_lex_nhstsymbols;
	asi64(R2) = cc_lex_hstthreshold;
	if (asi64(R1) < asi64(R2)) goto L3459;
	cc_lex_newhashtable();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	goto L3445;
L3459:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 106;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_nhstsymbols;
	(*toi64p(R1)) += 1;
	R1 = 0;
	goto L3444;
L3444:
	return asi64(R1);
}

static u64 cc_lex_gethashvalue(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 c;
	u64 hsum;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L3462;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L3462:
	R1 = 0;
	hsum = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3465;
L3463:
	asu64(R1) = hsum;
	R2 = 4;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asu64(R1) += asu64(R2);
	hsum = asu64(R1);
	if (--asi64(av_1)) goto L3463;
L3465:
	asu64(R1) = hsum;
	R2 = 5;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	goto L3460;
L3460:
	return asu64(R1);
}

static void cc_lex_inithashtable() {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = cc_decls_hstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_decls_hashtable = asu64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cc_decls_hstmask = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3469;
L3467:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= cc_decls_hstmask) goto L3467;
L3469:
	R1 = 0;
	cc_lex_nhstsymbols = asi64(R1);
	R1 = 6;
	asi64(R2) = cc_decls_hstsize;
	asi64(R1) *= asi64(R2);
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	cc_lex_hstthreshold = asi64(R1);
	return;
}

static void cc_lex_fillhashtable() {
    u64 R1, R2, R3; 
	i64 i;
	i64 av_1;
	R1 = 1;
	i = asi64(R1);
	R1 = 63;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3473;
L3471:
	R1 = (u64)&cc_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	cc_lex_lxsvalue = asu64(R1);
	R1 = (u64)&cc_tables_stsymbols;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L3475;
	asu64(R1) = cc_lex_lxsvalue;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_lex_lxsvalue = asu64(R1);
L3475:
	asu64(R1) = cc_lex_lxsvalue;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	asi64(R1) = cc_lex_lookup();
	if (!asi64(R1)) goto L3477;
	msysc_m$print_startcon();
	R1 = (u64)&cc_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Duplicate symbol table entry");
	mlib_abortprogram(asu64(R1));
L3477:
	R1 = (u64)&cc_tables_stsymbols;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_tables_stsubcodes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 100;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	i += 1; if (i <= av_1) goto L3471;
L3473:
	return;
}

static i64 cc_lex_dolexdirective() {
    u64 R1, R2, R3; 
	u64 symptr;
	u64 d;
	u64 p;
	u64 pstart;
	u64 s;
	i64 i;
	i64 cond;
	i64 c;
	i64 syshdr;
	i64 dir;
	i64 length;
	i64 allowmacros;
	struct $B15 filename;
	asu64(R1) = cc_lex_lxsptr;
	pstart = asu64(R1);
	asi64(R1) = cc_lex_getlexdirective();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3480;
	R1 = 0;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = pstart;
	asi64(R2) -= asi64(R3);
	asu64(R3) = pstart;
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Invalid # directive");
	cc_lex_lxerror(asu64(R1));
L3480:
	asi64(R1) = dir;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3482;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3483;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3484;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3485;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3486;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3487;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3488;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3488;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3489;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3490;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3491;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3492;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3493;
	goto L3494;
L3482:
	R1 = 1;
	cc_lex_isincludefile = asi64(R1);
	goto L3496;
L3495:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L3496:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3495;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3495;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 60;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	allowmacros = asi64(R1);
	cc_lex_lexm();
	R1 = 0;
	cc_lex_isincludefile = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L3499;
	R1 = 1;
	syshdr = asi64(R1);
	R1 = (u64)&filename;
	p = asu64(R1);
	asi64(R1) = allowmacros;
	if (!asi64(R1)) goto L3501;
L3502:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L3505;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3505;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L3506;
	goto L3507;
L3505:
	R1 = tou64("Bad include file");
	cc_lex_lxerror(asu64(R1));
	goto L3504;
L3506:
	goto L3503;
	goto L3504;
L3507:
	R1 = (u64)&length;
	R2 = (u64)&cc_decls_nextlx;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
L3504:
	goto L3502;
L3503:
	goto L3500;
L3501:
L3508:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L3511;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3512;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3512;
	goto L3513;
L3511:
	goto L3509;
	goto L3510;
L3512:
	R1 = tou64("include: > expected");
	cc_lex_lxerror(asu64(R1));
	goto L3510;
L3513:
	asi64(R1) = c;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3510:
	goto L3508;
L3509:
L3500:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L3498;
L3499:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L3514;
	R1 = 0;
	syshdr = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3498;
L3514:
	R1 = tou64("include?");
	cc_lex_lxerror(asu64(R1));
L3498:
	cc_lex_lexm();
	asu8(R1) = cc_cli_fshowincludes;
	if (!asu8(R1)) goto L3516;
	msysc_m$print_startcon();
	R1 = tou64("INCLUDE");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("FROM");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = cc_lex_getfileno();
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("NSOURCEFILES=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3516:
	R1 = (u64)&cc_lex_nincludes;
	(*toi64p(R1)) += 1;
	asi64(R1) = syshdr;
	R2 = (u64)&filename;
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	goto L3481;
L3483:
	cc_lex_dodefine();
	goto L3481;
L3484:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3518;
	R1 = tou64("undef: name expected");
	cc_lex_lxerror(asu64(R1));
L3518:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3520;
	goto L3519;
L3520:
	R1 = 0;
	asu64(R2) = d;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L3519:
	goto L3481;
L3485:
	asi64(R1) = cc_lex_getifdef();
	cond = asi64(R1);
	goto L3521;
	goto L3481;
L3486:
	asi64(R1) = cc_lex_getifdef();
	asi64(R1) = !asi64(R1);
	cond = asi64(R1);
	goto L3521;
	goto L3481;
L3487:
	asi64(R1) = cc_lex_getifexpr();
	cond = asi64(R1);
// cc_lex.dolexdirective.doif:
L3521:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) += 1;
	asi64(R1) = cond;
	if (!asi64(R1)) goto L3523;
	R1 = 0;
	goto L3478;
	goto L3522;
L3523:
// cc_lex.dolexdirective.doskipcode:
L3524:
	asi64(R1) = cc_lex_skipcode();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3526;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3527;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3528;
	goto L3529;
L3526:
	asi64(R1) = cc_lex_getifexpr();
	cond = asi64(R1);
	asi64(R1) = cond;
	if (!asi64(R1)) goto L3531;
	R1 = 0;
	goto L3478;
L3531:
	goto L3524;
	goto L3525;
L3527:
	goto L3525;
L3528:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L3525;
L3529:
L3525:
L3522:
	goto L3481;
L3488:
	asi64(R1) = cc_lex_ifcondlevel;
	if (asi64(R1)) goto L3533;
	R1 = tou64("#if missing/elif/else");
	cc_lex_lxerror(asu64(R1));
L3533:
L3534:
	asi64(R1) = cc_lex_skipcode();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3534;
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L3481;
L3489:
	asi64(R1) = cc_lex_ifcondlevel;
	if (asi64(R1)) goto L3538;
	R1 = tou64("#if missing/endif");
	cc_lex_lxerror(asu64(R1));
L3538:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L3481;
L3490:
	goto L3481;
L3491:
L3539:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L3539;
	goto L3481;
L3492:
	cc_lex_lexm();
	msysc_m$print_startcon();
	R1 = tou64("#ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_showtoken(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("ABORTING");
	cc_lex_lxerror(asu64(R1));
	goto L3481;
L3493:
	cc_lex_dopragmadir();
	goto L3481;
L3494:
// cc_lex.dolexdirective.skip:
	msysc_m$print_startcon();
	R1 = tou64("DIRECTIVE NOT IMPL:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_sourcedirnames;
	asi64(R2) = dir;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pstart;
	cc_lex_lxsptr = asu64(R1);
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	goto L3478;
	R1 = tou64("Directive not implemented");
	cc_lex_lxerror(asu64(R1));
L3481:
	R1 = 0;
	goto L3478;
L3478:
	return asi64(R1);
}

static i64 cc_lex_getlexdirective() {
    u64 R1, R2; 
	u64 d;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3545;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3546;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L3547;
	goto L3548;
L3545:
	goto L3544;
L3546:
	R1 = 13;
	goto L3543;
	goto L3544;
L3547:
L3549:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3552;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L3549;
L3552:
	R1 = 13;
	goto L3543;
	goto L3544;
L3548:
	R1 = 0;
	goto L3543;
L3544:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L3554;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L3555;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L3556;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3557;
	goto L3558;
L3554:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L3543;
	goto L3553;
L3555:
	R1 = 3;
	goto L3543;
	goto L3553;
L3556:
	R1 = 5;
	goto L3543;
	goto L3553;
L3557:
	R1 = 13;
	goto L3543;
	goto L3553;
L3558:
L3553:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3560;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L3562;
	asu64(R1) = d;
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L3543;
L3562:
L3560:
	R1 = 0;
	goto L3543;
L3543:
	return asi64(R1);
}

static void cc_lex_startlex(u64 caption, i64 fileno) {
    u64 R1, R2, R3; 
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	R1 = (u64)&cc_lex_normaltkx;
	cc_lex_normaltk = asu64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 1;
	cc_lex_firstsymbol = asi64(R1);
	R1 = 0;
	cc_lex_npastedtokens = asi64(R1);
	R1 = 0;
	cc_lex_isincludefile = asi64(R1);
	R1 = 0;
	cc_lex_tkptr = asu64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	cc_lex_lxsptr = asu64(R2);
	cc_lex_lxstart = asu64(R1);
	asi64(R1) = fileno;
	cc_lex_setfileno(asi64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	return;
}

static void cc_lex_endlex() {
    u64 R1; 
	asi64(R1) = cc_lex_ifcondlevel;
	if (!asi64(R1)) goto L3566;
	msysc_m$print_startcon();
	asi64(R1) = cc_lex_ifcondlevel;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("#endif missing");
	cc_lex_lxerror(asu64(R1));
L3566:
	return;
}

static void cc_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":::");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	cc_lex_printsymbol(asu64(R1));
	return;
}

static void cc_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":##");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_printsymbol(asu64(R1));
	return;
}

static i64 cc_lex_gethashtablesize() {
    u64 R1, R2; 
	i64 i;
	i64 n;
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3572;
L3570:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3574;
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L3574:
	i += 1; if (i <= cc_decls_hstmask) goto L3570;
L3572:
	asi64(R1) = n;
	goto L3569;
L3569:
	return asi64(R1);
}

static void cc_lex_readlinecomment() {
    u64 R1, R2; 
L3576:
	goto L3579;
L3578:
L3579:
	R1 = (u64)&cc_lex_linecommentmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3578;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3582;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3583;
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L3584;
	goto L3585;
L3582:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3577;
	goto L3581;
L3583:
	goto L3577;
	goto L3581;
L3584:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3587;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3588;
	goto L3589;
L3587:
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L3586;
L3588:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L3586;
L3589:
L3586:
	goto L3581;
L3585:
L3581:
	goto L3576;
L3577:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	return;
}

static void cc_lex_readblockcomment() {
    u64 R1, R2; 
L3591:
	goto L3594;
L3593:
L3594:
	R1 = (u64)&cc_lex_commentmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3593;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3597;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3598;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L3599;
	goto L3600;
L3597:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L3596;
L3598:
	R1 = tou64("block comment eof");
	cc_lex_lxerror(asu64(R1));
	goto L3596;
L3599:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) != asu64(R2)) goto L3602;
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	goto L3592;
L3602:
	goto L3596;
L3600:
L3596:
	goto L3591;
L3592:
	return;
}

static void cc_lex_readhex(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	u64 c;
	i64 length;
	i64 leading;
	i64 ll;
	i64 usigned;
	u64 p;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asi64(R2);
	ll = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L3604:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = R1;
	c = asu64(R2);
	switch (asi64(R1)) {
	case 46: case 80: case 112: goto L3614;
	case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 113: case 114: case 115: case 116: goto L3607;
	case 48: goto L3609;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3608;
	case 65: case 66: case 67: case 68: case 69: case 70: goto L3612;
	case 76: case 108: goto L3615;
	case 85: case 117: goto L3618;
	case 97: case 98: case 99: case 100: case 101: case 102: goto L3613;
	default: goto L3607;
    };
// SWITCH
L3608:
	R1 = 0;
	leading = asi64(R1);
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L3604;
L3609:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L3611;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L3610;
L3611:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asu64(R1) *= asu64(R2);
	aa = asu64(R1);
L3610:
	goto L3604;
L3612:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 65;
	asi64(R2) -= asi64(R3);
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	goto L3604;
L3613:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 97;
	asi64(R2) -= asi64(R3);
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	goto L3604;
L3614:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 16;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3603;
	goto L3604;
L3615:
	R1 = (u64)&ll;
	(*toi64p(R1)) += 1;
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3617;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L3617:
	goto L3604;
L3618:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L3620;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L3620:
	R1 = 1;
	usigned = asi64(R1);
	goto L3604;
L3607:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3605;
	goto L3604;
L3605:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L3622;
	R1 = tou64("Overflow in hex number");
	cc_lex_lxerror(asu64(R1));
L3622:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 9223372036854775807;
	if (asu64(R1) <= asu64(R2)) goto L3624;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3623;
L3624:
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) <= asu64(R2)) goto L3625;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3623;
L3625:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) <= asu64(R2)) goto L3626;
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3623;
L3626:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3623:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
L3603:
	return;
}

static void cc_lex_readbinary(u64 pstart) {
    u64 R1, R2, R3; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
L3628:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: goto L3637;
	case 47: goto L3631;
	case 48: goto L3633;
	case 49: goto L3632;
	case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3636;
	default: goto L3631;
    };
// SWITCH
L3632:
	R1 = 0;
	leading = asi64(R1);
	goto L3628;
L3633:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L3635;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L3635:
	goto L3628;
L3636:
	R1 = tou64("Binary bad digit");
	cc_lex_lxerror(asu64(R1));
	goto L3628;
L3637:
	R1 = tou64("Binary fp");
	cc_lex_lxerror(asu64(R1));
	goto L3628;
L3631:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3629;
	goto L3628;
L3629:
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L3639;
	R1 = tou64("Overflow in binary number");
	cc_lex_lxerror(asu64(R1));
L3639:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3642;
L3640:
	asu64(R1) = aa;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L3640;
L3642:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L3644;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3644:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
	return;
}

static void cc_lex_readoctal(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	i64 ll;
	i64 usigned;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asi64(R2);
	ll = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L3646:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: goto L3654;
	case 47: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L3649;
	case 48: goto L3651;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L3650;
	case 76: case 108: goto L3655;
	case 85: case 117: goto L3658;
	default: goto L3649;
    };
// SWITCH
L3650:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L3646;
L3651:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L3653;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L3652;
L3653:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L3652:
	goto L3646;
L3654:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3645;
	goto L3646;
L3655:
	R1 = (u64)&ll;
	(*toi64p(R1)) += 1;
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3657;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L3657:
	goto L3646;
L3658:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L3660;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L3660:
	R1 = 1;
	usigned = asi64(R1);
	goto L3646;
L3649:
	R1 = (u64)&cc_lex_alphamap;
	asi64(R2) = c;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3662;
// cc_lex.readoctal.doalpha:
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L3645;
L3662:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3647;
	goto L3646;
L3647:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 22;
	if (asi64(R1) > asi64(R2)) goto L3666;
	asi64(R1) = length;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L3665;
	R1 = 22;
	R2 = tou64("1777777777777777777777");
	asu64(R3) = p;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3665;
L3666:
	R1 = tou64("Overflow in octal number");
	cc_lex_lxerror(asu64(R1));
L3665:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3669;
L3667:
	asu64(R1) = aa;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L3667;
L3669:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L3671;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3671:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
L3645:
	return;
}

static void cc_lex_readdecimal(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	u8 ll;
	u8 usigned;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asu8(R2);
	ll = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) -= 1;
	p = asu64(R1);
	goto L3674;
L3673:
L3674:
	R1 = (u64)&cc_lex_digitmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3673;
	goto L3677;
L3676:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L3677:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L3676;
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
L3679:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: case 69: case 101: goto L3683;
	case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L3682;
	case 76: case 108: goto L3684;
	case 85: case 117: goto L3687;
	default: goto L3682;
    };
// SWITCH
L3683:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3672;
	goto L3679;
L3684:
	R1 = (u64)&ll;
	(*tou8p(R1)) += 1;
	asu8(R1) = ll;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3686;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L3686:
	goto L3679;
L3687:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L3689;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L3689:
	R1 = 1;
	usigned = asu8(R1);
	goto L3679;
L3682:
	R1 = (u64)&cc_lex_alphamap;
	asi64(R2) = c;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3691;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L3672;
L3691:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3680;
	goto L3679;
L3680:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L3694;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L3693;
	R1 = 20;
	R2 = tou64("18446744073709551615");
	asu64(R3) = p;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3693;
L3694:
	R1 = tou64("Overflow in decimal number");
	cc_lex_lxerror(asu64(R1));
L3693:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3697;
L3695:
	asu64(R1) = aa;
	R2 = 10;
	asu64(R1) *= asu64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = 48;
	asu64(R2) -= asu64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L3695;
L3697:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu8(R1) = ll;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3699;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3700;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3701;
	goto L3702;
L3699:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asi64(R1) < asi64(R2)) goto L3704;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3703;
L3704:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3703:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L3706;
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) < asu64(R2)) goto L3708;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3707;
L3708:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3707:
	goto L3705;
L3706:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L3710;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3710:
L3705:
	goto L3698;
L3700:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L3712;
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) < asu64(R2)) goto L3714;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3713;
L3714:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3713:
	goto L3711;
L3712:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L3716;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3716:
L3711:
	goto L3698;
L3701:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L3718;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3717;
L3718:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3717:
	goto L3698;
L3702:
L3698:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L3672:
	return;
}

static i64 cc_lex_checknumbersuffix() {
    u64 R1, R2; 
	u8 c;
L3720:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = R1;
	c = asu8(R2);
	switch (asi64(R1)) {
	case 76: case 85: case 108: case 117: goto L3724;
	case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L3723;
	default: goto L3723;
    };
// SWITCH
L3724:
	goto L3720;
L3723:
	R1 = (u64)&cc_lex_alphamap;
	asu8(R2) = c;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3726;
L3726:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3721;
	goto L3720;
L3721:
	R1 = 3;
	goto L3719;
L3719:
	return asi64(R1);
}

static void cc_lex_stacksourcefile(u64 file, i64 syshdr) {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	u64 sptr;
	i64 fileno;
	struct $B8 info;
	struct $B80 fullpath;
	asi64(R1) = syshdr;
	asu64(R2) = file;
	asi64(R1) = cc_lex_getsourcefile(asu64(R2), asi64(R1));
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3729;
	msysc_m$print_startcon();
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	asi64(R1) = strlen(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find include file");
	cc_lex_lxerror(asu64(R1));
L3729:
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L3731;
	R1 = tou64("Too many nested includes");
	cc_lex_lxerror(asu64(R1));
L3731:
	R1 = (u64)&cc_lex_lx_stackindex;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&fullpath;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3733;
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = cc_lex_lx_stackindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = (u64)&fullpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L3733:
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3735;
	R1 = (u64)&cc_lex_headerpath;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&fullpath;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3735:
	R1 = (u64)&fullpath;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_lex_headerpathlist;
	asi64(R3) = cc_lex_lx_stackindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = cc_lex_lxstart;
	R2 = (u64)&info;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&info;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&info;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_getfileno();
	R2 = (u64)&info;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	(R1_B8) = info;
	R2 = (u64)&cc_lex_lx_stack;
	asi64(R3) = cc_lex_lx_stackindex;
	*(struct $B8*)(((i64)R2+(i64)R3*24-24)) = (R1_B8);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	cc_lex_lxsptr = asu64(R2);
	cc_lex_lxstart = asu64(R1);
	asi64(R1) = fileno;
	cc_lex_setfileno(asi64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void cc_lex_unstacksourcefile() {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	u64 path;
	struct $B8 info;
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = cc_lex_lx_stackindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	path = asu64(R1);
	asu64(R1) = path;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = path;
	mlib_pcm_free(asu64(R2), asi64(R1));
	R1 = (u64)&cc_lex_lx_stack;
	R2 = (u64)&cc_lex_lx_stackindex;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	(R1_B8) = *(struct $B8*)(((i64)R1+(i64)R2*24-24));
	info = (R1_B8);
	R1 = (u64)&info;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_lxstart = asu64(R1);
	R1 = (u64)&info;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_lxsptr = asu64(R1);
	R1 = (u64)&info;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&info;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_lex_setfileno(asi64(R1));
	return;
}

static i64 cc_lex_getsourcefile(u64 file, i64 syshdr) {
    u64 R1, R2, R3; 
	struct $B15 filespec2;
	u64 hdrtext;
	i64 i;
	R1 = 0;
	R2 = (u64)&cc_lex_headerpath;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3740;
L3738:
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3742;
	asi64(R1) = i;
	goto L3737;
L3742:
	i += 1; if (i <= cc_decls_nsourcefiles) goto L3738;
L3740:
	asu8(R1) = cc_cli_dointheaders;
	if (!asu8(R1)) goto L3744;
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = cc_headers_findheader(asu64(R1));
	hdrtext = asu64(R1);
	asu64(R1) = hdrtext;
	if (!asu64(R1)) goto L3746;
	asu64(R1) = hdrtext;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadbuiltin(asu64(R2), asu64(R1));
	goto L3737;
L3746:
L3744:
	R1 = tou64("mcc.h");
	asu64(R2) = file;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3748;
	R1 = tou64("#define __attribute__(x)\n#define _WIN32\n#define WIN32\n#define __WIN32__\n#define __inline\n#define __dllimport(x)\n#define __declspec(x)\n#define __stdcall\n#define CALLBACK $callback\n#define __cdecl\n#define EXTERN_C extern\n#define DECLSPEC_IMPORT\n#define __32BIT__\n#define register\n#define __MCCC__\n\ntypedef signed char\t\ti8;\ntypedef short\t\t\ti16;\ntypedef int\t\t\t\ti32;\ntypedef long long int\ti64;\ntypedef unsigned char\t\t\tu8;\ntypedef unsigned short\t\t\tu16;\ntypedef unsigned int\t\t\tu32;\ntypedef unsigned long long int\tu64;\n\ntypedef unsigned char byte;\n\ntypedef float r32;\ntypedef double r64;\n\n");
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadbuiltin(asu64(R2), asu64(R1));
	goto L3737;
L3748:
	asu64(R1) = file;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&cc_lex_headerpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3750;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L3753;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L3752;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) != asu64(R2)) goto L3752;
L3753:
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3755;
	asu64(R1) = file;
	asu64(R2) = file;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L3737;
L3755:
	R1 = 0;
	goto L3737;
L3752:
L3750:
	asi64(R1) = cc_lex_lx_stackindex;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3758;
L3756:
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3760;
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L3737;
L3760:
	i += -1; if (i >= 1) goto L3756;
L3758:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsearchdirs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3763;
L3761:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3765;
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&cc_lex_headerpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L3737;
L3765:
	i += 1; if (i <= cc_decls_nsearchdirs) goto L3761;
L3763:
	R1 = 0;
	goto L3737;
L3737:
	return asi64(R1);
}

static void cc_lex_lex() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
// cc_lex.lex.reenter:
	(R1_B17) = cc_decls_nextlx;
	cc_decls_lx = (R1_B17);
	cc_lex_lexm();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L3769;
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3769;
	R1 = 0;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&cc_decls_lx;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3769:
L3770:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3772;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3773;
	goto L3774;
L3772:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L3776;
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3776:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3766;
	goto L3770;
L3773:
	cc_lex_lexm();
	goto L3770;
L3774:
	goto L3766;
	goto L3770;
L3766:
	return;
}

static void cc_lex_shownumberstr(u64 l, u64 f) {
    u64 R1, R2, R3; 
	u64 s;
	asu64(R1) = l;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	if (!asi64(R1)) goto L3779;
	R1 = (u64)&cc_decls_sourcefiletext;
	asu64(R2) = l;
	asi64(R2) = cc_lex_getfilenox(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = l;
	asi64(R2) = cc_lex_getnumberoffsetx(asu64(R2));
	R1 += (i64)R2;
	s = asu64(R1);
	goto L3778;
L3779:
	R1 = (u64)&cc_lex_pastedtokenlist;
	asu64(R2) = l;
	R3 = 28;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	s = asu64(R1);
L3778:
	asu64(R1) = f;
	asu64(R2) = l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = s;
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static u64 cc_lex_addnamestr(u64 name) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	struct $B17 oldlx;
	u64 symptr;
	(R1_B17) = cc_decls_nextlx;
	oldlx = (R1_B17);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = name;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_lex_lxsvalue = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R2) = name;
	asu64(R3) = cc_lex_lxsvalue;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cc_lex_lookup();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B17) = oldlx;
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = symptr;
	goto L3780;
L3780:
	return asu64(R1);
}

static void cc_lex_lxreadstring(i64 termchar, i64 fwide) {
    u64 R1, R2, R3, R4; 
	struct $B81 str;
	u64 dest;
	u64 ws;
	u64 wd;
	u64 wd0;
	i64 c;
	i64 d;
	i64 length;
	i64 useheap;
	i64 av_1;
	i64 av_2;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L3783;
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L3785;
	R1 = 64;
	goto L3784;
L3785:
	R1 = 63;
L3784:
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3782;
L3783:
	R1 = 61;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3782:
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3787;
	asi64(R1) = fwide;
	if (asi64(R1)) goto L3787;
	asu64(R1) = cc_lex_lxsptr;
	dest = asu64(R1);
	asu64(R1) = dest;
	ws = asu64(R1);
	R1 = 0;
	useheap = asi64(R1);
	goto L3786;
L3787:
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	ws = asu64(R1);
	R1 = 1;
	useheap = asi64(R1);
L3786:
	R1 = 0;
	length = asi64(R1);
L3788:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L3791;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L3792;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3792;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3793;
	goto L3794;
L3791:
	asi64(R1) = cc_lex_isincludefile;
	if (!asi64(R1)) goto L3796;
	R1 = 47;
	c = asi64(R1);
	goto L3797;
L3796:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
// cc_lex.lxreadstring.reenter:
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 10: goto L3831;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 93: case 94: case 95: case 96: case 99: case 100: case 101: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 111: case 112: case 113: case 115: case 117: case 119: goto L3801;
	case 13: goto L3828;
	case 34: goto L3825;
	case 39: goto L3827;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L3818;
	case 92: goto L3826;
	case 97: goto L3802;
	case 98: goto L3803;
	case 102: goto L3804;
	case 110: goto L3805;
	case 114: goto L3806;
	case 116: goto L3807;
	case 118: goto L3808;
	case 120: goto L3809;
	default: goto L3801;
    };
// SWITCH
L3802:
	R1 = 7;
	c = asi64(R1);
	goto L3799;
L3803:
	R1 = 8;
	c = asi64(R1);
	goto L3799;
L3804:
	R1 = 12;
	c = asi64(R1);
	goto L3799;
L3805:
	R1 = 10;
	c = asi64(R1);
	goto L3799;
L3806:
	R1 = 13;
	c = asi64(R1);
	goto L3799;
L3807:
	R1 = 9;
	c = asi64(R1);
	goto L3799;
L3808:
	R1 = 11;
	c = asi64(R1);
	goto L3799;
L3809:
	R1 = 0;
	c = asi64(R1);
L3810:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	d = asi64(R2);
	switch (asi64(R1)) {
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3817;
	case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: goto L3814;
	case 65: case 66: case 67: case 68: case 69: case 70: goto L3815;
	case 97: case 98: case 99: case 100: case 101: case 102: goto L3816;
	default: goto L3814;
    };
// SWITCH
L3815:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L3812;
L3816:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L3812;
L3817:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L3812;
L3814:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3811;
L3812:
	goto L3810;
L3811:
	goto L3799;
L3818:
	R1 = 48;
	R2 = (u64)&c;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	av_1 = asi64(R1);
L3819:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	d = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L3823;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L3823;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L3823;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L3823;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L3823;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L3823;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L3823;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L3823;
	goto L3824;
L3823:
	asi64(R1) = c;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L3822;
L3824:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3821;
L3822:
	if (--asi64(av_1)) goto L3819;
L3821:
	goto L3799;
L3825:
	R1 = 34;
	c = asi64(R1);
	goto L3799;
L3826:
	R1 = 92;
	c = asi64(R1);
	goto L3799;
L3827:
	R1 = 39;
	c = asi64(R1);
	goto L3799;
L3828:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3830;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L3830:
	goto L3788;
	goto L3799;
L3831:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L3788;
	goto L3799;
L3801:
L3799:
	goto L3790;
L3792:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L3833;
	goto L3789;
L3833:
	goto L3790;
L3793:
	msysc_m$print_startcon();
	R1 = tou64("NEXTLX.LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("String not terminated");
	cc_lex_lxerror(asu64(R1));
	goto L3790;
L3794:
L3790:
// cc_lex.lxreadstring.normalchar:
L3797:
	asi64(R1) = useheap;
	if (asi64(R1)) goto L3835;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3834;
L3835:
	R1 = (u64)&length;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L3836;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3834;
L3836:
	R1 = tou64("Local str too long");
	cc_lex_lxerror(asu64(R1));
L3834:
	goto L3788;
L3789:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L3838;
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 2;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	wd = asu64(R2);
	wd0 = asu64(R1);
	asi64(R1) = length;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3841;
L3839:
	R1 = (u64)&ws;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = (u64)&wd;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 2; asu64(R2) = asu64(R3);
	*tou16p(R2) = asu16(R1);
	if (--asi64(av_2)) goto L3839;
L3841:
	R1 = 0;
	asu64(R2) = wd;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = wd0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3837;
L3838:
	asi64(R1) = useheap;
	if (!asi64(R1)) goto L3842;
	asi64(R1) = length;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	R2 = 1;
	asu64(R1) += asu64(R2);
	R2 = (u64)&str;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L3837;
L3842:
	asu64(R1) = dest;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3837:
	return;
}

static void cc_lex_addlisttoken(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3845;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3844;
L3845:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3844:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlisttoken_copy(u64 ulist, u64 ulistx, u64 q) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 p;
	asu64(R1) = cc_lex_alloctoken();
	p = asu64(R1);
	asu64(R1) = q;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = p;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3848;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3847;
L3848:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3847:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlist_nextlx(u64 ulist, u64 ulistx) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 p;
	asu64(R1) = cc_lex_alloctoken();
	p = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	asu64(R2) = p;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3851;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3850;
L3851:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3850:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlisttoken_seq(u64 ulist, u64 ulistx, u64 seq) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 tk;
	goto L3854;
L3853:
	asu64(R1) = cc_lex_alloctoken();
	tk = asu64(R1);
	asu64(R1) = seq;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3857;
	asu64(R1) = tk;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3856;
L3857:
	asu64(R1) = tk;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3856:
	R1 = 0;
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L3854:
	asu64(R1) = seq;
	if (asu64(R1)) goto L3853;
	return;
}

static void cc_lex_addlistmparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3860;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3859;
L3860:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3859:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_dodefine() {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 stlist;
	u64 stlistx;
	u64 p;
	u64 q;
	u64 stname;
	u64 d;
	u64 tklist;
	u64 tklistx;
	u64 tk;
	i64 nparams;
	i64 ntokens;
	i64 paramno;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3863;
	R1 = tou64("define: name expected");
	cc_lex_lxerror(asu64(R1));
L3863:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 92;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = stname;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	nparams = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) != asu64(R2)) goto L3865;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 0;
	R2 = R1;
	stlistx = asu64(R2);
	stlist = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	cc_lex_lexreadtoken();
L3866:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3869;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3870;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L3871;
	goto L3872;
L3869:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = stlist;
	p = asu64(R1);
	goto L3874;
L3873:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L3877;
	R1 = tou64("Dupl macro param");
	cc_lex_lxerror(asu64(R1));
L3877:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L3874:
	asu64(R1) = p;
	if (asu64(R1)) goto L3873;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	cc_lex_addlistmparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3879;
	cc_lex_lexreadtoken();
L3879:
	goto L3868;
L3870:
	goto L3867;
	goto L3868;
L3871:
	R1 = tou64("__VA_ARGS__");
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	d = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3881;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L3881:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	cc_lex_addlistmparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	goto L3867;
	goto L3868;
L3872:
	R1 = tou64("macro params?");
	cc_lex_lxerror(asu64(R1));
L3868:
	goto L3866;
L3867:
	asu64(R1) = stlist;
	asu64(R2) = stname;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3865:
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	R1 = 0;
	ntokens = asi64(R1);
L3882:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3885;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L3885;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3886;
	goto L3887;
L3885:
	goto L3883;
	goto L3884;
L3886:
	asu64(R1) = stname;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = 1;
	paramno = asi64(R1);
	goto L3889;
L3888:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3892;
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	asi64(R1) = paramno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L3890;
L3892:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&paramno;
	(*toi64p(R1)) += 1;
L3889:
	asu64(R1) = p;
	if (asu64(R1)) goto L3888;
L3890:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	if (asu64(R1) != asu64(R2)) goto L3894;
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
L3894:
	goto L3884;
L3887:
L3884:
	R1 = (u64)&ntokens;
	(*toi64p(R1)) += 1;
	asu64(R1) = cc_lex_alloctoken();
	tk = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
	asu64(R1) = tk;
	R2 = (u64)&tklistx;
	R3 = (u64)&tklist;
	cc_lex_addlisttoken(asu64(R3), asu64(R2), asu64(R1));
	goto L3882;
L3883:
	asu64(R1) = tklist;
	asu64(R2) = stname;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nparams;
	asu64(R2) = stname;
	R3 = 111;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void cc_lex_readalphanumeric(u64 pstart) {
    u64 R1, R2, R3; 
	goto L3897;
L3896:
L3897:
	R1 = (u64)&cc_lex_alphamap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3896;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 58;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 cc_lex_inmacrostack(u64 d, u64 macrostack) {
    u64 R1, R2; 
	goto L3901;
L3900:
	asu64(R1) = macrostack;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L3904;
	R1 = 1;
	goto L3899;
L3904:
	asu64(R1) = macrostack;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	macrostack = asu64(R1);
L3901:
	asu64(R1) = macrostack;
	if (asu64(R1)) goto L3900;
	R1 = 0;
	goto L3899;
L3899:
	return asi64(R1);
}

static void cc_lex_showtokens(u64 caption, u64 tk) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("<");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3907;
L3906:
	asu64(R1) = tk;
	cc_lex_showtoken(asu64(R1));
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L3907:
	asu64(R1) = tk;
	if (asu64(R1)) goto L3906;
	msysc_m$print_startcon();
	R1 = tou64(">");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_lex_lexa(u64 tk) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = cc_lex_normaltk;
	if (asu64(R1) != asu64(R2)) goto L3911;
	cc_lex_lexreadtoken();
	goto L3909;
L3911:
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3913;
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3909;
L3913:
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	(R1_B17) = *(struct $B17*)(R1);
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	*tou64p(R2) = asu64(R1);
L3909:
	return;
}

static void cc_lex_lexm() {
    u64 R1, R2, R3, R4, R5; struct $B17 R1_B17; 
	u64 d;
	i64 newlineno;
// PROC LOCAL STATICS GO HERE
	static i64 cc_lex_lexm_doreset = 0;
L3915:
	asu64(R1) = cc_lex_tkptr;
	if (!asu64(R1)) goto L3918;
	asu64(R1) = cc_lex_tkptr;
	(R1_B17) = *(struct $B17*)(R1);
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = cc_lex_tkptr;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_tkptr = asu64(R1);
	asu64(R1) = cc_lex_tkptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3920;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L3922;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3922;
	asi64(R1) = cc_lex_peeklb();
	if (!asi64(R1)) goto L3922;
	asi64(R1) = cc_decls_sfileno;
	cc_lex_setfileno(asi64(R1));
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	cc_lex_lexm_doreset = asi64(R1);
	goto L3923;
L3922:
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
L3920:
	goto L3914;
L3918:
	asi64(R1) = cc_lex_lexm_doreset;
	if (!asi64(R1)) goto L3925;
	asi64(R1) = cc_decls_sfileno;
	cc_lex_setfileno(asi64(R1));
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	cc_lex_lexm_doreset = asi64(R1);
L3925:
	asi64(R1) = cc_lex_firstsymbol;
	if (!asi64(R1)) goto L3927;
	R1 = 0;
	cc_lex_firstsymbol = asi64(R1);
	cc_lex_dospecialinclude();
L3927:
	cc_lex_lexreadtoken();
// cc_lex.lexm.test1:
L3923:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3929;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3930;
	goto L3931;
L3929:
	asi64(R1) = cc_lex_dolexdirective();
	if (!asi64(R1)) goto L3933;
	goto L3914;
L3933:
	goto L3915;
	goto L3928;
L3930:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3935;
	goto L3936;
L3935:
	asi64(R1) = cc_lex_getfileno();
	cc_decls_sfileno = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_slineno = asi64(R1);
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	asu64(R3) = d;
	R4 = 100;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	cc_lex_expandpredefmacro(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
	goto L3914;
	goto L3934;
L3936:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3939;
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L3938;
L3939:
	goto L3914;
L3938:
L3934:
	goto L3928;
L3931:
	goto L3914;
L3928:
	asi64(R1) = cc_lex_getfileno();
	cc_decls_sfileno = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_slineno = asi64(R1);
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3941;
	asi64(R1) = cc_lex_peeklb();
	if (asi64(R1)) goto L3943;
	goto L3914;
L3943:
	R1 = (u64)&newlineno;
	R2 = 1;
	R3 = (u64)&cc_lex_normaltk;
	R4 = 0;
	asu64(R5) = d;
	asu64(R1) = cc_lex_expandfnmacro(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	cc_lex_tkptr = asu64(R1);
	asi64(R1) = newlineno;
	cc_decls_slineno = asi64(R1);
	goto L3940;
L3941:
	R1 = 1;
	R2 = (u64)&cc_lex_normaltk;
	R3 = 0;
	asu64(R4) = d;
	asu64(R1) = cc_lex_expandobjmacro(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	cc_lex_tkptr = asu64(R1);
L3940:
	asu64(R1) = cc_lex_tkptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3945;
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
L3945:
	goto L3915;
L3914:
	return;
}

static i64 cc_lex_peeklb() {
    u64 R1, R2; 
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) == asu64(R2)) goto L3949;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) != asu64(R2)) goto L3948;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) != asu64(R2)) goto L3948;
L3949:
	R1 = 1;
	goto L3946;
L3948:
	R1 = 0;
	goto L3946;
L3946:
	return asi64(R1);
}

static i64 cc_lex_peektk(u64 tk) {
    u64 R1, R2; 
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3952;
	R1 = 0;
	goto L3950;
L3952:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L3954;
	R1 = 1;
	goto L3950;
L3954:
	R1 = 0;
	goto L3950;
L3950:
	return asi64(R1);
}

static u64 cc_lex_expandobjmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel) {
    u64 R1, R2, R3, R4, R5; 
	u64 tk;
	u64 p;
	u64 repl;
	struct $B17 newmacro;
	i64 iscomplex;
	i64 useshh;
	i64 expanded;
	u64 d;
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	tk = asu64(R2);
	p = asu64(R1);
	R1 = 0;
	R2 = R1;
	useshh = asi64(R2);
	iscomplex = asi64(R1);
	goto L3957;
L3956:
	asu64(R1) = p;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L3960;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3963;
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L3962;
L3963:
	R1 = 1;
	iscomplex = asi64(R1);
	goto L3958;
L3962:
	goto L3959;
L3960:
	asu64(R1) = p;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L3964;
	R1 = 1;
	R2 = R1;
	useshh = asi64(R2);
	iscomplex = asi64(R1);
	goto L3958;
L3964:
L3959:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L3957:
	asu64(R1) = p;
	if (asu64(R1)) goto L3956;
L3958:
	asi64(R1) = iscomplex;
	if (asi64(R1)) goto L3966;
	asu64(R1) = tk;
	goto L3955;
L3966:
	asu64(R1) = m;
	R2 = (u64)&newmacro;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = macrostack;
	R2 = (u64)&newmacro;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = useshh;
	if (!asi64(R1)) goto L3968;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asu64(R5) = m;
	asu64(R1) = cc_lex_substituteargs(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	repl = asu64(R1);
	goto L3967;
L3968:
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	repl = asu64(R1);
L3967:
	R1 = (u64)&expanded;
	R2 = (u64)&newmacro;
	asu64(R3) = repl;
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	tk = asu64(R1);
	asu64(R1) = tk;
	goto L3955;
L3955:
	return asu64(R1);
}

static u64 cc_lex_expandfnmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel, u64 endlineno) {
    u64 R1, R2, R3, R4, R5; 
	struct $B73 args;
	struct $B73 expargs;
	u64 repl;
	u64 tk;
	struct $B17 newmacro;
	i64 nargs;
	i64 i;
	i64 expanded;
	asu64(R1) = tksource;
	R2 = (u64)&args;
	asu64(R3) = m;
	asi64(R1) = cc_lex_readmacrocall(asu64(R3), asu64(R2), asu64(R1));
	nargs = asi64(R1);
	asi64(R1) = frombaselevel;
	if (!asi64(R1)) goto L3971;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = endlineno;
	*toi64p(R2) = asi64(R1);
L3971:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3974;
L3972:
	R1 = 0;
	R2 = (u64)&expargs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nargs) goto L3972;
L3974:
	asu64(R1) = macrostack;
	asi64(R2) = nargs;
	R3 = (u64)&expargs;
	R4 = (u64)&args;
	asu64(R5) = m;
	asu64(R1) = cc_lex_substituteargs(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	repl = asu64(R1);
	asu64(R1) = m;
	R2 = (u64)&newmacro;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = macrostack;
	R2 = (u64)&newmacro;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&expanded;
	R2 = (u64)&newmacro;
	asu64(R3) = repl;
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	repl = asu64(R1);
	asu64(R1) = repl;
	goto L3969;
L3969:
	return asu64(R1);
}

static u64 cc_lex_scantokenseq(u64 tk, u64 macrostack, u64 expanded) {
    u64 R1, R2, R3, R4, R5; 
	u64 newtk;
	u64 newtkx;
	u64 expandtk;
	u64 oldtk;
	u64 m;
	struct $B17 newmacro;
	i64 noexpandflag;
	i64 simple;
	i64 dummy;
// cc_lex.scantokenseq.reenter:
L3976:
	R1 = 0;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = R1;
	newtkx = asu64(R2);
	newtk = asu64(R1);
	R1 = 0;
	noexpandflag = asi64(R1);
	R1 = 1;
	simple = asi64(R1);
	asu64(R1) = tk;
	oldtk = asu64(R1);
	goto L3978;
L3977:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3981;
	goto L3982;
L3981:
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3985;
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L3984;
L3985:
	R1 = 0;
	simple = asi64(R1);
	goto L3979;
L3984:
	goto L3980;
L3982:
L3980:
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3987;
	goto L3979;
L3987:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L3978:
	asu64(R1) = tk;
	if (asu64(R1)) goto L3977;
L3979:
	asi64(R1) = simple;
	if (!asi64(R1)) goto L3989;
	asu64(R1) = oldtk;
	goto L3975;
L3989:
	asu64(R1) = oldtk;
	tk = asu64(R1);
	goto L3991;
L3990:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3994;
	goto L3995;
L3994:
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3997;
	asi64(R1) = noexpandflag;
	if (asi64(R1)) goto L3997;
	asu64(R1) = tk;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4000;
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L3999;
L4000:
	goto L4001;
L3999:
	asu64(R1) = macrostack;
	asu64(R2) = m;
	asi64(R1) = cc_lex_inmacrostack(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4003;
	asu64(R1) = tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	asu64(R2) = newtkx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	goto L4004;
L4003:
	R1 = 0;
	simple = asi64(R1);
	asu64(R1) = m;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4006;
	asu64(R1) = tk;
	asi64(R1) = cc_lex_peektk(asu64(R1));
	if (asi64(R1)) goto L4008;
	goto L4001;
L4008:
	R1 = (u64)&tk;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&dummy;
	R2 = 1;
	R3 = (u64)&tk;
	asu64(R4) = macrostack;
	asu64(R5) = m;
	asu64(R1) = cc_lex_expandfnmacro(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	expandtk = asu64(R1);
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	goto L3991;
	goto L4005;
L4006:
	R1 = 0;
	R2 = (u64)&tk;
	asu64(R3) = macrostack;
	asu64(R4) = m;
	asu64(R1) = cc_lex_expandobjmacro(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	expandtk = asu64(R1);
	R1 = 1;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
L4005:
	goto L3996;
L3997:
	asu64(R1) = m;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L4009;
	R1 = 1;
	noexpandflag = asi64(R1);
	goto L4001;
	goto L3996;
L4009:
	asu64(R1) = m;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4010;
	asu64(R1) = cc_lex_alloctokenz();
	expandtk = asu64(R1);
	asi64(R1) = cc_decls_slineno;
	asu64(R2) = expandtk;
	asu64(R3) = m;
	R4 = 100;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	cc_lex_expandpredefmacro(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	goto L4011;
	goto L3996;
L4010:
	R1 = 0;
	noexpandflag = asi64(R1);
	goto L4001;
L3996:
	goto L3993;
L3995:
// cc_lex.scantokenseq.simpletoken:
L4001:
	asu64(R1) = tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
L3993:
// cc_lex.scantokenseq.skip:
L4004:
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4013;
	goto L3992;
L4013:
// cc_lex.scantokenseq.skip2:
L4011:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L3991:
	asu64(R1) = tk;
	if (asu64(R1)) goto L3990;
L3992:
	asu64(R1) = expanded;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L4015;
	asu64(R1) = newtk;
	tk = asu64(R1);
	goto L3976;
L4015:
	asu64(R1) = newtk;
	goto L3975;
L3975:
	return asu64(R1);
}

static i64 cc_lex_readmacrocall(u64 d, u64 args, u64 tksource) {
    u64 R1, R2, R3; 
	i64 nparams;
	i64 lbcount;
	i64 paramno;
	i64 nargs;
	i64 usesvargs;
	i64 varg;
	u64 tklist;
	u64 tklistx;
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4018;
	R1 = tou64("rmc: no '('");
	cc_lex_lxerror(asu64(R1));
L4018:
	asu64(R1) = d;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nparams = asi64(R1);
	R1 = 0;
	nargs = asi64(R1);
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4020;
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4022;
	R1 = tou64("rmc: ')' expected");
	cc_lex_lxerror(asu64(R1));
L4022:
	R1 = 0;
	goto L4016;
L4020:
	R1 = 1;
	paramno = asi64(R1);
	R1 = 1;
	lbcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	usesvargs = asi64(R1);
	R1 = 0;
	varg = asi64(R1);
L4023:
	asi64(R1) = paramno;
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L4026;
	asi64(R1) = usesvargs;
	if (!asi64(R1)) goto L4026;
	R1 = 1;
	varg = asi64(R1);
L4026:
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4028;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4029;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4030;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4031;
	goto L4032;
L4028:
	asi64(R1) = lbcount;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4034;
	asi64(R1) = varg;
	if (asi64(R1)) goto L4034;
	asu64(R1) = tklist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4036;
	asu64(R1) = cc_lex_alloctokenz();
	tklist = asu64(R1);
	asi64(R1) = cc_lex_getfileno();
	asu64(R2) = tklist;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	R1 = 66;
	asu64(R2) = tklist;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4036:
	asu64(R1) = tklist;
	asu64(R2) = args;
	asi64(R3) = paramno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	R1 = (u64)&paramno;
	(*toi64p(R1)) += 1;
	goto L4033;
L4034:
	goto L4037;
L4033:
	goto L4027;
L4029:
	R1 = tou64("EOS in macro call");
	cc_lex_lxerror(asu64(R1));
	goto L4027;
L4030:
	R1 = (u64)&lbcount;
	(*toi64p(R1)) += 1;
	goto L4037;
	goto L4027;
L4031:
	asi64(R1) = lbcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4039;
	R1 = (u64)&lbcount;
	(*toi64p(R1)) -=1;
	R1 = (u64)&tklistx;
	R2 = (u64)&tklist;
	cc_lex_addlist_nextlx(asu64(R2), asu64(R1));
	goto L4038;
L4039:
	asu64(R1) = tklist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4041;
	asu64(R1) = cc_lex_alloctokenz();
	tklist = asu64(R1);
	asi64(R1) = cc_lex_getfileno();
	asu64(R2) = tklist;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	R1 = 66;
	asu64(R2) = tklist;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4041:
	asu64(R1) = tklist;
	asu64(R2) = args;
	asi64(R3) = paramno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4024;
L4038:
	goto L4027;
L4032:
// cc_lex.readmacrocall.addtoken:
L4037:
	R1 = (u64)&tklistx;
	R2 = (u64)&tklist;
	cc_lex_addlist_nextlx(asu64(R2), asu64(R1));
L4027:
	goto L4023;
L4024:
	asi64(R1) = paramno;
	asi64(R2) = nparams;
	if (asi64(R1) == asi64(R2)) goto L4043;
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L4045;
	asi64(R1) = usesvargs;
	if (!asi64(R1)) goto L4045;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4044;
L4045:
	R1 = tou64("Wrong # macro params");
	cc_lex_lxerror(asu64(R1));
L4044:
L4043:
	asi64(R1) = nparams;
	goto L4016;
L4016:
	return asi64(R1);
}

static u64 cc_lex_substituteargs(u64 m, u64 args, u64 expargs, i64 nargs, u64 macrostack) {
    u64 R1, R2, R3, R4; 
	u64 params;
	u64 seq;
	u64 seqstart;
	u64 lasttoken;
	u64 newtk;
	u64 newtkx;
	u64 niltk;
	u64 tkexp;
	struct $B17 tk;
	i64 n;
	i64 i;
	i64 expanded;
	struct $B82 hhpoints;
	i64 nhashhash;
	asu64(R1) = m;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	params = asu64(R1);
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	seqstart = asu64(R2);
	seq = asu64(R1);
	R1 = 0;
	R2 = R1;
	newtkx = asu64(R2);
	newtk = asu64(R1);
	R1 = 0;
	nhashhash = asi64(R1);
	R1 = 0;
	lasttoken = asu64(R1);
	goto L4048;
L4047:
	asu64(R1) = seq;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4051;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4052;
	goto L4053;
L4051:
	asi64(R1) = nargs;
	if (!asi64(R1)) goto L4055;
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
	asu64(R1) = seq;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4057;
	R1 = tou64("# at end");
	cc_lex_lxerror(asu64(R1));
L4057:
	asu64(R1) = seq;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4059;
	R1 = tou64("# not followed by param");
	cc_lex_lxerror(asu64(R1));
L4059:
	asu64(R1) = seq;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	R1 = (u64)&tk;
	asu64(R2) = args;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	cc_lex_stringify(asu64(R2), asu64(R1));
	R1 = (u64)&tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	goto L4054;
L4055:
	asu64(R1) = seq;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken(asu64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = newtkx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4054:
	goto L4050;
L4052:
	asu64(R1) = seq;
	asu64(R2) = seqstart;
	if (asu64(R1) != asu64(R2)) goto L4061;
	R1 = tou64("## at start");
	cc_lex_lxerror(asu64(R1));
L4061:
	asi64(R1) = nhashhash;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L4063;
	R1 = tou64("Too many ##");
	cc_lex_lxerror(asu64(R1));
L4063:
	asu64(R1) = newtkx;
	R2 = (u64)&hhpoints;
	R3 = (u64)&nhashhash;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4050;
L4053:
	asu64(R1) = seq;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4065;
	asu64(R1) = seq;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4065;
	asi64(R1) = nargs;
	if (!asi64(R1)) goto L4065;
	asu64(R1) = seq;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4069;
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4068;
L4069:
	asu64(R1) = lasttoken;
	if (!asu64(R1)) goto L4067;
	asu64(R1) = lasttoken;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4067;
L4068:
	asu64(R1) = args;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
	goto L4066;
L4067:
	asu64(R1) = expargs;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	tkexp = asu64(R1);
	asu64(R1) = tkexp;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4071;
	R1 = (u64)&expanded;
	asu64(R2) = macrostack;
	asu64(R3) = args;
	asi64(R4) = n;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	asu64(R3) = expargs;
	asi64(R4) = n;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	tkexp = asu64(R1);
L4071:
	asu64(R1) = tkexp;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
L4066:
	goto L4064;
L4065:
// cc_lex.substituteargs.doother:
	asu64(R1) = seq;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
L4064:
L4050:
	asu64(R1) = seq;
	lasttoken = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L4048:
	asu64(R1) = seq;
	if (asu64(R1)) goto L4047;
	asi64(R1) = nhashhash;
	if (!asi64(R1)) goto L4074;
	R1 = 0;
	niltk = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nhashhash;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4077;
L4075:
	asi64(R1) = i;
	asi64(R2) = nhashhash;
	if (asi64(R1) >= asi64(R2)) goto L4079;
	R1 = (u64)&hhpoints;
	asi64(R2) = i;
	R1 += (i64)R2*8;
	goto L4078;
L4079:
	R1 = (u64)&niltk;
L4078:
	R2 = (u64)&hhpoints;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	cc_lex_pastetokens(asu64(R2), asu64(R1));
	i += 1; if (i <= nhashhash) goto L4075;
L4077:
L4074:
	asu64(R1) = newtk;
	goto L4046;
L4046:
	return asu64(R1);
}

static u64 cc_lex_strtoken(u64 lp, u64 length) {
    u64 R1, R2, R3, R4, R5; struct $B17 R1_B17; 
	u64 name;
	u64 s;
	struct $B17 l;
	asu64(R1) = lp;
	(R1_B17) = *(struct $B17*)(R1);
	l = (R1_B17);
	R1 = (u64)&l;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4082;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L4083;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L4083;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4084;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L4085;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L4085;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L4086;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4087;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4088;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4089;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4089;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4089;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L4089;
	goto L4090;
L4082:
// cc_lex.strtoken.doname:
L4091:
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4080;
	goto L4081;
L4083:
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	if (!asi64(R1)) goto L4093;
	R1 = (u64)&cc_decls_sourcefiletext;
	R2 = (u64)&l;
	asi64(R2) = cc_lex_getfilenox(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&l;
	asi64(R2) = cc_lex_getnumberoffsetx(asu64(R2));
	R1 += (i64)R2;
	goto L4080;
	goto L4092;
L4093:
	R1 = (u64)&cc_lex_pastedtokenlist;
	R2 = (u64)&l;
	R3 = 28;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L4080;
L4092:
	goto L4081;
L4084:
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4080;
	goto L4081;
L4085:
	R1 = 34;
	asu64(R2) = length;
	R3 = (u64)&l;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&l;
	R5 = 0;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = cc_lex_strstring(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	goto L4080;
	goto L4081;
L4086:
	R1 = 39;
	asu64(R2) = length;
	R3 = (u64)&l;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&l;
	R5 = 0;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = cc_lex_strstring(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	goto L4080;
	goto L4081;
L4087:
	asi64(R1) = cc_lex_dowhitespace;
	if (!asi64(R1)) goto L4095;
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = length;
	asi64(R1) = *toi64p(R1);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	R1 = 10;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	R4 = 1;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L4094;
L4095:
	R1 = 1;
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = tou64("\n");
	goto L4080;
L4094:
	asu64(R1) = s;
	goto L4080;
	goto L4081;
L4088:
	R1 = 0;
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = tou64("");
	goto L4080;
	goto L4081;
L4089:
	goto L4091;
	goto L4081;
L4090:
	R1 = (u64)&cc_tables_shortsymbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	asu64(R3) = length;
	*toi64p(R3) = asi64(R2);
	if (!asi64(R1)) goto L4097;
	asu64(R1) = name;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L4099;
	asu64(R1) = name;
	goto L4080;
	goto L4098;
L4099:
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2;
	goto L4080;
L4098:
	goto L4096;
L4097:
	R1 = tou64("");
	goto L4080;
L4096:
L4081:
	R1 = tou64("");
	goto L4080;
L4080:
	return asu64(R1);
}

static u64 cc_lex_strstring(u64 s, i64 length, u64 newlength, i64 quotechar) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 4;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	asi64(R1) = quotechar;
	if (!asi64(R1)) goto L4102;
	asi64(R1) = quotechar;
	asu64(R2) = u;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&u;
	(*tou64p(R1)) += 1;
L4102:
	asi64(R1) = length;
	asu64(R2) = u;
	asu64(R3) = s;
	asi64(R1) = cc_lib_convertstringc(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = newlength;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = quotechar;
	if (!asi64(R1)) goto L4104;
	asi64(R1) = quotechar;
	asu64(R2) = t;
	asu64(R3) = newlength;
	asi64(R3) = *toi64p(R3);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newlength;
	(*toi64p(R1)) += 1;
L4104:
	asu64(R1) = t;
	goto L4100;
L4100:
	return asu64(R1);
}

static void cc_lex_emittoken(u64 lp, u64 dest, i64 forcespace) {
    u64 R1, R2, R3; 
	i64 length;
	u64 s;
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L4107;
	asi64(R1) = cc_lex_lasttoken;
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L4107;
	goto L4105;
L4107:
	R1 = (u64)&length;
	asu64(R2) = lp;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = forcespace;
	if (asi64(R1)) goto L4110;
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = cc_lex_lasttoken;
	asi64(R1) = cc_lex_needspace(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L4109;
L4110:
	R1 = 32;
	asu64(R2) = dest;
	mlib_gs_char(asu64(R2), asi64(R1));
L4109:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_gs_strn(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_lex_lasttoken = asi64(R1);
L4105:
	return;
}

static void cc_lex_showtoken(u64 lp) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_showtoken_dest = (u64)&cc_lex_showtoken_buffer;
	asu64(R1) = cc_lex_showtoken_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	asu64(R2) = cc_lex_showtoken_dest;
	asu64(R3) = lp;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("v");
	asu64(R2) = cc_lex_showtoken_dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = cc_lex_showtoken_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static void cc_lex_stringify(u64 seq, u64 dest) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	i64 addspace;
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_stringify_deststr = (u64)&cc_lex_stringify_buffer;
	R1 = 63;
	asu64(R2) = dest;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4114;
	R1 = (u64)&length;
	asu64(R2) = seq;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4112;
L4114:
	asu64(R1) = cc_lex_stringify_deststr;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	cc_lex_lasttoken = asi64(R1);
	R1 = 0;
	addspace = asi64(R1);
	goto L4116;
L4115:
	asi64(R1) = addspace;
	asu64(R2) = cc_lex_stringify_deststr;
	asu64(R3) = seq;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	addspace = asi64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L4116:
	asu64(R1) = seq;
	if (asu64(R1)) goto L4115;
	asi64(R1) = length;
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_stringify_deststr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = cc_lex_stringify_deststr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4112:
	return;
}

static void cc_lex_pastetokens(u64 tk, u64 tknext) {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	u64 tk2;
	i64 length1;
	i64 length2;
	u64 s;
	u64 t;
	u64 u;
	struct $B17 oldtoken;
	struct $B17 token;
	u64 oldlxsptr;
	i64 oldlx_stackindex;
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk2 = asu64(R1);
	asu64(R1) = tk2;
	asu64(R2) = tknext;
	asu64(R2) = *tou64p(R2);
	if (asu64(R1) != asu64(R2)) goto L4120;
	asu64(R1) = tk;
	asu64(R2) = tknext;
	*tou64p(R2) = asu64(R1);
L4120:
	asu64(R1) = tk2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L4122;
	asu64(R1) = tk2;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L4124;
	goto L4123;
L4124:
	asu64(R1) = tk2;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
L4123:
	goto L4121;
L4122:
	asu64(R1) = tk2;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L4125;
	goto L4121;
L4125:
	R1 = (u64)&length1;
	asu64(R2) = tk;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	R1 = (u64)&length2;
	asu64(R2) = tk2;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	t = asu64(R1);
	asi64(R1) = length1;
	asi64(R2) = length2;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
	asi64(R1) = length1;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length2;
	asu64(R2) = t;
	asu64(R3) = u;
	asi64(R4) = length1;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = u;
	asi64(R3) = length1;
	R2 += (i64)R3;
	asi64(R3) = length2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_lex_npastedtokens;
	R2 = 87000;
	if (asi64(R1) < asi64(R2)) goto L4127;
	R1 = tou64("Too many pasted tokens");
	cc_lex_lxerror(asu64(R1));
L4127:
	asu64(R1) = u;
	R2 = (u64)&cc_lex_pastedtokenlist;
	R3 = (u64)&cc_lex_npastedtokens;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	oldtoken = (R1_B17);
	asu64(R1) = cc_lex_lxsptr;
	oldlxsptr = asu64(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	oldlx_stackindex = asi64(R1);
	asu64(R1) = u;
	cc_lex_lxsptr = asu64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_setfileno(asi64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	cc_lex_lexreadtoken();
	(R1_B17) = cc_decls_nextlx;
	token = (R1_B17);
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4129;
L4129:
	(R1_B17) = oldtoken;
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = oldlxsptr;
	cc_lex_lxsptr = asu64(R1);
	asi64(R1) = oldlx_stackindex;
	cc_lex_lx_stackindex = asi64(R1);
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&token;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&token;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	asi64(R1) = cc_lex_npastedtokens;
	R2 = (u64)&token;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 8;
	R2 = (u64)&token;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	(R1_B17) = token;
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
L4121:
	return;
}

static i64 cc_lex_getifexpr() {
    u64 R1, R2; 
	i64 sx;
	i64 x;
	cc_lex_lexm();
	R1 = (u64)&sx;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	x = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4132;
	R1 = tou64("#if:eol expected");
	cc_lex_lxerror(asu64(R1));
L4132:
	asi64(R1) = x;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L4130;
L4130:
	return asi64(R1);
}

static i64 cc_lex_evalcondexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 z;
	i64 sy;
	i64 sz;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalorexpr(asu64(R1));
	x = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4135;
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	y = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4137;
	R1 = tou64(": expected");
	cc_lex_lxerror(asu64(R1));
L4137:
	cc_lex_lexm();
	R1 = (u64)&sz;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	z = asi64(R1);
	asi64(R1) = x;
	if (!asi64(R1)) goto L4139;
	asi64(R1) = sy;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = y;
	x = asi64(R1);
	goto L4138;
L4139:
	asi64(R1) = sz;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = z;
	x = asi64(R1);
L4138:
L4135:
	asi64(R1) = x;
	goto L4133;
L4133:
	return asi64(R1);
}

static i64 cc_lex_evalorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalandexpr(asu64(R1));
	x = asi64(R1);
	goto L4142;
L4141:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalandexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L4146;
	asi64(R1) = y;
	if (!asi64(R1)) goto L4145;
L4146:
	R1 = 1;
	goto L4144;
L4145:
	R1 = 0;
L4144:
	x = asi64(R1);
L4142:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L4141;
	asi64(R1) = x;
	goto L4140;
L4140:
	return asi64(R1);
}

static i64 cc_lex_evalandexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaliorexpr(asu64(R1));
	x = asi64(R1);
	goto L4149;
L4148:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaliorexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (!asi64(R1)) goto L4152;
	asi64(R1) = y;
	if (!asi64(R1)) goto L4152;
	R1 = 1;
	goto L4151;
L4152:
	R1 = 0;
L4151:
	x = asi64(R1);
L4149:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4148;
	asi64(R1) = x;
	goto L4147;
L4147:
	return asi64(R1);
}

static i64 cc_lex_evaliorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalixorexpr(asu64(R1));
	x = asi64(R1);
	goto L4155;
L4154:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalixorexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) |= asi64(R1);
L4155:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L4154;
	asi64(R1) = x;
	goto L4153;
L4153:
	return asi64(R1);
}

static i64 cc_lex_evalixorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaliandexpr(asu64(R1));
	x = asi64(R1);
	goto L4159;
L4158:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaliandexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
L4159:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L4158;
	asi64(R1) = x;
	goto L4157;
L4157:
	return asi64(R1);
}

static i64 cc_lex_evaliandexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaleqexpr(asu64(R1));
	x = asi64(R1);
	goto L4163;
L4162:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaleqexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) &= asi64(R1);
L4163:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L4162;
	asi64(R1) = x;
	goto L4161;
L4161:
	return asi64(R1);
}

static i64 cc_lex_evaleqexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalcmpexpr(asu64(R1));
	x = asi64(R1);
	goto L4167;
L4166:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalcmpexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4170;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4171;
	goto L4172;
L4170:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	x = asi64(R1);
	goto L4169;
L4171:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	x = asi64(R1);
	goto L4169;
L4172:
L4169:
L4167:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4166;
	asi64(R1) = opc;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4166;
	asi64(R1) = x;
	goto L4165;
L4165:
	return asi64(R1);
}

static i64 cc_lex_evalcmpexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalshiftexpr(asu64(R1));
	x = asi64(R1);
	goto L4175;
L4174:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalshiftexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4178;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4179;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4180;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4181;
	goto L4182;
L4178:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	x = asi64(R1);
	goto L4177;
L4179:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	x = asi64(R1);
	goto L4177;
L4180:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	x = asi64(R1);
	goto L4177;
L4181:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	x = asi64(R1);
	goto L4177;
L4182:
L4177:
L4175:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4174;
	asi64(R1) = opc;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4174;
	asi64(R1) = opc;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4174;
	asi64(R1) = opc;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4174;
	asi64(R1) = x;
	goto L4173;
L4173:
	return asi64(R1);
}

static i64 cc_lex_evalshiftexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaladdexpr(asu64(R1));
	x = asi64(R1);
	goto L4185;
L4184:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaladdexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L4188;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4189;
	goto L4190;
L4188:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) >>= asi64(R2);
	x = asi64(R1);
	goto L4187;
L4189:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) <<= asi64(R2);
	x = asi64(R1);
	goto L4187;
L4190:
L4187:
L4185:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4184;
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L4184;
	asi64(R1) = x;
	goto L4183;
L4183:
	return asi64(R1);
}

static i64 cc_lex_evaladdexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalmulexpr(asu64(R1));
	x = asi64(R1);
	goto L4193;
L4192:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalmulexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4196;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4197;
	goto L4198;
L4196:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) += asi64(R1);
	goto L4195;
L4197:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) -= asi64(R1);
	goto L4195;
L4198:
L4195:
L4193:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4192;
	asi64(R1) = opc;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4192;
	asi64(R1) = x;
	goto L4191;
L4191:
	return asi64(R1);
}

static i64 cc_lex_evalmulexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	x = asi64(R1);
	goto L4201;
L4200:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4204;
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4204;
	R1 = tou64("#if:div by zero");
	cc_lex_lxerror(asu64(R1));
L4204:
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4206;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4207;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L4208;
	goto L4209;
L4206:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) *= asi64(R1);
	goto L4205;
L4207:
	asi64(R1) = x;
	asi64(R2) = y;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	x = asi64(R1);
	goto L4205;
L4208:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) %= asi64(R2);
	x = asi64(R1);
	goto L4205;
L4209:
L4205:
L4201:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4200;
	asi64(R1) = opc;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4200;
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L4200;
	asi64(R1) = x;
	goto L4199;
L4199:
	return asi64(R1);
}

static i64 cc_lex_evalunaryexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 opc;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4212;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4212;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L4212;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L4212;
	goto L4213;
L4212:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lexm();
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	x = asi64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4215;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4216;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L4217;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L4218;
	goto L4219;
L4215:
	asi64(R1) = x;
	goto L4210;
	goto L4214;
L4216:
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L4210;
	goto L4214;
L4217:
	asi64(R1) = x;
	asi64(R1) = !asi64(R1);
	goto L4210;
	goto L4214;
L4218:
	asi64(R1) = x;
	asi64(R1) = ~asi64(R1);
	goto L4210;
	goto L4214;
L4219:
L4214:
	goto L4211;
L4213:
L4211:
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalterm(asu64(R1));
	goto L4210;
L4210:
	return asi64(R1);
}

static i64 cc_lex_evalterm(u64 sx) {
    u64 R1, R2, R3, R4; 
	i64 res;
	i64 lb;
	R1 = 1;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4222;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L4223;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L4224;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4225;
	goto L4226;
L4222:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L4228;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L4229;
	goto L4230;
L4228:
	R1 = 1;
	cc_lex_noexpand = asi64(R1);
	R1 = 0;
	lb = asi64(R1);
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4232;
	R1 = 1;
	lb = asi64(R1);
	cc_lex_lexm();
L4232:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4234;
	R1 = tou64("defined?");
	cc_lex_lxerror(asu64(R1));
L4234:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	res = asi64(R1);
	cc_lex_lexm();
	asi64(R1) = lb;
	if (!asi64(R1)) goto L4236;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4238;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L4238:
	cc_lex_lexm();
L4236:
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	goto L4227;
L4229:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4240;
	R1 = tou64("'(' expected");
	cc_lex_lxerror(asu64(R1));
L4240:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4242;
	R1 = tou64("name expected");
	cc_lex_lxerror(asu64(R1));
L4242:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4244;
	goto L4245;
L4244:
	R1 = (u64)&cc_tables_typespecsizes;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 100;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	res = asi64(R1);
	goto L4243;
L4245:
	R1 = tou64("sizeof2");
	cc_lex_lxerror(asu64(R1));
L4243:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4247;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L4247:
	cc_lex_lexm();
	goto L4227;
L4230:
	cc_lex_lexm();
	R1 = 0;
	goto L4220;
L4227:
	goto L4221;
L4223:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	res = asi64(R1);
	cc_lex_lexm();
	goto L4221;
L4224:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4249;
	R1 = 0;
	res = asi64(R1);
	goto L4248;
L4249:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	res = asi64(R1);
L4248:
	cc_lex_lexm();
	goto L4221;
L4225:
	cc_lex_lexm();
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	res = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4251;
	R1 = tou64(") expected");
	cc_lex_lxerror(asu64(R1));
L4251:
	cc_lex_lexm();
	goto L4221;
L4226:
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_printsymbol(asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("evalterm?");
	cc_lex_lxerror(asu64(R1));
L4221:
	asi64(R1) = res;
	goto L4220;
L4220:
	return asi64(R1);
}

static i64 cc_lex_getifdef() {
    u64 R1, R2; 
	i64 res;
	u64 d;
	R1 = 1;
	cc_lex_noexpand = asi64(R1);
	cc_lex_lexreadtoken();
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4254;
	R1 = tou64("Name expected");
	cc_lex_lxerror(asu64(R1));
L4254:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	res = asi64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4256;
	R1 = 1;
	res = asi64(R1);
	goto L4255;
L4256:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4257;
	R1 = 1;
	res = asi64(R1);
L4257:
L4255:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4259;
	R1 = tou64("EOL expected");
	cc_lex_lxerror(asu64(R1));
L4259:
	asi64(R1) = res;
	goto L4252;
L4252:
	return asi64(R1);
}

static i64 cc_lex_skipcode() {
    u64 R1, R2; 
	i64 level;
	i64 dir;
	u64 pp;
	R1 = 0;
	level = asi64(R1);
L4261:
	cc_lex_fastreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4264;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4265;
	goto L4266;
L4264:
	asi64(R1) = cc_lex_getlexdirective();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4268;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4268;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4268;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4269;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4269;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4270;
	goto L4271;
L4268:
	R1 = (u64)&level;
	(*toi64p(R1)) += 1;
	goto L4267;
L4269:
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4273;
	asi64(R1) = dir;
	goto L4260;
L4273:
	goto L4267;
L4270:
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4275;
	asi64(R1) = dir;
	goto L4260;
L4275:
	R1 = (u64)&level;
	(*toi64p(R1)) -=1;
	goto L4267;
L4271:
L4267:
	goto L4263;
L4265:
	R1 = tou64("#if:Unexpected eof");
	cc_lex_lxerror(asu64(R1));
	goto L4263;
L4266:
L4263:
	goto L4261;
	R1 = 0;
	goto L4260;
L4260:
	return asi64(R1);
}

static void cc_lex_freetokens(u64 tk) {
    u64 R1, R2; 
	u64 nexttk;
	goto L4278;
L4277:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nexttk = asu64(R1);
	asu64(R1) = nexttk;
	tk = asu64(R1);
L4278:
	asu64(R1) = tk;
	if (asu64(R1)) goto L4277;
	return;
}

static void cc_lex_fastreadtoken() {
    u64 R1, R2, R3; 
	i64 c;
	i64 csum;
	i64 hsum;
	i64 commentseen;
	i64 dodir;
	i64 j;
	u64 pstart;
	u64 p;
	u64 ss;
L4281:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 0: goto L4306;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: goto L4284;
	case 10: goto L4305;
	case 12: goto L4309;
	case 13: goto L4304;
	case 34: goto L4303;
	case 35: goto L4285;
	case 39: goto L4302;
	case 47: goto L4297;
	default: goto L4284;
    };
// SWITCH
L4285:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	dodir = asi64(R1);
	goto L4287;
L4286:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L4290;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L4291;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L4291;
	goto L4292;
L4290:
	R1 = 1;
	dodir = asi64(R1);
	goto L4288;
	goto L4289;
L4291:
	goto L4289;
L4292:
	goto L4288;
L4289:
	R1 = (u64)&p;
	(*tou64p(R1)) -=1;
L4287:
	asu64(R1) = p;
	asu64(R2) = cc_lex_lxstart;
	if (asu64(R1) >= asu64(R2)) goto L4286;
L4288:
	asi64(R1) = dodir;
	if (asi64(R1)) goto L4295;
	asu64(R1) = p;
	asu64(R2) = cc_lex_lxstart;
	if (asu64(R1) >= asu64(R2)) goto L4294;
L4295:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4280;
	goto L4293;
L4294:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) != asu64(R2)) goto L4296;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L4296:
L4293:
	goto L4281;
L4297:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L4299;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L4300;
	goto L4301;
L4299:
	cc_lex_readlinecomment();
	goto L4298;
L4300:
	cc_lex_readblockcomment();
	goto L4298;
L4301:
L4298:
	goto L4281;
L4302:
	R1 = 0;
	R2 = 39;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L4281;
L4303:
	R1 = 0;
	R2 = 34;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L4281;
L4304:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L4281;
L4305:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4281;
L4306:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = cc_lex_lx_stackindex;
	if (!asi64(R1)) goto L4308;
	cc_lex_unstacksourcefile();
	goto L4307;
L4308:
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4280;
L4307:
	goto L4281;
L4309:
	goto L4281;
L4284:
	goto L4281;
L4280:
	return;
}

static u64 cc_lex_alloctoken() {
    u64 R1; 
	u64 tk;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	tk = asu64(R1);
	asu64(R1) = tk;
	goto L4310;
L4310:
	return asu64(R1);
}

static u64 cc_lex_alloctokenz() {
    u64 R1, R2, R3; 
	u64 tk;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	tk = asu64(R1);
	R1 = 0;
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	goto L4311;
L4311:
	return asu64(R1);
}

static void cc_lex_expandpredefmacro(i64 pdmcode, u64 tk, i64 lineno) {
    u64 R1, R2, R3; 
	struct $B16 str;
	struct $B3 tm;
	u64 s;
	i64 fileno;
// PROC LOCAL STATICS GO HERE
	static struct $B28 cc_lex_expandpredefmacro_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L4314;
	goto L4312;
L4314:
	asi64(R1) = pdmcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4316;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4317;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4318;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4319;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4320;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4321;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4322;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4323;
	goto L4324;
L4316:
	R1 = (u64)&tm;
	mnoos_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_lex_expandpredefmacro_monthnames;
	R2 = (u64)&tm;
	R3 = 2;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4315;
L4317:
	R1 = (u64)&tm;
	mnoos_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("2");
	R2 = (u64)&tm;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 10;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 12;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4315;
L4318:
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = tk;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4326;
	asi64(R1) = cc_decls_sfileno;
	fileno = asi64(R1);
L4326:
	asi64(R1) = cc_decls_sfileno;
	if (!asi64(R1)) goto L4328;
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = cc_decls_sfileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4327;
L4328:
	R1 = tou64("(File not available)");
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4327:
	goto L4315;
L4319:
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L4330;
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4329;
L4330:
	R1 = tou64("???");
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4329:
	goto L4315;
L4320:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = lineno;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4315;
L4321:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4315;
L4322:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4315;
L4323:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu8(R1) = cc_decls_pci_target;
	R1 = toi64(tou8(R1));
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4315;
L4324:
	msysc_m$print_startcon();
	asi64(R1) = pdmcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PDM");
	cc_lex_lxerror(asu64(R1));
L4315:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L4332;
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = tk;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = tk;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4331;
L4332:
	R1 = 3;
	asu64(R2) = tk;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = tk;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = tk;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_npastedtokens;
	R2 = 87000;
	if (asi64(R1) < asi64(R2)) goto L4334;
	R1 = tou64("2:Too many pasted tokens");
	cc_lex_lxerror(asu64(R1));
L4334:
	asu64(R1) = s;
	R2 = (u64)&cc_lex_pastedtokenlist;
	R3 = (u64)&cc_lex_npastedtokens;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = tk;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	asi64(R1) = cc_lex_npastedtokens;
	asu64(R2) = tk;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4331:
L4312:
	return;
}

static void cc_lex_dopragmadir() {
    u64 R1, R2, R3, R4; 
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4337;
	R1 = 4;
	R2 = tou64("pack");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4339;
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4341;
	R1 = tou64("'(' expected");
	cc_lex_lxerror(asu64(R1));
L4341:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L4343;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4345;
	goto L4346;
L4345:
	R1 = 0;
	cc_decls_structpadding = asi64(R1);
	goto L4344;
L4346:
	goto L4347;
	R1 = tou64("Only pack(1) or () allowed");
	cc_lex_lxerror(asu64(R1));
L4344:
	cc_lex_lexm();
	goto L4342;
L4343:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L4348;
	R1 = 1;
	cc_decls_structpadding = asi64(R1);
L4348:
L4342:
	goto L4338;
L4339:
	R1 = 6;
	R2 = tou64("module");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4349;
	R1 = 77;
	cc_lex_addbuildinfo(asi64(R1));
	goto L4338;
L4349:
	R1 = 6;
	R2 = tou64("header");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4350;
	R1 = 72;
	cc_lex_addbuildinfo(asi64(R1));
	goto L4338;
L4350:
	R1 = 4;
	R2 = tou64("link");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4351;
	R1 = 76;
	cc_lex_addbuildinfo(asi64(R1));
L4351:
L4338:
L4337:
// cc_lex.dopragmadir.finish:
L4347:
	goto L4353;
L4352:
	cc_lex_lexm();
L4353:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4355;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L4352;
L4355:
	return;
}

static void cc_lex_addbuildinfo(i64 code) {
    u64 R1, R2, R3; 
	u64 file;
	i64 j;
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L4358;
	R1 = tou64("Str expected");
	cc_lex_lxerror(asu64(R1));
L4358:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file = asu64(R1);
	asi64(R1) = code;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L4360;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L4361;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L4362;
	goto L4363;
L4360:
	asi64(R1) = cc_decls_npmodules;
	R2 = 199;
	if (asi64(R1) < asi64(R2)) goto L4365;
	R1 = tou64("TMM");
	cc_lex_lxerror(asu64(R1));
L4365:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pmodulelist;
	R3 = (u64)&cc_decls_npmodules;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4359;
L4361:
	asi64(R1) = cc_decls_npheaders;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L4367;
	R1 = tou64("TMH");
	cc_lex_lxerror(asu64(R1));
L4367:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pheaderlist;
	R3 = (u64)&cc_decls_npheaders;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4359;
L4362:
	asi64(R1) = cc_decls_nplibs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L4369;
	R1 = tou64("TMLM");
	cc_lex_lxerror(asu64(R1));
L4369:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pliblist;
	R3 = (u64)&cc_decls_nplibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4359;
L4363:
L4359:
	cc_lex_lexm();
	return;
}

static i64 cc_lex_needspace(i64 a, i64 b) {
    u64 R1, R2; 
	u64 aname;
	u64 bname;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4372;
	R1 = 0;
	goto L4370;
L4372:
	R1 = (u64)&cc_tables_shortsymbolnames;
	asi64(R2) = a;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	aname = asu64(R1);
	R1 = (u64)&cc_tables_shortsymbolnames;
	asi64(R2) = b;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	bname = asu64(R1);
	asu64(R1) = bname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L4374;
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L4374;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L4375;
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L4375;
	goto L4376;
L4374:
	asu64(R1) = aname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L4378;
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L4378;
	goto L4379;
L4378:
	R1 = 1;
	goto L4370;
	goto L4377;
L4379:
L4377:
	goto L4373;
L4375:
	asu64(R1) = aname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L4381;
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L4381;
	goto L4382;
L4381:
	R1 = 1;
	goto L4370;
	goto L4380;
L4382:
L4380:
	goto L4373;
L4376:
L4373:
	R1 = 0;
	goto L4370;
L4370:
	return asi64(R1);
}

static void cc_lex_dospecialinclude() {
    u64 R1, R2; 
	R1 = 1;
	R2 = tou64("mcc.h");
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_dheaderfile;
	if (!asu64(R1)) goto L4385;
	R1 = 1;
	asu64(R2) = cc_decls_dheaderfile;
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
L4385:
	return;
}

static void cc_lex_setnumberoffset(i64 offset) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4278190080;
	asi64(R1) &= asi64(R2);
	asi64(R2) = offset;
	R3 = 16777215;
	asi64(R2) &= asi64(R3);
	asi64(R1) |= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void cc_lex_setfileno(i64 fileno) {
    u64 R1, R2, R3; 
	asi64(R1) = fileno;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asi64(R2) = fileno;
	R3 = 65280;
	asi64(R2) &= asi64(R3);
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void cc_lex_setfilenox(u64 tk, i64 fileno) {
    u64 R1, R2, R3; 
	asi64(R1) = fileno;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	asu64(R2) = tk;
	R3 = 20;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asi64(R2) = fileno;
	R3 = 65280;
	asi64(R2) &= asi64(R3);
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = tk;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 cc_lex_getfileno() {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	asi64(R1) >>= asi64(R2);
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	goto L4389;
L4389:
	return asi64(R1);
}

static i64 cc_lex_getfilenox(u64 tk) {
    u64 R1, R2, R3; 
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	asi64(R1) >>= asi64(R2);
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = tk;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	goto L4390;
L4390:
	return asi64(R1);
}

static i64 cc_lex_getnumberoffsetx(u64 tk) {
    u64 R1, R2; 
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	goto L4391;
L4391:
	return asi64(R1);
}

static void cc_lex_freehashtable() {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	u64 f;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4395;
L4393:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4397;
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4397;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4399;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_freetokens(asu64(R1));
L4399:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L4401;
L4400:
	asu64(R1) = f;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 128;
	asu64(R2) = f;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = e;
	f = asu64(R1);
L4401:
	asu64(R1) = f;
	if (asu64(R1)) goto L4400;
	R1 = 128;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	goto L4396;
L4397:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4403;
	R1 = 0;
	asu64(R2) = d;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4403:
L4396:
	i += 1; if (i <= cc_decls_hstmask) goto L4393;
L4395:
	return;
}

static void cc_lex_regenlookup(u64 d) {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 length;
	u64 e;
	asu64(R1) = d;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	asi64(R2) = cc_decls_hstmask;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L4405:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	length = asi64(R1);
	asi64(R1) = length;
	if (asi64(R1)) goto L4408;
	R1 = 128;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = j;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = d;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_lex_nhstsymbols;
	(*toi64p(R1)) += 1;
	goto L4404;
L4408:
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 106;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L4410;
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = e;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4412;
	R1 = tou64("regenhst dupl?");
	cc_lex_lxerror(asu64(R1));
L4412:
L4410:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = cc_decls_hstsize;
	if (asi64(R1) < asi64(R2)) goto L4414;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L4416;
	R1 = tou64("REGENHST FULL?");
	mlib_abortprogram(asu64(R1));
L4416:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L4414:
	goto L4405;
L4404:
	return;
}

static void cc_lex_newhashtable() {
    u64 R1, R2, R3; 
	u64 oldhashtable;
	i64 oldhstsize;
	u64 d;
	i64 av_1;
	i64 i;
	asu64(R1) = cc_decls_hashtable;
	oldhashtable = asu64(R1);
	asi64(R1) = cc_decls_hstsize;
	oldhstsize = asi64(R1);
	R1 = 2;
	R2 = (u64)&cc_decls_hstsize;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cc_decls_hstmask = asi64(R1);
	R1 = 0;
	cc_lex_nhstsymbols = asi64(R1);
	R1 = 6;
	asi64(R2) = cc_decls_hstsize;
	asi64(R1) *= asi64(R2);
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	cc_lex_hstthreshold = asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_decls_hashtable = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4420;
L4418:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= cc_decls_hstmask) goto L4418;
L4420:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = oldhstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4423;
L4421:
	asu64(R1) = oldhashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4425;
	asu64(R1) = d;
	cc_lex_regenlookup(asu64(R1));
L4425:
	i += 1; if (i <= av_1) goto L4421;
L4423:
	asi64(R1) = oldhstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = oldhashtable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void cc_lex_old_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base) {
    u64 R1, R2, R3, R4; 
	u64 fractstart;
	i64 fractlen;
	i64 expon;
	i64 i;
	i64 c;
	i64 badexpon;
	r64 basex;
	r64 x;
	r64 expbase;
	struct $B80 realstr;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	R1 = 0;
	fractstart = asu64(R1);
	R1 = 0;
	fractlen = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L4428;
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	fractstart = asu64(R1);
	asi64(R1) = base;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = fractstart;
	asi64(R1) -= asi64(R2);
	fractlen = asi64(R1);
L4428:
	R1 = 0;
	badexpon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 101;
	if (asu64(R1) == asu64(R2)) goto L4430;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L4430;
	R2 = 112;
	if (asu64(R1) == asu64(R2)) goto L4431;
	R2 = 80;
	if (asu64(R1) == asu64(R2)) goto L4431;
	goto L4432;
L4430:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4434;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L4434:
	goto L4429;
L4431:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L4436;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L4436:
	goto L4429;
L4432:
L4429:
	asi64(R1) = badexpon;
	if (!asi64(R1)) goto L4438;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L4426;
L4438:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 102;
	if (asu64(R1) == asu64(R2)) goto L4440;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L4440;
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L4440;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L4440;
	goto L4441;
L4440:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L4439;
L4441:
	R1 = (u64)&cc_lex_alphamap;
	asu64(R2) = cc_lex_lxsptr;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4443;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L4426;
L4443:
L4439:
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L4445;
	R1 = tou64("Real too long");
	cc_lex_lxerror(asu64(R1));
L4445:
	asi64(R1) = intlen;
	if (!asi64(R1)) goto L4447;
	asi64(R1) = intlen;
	asu64(R2) = intstart;
	R3 = (u64)&realstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L4447:
	asi64(R1) = fractlen;
	if (!asi64(R1)) goto L4449;
	asi64(R1) = fractlen;
	asu64(R2) = fractstart;
	R3 = (u64)&realstr;
	R4 = 0;
	R3 += (i64)R4;
	asi64(R4) = intlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L4449:
	asi64(R1) = base;
	asr64(R1) = tor64(asi64(R1));
	R2 = R1;
	basex = asr64(R2);
	expbase = asr64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4451;
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	goto L4450;
L4451:
	asi64(R1) = fractlen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 2.000000000000000000e+000;
	expbase = asr64(R1);
L4450:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4454;
L4452:
	R1 = (u64)&realstr;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L4456;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L4456;
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	x = asr64(R1);
	goto L4455;
L4456:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) <= asi64(R2)) goto L4457;
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 97;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) += asr64(R2);
	x = asr64(R1);
	goto L4455;
L4457:
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 65;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) += asr64(R2);
	x = asr64(R1);
L4455:
	i += 1; if (i <= av_1) goto L4452;
L4454:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4459;
	asi64(R1) = expon;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4462;
L4460:
	asr64(R1) = expbase;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_2)) goto L4460;
L4462:
	goto L4458;
L4459:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4465;
L4463:
	asr64(R1) = expbase;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_3)) goto L4463;
L4465:
L4458:
	R1 = 60;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = intstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = intstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4426:
	return;
}

static i64 cc_lex_issimpleconstmacro(u64 m) {
    u64 R1, R2, R3; 
	u64 tk;
	i64 av_1;
	i64 i;
// PROC LOCAL STATICS GO HERE
	static struct $B8 cc_lex_issimpleconstmacro_specialnames = {{
	(u64)"stdin",
	(u64)"stdout",
	(u64)"stderr"    }};
	R1 = 1;
	i = asi64(R1);
	R1 = 3;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4469;
L4467:
	asu64(R1) = m;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_lex_issimpleconstmacro_specialnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4471;
	R1 = 2;
	goto L4466;
L4471:
	i += 1; if (i <= av_1) goto L4467;
L4469:
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
	asu64(R1) = tk;
	if (!asu64(R1)) goto L4473;
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4473;
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L4476;
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) != asi64(R2)) goto L4475;
L4476:
	R1 = 1;
	goto L4466;
L4475:
L4473:
	R1 = 0;
	goto L4466;
L4466:
	return asi64(R1);
}

static void cc_parse_readmodule() {
    u64 R1, R2, R3, R4, R5; 
	i64 linkage;
	i64 m;
	i64 mbase;
	i64 commaseen;
	i64 wasdef;
	u64 p;
	u64 d;
	u64 pm;
	i64 t;
	i64 nitems;
	i64 wasenum;
	goto L4479;
L4478:
	R1 = 0;
	nitems = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4482;
	goto L4483;
L4482:
	R1 = tou64("Extra semicolon 2");
	cc_support_serror(asu64(R1));
	goto L4481;
L4483:
L4481:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	wasenum = asi64(R1);
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_stmodule;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	commaseen = asi64(R1);
L4484:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4486;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4486;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4486;
	goto L4487;
L4486:
	R1 = (u64)&nitems;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_stmodule;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4489;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L4489:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4491;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L4493;
	asu64(R1) = pm;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	m = asi64(R1);
L4493:
	asi64(R1) = m;
	asu64(R2) = d;
	asu64(R3) = cc_decls_stmodule;
	asu64(R1) = cc_parse_createtypedef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L4490;
L4491:
	asu64(R1) = pm;
	if (!asu64(R1)) goto L4494;
// cc_parse.readmodule.readfn:
L4495:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4497;
	asi64(R1) = commaseen;
	if (!asi64(R1)) goto L4497;
	R1 = tou64("fn def after comma");
	cc_support_serror(asu64(R1));
L4497:
	R1 = (u64)&wasdef;
	asu64(R2) = pm;
	asi64(R3) = linkage;
	asi64(R4) = m;
	asu64(R5) = d;
	asu64(R1) = cc_parse_readfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	d = asu64(R1);
	asi64(R1) = wasdef;
	if (!asi64(R1)) goto L4499;
	goto L4485;
L4499:
	goto L4490;
L4494:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L4500;
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	goto L4495;
	goto L4490;
L4500:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readmodulevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
L4490:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4502;
	goto L4503;
L4502:
	R1 = 1;
	commaseen = asi64(R1);
	cc_lex_lex();
	goto L4501;
L4503:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L4485;
L4501:
	goto L4484;
L4487:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4505;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L4505;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4505;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4506;
	goto L4507;
L4505:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L4485;
	goto L4504;
L4506:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L4485;
	goto L4504;
L4507:
	asi64(R1) = mbase;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4504:
	goto L4484;
L4485:
L4479:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L4478;
	return;
}

static i64 cc_parse_parsemodule() {
    u64 R1, R2, R3; 
	i64 size;
	i64 t;
	u64 owner;
	r64 tsecs;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4510;
	msysc_m$print_startcon();
	R1 = tou64("Parsing:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4510:
	R1 = 0;
	R2 = R1;
	cc_parse_ingeneric = asu8(R2);
	cc_parse_loopindex = asi64(R1);
	R1 = 0;
	cc_parse_ist_symptr = asu64(R1);
	R1 = 512;
	R2 = 0;
	R3 = (u64)&cc_parse_casevaluestack;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asi64(R1) = cc_decls_mainfileno;
	R2 = tou64("PARSETEST");
	cc_lex_startlex(asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	R1 = 0;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	cc_parse_loopindex = asi64(R1);
	cc_lex_lex();
	cc_parse_readmodule();
	cc_lex_endlex();
	R1 = 1;
	goto L4508;
L4508:
	return asi64(R1);
}

static i64 cc_parse_readdeclspec(u64 owner, u64 linkage) {
    u64 R1, R2, R3; 
	struct $B63 d;
	u64 p;
	i64 t;
	i64 mod;
	i64 m;
	i64 fstruct;
	u64 pm;
	u64 e;
	R1 = 15;
	R2 = 0;
	R3 = (u64)&d;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 20;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	mod = asi64(R2);
	fstruct = asi64(R1);
L4512:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 67: goto L4563;
	case 68: case 69: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 89: goto L4515;
	case 70: goto L4517;
	case 83: case 84: goto L4557;
	case 85: goto L4550;
	case 86: goto L4544;
	case 87: goto L4516;
	case 88: goto L4553;
	case 90: goto L4560;
	default: goto L4515;
    };
// SWITCH
L4516:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	cc_lex_lex();
	goto L4512;
L4517:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: case 2: case 5: case 6: case 7: case 10: goto L4521;
	case 3: goto L4527;
	case 4: goto L4531;
	case 8: goto L4536;
	case 9: goto L4540;
	default: goto L4520;
    };
// SWITCH
L4521:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4523;
	asi64(R1) = fstruct;
	if (!asi64(R1)) goto L4525;
	R1 = 9;
	cc_lib_checksymbol(asi64(R1));
	goto L4524;
L4525:
	goto L4526;
L4524:
L4523:
	R1 = (u64)&cc_tables_typespectypes;
	R2 = (u64)&cc_decls_lx;
	R3 = 22;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4518;
L4527:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4530;
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4530;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4529;
L4530:
	goto L4526;
L4529:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4518;
L4531:
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4534;
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4533;
L4534:
	goto L4526;
	goto L4532;
L4533:
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4535;
	R1 = 0;
	R2 = (u64)&d;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4532;
L4535:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4532:
	R1 = 1;
	mod = asi64(R1);
	goto L4518;
L4536:
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4539;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4538;
L4539:
	goto L4526;
L4538:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4518;
L4540:
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4543;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4542;
L4543:
	goto L4526;
L4542:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4518;
L4520:
// cc_parse.readdeclspec.tserror:
L4526:
	R1 = (u64)&cc_tables_typespecnames;
	R2 = (u64)&cc_decls_lx;
	R3 = 22;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("declspec/ts #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4518:
	cc_lex_lex();
	goto L4512;
L4544:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4546;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4547;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4548;
	goto L4549;
L4546:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4545;
L4547:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4545;
L4548:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4545;
L4549:
L4545:
	cc_lex_lex();
	goto L4512;
L4550:
	R1 = (u64)&d;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4552;
	R1 = tou64("Dual storage spec");
	cc_support_serror(asu64(R1));
L4552:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&d;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	goto L4512;
L4553:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4555;
	goto L4556;
L4555:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4554;
L4556:
L4554:
	cc_lex_lex();
	goto L4512;
L4557:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4559;
	R1 = tou64("struct?");
	cc_support_serror(asu64(R1));
L4559:
	asu64(R1) = owner;
	asi64(R1) = cc_parse_readstructdecl(asu64(R1));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	fstruct = asi64(R1);
	goto L4512;
L4560:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4562;
	R1 = tou64("enum?");
	cc_support_serror(asu64(R1));
L4562:
	asu64(R1) = owner;
	asi64(R1) = cc_parse_readenumdecl(asu64(R1));
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4512;
L4563:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L4565;
	asu64(R1) = owner;
	asi64(R1) = cc_parse_isusertype(asu64(R1));
	R2 = R1;
	m = asi64(R2);
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4565;
	asi64(R1) = mod;
	if (!asi64(R1)) goto L4567;
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4513;
L4567:
	asi64(R1) = m;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	goto L4564;
L4565:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L4569;
	asi64(R1) = mod;
	if (asi64(R1)) goto L4569;
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Implicit decls not allowed: #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4569:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L4571;
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4571:
	goto L4513;
L4564:
	goto L4512;
L4515:
	goto L4513;
	goto L4512;
L4513:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4573;
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L4572;
L4573:
	R1 = 3;
L4572:
	t = asi64(R1);
	R1 = (u64)&d;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4575;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4577;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4578;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4579;
	goto L4580;
L4577:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4582;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4584;
	R1 = 7;
	goto L4583;
L4584:
	R1 = 2;
L4583:
	t = asi64(R1);
	goto L4581;
L4582:
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4585;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4587;
	R1 = 8;
	goto L4586;
L4587:
	R1 = 3;
L4586:
	t = asi64(R1);
	goto L4581;
L4585:
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4588;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4590;
	R1 = 9;
	goto L4589;
L4590:
	R1 = 4;
L4589:
	t = asi64(R1);
	goto L4581;
L4588:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4591;
	R1 = 8;
	t = asi64(R1);
L4591:
L4581:
	goto L4576;
L4578:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4594;
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4594;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4593;
L4594:
	R1 = tou64("char decl?");
	cc_support_serror(asu64(R1));
L4593:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4596;
	R1 = 6;
	goto L4595;
L4596:
	R1 = 1;
L4595:
	t = asi64(R1);
	goto L4576;
L4579:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4599;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4599;
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4599;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4598;
L4599:
	R1 = tou64("dbl decl?");
	cc_support_serror(asu64(R1));
L4598:
	goto L4576;
L4580:
	asi64(R1) = mod;
	if (!asi64(R1)) goto L4601;
	R1 = tou64("declspec/float");
	cc_support_serror(asu64(R1));
L4601:
L4576:
L4575:
	R1 = (u64)&d;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4603;
	asi64(R1) = t;
	asi64(R1) = cc_lib_createconstmode(asi64(R1));
	t = asi64(R1);
L4603:
	R1 = (u64)&d;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = linkage;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = t;
	goto L4511;
L4511:
	return asi64(R1);
}

static i64 cc_parse_istypestarter() {
    u64 R1, R2, R3, R4; 
	u64 d;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4606;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4606;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4607;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4608;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4609;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4609;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L4609;
	goto L4610;
L4606:
	R1 = 1;
	goto L4604;
	goto L4605;
L4607:
	R1 = 1;
	goto L4604;
	goto L4605;
L4608:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L4612;
	asu64(R4) = cc_decls_currproc;
	goto L4611;
L4612:
	asu64(R4) = cc_decls_stmodule;
L4611:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L4614;
	asu64(R1) = d;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L4604;
L4614:
	goto L4605;
L4609:
	R1 = 1;
	goto L4604;
	goto L4605;
L4610:
L4605:
	R1 = 0;
	goto L4604;
L4604:
	return asi64(R1);
}

static i64 cc_parse_istypestarter_next() {
    u64 R1, R2, R3, R4; 
	u64 d;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4617;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4617;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4618;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4619;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4620;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4620;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L4620;
	goto L4621;
L4617:
	R1 = 1;
	goto L4615;
	goto L4616;
L4618:
	R1 = 1;
	goto L4615;
	goto L4616;
L4619:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L4623;
	asu64(R4) = cc_decls_currproc;
	goto L4622;
L4623:
	asu64(R4) = cc_decls_stmodule;
L4622:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L4625;
	asu64(R1) = d;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L4615;
L4625:
	goto L4616;
L4620:
	R1 = 1;
	goto L4615;
	goto L4616;
L4621:
L4616:
	R1 = 0;
	goto L4615;
L4615:
	return asi64(R1);
}

static u64 cc_parse_readexpression() {
    u64 R1, R2, R3; 
	u64 p;
	u64 ulist;
	u64 ulistx;
	i64 t;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4628;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4628;
	goto L4629;
L4628:
	asu64(R1) = cc_parse_readterm();
	goto L4626;
	goto L4627;
L4629:
L4627:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4631;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L4632:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4635;
	goto L4633;
L4635:
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	goto L4632;
L4633:
	asu64(R1) = ulist;
	R2 = 29;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = ulistx;
	if (!asu64(R1)) goto L4637;
	asu64(R1) = ulistx;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4637:
	asu64(R1) = p;
	goto L4626;
L4631:
	asu64(R1) = p;
	goto L4626;
L4626:
	return asu64(R1);
}

static u64 cc_parse_readassignexpr() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 r;
	i64 opc;
	i64 oldpmode;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4640;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4640;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4640;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4641;
	goto L4642;
L4640:
	asu64(R1) = cc_parse_readterm();
	goto L4638;
	goto L4639;
L4641:
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L4643;
	goto L4639;
L4642:
L4639:
	asu64(R1) = cc_parse_readcondexpr();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	switch (asi64(R1)) {
	case 11: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L4647;
	case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: goto L4646;
	default: goto L4646;
    };
// SWITCH
L4647:
// cc_parse.readassignexpr.gotp:
L4643:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldpmode = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
	asu64(R1) = cc_parse_readassignexpr();
	q = asu64(R1);
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4649;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = opc;
	asu64(R1) = cc_parse_createassignopref(asi64(R3), asu64(R2), asu64(R1));
	goto L4638;
L4649:
	asi64(R1) = oldpmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = oldpmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4651;
	R1 = tou64("Modifying read-only var");
	cc_support_terror(asu64(R1));
L4651:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L4653;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4653;
	R1 = tou64("Modifying constant?");
	cc_support_terror(asu64(R1));
L4653:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	asi64(R1) = oldpmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L4638;
	goto L4644;
L4646:
L4644:
	asu64(R1) = p;
	goto L4638;
L4638:
	return asu64(R1);
}

static u64 cc_parse_readcondexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	u64 pcond;
	i64 s;
	i64 t;
	i64 u;
	asu64(R1) = cc_parse_readorlexpr();
	pcond = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4656;
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	x = asu64(R1);
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readcondexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4658;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4660;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4660;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4660;
	asu64(R1) = pcond;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4662;
	asu64(R1) = x;
	goto L4661;
L4662:
	asu64(R1) = y;
L4661:
	goto L4654;
L4660:
	goto L4657;
L4658:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4663;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4663;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L4657;
L4663:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4664;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4664;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4664;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4664;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	goto L4657;
L4664:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4665;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4665;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4665;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4665;
	asu64(R1) = y;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	goto L4657;
L4665:
	asi64(R1) = s;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L4666;
	asi64(R1) = t;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L4666;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L4657;
L4666:
	asi64(R1) = s;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4667;
	asi64(R1) = t;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4667;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L4657;
L4667:
	asi64(R1) = s;
	asi64(R2) = t;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L4668;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4668;
	R1 = 0;
	u = asi64(R1);
	goto L4657;
L4668:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("?: incompatible types");
	cc_support_terror(asu64(R1));
L4657:
	asu64(R1) = y;
	asu64(R2) = x;
	asu64(R3) = pcond;
	R4 = 31;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	pcond = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = pcond;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4656:
	asu64(R1) = pcond;
	goto L4654;
L4654:
	return asu64(R1);
}

static u64 cc_parse_readorlexpr() {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = cc_parse_readandlexpr();
	x = asu64(R1);
	goto L4671;
L4670:
	cc_lex_lex();
	asu64(R1) = cc_parse_readandlexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = y;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4674;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4674;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L4677;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4676;
L4677:
	R1 = 1;
	goto L4675;
L4676:
	R1 = 0;
L4675:
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4671;
L4674:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 25;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4671:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L4670;
	asu64(R1) = x;
	goto L4669;
L4669:
	return asu64(R1);
}

static u64 cc_parse_readandlexpr() {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = cc_parse_readiorexpr();
	x = asu64(R1);
	goto L4680;
L4679:
	cc_lex_lex();
	asu64(R1) = cc_parse_readiorexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = y;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4683;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4683;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4685;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4685;
	R1 = 1;
	goto L4684;
L4685:
	R1 = 0;
L4684:
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4680;
L4683:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 24;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4680:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4679;
	asu64(R1) = x;
	goto L4678;
L4678:
	return asu64(R1);
}

static u64 cc_parse_readiorexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readixorexpr();
	x = asu64(R1);
	goto L4688;
L4687:
	cc_lex_lex();
	asu64(R1) = cc_parse_readixorexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4691;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4693;
	R1 = tou64("float|float");
	cc_support_terror(asu64(R1));
L4693:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4690;
L4691:
	R1 = tou64("invalid | operands");
	cc_support_terror(asu64(R1));
L4690:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4695;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4695;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4697;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4697;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4697;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4697;
	goto L4698;
L4697:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) |= asi64(R1);
	goto L4688;
	goto L4696;
L4698:
L4696:
L4695:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 45;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4688:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L4687;
	asu64(R1) = x;
	goto L4686;
L4686:
	return asu64(R1);
}

static u64 cc_parse_readixorexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readiandexpr();
	x = asu64(R1);
	goto L4701;
L4700:
	cc_lex_lex();
	asu64(R1) = cc_parse_readiandexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4704;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4706;
	R1 = tou64("float^float");
	cc_support_terror(asu64(R1));
L4706:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4703;
L4704:
	R1 = tou64("invalid ^ operands");
	cc_support_terror(asu64(R1));
L4703:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4708;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4708;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4710;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4710;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4710;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4710;
	goto L4711;
L4710:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) ^= asi64(R1);
	goto L4701;
	goto L4709;
L4711:
L4709:
L4708:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 46;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4701:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L4700;
	asu64(R1) = x;
	goto L4699;
L4699:
	return asu64(R1);
}

static u64 cc_parse_readiandexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readeqexpr();
	x = asu64(R1);
	goto L4714;
L4713:
	cc_lex_lex();
	asu64(R1) = cc_parse_readeqexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4717;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4719;
	R1 = tou64("float&float");
	cc_support_terror(asu64(R1));
L4719:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4716;
L4717:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("invalid & operands");
	cc_support_terror(asu64(R1));
L4716:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4721;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4721;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4723;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4723;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4723;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4723;
	goto L4724;
L4723:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) &= asi64(R1);
	goto L4714;
	goto L4722;
L4724:
L4722:
L4721:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 44;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4714:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L4713;
	asu64(R1) = x;
	goto L4712;
L4712:
	return asu64(R1);
}

static u64 cc_parse_readeqexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 s;
	i64 t;
	i64 u;
	i64 ss;
	i64 tt;
	asu64(R1) = cc_parse_readrelexpr();
	x = asu64(R1);
	goto L4727;
L4726:
	cc_lex_lex();
	asu64(R1) = cc_parse_readrelexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4730;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4729;
L4730:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4731;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4731;
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	ss = asi64(R2);
	R2 = (u64)&cc_decls_tttarget;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	tt = asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L4733;
	asi64(R1) = ss;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4735;
	asi64(R1) = tt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4735;
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (asi64(R1)) goto L4737;
	R1 = tou64("Comparing distinct pointers/eq");
	cc_support_terror(asu64(R1));
L4737:
L4735:
L4733:
	goto L4729;
L4731:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4738;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4738;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4741;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4740;
L4741:
	R1 = tou64("Can't compare pointer to int");
	cc_support_terror(asu64(R1));
L4740:
	goto L4729;
L4738:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4742;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4742;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4745;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4744;
L4745:
	R1 = tou64("Can't compare pointer to int2");
	cc_support_terror(asu64(R1));
L4744:
	goto L4729;
L4742:
	msysc_m$print_startcon();
	R1 = tou64("U=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = u;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("invalid == operands");
	cc_support_terror(asu64(R1));
L4729:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4747;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4747;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4749;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4749;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4749;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4749;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4749;
	goto L4750;
L4749:
	asi64(R1) = opc;
	R2 = 40;
	if (asi64(R1) != asi64(R2)) goto L4752;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4751;
L4752:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4751:
	goto L4727;
	goto L4748;
L4750:
L4748:
L4747:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4727:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4726;
	asi64(R1) = opc;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4726;
	asu64(R1) = x;
	goto L4725;
L4725:
	return asu64(R1);
}

static u64 cc_parse_readrelexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 s;
	i64 t;
	i64 u;
	i64 a;
	i64 b;
	i64 c;
	u64 aa;
	u64 bb;
	u64 cc;
	asu64(R1) = cc_parse_readshiftexpr();
	x = asu64(R1);
	goto L4755;
L4754:
	cc_lex_lex();
	asu64(R1) = cc_parse_readshiftexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4758;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4757;
L4758:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4759;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4759;
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (asi64(R1)) goto L4761;
	R1 = tou64("Comparing distinct pointers/rel");
	cc_support_terror(asu64(R1));
L4761:
	goto L4757;
L4759:
	R1 = tou64("invalid rel operands");
	cc_support_terror(asu64(R1));
L4757:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4763;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4763;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4765;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4765;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4766;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4766;
	goto L4767;
L4765:
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4769;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4770;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4771;
	goto L4772;
L4769:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	c = asi64(R1);
	goto L4768;
L4770:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	c = asi64(R1);
	goto L4768;
L4771:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	c = asi64(R1);
	goto L4768;
L4772:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	c = asi64(R1);
L4768:
	asi64(R1) = c;
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4755;
	goto L4764;
L4766:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	aa = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	bb = asu64(R1);
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4774;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4775;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4776;
	goto L4777;
L4774:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	cc = asu64(R1);
	goto L4773;
L4775:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	cc = asu64(R1);
	goto L4773;
L4776:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	cc = asu64(R1);
	goto L4773;
L4777:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  >  asu64(R2);
	cc = asu64(R1);
L4773:
	asu64(R1) = cc;
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4755;
	goto L4764;
L4767:
L4764:
L4763:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4755:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4754;
	asi64(R1) = opc;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4754;
	asi64(R1) = opc;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4754;
	asi64(R1) = opc;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4754;
	asu64(R1) = x;
	goto L4753;
L4753:
	return asu64(R1);
}

static u64 cc_parse_readshiftexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 u;
	asu64(R1) = cc_parse_readaddexpr();
	x = asu64(R1);
	goto L4780;
L4779:
	cc_lex_lex();
	asu64(R1) = cc_parse_readaddexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercebasetype(asu64(R1));
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	u = asi64(R2);
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4784;
	asi64(R1) = u;
	R2 = 9;
	if (asi64(R1) <= asi64(R2)) goto L4783;
L4784:
	R1 = tou64("shift:Not an int");
	cc_support_terror(asu64(R1));
L4783:
	R1 = 3;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4786;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4786;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4788;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4788;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4789;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4789;
	goto L4790;
L4788:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L4792;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) <<= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4791;
L4792:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) >>= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4791:
	goto L4780;
	goto L4787;
L4789:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L4794;
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) <<= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4793;
L4794:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) >>= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4793:
	goto L4780;
	goto L4787;
L4790:
L4787:
L4786:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	R4 = 33;
	if (asi64(R3) != asi64(R4)) goto L4796;
	R3 = 47;
	goto L4795;
L4796:
	R3 = 48;
L4795:
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4780:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4779;
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L4779;
	asu64(R1) = x;
	goto L4778;
L4778:
	return asu64(R1);
}

static u64 cc_parse_readaddexpr() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	i64 opc;
	asu64(R1) = cc_parse_readmulexpr();
	p = asu64(R1);
	goto L4799;
L4798:
	cc_lex_lex();
	asu64(R1) = cc_parse_readmulexpr();
	q = asu64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L4802;
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createaddop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4801;
L4802:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsubop(asu64(R2), asu64(R1));
	p = asu64(R1);
L4801:
L4799:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4798;
	asi64(R1) = opc;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4798;
	asu64(R1) = p;
	goto L4797;
L4797:
	return asu64(R1);
}

static u64 cc_parse_readmulexpr() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	i64 opc;
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L4805;
L4804:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	q = asu64(R1);
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4808;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4809;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L4810;
	goto L4811;
L4808:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createmulop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4807;
L4809:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createdivop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4807;
L4810:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createremop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4807;
L4811:
L4807:
L4805:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4804;
	asi64(R1) = opc;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4804;
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L4804;
	asu64(R1) = p;
	goto L4803;
L4803:
	return asu64(R1);
}

static u64 cc_parse_readterm() {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	i64 t;
	i64 u;
	i64 opc;
	i64 shift;
	i64 newlen;
	i64 slength;
	i64 tbase;
	i64 fwide;
	i64 newmode;
	i64 tag;
	u64 pbyte;
	i64 a;
	u64 d;
	u64 ss;
	u64 s;
	u64 pm;
	i64 av_1;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 13: goto L4862;
	case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 26: case 27: case 28: case 30: case 31: case 33: case 34: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 62: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 92: goto L4815;
	case 23: goto L4849;
	case 24: goto L4850;
	case 25: goto L4859;
	case 29: goto L4855;
	case 32: goto L4858;
	case 35: goto L4854;
	case 36: goto L4851;
	case 37: case 38: goto L4860;
	case 39: goto L4861;
	case 59: case 60: goto L4816;
	case 61: goto L4841;
	case 63: case 64: goto L4835;
	case 67: goto L4817;
	case 91: goto L4867;
	case 93: goto L4878;
	case 94: goto L4879;
	case 95: goto L4880;
	default: goto L4815;
    };
// SWITCH
L4816:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L4813;
L4817:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L4819;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L4821;
	asu64(R4) = cc_decls_currproc;
	goto L4820;
L4821:
	asu64(R4) = cc_decls_stmodule;
L4820:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4823;
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	R2 = tou64("Undefined name \"#\"");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4823:
	goto L4818;
L4819:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4818:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4825;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4826;
	goto L4827;
L4825:
	R1 = 3;
	asu64(R2) = d;
	R3 = 88;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = tou64(toi32(R2));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L4824;
L4826:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4829;
	R1 = 5;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4828;
L4829:
	goto L4830;
L4828:
	goto L4824;
L4827:
// cc_parse.readterm.doname:
L4830:
	asu64(R1) = d;
	asu64(R1) = cc_lib_createname(asu64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = R1;
	t = asi64(R2);
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4832;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R1) = cc_parse_createaddrofop(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4831;
L4832:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4833;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L4833;
	asu64(R1) = p;
	cc_parse_fixmemopnd(asu64(R1));
	goto L4831;
L4833:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4834;
L4834:
L4831:
L4824:
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	cc_lex_lex();
	goto L4813;
L4835:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	fwide = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	slength = asi64(R1);
	goto L4837;
L4836:
	asi64(R1) = slength;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	ss = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R3) = ss;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = ss;
	asi64(R4) = slength;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ss;
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ss;
	s = asu64(R1);
	asi64(R1) = newlen;
	slength = asi64(R1);
	cc_lex_lex();
L4837:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L4836;
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L4840;
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R1) = cc_lib_createwstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefwchar;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4839;
L4840:
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R1) = cc_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4839:
	cc_lex_lex();
	goto L4813;
L4841:
	R1 = 0;
	a = asi64(R1);
	R1 = 0;
	shift = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pbyte = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L4843;
	R1 = tou64("char const too long");
	cc_support_serror(asu64(R1));
L4843:
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4846;
L4844:
	asi64(R1) = a;
	asu64(R2) = pbyte;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	a = asi64(R1);
	R1 = 8;
	R2 = (u64)&shift;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&pbyte;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L4844;
L4846:
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L4848;
	R1 = 3;
	goto L4847;
L4848:
	R1 = 4;
L4847:
	asi64(R2) = a;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L4813;
L4849:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L4813;
L4850:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createnegop(asu64(R1));
	p = asu64(R1);
	goto L4813;
L4851:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	asu64(R1) = p;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = p;
	R2 = 26;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L4853;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L4853;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4853:
	goto L4813;
L4854:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createinotop(asu64(R1));
	p = asu64(R1);
	goto L4813;
L4855:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L4857;
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L4856;
L4857:
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createaddrofop(asu64(R1));
	p = asu64(R1);
L4856:
	goto L4813;
L4858:
	R1 = tou64("rt/&&label");
	cc_support_serror(asu64(R1));
	goto L4813;
L4859:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	p = asu64(R1);
	goto L4813;
L4860:
	R1 = (u64)&cc_tables_symboltojtag;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asi64(R2) = opc;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4813;
L4861:
	cc_lex_lex();
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readexpression();
	asu64(R1) = cc_parse_createabsop(asu64(R1));
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	goto L4813;
L4862:
	cc_lex_lex();
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L4864;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4866;
	R1 = tou64("rt/compound lit");
	cc_support_serror(asu64(R1));
	goto L4865;
L4866:
	R1 = 0;
	R2 = 1;
	asi64(R3) = t;
	asu64(R4) = cc_parse_readterm();
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
L4865:
	goto L4863;
L4864:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
L4863:
	goto L4813;
L4867:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4869;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4871;
	cc_lex_lex();
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L4873;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 9;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L4872;
L4873:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L4872:
	goto L4870;
L4871:
	R1 = 1;
	asu64(R2) = cc_parse_readterm();
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L4870:
	goto L4868;
L4869:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4875;
	asi64(R1) = cc_parse_istypestarter_next();
	if (!asi64(R1)) goto L4877;
	cc_lex_lex();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 9;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = t;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L4876;
L4877:
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L4876:
	goto L4874;
L4875:
	R1 = 0;
	asu64(R2) = cc_parse_readterm();
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L4874:
L4868:
	goto L4813;
L4878:
	asu64(R1) = cc_parse_readgeneric();
	p = asu64(R1);
	goto L4813;
L4879:
	R1 = tou64("rt/alignof");
	cc_support_serror(asu64(R1));
	goto L4813;
L4880:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	tag = asi64(R1);
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = tag;
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L4882;
	R1 = 8;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	q = asu64(R1);
	goto L4881;
L4882:
	R1 = 0;
	q = asu64(R1);
L4881:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = tag;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	goto L4813;
L4815:
	R1 = tou64("RT");
	cc_lex_ps(asu64(R1));
	R1 = tou64("Readterm?");
	cc_support_serror(asu64(R1));
L4813:
L4883:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: case 3: goto L4888;
	case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 14: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: goto L4886;
	case 13: goto L4889;
	case 15: goto L4887;
	case 37: goto L4892;
	case 38: goto L4893;
	default: goto L4886;
    };
// SWITCH
L4887:
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	q = asu64(R1);
	R1 = 16;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createindexop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4883;
L4888:
	R1 = (u64)&cc_tables_symboltojtag;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lex();
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	asu64(R1) = d;
	asu64(R2) = p;
	asi64(R3) = opc;
	asu64(R1) = cc_parse_createdotop(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4883;
L4889:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L4891;
	R1 = 0;
	q = asu64(R1);
	cc_lex_lex();
	goto L4890;
L4891:
	R1 = 0;
	asu64(R1) = cc_parse_readexprlist(asu64(R1));
	q = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
L4890:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createcall(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4883;
L4892:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 73;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4883;
L4893:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 74;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4883;
L4886:
	goto L4884;
	goto L4883;
L4884:
	asu64(R1) = p;
	goto L4812;
L4812:
	return asu64(R1);
}

static u64 cc_parse_readexprlist(u64 p) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L4895:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4898;
	goto L4896;
L4898:
	cc_lex_lex();
	goto L4895;
L4896:
	asu64(R1) = ulist;
	goto L4894;
L4894:
	return asu64(R1);
}

static u64 cc_parse_readmodulevar(u64 d, i64 m, i64 linkage) {
    u64 R1, R2, R3, R4; 
	u64 e;
	i64 scope;
	i64 emode;
	R1 = 0;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = cc_decls_stmodule;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L4901;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4903;
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = e;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("var: name in use # #");
	cc_support_serror_ss(asu64(R3), asu64(R2), asu64(R1));
L4903:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	emode = asi64(R1);
	asi64(R1) = emode;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L4905;
	asi64(R1) = m;
	asi64(R2) = emode;
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L4907;
// cc_parse.readmodulevar.redef:
L4908:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("var: redefining #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4907:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = emode;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L4910;
	goto L4911;
L4910:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = emode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4913;
	asi64(R1) = m;
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L4912;
L4913:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L4914;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = emode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) == asi64(R2)) goto L4914;
	goto L4908;
L4914:
L4912:
	goto L4909;
L4911:
L4909:
L4905:
	asu64(R1) = e;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4918;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4917;
L4918:
	asi64(R1) = scope;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4919;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4917;
L4919:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4916;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4916;
L4917:
	goto L4915;
L4916:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4920;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4920;
	R1 = 4;
	scope = asi64(R1);
L4920:
L4915:
	goto L4900;
L4901:
	R1 = 7;
	asu64(R2) = d;
	asu64(R3) = cc_decls_stmodule;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4922;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4923;
	goto L4924;
L4922:
	R1 = 2;
	scope = asi64(R1);
	goto L4921;
L4923:
	R1 = 3;
	scope = asi64(R1);
	goto L4921;
L4924:
	R1 = 4;
	scope = asi64(R1);
L4921:
L4900:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4926;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4928;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4928:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4930;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init extern #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4930:
	cc_lex_lex();
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = cc_decls_stmodule;
	asu64(R1) = cc_parse_readinitexpr(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4926:
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	goto L4899;
L4899:
	return asu64(R1);
}

static u64 cc_parse_readframevar(u64 d, i64 m, i64 linkage) {
    u64 R1, R2, R3, R4; 
	u64 pm;
	u64 e;
	i64 scope;
	i64 id;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_checkdupl_inproc(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L4933;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("var: name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
	asu64(R1) = e;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4937;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4936;
L4937:
	asi64(R1) = scope;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4938;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4936;
L4938:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4935;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4935;
L4936:
	goto L4934;
L4935:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4939;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4939;
	R1 = 4;
	scope = asi64(R1);
L4939:
L4934:
	goto L4932;
L4933:
	R1 = 8;
	id = asi64(R1);
	R1 = 1;
	scope = asi64(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4941;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4942;
	goto L4943;
L4941:
	R1 = 7;
	id = asi64(R1);
	goto L4940;
L4942:
	R1 = 3;
	scope = asi64(R1);
	R1 = 7;
	id = asi64(R1);
	goto L4940;
L4943:
L4940:
	asi64(R1) = id;
	asu64(R2) = d;
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L4932:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4945;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4947;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4947:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4949;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init extern #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4949:
	cc_lex_lex();
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = cc_decls_currproc;
	asu64(R1) = cc_parse_readinitexpr(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4945:
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	goto L4931;
L4931:
	return asu64(R1);
}

static i64 cc_parse_readtype(u64 owner, u64 d, i64 m, u64 pm) {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 modtype;
	struct $B16 modvalue;
	u64 pmx;
	i64 nmodifiers;
	i64 i;
	R1 = 0;
	nmodifiers = asi64(R1);
	R1 = 0;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&nmodifiers;
	R2 = (u64)&modvalue;
	R3 = (u64)&modtype;
	asu64(R4) = d;
	asu64(R5) = owner;
	cc_parse_readnamedtype(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = nmodifiers;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4953;
L4951:
	R1 = (u64)&modtype;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L4955;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L4956;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4957;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4958;
	goto L4959;
L4955:
	R1 = (u64)&modvalue;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = m;
	asi64(R1) = cc_lib_createarraymode(asi64(R2), asi64(R1));
	m = asi64(R1);
	goto L4954;
L4956:
	asi64(R1) = m;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L4954;
L4957:
	asi64(R1) = m;
	asi64(R1) = cc_lib_createconstmode(asi64(R1));
	m = asi64(R1);
	goto L4954;
L4958:
	R1 = (u64)&modvalue;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pmx = asu64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4961;
	asu64(R1) = pmx;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	goto L4960;
L4961:
	asu64(R1) = pmx;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	m = asi64(R1);
L4960:
	goto L4954;
L4959:
L4954:
	i += -1; if (i >= 1) goto L4951;
L4953:
	asi64(R1) = m;
	goto L4950;
L4950:
	return asi64(R1);
}

static void cc_parse_readnamedtype(u64 owner, u64 d, u64 modtype, u64 modvalue, u64 nmodifiers) {
    u64 R1, R2, R3, R4, R5; 
	i64 length;
	struct $B16 fconst;
	i64 nrefs;
	u64 pdim;
	R1 = 0;
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	nrefs = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) != asi64(R2)) goto L4964;
	cc_lex_lex();
L4964:
	goto L4966;
L4965:
	R1 = (u64)&nrefs;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&fconst;
	asi64(R3) = nrefs;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	cc_lex_lex();
	goto L4969;
L4968:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4972;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4973;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4973;
	goto L4974;
L4972:
	R1 = 1;
	R2 = (u64)&fconst;
	asi64(R3) = nrefs;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L4971;
L4973:
	goto L4971;
L4974:
	R1 = tou64("rnt1");
	cc_support_serror(asu64(R1));
L4971:
	cc_lex_lex();
L4969:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4968;
L4966:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4965;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4976;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4977;
	goto L4978;
L4976:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	cc_lex_lex();
	goto L4975;
L4977:
	cc_lex_lex();
	asu64(R1) = nmodifiers;
	asu64(R2) = modvalue;
	asu64(R3) = modtype;
	asu64(R4) = d;
	asu64(R5) = owner;
	cc_parse_readnamedtype(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	goto L4975;
L4978:
L4975:
L4979:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4981;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4982;
	goto L4983;
L4981:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L4985;
	R1 = 0;
	length = asi64(R1);
	goto L4984;
L4985:
	asu64(R1) = cc_parse_readassignexpr();
	pdim = asu64(R1);
	asu64(R1) = pdim;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4987;
	asu64(R1) = pdim;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	goto L4986;
L4987:
	R1 = tou64("Can't do VLAs");
	cc_support_serror(asu64(R1));
L4986:
	R1 = 16;
	cc_lib_checksymbol(asi64(R1));
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4989;
	R1 = tou64("ZERO LEN ARRAY");
	cc_support_serror(asu64(R1));
L4989:
L4984:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L4991;
	R1 = tou64("Negative array dim");
	cc_support_terror(asu64(R1));
L4991:
	cc_lex_lex();
	R1 = 65;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = modvalue;
	asu64(R3) = nmodifiers;
	asi64(R3) = *toi64p(R3);
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4979;
L4982:
	cc_lex_lex();
	R1 = 70;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = owner;
	asu64(R1) = cc_parse_readparams(asu64(R1));
	asu64(R2) = modvalue;
	asu64(R3) = nmodifiers;
	asi64(R3) = *toi64p(R3);
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4979;
L4983:
	goto L4980;
	goto L4979;
L4980:
	goto L4993;
L4992:
	R1 = (u64)&fconst;
	asi64(R2) = nrefs;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L4996;
	R1 = 67;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L4996:
	R1 = 82;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&nrefs;
	(*toi64p(R1)) -=1;
L4993:
	asi64(R1) = nrefs;
	if (asi64(R1)) goto L4992;
	return;
}

static i64 cc_parse_readconstintexpr() {
    u64 R1, R2, R3; 
	u64 p;
	i64 val;
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4999;
	goto L5000;
L4999:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L4997;
	goto L4998;
L5000:
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("readconstint #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4998:
	R1 = 0;
	goto L4997;
L4997:
	return asi64(R1);
}

static u64 cc_parse_readinitexpr(u64 owner, i64 m) {
    u64 R1, R2, R3; 
	i64 count;
	u64 p;
	R1 = 1;
	asi64(R2) = m;
	asu64(R3) = owner;
	asu64(R1) = cc_parse_readinitexpr2(asu64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L5001;
L5001:
	return asu64(R1);
}

static u64 cc_parse_readinitexpr2(u64 owner, i64 m, i64 istop) {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 mbase;
	i64 melem;
	i64 mm;
	i64 dim;
	i64 count;
	u64 d;
	u64 e;
	i64 braces;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5004;
	cc_lex_lex();
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5006;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5007;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5007;
	goto L5008;
L5006:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	dim = asi64(R1);
	asi64(R1) = istop;
	if (asi64(R1)) goto L5010;
	asi64(R1) = dim;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5010;
	R1 = tou64("init/0-size array");
	cc_support_terror(asu64(R1));
L5010:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	melem = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = melem;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5012;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L5012;
	R1 = 1;
	braces = asi64(R1);
	goto L5013;
L5012:
	goto L5005;
L5007:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5015;
	R1 = tou64("init/Empty struct");
	cc_support_terror(asu64(R1));
L5015:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	melem = asi64(R1);
	goto L5005;
L5008:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L5002;
L5005:
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L5016:
	R1 = 0;
	asi64(R2) = melem;
	asu64(R3) = owner;
	asu64(R1) = cc_parse_readinitexpr2(asu64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5019;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5020;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5021;
	goto L5022;
L5019:
	asi64(R1) = dim;
	if (!asi64(R1)) goto L5024;
	asi64(R1) = count;
	asi64(R2) = dim;
	if (asi64(R1) <= asi64(R2)) goto L5024;
	R1 = tou64("Too many array elems");
	cc_support_terror(asu64(R1));
L5024:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = melem;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5026;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = melem;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5026;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L5026;
	goto L5025;
L5026:
	asi64(R1) = melem;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L5025:
	goto L5018;
L5020:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	mm = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mm;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5028;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = mm;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5028;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L5028;
	goto L5027;
L5028:
	asi64(R1) = mm;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L5027:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5030;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5032;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5032;
	R1 = tou64("Too many struct elems");
	cc_support_terror(asu64(R1));
L5032:
	goto L5029;
L5030:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	melem = asi64(R1);
L5029:
	goto L5018;
L5021:
	asi64(R1) = melem;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	goto L5033;
	goto L5018;
L5022:
L5018:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5035;
	goto L5017;
L5035:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L5037;
	cc_lex_lex();
	goto L5017;
L5037:
	cc_lex_lex();
	goto L5016;
L5017:
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5039;
	asi64(R1) = dim;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5039;
	asi64(R1) = count;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = count;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = melem;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L5039:
// cc_parse.readinitexpr2.donestruct:
L5033:
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = ulist;
	R2 = 28;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = count;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5003;
L5004:
	R1 = 0;
	braces = asi64(R1);
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5041;
	goto L5042;
L5041:
// cc_parse.readinitexpr2.doarraystring:
L5013:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L5044;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L5044;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5044;
	R1 = tou64("{} initialiser expected");
	cc_support_terror(asu64(R1));
L5044:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) == asi64(R2)) goto L5046;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) == asi64(R2)) goto L5047;
	goto L5048;
L5046:
	goto L5045;
L5047:
	goto L5045;
L5048:
	R1 = tou64("Array init");
	cc_support_terror(asu64(R1));
L5045:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	dim = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5050;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	R3 = (u64)&cc_decls_ttsize;
	asi64(R4) = m;
	*toi64p(((i64)R3+(i64)R4*8)) = asi64(R2);
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L5049;
L5050:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = dim;
	if (asi64(R1) <= asi64(R2)) goto L5052;
	R1 = tou64("Init str too long");
	cc_support_terror(asu64(R1));
L5052:
L5049:
	asi64(R1) = braces;
	if (!asi64(R1)) goto L5054;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
L5054:
	asu64(R1) = p;
	goto L5002;
	goto L5040;
L5042:
L5040:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L5003:
	asu64(R1) = p;
	goto L5002;
L5002:
	return asu64(R1);
}

static void cc_parse_pushblock() {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 m;
	asi64(R1) = cc_decls_blocklevel;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5057;
	R1 = tou64("Too many block levels");
	cc_support_serror(asu64(R1));
L5057:
	asi64(R1) = cc_decls_nextblockno;
	R2 = 2100;
	if (asi64(R1) < asi64(R2)) goto L5059;
	R1 = tou64("Too many blocks");
	cc_support_serror(asu64(R1));
L5059:
	R1 = (u64)&cc_decls_blocklevel;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_nextblockno;
	(*toi64p(R1)) += 1;
	asi64(R1) = cc_decls_currblockno;
	n = asi64(R1);
	asi64(R1) = cc_decls_blocklevel;
	m = asi64(R1);
	goto L5061;
L5060:
	R1 = (u64)&m;
	(*toi64p(R1)) -=1;
	R1 = (u64)&cc_decls_blockstack;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
L5061:
	asi64(R1) = m;
	if (!asi64(R1)) goto L5063;
	R1 = (u64)&cc_decls_blockcounts;
	R2 = (u64)&cc_decls_blockstack;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5060;
L5063:
	asi64(R1) = n;
	R2 = (u64)&cc_decls_blockowner;
	asi64(R3) = cc_decls_nextblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cc_decls_nextblockno;
	R2 = R1;
	R3 = (u64)&cc_decls_blockstack;
	asi64(R4) = cc_decls_blocklevel;
	*toi32p(((i64)R3+(i64)R4*4)) = asi32(R2);
	cc_decls_currblockno = asi64(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	return;
}

static void cc_parse_popblock() {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_blockstack;
	R2 = (u64)&cc_decls_blocklevel;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	cc_decls_currblockno = asi64(R1);
	return;
}

static u64 cc_parse_readcompoundstmt(i64 params) {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	cc_lex_lex();
	cc_parse_pushblock();
	asi64(R1) = params;
	if (!asi64(R1)) goto L5067;
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	R3 = 1;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L5067:
	goto L5069;
L5068:
	asu64(R1) = cc_parse_readstatement();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5072;
	goto L5069;
L5072:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5074;
L5075:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5079;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5079;
	R1 = 8;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L5079:
	asu64(R1) = q;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5075;
	goto L5073;
L5074:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L5073:
L5069:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L5068;
	cc_lex_lex();
	cc_parse_popblock();
	asu64(R1) = ulistx;
	R2 = 0;
	asu64(R3) = ulist;
	R4 = 6;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L5065;
L5065:
	return asu64(R1);
}

static u64 cc_parse_readblock(i64 ifelse) {
    u64 R1, R2; 
	asu64(R1) = cc_parse_readstatement();
	goto L5080;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 71;
	if (asi64(R1) != asi64(R2)) goto L5082;
	asi64(R1) = ifelse;
	if (!asi64(R1)) goto L5082;
	asu64(R1) = cc_parse_readstatement();
	goto L5080;
L5082:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5084;
	R1 = tou64("{...} statement expected");
	cc_support_serror(asu64(R1));
L5084:
	R1 = 0;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	goto L5080;
L5080:
	return asu64(R1);
}

static u64 cc_parse_readstatement() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 ss;
	u64 d;
	i64 index;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 9: goto L5111;
	case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 72: case 89: goto L5088;
	case 17: goto L5095;
	case 67: goto L5112;
	case 70: case 83: case 84: case 85: case 86: case 87: case 88: case 90: goto L5128;
	case 71: goto L5089;
	case 73: goto L5109;
	case 74: goto L5110;
	case 75: goto L5090;
	case 76: goto L5091;
	case 77: goto L5092;
	case 78: goto L5093;
	case 79: goto L5097;
	case 80: goto L5102;
	case 81: goto L5096;
	case 82: goto L5094;
	default: goto L5088;
    };
// SWITCH
L5089:
	asu64(R1) = cc_parse_readifstmt();
	goto L5085;
	goto L5086;
L5090:
	asu64(R1) = cc_parse_readforstmt();
	goto L5085;
	goto L5086;
L5091:
	asu64(R1) = cc_parse_readwhilestmt();
	goto L5085;
	goto L5086;
L5092:
	asu64(R1) = cc_parse_readdostmt();
	goto L5085;
	goto L5086;
L5093:
	asu64(R1) = cc_parse_readreturnstmt();
	goto L5085;
	goto L5086;
L5094:
	asu64(R1) = cc_parse_readswitchstmt();
	goto L5085;
	goto L5086;
L5095:
	R1 = 0;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	goto L5085;
	goto L5086;
L5096:
	asu64(R1) = cc_parse_readgotostmt();
	goto L5085;
	goto L5086;
L5097:
	asi64(R1) = cc_parse_loopindex;
	if (!asi64(R1)) goto L5099;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = cc_parse_loopindex;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L5101;
	R1 = 20;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L5100;
L5101:
	R1 = 23;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
L5100:
	goto L5098;
L5099:
	R1 = tou64("break outside loop/sw");
	cc_support_serror(asu64(R1));
L5098:
	goto L5086;
L5102:
	asi64(R1) = cc_parse_loopindex;
	index = asi64(R1);
	goto L5104;
L5103:
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
L5104:
	asi64(R1) = index;
	if (!asi64(R1)) goto L5106;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L5103;
L5106:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5108;
	R1 = tou64("continue outside loop");
	cc_support_serror(asu64(R1));
L5108:
	R1 = 21;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L5086;
L5109:
	asu64(R1) = cc_parse_readcaselabel();
	goto L5085;
	goto L5086;
L5110:
	cc_lex_lex();
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readstatement();
	R2 = 19;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	goto L5085;
	goto L5086;
L5111:
	cc_lex_lex();
	R1 = 0;
	goto L5085;
	goto L5086;
L5112:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5114;
	R1 = 0;
	R2 = 17;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 3;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5116;
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5118;
	msysc_m$print_startcon();
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("2:Duplicate label");
	cc_support_terror(asu64(R1));
L5118:
	goto L5115;
L5116:
	R1 = 14;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L5115:
	R1 = -1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_lex_lex();
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L5120;
	goto L5119;
L5120:
	asi64(R1) = cc_parse_istypestarter();
	if (asi64(R1)) goto L5122;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 85;
	if (asi64(R1) != asi64(R2)) goto L5121;
L5122:
	goto L5119;
L5121:
	asu64(R1) = cc_parse_readstatement();
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5119:
	asu64(R1) = p;
	goto L5085;
	goto L5113;
L5114:
	R1 = 0;
	cc_parse_ist_symptr = asu64(R1);
	asu64(R1) = cc_decls_currproc;
	asi64(R1) = cc_parse_isusertype(asu64(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5124;
	goto L5125;
L5124:
	asu64(R1) = cc_parse_ist_symptr;
	if (!asu64(R1)) goto L5127;
	asu64(R1) = cc_parse_ist_symptr;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5127:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
L5113:
	goto L5086;
L5128:
// cc_parse.readstatement.doreaddecl:
L5125:
	asu64(R1) = cc_parse_readlocaldecl();
	goto L5085;
	goto L5086;
L5088:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
L5086:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L5085;
L5085:
	return asu64(R1);
}

static u64 cc_parse_readifstmt() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 pcond;
	u64 pbody;
	u64 pelse;
	i64 lineno;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	lineno = asi64(R1);
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	pelse = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 72;
	if (asi64(R1) != asi64(R2)) goto L5131;
	cc_lex_lex();
	R1 = 1;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pelse = asu64(R1);
L5131:
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	asu64(R3) = pcond;
	R4 = 12;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = lineno;
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L5133;
	asu64(R1) = pbody;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5135;
	R1 = 6;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pbody = asu64(R1);
L5135:
	asu64(R1) = pbody;
	asu64(R2) = p;
	cc_parse_deleteunit(asu64(R2), asu64(R1));
	goto L5132;
L5133:
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L5136;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5138;
	R1 = 6;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pelse = asu64(R1);
L5138:
	asu64(R1) = pelse;
	asu64(R2) = p;
	cc_parse_deleteunit(asu64(R2), asu64(R1));
L5136:
L5132:
	asu64(R1) = p;
	goto L5129;
L5129:
	return asu64(R1);
}

static i64 cc_parse_iscondtrue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5140;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5140;
	R1 = 1;
	goto L5141;
L5140:
	R1 = 0;
L5141:
	goto L5139;
L5139:
	return asi64(R1);
}

static i64 cc_parse_iscondfalse(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5143;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5143;
	R1 = 1;
	goto L5144;
L5143:
	R1 = 0;
L5144:
	goto L5142;
L5142:
	return asi64(R1);
}

static void cc_parse_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B37 R1_B37; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B37) = *(struct $B37*)(R1);
	asu64(R2) = p;
	*(struct $B37*)(R2) = (R1_B37);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_parse_readforstmt() {
    u64 R1, R2, R3, R4; 
	u64 pinit;
	u64 pcond;
	u64 pincr;
	u64 pbody;
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 linkage;
	i64 hasblock;
	i64 m;
	i64 mbase;
	u64 pm;
	u64 d;
	cc_lex_lex();
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 0;
	hasblock = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5148;
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L5150;
	R1 = 1;
	hasblock = asi64(R1);
	cc_parse_pushblock();
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_currproc;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L5151:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5153;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5153;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5153;
	goto L5154;
L5153:
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_currproc;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5156;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L5156:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5159;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L5158;
L5159:
	R1 = tou64("Not allowed in for stmt");
	cc_support_serror(asu64(R1));
L5158:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readframevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5161;
	R1 = 8;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L5161:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5163;
	goto L5164;
L5163:
	cc_lex_lex();
	goto L5162;
L5164:
	goto L5152;
L5162:
	goto L5151;
L5154:
	R1 = tou64("For decl error");
	cc_support_serror(asu64(R1));
	goto L5151;
L5152:
	asu64(R1) = ulistx;
	R2 = 0;
	asu64(R3) = ulist;
	R4 = 6;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	pinit = asu64(R1);
	goto L5149;
L5150:
	asu64(R1) = cc_parse_readexpression();
	pinit = asu64(R1);
L5149:
	goto L5147;
L5148:
	R1 = 2;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pinit = asu64(R1);
L5147:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5166;
	asu64(R1) = cc_parse_readexpression();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	goto L5165;
L5166:
	R1 = 2;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pcond = asu64(R1);
L5165:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5168;
	asu64(R1) = cc_parse_readexprstmt();
	pincr = asu64(R1);
	goto L5167;
L5168:
	R1 = 0;
	pincr = asu64(R1);
L5167:
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	asi64(R1) = hasblock;
	if (!asi64(R1)) goto L5170;
	cc_parse_popblock();
L5170:
	asu64(R1) = pcond;
	asu64(R2) = pinit;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pincr;
	asu64(R2) = pcond;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pinit;
	R3 = 13;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L5146;
L5146:
	return asu64(R1);
}

static u64 cc_parse_readwhilestmt() {
    u64 R1, R2, R3; 
	u64 pcond;
	u64 pbody;
	cc_lex_lex();
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 14;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L5171;
L5171:
	return asu64(R1);
}

static u64 cc_parse_readdostmt() {
    u64 R1, R2, R3; 
	u64 pbody;
	u64 pcond;
	cc_lex_lex();
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	R1 = 76;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 15;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L5172;
L5172:
	return asu64(R1);
}

static u64 cc_parse_readreturnstmt() {
    u64 R1, R2; 
	u64 p;
	cc_lex_lex();
	R1 = 0;
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5175;
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5177;
	R1 = tou64("Can't return value in void function");
	cc_support_terror(asu64(R1));
L5177:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 9;
	cc_lib_checksymbol(asi64(R1));
	goto L5174;
L5175:
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5178;
	R1 = tou64("Return value needed");
	cc_support_terror(asu64(R1));
L5178:
L5174:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 9;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	goto L5173;
L5173:
	return asu64(R1);
}

static u64 cc_parse_readgotostmt() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 p;
	cc_lex_lex();
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 3;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5181;
	R1 = 14;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L5181:
	R1 = 0;
	R2 = 16;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_lex_lex();
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L5179;
L5179:
	return asu64(R1);
}

static u64 cc_parse_readswitchstmt() {
    u64 R1, R2, R3; 
	u64 pindex;
	u64 pstmt;
	u64 p;
	cc_lex_lex();
	asu64(R1) = cc_parse_readcond();
	pindex = asu64(R1);
	R1 = 3;
	asu64(R2) = pindex;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	R1 = 83;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pstmt = asu64(R1);
	asu64(R1) = pstmt;
	asu64(R2) = pindex;
	R3 = 22;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&cc_parse_casevaluestack;
	asi64(R2) = cc_parse_loopindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_parse_poploop();
	asu64(R1) = p;
	goto L5182;
L5182:
	return asu64(R1);
}

static u64 cc_parse_readcaselabel() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 value;
	cc_lex_lex();
	asi64(R1) = cc_parse_readconstintexpr();
	value = asi64(R1);
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readstatement();
	R2 = 18;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = value;
	cc_parse_addcasevalue(asi64(R1));
	asu64(R1) = p;
	goto L5183;
L5183:
	return asu64(R1);
}

static u64 cc_parse_readexprstmt() {
    u64 R1; 
	asu64(R1) = cc_parse_readexpression();
	goto L5184;
L5184:
	return asu64(R1);
}

static u64 cc_parse_readcond() {
    u64 R1; 
	u64 pcond;
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readexpression();
	pcond = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = pcond;
	goto L5185;
L5185:
	return asu64(R1);
}

static i64 cc_parse_isusertype(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5188;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5190;
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5186;
L5190:
	asu64(R1) = d;
	cc_parse_ist_symptr = asu64(R1);
L5188:
	R1 = 20;
	goto L5186;
L5186:
	return asi64(R1);
}

static u64 cc_parse_readlocaldecl() {
    u64 R1, R2, R3, R4, R5; 
	i64 m;
	i64 mbase;
	i64 linkage;
	i64 nitems;
	i64 wasenum;
	i64 wasdef;
	u64 d;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 pm;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	wasenum = asi64(R1);
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_currproc;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	nitems = asi64(R1);
L5192:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5194;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5194;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5194;
	goto L5195;
L5194:
	R1 = (u64)&nitems;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_currproc;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5197;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L5197:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5199;
	asi64(R1) = m;
	asu64(R2) = d;
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_parse_createtypedef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L5198;
L5199:
	asu64(R1) = pm;
	if (!asu64(R1)) goto L5200;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5202;
	R1 = tou64("Nested function");
	cc_support_serror(asu64(R1));
L5202:
	R1 = (u64)&wasdef;
	asu64(R2) = pm;
	asi64(R3) = linkage;
	asi64(R4) = m;
	asu64(R5) = d;
	asu64(R1) = cc_parse_readfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	d = asu64(R1);
	goto L5198;
L5200:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readframevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 7;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L5198:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5204;
	goto L5205;
L5204:
	cc_lex_lex();
	goto L5203;
L5205:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5193;
L5203:
	goto L5192;
L5195:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5207;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5207;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5207;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5208;
	goto L5209;
L5207:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5193;
	goto L5206;
L5208:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5193;
	goto L5206;
L5209:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Local decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5206:
	goto L5192;
L5193:
	asu64(R1) = ulist;
	goto L5191;
L5191:
	return asu64(R1);
}

static u64 cc_parse_createtypedef(u64 owner, u64 symptr, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	asu64(R3) = symptr;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5212;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5214;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Typedef name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5214:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R2) = mode;
	if (asi64(R1) == asi64(R2)) goto L5216;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L5218;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Typedef redefined or can't match types #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5218:
L5216:
	asu64(R1) = d;
	goto L5210;
L5212:
	R1 = 5;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = d;
	R2 = (u64)&cc_decls_tttypedef;
	asi64(R3) = mode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = d;
	goto L5210;
L5210:
	return asu64(R1);
}

static u64 cc_parse_readparams(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	u64 ulist;
	u64 ulistx;
	u64 pm;
	u64 q;
	i64 m;
	i64 lastbasetype;
	i64 nparams;
	i64 variadic;
	i64 flags;
	i64 nnames;
	u64 d;
	i64 names;
	i64 nonames;
	i64 reported;
	R1 = 0;
	d = asu64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	R2 = R1;
	nnames = asi64(R2);
	R2 = R1;
	nparams = asi64(R2);
	variadic = asi64(R1);
	R1 = 0;
	lastbasetype = asi64(R1);
	R1 = 0;
	names = asi64(R1);
	R1 = 0;
	nonames = asi64(R1);
	R1 = 0;
	reported = asi64(R1);
	goto L5221;
L5220:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L5224;
	R1 = 1;
	variadic = asi64(R1);
	cc_lex_lex();
	goto L5222;
L5224:
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L5226;
	R1 = (u64)&lastbasetype;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 1;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = pm;
	if (!asu64(R1)) goto L5228;
	asu64(R1) = pm;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
L5228:
	goto L5225;
L5226:
	asi64(R1) = lastbasetype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5230;
	R1 = tou64("Param type missing or misspelt");
	cc_support_serror(asu64(R1));
L5230:
	R1 = 0;
	asi64(R2) = lastbasetype;
	R3 = (u64)&pm;
	R4 = 1;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
L5225:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5232;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5233;
	goto L5234;
L5232:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L5231;
L5233:
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L5231;
L5234:
L5231:
	R1 = 24;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pm;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	if (!asu64(R1)) goto L5236;
	R1 = 1;
	names = asi64(R1);
	goto L5235;
L5236:
	R1 = 1;
	nonames = asi64(R1);
L5235:
	asi64(R1) = names;
	if (!asi64(R1)) goto L5238;
	asi64(R1) = nonames;
	if (!asi64(R1)) goto L5238;
	asi64(R1) = reported;
	if (asi64(R1)) goto L5238;
	R1 = 1;
	reported = asi64(R1);
L5238:
	asu64(R1) = d;
	if (!asu64(R1)) goto L5240;
	R1 = (u64)&nnames;
	(*toi64p(R1)) += 1;
	asu64(R1) = ulist;
	q = asu64(R1);
	goto L5242;
L5241:
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L5245;
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Param name reused # #");
	cc_support_serror_ss(asu64(R3), asu64(R2), asu64(R1));
L5245:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5242:
	asu64(R1) = q;
	if (asu64(R1)) goto L5241;
L5240:
	asu64(R1) = pm;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5247;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L5248;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5248;
	goto L5249;
L5247:
	cc_lex_lex();
	goto L5246;
L5248:
	goto L5246;
L5249:
	R1 = tou64("bad symbol in paramlist");
	cc_support_serror(asu64(R1));
L5246:
L5221:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5220;
L5222:
	R1 = 0;
	flags = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	asi64(R1) = variadic;
	if (!asi64(R1)) goto L5251;
	R1 = 3;
	flags = asi64(R1);
	goto L5250;
L5251:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5252;
	R1 = 1;
	flags = asi64(R1);
	goto L5250;
L5252:
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5253;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5253;
	R1 = 2;
	flags = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	asu64(R2) = ulist;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5253:
L5250:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5255;
	R1 = 24;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	ulist = asu64(R1);
L5255:
	asi64(R1) = nparams;
	asu64(R2) = ulist;
	R3 = 20;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = flags;
	asu64(R2) = ulist;
	R3 = 22;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = ulist;
	goto L5219;
L5219:
	return asu64(R1);
}

static i64 cc_parse_readcasttype(u64 d, i64 allowname, u64 pm, i64 m, u64 mbase) {
    u64 R1, R2, R3, R4; 
	u64 owner;
	i64 linkage;
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L5258;
	asu64(R1) = cc_decls_currproc;
	goto L5257;
L5258:
	asu64(R1) = cc_decls_stmodule;
L5257:
	owner = asu64(R1);
	R1 = 0;
	linkage = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5260;
	R1 = (u64)&linkage;
	asu64(R2) = owner;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = mbase;
	if (!asu64(R1)) goto L5262;
	asi64(R1) = m;
	asu64(R2) = mbase;
	*toi64p(R2) = asi64(R1);
L5262:
L5260:
	R1 = 0;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5264;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5264;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5264;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5264;
	goto L5265;
L5264:
	asu64(R1) = pm;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R4) = owner;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	asu64(R1) = *tou64p(R1);
	if (!asu64(R1)) goto L5267;
	asi64(R1) = allowname;
	if (asi64(R1)) goto L5267;
	asu64(R1) = d;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("NAME not allowed in cast type #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5267:
	goto L5263;
L5265:
L5263:
	asi64(R1) = m;
	goto L5256;
L5256:
	return asi64(R1);
}

static u64 cc_parse_readfunction(u64 d, i64 m, i64 linkage, u64 pm, u64 wasdef) {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 owner;
	i64 scope;
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	R1 = 0;
	asu64(R2) = wasdef;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L5270;
	asu64(R1) = f;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5272;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("fn: name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5272:
	asu64(R1) = f;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5274;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5274;
	R1 = 4;
	scope = asi64(R1);
	goto L5273;
L5274:
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5275;
	R1 = 2;
	scope = asi64(R1);
L5275:
L5273:
	goto L5269;
L5270:
	R1 = 6;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5277;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5278;
	goto L5279;
L5277:
	R1 = 2;
	scope = asi64(R1);
	goto L5276;
L5278:
	R1 = 3;
	scope = asi64(R1);
	goto L5276;
L5279:
	R1 = 4;
	scope = asi64(R1);
L5276:
L5269:
	asu64(R1) = pm;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5281;
	R1 = 1;
	asu64(R2) = wasdef;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5283;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't define function twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5283:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5285;
	R1 = 4;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5285:
	asu64(R1) = d;
	cc_parse_readfunctionbody(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L5287;
	R1 = tou64("; after function def");
	cc_support_serror(asu64(R1));
L5287:
L5281:
	asu64(R1) = d;
	goto L5268;
L5268:
	return asu64(R1);
}

static void cc_parse_readfunctionbody(u64 f) {
    u64 R1, R2, R3; 
	u64 e;
	u64 p;
	u64 pm;
	i64 pmcount;
	i64 av_1;
	asu64(R1) = f;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	R2 = R1;
	cc_decls_currblockno = asi64(R2);
	cc_decls_nextblockno = asi64(R1);
	R1 = 0;
	pmcount = asi64(R1);
	asu64(R1) = f;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5291;
L5289:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5293;
	goto L5292;
L5293:
	R1 = 9;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = f;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) != asu64(R2)) goto L5295;
	R1 = 1;
	asu64(R2) = e;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5295:
	R1 = 1;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = pm;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L5292:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 1;
	pmcount = asi64(R1);
	if (--asi64(av_1)) goto L5289;
L5291:
	asi64(R1) = pmcount;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = cc_decls_currproc;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	cc_decls_currproc = asu64(R1);
	return;
}

static u64 cc_parse_createnegop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5298;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5300;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5300;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5300;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5301;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5302;
	goto L5303;
L5300:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L5296;
	goto L5299;
L5301:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	R2 = 4294967295;
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L5296;
	goto L5299;
L5302:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R1) = -asr64(R1);
	asu64(R2) = p;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = p;
	goto L5296;
	goto L5299;
L5303:
L5299:
L5298:
// cc_parse.createnegop.retry:
L5304:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5306;
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L5306;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 58;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L5305;
L5306:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5307;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L5304;
	goto L5305;
L5307:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("neg bad type");
	cc_support_terror(asu64(R1));
L5305:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L5296;
L5296:
	return asu64(R1);
}

static u64 cc_parse_createabsop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5310;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5312;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5312;
	goto L5313;
L5312:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L5308;
	goto L5311;
L5313:
L5311:
L5310:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5315;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 59;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L5314;
L5315:
	R1 = tou64("abs bad type");
	cc_support_terror(asu64(R1));
L5314:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L5308;
L5308:
	return asu64(R1);
}

static u64 cc_parse_createinotop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5318;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5320;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5320;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5320;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5320;
	goto L5321;
L5320:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = ~asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L5316;
	goto L5319;
L5321:
L5319:
L5318:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5323;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 60;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L5322;
L5323:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("! bad type");
	cc_support_terror(asu64(R1));
L5322:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L5316;
L5316:
	return asu64(R1);
}

static u64 cc_parse_createptrop(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 t;
	i64 m;
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5326;
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("* not pointer");
	cc_support_terror(asu64(R1));
L5326:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5328;
	goto L5329;
L5328:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = q;
	goto L5324;
	goto L5327;
L5329:
L5327:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R1) = cc_parse_arraytopointer(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = q;
	goto L5324;
L5324:
	return asu64(R1);
}

static u64 cc_parse_createincrop(i64 opc, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5333;
	asi64(R1) = t;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5332;
L5333:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5332;
	R1 = tou64("++ bad type");
	cc_support_terror(asu64(R1));
L5332:
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L5330;
L5330:
	return asu64(R1);
}

static u64 cc_parse_createaddrofop(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 q;
	i64 t;
	i64 u;
	i64 alength;
	R1 = 0;
	alength = asi64(R1);
// cc_parse.createaddrofop.restartx:
L5335:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5337;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
L5337:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5339;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5340;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5341;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5342;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5343;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5344;
	goto L5345;
L5339:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 108;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5347;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	alength = asi64(R1);
L5347:
	goto L5338;
L5340:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5349;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5349;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5334;
L5349:
	goto L5338;
L5341:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L5351;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5351;
	R1 = 3;
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R2) += asu64(R3);
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L5334;
L5351:
	goto L5352;
	goto L5338;
L5342:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5354;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&cc_decls_tttarget;
	asu64(R3) = p;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = cc_lib_createarraymode(asi64(R2), asi64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5334;
L5354:
	goto L5338;
L5343:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L5335;
	goto L5338;
L5344:
	asu64(R1) = p;
	goto L5334;
	goto L5338;
L5345:
// cc_parse.createaddrofop.cad1:
L5352:
	R1 = 0;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
L5338:
	asu64(R1) = p;
	R2 = 55;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = alength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5334;
L5334:
	return asu64(R1);
}

static u64 cc_parse_createaddop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	i64 elemsize;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 39;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5357;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5356;
L5357:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5358;
// cc_parse.createaddop.doaddref:
L5359:
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = u;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5361;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5361;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L5355;
L5361:
	R1 = 4;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 53;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemsize;
	asu64(R2) = z;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5355;
	goto L5356;
L5358:
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5362;
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	goto L5359;
	R1 = tou64("Sub bad types");
	cc_support_terror(asu64(R1));
L5362:
L5356:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5364;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5366;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_add(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5355;
	goto L5365;
L5366:
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L5365:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5368;
	asu64(R1) = x;
	goto L5355;
L5368:
L5364:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5355;
L5355:
	return asu64(R1);
}

static u64 cc_parse_createsubop(u64 x, u64 y) {
    u64 R1, R2, R3, R4, R5; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	i64 elemsize;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 40;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5371;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5370;
L5371:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5372;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5374;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = u;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	R1 = 4;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 54;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemsize;
	asu64(R2) = z;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5369;
	goto L5373;
L5374:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5376;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5376;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asu64(R4) = x;
	R5 = 52;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) -= asi64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = x;
	goto L5369;
	goto L5375;
L5376:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	R1 = 4;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = z;
	asu64(R1) = cc_parse_divunit(asu64(R2), asi64(R1));
	z = asu64(R1);
	R1 = 4;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5369;
L5375:
L5373:
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = y;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5370;
L5372:
	R1 = tou64("Sub bad types");
	cc_support_terror(asu64(R1));
L5370:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5378;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5378;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_sub(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5369;
L5378:
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5380;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5380;
L5380:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5369;
L5369:
	return asu64(R1);
}

static u64 cc_parse_createmulop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 41;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5383;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5382;
L5383:
	R1 = tou64("Mul bad types");
	cc_support_terror(asu64(R1));
L5382:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5385;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5387;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_mul(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5381;
	goto L5386;
L5387:
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L5386:
L5385:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5381;
L5381:
	return asu64(R1);
}

static u64 cc_parse_createdivop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 42;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5390;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5389;
L5390:
	R1 = tou64("Div bad types");
	cc_support_terror(asu64(R1));
L5389:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5392;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5392;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_div(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5388;
	goto L5391;
L5392:
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5393;
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5393;
	R1 = 41;
	opc = asi64(R1);
	asr64(R1) = 1.000000000000000000e+000;
	asu64(R2) = y;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) /= asr64(R2);
	asu64(R2) = y;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
L5393:
L5391:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5388;
L5388:
	return asu64(R1);
}

static u64 cc_parse_createremop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 43;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5396;
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5399;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5398;
L5399:
	R1 = 3;
	u = asi64(R1);
L5398:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5395;
L5396:
	R1 = tou64("Rem bad types");
	cc_support_terror(asu64(R1));
L5395:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5401;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5401;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_rem(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5394;
L5401:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5394;
L5394:
	return asu64(R1);
}

static void cc_parse_insertunit(u64 p, i64 tag) {
    u64 R1, R2, R3, R4; struct $B37 R1_B37; 
	u64 q;
	R1 = 0;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B37) = *(struct $B37*)(R1);
	asu64(R2) = q;
	*(struct $B37*)(R2) = (R1_B37);
	asi64(R1) = tag;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 56;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_parse_eval_add(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5405;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5405;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5405;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5405;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5406;
	goto L5407;
L5405:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L5403;
	goto L5404;
L5406:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) += asr64(R1);
	asu64(R1) = x;
	goto L5403;
	goto L5404;
L5407:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5409;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L5403;
L5409:
L5404:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5403;
L5403:
	return asu64(R1);
}

static u64 cc_parse_eval_sub(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5412;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5412;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5412;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5412;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5413;
	goto L5414;
L5412:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = x;
	goto L5410;
	goto L5411;
L5413:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) -= asr64(R1);
	asu64(R1) = x;
	goto L5410;
	goto L5411;
L5414:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5416;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5418;
	R1 = tou64("EVALSUB/REF");
	cc_support_terror(asu64(R1));
L5418:
	asu64(R1) = x;
	goto L5410;
L5416:
L5411:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5410;
L5410:
	return asu64(R1);
}

static u64 cc_parse_eval_mul(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5421;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5421;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5421;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5421;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5422;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5422;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5422;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5422;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5423;
	goto L5424;
L5421:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) *= asi64(R1);
	asu64(R1) = x;
	goto L5419;
	goto L5420;
L5422:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) *= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = x;
	goto L5419;
	goto L5420;
L5423:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) *= asr64(R1);
	asu64(R1) = x;
	goto L5419;
	goto L5420;
L5424:
L5420:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5419;
L5419:
	return asu64(R1);
}

static u64 cc_parse_eval_div(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5427;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5427;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5428;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5428;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5429;
	goto L5430;
L5427:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5432;
	R1 = tou64("div 0");
	cc_support_serror(asu64(R1));
L5432:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	goto L5425;
	goto L5426;
L5428:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5434;
	R1 = tou64("div 0");
	cc_support_serror(asu64(R1));
L5434:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = x;
	goto L5425;
	goto L5426;
L5429:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) /= asr64(R1);
	asu64(R1) = x;
	goto L5425;
	goto L5426;
L5430:
L5426:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5425;
L5425:
	return asu64(R1);
}

static u64 cc_parse_eval_rem(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5437;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5437;
	goto L5438;
L5437:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5440;
	R1 = tou64("rem 0");
	cc_support_serror(asu64(R1));
L5440:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) %= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	goto L5435;
	goto L5436;
L5438:
L5436:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5435;
L5435:
	return asu64(R1);
}

static i64 cc_parse_eval_convert(u64 p, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	i64 s;
	asi64(R1) = opc;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5443;
// cc_parse.eval_convert.dosoft:
L5444:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
L5443:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5446;
	R1 = 1;
	goto L5441;
L5446:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5448;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5448;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5448;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5448;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5449;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5449;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5449;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5449;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5450;
	goto L5451;
L5448:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5453;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5453;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5454;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5454;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5454;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5454;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5454;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5454;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5454;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5454;
	goto L5455;
L5453:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = p;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
	goto L5452;
L5454:
// cc_parse.eval_convert.dotrunc:
L5456:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5458;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5459;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5460;
	goto L5461;
L5458:
	R1 = 255;
	asu64(R2) = p;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5463;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi8(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5463:
	goto L5457;
L5459:
	R1 = 65535;
	asu64(R2) = p;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5465;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi16(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5465:
	goto L5457;
L5460:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4294967295;
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5467;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5467:
	goto L5457;
L5461:
L5457:
	goto L5444;
	goto L5452;
L5455:
L5452:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5469;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
L5469:
	goto L5447;
L5449:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5471;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5471;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5472;
	goto L5473;
L5471:
	R1 = 0;
	goto L5441;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
	goto L5470;
L5472:
	goto L5456;
	goto L5470;
L5473:
L5470:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5475;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
L5475:
	goto L5447;
L5450:
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5477;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5477;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5478;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5478;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5479;
	goto L5480;
L5477:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
	goto L5476;
L5478:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
	goto L5476;
L5479:
	R1 = 10;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
	goto L5476;
L5480:
L5476:
	goto L5447;
L5451:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5482;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5484;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5486;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5486;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5486;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5486;
	goto L5487;
L5486:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5441;
	goto L5485;
L5487:
L5485:
L5484:
L5482:
L5447:
	R1 = 0;
	goto L5441;
L5441:
	return asi64(R1);
}

static void cc_parse_coercecond(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5490;
	goto L5488;
L5490:
// cc_parse.coercecond.retry:
L5491:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5493;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5493;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5493;
	goto L5494;
L5493:
	goto L5495;
	goto L5492;
L5494:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5497;
// cc_parse.coercecond.doint:
L5495:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5499;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L5499;
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5498;
L5499:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5500;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L5500;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5498;
L5500:
	R1 = 27;
	asu64(R2) = p;
	cc_parse_insertunit(asu64(R2), asi64(R1));
L5498:
	goto L5496;
L5497:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5501;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L5491;
	goto L5496;
L5501:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	R2 = tou64("Invalid condition #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5496:
L5492:
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5488:
	return;
}

static void cc_parse_coercebasetype(u64 p) {
    u64 R1, R2; 
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5504;
	asi64(R1) = t;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L5504;
	R1 = 3;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L5503;
L5504:
	asi64(R1) = t;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L5505;
	asi64(R1) = t;
	R2 = 7;
	if (asi64(R1) > asi64(R2)) goto L5505;
	R1 = 8;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L5505:
L5503:
	return;
}

static void cc_parse_checklvalue(u64 p, i64 assign) {
    u64 R1, R2, R3, R4; struct $B37 R1_B37; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5508;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5509;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5510;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5511;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5512;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5513;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5514;
	goto L5515;
L5508:
	goto L5507;
L5509:
	goto L5507;
L5510:
	asi64(R1) = assign;
	if (!asi64(R1)) goto L5517;
	goto L5518;
L5517:
	goto L5507;
L5511:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5520;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5520;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5520;
	goto L5521;
L5520:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B37) = *(struct $B37*)(R1);
	asu64(R2) = p;
	*(struct $B37*)(R2) = (R1_B37);
	goto L5519;
L5521:
	R1 = tou64("CHECKLV/WIDEN");
	cc_support_terror(asu64(R1));
L5519:
	goto L5507;
L5512:
	goto L5507;
L5513:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5523;
	goto L5518;
L5523:
	goto L5507;
L5514:
	asi64(R1) = assign;
	if (!asi64(R1)) goto L5525;
	goto L5518;
L5525:
	goto L5507;
L5515:
// cc_parse.checklvalue.notlv:
L5518:
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("value: #");
	cc_support_terror_s(asu64(R2), asu64(R1));
L5507:
	return;
}

static u64 cc_parse_createcall(u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	u64 r;
	u64 s;
	u64 u;
	u64 d;
	u64 pm;
	i64 i;
	i64 nparams;
	i64 aparams;
	i64 retmode;
	i64 mproc;
	i64 m;
	i64 c;
	struct $B41 str;
	u64 ss;
	u64 tt;
	u64 uu;
	u64 exprstr;
	R1 = 0;
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5528;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5529;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5529;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5530;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L5530;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L5530;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5530;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L5530;
	goto L5531;
L5528:
// cc_parse.createcall.doptr:
L5532:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mproc = asi64(R1);
	goto L5534;
L5533:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mproc = asi64(R1);
	asi64(R1) = mproc;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	p = asu64(R1);
L5534:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5533;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5537;
	asi64(R1) = mproc;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Not function pointer: #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5537:
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = mproc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	retmode = asi64(R1);
	goto L5527;
L5529:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5539;
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	retmode = asi64(R1);
	goto L5538;
L5539:
	goto L5532;
L5538:
	goto L5527;
L5530:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	p = asu64(R1);
	goto L5532;
	goto L5527;
L5531:
	msysc_m$print_startcon();
	R1 = tou64("JTAGNAMES[P.TAG]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("ccall?");
	cc_support_serror(asu64(R1));
L5527:
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nparams = asi64(R1);
	R1 = 0;
	aparams = asi64(R1);
	asu64(R1) = q;
	s = asu64(R1);
	goto L5541;
L5540:
	R1 = (u64)&aparams;
	(*toi64p(R1)) += 1;
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
L5541:
	asu64(R1) = s;
	if (asu64(R1)) goto L5540;
	asi64(R1) = aparams;
	asi64(R2) = nparams;
	if (asi64(R1) >= asi64(R2)) goto L5544;
	R1 = tou64("1:Too few args");
	cc_support_terror(asu64(R1));
	goto L5543;
L5544:
	asi64(R1) = aparams;
	asi64(R2) = nparams;
	if (asi64(R1) <= asi64(R2)) goto L5545;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5545;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5545;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5547;
	msysc_m$print_startcon();
	asi64(R1) = aparams;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many args");
	cc_support_terror(asu64(R1));
L5547:
L5545:
L5543:
	asu64(R1) = q;
	s = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = aparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5550;
L5548:
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L5552;
	asu64(R1) = pm;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	cc_parse_coercemode_inplace(asu64(R2), asi64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	goto L5551;
L5552:
	asu64(R1) = s;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5554;
	R1 = tou64("Variadic param is void");
	cc_support_terror(asu64(R1));
L5554:
	asu64(R1) = s;
	cc_parse_coercebasetype(asu64(R1));
L5551:
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	i += 1; if (i <= aparams) goto L5548;
L5550:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 30;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	asi64(R1) = retmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	cc_parse_fixmemopnd(asu64(R1));
	asi64(R1) = aparams;
	asu64(R2) = r;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L5526;
L5526:
	return asu64(R1);
}

static u64 cc_parse_arraytopointer(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 offset;
	i64 t;
	i64 elemmode;
	i64 refmode;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5557;
	asi64(R1) = elemmode;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	refmode = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5559;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5560;
	goto L5561;
L5559:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L5558;
L5560:
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	R1 = 53;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 55;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = refmode;
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5558;
L5561:
	msysc_m$print_startcon();
	R1 = tou64("ATP:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("ATP?");
	cc_support_terror(asu64(R1));
L5558:
	asi64(R1) = refmode;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5557:
	asu64(R1) = p;
	goto L5555;
L5555:
	return asu64(R1);
}

static u64 cc_parse_createindexop(u64 p, u64 q) {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createaddop(asu64(R2), asu64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	goto L5562;
L5562:
	return asu64(R1);
}

static i64 cc_parse_readstructdecl(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 currrecord;
	u64 ulist;
	u64 ulistx;
	u64 tagowner;
	i64 funion;
	i64 linkage;
	i64 mbase;
	i64 m;
	i64 offset;
	i64 recsize;
	i64 maxsize;
	i64 maxalignment;
	i64 alignment;
	i64 size;
	u64 pm;
	u64 fieldlist;
	u64 fl;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	funion = asi64(R1);
	cc_lex_lex();
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L5565;
	asu64(R1) = cc_decls_currproc;
	goto L5564;
L5565:
	asu64(R1) = cc_decls_stmodule;
L5564:
	tagowner = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5567;
	asu64(R1) = cc_lib_nextautotype();
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	d = asu64(R1);
	goto L5566;
L5567:
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5569;
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = tagowner;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5571;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5573;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Struct tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5573:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5563;
L5571:
	R1 = 13;
	asu64(R2) = d;
	asu64(R3) = tagowner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = funion;
	if (!asi64(R1)) goto L5575;
	R1 = 19;
	goto L5574;
L5575:
	R1 = 18;
L5574:
	asu64(R2) = e;
	asi64(R1) = cc_lib_createstructmode(asu64(R2), asi64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5563;
L5569:
L5566:
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = tagowner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5577;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5579;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Struct tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5579:
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5581;
	msysc_m$print_startcon();
	R1 = tou64("Prev");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1677215;
	asi64(R1) &= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asu64(R2) = e;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asu64(R2) = e;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Redefining struct #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5581:
	goto L5576;
L5577:
	R1 = 13;
	asu64(R2) = d;
	asu64(R3) = tagowner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = funion;
	if (!asi64(R1)) goto L5583;
	R1 = 19;
	goto L5582;
L5583:
	R1 = 18;
L5582:
	asu64(R2) = e;
	asi64(R1) = cc_lib_createstructmode(asu64(R2), asi64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L5576:
	cc_lex_lex();
	asu64(R1) = e;
	currrecord = asu64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	R2 = R1;
	recsize = asi64(R2);
	R2 = R1;
	maxsize = asi64(R2);
	offset = asi64(R1);
	R1 = 1;
	maxalignment = asi64(R1);
	R1 = 0;
	fieldlist = asu64(R1);
	R1 = -1;
	m = asi64(R1);
	goto L5585;
L5584:
	R1 = (u64)&linkage;
	asu64(R2) = currrecord;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
L5587:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5589;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5589;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5589;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5590;
	goto L5591;
L5589:
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = currrecord;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5593;
	R1 = tou64("Field name expected");
	cc_support_serror(asu64(R1));
L5593:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5596;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L5595;
L5596:
	R1 = tou64("typedef or function inside struct");
	cc_support_serror(asu64(R1));
L5595:
	R1 = 0;
	R2 = 4;
	asu64(R3) = d;
	asu64(R4) = currrecord;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5598;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("member name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5598:
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5600;
	R1 = tou64("Can't use ss in struct");
	cc_support_serror(asu64(R1));
L5600:
// cc_parse.readstructdecl.addanonfield:
L5601:
	R1 = 10;
	asu64(R2) = d;
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = d;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistdef(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ulist;
	asu64(R2) = currrecord;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulistx;
	asu64(R2) = currrecord;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = currrecord;
	asu64(R2) = d;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asi64(R2) = maxalignment;
	if (asi64(R1) <= asi64(R2)) goto L5603;
	asi64(R1) = alignment;
	maxalignment = asi64(R1);
L5603:
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = cc_parse_roundoffset(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&recsize;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	asu64(R2) = d;
	R3 = (u64)&fieldlist;
	cc_parse_addnewfield(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = funion;
	if (!asi64(R1)) goto L5605;
	asi64(R1) = maxsize;
	asi64(R2) = size;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxsize = asi64(R1);
	goto L5604;
L5605:
	asi64(R1) = size;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&recsize;
	*toi64p(R2) += asi64(R1);
L5604:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5607;
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
L5607:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5609;
	goto L5610;
L5609:
	cc_lex_lex();
	goto L5608;
L5610:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5588;
L5608:
	goto L5587;
L5590:
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5588;
	goto L5587;
L5591:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5612;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5612;
	goto L5613;
L5612:
	asu64(R1) = cc_lib_getautofieldname();
	d = asu64(R1);
	asi64(R1) = mbase;
	m = asi64(R1);
	goto L5601;
	goto L5611;
L5613:
	asi64(R1) = m;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5615;
	R1 = tou64("Struct decl error");
	cc_support_serror(asu64(R1));
	goto L5614;
L5615:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Struct decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5614:
L5611:
	goto L5587;
L5588:
L5585:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L5584;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = fieldlist;
	asu64(R2) = currrecord;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = maxalignment;
	asi64(R2) = funion;
	if (!asi64(R2)) goto L5617;
	asi64(R2) = maxsize;
	goto L5616;
L5617:
	asi64(R2) = recsize;
L5616:
	asi64(R1) = cc_parse_roundoffset(asi64(R2), asi64(R1));
	R2 = (u64)&cc_decls_ttsize;
	asu64(R3) = currrecord;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = maxalignment;
	asu64(R2) = currrecord;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = currrecord;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5620;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5620;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5620;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5619;
L5620:
	R1 = 0;
	R2 = (u64)&cc_decls_ttisblock;
	asu64(R3) = currrecord;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5619:
	asu64(R1) = currrecord;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5563;
L5563:
	return asi64(R1);
}

static i64 cc_parse_checkpointertypes(i64 s, i64 t, i64 hard) {
    u64 R1, R2, R3; 
	i64 starget;
	i64 ttarget;
	i64 sbase;
	i64 tbase;
	i64 sconst;
	i64 tconst;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	R1 = 0;
	sconst = asi64(R1);
	R1 = 0;
	tconst = asi64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = starget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5623;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = starget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = 1;
	sconst = asi64(R1);
L5623:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = ttarget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5625;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = ttarget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	R1 = 1;
	tconst = asi64(R1);
L5625:
	asi64(R1) = hard;
	if (asi64(R1)) goto L5627;
	asi64(R1) = sconst;
	if (!asi64(R1)) goto L5627;
	asi64(R1) = tconst;
	if (asi64(R1)) goto L5627;
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("const to non-const pointer");
	cc_support_terror(asu64(R1));
L5627:
	asi64(R1) = starget;
	asi64(R2) = ttarget;
	if (asi64(R1) != asi64(R2)) goto L5629;
	R1 = 1;
	goto L5621;
L5629:
	asi64(R1) = starget;
	s = asi64(R1);
	asi64(R1) = ttarget;
	t = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	sbase = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5631;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L5631;
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5631;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L5631;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = sbase;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = tbase;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) != asi64(R2)) goto L5633;
	R1 = 1;
	goto L5621;
L5633:
L5631:
	asi64(R1) = sbase;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5636;
	asi64(R1) = tbase;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5635;
L5636:
	R1 = 1;
	goto L5621;
L5635:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5638;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5638;
	asi64(R1) = hard;
	asi64(R2) = t;
	asi64(R3) = s;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L5621;
	goto L5637;
L5638:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5639;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5639;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) == asi64(R2)) goto L5641;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L5643;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L5643;
	msysc_m$print_startcon();
	R1 = tou64("BAD REF[]");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	goto L5621;
	R1 = 0;
	goto L5621;
L5643:
L5641:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	asi64(R1) = starget;
	asi64(R2) = ttarget;
	if (asi64(R1) != asi64(R2)) goto L5645;
	R1 = 1;
	goto L5621;
L5645:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = starget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5647;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = ttarget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5647;
	asi64(R1) = hard;
	asi64(R2) = ttarget;
	asi64(R3) = starget;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L5621;
L5647:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = starget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5649;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = ttarget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5649;
	asi64(R1) = hard;
	asi64(R2) = ttarget;
	asi64(R3) = starget;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L5621;
L5649:
	goto L5637;
L5639:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5650;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5650;
	R1 = 1;
	goto L5621;
L5650:
L5637:
	R1 = 0;
	goto L5621;
L5621:
	return asi64(R1);
}

static i64 cc_parse_comparemode(i64 s, i64 t) {
    u64 R1, R2, R3; 
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5653;
	R1 = 1;
	goto L5651;
L5653:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5655;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5655;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = s;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5657;
	R1 = 0;
	goto L5651;
L5657:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5660;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5660;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) != asi64(R2)) goto L5659;
L5660:
	R1 = 1;
	goto L5651;
L5659:
L5655:
	R1 = 0;
	goto L5651;
L5651:
	return asi64(R1);
}

static i64 cc_parse_readenumdecl(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5663;
	asu64(R1) = owner;
	cc_parse_readenumnames(asu64(R1));
	R1 = 12;
	goto L5661;
L5663:
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5665;
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5667;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5669;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Enum tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5669:
L5667:
	R1 = 12;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asi64(R1) = cc_lib_createenummode(asu64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5661;
L5665:
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5671;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5673;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Enum tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5673:
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5675;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Redefining enum #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5675:
	goto L5670;
L5671:
	R1 = 12;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asi64(R1) = cc_lib_createenummode(asu64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L5670:
	asu64(R1) = owner;
	cc_parse_readenumnames(asu64(R1));
	asu64(R1) = e;
	R2 = (u64)&cc_decls_ttnamedef;
	asu64(R3) = e;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5661;
L5661:
	return asi64(R1);
}

static void cc_parse_readenumnames(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 ulist;
	u64 ulistx;
	i64 enumseq;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	enumseq = asi64(R1);
	cc_lex_lex();
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5678;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5678;
	goto L5679;
L5678:
	goto L5677;
L5679:
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L5681;
	asu64(R1) = cc_decls_currproc;
	goto L5680;
L5681:
	asu64(R1) = cc_decls_stmodule;
L5680:
	owner = asu64(R1);
L5677:
	goto L5683;
L5682:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5686;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("enum name reused #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5686:
	R1 = 11;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5688;
	cc_lex_lex();
	asi64(R1) = cc_parse_readconstintexpr();
	enumseq = asi64(R1);
L5688:
	asi64(R1) = enumseq;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&enumseq;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5690;
	cc_lex_lex();
L5690:
L5683:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5682;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	return;
}

static u64 cc_parse_createdotop(i64 opc, u64 p, u64 d) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 poffset;
	u64 pb;
	u64 pc;
	u64 e;
	u64 f;
	u64 prec;
	u64 panon;
	u64 pfield;
	u64 gend;
	i64 m;
	i64 offset;
	i64 scale;
	u64 fl;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = opc;
	R2 = 50;
	if (asi64(R1) != asi64(R2)) goto L5693;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5695;
	R1 = tou64("-> needs pointer");
	cc_support_serror(asu64(R1));
L5695:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
L5693:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5697;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5697;
	goto L5698;
L5697:
	goto L5696;
L5698:
	R1 = tou64(". -> not a struct");
	cc_support_serror(asu64(R1));
L5696:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	prec = asu64(R1);
	asu64(R1) = d;
	f = asu64(R1);
	goto L5700;
L5699:
	asu64(R1) = f;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = prec;
	if (asu64(R1) != asu64(R2)) goto L5703;
	asu64(R1) = f;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	goto L5701;
L5703:
L5700:
	asu64(R1) = f;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L5699;
L5701:
	asu64(R1) = f;
	if (asu64(R1)) goto L5705;
	asu64(R1) = d;
	gend = asu64(R1);
	goto L5707;
L5706:
	asu64(R1) = gend;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	gend = asu64(R1);
L5707:
	asu64(R1) = gend;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5706;
	asu64(R1) = prec;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fl = asu64(R1);
	goto L5710;
L5709:
	asu64(R1) = fl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = gend;
	if (asu64(R1) != asu64(R2)) goto L5713;
	asu64(R1) = fl;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	asu64(R1) = fl;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	offset = asi64(R1);
	goto L5711;
L5713:
	asu64(R1) = fl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fl = asu64(R1);
L5710:
	asu64(R1) = fl;
	if (asu64(R1)) goto L5709;
L5711:
L5705:
	asu64(R1) = f;
	if (asu64(R1)) goto L5715;
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field of struct # #");
	cc_support_terror_ss(asu64(R3), asu64(R2), asu64(R1));
L5715:
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	poffset = asu64(R1);
	asi64(R1) = opc;
	R2 = 50;
	if (asi64(R1) != asi64(R2)) goto L5717;
	asu64(R1) = p;
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	p = asu64(R1);
L5717:
	asu64(R1) = p;
	R2 = 49;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = f;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R1) = cc_parse_arraytopointer(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = p;
	goto L5691;
L5691:
	return asu64(R1);
}

static u64 cc_parse_mulunit(u64 p, i64 elemtype) {
    u64 R1, R2, R3; 
	i64 elemsize;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5720;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5722;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5721;
L5722:
	asu64(R1) = p;
	R2 = 57;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = elemsize;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5721:
L5720:
	asu64(R1) = p;
	goto L5718;
L5718:
	return asu64(R1);
}

static u64 cc_parse_divunit(u64 p, i64 elemtype) {
    u64 R1, R2, R3; 
	i64 elemsize;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5725;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5727;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5726;
L5727:
	asu64(R1) = p;
	R2 = 57;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = elemsize;
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5726:
L5725:
	asu64(R1) = p;
	goto L5723;
L5723:
	return asu64(R1);
}

static u64 cc_parse_createassignopref(i64 opc, u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	i64 pmode;
	i64 qmode;
	i64 rmode;
	i64 elemmode;
	u64 r;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	rmode = asi64(R2);
	pmode = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = pmode;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	asu64(R1) = q;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qmode = asi64(R1);
	asi64(R1) = opc;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5730;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5731;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5732;
	goto L5733;
L5730:
	asi64(R1) = pmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 11;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	goto L5729;
L5731:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = qmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5735;
	R1 = tou64("ptr+=ptr");
	cc_support_serror(asu64(R1));
L5735:
	R1 = 4;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 61;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	goto L5729;
L5732:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = qmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5737;
	asi64(R1) = qmode;
	asi64(R2) = pmode;
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L5739;
	R1 = tou64("-= refs don't match");
	cc_support_serror(asu64(R1));
L5739:
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R3) = p;
	R4 = 40;
	asu64(R2) = cc_lib_createunit2(asi64(R4), asu64(R3), asu64(R2));
	asu64(R1) = cc_parse_divunit(asu64(R2), asi64(R1));
	r = asu64(R1);
	R1 = 3;
	rmode = asi64(R1);
	goto L5736;
L5737:
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 62;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
L5736:
	goto L5729;
L5733:
	R1 = tou64("Not allowed on ptrs");
	cc_support_serror(asu64(R1));
L5729:
	asi64(R1) = rmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L5728;
L5728:
	return asu64(R1);
}

static void cc_parse_addnewfield(u64 flist, u64 d, i64 offset) {
    u64 R1, R2, R3; 
	u64 e;
	u64 f;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5742;
	R1 = 32;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	f = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = f;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5744;
L5743:
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L5744:
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5743;
	asu64(R1) = d;
	asu64(R2) = f;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = f;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = flist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = f;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = flist;
	*tou64p(R2) = asu64(R1);
	goto L5741;
L5742:
	R1 = (u64)&cc_decls_ttnamedef;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5747;
L5746:
	asi64(R1) = offset;
	asu64(R2) = e;
	R3 = 88;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	asu64(R3) = flist;
	cc_parse_addnewfield(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5747:
	asu64(R1) = e;
	if (asu64(R1)) goto L5746;
L5741:
	return;
}

static void cc_parse_pushloop(i64 looptype) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_parse_loopindex;
	R2 = 64;
	if (asi64(R1) < asi64(R2)) goto L5751;
	R1 = tou64("Too many nested loop or switch");
	cc_support_serror(asu64(R1));
L5751:
	R1 = (u64)&cc_parse_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = looptype;
	R2 = (u64)&cc_parse_looptypestack;
	asi64(R3) = cc_parse_loopindex;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_parse_casevaluestack;
	asi64(R3) = cc_parse_loopindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void cc_parse_poploop() {
    u64 R1; 
	asi64(R1) = cc_parse_loopindex;
	if (!asi64(R1)) goto L5754;
	R1 = (u64)&cc_parse_loopindex;
	(*toi64p(R1)) -=1;
	goto L5753;
L5754:
	R1 = tou64("poploop?");
	cc_support_serror(asu64(R1));
L5753:
	return;
}

static void cc_parse_addcasevalue(i64 value) {
    u64 R1, R2, R3; 
	u64 p;
	i64 index;
	asi64(R1) = cc_parse_loopindex;
	index = asi64(R1);
	goto L5757;
L5756:
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
L5757:
	asi64(R1) = index;
	if (!asi64(R1)) goto L5759;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L5756;
L5759:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5761;
	R1 = tou64("case not inside switch stmt");
	cc_support_serror(asu64(R1));
L5761:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&cc_parse_casevaluestack;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&cc_parse_casevaluestack;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static i64 cc_parse_roundoffset(i64 offset, i64 alignment) {
    u64 R1, R2; 
	i64 mask;
	asi64(R1) = cc_decls_structpadding;
	if (!asi64(R1)) goto L5764;
	asi64(R1) = alignment;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5766;
	asi64(R1) = offset;
	goto L5762;
L5766:
	asi64(R1) = alignment;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mask = asi64(R1);
	goto L5768;
L5767:
	R1 = (u64)&offset;
	(*toi64p(R1)) += 1;
L5768:
	asi64(R1) = offset;
	asi64(R2) = mask;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L5767;
L5764:
	asi64(R1) = offset;
	goto L5762;
L5762:
	return asi64(R1);
}

static void cc_parse_fixmemopnd(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	asu8(R1) = cc_parse_ingeneric;
	if (!asu8(R1)) goto L5772;
	goto L5770;
L5772:
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5774;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5774;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5774;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5774;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5774;
	goto L5775;
L5774:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 56;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5773;
L5775:
L5773:
L5770:
	return;
}

static u64 cc_parse_docast(u64 p, i64 t, i64 hard, i64 inplace) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 s;
	i64 opc;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
// cc_parse.docast.retry:
L5777:
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5779;
	asu64(R1) = p;
	goto L5776;
L5779:
	R1 = 0;
	opc = asi64(R1);
	asi64(R1) = s;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L5781;
	asi64(R1) = t;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L5781;
	R1 = (u64)&cc_tables_conversionops;
	asi64(R2) = s;
	R1 += (i64)R2*16;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L5780;
L5781:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5782;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5782;
	asi64(R1) = hard;
	asi64(R2) = t;
	asi64(R3) = s;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L5784;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5776;
L5784:
	goto L5780;
L5782:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5785;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	goto L5777;
	goto L5780;
L5785:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5786;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L5777;
	goto L5780;
L5786:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5787;
	asi64(R1) = s;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5787;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5787;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5787;
	R1 = 1;
	opc = asi64(R1);
L5787:
L5780:
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5789;
	asi64(R1) = hard;
	if (asi64(R1)) goto L5791;
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = t;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asi64(R2) = s;
	asu64(R2) = cc_lib_typename(asi64(R2));
	R3 = tou64("Can't do conversion # => #");
	cc_support_terror_ss(asu64(R3), asu64(R2), asu64(R1));
L5791:
	R1 = 2;
	opc = asi64(R1);
L5789:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5793;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5794;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5795;
	goto L5796;
L5793:
	asi64(R1) = opc;
	asi64(R2) = t;
	asu64(R3) = p;
	asi64(R1) = cc_parse_eval_convert(asu64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L5798;
	asu64(R1) = p;
	goto L5776;
L5798:
	goto L5792;
L5794:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5776;
	goto L5792;
L5795:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5800;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5800;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5776;
L5800:
	goto L5792;
L5796:
L5792:
	asi64(R1) = inplace;
	if (!asi64(R1)) goto L5802;
	R1 = 56;
	asu64(R2) = p;
	cc_parse_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 58;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = t;
	asi64(R1) = cc_parse_getpromotedtype(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	goto L5776;
	goto L5801;
L5802:
	asu64(R1) = p;
	R2 = 56;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = q;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asu64(R2) = q;
	R3 = 58;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = t;
	asi64(R1) = cc_parse_getpromotedtype(asi64(R1));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5801:
	asu64(R1) = q;
	goto L5776;
L5776:
	return asu64(R1);
}

static u64 cc_parse_coercemode(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 s;
	i64 opc;
	u64 q;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5805;
	asu64(R1) = p;
	goto L5803;
L5805:
	R1 = 1;
	R2 = 0;
	asi64(R3) = t;
	asu64(R4) = p;
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	goto L5803;
L5803:
	return asu64(R1);
}

static void cc_parse_coercemode_inplace(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 s;
	i64 opc;
	u64 q;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5808;
	goto L5806;
L5808:
	R1 = 1;
	R2 = 0;
	asi64(R3) = t;
	asu64(R4) = p;
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L5806:
	return;
}

static u64 cc_parse_createsizeofop(u64 p, i64 islength) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 t;
	i64 size;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L5811;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5811;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5811;
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("Not array");
	cc_support_serror(asu64(R1));
L5811:
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5813;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5814;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5815;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5816;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5817;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5818;
	goto L5819;
L5813:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5821;
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	goto L5820;
L5821:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5820:
	goto L5812;
L5814:
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) == asi64(R2)) goto L5823;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) == asi64(R2)) goto L5824;
	goto L5825;
L5823:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	goto L5822;
L5824:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	goto L5822;
L5825:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5822:
	goto L5812;
L5815:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5827;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5827;
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	goto L5826;
L5827:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5826:
	goto L5812;
L5816:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5829;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L5831;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L5830;
L5831:
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
L5830:
	goto L5828;
L5829:
	goto L5832;
L5828:
	goto L5812;
L5817:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5834;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5834;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L5836;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L5835;
L5836:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5835:
	goto L5833;
L5834:
	R1 = 8;
	size = asi64(R1);
L5833:
	goto L5812;
L5818:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	goto L5809;
	goto L5812;
L5819:
// cc_parse.createsizeofop.cad1:
L5832:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5812:
	R1 = 9;
	asi64(R2) = size;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	goto L5809;
L5809:
	return asu64(R1);
}

static u64 cc_parse_readgeneric() {
    u64 R1, R2, R3, R4, R5; 
	u64 pexpr;
	u64 pmatch;
	u64 p;
	u64 pm;
	i64 m;
	i64 t;
	i64 def;
	i64 oldingeneric;
	i64 count;
	u64 d;
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu8(R1) = cc_parse_ingeneric;
	R1 = toi64(tou8(R1));
	oldingeneric = asi64(R1);
	R1 = 1;
	cc_parse_ingeneric = asu8(R1);
	asu64(R1) = cc_parse_readassignexpr();
	pexpr = asu64(R1);
	asi64(R1) = oldingeneric;
	cc_parse_ingeneric = asu8(R1);
	asu64(R1) = pexpr;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = 0;
	pmatch = asu64(R1);
	R1 = 0;
	def = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	R1 = 8;
	cc_lib_checksymbol(asi64(R1));
L5838:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 74;
	if (asi64(R1) != asi64(R2)) goto L5842;
	asi64(R1) = def;
	if (!asi64(R1)) goto L5844;
	R1 = tou64("generic/default twice");
	cc_support_serror(asu64(R1));
L5844:
	R1 = 1;
	def = asi64(R1);
	asi64(R1) = count;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5846;
	R1 = -1;
	t = asi64(R1);
	goto L5845;
L5846:
	R1 = -2;
	t = asi64(R1);
L5845:
	cc_lex_lex();
	goto L5841;
L5842:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
L5841:
	R1 = 10;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = t;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L5849;
	asi64(R1) = t;
	asi64(R2) = m;
	if (asi64(R1) != asi64(R2)) goto L5848;
L5849:
	asu64(R1) = p;
	pmatch = asu64(R1);
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
L5848:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5838;
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = pmatch;
	if (asu64(R1)) goto L5851;
	R1 = tou64("Generic: no type match");
	cc_support_serror(asu64(R1));
L5851:
	asi64(R1) = count;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L5853;
	R1 = tou64("Generic: multiple types match");
	cc_support_serror(asu64(R1));
L5853:
	asu64(R1) = pmatch;
	goto L5837;
L5837:
	return asu64(R1);
}

static i64 cc_parse_getmemmode(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5856;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L5855;
L5856:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
L5855:
	goto L5854;
L5854:
	return asi64(R1);
}

static i64 cc_parse_getpromotedtype(i64 t) {
    u64 R1, R2; 
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5859;
	R1 = 0;
	goto L5857;
L5859:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L5861;
	R1 = 3;
	goto L5857;
L5861:
	asi64(R1) = t;
	goto L5857;
L5857:
	return asi64(R1);
}

static void cc_genpcl_codegen_pcl() {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	u64 pp;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5864;
	msysc_m$print_startcon();
	R1 = tou64("GenPCL:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5864:
	asi64(R1) = cc_decls_nunits;
	R2 = 0;
	asu64(R1) = pc_api_pcl_start(asu64(R2), asi64(R1));
	cc_genpcl_dolibs();
	R1 = tou64("1:Start of code");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5866;
L5865:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5869;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5870;
	goto L5871;
L5869:
	asu64(R1) = d;
	cc_genpcl_dostaticvar(asu64(R1));
	goto L5868;
L5870:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5873;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5874;
	goto L5875;
L5873:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5877;
	R1 = 3;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5877:
	goto L5872;
L5874:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5879;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Static fn not defined: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5879:
	goto L5872;
L5875:
L5872:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5881;
L5880:
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5884;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5885;
	goto L5886;
L5884:
	asu64(R1) = e;
	cc_genpcl_dostaticvar(asu64(R1));
	goto L5883;
L5885:
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5888;
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5891;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = e;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5890;
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5890;
L5891:
	asu64(R1) = e;
	cc_genpcl_dostaticvar(asu64(R1));
L5890:
L5888:
	goto L5883;
L5886:
L5883:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5881:
	asu64(R1) = e;
	if (asu64(R1)) goto L5880;
	goto L5868;
L5871:
L5868:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L5866:
	asu64(R1) = d;
	if (asu64(R1)) goto L5865;
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5893;
L5892:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5896;
	goto L5897;
L5896:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5899;
	asu64(R1) = d;
	cc_genpcl_genprocdef(asu64(R1));
L5899:
	goto L5895;
L5897:
L5895:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L5893:
	asu64(R1) = d;
	if (asu64(R1)) goto L5892;
	pc_api_pcl_end();
	return;
}

static void cc_genpcl_genprocdef(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	u64 e;
	u64 pm;
	i64 ismain;
	R1 = 0;
	ismain = asi64(R1);
	R1 = tou64("main");
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5902;
	R1 = 1;
	ismain = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5902:
	asu64(R1) = p;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	asi64(R2) = ismain;
	R3 = 0;
	asu64(R4) = p;
	asu64(R4) = cc_libpcl_getpsymbol(asu64(R4));
	R5 = R4;
	e = asu64(R5);
	pc_api_pc_defproc(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = e;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5906;
L5903:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5908;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5909;
	goto L5910;
L5908:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	goto L5907;
L5909:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addlocal(asu64(R1));
	goto L5907;
L5910:
L5907:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L5906:
	asu64(R1) = d;
	if (asu64(R1)) goto L5903;
	asi64(R1) = cc_libpcl_createfwdlabel();
	cc_genpcl_retindex = asi64(R1);
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_stmt(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = cc_genpcl_retindex;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = ismain;
	if (!asi64(R1)) goto L5912;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5912:
	R1 = 0;
	asu64(R2) = p;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	if (asi64(R2) == asi64(R3)) goto L5914;
	R2 = 23;
	goto L5913;
L5914:
	R2 = 20;
L5913:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	pc_api_pc_endproc();
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	return;
}

static void cc_genpcl_dostaticvar(u64 d) {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 str;
	i64 align;
	u64 e;
	u64 p;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5917;
	goto L5915;
L5917:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	align = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5919;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5921;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$#.#.#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 7;
	R2 = (u64)&str;
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = d;
	R3 = 114;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5920;
L5921:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5920:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = align;
	pc_api_pc_setalign(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 1;
	asu64(R4) = d;
	R5 = 72;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5918;
L5919:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 124;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = align;
	pc_api_pc_setalign(asi64(R1));
L5918:
L5915:
	return;
}

static void cc_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset) {
    u64 R1, R2, R3, R4, R5; 
	i64 t;
	i64 length;
	i64 n;
	i64 i;
	i64 j;
	i64 nwords;
	i64 offset1;
	i64 offset2;
	i64 size;
	i64 padding;
	i64 isunion;
	u64 q;
	u64 a;
	u64 b;
	u64 d;
	r32 sx;
	struct $B16 str;
	struct $B3 str2;
	i64 av_1;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5924;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5925;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5926;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5926;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5927;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5928;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5929;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L5929;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5930;
	goto L5931;
L5924:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5933;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5936;
L5934:
	R1 = 0;
	R2 = 1;
	R3 = 1;
	asu64(R4) = q;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= n) goto L5934;
L5936:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L5938;
	asi64(R1) = length;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
L5938:
	goto L5932;
L5933:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 19;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isunion = asi64(R1);
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	R1 = 0;
	R2 = R1;
	offset2 = asi64(R2);
	offset1 = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5941;
L5939:
	R1 = 0;
	R2 = 1;
	R3 = 0;
	asu64(R4) = q;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = q;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&offset1;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5943;
	asi64(R1) = isunion;
	if (asi64(R1)) goto L5943;
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset2 = asi64(R1);
	goto L5942;
L5943:
	asi64(R1) = size;
	offset2 = asi64(R1);
L5942:
	asi64(R1) = offset2;
	asi64(R2) = offset1;
	asi64(R1) -= asi64(R2);
	padding = asi64(R1);
	asi64(R1) = padding;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5945;
	asi64(R1) = offset2;
	asi64(R2) = offset1;
	asi64(R1) -= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
	asi64(R1) = offset2;
	offset1 = asi64(R1);
L5945:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= n) goto L5939;
L5941:
	asi64(R1) = offset2;
	asi64(R2) = size;
	if (asi64(R1) >= asi64(R2)) goto L5947;
	asi64(R1) = size;
	asi64(R2) = offset2;
	asi64(R1) -= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
L5947:
L5932:
	goto L5922;
	goto L5923;
L5925:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (asi64(R1)) goto L5950;
	asi64(R1) = t;
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L5949;
L5950:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5952;
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	sx = asr32(R1);
	R1 = (u64)&sx;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5951;
L5952:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5951:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	goto L5948;
L5949:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5953;
	R1 = 0;
	padding = asi64(R1);
// cc_genpcl.genidata.doref:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5956;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5955;
L5956:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5957;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5955;
L5957:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5958;
	R1 = 0;
	R2 = tou64("GENIDATA/WSTRING2");
	cc_support_gerror(asu64(R2), asu64(R1));
	asi64(R1) = padding;
	cc_genpcl_doresb(asi64(R1));
	goto L5955;
L5958:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5955:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	goto L5948;
L5953:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5959;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	padding = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5962;
L5960:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 6;
	cc_libpcl_setmode(asi64(R1));
	i += 1; if (i <= av_1) goto L5960;
L5962:
	asi64(R1) = padding;
	cc_genpcl_doresb(asi64(R1));
	goto L5948;
L5959:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("IDATA/SCALAR");
	cc_support_gerror(asu64(R2), asu64(R1));
L5948:
	goto L5922;
	goto L5923;
L5926:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5964;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5964;
	goto L5965;
L5964:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L5963;
L5965:
	asu64(R1) = p;
	R2 = tou64("Idata &frame");
	cc_support_gerror(asu64(R2), asu64(R1));
L5963:
	goto L5922;
	goto L5923;
L5927:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5967;
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5967;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5969;
	goto L5970;
L5969:
	R1 = tou64("`");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5972;
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(",");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L5972:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("+");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	asu64(R2) = b;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = pc_api_genname(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5968;
L5970:
	R1 = 0;
	R2 = tou64("Add/Idata &frame");
	cc_support_gerror(asu64(R2), asu64(R1));
L5968:
	goto L5966;
L5967:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5973;
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5973;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5973;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64("+");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = pc_api_genname(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5966;
L5973:
	R1 = 0;
	R2 = tou64("1:Runtime or unsupported expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L5966:
	goto L5922;
	goto L5923;
L5928:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L5975;
	asi64(R1) = offset;
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5974;
L5975:
	asi64(R1) = offset;
	R2 = 0;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L5974:
	goto L5923;
L5929:
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5977;
	R1 = 0;
	R2 = tou64("Complex ptr expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L5977:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5923;
L5930:
	asi64(R1) = offset;
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5923;
L5931:
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = tou64("2:Runtime expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L5923:
L5922:
	return;
}

static void cc_genpcl_doresb(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	goto L5980;
L5979:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
L5980:
	asi64(R1) = n;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L5979;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5984;
L5982:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 6;
	cc_libpcl_setmode(asi64(R1));
	if (--asi64(av_1)) goto L5982;
L5984:
	return;
}

static void cc_genpcl_pushint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_genpcl_dolibs() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5989;
L5987:
	R1 = (u64)&cc_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pc_api_pc_addplib(asu64(R1));
	i += 1; if (i <= cc_decls_nlibfiles) goto L5987;
L5989:
	return;
}

static void cc_blockpcl_do_stmt(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 oldclineno;
	u64 a;
	u64 b;
	u64 d;
	asu64(R1) = p;
	if (asu64(R1)) goto L5992;
	goto L5990;
L5992:
	asi64(R1) = cc_decls_clineno;
	oldclineno = asi64(R1);
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_clineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_decls_cfileno = asi64(R1);
	asi64(R1) = cc_decls_cfileno;
	R2 = 24;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = cc_decls_clineno;
	asi64(R1) += asi64(R2);
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 6: goto L5996;
	case 7: case 10: case 24: case 25: case 26: case 27: case 28: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: goto L5995;
	case 8: goto L6000;
	case 9: goto L6002;
	case 11: goto L6003;
	case 12: case 31: goto L6004;
	case 13: goto L6005;
	case 14: goto L6006;
	case 15: goto L6007;
	case 16: goto L6008;
	case 17: goto L6009;
	case 18: goto L6010;
	case 19: goto L6011;
	case 20: goto L6013;
	case 21: goto L6014;
	case 22: goto L6015;
	case 23: goto L6012;
	case 29: goto L6030;
	case 30: goto L6001;
	case 61: goto L6016;
	case 62: goto L6017;
	case 63: goto L6018;
	case 64: goto L6019;
	case 65: goto L6022;
	case 66: goto L6023;
	case 67: goto L6024;
	case 68: goto L6025;
	case 69: goto L6026;
	case 70: goto L6027;
	case 71: case 73: goto L6028;
	case 72: case 74: goto L6029;
	default: goto L5995;
    };
// SWITCH
L5996:
	goto L5998;
L5997:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L5998:
	asu64(R1) = a;
	if (asu64(R1)) goto L5997;
	goto L5993;
L6000:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_decl(asu64(R1));
	goto L5993;
L6001:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_call(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5993;
L6002:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_do_return(asu64(R2), asu64(R1));
	goto L5993;
L6003:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_assign(asu64(R3), asu64(R2), asi64(R1));
	goto L5993;
L6004:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_if(asu64(R3), asu64(R2), asu64(R1));
	goto L5993;
L6005:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_for(asu64(R2), asu64(R1));
	goto L5993;
L6006:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_while(asu64(R2), asu64(R1));
	goto L5993;
L6007:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_dowhile(asu64(R2), asu64(R1));
	goto L5993;
L6008:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_goto(asu64(R1));
	goto L5993;
L6009:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_labeldef(asu64(R1));
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L5993;
L6010:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_do_casestmt(asu64(R2), asu64(R1));
	goto L5993;
L6011:
	R1 = 1;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = cc_blockpcl_sw_defaultlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L5993;
L6012:
	asi64(R1) = cc_blockpcl_sw_breaklabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L5993;
L6013:
	R1 = (u64)&cc_blockpcl_breakstack;
	asi64(R2) = cc_blockpcl_loopindex;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	cc_blockpcl_genjumpl(asi64(R1));
	goto L5993;
L6014:
	R1 = (u64)&cc_blockpcl_continuestack;
	asi64(R2) = cc_blockpcl_loopindex;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	cc_blockpcl_genjumpl(asi64(R1));
	goto L5993;
L6015:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_do_switch(asu64(R3), asu64(R2), asu64(R1));
	goto L5993;
L6016:
	R1 = 0;
	R2 = 90;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6017:
	R1 = 0;
	R2 = 91;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6018:
	R1 = 0;
	R2 = 92;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6019:
	R1 = 0;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = cc_lib_isrealcc(asi64(R2));
	if (!asi64(R2)) goto L6021;
	R2 = 93;
	goto L6020;
L6021:
	R2 = 94;
L6020:
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6022:
	R1 = 0;
	R2 = 95;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6023:
	R1 = 0;
	R2 = 96;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6024:
	R1 = 0;
	R2 = 97;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6025:
	R1 = 0;
	R2 = 98;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6026:
	R1 = 0;
	R2 = 99;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6027:
	R1 = 0;
	R2 = 100;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5993;
L6028:
	R1 = 84;
	asu64(R2) = a;
	cc_blockpcl_do_preincr(asu64(R2), asi64(R1));
	goto L5993;
L6029:
	R1 = 85;
	asu64(R2) = a;
	cc_blockpcl_do_preincr(asu64(R2), asi64(R1));
	goto L5993;
L6030:
	goto L6032;
L6031:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L6032:
	asu64(R1) = a;
	if (asu64(R1)) goto L6031;
	goto L5993;
L5995:
	R1 = 0;
	asu64(R2) = p;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L6035;
	asu64(R1) = a;
	goto L6034;
L6035:
	asu64(R1) = p;
L6034:
	cc_libpcl_setmode_u(asu64(R1));
L5993:
L5990:
	return;
}

static void cc_blockpcl_dx_expr(u64 p, i64 am) {
    u64 R1, R2, R3, R4, R5; 
	i64 oldclineno;
	i64 value;
	i64 m;
	u64 a;
	u64 b;
	struct $B16 str;
	u64 d;
	asu64(R1) = p;
	if (asu64(R1)) goto L6038;
	goto L6036;
L6038:
	asi64(R1) = cc_decls_clineno;
	oldclineno = asi64(R1);
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_clineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_decls_cfileno = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 1: goto L6042;
	case 2: case 6: case 7: case 8: case 9: case 10: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 28: case 32: case 50: case 51: case 59: goto L6041;
	case 3: goto L6043;
	case 4: goto L6044;
	case 5: goto L6045;
	case 11: goto L6046;
	case 24: case 25: goto L6047;
	case 26: goto L6048;
	case 27: goto L6051;
	case 29: goto L6052;
	case 30: goto L6063;
	case 31: goto L6064;
	case 33: case 34: case 35: case 36: case 37: case 38: goto L6065;
	case 39: goto L6066;
	case 40: goto L6069;
	case 41: goto L6070;
	case 42: goto L6071;
	case 43: goto L6074;
	case 44: goto L6075;
	case 45: goto L6076;
	case 46: goto L6077;
	case 47: goto L6078;
	case 48: goto L6079;
	case 49: goto L6102;
	case 52: goto L6080;
	case 53: goto L6081;
	case 54: goto L6082;
	case 55: goto L6101;
	case 56: goto L6083;
	case 57: goto L6086;
	case 58: goto L6087;
	case 60: goto L6088;
	case 61: goto L6091;
	case 62: goto L6092;
	case 63: goto L6093;
	case 64: goto L6094;
	case 65: goto L6095;
	case 66: goto L6096;
	case 67: goto L6097;
	case 68: goto L6098;
	case 69: goto L6099;
	case 70: goto L6100;
	case 71: case 72: goto L6089;
	case 73: case 74: goto L6090;
	case 75: goto L6103;
	case 76: goto L6104;
	default: goto L6041;
    };
// SWITCH
L6042:
	asu64(R1) = p;
	cc_blockpcl_dx_const(asu64(R1));
	goto L6039;
L6043:
	asi64(R1) = am;
	asu64(R2) = p;
	cc_blockpcl_dx_name(asu64(R2), asi64(R1));
	goto L6039;
L6044:
	asi64(R1) = am;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	goto L6039;
L6045:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L6039;
L6046:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_assign(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6047:
	asu64(R1) = p;
	cc_blockpcl_dx_andorl(asu64(R1));
	goto L6039;
L6048:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L6050;
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode2(asi64(R1));
	goto L6049;
L6050:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 63;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
L6049:
	goto L6039;
L6051:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode2(asi64(R1));
	goto L6039;
L6052:
	goto L6056;
L6053:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L6058;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6059;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6059;
	R2 = 31;
	if (asi64(R1) != asi64(R2)) goto L6058;
L6059:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L6057;
L6058:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L6061;
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6062;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L6061;
L6062:
	R1 = 0;
	R2 = 134;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6061:
L6057:
	asu64(R1) = b;
	a = asu64(R1);
L6056:
	asu64(R1) = a;
	if (asu64(R1)) goto L6053;
	goto L6039;
L6063:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_call(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6064:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_ifx(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6039;
L6065:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_eq(asu64(R3), asu64(R2), asu64(R1));
	goto L6039;
L6066:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6068;
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = b;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L6068;
	R1 = 9;
	asu64(R2) = b;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6068:
	R1 = 43;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6069:
	R1 = 44;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6070:
	R1 = 45;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6071:
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L6073;
	R1 = 46;
	goto L6072;
L6073:
	R1 = 47;
L6072:
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6074:
	R1 = 48;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6075:
	R1 = 50;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6076:
	R1 = 51;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6077:
	R1 = 52;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6078:
	R1 = 53;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6079:
	R1 = 54;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6080:
	asi64(R1) = am;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_ptr(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6081:
	asi64(R1) = am;
	R2 = 57;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	cc_blockpcl_dx_addptr(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6082:
	asi64(R1) = am;
	R2 = 58;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	cc_blockpcl_dx_addptr(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6083:
	asu64(R1) = p;
	R2 = 58;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6085;
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	goto L6084;
L6085:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 58;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_convert(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L6084:
	goto L6039;
L6086:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_scale(asu64(R3), asu64(R2), asu64(R1));
	goto L6039;
L6087:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 60;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	goto L6039;
L6088:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 62;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	goto L6039;
L6089:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_dx_preincrx(asu64(R2), asu64(R1));
	goto L6039;
L6090:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_dx_postincrx(asu64(R2), asu64(R1));
	goto L6039;
L6091:
	R1 = 1;
	R2 = 90;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6092:
	R1 = 1;
	R2 = 91;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6093:
	R1 = 1;
	R2 = 92;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6094:
	R1 = 1;
	R2 = 93;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6095:
	R1 = 1;
	R2 = 95;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6096:
	R1 = 1;
	R2 = 96;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6097:
	R1 = 1;
	R2 = 97;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6098:
	R1 = 1;
	R2 = 98;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6099:
	R1 = 1;
	R2 = 99;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6100:
	R1 = 1;
	R2 = 100;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6039;
L6101:
	asi64(R1) = am;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_addrof(asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6102:
	asi64(R1) = am;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_dot(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6039;
L6103:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 129;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6039;
L6104:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 130;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6039;
L6041:
	R1 = 0;
	R2 = (u64)&cc_tables_jtagnames;
	asu64(R3) = p;
	R4 = 40;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("DX-EXPR: can't do tag: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6039:
	asi64(R1) = oldclineno;
	cc_decls_clineno = asi64(R1);
L6036:
	return;
}

static void cc_blockpcl_dx_const(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6107;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L6107;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6106;
L6107:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6109;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6110;
	goto L6111;
L6109:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6108;
L6110:
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6108;
L6111:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L6113;
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L6113;
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6112;
L6113:
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6114;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6116;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6115;
L6116:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6117;
	R1 = 0;
	R2 = tou64("CONST/WSTRING");
	cc_support_gerror(asu64(R2), asu64(R1));
	goto L6115;
L6117:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6115:
	goto L6112;
L6114:
	R1 = 0;
	R2 = tou64("const?");
	cc_support_gerror(asu64(R2), asu64(R1));
L6112:
L6108:
L6106:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_name(u64 p, i64 am) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6120;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6120;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6120;
	goto L6121;
L6120:
	asi64(R1) = am;
	if (!asi64(R1)) goto L6123;
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L6122;
L6123:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L6122:
	goto L6119;
L6121:
	R1 = 0;
	R2 = tou64("dxname");
	cc_support_gerror(asu64(R2), asu64(R1));
L6119:
	return;
}

static void cc_blockpcl_dx_bin(u64 a, u64 b, i64 opc) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_binto(u64 a, u64 b, i64 opc, i64 res) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = res;
	if (asi64(R1)) goto L6127;
	asi64(R1) = opc;
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L6127;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L6127;
	cc_blockpcl_do_setinplace();
L6127:
	asi64(R1) = res;
	if (!asi64(R1)) goto L6129;
	R1 = 0;
	R2 = 8;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 3;
	R3 = 2;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
L6129:
	R1 = 0;
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = res;
	if (!asi64(R1)) goto L6131;
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
L6131:
	return;
}

static void cc_blockpcl_do_assign(u64 a, u64 b, i64 res) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = res;
	if (!asi64(R1)) goto L6134;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6134:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6136;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6137;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6138;
	goto L6139;
L6136:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6135;
L6137:
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 5;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6135;
L6138:
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 5;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6135;
L6139:
	R1 = 0;
	R2 = (u64)&cc_tables_jtagnames;
	asu64(R3) = a;
	R4 = 40;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("DOASSIGN not ready: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6135:
	return;
}

static void cc_blockpcl_dx_ptr(u64 p, u64 a, i64 am) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = am;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6142;
	R1 = 0;
	R2 = 1;
	R3 = 2;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L6142:
	return;
}

static void cc_blockpcl_dx_addptr(u64 p, u64 a, u64 b, i64 opc, i64 am) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asi64(R3) = opc;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_addrof(u64 p, u64 a, i64 am) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	return;
}

static void cc_blockpcl_dx_convert(u64 p, u64 a, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	i64 s;
	i64 ssize;
	i64 tsize;
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	ssize = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	tsize = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6147;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6148;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6149;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6149;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6150;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6150;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6151;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6151;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6152;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6153;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6154;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6154;
	goto L6155;
L6147:
	goto L6145;
	goto L6146;
L6148:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6158;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6157;
L6158:
	R1 = 0;
	R2 = tou64("Bad cast");
	cc_support_gerror(asu64(R2), asu64(R1));
L6157:
	asi64(R1) = tsize;
	asi64(R2) = ssize;
	if (asi64(R1) <= asi64(R2)) goto L6160;
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6159;
L6160:
	asi64(R1) = tsize;
	asi64(R2) = ssize;
	if (asi64(R1) >= asi64(R2)) goto L6161;
	goto L6162;
	goto L6145;
L6161:
L6159:
	goto L6146;
L6149:
	asi64(R1) = ssize;
	asi64(R2) = tsize;
	if (asi64(R1) != asi64(R2)) goto L6164;
	goto L6145;
L6164:
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6146;
L6150:
	R1 = 0;
	R2 = 111;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6146;
L6151:
	R1 = 0;
	R2 = 112;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6146;
L6152:
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6146;
L6153:
	R1 = 0;
	R2 = 116;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6146;
L6154:
// cc_blockpcl.dx_convert.dotruncate:
L6162:
	R1 = 0;
	R2 = 113;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = t;
	cc_libpcl_setmode2(asi64(R1));
	goto L6145;
	goto L6146;
L6155:
	R1 = 0;
	R2 = (u64)&cc_tables_convnames;
	asi64(R3) = opc;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Convert op not implem: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6146:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = s;
	cc_libpcl_setmode2(asi64(R1));
L6145:
	return;
}

static void cc_blockpcl_do_if(u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = b;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = c;
	if (!asu64(R1)) goto L6167;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = c;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L6166;
L6167:
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
L6166:
	return;
}

static void cc_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	i64 lab2;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 24: goto L6172;
	case 25: goto L6177;
	case 26: goto L6182;
	case 27: goto L6187;
	case 28: case 30: case 31: case 32: goto L6171;
	case 29: goto L6189;
	case 33: case 34: case 35: case 36: case 37: case 38: goto L6188;
	default: goto L6171;
    };
// SWITCH
L6172:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6174;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6175;
	goto L6176;
L6174:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6173;
L6175:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L6173;
L6176:
L6173:
	goto L6169;
L6177:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6179;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6180;
	goto L6181;
L6179:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L6178;
L6180:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6178;
L6181:
L6178:
	goto L6169;
L6182:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6184;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6185;
	goto L6186;
L6184:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6183;
L6185:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6183;
L6186:
L6183:
	goto L6169;
L6187:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6169;
L6188:
	asi64(R1) = lab;
	asu64(R2) = r;
	asu64(R3) = q;
	asu64(R4) = p;
	asi64(R5) = opc;
	cc_blockpcl_gcomparejump(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6169;
L6189:
	goto L6191;
L6190:
	asu64(R1) = q;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L6191:
	asu64(R1) = q;
	if (!asu64(R1)) goto L6193;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	r = asu64(R2);
	if (asu64(R1)) goto L6190;
L6193:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6169;
L6171:
	R1 = 0;
	asu64(R2) = p;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L6169:
	return;
}

static void cc_blockpcl_gcomparejump(i64 jumpopc, u64 p, u64 lhs, u64 rhs, i64 lab) {
    u64 R1, R2, R3; 
	i64 cond;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_blockpcl_getpclcond(asi64(R1));
	cond = asi64(R1);
	asi64(R1) = jumpopc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L6196;
	asi64(R1) = cond;
	asi64(R1) = cc_blockpcl_reversecond(asi64(R1));
	cond = asi64(R1);
L6196:
	asu64(R1) = rhs;
	asu64(R2) = lhs;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lhs;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = rhs;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 26;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = lhs;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static i64 cc_blockpcl_getpclcond(i64 op) {
    u64 R1, R2; 
	asi64(R1) = op;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6199;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6200;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6201;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6202;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L6203;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6204;
	goto L6205;
L6199:
	R1 = 1;
	goto L6197;
	goto L6198;
L6200:
	R1 = 2;
	goto L6197;
	goto L6198;
L6201:
	R1 = 3;
	goto L6197;
	goto L6198;
L6202:
	R1 = 4;
	goto L6197;
	goto L6198;
L6203:
	R1 = 5;
	goto L6197;
	goto L6198;
L6204:
	R1 = 6;
	goto L6197;
	goto L6198;
L6205:
L6198:
	R1 = 0;
	goto L6197;
L6197:
	return asi64(R1);
}

static i64 cc_blockpcl_reversecond(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6208;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6209;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6210;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6211;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6212;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6213;
	goto L6214;
L6208:
	R1 = 2;
	cc = asi64(R1);
	goto L6207;
L6209:
	R1 = 1;
	cc = asi64(R1);
	goto L6207;
L6210:
	R1 = 5;
	cc = asi64(R1);
	goto L6207;
L6211:
	R1 = 6;
	cc = asi64(R1);
	goto L6207;
L6212:
	R1 = 3;
	cc = asi64(R1);
	goto L6207;
L6213:
	R1 = 4;
	cc = asi64(R1);
	goto L6207;
L6214:
L6207:
	asi64(R1) = cc;
	goto L6206;
L6206:
	return asi64(R1);
}

static void cc_blockpcl_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_do_while(u64 pcond, u64 pbody) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6218;
	asu64(R1) = pcond;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6218;
	asu64(R1) = pbody;
	cc_blockpcl_do_while1(asu64(R1));
	goto L6216;
L6218:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = lab_c;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
L6216:
	return;
}

static void cc_blockpcl_do_while1(u64 pbody) {
    u64 R1, R2; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_do_dowhile(u64 pbody, u64 pcond) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondfalse(asu64(R1));
	if (asi64(R1)) goto L6222;
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
L6222:
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_stacklooplabels(i64 a, i64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = a;
	R2 = (u64)&cc_blockpcl_continuestack;
	R3 = (u64)&cc_blockpcl_loopindex;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&cc_blockpcl_breakstack;
	asi64(R3) = cc_blockpcl_loopindex;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static void cc_blockpcl_do_return(u64 p, u64 a) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = a;
	if (!asu64(R1)) goto L6226;
	asu64(R1) = cc_decls_currproc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6228;
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6227;
L6228:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = cc_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
L6227:
	goto L6225;
L6226:
	asi64(R1) = cc_genpcl_retindex;
	cc_blockpcl_genjumpl(asi64(R1));
L6225:
	return;
}

static void cc_blockpcl_dx_call(u64 p, u64 a, u64 b, i64 res) {
    u64 R1, R2, R3, R4; 
	u64 pm;
	i64 isfnptr;
	i64 variadic;
	i64 nparams;
	i64 retmode;
	i64 nbytes;
	i64 retsize;
	i64 m;
	i64 nvariadics;
	i64 nfixedparams;
	i64 isfn;
	i64 blockret;
	struct $B20 paramlist;
	struct $B37 paramconst;
	struct $B37 argattr;
	i64 iparams;
	i64 fparams;
	u64 dblock;
	u64 dtemp;
	u64 q;
	i64 i;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	retmode = asi64(R1);
	asi64(R1) = retmode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6231;
	R1 = 3;
	retmode = asi64(R1);
L6231:
	R1 = 0;
	isfn = asi64(R1);
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6233;
	goto L6234;
L6233:
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	goto L6236;
L6235:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
L6236:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6235;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = 1;
	isfnptr = asi64(R1);
	goto L6232;
L6234:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	isfnptr = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
L6232:
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	variadic = asi64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nfixedparams = asi64(R1);
	R1 = 0;
	R2 = R1;
	nvariadics = asi64(R2);
	nparams = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	goto L6241;
L6238:
	asi64(R1) = nparams;
	R2 = 64;
	if (asi64(R1) < asi64(R2)) goto L6243;
	R1 = 0;
	R2 = tou64("maxparams");
	cc_support_gerror(asu64(R2), asu64(R1));
L6243:
	asu64(R1) = q;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&paramconst;
	asi64(R3) = nparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = variadic;
	if (!asi64(R1)) goto L6245;
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) <= asi64(R2)) goto L6245;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L6245;
	asi64(R1) = nvariadics;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6245;
	asi64(R1) = nparams;
	nvariadics = asi64(R1);
L6245:
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) > asi64(R2)) goto L6247;
	R1 = (u64)&cc_decls_ttconst;
	asu64(R2) = pm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&paramconst;
	asi64(R3) = nparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L6247:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6241:
	asu64(R1) = q;
	if (asu64(R1)) goto L6238;
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	fparams = asi64(R2);
	iparams = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6250;
L6248:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6253;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6252;
L6253:
	R1 = (u64)&fparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R1) = -asi64(R1);
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	goto L6251;
L6252:
	R1 = (u64)&iparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L6251:
	i += 1; if (i <= nparams) goto L6248;
L6250:
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6256;
L6254:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L6258;
	asi64(R1) = i;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L6258;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6258;
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 2;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L6258:
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = i;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	R1 = toi64(toi8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += -1; if (i >= 1) goto L6254;
L6256:
	asi64(R1) = isfnptr;
	if (asi64(R1)) goto L6260;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L6262;
	R2 = 21;
	goto L6261;
L6262:
	R2 = 18;
L6261:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6259;
L6260:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L6264;
	R2 = 22;
	goto L6263;
L6264:
	R2 = 19;
L6263:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6259:
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = nvariadics;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L6266;
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = res;
	if (asi64(R1)) goto L6268;
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6267;
L6268:
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L6267:
L6266:
	return;
}

static void cc_blockpcl_do_decl(u64 d) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6271;
	R1 = 1;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6271:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6273;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6275;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6275;
	goto L6276;
L6275:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6269;
L6273:
// cc_blockpcl.do_decl.copyl:
L6276:
	asu64(R1) = d;
	R2 = 114;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
L6269:
	return;
}

static void cc_blockpcl_do_for(u64 pinit, u64 pbody) {
    u64 R1, R2, R3; 
	u64 pcond;
	u64 pincr;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_cond;
	asu64(R1) = pinit;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcond = asu64(R1);
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pincr = asu64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_cond = asi64(R1);
	asu64(R1) = pinit;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6279;
	asu64(R1) = pinit;
	cc_blockpcl_do_stmt(asu64(R1));
L6279:
	asi64(R1) = lab_cond;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_cond;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6281;
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6280;
L6281:
	asi64(R1) = lab_b;
	cc_blockpcl_genjumpl(asi64(R1));
L6280:
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_do_preincr(u64 a, i64 incrop) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asi64(R2) = incrop;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	return;
}

static void cc_blockpcl_setincrstep(i64 m) {
    u64 R1, R2, R3; 
	R1 = 1;
	pc_api_pc_setincr(asi64(R1));
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6285;
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	pc_api_pc_setincr(asi64(R1));
L6285:
	return;
}

static void cc_blockpcl_dx_preincrx(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 71;
	if (asi64(R2) != asi64(R3)) goto L6288;
	R2 = 86;
	goto L6287;
L6288:
	R2 = 87;
L6287:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	asu64(R1) = a;
	cc_blockpcl_widen(asu64(R1));
	return;
}

static void cc_blockpcl_dx_postincrx(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 73;
	if (asi64(R2) != asi64(R3)) goto L6291;
	R2 = 88;
	goto L6290;
L6291:
	R2 = 89;
L6290:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	asu64(R1) = a;
	cc_blockpcl_widen(asu64(R1));
	return;
}

static void cc_blockpcl_dx_dot(u64 p, u64 a, u64 b, i64 am) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = am;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6294;
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 2;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
	goto L6293;
L6294:
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L6293:
	return;
}

static void cc_blockpcl_dx_eq(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 31;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_blockpcl_getpclcond(asi64(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static void cc_blockpcl_do_labeldef(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L6298;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6298:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_api_gencomment(asu64(R1));
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_do_goto(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6301;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Label not defined: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L6300;
L6301:
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6302;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6302:
L6300:
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_dx_ifx(u64 p, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	i64 ismult;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	ismult = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6305;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6305:
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6307;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L6307:
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = c;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6309;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L6309:
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	return;
}

static void cc_blockpcl_do_casestmt(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 value;
	i64 i;
	asi64(R1) = cc_blockpcl_sw_ncases;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6312;
	asu64(R1) = cc_blockpcl_sw_labeltable;
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = cc_blockpcl_sw_lower;
	asi64(R2) -= asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6311;
L6312:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6316;
L6313:
	asu64(R1) = cc_blockpcl_sw_valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asi64(R2) = value;
	if (asi64(R1) != asi64(R2)) goto L6318;
	asu64(R1) = cc_blockpcl_sw_labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6315;
L6318:
	i += 1; if (i <= cc_blockpcl_sw_ncases) goto L6313;
L6316:
	R1 = 0;
	R2 = tou64("case: serial switch not found");
	cc_support_gerror(asu64(R2), asu64(R1));
L6315:
L6311:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	return;
}

static void cc_blockpcl_do_switch(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	struct $B82 labeltable;
	struct $B82 valuetable;
	struct $B80 flags;
	i64 defaultlabel;
	i64 breakswlabel;
	i64 switchlabel;
	i64 lower;
	i64 upper;
	i64 length;
	i64 value;
	i64 ncases;
	u8 serialsw;
	i64 i;
	i64 index;
	u64 pcase;
	u64 old_labeltable;
	u64 old_valuetable;
	i64 old_ncases;
	i64 old_lower;
	u8 old_defaultseen;
	i64 old_defaultlabel;
	i64 old_breaklabel;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcase = asu64(R1);
	R1 = 0;
	R2 = R1;
	length = asi64(R2);
	ncases = asi64(R1);
	goto L6321;
L6320:
	R1 = (u64)&ncases;
	(*toi64p(R1)) += 1;
	asi64(R1) = ncases;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L6324;
	R1 = 0;
	R2 = tou64("Too many cases on one switch");
	cc_support_gerror(asu64(R2), asu64(R1));
L6324:
	asu64(R1) = pcase;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	value = asi64(R2);
	R2 = (u64)&valuetable;
	asi64(R3) = ncases;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6326;
	asi64(R1) = value;
	R2 = R1;
	upper = asi64(R2);
	lower = asi64(R1);
	goto L6325;
L6326:
	asi64(R1) = lower;
	asi64(R2) = value;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	lower = asi64(R1);
	asi64(R1) = upper;
	asi64(R2) = value;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	upper = asi64(R1);
L6325:
	asu64(R1) = pcase;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcase = asu64(R1);
L6321:
	asu64(R1) = pcase;
	if (asu64(R1)) goto L6320;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6328;
	asi64(R1) = upper;
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	goto L6327;
L6328:
	R1 = 0;
	length = asi64(R1);
L6327:
	asi64(R1) = cc_libpcl_createfwdlabel();
	defaultlabel = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	breakswlabel = asi64(R1);
	asi64(R1) = length;
	R2 = 500;
	if (asi64(R1) > asi64(R2)) goto L6331;
	asi64(R1) = ncases;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L6330;
L6331:
	R1 = 1;
	serialsw = asu8(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6334;
L6332:
	asi64(R1) = cc_libpcl_createfwdlabel();
	R2 = (u64)&labeltable;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = (u64)&labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 26;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = i;
	asi64(R2) = ncases;
	if (asi64(R1) >= asi64(R2)) goto L6336;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6336:
	i += 1; if (i <= ncases) goto L6332;
L6334:
	asi64(R1) = defaultlabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L6329;
L6330:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6337;
	asi64(R1) = defaultlabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L6329;
L6337:
	R1 = 0;
	serialsw = asu8(R1);
	asi64(R1) = length;
	R2 = 0;
	R3 = (u64)&flags;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6340;
L6338:
	asi64(R1) = defaultlabel;
	R2 = (u64)&labeltable;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	i += 1; if (i <= length) goto L6338;
L6340:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6343;
L6341:
	R1 = (u64)&valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	value = asi64(R1);
	asi64(R1) = value;
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	index = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	R2 = (u64)&labeltable;
	asi64(R3) = index;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&flags;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L6345;
	R1 = 0;
	R2 = 0;
	asi64(R3) = value;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Dupl case value: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6345:
	R1 = 1;
	R2 = (u64)&flags;
	asi64(R3) = index;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= ncases) goto L6341;
L6343:
	asi64(R1) = cc_libpcl_createfwdlabel();
	switchlabel = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = switchlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 37;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = lower;
	asi64(R2) = length;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = lower;
	pc_api_pc_setxy(asi64(R2), asi64(R1));
	asi64(R1) = defaultlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = switchlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6348;
L6346:
	R1 = (u64)&labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	i += 1; if (i <= length) goto L6346;
L6348:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6329:
	asu64(R1) = cc_blockpcl_sw_labeltable;
	old_labeltable = asu64(R1);
	asu64(R1) = cc_blockpcl_sw_valuetable;
	old_valuetable = asu64(R1);
	asi64(R1) = cc_blockpcl_sw_lower;
	old_lower = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_ncases;
	old_ncases = asi64(R1);
	asu8(R1) = cc_blockpcl_sw_defaultseen;
	old_defaultseen = asu8(R1);
	asi64(R1) = cc_blockpcl_sw_defaultlabel;
	old_defaultlabel = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_breaklabel;
	old_breaklabel = asi64(R1);
	R1 = (u64)&labeltable;
	cc_blockpcl_sw_labeltable = asu64(R1);
	R1 = (u64)&valuetable;
	cc_blockpcl_sw_valuetable = asu64(R1);
	asi64(R1) = lower;
	cc_blockpcl_sw_lower = asi64(R1);
	asu8(R1) = serialsw;
	if (!asu8(R1)) goto L6350;
	asi64(R1) = ncases;
	goto L6349;
L6350:
	R1 = 0;
L6349:
	cc_blockpcl_sw_ncases = asi64(R1);
	R1 = 0;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = defaultlabel;
	cc_blockpcl_sw_defaultlabel = asi64(R1);
	asi64(R1) = breakswlabel;
	cc_blockpcl_sw_breaklabel = asi64(R1);
	asu64(R1) = b;
	cc_blockpcl_do_stmt(asu64(R1));
	asu8(R1) = cc_blockpcl_sw_defaultseen;
	if (asu8(R1)) goto L6352;
	asi64(R1) = defaultlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
L6352:
	asi64(R1) = breakswlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = old_labeltable;
	cc_blockpcl_sw_labeltable = asu64(R1);
	asu64(R1) = old_valuetable;
	cc_blockpcl_sw_valuetable = asu64(R1);
	asi64(R1) = old_lower;
	cc_blockpcl_sw_lower = asi64(R1);
	asi64(R1) = old_ncases;
	cc_blockpcl_sw_ncases = asi64(R1);
	asu8(R1) = old_defaultseen;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = old_defaultlabel;
	cc_blockpcl_sw_defaultlabel = asi64(R1);
	asi64(R1) = old_breaklabel;
	cc_blockpcl_sw_breaklabel = asi64(R1);
	return;
}

static void cc_blockpcl_dx_andorl(u64 p) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = lab1;
	asu64(R2) = p;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	R1 = 1;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	return;
}

static void cc_blockpcl_dx_scale(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	i64 opc;
	i64 scale;
	i64 n;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6356;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 45;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6355;
L6356:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 47;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6355:
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static void cc_blockpcl_widen(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6359;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6357;
L6359:
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	cc_libpcl_setmode(asi64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L6361;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6362;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6362;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6362;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L6362;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L6362;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L6362;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L6362;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L6361;
L6362:
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6365;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6364;
L6365:
	R1 = 3;
	goto L6363;
L6364:
	R1 = 8;
L6363:
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = mode;
	cc_libpcl_setmode2(asi64(R1));
L6361:
L6357:
	return;
}

static void cc_blockpcl_do_setinplace() {
    u64 R1, R2, R3; 
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6368;
	asu64(R1) = pc_api_pccurr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6368;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6368:
	return;
}

static void cc_blockpcl_do_fixwiden(u64 a, u64 b) {
	goto L6369;
L6369:
	return;
}

static u64 cc_libpcl_getpsymbol(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 e;
	u64 name;
	struct $B16 str;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6372;
	R1 = 0;
	goto L6370;
L6372:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6374;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6370;
L6374:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6377;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L6376;
L6377:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6379;
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6379:
	goto L6375;
L6376:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L6380;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6380;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6380;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6382;
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6382:
	goto L6375;
L6380:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6375:
	R1 = (u64)&cc_tables_name2pid;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	R2 = R1;
	p = asu64(R2);
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6384;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6384;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6384:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6386;
	R1 = 1;
	asu64(R2) = p;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6386:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6388;
	R1 = 1;
	asu64(R2) = p;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6388:
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6390;
	R1 = tou64("main");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6390;
	R1 = 1;
	R2 = R1;
	asu64(R3) = p;
	R4 = 110;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L6390:
	asu64(R1) = p;
	goto L6370;
L6370:
	return asu64(R1);
}

static void cc_libpcl_setmode(i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = mode;
	asi64(R2) = cc_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static void cc_libpcl_setmode2(i64 mode) {
    u64 R1; 
	asi64(R1) = mode;
	asi64(R1) = cc_lib_getpclmode(asi64(R1));
	pc_api_pc_setmode2(asi64(R1));
	return;
}

static void cc_libpcl_setmode_u(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = mode;
	asi64(R2) = cc_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static u64 cc_libpcl_genmem_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L6394;
L6394:
	return asu64(R1);
}

static u64 cc_libpcl_genmemaddr_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L6395;
L6395:
	return asu64(R1);
}

static i64 cc_libpcl_definelabel() {
    u64 R1, R2; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = pc_api_mlabelno;
	goto L6396;
L6396:
	return asi64(R1);
}

static i64 cc_libpcl_createfwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L6397;
L6397:
	return asi64(R1);
}

static void cc_libpcl_definefwdlabel(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static u64 cc_lib_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 128;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	memset(R1, 0, 128);
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L6399;
L6399:
	return asu64(R1);
}

static void cc_lib_initcclib() {
	return;
}

static u64 cc_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 3;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L6401;
L6401:
	return asu64(R1);
}

static u64 cc_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = u;
	goto L6402;
L6402:
	return asu64(R1);
}

static u64 cc_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L6403;
L6403:
	return asu64(R1);
}

static u64 cc_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L6404;
L6404:
	return asu64(R1);
}

static u64 cc_lib_createunit3(i64 tag, u64 p, u64 q, u64 r) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = u;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L6405;
L6405:
	return asu64(R1);
}

static u64 cc_lib_createconstunit(u64 a, i64 t) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	asu64(R2) = u;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = u;
	goto L6406;
L6406:
	return asu64(R1);
}

static u64 cc_lib_createstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L6409;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6408;
L6409:
	asi64(R1) = length;
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6408:
	R1 = 1;
	asu64(R2) = u;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L6407;
L6407:
	return asu64(R1);
}

static u64 cc_lib_createwstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_decls_trefwchar;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L6410;
L6410:
	return asu64(R1);
}

static i64 cc_lib_getoptocode(i64 opc) {
    u64 R1, R2, R3; 
	i64 n;
	i64 opcto;
	i64 i;
	struct $B45 str;
	i64 av_1;
	R1 = (u64)&cc_lib_getoptocode_opctotable;
	asi64(R2) = opc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	opcto = asi64(R1);
	asi64(R1) = opcto;
	if (!asi64(R1)) goto L6413;
	asi64(R1) = opcto;
	goto L6411;
L6413:
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("to");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	i = asi64(R1);
	R1 = 77;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6416;
L6414:
	R1 = (u64)&str;
	R2 = (u64)&cc_tables_jtagnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6418;
	asi64(R1) = i;
	R2 = (u64)&cc_lib_getoptocode_opctotable;
	asi64(R3) = opc;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = i;
	goto L6411;
L6418:
	i += 1; if (i <= av_1) goto L6414;
L6416:
	msysc_m$print_startcon();
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find -to version");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L6411;
L6411:
	return asi64(R1);
}

static i64 cc_lib_getconstvalue(u64 p, i64 id) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L6421;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6421;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6419;
L6421:
	R1 = tou64("GCV Not constant");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L6419;
L6419:
	return asi64(R1);
}

static u64 cc_lib_nextautotype() {
    u64 R1; 
	R1 = (u64)&cc_lib_nextautotype_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_lib_autotypeno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_lib_nextautotype_str;
	goto L6422;
L6422:
	return asu64(R1);
}

static i64 cc_lib_createconstmode(i64 m) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6425;
	asi64(R1) = m;
	goto L6423;
L6425:
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L6427;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	goto L6423;
L6427:
	asi64(R1) = m;
	asi64(R1) = cc_lib_copymode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = newm;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttconst;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = newm;
	goto L6423;
L6423:
	return asi64(R1);
}

static i64 cc_lib_createrefmode(i64 m) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L6430;
	R1 = (u64)&cc_decls_ttshared;
	R2 = (u64)&cc_decls_ttreftype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*4;
	(*toi32p(R1)) += 1;
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	goto L6428;
L6430:
	R1 = 13;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = newm;
	R2 = (u64)&cc_decls_ttreftype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisref;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L6428;
L6428:
	return asi64(R1);
}

static i64 cc_lib_createprocmode(i64 m, u64 pm) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 14;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = pm;
	R2 = (u64)&cc_decls_ttparams;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = newm;
	goto L6431;
L6431:
	return asi64(R1);
}

static i64 cc_lib_createarraymode(i64 m, i64 length) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 17;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = length;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = newm;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = newm;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L6432;
L6432:
	return asi64(R1);
}

static i64 cc_lib_createenummode(u64 e) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 12;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = e;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = newm;
	goto L6433;
L6433:
	return asi64(R1);
}

static i64 cc_lib_createstructmode(u64 s, i64 smode) {
    u64 R1, R2, R3; 
	i64 newm;
	asi64(R1) = smode;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L6434;
L6434:
	return asi64(R1);
}

static void cc_lib_setnameptr(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_lib_getautofieldname() {
    u64 R1; 
	struct $B17 str;
	u64 name;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$F");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_lib_nextafindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	goto L6436;
L6436:
	return asu64(R1);
}

static i64 cc_lib_convertstringc(u64 s, u64 t, i64 length) {
    u64 R1, R2, R3; 
	i64 c;
	struct $B45 str;
	u64 t0;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L6439;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L6439:
	asu64(R1) = t;
	t0 = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6442;
L6440:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 7: goto L6452;
	case 8: goto L6453;
	case 9: goto L6450;
	case 10: goto L6448;
	case 11: goto L6455;
	case 12: goto L6454;
	case 13: goto L6449;
	case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: goto L6445;
	case 34: goto L6446;
	case 39: goto L6447;
	case 92: goto L6451;
	default: goto L6445;
    };
// SWITCH
L6446:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6447:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 39;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6448:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6449:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6450:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6451:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6452:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 97;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6453:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 98;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6454:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 102;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6455:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 118;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6443;
L6445:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L6458;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) < asi64(R2)) goto L6457;
L6458:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\#o");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("z3");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6456;
L6457:
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6456:
L6443:
	if (--asi64(av_1)) goto L6440;
L6442:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L6437;
L6437:
	return asi64(R1);
}

static u64 cc_lib_getopcjname(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	name = asu64(R1);
	R1 = 32;
	asu64(R2) = name;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (!asu64(R1)) goto L6461;
	asu64(R1) = s;
	asu64(R2) = name;
	asu64(R1) -= asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&cc_lib_getopcjname_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_lib_getopcjname_str;
	asu64(R3) = s;
	asu64(R4) = name;
	asi64(R3) -= asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lib_getopcjname_str;
	goto L6460;
L6461:
	asu64(R1) = name;
L6460:
	goto L6459;
L6459:
	return asu64(R1);
}

static u64 cc_lib_strmode(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_lib_strmode_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_lib_strmode_str;
	goto L6462;
L6462:
	return asu64(R1);
}

static u64 cc_lib_strmode2(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_lib_strmode2_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_lib_strmode2_str;
	goto L6463;
L6463:
	return asu64(R1);
}

static void cc_lib_istrmode(i64 m, i64 expand, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 q;
	i64 value;
	i64 needcomma;
	i64 x;
	i64 i;
	i64 target;
	i64 t;
	i64 n;
	struct $B3 sxx;
	u64 xx;
	u64 sdim;
	u64 slength;
	struct $B5 strdim;
	struct $B5 strlength;
	u64 pm;
	R1 = (u64)&sxx;
	xx = asu64(R1);
	asi64(R1) = m;
	R2 = 21;
	if (asi64(R1) >= asi64(R2)) goto L6466;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6464;
L6466:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6468;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6469;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6470;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6471;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6471;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6472;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6473;
	goto L6474;
L6468:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6476;
	R1 = tou64("const ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6475;
L6476:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6475:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	target = asi64(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6478;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6478;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L6477;
L6478:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L6477:
	goto L6467;
L6469:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6480;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6479;
L6480:
	R1 = tou64("[]");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6479:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L6467;
L6470:
	R1 = tou64("enum ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L6467;
L6471:
	asi64(R1) = expand;
	if (asi64(R1)) goto L6482;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6464;
L6482:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6484;
L6483:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L6487;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6487:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6484:
	asu64(R1) = q;
	if (asu64(R1)) goto L6483;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L6467;
L6472:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6467;
L6473:
	R1 = tou64("proc(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6490;
L6488:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = pm;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = n;
	if (asi64(R1) == asi64(R2)) goto L6492;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6492:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	i += 1; if (i <= n) goto L6488;
L6490:
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L6467;
L6474:
	asi64(R1) = t;
	R2 = 21;
	if (asi64(R1) >= asi64(R2)) goto L6494;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6464;
	goto L6493;
L6494:
	msysc_m$print_startcon();
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("NEWSTRMODE");
	cc_support_mcerror(asu64(R1));
L6493:
L6467:
L6464:
	return;
}

static u64 cc_lib_typename(i64 m) {
    u64 R1, R2, R3; 
	i64 basem;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	basem = asi64(R1);
	asi64(R1) = basem;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6497;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6497;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6498;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6499;
	goto L6500;
L6497:
	asi64(R1) = basem;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6502;
	R1 = tou64("struct ");
	goto L6501;
L6502:
	R1 = tou64("union ");
L6501:
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6504;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6504:
	R1 = (u64)&cc_lib_typename_str;
	goto L6495;
	goto L6496;
L6498:
	R1 = tou64("<array>");
	goto L6495;
	goto L6496;
L6499:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6506;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6495;
L6506:
	R1 = tou64("<enum>");
	goto L6495;
	goto L6496;
L6500:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6508;
	R1 = tou64("const ");
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_tables_stdtypenames;
	asi64(R2) = basem;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lib_typename_str;
	goto L6495;
L6508:
	R1 = (u64)&cc_tables_stdtypenames;
	asi64(R2) = basem;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L6495;
L6496:
	R1 = tou64("");
	goto L6495;
L6495:
	return asu64(R1);
}

static u64 cc_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 nwords;
	R1 = (u64)&cc_decls_nunits;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_lib_remainingunits;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) -= 1; asi64(R1) = asi64(R2);
	if (!asi64(R1)) goto L6511;
	asu64(R1) = cc_lib_unitheapptr;
	p = asu64(R1);
	R1 = (u64)&cc_lib_unitheapptr;
	(*tou64p(R1)) += 64;
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L6513;
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6513:
	asu64(R1) = p;
	goto L6509;
L6511:
	R1 = 3200000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	cc_lib_unitheapptr = asu64(R2);
	p = asu64(R1);
	R1 = 3200000;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 49999;
	cc_lib_remainingunits = asi64(R1);
	R1 = (u64)&cc_lib_unitheapptr;
	(*tou64p(R1)) += 64;
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L6515;
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6515:
	asu64(R1) = p;
	goto L6509;
L6509:
	return asu64(R1);
}

static i64 cc_lib_copymode(i64 m) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_decls_ntypes;
	R2 = 80000;
	if (asi64(R1) < asi64(R2)) goto L6518;
	R1 = tou64("Too many types");
	cc_support_serror(asu64(R1));
L6518:
	R1 = (u64)&cc_decls_ntypes;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = cc_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttconst;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttparams;
	asi64(R3) = cc_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttisref;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_decls_ntypes;
	goto L6516;
L6516:
	return asi64(R1);
}

static i64 cc_lib_createnewmode(i64 m) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_decls_ntypes;
	R2 = 80000;
	if (asi64(R1) < asi64(R2)) goto L6521;
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(M)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many types/cnm");
	cc_support_serror(asu64(R1));
L6521:
	R1 = (u64)&cc_decls_ntypes;
	(*toi64p(R1)) += 1;
	asi64(R1) = m;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = cc_decls_ntypes;
	goto L6519;
L6519:
	return asi64(R1);
}

static void cc_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6524;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6523;
L6524:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6523:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_addlistdef(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6527;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6526;
L6527:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6526:
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_addlistparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6530;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6529;
L6530:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6529:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_checksymbol(i64 symbol) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L6533;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asi64(R2) = symbol;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6535;
	R1 = tou64(" \"");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6535:
	R1 = (u64)&str;
	cc_support_serror(asu64(R1));
L6533:
	return;
}

static void cc_lib_skipsymbol(i64 symbol) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L6538;
	asi64(R1) = symbol;
	cc_lib_checksymbol(asi64(R1));
L6538:
	cc_lex_lex();
	return;
}

static void cc_lib_inittypetables() {
    u64 R1, R2, R3; 
	i64 i;
	i64 j;
	i64 size;
	i64 bitsize;
	i64 s;
	i64 t;
	i64 u;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	R1 = 0;
	i = asi64(R1);
	R1 = 20;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6542;
L6540:
	asi64(R1) = i;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_tables_stdtypewidths;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = i;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6545;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6544;
L6545:
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6544:
	i += 1; if (i <= av_1) goto L6540;
L6542:
	R1 = 20;
	cc_decls_ntypes = asi64(R1);
	R1 = 1;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	cc_decls_trefchar = asi64(R1);
	R1 = 7;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	cc_decls_trefwchar = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 121;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6548;
L6546:
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = (u64)&cc_tables_dominantmode;
	asi64(R3) = s;
	R2 += (i64)R3*32;
	asi64(R3) = t;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_2) goto L6546;
L6548:
	R1 = 1;
	i = asi64(R1);
	R1 = 121;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6551;
L6549:
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = (u64)&cc_tables_conversionops;
	asi64(R3) = s;
	R2 += (i64)R3*16;
	asi64(R3) = t;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_3) goto L6549;
L6551:
	return;
}

static u64 cc_lib_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	asu64(R1) = cc_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 106;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_tables_namespaces;
	asi64(R2) = id;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 98;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (!asu64(R1)) goto L6554;
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6554:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	asu64(R2) = p;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L6556;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6558;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6557;
L6558:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6557:
L6556:
	asu64(R1) = p;
	goto L6552;
L6552:
	return asu64(R1);
}

static u64 cc_lib_createnewmoduledef(u64 owner, u64 symptr) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	R1 = 3;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L6559;
L6559:
	return asu64(R1);
}

static u64 cc_lib_createnewproc(u64 owner, u64 symptr) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	R1 = 6;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	q = asu64(R1);
	goto L6562;
L6561:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L6565;
	msysc_m$print_startcon();
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Dupl proc name");
	cc_support_serror(asu64(R1));
L6565:
L6562:
	asu64(R1) = q;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (asu64(R1)) goto L6561;
	asu64(R1) = p;
	goto L6560;
L6560:
	return asu64(R1);
}

static u64 cc_lib_resolvename(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6568;
	asu64(R1) = symptr;
	goto L6566;
L6568:
	asi64(R1) = ns;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6570;
	asu64(R1) = symptr;
	asu64(R2) = owner;
	asu64(R1) = cc_lib_resolvelabel(asu64(R2), asu64(R1));
	goto L6566;
L6570:
	asi64(R1) = blockno;
	if (!asi64(R1)) goto L6572;
	R1 = (u64)&cc_decls_blockcounts;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6572;
	R1 = (u64)&cc_decls_blockowner;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	blockno = asi64(R1);
L6572:
L6573:
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	asu64(R1) = symptr;
	d = asu64(R1);
	goto L6576;
L6575:
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6579;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L6579;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6579;
	goto L6577;
L6579:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L6581;
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L6581;
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) >= asi64(R2)) goto L6583;
	asu64(R1) = d;
	R2 = 122;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
L6583:
	asu64(R1) = d;
	goto L6566;
L6581:
L6576:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L6575;
L6577:
	asi64(R1) = blockno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6585;
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6587;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6588;
	goto L6589;
L6587:
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	goto L6573;
	goto L6586;
L6588:
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6591;
	R1 = 0;
	goto L6566;
L6591:
	goto L6586;
L6589:
	R1 = 0;
	goto L6566;
L6586:
	goto L6584;
L6585:
	R1 = (u64)&cc_decls_blockowner;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	blockno = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6592;
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
L6592:
L6584:
	goto L6573;
	R1 = 0;
	goto L6566;
L6566:
	return asu64(R1);
}

static u64 cc_lib_resolvelabel(u64 owner, u64 symptr) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	goto L6595;
L6594:
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6598;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L6598;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6598;
	goto L6596;
L6598:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L6600;
	asu64(R1) = d;
	R2 = 98;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6600;
	asu64(R1) = d;
	goto L6593;
L6600:
L6595:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L6594;
L6596:
	R1 = 0;
	goto L6593;
L6593:
	return asu64(R1);
}

static u64 cc_lib_checkdupl(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	goto L6603;
L6602:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L6606;
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L6606;
	asu64(R1) = d;
	goto L6601;
L6606:
L6603:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L6602;
	R1 = 0;
	goto L6601;
L6601:
	return asu64(R1);
}

static u64 cc_lib_checkdupl_inproc(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	goto L6609;
L6608:
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L6612;
	asu64(R1) = d;
	goto L6607;
L6612:
L6609:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (!asu64(R1)) goto L6613;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L6608;
L6613:
	R1 = 0;
	goto L6607;
L6607:
	return asu64(R1);
}

static i64 cc_lib_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6616;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6617;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6617;
	goto L6618;
L6616:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	goto L6614;
	goto L6615;
L6617:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6620;
	R1 = 16;
	goto L6614;
L6620:
	asi64(R1) = a;
	goto L6614;
	goto L6615;
L6618:
L6615:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6622;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6622;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6622;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6622;
	goto L6623;
L6622:
	asi64(R1) = a;
	goto L6614;
	goto L6621;
L6623:
L6621:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = a;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("GETALIGN SIZE NOT 1248");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L6614;
L6614:
	return asi64(R1);
}

static i64 cc_lib_isexported(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6626;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6628;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6629;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6628;
L6629:
	R1 = 1;
	goto L6624;
L6628:
	goto L6625;
L6626:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6631;
	R1 = 1;
	goto L6624;
L6631:
L6625:
	R1 = 0;
	goto L6624;
L6624:
	return asi64(R1);
}

static i64 cc_lib_isimported(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6634;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6636;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6637;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6636;
L6637:
	R1 = 1;
	goto L6632;
L6636:
	goto L6633;
L6634:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6639;
	R1 = 1;
	goto L6632;
L6639:
L6633:
	R1 = 0;
	goto L6632;
L6632:
	return asi64(R1);
}

static u64 cc_lib_getstname(u64 d) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = d;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&cc_lib_getstname_name;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_lib_getstname_name;
	asu64(R3) = d;
	R4 = 106;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lib_getstname_name;
	goto L6640;
L6640:
	return asu64(R1);
}

static i64 cc_lib_isrealcc(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	R1 = 10;
	asi64(R2) = m;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L6642;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L6642;
	R1 = 1;
	goto L6643;
L6642:
	R1 = 0;
L6643:
	goto L6641;
L6641:
	return asi64(R1);
}

static i64 cc_lib_isintcc(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	R1 = 1;
	asi64(R2) = m;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L6645;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L6645;
	R1 = 1;
	goto L6646;
L6645:
	R1 = 0;
L6646:
	goto L6644;
L6644:
	return asi64(R1);
}

static void cc_lib_writegsfile(u64 filename, u64 d) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	return;
}

static void cc_lib_pause(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asi64(R1) = mnoos_os_getch();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static i64 cc_lib_getpclmode(i64 t) {
    u64 R1, R2, R3; 
	i64 u;
	R1 = (u64)&cc_tables_stdpcl;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6651;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6653;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6654;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6655;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6656;
	goto L6657;
L6653:
	R1 = 6;
	u = asi64(R1);
	goto L6652;
L6654:
	R1 = 5;
	u = asi64(R1);
	goto L6652;
L6655:
	R1 = 4;
	u = asi64(R1);
	goto L6652;
L6656:
	R1 = 3;
	u = asi64(R1);
	goto L6652;
L6657:
L6652:
L6651:
	asi64(R1) = u;
	goto L6649;
L6649:
	return asi64(R1);
}

static void cc_lib_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6660;
	msysc_m$print_startcon();
	R1 = tou64("ATL ERROR");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L6658;
L6660:
L6661:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L6664;
	goto L6662;
L6664:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L6661;
L6662:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L6658:
	return;
}

static void cc_support_stopcompiler(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	asu8(R1) = cc_cli_fwriteerrors;
	if (!asu8(R1)) goto L6667;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L6667:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void cc_support_mcerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("\nMC Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 40;
	exit(R1);
	return;
}

static void cc_support_serror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_serror_gen(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L6672;
	msysc_m$print_startcon();
	R1 = tou64("\nIn function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6671;
L6672:
	msysc_m$print_startcon();
	R1 = tou64("OUTSIDE PROC");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6671:
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	cc_support_showmacrolineno();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Syntax Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = (u64)&cc_decls_lx;
	R4 = 20;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_serror_ss(u64 mess, u64 a, u64 b) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_serror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_terror_gen(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L6677;
	msysc_m$print_startcon();
	R1 = tou64("\nIn function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6677:
	msysc_m$print_startcon();
	R1 = tou64("Type error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("on line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	cc_support_showmacrolineno();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = (u64)&cc_decls_lx;
	R4 = 20;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_terror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_terror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_terror_ss(u64 mess, u64 a, u64 b) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_gerror_gen(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	i64 lineno;
	i64 fileno;
	asu64(R1) = p;
	if (!asu64(R1)) goto L6683;
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	lineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	fileno = asi64(R1);
	goto L6682;
L6683:
	asi64(R1) = cc_decls_clineno;
	lineno = asi64(R1);
	asi64(R1) = cc_decls_cfileno;
	fileno = asi64(R1);
L6682:
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L6685;
	msysc_m$print_startcon();
	R1 = tou64("In function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6685:
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Code Gen Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = fileno;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_gerror(u64 mess, u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = mess;
	cc_support_gerror_gen(asu64(R2), asu64(R1));
	return;
}

static void cc_support_gerror_s(u64 mess, u64 s, u64 p) {
    u64 R1, R2; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	cc_support_gerror_gen(asu64(R2), asu64(R1));
	return;
}

static i64 cc_support_nextpoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6690;
	R1 = 0;
	goto L6688;
L6690:
	R1 = 1;
	a = asi64(R1);
	goto L6692;
L6691:
	R1 = 1;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
L6692:
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) < asi64(R2)) goto L6691;
	asi64(R1) = a;
	goto L6688;
L6688:
	return asi64(R1);
}

static void cc_support_loaderror(u64 mess, u64 mess2) {
    u64 R1; 
	struct $B20 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	exit(R1);
	return;
}

static i64 cc_support_loadsourcefile(u64 file, u64 shortfile) {
    u64 R1, R2, R3; 
	u64 s;
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L6697;
	R1 = tou64("");
	R2 = tou64("Too many source files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L6697:
	R1 = (u64)&cc_decls_nsourcefiles;
	(*toi64p(R1)) += 1;
	asu64(R1) = file;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = shortfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = file;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L6699;
	asu64(R1) = file;
	R2 = tou64("LSF can't load ");
	cc_support_loaderror(asu64(R2), asu64(R1));
L6699:
	asu64(R1) = s;
	R2 = (u64)&cc_decls_sourcefiletext;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	R2 = (u64)&cc_decls_sourcefilesizes;
	asi64(R3) = cc_decls_nsourcefiles;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	goto L6695;
L6695:
	return asi64(R1);
}

static u64 cc_support_splicelines(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	goto L6702;
L6701:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L6705;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6705;
	R1 = 2;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	goto L6704;
L6705:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L6706;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6706;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6706;
	R1 = 3;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	goto L6704;
L6706:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6704:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L6702:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L6701;
	asu64(R1) = u;
	goto L6700;
L6700:
	return asu64(R1);
}

static i64 cc_support_loadbuiltin(u64 shortfile, u64 hdrtext) {
    u64 R1, R2, R3; 
	u64 s;
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L6709;
	R1 = tou64("");
	R2 = tou64("Too many source files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L6709:
	R1 = (u64)&cc_decls_nsourcefiles;
	(*toi64p(R1)) += 1;
	R1 = tou64("<builtin>");
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = shortfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = hdrtext;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefiletext;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = hdrtext;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilesizes;
	asi64(R3) = cc_decls_nsourcefiles;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	goto L6707;
L6707:
	return asi64(R1);
}

static void cc_support_gs_copytostr(u64 source, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6712;
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = source;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = s;
	asu64(R3) = source;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6711;
L6712:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L6711:
	return;
}

static void cc_support_gs_additem(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6715;
	asu64(R1) = d;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = cc_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L6717;
	asi64(R1) = nextchar;
	asi64(R1) = cc_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L6717;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L6717:
L6715:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 cc_support_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L6722;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L6721;
L6722:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L6723;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L6721;
L6723:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L6720;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L6720;
L6721:
	R1 = 1;
	goto L6718;
L6720:
	R1 = 0;
	goto L6718;
L6718:
	return asi64(R1);
}

static void cc_support_showmacrolineno() {
    u64 R1; 
	asi64(R1) = cc_decls_slineno;
	if (!asi64(R1)) goto L6726;
L6726:
	return;
}

static u64 cc_headers_findheader(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	struct $B16 newname;
	u64 s;
	u64 t;
	i64 av_1;
	R1 = 92;
	asu64(R2) = name;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	if (!asu64(R1)) goto L6729;
	asu64(R1) = name;
	s = asu64(R1);
	R1 = (u64)&newname;
	t = asu64(R1);
	goto L6731;
L6730:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L6734;
	R1 = 47;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6733;
L6734:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6733:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L6731:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L6730;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&newname;
	name = asu64(R1);
L6729:
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6737;
L6735:
	R1 = (u64)&cc_headers_stdhdrnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6739;
	R1 = (u64)&cc_headers_stdhdrtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = *tou64p(R1);
	goto L6727;
L6739:
	i += 1; if (i <= av_1) goto L6735;
L6737:
	R1 = 0;
	goto L6727;
L6727:
	return asu64(R1);
}

static void cc_headers_writeheaders() {
    u64 R1, R2, R3, R4, R5; 
	u64 f;
	u64 ifile;
	i64 i;
	i64 av_1;
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6743;
L6741:
	R1 = tou64("hdr");
	R2 = (u64)&cc_headers_stdhdrnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	ifile = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Writing internal");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_headers_stdhdrnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("as");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ifile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("wb");
	asu64(R2) = ifile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = (u64)&cc_headers_stdhdrtext;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R2) = *tou64p(R2);
	asu64(R2) = strlen(asu64(R2));
	R3 = 1;
	R4 = (u64)&cc_headers_stdhdrtext;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R4) = *tou64p(R4);
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	i += 1; if (i <= av_1) goto L6741;
L6743:
	return;
}

static i64 cc_headers_isheaderfile(u64 file) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6747;
L6745:
	asu64(R1) = file;
	R2 = (u64)&cc_headers_stdhdrnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6749;
	R1 = 1;
	goto L6744;
L6749:
	i += 1; if (i <= av_1) goto L6745;
L6747:
	R1 = 0;
	goto L6744;
L6744:
	return asi64(R1);
}

static void cc_show_printcode(u64 f, u64 caption) {
    u64 R1, R2, R3, R4; 
	i64 i;
	u64 p;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L6752;
L6751:
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6755;
	goto L6756;
L6755:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6758;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_scopenames;
	asu64(R2) = p;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	R2 = 0;
	asu64(R3) = p;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6758:
	goto L6754;
L6756:
L6754:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6752:
	asu64(R1) = p;
	if (asu64(R1)) goto L6751;
	return;
}

static void cc_show_printunit(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	i64 t;
	i64 n;
	i64 lincr;
	u64 idname;
	u64 pc;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6761;
	goto L6759;
L6761:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 77;
	if (asi64(R1) < asi64(R2)) goto L6763;
	msysc_m$print_startcon();
	R1 = tou64("print unit: bad tag");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 30;
	exit(R1);
L6763:
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	if (!asu32(R1)) goto L6765;
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_show_currlineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_show_currfileno = asi64(R1);
L6765:
	R1 = 1;
	lincr = asi64(R1);
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6767;
	R1 = -1;
	lincr = asi64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("             ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6767:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = prefix;
	asi64(R3) = level;
	if (asi64(R3) < 0) asi64(R3) = -asi64(R3);
	asu64(R1) = cc_show_getprefix(asi64(R3), asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	idname = asu64(R1);
	asu64(R1) = idname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 106;
	if (asu64(R1) != asu64(R2)) goto L6769;
	R1 = (u64)&idname;
	(*tou64p(R1)) += 1;
L6769:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = idname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6771;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6771;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6772;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6772;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6772;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6773;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6774;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6775;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6776;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6777;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6778;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6779;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L6779;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L6780;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L6781;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6782;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6783;
	goto L6784;
L6771:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6786;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" {");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = d;
	R3 = 72;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("}");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6786:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = d;
	asu64(R1) = cc_show_getdottedname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6788;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Lastcall:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L6788:
	goto L6770;
L6772:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = d;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L6759;
	goto L6770;
L6773:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6770;
L6774:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6770;
L6775:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Value:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6770;
L6776:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L6790;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6792;
	goto L6793;
L6792:
// cc_show.printunit.dostring:
L6794:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 256;
	if (asi64(R1) <= asi64(R2)) goto L6796;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("(LONGSTR)");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6795;
L6796:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6795:
	goto L6789;
L6790:
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) != asi64(R2)) goto L6797;
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6799;
	goto L6793;
L6799:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("(WSTRING)");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6789;
L6797:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6800;
	asi64(R1) = t;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L6800;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6789;
L6800:
	asi64(R1) = t;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L6801;
	asi64(R1) = t;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L6801;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6789;
L6801:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L6802;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6789;
L6802:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6803;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6805;
	goto L6794;
L6805:
// cc_show.printunit.doref:
L6793:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	goto L6789;
L6803:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6806;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6808;
	goto L6794;
L6808:
	R1 = tou64("PRINTUNIT/CONST/aRRAY");
	cc_support_serror(asu64(R1));
	goto L6789;
L6806:
	msysc_m$print_startcon();
	asi64(R1) = t;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PRINTUNIT BAD CONST");
	cc_support_serror(asu64(R1));
L6789:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6810;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<STRCONST>");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6810:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6812;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<WSTRCONST>");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6812:
	goto L6770;
L6777:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&cc_tables_convnames;
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" => ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 58;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6770;
L6778:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Scale:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6770;
L6779:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Ptrscale:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6770;
L6780:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L6814;
L6813:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L6814:
	asu64(R1) = pc;
	if (asu64(R1)) goto L6813;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6770;
L6781:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Aparams:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6770;
L6782:
	goto L6770;
L6783:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Offset:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6770;
L6784:
L6770:
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L6817;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Widen from:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 56;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6817:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6819;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ALENGTH=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6819:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("2");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6821;
	R1 = tou64("3");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 32;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L6821:
L6759:
	return;
}

static void cc_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6824;
	goto L6822;
L6824:
	goto L6826;
L6825:
	asu64(R1) = prefix;
	asi64(R2) = level;
	asu64(R3) = p;
	asu64(R4) = dev;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6826:
	asu64(R1) = p;
	if (asu64(R1)) goto L6825;
L6822:
	return;
}

static u64 cc_show_getprefix(i64 level, u64 prefix, u64 p) {
    u64 R1, R2, R3; 
	struct $B20 indentstr;
	u64 modestr;
	i64 length;
	i64 av_1;
	R1 = 0;
	R2 = (u64)&indentstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = level;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L6830;
	R1 = 10;
	level = asi64(R1);
L6830:
	R1 = tou64("-----------------------");
	R2 = (u64)&indentstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	modestr = asu64(R1);
	asu64(R1) = modestr;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&indentstr;
	asi64(R2) = strlen(asu64(R2));
	if (asi64(R1) >= asi64(R2)) goto L6832;
	asi64(R1) = length;
	asu64(R2) = modestr;
	R3 = (u64)&indentstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L6831;
L6832:
	asu64(R1) = modestr;
	R2 = (u64)&indentstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6831:
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6835;
L6833:
	R1 = tou64("|---");
	R2 = (u64)&indentstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L6833;
L6835:
	asu64(R1) = cc_show_getlineinfok();
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&indentstr;
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L6837;
	R1 = tou64(" ");
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6837:
	R1 = (u64)&cc_show_getprefix_str;
	goto L6828;
L6828:
	return asu64(R1);
}

static u64 cc_show_getdottedname(u64 p) {
    u64 R1, R2; 
	struct $B16 str2;
	u64 owner;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	goto L6840;
L6839:
	R1 = (u64)&cc_show_getdottedname_str;
	R2 = (u64)&str2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
L6840:
	asu64(R1) = owner;
	if (!asu64(R1)) goto L6842;
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6839;
L6842:
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L6844;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6844:
	R1 = (u64)&cc_show_getdottedname_str;
	goto L6838;
L6838:
	return asu64(R1);
}

static u64 cc_show_getlineinfok() {
    u64 R1, R2; 
	R1 = (u64)&cc_show_getlineinfok_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = cc_show_currfileno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("z5");
	asi64(R2) = cc_show_currlineno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	R1 = (u64)&cc_show_getlineinfok_str;
	goto L6845;
L6845:
	return asu64(R1);
}

static void cc_show_printst(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = p;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6848;
	R1 = tou64("PRINTST not name");
	cc_support_mcerror(asu64(R1));
L6848:
	asi64(R1) = level;
	asu64(R2) = p;
	asu64(R3) = f;
	cc_show_printstrec(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6850;
L6849:
	asi64(R1) = level;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	asu64(R3) = f;
	cc_show_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6850:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6849;
	return;
}

static void cc_show_printstrec(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	struct $B3 v;
	u64 d;
	i64 col;
	i64 offset;
	struct $B16 str;
	i64 scope;
	u64 pm;
	i64 av_1;
	R1 = (u64)&v;
	d = asu64(R1);
	asu64(R1) = d;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6855;
L6853:
	R1 = tou64("    ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L6853;
L6855:
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L6857;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 45;
	R2 = 28;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6856;
L6857:
	R1 = 45;
	R2 = 28;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L6856:
	R1 = 46;
	R2 = 12;
	R3 = (u64)&cc_tables_namenames;
	asu64(R4) = p;
	R5 = 109;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	asi64(R1) = mlib_gs_getcol(asu64(R1));
	col = asi64(R1);
	R1 = tou64("[");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_tables_scopenames;
	asu64(R2) = p;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6859;
	R1 = tou64("@@");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6859:
	asu64(R1) = p;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6861;
	R1 = tou64("Var ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6861:
	asu64(R1) = p;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6863;
	R1 = tou64("Used ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6863:
	asu64(R1) = p;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6865;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Pm:# ");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6865:
	R1 = tou64("]");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 61;
	asi64(R2) = col;
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R3) = d;
	mlib_gs_padto(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6867;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 32;
	R2 = 18;
	R3 = (u64)&str;
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6866;
L6867:
	R1 = 32;
	R2 = 18;
	R3 = tou64("()");
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L6866:
	asu64(R1) = p;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6869;
	goto L6870;
L6869:
	R1 = tou64("Void ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6868;
L6870:
	R1 = 1;
	asu64(R2) = p;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	mlib_gs_strsp(asu64(R2), asu64(R1));
L6868:
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6872;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6873;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6873;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6874;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6875;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6876;
	goto L6877;
L6872:
	R1 = tou64("Offset:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6871;
L6873:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6879;
	R1 = tou64("=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_show_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6879:
	R1 = tou64(" Offset: ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6871;
L6874:
	R1 = tou64("Index:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6871;
L6875:
	R1 = tou64("Enum:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6871;
L6876:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6881;
	R1 = tou64("=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_show_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6881:
	R1 = tou64("STATIC********");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6871;
L6877:
L6871:
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("Lineno:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 92;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asu64(R2) = p;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6883;
	asu64(R1) = d;
	mlib_gs_line(asu64(R1));
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	goto L6885;
L6884:
	R1 = tou64("\t\tParam: ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 45;
	R2 = 10;
	asu64(R3) = pm;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	if (!asu64(R3)) goto L6888;
	asu64(R3) = pm;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	goto L6887;
L6888:
	R3 = tou64("Anon");
L6887:
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&cc_tables_pmflagnames;
	asu64(R2) = pm;
	R3 = 22;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" Mode:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" Code:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = d;
	mlib_gs_line(asu64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L6885:
	asu64(R1) = pm;
	if (asu64(R1)) goto L6884;
L6883:
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6890;
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6892;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6892;
	goto L6893;
L6892:
	R1 = tou64("*");
	R2 = -3;
	asu64(R3) = p;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L6891;
L6893:
L6891:
L6890:
	return;
}

static void cc_show_printstflat(u64 f) {
    u64 R1, R2, R3; 
	i64 i;
	u64 p;
	u64 lx;
	i64 av_1;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("GLOBAL SYMBOL TABLE:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6897;
L6895:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6899;
	asu64(R1) = p;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6901;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6901;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L6901;
	goto L6902;
L6901:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = cc_lib_getstname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asu64(R2) = p;
	R3 = 107;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = p;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L6904;
L6903:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = cc_lib_getstname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asu64(R2) = p;
	R3 = 107;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = p;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("(From");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6907;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	goto L6906;
L6907:
	R1 = tou64("-");
L6906:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(")");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6904:
	asu64(R1) = p;
	if (asu64(R1)) goto L6903;
	goto L6900;
L6902:
L6900:
L6899:
	i += 1; if (i <= av_1) goto L6895;
L6897:
	return;
}

static u64 cc_show_strexpr(u64 p) {
    u64 R1, R2; 
	asu64(R1) = cc_show_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = cc_show_exprstr;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = cc_show_exprstr;
	goto L6908;
L6908:
	return asu64(R1);
}

static void cc_show_jeval(u64 dest, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B83 str;
	i64 lb;
	i64 t;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6911;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6912;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6913;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6914;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L6915;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6915;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6915;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6915;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6915;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L6916;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6917;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L6918;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6919;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L6919;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6920;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L6921;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6922;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6923;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6924;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L6925;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L6926;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L6927;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L6928;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6929;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6930;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6931;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6932;
	goto L6933;
L6911:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L6935;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6937;
	goto L6938;
L6937:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6940;
	goto L6938;
L6940:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8000;
	if (asi64(R1) <= asi64(R2)) goto L6942;
	R1 = tou64("LONGSTR)");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6941;
L6942:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
L6941:
	R1 = tou64("\"");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6909;
	goto L6934;
L6935:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6943;
	asi64(R1) = t;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L6943;
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L6934;
L6943:
	asi64(R1) = t;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L6944;
	asi64(R1) = t;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L6944;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6934;
L6944:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6946;
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6945;
L6946:
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6934;
L6945:
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6948;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6949;
	goto L6950;
L6948:
// cc_show.jeval.doref:
L6938:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	goto L6947;
L6949:
	R1 = tou64("ARRAY");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6947;
L6950:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("EVAL/C");
	mlib_abortprogram(asu64(R1));
L6947:
L6934:
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6912:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6913:
	R1 = tou64("&");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6914:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_getopcjname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6915:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_getopcjname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6916:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6952;
L6951:
	asu64(R1) = q;
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L6955;
	R1 = tou64(",");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
L6955:
L6952:
	asu64(R1) = q;
	if (asu64(R1)) goto L6951;
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6917:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("???");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6910;
L6918:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("->");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L6910;
L6919:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 29;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	lb = asi64(R1);
	asi64(R1) = lb;
	if (!asi64(R1)) goto L6957;
	R1 = tou64("(");
	goto L6956;
L6957:
	R1 = tou64("{");
L6956:
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6959;
L6958:
	asu64(R1) = q;
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L6962;
	R1 = tou64(",");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
L6962:
L6959:
	asu64(R1) = q;
	if (asu64(R1)) goto L6958;
	asi64(R1) = lb;
	if (!asi64(R1)) goto L6964;
	R1 = tou64(")");
	goto L6963;
L6964:
	R1 = tou64("}");
L6963:
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6920:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("=");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L6910;
L6921:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("?");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(":");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L6910;
L6922:
	R1 = 1;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6923:
	R1 = tou64("*(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6966;
	R1 = tou64("+");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
L6966:
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6924:
	R1 = tou64("<JBLOCK>");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6925:
	R1 = tou64("++");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L6910;
L6926:
	R1 = tou64("--");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L6910;
L6927:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("++");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6928:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("--");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L6910;
L6929:
	R1 = tou64("<nullunit>");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6910;
L6930:
	R1 = tou64("scale((");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6968;
	R1 = tou64(")*");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6967;
L6968:
	R1 = tou64(")/");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R2) = dest;
	mlib_gs_strint(asu64(R2), asi64(R1));
L6967:
	R1 = tou64(")");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6910;
L6931:
	R1 = tou64("(");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("+");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6910;
L6932:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L6910;
L6933:
	R1 = tou64("<CAN'T DO JEVAL>");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L6910:
L6909:
	return;
}

static void cc_show_printfilelist(u64 f) {
    u64 R1, R2, R3; 
	i64 i;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Source files");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6972;
L6970:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# # (#)");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("12jl");
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nsourcefiles) goto L6970;
L6972:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\nInput file:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\nLibfiles");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nlibfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6975;
L6973:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nlibfiles) goto L6973;
L6975:
	return;
}

static void cc_show_printmodelist(u64 f) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mbase;
	u64 d;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC MODELIST");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	m = asi64(R1);
	asi64(R1) = cc_decls_ntypes;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6979;
L6977:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("4");
	asi64(R2) = m;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	R1 = (u64)&cc_decls_tttypedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6981;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Typedef:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_tttypedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6981:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Basetype:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mbase;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = 1;
	asi64(R2) = mbase;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Name:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("ttnamedef:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	if (!asu64(R1)) goto L6983;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6982;
L6983:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6982:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Target:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Length:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isblock:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Const:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Signed:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttsigned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Ref:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Constver:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Shared:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttshared;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	m += 1; if (m <= cc_decls_ntypes) goto L6977;
L6979:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void pepcl_start() {
	mc_decls_start();
	mc_writegas_start();
	return;
}

static struct $B76 $procaddr = {{
(u64)&mc_genmcl_px_nop,
(u64)&mc_genmcl_px_dupl,
(u64)&mc_genmcl_px_double,
(u64)&mc_genmcl_px_opnd,
(u64)&mc_genmcl_px_type,
(u64)&mc_genmcl_px_comment,
(u64)&mc_genmcl_px_proc,
(u64)&mc_genmcl_px_endproc,
(u64)&mc_genmcl_px_endprog,
(u64)&mc_genmcl_px_istatic,
(u64)&mc_genmcl_px_zstatic,
(u64)&mc_genmcl_px_data,
(u64)&mc_genmcl_px_label,
(u64)&mc_genmcl_px_load,
(u64)&mc_genmcl_px_store,
(u64)&mc_genmcl_px_add,
(u64)&mc_genmcl_px_sub,
(u64)&mc_genmcl_px_mul,
(u64)&mc_genmcl_px_div,
(u64)&mc_genmcl_px_eval,
(u64)&mc_genmcl_px_widen,
(u64)&mc_genmcl_px_jump,
(u64)&mc_genmcl_px_ijump,
(u64)&mc_genmcl_px_neg,
(u64)&mc_genmcl_px_abs,
(u64)&mc_genmcl_px_bitnot,
(u64)&mc_genmcl_px_not,
(u64)&mc_genmcl_px_toboolt,
(u64)&mc_genmcl_px_sqr,
(u64)&mc_genmcl_px_sqrt,
(u64)&mc_genmcl_px_jumpcc,
(u64)&mc_genmcl_px_jumpt,
(u64)&mc_genmcl_px_jumpf,
(u64)&mc_genmcl_px_bitand,
(u64)&mc_genmcl_px_bitor,
(u64)&mc_genmcl_px_bitxor,
(u64)&mc_genmcl_px_shl,
(u64)&mc_genmcl_px_shr,
(u64)&mc_genmcl_px_retproc,
(u64)&mc_genmcl_px_retfn,
(u64)&mc_genmcl_px_setcall,
(u64)&mc_genmcl_px_setarg,
(u64)&mc_genmcl_px_callp,
(u64)&mc_genmcl_px_jumpret,
(u64)&mc_genmcl_px_jumpretm,
(u64)&mc_genmcl_px_startmx,
(u64)&mc_genmcl_px_resetmx,
(u64)&mc_genmcl_px_stop,
(u64)&mc_genmcl_px_incrto,
(u64)&mc_genmcl_px_decrto,
(u64)&mc_genmcl_px_incrload,
(u64)&mc_genmcl_px_decrload,
(u64)&mc_genmcl_px_loadincr,
(u64)&mc_genmcl_px_loaddecr,
(u64)&mc_genmcl_px_forup,
(u64)&mc_genmcl_px_fordown,
(u64)&mc_genmcl_px_iload,
(u64)&mc_genmcl_px_iloadx,
(u64)&mc_genmcl_px_istore,
(u64)&mc_genmcl_px_istorex,
(u64)&mc_genmcl_px_storem,
(u64)&mc_genmcl_px_addpx,
(u64)&mc_genmcl_px_subpx,
(u64)&mc_genmcl_px_to,
(u64)&mc_genmcl_px_iswap,
(u64)&mc_genmcl_px_swapstk,
(u64)&mc_genmcl_px_labeldef,
(u64)&mc_genmcl_px_addto,
(u64)&mc_genmcl_px_subto,
(u64)&mc_genmcl_px_multo,
(u64)&mc_genmcl_px_bitandto,
(u64)&mc_genmcl_px_bitorto,
(u64)&mc_genmcl_px_bitxorto,
(u64)&mc_genmcl_px_shlto,
(u64)&mc_genmcl_px_shrto,
(u64)&mc_genmcl_px_fix,
(u64)&mc_genmcl_px_float,
(u64)&mc_genmcl_px_idiv,
(u64)&mc_genmcl_px_irem,
(u64)&mc_genmcl_px_idivrem,
(u64)&mc_genmcl_px_clear,
(u64)&mc_genmcl_px_subp,
(u64)&mc_genmcl_px_switch,
(u64)&mc_genmcl_px_switchu,
(u64)&mc_genmcl_px_swlabel,
(u64)&mc_genmcl_px_endsw,
(u64)&mc_genmcl_px_fwiden,
(u64)&mc_genmcl_px_fnarrow,
(u64)&mc_genmcl_px_truncate,
(u64)&mc_genmcl_px_typepun,
(u64)&mc_genmcl_px_unload,
(u64)&mc_genmcl_px_loadbit,
(u64)&mc_genmcl_px_assem,
(u64)&mc_genmcl_px_sin,
(u64)&mc_genmcl_px_cos,
(u64)&mc_genmcl_px_tan,
(u64)&mc_genmcl_px_asin,
(u64)&mc_genmcl_px_acos,
(u64)&mc_genmcl_px_atan,
(u64)&mc_genmcl_px_log,
(u64)&mc_genmcl_px_log10,
(u64)&mc_genmcl_px_exp,
(u64)&mc_genmcl_px_round,
(u64)&mc_genmcl_px_floor,
(u64)&mc_genmcl_px_ceil,
(u64)&mc_genmcl_px_atan2,
(u64)&mc_genmcl_px_fmod,
(u64)&mc_genmcl_px_setcc,
(u64)&mc_genmcl_px_min,
(u64)&mc_genmcl_px_max,
(u64)&mc_genmcl_px_power,
(u64)&mc_genmcl_px_minto,
(u64)&mc_genmcl_px_maxto,
(u64)&mc_genmcl_px_negto,
(u64)&mc_genmcl_px_absto,
(u64)&mc_genmcl_px_addpxto,
(u64)&mc_genmcl_px_subpxto,
(u64)&mc_genmcl_px_divto,
(u64)&mc_genmcl_px_bitnotto,
(u64)&mc_genmcl_px_notto,
(u64)&mc_genmcl_px_toboolto,
(u64)&mc_genmcl_px_sign,
(u64)&mc_genmcl_px_loadbf,
(u64)&mc_genmcl_px_storebit,
(u64)&mc_genmcl_px_storebf,
(u64)&mc_genmcl_px_loadall,
(u64)&mc_genmcl_px_setjmp,
(u64)&mc_genmcl_px_longjmp,
(u64)&mc_genmcl_px_initdswx,
(u64)&mc_auxmcl_do_addrmode}};

static struct $B76 $procname = {{
(u64)"px_nop",
(u64)"px_dupl",
(u64)"px_double",
(u64)"px_opnd",
(u64)"px_type",
(u64)"px_comment",
(u64)"px_proc",
(u64)"px_endproc",
(u64)"px_endprog",
(u64)"px_istatic",
(u64)"px_zstatic",
(u64)"px_data",
(u64)"px_label",
(u64)"px_load",
(u64)"px_store",
(u64)"px_add",
(u64)"px_sub",
(u64)"px_mul",
(u64)"px_div",
(u64)"px_eval",
(u64)"px_widen",
(u64)"px_jump",
(u64)"px_ijump",
(u64)"px_neg",
(u64)"px_abs",
(u64)"px_bitnot",
(u64)"px_not",
(u64)"px_toboolt",
(u64)"px_sqr",
(u64)"px_sqrt",
(u64)"px_jumpcc",
(u64)"px_jumpt",
(u64)"px_jumpf",
(u64)"px_bitand",
(u64)"px_bitor",
(u64)"px_bitxor",
(u64)"px_shl",
(u64)"px_shr",
(u64)"px_retproc",
(u64)"px_retfn",
(u64)"px_setcall",
(u64)"px_setarg",
(u64)"px_callp",
(u64)"px_jumpret",
(u64)"px_jumpretm",
(u64)"px_startmx",
(u64)"px_resetmx",
(u64)"px_stop",
(u64)"px_incrto",
(u64)"px_decrto",
(u64)"px_incrload",
(u64)"px_decrload",
(u64)"px_loadincr",
(u64)"px_loaddecr",
(u64)"px_forup",
(u64)"px_fordown",
(u64)"px_iload",
(u64)"px_iloadx",
(u64)"px_istore",
(u64)"px_istorex",
(u64)"px_storem",
(u64)"px_addpx",
(u64)"px_subpx",
(u64)"px_to",
(u64)"px_iswap",
(u64)"px_swapstk",
(u64)"px_labeldef",
(u64)"px_addto",
(u64)"px_subto",
(u64)"px_multo",
(u64)"px_bitandto",
(u64)"px_bitorto",
(u64)"px_bitxorto",
(u64)"px_shlto",
(u64)"px_shrto",
(u64)"px_fix",
(u64)"px_float",
(u64)"px_idiv",
(u64)"px_irem",
(u64)"px_idivrem",
(u64)"px_clear",
(u64)"px_subp",
(u64)"px_switch",
(u64)"px_switchu",
(u64)"px_swlabel",
(u64)"px_endsw",
(u64)"px_fwiden",
(u64)"px_fnarrow",
(u64)"px_truncate",
(u64)"px_typepun",
(u64)"px_unload",
(u64)"px_loadbit",
(u64)"px_assem",
(u64)"px_sin",
(u64)"px_cos",
(u64)"px_tan",
(u64)"px_asin",
(u64)"px_acos",
(u64)"px_atan",
(u64)"px_log",
(u64)"px_log10",
(u64)"px_exp",
(u64)"px_round",
(u64)"px_floor",
(u64)"px_ceil",
(u64)"px_atan2",
(u64)"px_fmod",
(u64)"px_setcc",
(u64)"px_min",
(u64)"px_max",
(u64)"px_power",
(u64)"px_minto",
(u64)"px_maxto",
(u64)"px_negto",
(u64)"px_absto",
(u64)"px_addpxto",
(u64)"px_subpxto",
(u64)"px_divto",
(u64)"px_bitnotto",
(u64)"px_notto",
(u64)"px_toboolto",
(u64)"px_sign",
(u64)"px_loadbf",
(u64)"px_storebit",
(u64)"px_storebf",
(u64)"px_loadall",
(u64)"px_setjmp",
(u64)"px_longjmp",
(u64)"px_initdswx",
(u64)"do_addrmode"}};

static i64 $nprocs = 130;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

