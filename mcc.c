/*
 This generated C code is placed in the public domain

 Recommended build instructions, when file is called prog.c:

   gcc -O2 -s prog.c -o prog -lm -ldl -fno-strict-aliasing

   -lm/-ldl are needed for Linux
   -O2 is recommended due to low quality C code

*/

#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void cc_cli_main();
void (*entrypoint)(void) = cc_cli_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u64 a[4];};   // mem:32;
struct $B18 {u64 a[50];};   // mem:400;
struct $B19 {u64 a[143];};   // mem:1144;
struct $B20 {u64 a[64];};   // mem:512;
struct $B21 {u64 a[14];};   // mem:112;
struct $B22 {u16 a[7];};   // mem:14;
struct $B23 {u8 a[143];};   // mem:143;
struct $B24 {u64 a[7];};   // mem:56;
struct $B25 {u16 a[3];};   // mem:6;
struct $B26 {u16 a[9];};   // mem:18;
struct $B27 {u16 a[1];};   // mem:2;
struct $B28 {u64 a[12];};   // mem:96;
struct $B29 {u64 a[20];};   // mem:160;
struct $B30 {u64 a[152];};   // mem:1216;
struct $B31 {u64 a[19];};   // mem:152;
struct $B32 {u64 a[21];};   // mem:168;
struct $B33 {u8 a[21];};   // mem:21;
struct $B34 {u64 a[137];};   // mem:1096;
struct $B35 {u8 a[137];};   // mem:137;
struct $B36 {u64 a[16];};   // mem:128;
struct $B37 {u64 a[8];};   // mem:64;
struct $B38 {u64 a[18];};   // mem:144;
struct $B39 {u16 a[25];};   // mem:50;
struct $B40 {u64 a[17];};   // mem:136;
struct $B41 {u64 a[256];};   // mem:2048;
struct $B42 {u64 a[128];};   // mem:1024;
struct $B43 {u64 a[193];};   // mem:1544;
struct $B44 {u64 a[1];};   // mem:8;
struct $B45 {u64 a[13];};   // mem:104;
struct $B46 {u32 a[5];};   // mem:20;
struct $B47 {u64 a[53];};   // mem:424;
struct $B48 {u8 a[53];};   // mem:53;
struct $B49 {u64 a[80000];};   // mem:640000;
struct $B50 {u64 a[20000];};   // mem:160000;
struct $B51 {u64 a[10000];};   // mem:80000;
struct $B52 {u64 a[40000];};   // mem:320000;
struct $B53 {u64 a[201];};   // mem:1608;
struct $B54 {u32 a[201];};   // mem:804;
struct $B55 {u32 a[2101];};   // mem:8404;
struct $B56 {u32 a[101];};   // mem:404;
struct $B57 {u64 a[199];};   // mem:1592;
struct $B58 {u64 a[100];};   // mem:800;
struct $B59 {u64 a[22];};   // mem:176;
struct $B60 {u16 a[11];};   // mem:22;
struct $B61 {u64 a[5];};   // mem:40;
struct $B62 {u64 a[15];};   // mem:120;
struct $B63 {u32 a[15];};   // mem:60;
struct $B64 {u8 a[15];};   // mem:15;
struct $B65 {u64 a[78];};   // mem:624;
struct $B66 {u64 a[97];};   // mem:776;
struct $B67 {u8 a[97];};   // mem:97;
struct $B68 {u8 a[363];};   // mem:363;
struct $B69 {u8 a[3];};   // mem:3;
struct $B70 {u64 a[34];};   // mem:272;
struct $B71 {u64 a[60];};   // mem:480;
struct $B72 {u64 a[87000];};   // mem:696000;
struct $B73 {u64 a[200];};   // mem:1600;
struct $B74 {u32 a[39];};   // mem:156;
struct $B75 {u64 a[2048];};   // mem:16384;
struct $B76 {u64 a[130];};   // mem:1040;
struct $B77 {u64 a[45];};   // mem:360;
struct $B78 {u64 a[320];};   // mem:2560;
struct $B79 {u64 a[157];};   // mem:1256;
struct $B80 {u32 a[125];};   // mem:500;
struct $B81 {u64 a[250];};   // mem:2000;
struct $B82 {u64 a[2000];};   // mem:16000;

// Function Ptr Types:
typedef i64 (*F1)();
typedef i64 (*F2)(i64);
typedef i64 (*F3)(i64, i64);
typedef i64 (*F4)(i64, i64, i64);
typedef i64 (*F5)(i64, i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F13)();
typedef r64 (*F14)(i64);
typedef r64 (*F15)(i64, i64);
typedef i64 (*F16)(i64, u64, u64);
typedef i64 (*F17)(u64);
typedef void (*F18)(u64);
typedef u64 (*F19)(i64);

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u8 pepcl_pc_userunpcl;
static u8 pepcl_asmonly;
static u8 pepcl_pdcc;
static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc;
static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B17 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest;
static struct $B18 pc_decls_plibfiles;
static struct $B18 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype;
static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole;
static u8 pc_decls_fregoptim;
static u8 pc_decls_fnoconst;
static u8 pc_decls_fshowil;
static u8 pc_decls_flong64;
static i64 pc_decls_pcltime;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B19 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_decls_npcl;
static i64 pc_decls_npst;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest;
static i64 pc_diags_destlinestart;
static struct $B20 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static u64 pc_diags_psopnd_longstring;
static struct $B21 pc_tables_pstdnames;
static struct $B22 pc_tables_psize;
static struct $B22 pc_tables_psigned;
static struct $B22 pc_tables_pint;
static struct $B22 pc_tables_pfloat;
static struct $B22 pc_tables_pmin;
static struct $B22 pc_tables_xxpiwrb;
static struct $B21 pc_tables_opndnames;
static struct $B19 pc_tables_pclnames;
static struct $B23 pc_tables_pclhastype;
static struct $B23 pc_tables_pclextra;
static struct $B23 pc_tables_pclhasopnd;
static struct $B23 pc_tables_pclargs;
static struct $B24 pc_tables_ccnames;
static struct $B1 pc_tables_idnames;
static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B19 mc_genmcl_px_handlertable;
static struct $B25 mc_genmcl_scondcodes;
static struct $B25 mc_genmcl_ucondcodes;
static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B28 mc_libmcl_smallinttable;
static struct $B29 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B29 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B20 mc_stackmcl_stropndstack_str;
static i64 mc_genss_dummy_psstime;
static struct $B11 mc_decls_valtypenames;
static struct $B30 mc_decls_mclnames;
static struct $B31 mc_decls_mclnopnds;
static struct $B31 mc_decls_mclcodes;
static struct $B32 mc_decls_regnames;
static struct $B33 mc_decls_regcodes;
static struct $B29 mc_decls_condnames;
static struct $B29 mc_decls_asmcondnames;
static struct $B29 mc_decls_asmrevcond;
static struct $B34 mc_decls_dregnames;
static struct $B35 mc_decls_regsizes;
static struct $B35 mc_decls_regindices;
static struct $B36 mc_decls_xmmregnames;
static struct $B37 mc_decls_fregnames;
static struct $B37 mc_decls_mregnames;
static struct $B38 mc_decls_jmpccnames;
static struct $B26 mc_decls_jmpcccodes;
static struct $B36 mc_decls_setccnames;
static struct $B3 mc_decls_setcccodes;
static struct $B36 mc_decls_cmovccnames;
static struct $B3 mc_decls_cmovcccodes;
static struct $B12 mc_decls_segmentnames;
static struct $B8 mc_decls_reftypenames;
static struct $B12 mc_decls_opndnames_ma;
static struct $B18 mc_decls_pclopnd;
static struct $B39 mc_decls_pclreg;
static struct $B39 mc_decls_pclmode;
static struct $B39 mc_decls_pclcount;
static struct $B39 mc_decls_pclloc;
static struct $B39 mc_decls_pcltempflags;
static struct $B18 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B17 mc_decls_locnames;
static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames;
static struct $B3 mc_decls_callalign;
static struct $B3 mc_decls_callblockret;
static struct $B37 mc_decls_callblocksize;
static struct $B20 mc_decls_callargmode;
static struct $B41 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used;
static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment;
static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B42 mc_decls_regtable;
static struct $B43 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes;
static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B18 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs;
static struct $B12 mc_decls_multxregs;
static struct $B22 mc_decls_ploadopx;
static struct $B22 mc_decls_ploadop;
static struct $B24 mc_objdecls_relocnames;
static u64 mc_writegas_asmext;
static struct $B42 mc_writegas_nregnames;
static u8 mc_writegas_currseg;
static struct $B20 mc_writegas_strmcl_str;
static struct $B20 mc_writegas_mstropnd_str;
static struct $B20 mc_writegas_strvalue_str;
static struct $B17 mc_writegas_getxregname_str;
static struct $B16 mc_writegas_getdispname_str;
static struct $B36 mc_writegas_gettempname_str;
static struct $B3 mc_writegas_strreg_str;
static struct $B45 cc_cli_passnames;
static struct $B45 cc_cli_extnames;
static u8 cc_cli_cc_pass;
static struct $B46 cc_cli_dummy;
static u8 cc_cli_debugmode;
static u64 cc_cli_outfile;
static u64 cc_cli_outext;
static i64 cc_cli_cmdskip;
static i64 cc_cli_ttt;
static u8 cc_cli_fverbose;
static u8 cc_cli_fshowincludes;
static u8 cc_cli_dointheaders;
static u8 cc_cli_highmem;
static u8 cc_cli_fshowst;
static u8 cc_cli_fshowstflat;
static u8 cc_cli_fshowast;
static u8 cc_cli_fshowpcl;
static u8 cc_cli_fshowpst;
static u8 cc_cli_fshowmcl;
static u8 cc_cli_fshowss;
static u8 cc_cli_fshowtypes;
static u8 cc_cli_fshowfiles;
static u8 cc_cli_fshowpaths;
static u8 cc_cli_fshowheaders;
static u8 cc_cli_fwriteheaders;
static u8 cc_cli_fshowlog;
static u8 cc_cli_fshowtiming;
static u8 cc_cli_fgendll;
static u8 cc_cli_fstdout;
static u8 cc_cli_fshortnames;
static u8 cc_cli_fwriteerrors;
static u64 cc_cli_entrypointname;
static struct $B47 cc_cli_optionnames;
static struct $B47 cc_cli_optvars;
static struct $B48 cc_cli_optvalues;
static i64 cc_cli_totallines;
static i64 cc_cli_nstringobjects;
static i64 cc_cli_startclock;
static i64 cc_cli_loadtime;
static i64 cc_cli_parsetime;
static i64 cc_cli_pcltime;
static i64 cc_cli_compiletime;
static i64 cc_cli_inittime;
static i64 cc_decls_ntypes;
static struct $B49 cc_decls_ttnamedef;
static struct $B50 cc_decls_ttbasetype;
static struct $B49 cc_decls_ttlength;
static struct $B51 cc_decls_ttconst;
static struct $B50 cc_decls_tttarget;
static struct $B50 cc_decls_ttreftype;
static struct $B50 cc_decls_ttconsttype;
static struct $B49 cc_decls_ttsize;
static struct $B51 cc_decls_ttisref;
static struct $B51 cc_decls_ttisblock;
static struct $B51 cc_decls_ttsigned;
static struct $B52 cc_decls_ttshared;
static struct $B49 cc_decls_ttparams;
static struct $B49 cc_decls_tttypedef;
static i64 cc_decls_trefchar;
static i64 cc_decls_trefwchar;
static u64 cc_decls_inputfile;
static i64 cc_decls_mainfileno;
static struct $B53 cc_decls_libfiles;
static struct $B53 cc_decls_sourcefilenames;
static struct $B53 cc_decls_sourcefilepaths;
static struct $B53 cc_decls_sourcefiletext;
static struct $B54 cc_decls_sourcefilesizes;
static i64 cc_decls_nsourcefiles;
static i64 cc_decls_nlibfiles;
static struct $B29 cc_decls_searchdirs;
static i64 cc_decls_nsearchdirs;
static struct $B29 cc_decls_includepaths;
static i64 cc_decls_nincludepaths;
static u64 cc_decls_stprogram;
static u64 cc_decls_stmodule;
static u64 cc_decls_logdev;
static u64 cc_decls_nullunit;
static i64 cc_decls_clineno;
static i64 cc_decls_cfileno;
static struct $B17 cc_decls_lx;
static struct $B17 cc_decls_nextlx;
static i64 cc_decls_debug;
static i64 cc_decls_hstsize;
static i64 cc_decls_hstmask;
static u64 cc_decls_hashtable;
static struct $B55 cc_decls_blockowner;
static struct $B55 cc_decls_blockcounts;
static struct $B56 cc_decls_blockstack;
static i64 cc_decls_currblockno;
static i64 cc_decls_nextblockno;
static i64 cc_decls_blocklevel;
static u64 cc_decls_currproc;
static u64 cc_decls_dheaderfile;
static i64 cc_decls_structpadding;
static i64 cc_decls_callbackflag;
static i64 cc_decls_slineno;
static i64 cc_decls_sfileno;
static u64 cc_decls_oemname;
static u64 cc_decls_mclstr;
static i64 cc_decls_mclstrlen;
static i64 cc_decls_nunits;
static struct $B57 cc_decls_pmodulelist;
static struct $B58 cc_decls_pheaderlist;
static struct $B58 cc_decls_pliblist;
static i64 cc_decls_npmodules;
static i64 cc_decls_npheaders;
static i64 cc_decls_nplibs;
static u8 cc_decls_pci_target;
static struct $B59 cc_tables_stdtypenames;
static struct $B60 cc_tables_stdtypewidths;
static struct $B60 cc_tables_stdsigned;
static struct $B60 cc_tables_stdpcl;
static struct $B60 cc_tables_stdsize;
static struct $B61 cc_tables_catnames;
static struct $B62 cc_tables_typespecnames;
static struct $B63 cc_tables_typespectypes;
static struct $B64 cc_tables_typespecsizes;
static struct $B17 cc_tables_pmflagnames;
static struct $B61 cc_tables_scopenames;
static struct $B12 cc_tables_cccnames;
static struct $B12 cc_tables_linkagenames;
static struct $B17 cc_tables_typequalnames;
static struct $B8 cc_tables_fnspecnames;
static struct $B65 cc_tables_jtagnames;
static struct $B66 cc_tables_symbolnames;
static struct $B66 cc_tables_shortsymbolnames;
static struct $B67 cc_tables_symboltojtag;
static struct $B62 cc_tables_sourcedirnames;
static struct $B61 cc_tables_namespacenames;
static struct $B62 cc_tables_namenames;
static struct $B63 cc_tables_namespaces;
static struct $B64 cc_tables_name2pid;
static struct $B20 cc_tables_stnames;
static struct $B16 cc_tables_stsymbols;
static struct $B16 cc_tables_stsubcodes;
static struct $B21 cc_tables_convnames;
static struct $B42 cc_tables_dominantmode;
static struct $B16 cc_tables_conversionops;
static struct $B68 cc_tables_dominantsetuptable;
static struct $B68 cc_tables_convsetuptable;
static struct $B70 cc_tables_badexprs;
static u64 cc_lex_tkptr;
static i64 cc_lex_dowhitespace;
static i64 cc_lex_nincludes;
static struct $B17 cc_lex_normaltkx;
static u64 cc_lex_normaltk;
static i64 cc_lex_noexpand;
static struct $B71 cc_lex_lx_stack;
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel;
static struct $B29 cc_lex_headerpathlist;
static struct $B15 cc_lex_headerpath;
static u64 cc_lex_lxstart;
static u64 cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static u64 cc_lex_lxsvalue;
static struct $B16 cc_lex_alphamap;
static struct $B16 cc_lex_digitmap;
static struct $B16 cc_lex_commentmap;
static struct $B16 cc_lex_linecommentmap;
static struct $B16 cc_lex_spacemap;
static u64 cc_lex_destcopy;
static struct $B72 cc_lex_pastedtokenlist;
static i64 cc_lex_npastedtokens;
static i64 cc_lex_isincludefile;
static i64 cc_lex_firstsymbol;
static u64 cc_lex_reallxsptr;
static i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static struct $B3 cc_lex_lex_preprocess_only_sbuffer;
static struct $B15 cc_lex_getsourcefile_filespec;
static i64 cc_lex_lasttoken;
static struct $B3 cc_lex_showtoken_buffer;
static struct $B3 cc_lex_stringify_buffer;
static u64 cc_parse_ist_symptr;
static struct $B37 cc_parse_looptypestack;
static i64 cc_parse_loopindex;
static struct $B20 cc_parse_casevaluestack;
static u8 cc_parse_ingeneric;
static i64 cc_genpcl_retindex;
static i64 cc_genpcl_initstaticsindex;
static struct $B73 cc_genpcl_loopstack;
static i64 cc_genpcl_loopindex;
static struct $B37 cc_genpcl_zero_unit;
static u64 cc_genpcl_pzero;
static i64 cc_genpcl_nvarlocals;
static i64 cc_genpcl_nvarparams;
static struct $B20 cc_blockpcl_continuestack;
static struct $B20 cc_blockpcl_breakstack;
static i64 cc_blockpcl_loopindex;
static u64 cc_blockpcl_sw_labeltable;
static u64 cc_blockpcl_sw_valuetable;
static i64 cc_blockpcl_sw_lower;
static i64 cc_blockpcl_sw_ncases;
static u8 cc_blockpcl_sw_defaultseen;
static i64 cc_blockpcl_sw_defaultlabel;
static i64 cc_blockpcl_sw_breaklabel;
static i64 cc_lib_autotypeno;
static i64 cc_lib_nextafindex;
static u64 cc_lib_unitheapptr;
static i64 cc_lib_remainingunits;
static struct $B74 cc_lib_getoptocode_opctotable;
static struct $B17 cc_lib_nextautotype_str;
static struct $B46 cc_lib_getopcjname_str;
static struct $B75 cc_lib_strmode_str;
static struct $B75 cc_lib_strmode2_str;
static struct $B15 cc_lib_typename_str;
static struct $B16 cc_lib_getstname_name;
static u64 cc_support_bytemasks;
static i64 cc_headers_builtinheaders;
static u64 cc_headers_h_assert;
static u64 cc_headers_h_ctype;
static u64 cc_headers_h_errno;
static u64 cc_headers_h_fenv;
static u64 cc_headers_h_float;
static u64 cc_headers_h_inttypes;
static u64 cc_headers_h_stdint;
static u64 cc_headers_h_limits;
static u64 cc_headers_h_locale;
static u64 cc_headers_h__ansi;
static u64 cc_headers_h_math;
static u64 cc_headers_h_setjmp;
static u64 cc_headers_h_signal;
static u64 cc_headers_h_stdarg;
static u64 cc_headers_h_stdbool;
static u64 cc_headers_h_stddef;
static u64 cc_headers_h_stdio;
static u64 cc_headers_h_stdlib;
static u64 cc_headers_h__syslist;
static u64 cc_headers_h_string;
static u64 cc_headers_h_time;
static u64 cc_headers_h_utime;
static u64 cc_headers_h_unistd;
static u64 cc_headers_h_safelib;
static u64 cc_headers_h_wchar;
static u64 cc_headers_h_wctype;
static u64 cc_headers_h_systypes;
static u64 cc_headers_h_sysstat;
static u64 cc_headers_h_systimeb;
static u64 cc_headers_h_sysutime;
static u64 cc_headers_h_memory;
static u64 cc_headers_h_fcntl;
static u64 cc_headers_h_io;
static u64 cc_headers_h_direct;
static u64 cc_headers_h_process;
static u64 cc_headers_h_malloc;
static u64 cc_headers_h_conio;
static u64 cc_headers_h_winsock2;
static u64 cc_headers_h__mingw;
static u64 cc_headers_h_windowsx;
static struct $B6 cc_headers_stdhdrnames;
static struct $B6 cc_headers_stdhdrtext;
static i64 cc_show_currfileno;
static i64 cc_show_currlineno;
static struct $B3 cc_show_sbuffer;
static u64 cc_show_dest;
static i64 cc_show_destlinestart;
static struct $B3 cc_show_exprstrvar;
static u64 cc_show_exprstr;
static struct $B20 cc_show_getprefix_str;
static struct $B16 cc_show_getdottedname_str;
static struct $B61 cc_show_getlineinfok_str;
static i64 $nprocs;
static struct $B76 $procname;
static struct $B76 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sqrt(r64 $1);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static u64 pc_api_strpmode(i64 mode, i64 size);
static u64 pc_api_getfullname(u64 d, i64 backtick);
static u64 pc_api_addstr(u64 s, u64 t);
static u64 pc_diags_stropnd(u64 p);
static void pc_diags_psopnd(u64 p);
static void mc_genmcl_inithandlers();
static u64 mc_libmcl_mgenextname(u64 s);
static u64 mc_stackmcl_stropndstack(i64 indent);
static void mc_writegas_strmcl(u64 mcl);
static u64 mc_writegas_mstropnd(u64 a, i64 sizeprefix, i64 opcode);
static u64 mc_writegas_strvalue(u64 a);
static u64 mc_writegas_getxregname(i64 reg, i64 size);
static u64 mc_writegas_getdispname(u64 d);
static u64 mc_writegas_gettempname(u64 d, i64 n);
static u64 mc_writegas_strreg(i64 reg, i64 size);
static void cc_cli_showextrainfo();
static void cc_lex_lex_preprocess_only(u64 infile, u64 outfile, i64 toconsole);
static i64 cc_lex_getsourcefile(u64 file, i64 syshdr);
static void cc_lex_lexm();
static void cc_lex_showtoken(u64 lp);
static void cc_lex_stringify(u64 seq, u64 dest);
static void cc_lex_expandpredefmacro(i64 pdmcode, u64 tk, i64 lineno);
static i64 cc_lex_issimpleconstmacro(u64 m);
static i64 cc_lib_getoptocode(i64 opc);
static u64 cc_lib_nextautotype();
static u64 cc_lib_getopcjname(i64 opc);
static u64 cc_lib_strmode(i64 m, i64 expand);
static u64 cc_lib_strmode2(i64 m, i64 expand);
static u64 cc_lib_typename(i64 m);
static u64 cc_lib_getstname(u64 d);
static u64 cc_show_getprefix(i64 level, u64 prefix, u64 p);
static u64 cc_show_getdottedname(u64 p);
static u64 cc_show_getlineinfok();
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_startcon();
static void msysc_m$print_setfmt(u64 format);
static void msysc_m$print_end();
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_newline();
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mnoos_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mnoos_os_init();
static i64 mnoos_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mnoos_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mnoos_os_getch();
static i64 mnoos_os_kbhit();
static u64 mnoos_os_getdllinst(u64 name);
static u64 mnoos_os_getdllprocaddr(i64 hinst, u64 name);
static void mnoos_os_initwindows();
static void mnoos_os_gxregisterclass(u64 classname);
static void mnoos_os_setmesshandler(u64 addr);
static i64 mnoos_os_getchx();
static u64 mnoos_os_getos();
static i64 mnoos_os_gethostsize();
static i64 mnoos_os_shellexec(u64 opc, u64 file);
static void mnoos_os_sleep(i64 a);
static u64 mnoos_os_getstdout();
static u64 mnoos_os_gethostname();
static u64 mnoos_os_getmpath();
static i64 mnoos_os_clock();
static i64 mnoos_os_ticks();
static i64 mnoos_os_iswindows();
static void mnoos_os_getsystime(u64 $1);
static void mnoos_os_peek();
static u64 mnoos_os_allocexecmem(i64 n);
static i64 mnoos_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static i64 mnoos_os_hpcounter();
static i64 mnoos_os_hpfreq();
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
static u64 pc_api_pcl_start(u64 name, i64 nunits);
static void pc_api_pclerror(u64 mess);
static u64 pc_api_pc_makesymbol(u64 s, i64 id);
static void pc_api_pcl_end();
static void pc_api_pc_gen(i64 opcode, u64 p);
static u64 pc_api_pcl_writepcl(u64 filename);
static u64 pc_diags_writeallpcl();
static u64 pc_api_pcl_writepst(u64 filename);
static u64 pc_diags_writepst();
static void pc_api_pcl_genmcl();
static void mc_genmcl_genmcl(u64 dummy);
static void pc_api_pcl_genss(i64 obj);
static void mc_genss_dummy_genss(i64 obj);
static u64 pc_api_pcl_writess(u64 filename, i64 obj);
static u64 mc_writess_dummy_writessdata(i64 fexe);
static u64 pc_api_pcl_writeasm(u64 filename, i64 atype);
static u64 mc_writegas_getassemstr();
static void pc_api_pcl_writeobj(u64 filename);
static void mc_writeobj_dummy_writecoff(u64 outfile);
static void pc_api_pcl_writedll(u64 filename);
static void mc_writeexe_dummy_writeexe(u64 outfile, i64 dodll);
static void pc_api_pcl_writeexe(u64 filename);
static void pc_api_pcl_writemx(u64 filename);
static void mx_run_dummy_writemcx(u64 filename);
static void pc_api_pcl_exec();
static void mx_run_dummy_runlibfile(u64 filename, i64 cmdskip);
static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames);
static void pc_api_extendpclblock();
static u64 pc_api_newpcl();
static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset);
static void pc_api_pc_genx(i64 opcode, i64 x, u64 p);
static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p);
static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p);
static u64 pc_api_genint(i64 a);
static u64 pc_api_genreal(r64 x, i64 mode);
static u64 pc_api_genrealimm(r64 x, i64 mode);
static u64 pc_api_genstring(u64 s, i64 length);
static u64 pc_api_genpcstrimm(u64 s);
static u64 pc_api_genlabel(i64 a);
static u64 pc_api_genmem(u64 d);
static u64 pc_api_genmemaddr(u64 d);
static u64 pc_api_gendata(u64 s, i64 length);
static void pc_api_gencomment(u64 s);
static u64 pc_api_genname(u64 s);
static u64 pc_api_gennameaddr(u64 s);
static u64 pc_api_genassem(u64 code);
static void pc_api_pc_setmode(i64 m, i64 size);
static void pc_api_pc_setmode2(i64 m);
static void pc_api_pc_setxy(i64 x, i64 y);
static void pc_api_pc_setscaleoff(i64 scale, i64 offset);
static void pc_api_pc_setoffset(i64 offset);
static void pc_api_pc_addoffset(i64 offset);
static void pc_api_pc_setincr(i64 n);
static void pc_api_pc_setnargs(i64 n);
static void pc_api_pc_setnvariadics(i64 n);
static void pc_api_pc_setalign(i64 n);
static void pc_api_perror(u64 mess);
static void pc_api_perror_s(u64 mess, u64 param);
static u64 pc_api_getbasename(u64 s);
static void pc_api_pc_addsymbol(u64 d);
static void pc_api_pcerrorstop(u64 filename, i64 lineno);
static void pc_api_pc_addplib(u64 name);
static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded);
static void pc_api_pc_setimport(u64 d);
static void pc_api_pc_addparam(u64 d);
static void pc_api_pc_addlocal(u64 d);
static void pc_api_pc_endproc();
static void pc_api_merror(u64 mess, u64 param);
static u64 pc_api_pc_duplpst(u64 d);
static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip);
static i64 pc_api_convertstring(u64 s, u64 t);
static void pc_diags_strpcl(u64 p);
static void pc_diags_strlabel(i64 labelno, i64 colon);
static void pc_diags_psstr(u64 s);
static void pc_diags_psname(u64 d);
static void pc_diags_psline();
static void pc_diags_psstrline(u64 s);
static void pc_diags_psdata(u64 p);
static void pc_diags_pstabto(i64 n);
static void pc_diags_psint(i64 a);
static i64 pc_diags_newconvertstring(u64 s, u64 t, i64 length);
static u64 pc_diags_strpclstr(u64 p, i64 buffsize);
static void pc_diags_writepcl(u64 p);
static void pc_diags_psstrx(u64 s);
static void pc_diags_writepsymbol(u64 d, u64 fmt);
static void pc_diags_showprocinfo(u64 d);
static void pc_reduce_pcl_reducetest();
static void pc_run_dummy_pcl_runpcl();
static void mc_libmcl_mclinit(i64 bypass);
static void mc_genmcl_convertpcl(u64 p);
static void mc_stackmcl_showopndstack();
static void mc_auxmcl_genrealtable();
static void mc_auxmcl_genabsneg();
static void mc_auxmcl_genstringtable();
static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b);
static void mc_optim_peephole();
static void mc_genmcl_doshowpcl(u64 p);
static void mc_genmcl_unimpl(u64 p);
static void mc_libmcl_mgencomment(u64 s);
static void mc_genmcl_px_nop(u64 p);
static void mc_genmcl_px_dupl(u64 p);
static void mc_stackmcl_duplpcl();
static void mc_genmcl_px_double(u64 p);
static void mc_genmcl_px_opnd(u64 p);
static void mc_genmcl_px_type(u64 p);
static void mc_genmcl_px_comment(u64 p);
static void mc_genmcl_px_proc(u64 p);
static void mc_libmcl_setsegment(i64 seg, i64 align);
static u64 mc_libmcl_mgenmemaddr(u64 d);
static void mc_auxmcl_initproc(u64 d);
static void mc_auxmcl_fixmain();
static void mc_genmcl_px_endproc(u64 p);
static void mc_genmcl_px_endprog(u64 p);
static void mc_genmcl_px_istatic(u64 p);
static void mc_genmcl_px_zstatic(u64 p);
static u64 mc_libmcl_mgenint(i64 x, i64 mode);
static void mc_genmcl_px_data(u64 p);
static void mc_auxmcl_do_blockdata(u64 p);
static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode);
static i64 mc_libmcl_getstringindex(u64 s, i64 length);
static u64 mc_libmcl_mgenlabel(i64 x);
static void mc_genmcl_px_label(u64 p);
static void mc_genmcl_px_load(u64 p);
static void mc_stackmcl_pushpcl(u64 p);
static void mc_genmcl_px_store(u64 p);
static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg);
static u64 mc_libmcl_mgenmem(u64 d, i64 mode);
static u64 mc_stackmcl_getworkregm(i64 mode);
static u64 mc_stackmcl_makeopndind(u64 a, i64 mode);
static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest);
static void mc_stackmcl_poppcl();
static void mc_genmcl_px_add(u64 p);
static u64 mc_stackmcl_isimmload(i64 n);
static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_sub(u64 p);
static void mc_genmcl_px_mul(u64 p);
static void mc_auxmcl_mulimm(u64 ax, i64 n);
static void mc_genmcl_px_div(u64 p);
static void mc_genmcl_px_eval(u64 p);
static void mc_genmcl_px_widen(u64 p);
static void mc_stackmcl_setnewzz(i64 reg, i64 mode);
static void mc_genmcl_px_jump(u64 p);
static void mc_genmcl_px_ijump(u64 p);
static void mc_genmcl_px_neg(u64 p);
static void mc_auxmcl_do_negreal(u64 ax, i64 mode);
static void mc_genmcl_px_abs(u64 p);
static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b);
static void mc_auxmcl_do_absreal(u64 ax, i64 mode);
static void mc_genmcl_px_bitnot(u64 p);
static void mc_genmcl_px_not(u64 p);
static u64 mc_libmcl_changeopndsize(u64 a, i64 size);
static void mc_genmcl_px_toboolt(u64 p);
static void mc_genmcl_px_sqr(u64 p);
static void mc_genmcl_px_sqrt(u64 p);
static void mc_genmcl_px_jumpcc(u64 p);
static void mc_genmcl_px_jumpt(u64 p);
static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond);
static void mc_genmcl_px_jumpf(u64 p);
static void mc_genmcl_px_bitand(u64 p);
static void mc_auxmcl_do_bitwise(u64 p, i64 opc);
static void mc_genmcl_px_bitor(u64 p);
static void mc_genmcl_px_bitxor(u64 p);
static void mc_genmcl_px_shl(u64 p);
static void mc_auxmcl_do_shift(u64 p, i64 opc);
static void mc_genmcl_px_shr(u64 p);
static void mc_genmcl_px_retproc(u64 p);
static void mc_auxmcl_do_procentry(u64 p);
static void mc_auxmcl_do_procexit();
static void mc_genmcl_px_retfn(u64 p);
static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset);
static u64 mc_libmcl_mgenreg(i64 reg, i64 mode);
static void mc_genmcl_px_setcall(u64 p);
static void mc_stackmcl_saveopnds(i64 n);
static void mc_libmcl_pushslots(i64 nslots);
static void mc_genmcl_px_setarg(u64 p);
static void mc_stackmcl_pushopnd(i64 n, i64 mode, i64 size);
static void mc_genmcl_px_callp(u64 p);
static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr, i64 pstack);
static void mc_libmcl_popslots(i64 nslots);
static void mc_auxmcl_do_getretvalue(u64 p);
static void mc_genmcl_px_jumpret(u64 p);
static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_jumpretm(u64 p);
static void mc_stackmcl_movetoreg(i64 newreg);
static void mc_genmcl_px_startmx(u64 p);
static void mc_genmcl_px_resetmx(u64 p);
static void mc_genmcl_px_stop(u64 p);
static void mc_genmcl_px_incrto(u64 p);
static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrto(u64 p);
static void mc_genmcl_px_incrload(u64 p);
static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrload(u64 p);
static void mc_genmcl_px_loadincr(u64 p);
static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_loaddecr(u64 p);
static void mc_genmcl_px_forup(u64 p);
static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond);
static void mc_genmcl_px_fordown(u64 p);
static void mc_genmcl_px_iload(u64 p);
static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode);
static i64 mc_genmcl_getsharereg(u64 ax, i64 mode);
static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode);
static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode);
static void mc_auxmcl_dolea(u64 ax, u64 px);
static void mc_genmcl_px_iloadx(u64 p);
static u64 mc_auxmcl_do_addrmode(u64 p);
static void mc_genmcl_px_istore(u64 p);
static u64 mc_stackmcl_makesimpleaddr(u64 ax);
static void mc_genmcl_px_istorex(u64 p);
static void mc_genmcl_px_storem(u64 p);
static u64 mc_libmcl_newblocktemp(i64 size);
static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size);
static void mc_genmcl_px_addpx(u64 p);
static void mc_genmcl_px_subpx(u64 p);
static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale);
static void mc_genmcl_px_to(u64 p);
static void mc_genmcl_px_iswap(u64 p);
static void mc_genmcl_px_swapstk(u64 p);
static void mc_stackmcl_swapopnds(i64 m, i64 n);
static void mc_genmcl_px_labeldef(u64 p);
static void mc_genmcl_px_addto(u64 p);
static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc);
static void mc_genmcl_px_subto(u64 p);
static void mc_genmcl_px_multo(u64 p);
static void mc_auxmcl_do_binto_float(u64 p, i64 opc);
static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg);
static void mc_genmcl_px_bitandto(u64 p);
static void mc_genmcl_px_bitorto(u64 p);
static void mc_genmcl_px_bitxorto(u64 p);
static void mc_genmcl_px_shlto(u64 p);
static void mc_auxmcl_do_shiftnto(u64 p, i64 opc);
static void mc_genmcl_px_shrto(u64 p);
static void mc_genmcl_px_fix(u64 p);
static void mc_genmcl_px_float(u64 p);
static i64 mc_libmcl_mcreatefwdlabel();
static void mc_libmcl_mdefinefwdlabel(i64 lab);
static u64 mc_libmcl_mgenlabelmem(i64 x);
static void mc_genmcl_px_idiv(u64 p);
static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv);
static void mc_genmcl_px_irem(u64 p);
static void mc_genmcl_px_idivrem(u64 p);
static void mc_genmcl_px_clear(u64 p);
static void mc_auxmcl_clearblock(u64 ax, i64 n);
static void mc_genmcl_px_subp(u64 p);
static i64 mc_libmcl_ispoweroftwo(i64 x);
static void mc_genmcl_px_switch(u64 p);
static i64 mc_stackmcl_getworkireg();
static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def);
static void mc_genmcl_px_switchu(u64 p);
static void mc_genmcl_px_swlabel(u64 p);
static void mc_genmcl_px_endsw(u64 p);
static void mc_genmcl_px_fwiden(u64 p);
static void mc_genmcl_px_fnarrow(u64 p);
static void mc_genmcl_px_truncate(u64 p);
static void mc_genmcl_px_typepun(u64 p);
static void mc_genmcl_px_unload(u64 p);
static void mc_genmcl_px_loadbit(u64 p);
static void mc_genmcl_px_assem(u64 p);
static void mc_genmcl_px_sin(u64 p);
static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs);
static void mc_genmcl_px_cos(u64 p);
static void mc_genmcl_px_tan(u64 p);
static void mc_genmcl_px_asin(u64 p);
static void mc_genmcl_px_acos(u64 p);
static void mc_genmcl_px_atan(u64 p);
static void mc_genmcl_px_log(u64 p);
static void mc_genmcl_px_log10(u64 p);
static void mc_genmcl_px_exp(u64 p);
static void mc_genmcl_px_round(u64 p);
static void mc_genmcl_px_floor(u64 p);
static void mc_genmcl_px_ceil(u64 p);
static void mc_genmcl_px_atan2(u64 p);
static void mc_genmcl_px_fmod(u64 p);
static void mc_genmcl_px_setcc(u64 p);
static void mc_genmcl_px_min(u64 p);
static void mc_auxmcl_do_max_int(i64 cond);
static void mc_auxmcl_do_max_float(i64 opc);
static void mc_genmcl_px_max(u64 p);
static void mc_genmcl_px_power(u64 p);
static u64 mc_auxmcl_gethostfn(i64 opc);
static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs);
static void mc_genmcl_px_minto(u64 p);
static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode);
static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode);
static void mc_genmcl_px_maxto(u64 p);
static void mc_genmcl_px_negto(u64 p);
static void mc_genmcl_px_absto(u64 p);
static void mc_genmcl_px_addpxto(u64 p);
static void mc_genmcl_px_subpxto(u64 p);
static void mc_genmcl_px_divto(u64 p);
static void mc_genmcl_px_bitnotto(u64 p);
static void mc_genmcl_px_notto(u64 p);
static void mc_genmcl_px_toboolto(u64 p);
static void mc_genmcl_px_sign(u64 p);
static void mc_libmcl_clearreg(u64 ax);
static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode);
static void mc_genmcl_px_loadbf(u64 p);
static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j);
static void mc_auxmcl_do_loadbf_var(u64 p);
static void mc_genmcl_px_storebit(u64 p);
static void mc_auxmcl_do_storebit(u64 p);
static void mc_genmcl_px_storebf(u64 p);
static void mc_auxmcl_do_storebf(u64 p);
static void mc_genmcl_px_loadall(u64 p);
static void mc_stackmcl_checkallloaded();
static void mc_genmcl_px_setjmp(u64 p);
static void mc_stackmcl_freeworkregs(u64 p);
static void mc_genmcl_px_longjmp(u64 p);
static void mc_stackmcl_swapopndregs(i64 reg2);
static void mc_genmcl_px_initdswx(u64 p);
static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf);
static void mc_auxmcl_setmclentry(u64 p);
static u64 mc_libmcl_mgenname(u64 s);
static i64 mc_libmcl_roundsizetg(i64 size);
static u64 mc_auxmcl_resetmclentry();
static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size);
static void mc_auxmcl_spillparams();
static void mc_auxmcl_setmclentryf(u64 p);
static void mc_libmcl_pushstack(i64 n);
static u64 mc_auxmcl_resetmclentryf();
static void mc_libmcl_popstack(i64 n);
static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno);
static i64 mc_auxmcl_ismemaddr(i64 n);
static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n);
static void mc_auxmcl_saverdx();
static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz);
static void mc_auxmcl_restorerdx();
static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype);
static void mc_auxmcl_gendb(i64 a);
static void mc_auxmcl_gendbstring(u64 s, i64 length);
static u64 mc_libmcl_mgenstring(u64 s, i64 length);
static void mc_auxmcl_gendq(i64 a);
static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs);
static u64 mc_libmcl_mgenreg0(i64 reg, i64 size);
static u64 mc_libmcl_newmclopnd();
static void mc_libmcl_initmcdest();
static u64 mc_libmcl_mgenint0(i64 x, i64 size);
static void mc_libmcl_genmc_str(i64 opcode, u64 s);
static u64 mc_libmcl_duplopnd(u64 a);
static i64 mc_libmcl_getrealindex(r64 x);
static i64 mc_libmcl_getr32index(r64 x);
static u64 mc_libmcl_mgenxregvar(u64 d);
static u64 mc_libmcl_mgenregvar(u64 d, i64 mode);
static u64 mc_libmcl_mgenregi(i64 reg, i64 mode);
static u64 mc_libmcl_mgentemp(i64 n, i64 mode);
static void mc_libmcl_merroropnd(u64 mess, i64 opndtype);
static u64 mc_libmcl_findnamesym(u64 s);
static void mc_libmcl_addnamesym(u64 d);
static i64 mc_libmcl_getprimreg(u64 ax);
static i64 mc_libmcl_addconst(u64 clist, i64 value, i64 length);
static void mc_libmcl_axerror(u64 mess);
static i64 mc_stackmcl_getworkreg(i64 mode);
static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg);
static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg);
static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax);
static void mc_stackmcl_savenextopnd();
static i64 mc_stackmcl_getworkxreg();
static void mc_stackmcl_saveopnd(i64 n, i64 allregs);
static void mc_stackmcl_savenextxopnd();
static i64 mc_optim_isreg0(u64 a);
static i64 mc_optim_endr0(u64 m);
static i64 mc_optim_isreg10(u64 a);
static i64 mc_optim_isreg(u64 a);
static u64 mc_optim_deletemcl(u64 p);
static i64 mc_optim_isconst(u64 a);
static i64 mc_optim_isreg00(u64 m);
static i64 mc_optim_sameoperand(u64 a, u64 b);
static i64 mc_optim_sameregopnd(u64 a, u64 b);
static void mc_decls_start();
static void mc_writegas_asmstr(u64 s);
static void mc_writegas_writemcl(i64 index, u64 mcl);
static void mc_writegas_start();
static void mc_writegas_asmchar(i64 c);
static void mc_writegas_asmopnd(u64 a, i64 sizeprefix, i64 opcode);
static i64 mc_writegas_needsizeprefix(i64 opcode, u64 a, u64 b);
static u64 mc_writegas_strmclstr(u64 m);
static u64 mc_writegas_getsizeprefix(i64 size, i64 enable);
static u64 mc_writegas_strxreg(i64 reg, i64 size);
static u64 mc_writegas_checkregvar(i64 reg, i64 ispfloat);
static void mc_writeexe_dummy_genexe(u64 entrypoint, u64 outfile, i64 dodll);
void cc_cli_main();
static void pepcl_start();
static void cc_cli_starttiming();
static void cc_cli_initdata();
static void cc_cli_getinputoptions();
static void cc_cli_initsearchdirs();
static void cc_cli_showsearchdirs();
static void cc_cli_initlogfile();
static i64 cc_cli_gettiming();
static void cc_cli_do_loadmodule();
static void cc_cli_do_preprocess();
static void cc_cli_do_parsemodule();
static void cc_cli_do_genpcl();
static void cc_cli_do_genmcl();
static void cc_cli_do_asm();
static void cc_cli_do_obj();
static void cc_cli_do_dll();
static void cc_cli_do_exe();
static void cc_cli_do_mx();
static void cc_cli_do_run();
static void cc_cli_showtiming();
static void cc_cli_closelogfile();
static u64 cc_lex_addnamestr(u64 name);
static u64 cc_lib_createdupldef(u64 owner, u64 symptr, i64 id);
static void cc_support_loaderror(u64 mess, u64 mess2);
static i64 cc_support_loadsourcefile(u64 file, u64 shortfile);
static i64 cc_parse_parsemodule();
static void cc_genpcl_codegen_pcl();
static void cc_lib_addtolog(u64 filename, u64 logdest);
static void cc_cli_showast();
static void cc_cli_showst(u64 caption);
static void cc_cli_showstflat(u64 caption);
static void cc_show_printmodelist(u64 f);
static void cc_lex_lexsetup();
static void cc_lib_inittypetables();
static void cc_lib_initcclib();
static i64 cc_cli_cgetsourceinfo(i64 pos, u64 filename, u64 sourceline);
static void cc_show_printcode(u64 f, u64 caption);
static void cc_show_printstflat(u64 f);
static void cc_show_printst(u64 f, u64 p, i64 level);
static void cc_cli_showfiles();
static void cc_cli_showtime(u64 caption, i64 t);
static void cc_cli_do_option(i64 sw, u64 value);
static void cc_cli_showcaption();
static void cc_headers_writeheaders();
static void cc_cli_showhelp();
static void cc_cli_showincludepaths();
static void cc_lex_setfileno(i64 fileno);
static void cc_lex_stacksourcefile(u64 file, i64 syshdr);
static void cc_lex_emittoken(u64 lp, u64 dest, i64 forcespace);
static void cc_lex_lxerror(u64 mess);
static void cc_lex_showtokens(u64 caption, u64 tk);
static void cc_lex_lexreadtoken();
static void cc_lex_lxreadstring(i64 termchar, i64 fwide);
static i64 cc_lex_lookup();
static void cc_lex_setnumberoffset(i64 offset);
static void cc_lex_readdecimal(u64 pstart);
static void cc_lex_readhex(u64 pstart);
static void cc_lex_readbinary(u64 pstart);
static void cc_lex_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base);
static void cc_lex_readoctal(u64 pstart);
static void cc_lex_readlinecomment();
static void cc_lex_readblockcomment();
static void cc_lex_unstacksourcefile();
static void cc_lex_old_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base);
static u64 cc_lex_scannumber(i64 base);
static i64 cc_lex_readexponent(u64 badexpon);
static void cc_lex_readalphanumeric(u64 pstart);
static i64 cc_lex_getfileno();
static void cc_lex_printsymbol(u64 lp);
static void cc_lex_printstrn(u64 s, i64 length, u64 f);
static void cc_lex_shownumberstr(u64 l, u64 f);
static void cc_lex_inithashtable();
static void cc_lex_fillhashtable();
static void cc_lex_newhashtable();
static u64 cc_lex_gethashvalue(u64 s, i64 length);
static i64 cc_lex_dolexdirective();
static i64 cc_lex_getlexdirective();
static u64 cc_lex_strtoken(u64 lp, u64 length);
static void cc_lex_dodefine();
static i64 cc_lex_getifdef();
static i64 cc_lex_getifexpr();
static i64 cc_lex_skipcode();
static void cc_lex_dopragmadir();
static void cc_lex_startlex(u64 caption, i64 fileno);
static void cc_lex_lex();
static void cc_lex_endlex();
static void cc_lex_ps(u64 caption);
static void cc_lex_psnext(u64 caption);
static i64 cc_lex_gethashtablesize();
static i64 cc_lex_checknumbersuffix();
static u64 cc_headers_findheader(u64 name);
static i64 cc_support_loadbuiltin(u64 shortfile, u64 hdrtext);
static i64 cc_lex_getfilenox(u64 tk);
static i64 cc_lex_getnumberoffsetx(u64 tk);
static void cc_lex_addlisttoken(u64 ulist, u64 ulistx, u64 p);
static void cc_lex_addlisttoken_copy(u64 ulist, u64 ulistx, u64 q);
static u64 cc_lex_alloctoken();
static void cc_lex_addlist_nextlx(u64 ulist, u64 ulistx);
static void cc_lex_addlisttoken_seq(u64 ulist, u64 ulistx, u64 seq);
static void cc_lex_addlistmparam(u64 ulist, u64 ulistx, u64 p);
static i64 cc_lex_inmacrostack(u64 d, u64 macrostack);
static void cc_lex_lexa(u64 tk);
static i64 cc_lex_peeklb();
static void cc_lex_dospecialinclude();
static u64 cc_lex_expandfnmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel, u64 endlineno);
static u64 cc_lex_expandobjmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel);
static i64 cc_lex_peektk(u64 tk);
static u64 cc_lex_substituteargs(u64 m, u64 args, u64 expargs, i64 nargs, u64 macrostack);
static u64 cc_lex_scantokenseq(u64 tk, u64 macrostack, u64 expanded);
static i64 cc_lex_readmacrocall(u64 d, u64 args, u64 tksource);
static u64 cc_lex_alloctokenz();
static void cc_lex_setfilenox(u64 tk, i64 fileno);
static void cc_lex_pastetokens(u64 tk, u64 tknext);
static u64 cc_lex_strstring(u64 s, i64 length, u64 newlength, i64 quotechar);
static i64 cc_lib_convertstringc(u64 s, u64 t, i64 length);
static i64 cc_lex_needspace(i64 a, i64 b);
static i64 cc_lex_evalcondexpr(u64 sx);
static i64 cc_lex_evalorexpr(u64 sx);
static i64 cc_lex_evalandexpr(u64 sx);
static i64 cc_lex_evaliorexpr(u64 sx);
static i64 cc_lex_evalixorexpr(u64 sx);
static i64 cc_lex_evaliandexpr(u64 sx);
static i64 cc_lex_evaleqexpr(u64 sx);
static i64 cc_lex_evalcmpexpr(u64 sx);
static i64 cc_lex_evalshiftexpr(u64 sx);
static i64 cc_lex_evaladdexpr(u64 sx);
static i64 cc_lex_evalmulexpr(u64 sx);
static i64 cc_lex_evalunaryexpr(u64 sx);
static i64 cc_lex_evalterm(u64 sx);
static void cc_lex_fastreadtoken();
static void cc_lex_freetokens(u64 tk);
static void cc_lex_addbuildinfo(i64 code);
static void cc_lex_freehashtable();
static void cc_lex_regenlookup(u64 d);
static void cc_parse_readmodule();
static void cc_support_serror(u64 mess);
static i64 cc_parse_readdllexport();
static i64 cc_parse_readdeclspec(u64 owner, u64 linkage);
static i64 cc_parse_readtype(u64 owner, u64 d, i64 m, u64 pm);
static i64 cc_lib_createprocmode(i64 m, u64 pm);
static u64 cc_parse_createtypedef(u64 owner, u64 symptr, i64 mode);
static u64 cc_parse_readfunction(u64 d, i64 m, i64 linkage, u64 pm, u64 wasdef, i64 exported);
static u64 cc_parse_readmodulevar(u64 d, i64 m, i64 linkage);
static void cc_lib_skipsymbol(i64 symbol);
static void cc_support_serror_s(u64 mess, u64 a);
static void cc_lib_checksymbol(i64 symbol);
static i64 cc_parse_readstructdecl(u64 owner);
static i64 cc_parse_readenumdecl(u64 owner);
static i64 cc_parse_isusertype(u64 owner);
static i64 cc_lib_createconstmode(i64 m);
static i64 cc_parse_istypestarter();
static u64 cc_lib_resolvename(u64 owner, u64 symptr, i64 ns, i64 blockno);
static i64 cc_parse_istypestarter_next();
static u64 cc_parse_readexpression();
static u64 cc_parse_readterm();
static u64 cc_parse_readassignexpr();
static void cc_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static u64 cc_lib_createunit1(i64 tag, u64 p);
static u64 cc_parse_readcondexpr();
static void cc_parse_checklvalue(u64 p, i64 assign);
static u64 cc_parse_createassignopref(i64 opc, u64 p, u64 q);
static u64 cc_parse_coercemode(u64 p, i64 t);
static void cc_support_terror(u64 mess);
static u64 cc_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 cc_parse_readorlexpr();
static void cc_parse_coercecond(u64 p);
static u64 cc_lib_createunit3(i64 tag, u64 p, u64 q, u64 r);
static u64 cc_parse_readandlexpr();
static u64 cc_parse_readiorexpr();
static u64 cc_parse_readixorexpr();
static u64 cc_parse_readiandexpr();
static u64 cc_parse_readeqexpr();
static u64 cc_parse_readrelexpr();
static i64 cc_parse_checkpointertypes(i64 s, i64 t, i64 hard);
static u64 cc_parse_readshiftexpr();
static u64 cc_parse_readaddexpr();
static void cc_parse_coercebasetype(u64 p);
static u64 cc_parse_readmulexpr();
static u64 cc_parse_createaddop(u64 x, u64 y);
static u64 cc_parse_createsubop(u64 x, u64 y);
static u64 cc_parse_createmulop(u64 x, u64 y);
static u64 cc_parse_createdivop(u64 x, u64 y);
static u64 cc_parse_createremop(u64 x, u64 y);
static u64 cc_lib_createconstunit(u64 a, i64 t);
static u64 cc_lib_createunit0(i64 tag);
static i64 cc_lib_createrefmode(i64 m);
static u64 cc_lib_createname(u64 p);
static u64 cc_parse_createaddrofop(u64 p);
static void cc_parse_fixmemopnd(u64 p);
static u64 cc_lib_createwstringconstunit(u64 s, i64 length);
static u64 cc_lib_createstringconstunit(u64 s, i64 length);
static u64 cc_parse_createnegop(u64 p);
static u64 cc_parse_createinotop(u64 p);
static u64 cc_parse_createptrop(u64 p);
static u64 cc_parse_createincrop(i64 opc, u64 p);
static u64 cc_parse_createabsop(u64 p);
static i64 cc_parse_readcasttype(u64 d, i64 allowname, u64 pm, i64 m, u64 mbase);
static u64 cc_parse_docast(u64 p, i64 t, i64 hard, i64 inplace);
static u64 cc_parse_createsizeofop(u64 p, i64 islength);
static u64 cc_parse_readgeneric();
static u64 cc_parse_createindexop(u64 p, u64 q);
static u64 cc_parse_createdotop(i64 opc, u64 p, u64 d);
static u64 cc_parse_readexprlist(u64 p);
static u64 cc_parse_createcall(u64 p, u64 q);
static u64 cc_lib_checkdupl(u64 owner, u64 symptr, i64 ns, i64 blockno);
static void cc_support_serror_ss(u64 mess, u64 a, u64 b);
static i64 cc_parse_comparemode(i64 s, i64 t);
static u64 cc_parse_readinitexpr(u64 owner, i64 m);
static u64 cc_parse_readframevar(u64 d, i64 m, i64 linkage);
static u64 cc_lib_checkdupl_inproc(u64 owner, u64 symptr, i64 ns, i64 blockno);
static void cc_parse_readnamedtype(u64 owner, u64 d, u64 modtype, u64 modvalue, u64 nmodifiers);
static i64 cc_lib_createarraymode(i64 m, i64 length);
static u64 cc_parse_readparams(u64 owner);
static i64 cc_parse_readconstintexpr();
static u64 cc_parse_readinitexpr2(u64 owner, i64 m, i64 istop);
static void cc_parse_pushblock();
static void cc_parse_popblock();
static u64 cc_parse_readcompoundstmt(i64 params);
static u64 cc_parse_readstatement();
static u64 cc_parse_readblock(i64 ifelse);
static u64 cc_parse_readifstmt();
static u64 cc_parse_readforstmt();
static u64 cc_parse_readwhilestmt();
static u64 cc_parse_readdostmt();
static u64 cc_parse_readreturnstmt();
static u64 cc_parse_readswitchstmt();
static u64 cc_parse_readgotostmt();
static u64 cc_parse_readcaselabel();
static u64 cc_parse_readlocaldecl();
static u64 cc_parse_readcond();
static i64 cc_parse_iscondtrue(u64 p);
static void cc_parse_deleteunit(u64 p, u64 q);
static i64 cc_parse_iscondfalse(u64 p);
static u64 cc_parse_readexprstmt();
static void cc_parse_pushloop(i64 looptype);
static void cc_parse_poploop();
static void cc_parse_addcasevalue(i64 value);
static void cc_lib_addlistparam(u64 ulist, u64 ulistx, u64 p);
static void cc_parse_readfunctionbody(u64 f);
static i64 cc_lib_isintcc(i64 m);
static void cc_show_printunit(u64 dev, u64 p, i64 level, u64 prefix);
static u64 cc_parse_arraytopointer(u64 p);
static i64 cc_parse_getmemmode(u64 p);
static u64 cc_parse_eval_add(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_divunit(u64 p, i64 elemtype);
static u64 cc_parse_mulunit(u64 p, i64 elemtype);
static u64 cc_parse_eval_sub(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_mul(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_div(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_rem(i64 opc, u64 x, u64 y, i64 t);
static void cc_parse_insertunit(u64 p, i64 tag);
static i64 cc_parse_eval_convert(u64 p, i64 t, i64 opc);
static void cc_support_terror_s(u64 mess, u64 a);
static void cc_parse_coercemode_inplace(u64 p, i64 t);
static i64 cc_lib_createstructmode(u64 s, i64 smode);
static void cc_lib_addlistdef(u64 ulist, u64 ulistx, u64 p);
static i64 cc_lib_getalignment(i64 m);
static i64 cc_parse_roundoffset(i64 offset, i64 alignment);
static void cc_parse_addnewfield(u64 flist, u64 d, i64 offset);
static u64 cc_lib_getautofieldname();
static void cc_parse_readenumnames(u64 owner);
static i64 cc_lib_createenummode(u64 e);
static void cc_support_terror_ss(u64 mess, u64 a, u64 b);
static i64 cc_parse_getpromotedtype(i64 t);
static void cc_genpcl_dolibs();
static void cc_genpcl_dostaticvar(u64 d);
static void cc_support_gerror_s(u64 mess, u64 s, u64 p);
static void cc_genpcl_genprocdef(u64 p);
static u64 cc_libpcl_getpsymbol(u64 d);
static i64 cc_libpcl_createfwdlabel();
static void cc_blockpcl_do_stmt(u64 p);
static void cc_libpcl_setmode(i64 mode);
static void cc_libpcl_definefwdlabel(i64 lab);
static u64 cc_libpcl_genmem_d(u64 d);
static void cc_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset);
static void cc_genpcl_doresb(i64 n);
static i64 cc_lib_isrealcc(i64 m);
static void cc_support_gerror(u64 mess, u64 p);
static u64 cc_libpcl_genmemaddr_d(u64 d);
static void cc_genpcl_pushint(i64 a);
static void cc_blockpcl_do_decl(u64 d);
static void cc_blockpcl_dx_call(u64 p, u64 a, u64 b, i64 res);
static void cc_blockpcl_do_return(u64 p, u64 a);
static void cc_blockpcl_do_assign(u64 a, u64 b, i64 res);
static void cc_blockpcl_do_if(u64 a, u64 b, u64 c);
static void cc_blockpcl_do_for(u64 pinit, u64 pbody);
static void cc_blockpcl_do_while(u64 pcond, u64 pbody);
static void cc_blockpcl_do_dowhile(u64 pbody, u64 pcond);
static void cc_blockpcl_do_goto(u64 d);
static void cc_blockpcl_do_labeldef(u64 d);
static void cc_blockpcl_do_casestmt(u64 p, u64 a);
static void cc_blockpcl_genjumpl(i64 lab);
static void cc_blockpcl_do_switch(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_binto(u64 a, u64 b, i64 opc, i64 res);
static void cc_blockpcl_do_preincr(u64 a, i64 incrop);
static void cc_blockpcl_dx_expr(u64 p, i64 am);
static void cc_libpcl_setmode_u(u64 p);
static void cc_blockpcl_dx_const(u64 p);
static void cc_blockpcl_dx_name(u64 p, i64 am);
static void cc_blockpcl_dx_andorl(u64 p);
static i64 cc_blockpcl_isboolexpr(u64 p);
static void cc_libpcl_setmode2(i64 mode);
static void cc_blockpcl_dx_ifx(u64 p, u64 a, u64 b, u64 c);
static void cc_blockpcl_dx_eq(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_bin(u64 a, u64 b, i64 opc);
static void cc_blockpcl_dx_ptr(u64 p, u64 a, i64 am);
static void cc_blockpcl_dx_addptr(u64 p, u64 a, u64 b, i64 opc, i64 am);
static void cc_blockpcl_dx_convert(u64 p, u64 a, i64 t, i64 opc);
static void cc_blockpcl_dx_scale(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_preincrx(u64 p, u64 a);
static void cc_blockpcl_dx_postincrx(u64 p, u64 a);
static void cc_blockpcl_dx_addrof(u64 p, u64 a, i64 am);
static void cc_blockpcl_dx_dot(u64 p, u64 a, u64 b, i64 am);
static void cc_blockpcl_widen(u64 p);
static void cc_blockpcl_do_setinplace();
static void cc_blockpcl_do_fixwiden(u64 a, u64 b);
static void cc_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab);
static void cc_blockpcl_gcomparejump(i64 jumpopc, u64 p, u64 lhs, u64 rhs, i64 lab);
static i64 cc_blockpcl_getpclcond(i64 op);
static i64 cc_blockpcl_reversecond(i64 cc);
static void cc_blockpcl_do_while1(u64 pbody);
static void cc_blockpcl_stacklooplabels(i64 a, i64 b);
static i64 cc_libpcl_definelabel();
static void cc_blockpcl_setincrstep(i64 m);
static i64 cc_lib_getpclmode(i64 t);
static u64 cc_lib_newstrec();
static u64 cc_lib_allocunitrec();
static i64 cc_lib_getconstvalue(u64 p, i64 id);
static i64 cc_lib_copymode(i64 m);
static i64 cc_lib_createnewmode(i64 m);
static void cc_lib_setnameptr(u64 p);
static void cc_lib_istrmode(i64 m, i64 expand, u64 dest);
static void cc_support_mcerror(u64 mess);
static u64 cc_lib_createnewmoduledef(u64 owner, u64 symptr);
static u64 cc_lib_createnewproc(u64 owner, u64 symptr);
static u64 cc_lib_resolvelabel(u64 owner, u64 symptr);
static i64 cc_lib_isexported(u64 d);
static i64 cc_lib_isimported(u64 d);
static void cc_lib_writegsfile(u64 filename, u64 d);
static void cc_lib_pause(u64 mess);
static void cc_support_stopcompiler(u64 filename, i64 lineno);
static void cc_support_serror_gen(u64 mess);
static void cc_support_showmacrolineno();
static void cc_support_terror_gen(u64 mess);
static void cc_support_gerror_gen(u64 mess, u64 p);
static i64 cc_support_nextpoweroftwo(i64 x);
static u64 cc_support_splicelines(u64 s);
static void cc_support_gs_copytostr(u64 source, u64 s);
static void cc_support_gs_additem(u64 dest, u64 s);
static i64 cc_support_isalphanum(i64 c);
static i64 cc_headers_isheaderfile(u64 file);
static void cc_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix);
static void cc_show_printstrec(u64 f, u64 p, i64 level);
static u64 cc_show_strexpr(u64 p);
static void cc_show_jeval(u64 dest, u64 p);
static void cc_show_printfilelist(u64 f);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    cc_cli_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u8 pepcl_pc_userunpcl = 0;

static u8 pepcl_asmonly = 1;

static u8 pepcl_pdcc = 1;

static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc = 65536;

static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B17 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest = (u64)&pc_decls_sbuffer;

static struct $B18 pc_decls_plibfiles;
static struct $B18 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype = 16705;

static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole = 1;

static u8 pc_decls_fregoptim = 1;

static u8 pc_decls_fnoconst = 0;

static u8 pc_decls_fshowil = 0;

static u8 pc_decls_flong64 = 0;

static i64 pc_decls_pcltime;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B19 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_decls_npcl;
static i64 pc_decls_npst;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest = (u64)&pc_diags_sbuffer;

static i64 pc_diags_destlinestart;
static struct $B20 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static u64 pc_diags_psopnd_longstring;
static struct $B21 pc_tables_pstdnames = {{
(u64)"void",
(u64)"r32",
(u64)"r64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"mem",
(u64)"vec",
(u64)"$last"}};

static struct $B22 pc_tables_psize = {{
1024,
264,
1026,
264,
1026,
8,
0}};

static struct $B22 pc_tables_psigned = {{
0,
0,
0,
256,
257,
1,
0}};

static struct $B22 pc_tables_pint = {{
0,
256,
257,
257,
257,
1,
0}};

static struct $B22 pc_tables_pfloat = {{
256,
1,
0,
0,
0,
0,
0}};

static struct $B22 pc_tables_pmin = {{
256,
1282,
1285,
2310,
2313,
2826,
12}};

static struct $B22 pc_tables_xxpiwrb = {{
256,
1538,
1542,
2566,
2570,
10,
0}};

static struct $B21 pc_tables_opndnames = {{
(u64)"no_opnd",
(u64)"mem_opnd",
(u64)"memaddr_opnd",
(u64)"label_opnd",
(u64)"int_opnd",
(u64)"real_opnd",
(u64)"r32_opnd",
(u64)"string_opnd",
(u64)"strimm_opnd",
(u64)"assem_opnd",
(u64)"realimm_opnd",
(u64)"realimm32_opnd",
(u64)"data_opnd",
(u64)"any_opnd"}};

static struct $B19 pc_tables_pclnames = {{
(u64)"nop",
(u64)"load",
(u64)"iload",
(u64)"iloadx",
(u64)"store",
(u64)"istore",
(u64)"istorex",
(u64)"storem",
(u64)"dupl",
(u64)"double",
(u64)"swapstk",
(u64)"unload",
(u64)"opnd",
(u64)"type",
(u64)"loadbit",
(u64)"loadbf",
(u64)"storebit",
(u64)"storebf",
(u64)"callp",
(u64)"icallp",
(u64)"retproc",
(u64)"callf",
(u64)"icallf",
(u64)"retfn",
(u64)"jump",
(u64)"ijump",
(u64)"jumpcc",
(u64)"jumpt",
(u64)"jumpf",
(u64)"jumpret",
(u64)"jumpretm",
(u64)"setcc",
(u64)"stop",
(u64)"to",
(u64)"forup",
(u64)"fordown",
(u64)"iswap",
(u64)"switch",
(u64)"switchu",
(u64)"swlabel",
(u64)"endsw",
(u64)"clear",
(u64)"assem",
(u64)"add",
(u64)"sub",
(u64)"mul",
(u64)"div",
(u64)"idiv",
(u64)"irem",
(u64)"idivrem",
(u64)"bitand",
(u64)"bitor",
(u64)"bitxor",
(u64)"shl",
(u64)"shr",
(u64)"min",
(u64)"max",
(u64)"addpx",
(u64)"subpx",
(u64)"subp",
(u64)"neg",
(u64)"abs",
(u64)"bitnot",
(u64)"not",
(u64)"toboolt",
(u64)"toboolf",
(u64)"sqr",
(u64)"sqrt",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"sign",
(u64)"atan2",
(u64)"power",
(u64)"fmod",
(u64)"incrto",
(u64)"decrto",
(u64)"incrload",
(u64)"decrload",
(u64)"loadincr",
(u64)"loaddecr",
(u64)"addto",
(u64)"subto",
(u64)"multo",
(u64)"divto",
(u64)"idivto",
(u64)"iremto",
(u64)"bitandto",
(u64)"bitorto",
(u64)"bitxorto",
(u64)"shlto",
(u64)"shrto",
(u64)"minto",
(u64)"maxto",
(u64)"addpxto",
(u64)"subpxto",
(u64)"negto",
(u64)"absto",
(u64)"bitnotto",
(u64)"notto",
(u64)"toboolto",
(u64)"typepun",
(u64)"float",
(u64)"fix",
(u64)"truncate",
(u64)"widen",
(u64)"fwiden",
(u64)"fnarrow",
(u64)"startmx",
(u64)"resetmx",
(u64)"endmx",
(u64)"proc",
(u64)"tcproc",
(u64)"endproc",
(u64)"istatic",
(u64)"zstatic",
(u64)"data",
(u64)"initdswx",
(u64)"label",
(u64)"labeldef",
(u64)"setjmp",
(u64)"longjmp",
(u64)"setcall",
(u64)"setarg",
(u64)"loadall",
(u64)"eval",
(u64)"comment",
(u64)"endprog",
(u64)"param",
(u64)"local",
(u64)"rettype",
(u64)"variadic",
(u64)"addlib",
(u64)"extproc"}};

static struct $B23 pc_tables_pclhastype = {{
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
2,
2,
2,
2,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0}};

static struct $B23 pc_tables_pclextra = {{
0,
1,
0,
2,
0,
0,
2,
0,
0,
0,
2,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
2,
2,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
0,
0,
0,
0,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B23 pc_tables_pclhasopnd = {{
0,
13,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
13,
0,
0,
0,
0,
0,
2,
0,
0,
2,
0,
0,
3,
0,
3,
3,
3,
3,
3,
0,
0,
3,
3,
3,
0,
3,
3,
3,
0,
0,
13,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
1,
1,
13,
0,
3,
2,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
7,
1}};

static struct $B23 pc_tables_pclargs = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
9,
9,
0,
9,
9,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B24 pc_tables_ccnames = {{
(u64)"xx",
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B1 pc_tables_idnames = {{
(u64)"--",
(u64)"Import",
(u64)"Proc",
(u64)"Static",
(u64)"Local",
(u64)"Param",
(u64)"Label",
(u64)"Export",
(u64)"Misc",
(u64)"Program"}};

static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B19 mc_genmcl_px_handlertable;
static struct $B25 mc_genmcl_scondcodes = {{
1284,
3596,
3853}};

static struct $B25 mc_genmcl_ucondcodes = {{
1284,
1538,
1795}};

// Istatic skipped:mc_genmcl.inithandlers.initdone

// Istatic skipped:mc_genmcl.inithandlers.dupltable

static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B28 mc_libmcl_smallinttable;
static struct $B29 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B29 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B20 mc_stackmcl_stropndstack_str;
static i64 mc_genss_dummy_psstime;
static struct $B11 mc_decls_valtypenames = {{
(u64)"no_val",
(u64)"intimm_val",
(u64)"realimm_val",
(u64)"realmem_val",
(u64)"stringimm_val",
(u64)"def_val",
(u64)"label_val",
(u64)"name_val",
(u64)"temp_val"}};

static struct $B30 mc_decls_mclnames = {{
(u64)"m_procstart",
(u64)"m_procend",
(u64)"m_comment",
(u64)"m_labelname",
(u64)"m_define",
(u64)"m_definereg",
(u64)"m_trace",
(u64)"m_endx",
(u64)"m_labelx",
(u64)"m_nop",
(u64)"m_mov",
(u64)"m_push",
(u64)"m_pop",
(u64)"m_lea",
(u64)"m_cmovcc",
(u64)"m_movd",
(u64)"m_movq",
(u64)"m_movsx",
(u64)"m_movzx",
(u64)"m_movsxd",
(u64)"m_call",
(u64)"m_ret",
(u64)"m_leave",
(u64)"m_retn",
(u64)"m_jmp",
(u64)"m_jmpcc",
(u64)"m_xchg",
(u64)"m_add",
(u64)"m_sub",
(u64)"m_adc",
(u64)"m_sbb",
(u64)"m_imul",
(u64)"m_mul",
(u64)"m_imul2",
(u64)"m_imul3",
(u64)"m_idiv",
(u64)"m_div",
(u64)"m_andx",
(u64)"m_orx",
(u64)"m_xorx",
(u64)"m_test",
(u64)"m_cmp",
(u64)"m_shl",
(u64)"m_sar",
(u64)"m_shr",
(u64)"m_rol",
(u64)"m_ror",
(u64)"m_rcl",
(u64)"m_rcr",
(u64)"m_neg",
(u64)"m_notx",
(u64)"m_inc",
(u64)"m_dec",
(u64)"m_cbw",
(u64)"m_cwd",
(u64)"m_cdq",
(u64)"m_cqo",
(u64)"m_setcc",
(u64)"m_bsf",
(u64)"m_bsr",
(u64)"m_shld",
(u64)"m_shrd",
(u64)"m_sqrtss",
(u64)"m_sqrtsd",
(u64)"m_addss",
(u64)"m_addsd",
(u64)"m_subss",
(u64)"m_subsd",
(u64)"m_mulss",
(u64)"m_mulsd",
(u64)"m_divss",
(u64)"m_divsd",
(u64)"m_comiss",
(u64)"m_comisd",
(u64)"m_ucomisd",
(u64)"m_xorps",
(u64)"m_xorpd",
(u64)"m_andps",
(u64)"m_andpd",
(u64)"m_pxor",
(u64)"m_pand",
(u64)"m_cvtss2si",
(u64)"m_cvtsd2si",
(u64)"m_cvttss2si",
(u64)"m_cvttsd2si",
(u64)"m_cvtsi2ss",
(u64)"m_cvtsi2sd",
(u64)"m_cvtsd2ss",
(u64)"m_cvtss2sd",
(u64)"m_movdqa",
(u64)"m_movdqu",
(u64)"m_pcmpistri",
(u64)"m_pcmpistrm",
(u64)"m_fld",
(u64)"m_fst",
(u64)"m_fstp",
(u64)"m_fild",
(u64)"m_fist",
(u64)"m_fistp",
(u64)"m_fadd",
(u64)"m_fsub",
(u64)"m_fmul",
(u64)"m_fdiv",
(u64)"m_fsqrt",
(u64)"m_fsin",
(u64)"m_fcos",
(u64)"m_fsincos",
(u64)"m_fptan",
(u64)"m_fpatan",
(u64)"m_fabs",
(u64)"m_fchs",
(u64)"m_minss",
(u64)"m_maxss",
(u64)"m_minsd",
(u64)"m_maxsd",
(u64)"m_db",
(u64)"m_dw",
(u64)"m_dd",
(u64)"m_dq",
(u64)"m_ascii",
(u64)"m_isegment",
(u64)"m_zsegment",
(u64)"m_csegment",
(u64)"m_align",
(u64)"m_resb",
(u64)"m_resw",
(u64)"m_resd",
(u64)"m_resq",
(u64)"m_xlat",
(u64)"m_loopnz",
(u64)"m_loopz",
(u64)"m_loopcx",
(u64)"m_jecxz",
(u64)"m_jrcxz",
(u64)"m_cmpsb",
(u64)"m_cmpsw",
(u64)"m_cmpsd",
(u64)"m_cmpsq",
(u64)"m_rdtsc",
(u64)"m_popcnt",
(u64)"m_bswap",
(u64)"m_finit",
(u64)"m_fldz",
(u64)"m_fld1",
(u64)"m_fldpi",
(u64)"m_fld2t",
(u64)"m_fld2e",
(u64)"m_fldlg2",
(u64)"m_fldln2",
(u64)"m_cpuid",
(u64)"m_xxxx",
(u64)"m_halt"}};

static struct $B31 mc_decls_mclnopnds = {{
0,
144680341364408321,
72057598366581250,
72622751638225153,
144680341364474369,
144680345676153346,
4311810306,
144680345676153088,
144680345676153346,
144680345676153346,
144680345676153346,
72340181461631490,
65793,
144115188075855872,
72340172838142466,
72340172838010880,
1103823438080,
4328521728,
0}};

static struct $B31 mc_decls_mclcodes = {{
0,
36864,
56791871518670848,
361134615617863913,
432631463138033668,
144396684645107456,
4295099139,
5859654413743554560,
6799970727712544856,
-1201242466499547392,
219,
216736154650895872,
-362036289223851520,
6764655078180388862,
6249823,
577588855528488960,
250567903535319,
-1662391212449923072,
-796010212255667733}};

static struct $B32 mc_decls_regnames = {{
(u64)"rnone",
(u64)"r0",
(u64)"r1",
(u64)"r2",
(u64)"r3",
(u64)"r4",
(u64)"r5",
(u64)"r6",
(u64)"r7",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"r16",
(u64)"r17",
(u64)"r18",
(u64)"r19"}};

static struct $B33 mc_decls_regcodes = {{
0,
0,
10,
11,
7,
3,
6,
12,
13,
14,
15,
1,
2,
8,
9,
5,
4,
4,
7,
5,
6}};

static struct $B29 mc_decls_condnames = {{
(u64)"ov",
(u64)"nov",
(u64)"ltu",
(u64)"geu",
(u64)"eq",
(u64)"ne",
(u64)"leu",
(u64)"gtu",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"lt",
(u64)"ge",
(u64)"le",
(u64)"gt",
(u64)"flt",
(u64)"fge",
(u64)"fle",
(u64)"fgt"}};

static struct $B29 mc_decls_asmcondnames = {{
(u64)"o",
(u64)"no",
(u64)"b",
(u64)"ae",
(u64)"z",
(u64)"nz",
(u64)"be",
(u64)"a",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"l",
(u64)"ge",
(u64)"le",
(u64)"g",
(u64)"b",
(u64)"ae",
(u64)"be",
(u64)"a"}};

static struct $B29 mc_decls_asmrevcond = {{
1,
0,
3,
2,
5,
4,
7,
6,
9,
8,
11,
10,
13,
12,
15,
14,
17,
16,
19,
18}};

static struct $B34 mc_decls_dregnames = {{
(u64)"d0",
(u64)"d1",
(u64)"d2",
(u64)"d3",
(u64)"d4",
(u64)"d5",
(u64)"d6",
(u64)"d7",
(u64)"d8",
(u64)"d9",
(u64)"d10",
(u64)"d11",
(u64)"d12",
(u64)"d13",
(u64)"d14",
(u64)"d15",
(u64)"a0",
(u64)"a1",
(u64)"a2",
(u64)"a3",
(u64)"a4",
(u64)"a5",
(u64)"a6",
(u64)"a7",
(u64)"a8",
(u64)"a9",
(u64)"a10",
(u64)"a11",
(u64)"a12",
(u64)"a13",
(u64)"a14",
(u64)"a15",
(u64)"w0",
(u64)"w1",
(u64)"w2",
(u64)"w3",
(u64)"w4",
(u64)"w5",
(u64)"w6",
(u64)"w7",
(u64)"w8",
(u64)"w9",
(u64)"w10",
(u64)"w11",
(u64)"w12",
(u64)"w13",
(u64)"w14",
(u64)"w15",
(u64)"b0",
(u64)"b1",
(u64)"b2",
(u64)"b3",
(u64)"b4",
(u64)"b5",
(u64)"b6",
(u64)"b7",
(u64)"b8",
(u64)"b9",
(u64)"b10",
(u64)"b11",
(u64)"b12",
(u64)"b13",
(u64)"b14",
(u64)"b15",
(u64)"b16",
(u64)"b17",
(u64)"b18",
(u64)"b19",
(u64)"_b20",
(u64)"rax",
(u64)"rbx",
(u64)"rcx",
(u64)"rdx",
(u64)"rsi",
(u64)"rdi",
(u64)"rbp",
(u64)"rsp",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"eax",
(u64)"ebx",
(u64)"ecx",
(u64)"edx",
(u64)"esi",
(u64)"edi",
(u64)"ebp",
(u64)"esp",
(u64)"r8d",
(u64)"r9d",
(u64)"r10d",
(u64)"r11d",
(u64)"r12d",
(u64)"r13d",
(u64)"r14d",
(u64)"r15d",
(u64)"ax",
(u64)"bx",
(u64)"cx",
(u64)"dx",
(u64)"si",
(u64)"di",
(u64)"bp",
(u64)"sp",
(u64)"r8w",
(u64)"r9w",
(u64)"r10w",
(u64)"r11w",
(u64)"r12w",
(u64)"r13w",
(u64)"r14w",
(u64)"r15w",
(u64)"al",
(u64)"bl",
(u64)"cl",
(u64)"dl",
(u64)"ah",
(u64)"bh",
(u64)"ch",
(u64)"dh",
(u64)"sil",
(u64)"dil",
(u64)"bpl",
(u64)"spl",
(u64)"r8b",
(u64)"r9b",
(u64)"r10b",
(u64)"r11b",
(u64)"r12b",
(u64)"r13b",
(u64)"r14b",
(u64)"r15b"}};

static struct $B35 mc_decls_regsizes = {{
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1}};

static struct $B35 mc_decls_regindices = {{
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
0,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
17,
18,
19,
20,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10}};

static struct $B36 mc_decls_xmmregnames = {{
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm14",
(u64)"xmm15"}};

static struct $B37 mc_decls_fregnames = {{
(u64)"st0",
(u64)"st1",
(u64)"st2",
(u64)"st3",
(u64)"st4",
(u64)"st5",
(u64)"st6",
(u64)"st7"}};

static struct $B37 mc_decls_mregnames = {{
(u64)"mmx0",
(u64)"mmx1",
(u64)"mmx2",
(u64)"mmx3",
(u64)"mmx4",
(u64)"mmx5",
(u64)"mmx6",
(u64)"mmx7"}};

static struct $B38 mc_decls_jmpccnames = {{
(u64)"jo",
(u64)"jno",
(u64)"jb",
(u64)"jae",
(u64)"jz",
(u64)"jnz",
(u64)"jbe",
(u64)"ja",
(u64)"js",
(u64)"jns",
(u64)"jp",
(u64)"jnp",
(u64)"jl",
(u64)"jge",
(u64)"jle",
(u64)"jg",
(u64)"jc",
(u64)"jnc"}};

static struct $B26 mc_decls_jmpcccodes = {{
256,
770,
1284,
1798,
2312,
2826,
3340,
3854,
770}};

static struct $B36 mc_decls_setccnames = {{
(u64)"seto",
(u64)"setno",
(u64)"setb",
(u64)"setae",
(u64)"setz",
(u64)"setnz",
(u64)"setbe",
(u64)"seta",
(u64)"sets",
(u64)"setns",
(u64)"setp",
(u64)"setnp",
(u64)"setl",
(u64)"setge",
(u64)"setle",
(u64)"setg"}};

static struct $B3 mc_decls_setcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B36 mc_decls_cmovccnames = {{
(u64)"cmovo",
(u64)"cmovno",
(u64)"cmovb",
(u64)"cmovae",
(u64)"cmovz",
(u64)"cmovnz",
(u64)"cmovbe",
(u64)"cmova",
(u64)"cmovs",
(u64)"cmovns",
(u64)"cmovp",
(u64)"cmovnp",
(u64)"cmovl",
(u64)"cmovge",
(u64)"cmovle",
(u64)"cmovg"}};

static struct $B3 mc_decls_cmovcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B12 mc_decls_segmentnames = {{
(u64)"no_seg",
(u64)"code_seg",
(u64)"idata_seg",
(u64)"zdata_seg",
(u64)"rodata_seg",
(u64)"impdata_seg"}};

static struct $B8 mc_decls_reftypenames = {{
(u64)"extern_ref",
(u64)"fwd_ref",
(u64)"back_ref"}};

static struct $B12 mc_decls_opndnames_ma = {{
(u64)"a_none",
(u64)"a_reg",
(u64)"a_imm",
(u64)"a_mem",
(u64)"a_cond",
(u64)"a_xreg"}};

static struct $B18 mc_decls_pclopnd;
static struct $B39 mc_decls_pclreg;
static struct $B39 mc_decls_pclmode;
static struct $B39 mc_decls_pclcount;
static struct $B39 mc_decls_pclloc;
static struct $B39 mc_decls_pcltempflags;
static struct $B18 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B17 mc_decls_locnames = {{
(u64)"pend",
(u64)"reg",
(u64)"regvar",
(u64)"temp"}};

static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames = {{
(u64)"-",
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm15",
(u64)"xmm15"}};

static struct $B3 mc_decls_callalign;
static struct $B3 mc_decls_callblockret;
static struct $B37 mc_decls_callblocksize;
static struct $B20 mc_decls_callargmode;
static struct $B41 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used = 0;

static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment = 0;

static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B42 mc_decls_regtable;
static struct $B43 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes = 432345564311454723;

static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B18 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs = {{
1,
2,
3,
11,
12,
13}};

static struct $B12 mc_decls_multxregs = {{
1,
2,
3,
4,
5,
6}};

static struct $B22 mc_decls_ploadopx;
static struct $B22 mc_decls_ploadop;
static struct $B24 mc_objdecls_relocnames = {{
(u64)"abs_rel",
(u64)"addr64_rel",
(u64)"addr32_rel",
(u64)"addr32nb_rel",
(u64)"rel32_rel",
(u64)"rel321_rel",
(u64)"rel8_rel"}};

static u64 mc_writegas_asmext = (u64)"asm";

static struct $B42 mc_writegas_nregnames;
static u8 mc_writegas_currseg;
static struct $B20 mc_writegas_strmcl_str;
static struct $B20 mc_writegas_mstropnd_str;
static struct $B20 mc_writegas_strvalue_str;
static struct $B17 mc_writegas_getxregname_str;
static struct $B16 mc_writegas_getdispname_str;
static struct $B36 mc_writegas_gettempname_str;
static struct $B3 mc_writegas_strreg_str;
static struct $B45 cc_cli_passnames = {{
(u64)"load_pass",
(u64)"pp_pass",
(u64)"parse_pass",
(u64)"type_pass",
(u64)"pcl_pass",
(u64)"runpcl_pass",
(u64)"mcl_pass",
(u64)"asm_pass",
(u64)"mx_pass",
(u64)"obj_pass",
(u64)"dll_pass",
(u64)"exe_pass",
(u64)"run_pass"}};

static struct $B45 cc_cli_extnames = {{
(u64)"",
(u64)"i",
(u64)"",
(u64)"",
(u64)"pcl",
(u64)"(int)",
(u64)"asm",
(u64)"asm",
(u64)"mx",
(u64)"obj",
(u64)"dll",
(u64)"exe",
(u64)"(run)"}};

static u8 cc_cli_cc_pass;
static struct $B46 cc_cli_dummy;
static u8 cc_cli_debugmode;
static u64 cc_cli_outfile;
static u64 cc_cli_outext = (u64)"exe";

static i64 cc_cli_cmdskip;
static i64 cc_cli_ttt;
static u8 cc_cli_fverbose = 1;

static u8 cc_cli_fshowincludes = 0;

static u8 cc_cli_dointheaders = 1;

static u8 cc_cli_highmem = 1;

static u8 cc_cli_fshowst;
static u8 cc_cli_fshowstflat;
static u8 cc_cli_fshowast;
static u8 cc_cli_fshowpcl;
static u8 cc_cli_fshowpst;
static u8 cc_cli_fshowmcl;
static u8 cc_cli_fshowss;
static u8 cc_cli_fshowtypes;
static u8 cc_cli_fshowfiles;
static u8 cc_cli_fshowpaths;
static u8 cc_cli_fshowheaders;
static u8 cc_cli_fwriteheaders;
static u8 cc_cli_fshowlog;
static u8 cc_cli_fshowtiming;
static u8 cc_cli_fgendll;
static u8 cc_cli_fstdout;
static u8 cc_cli_fshortnames;
static u8 cc_cli_fwriteerrors = 1;

static u64 cc_cli_entrypointname;
static struct $B47 cc_cli_optionnames = {{
(u64)"load",
(u64)"e",
(u64)"ei",
(u64)"parse",
(u64)"type",
(u64)"p",
(u64)"pi",
(u64)"i",
(u64)"mcl",
(u64)"s",
(u64)"a",
(u64)"c",
(u64)"obj",
(u64)"mx",
(u64)"dll",
(u64)"exe",
(u64)"r",
(u64)"noregs",
(u64)"nopeep",
(u64)"no",
(u64)"noconst",
(u64)"paths",
(u64)"headers",
(u64)"incl",
(u64)"includes",
(u64)"showst",
(u64)"showstflat",
(u64)"showast",
(u64)"showpcl",
(u64)"showpst",
(u64)"showmcl",
(u64)"showss",
(u64)"showtypes",
(u64)"showfiles",
(u64)"time",
(u64)"time2",
(u64)"v",
(u64)"vv",
(u64)"q",
(u64)"cs",
(u64)"ss",
(u64)"h",
(u64)"help",
(u64)"ext",
(u64)"writeheaders",
(u64)"o",
(u64)"stdout",
(u64)"shortnames",
(u64)"norip",
(u64)"himem",
(u64)"options",
(u64)"showil",
(u64)"long64"}};

static struct $B47 cc_cli_optvars = {{
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&pc_decls_fregoptim,
(u64)&pc_decls_fpeephole,
0,
(u64)&pc_decls_fnoconst,
(u64)&cc_cli_fshowpaths,
(u64)&cc_cli_fshowheaders,
0,
(u64)&cc_cli_fshowincludes,
(u64)&cc_cli_fshowst,
(u64)&cc_cli_fshowstflat,
(u64)&cc_cli_fshowast,
(u64)&cc_cli_fshowpcl,
(u64)&cc_cli_fshowpst,
(u64)&cc_cli_fshowmcl,
(u64)&cc_cli_fshowss,
(u64)&cc_cli_fshowtypes,
(u64)&cc_cli_fshowfiles,
(u64)&cc_cli_fshowtiming,
(u64)&cc_cli_fshowtiming,
(u64)&cc_cli_fverbose,
(u64)&cc_cli_fverbose,
(u64)&cc_cli_fverbose,
(u64)&pc_decls_pverbose,
(u64)&pc_decls_pverbose,
0,
0,
(u64)&cc_cli_dointheaders,
(u64)&cc_cli_fwriteheaders,
0,
(u64)&cc_cli_fstdout,
(u64)&cc_cli_fshortnames,
(u64)&cc_cli_highmem,
(u64)&cc_cli_highmem,
0,
(u64)&pc_decls_fshowil,
(u64)&pc_decls_flong64}};

static struct $B48 cc_cli_optvalues = {{
1,
2,
2,
3,
4,
5,
5,
6,
7,
8,
8,
10,
10,
9,
11,
12,
13,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
3,
0,
1,
2,
0,
0,
0,
1,
0,
1,
1,
0,
2,
0,
1,
1}};

static i64 cc_cli_totallines = 0;

static i64 cc_cli_nstringobjects = 0;

static i64 cc_cli_startclock;
static i64 cc_cli_loadtime;
static i64 cc_cli_parsetime;
static i64 cc_cli_pcltime;
static i64 cc_cli_compiletime;
static i64 cc_cli_inittime;
// Istatic skipped:cc_cli.showextrainfo.infotext

static i64 cc_decls_ntypes;
static struct $B49 cc_decls_ttnamedef;
static struct $B50 cc_decls_ttbasetype;
static struct $B49 cc_decls_ttlength;
static struct $B51 cc_decls_ttconst;
static struct $B50 cc_decls_tttarget;
static struct $B50 cc_decls_ttreftype;
static struct $B50 cc_decls_ttconsttype;
static struct $B49 cc_decls_ttsize;
static struct $B51 cc_decls_ttisref;
static struct $B51 cc_decls_ttisblock;
static struct $B51 cc_decls_ttsigned;
static struct $B52 cc_decls_ttshared;
static struct $B49 cc_decls_ttparams;
static struct $B49 cc_decls_tttypedef;
static i64 cc_decls_trefchar;
static i64 cc_decls_trefwchar;
static u64 cc_decls_inputfile;
static i64 cc_decls_mainfileno;
static struct $B53 cc_decls_libfiles;
static struct $B53 cc_decls_sourcefilenames;
static struct $B53 cc_decls_sourcefilepaths;
static struct $B53 cc_decls_sourcefiletext;
static struct $B54 cc_decls_sourcefilesizes;
static i64 cc_decls_nsourcefiles;
static i64 cc_decls_nlibfiles;
static struct $B29 cc_decls_searchdirs;
static i64 cc_decls_nsearchdirs = 0;

static struct $B29 cc_decls_includepaths;
static i64 cc_decls_nincludepaths = 0;

static u64 cc_decls_stprogram;
static u64 cc_decls_stmodule;
static u64 cc_decls_logdev;
static u64 cc_decls_nullunit;
static i64 cc_decls_clineno = 0;

static i64 cc_decls_cfileno = 0;

static struct $B17 cc_decls_lx;
static struct $B17 cc_decls_nextlx;
static i64 cc_decls_debug = 0;

static i64 cc_decls_hstsize = 65536;

static i64 cc_decls_hstmask;
static u64 cc_decls_hashtable;
static struct $B55 cc_decls_blockowner;
static struct $B55 cc_decls_blockcounts;
static struct $B56 cc_decls_blockstack;
static i64 cc_decls_currblockno;
static i64 cc_decls_nextblockno;
static i64 cc_decls_blocklevel;
static u64 cc_decls_currproc;
static u64 cc_decls_dheaderfile = 0;

static i64 cc_decls_structpadding = 1;

static i64 cc_decls_callbackflag = 0;

static i64 cc_decls_slineno;
static i64 cc_decls_sfileno;
static u64 cc_decls_oemname = (u64)"MCC";

static u64 cc_decls_mclstr;
static i64 cc_decls_mclstrlen;
static i64 cc_decls_nunits;
static struct $B57 cc_decls_pmodulelist;
static struct $B58 cc_decls_pheaderlist;
static struct $B58 cc_decls_pliblist;
static i64 cc_decls_npmodules;
static i64 cc_decls_npheaders;
static i64 cc_decls_nplibs;
static u8 cc_decls_pci_target;
static struct $B59 cc_tables_stdtypenames = {{
(u64)"void",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"bool",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"r32",
(u64)"r64",
(u64)"enum",
(u64)"ref",
(u64)"proc",
(u64)"label",
(u64)"block",
(u64)"array",
(u64)"struct",
(u64)"union",
(u64)"notset",
(u64)"tlast"}};

static struct $B60 cc_tables_stdtypewidths = {{
2048,
8208,
2112,
4104,
16416,
16416,
16384,
16448,
0,
0,
0}};

static struct $B60 cc_tables_stdsigned = {{
256,
257,
1,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B60 cc_tables_stdpcl = {{
1792,
2312,
778,
1027,
1541,
513,
1545,
0,
2827,
2827,
0}};

static struct $B60 cc_tables_stdsize = {{
256,
1026,
264,
513,
2052,
2052,
0,
0,
0,
0,
0}};

static struct $B61 cc_tables_catnames = {{
(u64)"voidcat",
(u64)"intcat",
(u64)"realcat",
(u64)"shortcat",
(u64)"blockcat"}};

static struct $B62 cc_tables_typespecnames = {{
(u64)"ts_void",
(u64)"ts_char",
(u64)"ts_short",
(u64)"ts_long",
(u64)"ts_int",
(u64)"ts_float",
(u64)"ts_double",
(u64)"ts_signed",
(u64)"ts_unsigned",
(u64)"ts_bool",
(u64)"ts_user",
(u64)"ts_struct",
(u64)"ts_union",
(u64)"ts_enum",
(u64)"ts_atomic"}};

static struct $B63 cc_tables_typespectypes = {{
0,
1,
0,
0,
3,
10,
11,
0,
0,
5,
0,
0,
0,
0,
0}};

static struct $B64 cc_tables_typespecsizes = {{
0,
1,
2,
4,
4,
4,
8,
0,
0,
1,
0,
0,
0,
4,
0}};

static struct $B17 cc_tables_pmflagnames = {{
(u64)"pm_normal",
(u64)"pm_notset",
(u64)"pm_empty",
(u64)"pm_variadic"}};

static struct $B61 cc_tables_scopenames = {{
(u64)"-",
(u64)"Fn",
(u64)"Loc",
(u64)"Imp",
(u64)"Exp"}};

static struct $B12 cc_tables_cccnames = {{
(u64)"open_cc",
(u64)"own_cc",
(u64)"clang_cc",
(u64)"stdcall_cc",
(u64)"callback_cc",
(u64)"dummy_cc"}};

static struct $B12 cc_tables_linkagenames = {{
(u64)"none_ss",
(u64)"static_ss",
(u64)"auto_ss",
(u64)"register_ss",
(u64)"extern_ss",
(u64)"typedef_ss"}};

static struct $B17 cc_tables_typequalnames = {{
(u64)"const_qual",
(u64)"volatile_qual",
(u64)"restrict_qual",
(u64)"atomic_qual"}};

static struct $B8 cc_tables_fnspecnames = {{
(u64)"inline_fnspec",
(u64)"noreturn_fnspec",
(u64)"callback_fnspec"}};

static struct $B65 cc_tables_jtagnames = {{
(u64)"jnone",
(u64)"jconst",
(u64)"jnull",
(u64)"jname",
(u64)"jwidenmem",
(u64)"jfuncname",
(u64)"jblock",
(u64)"jtempdecl",
(u64)"jdecl",
(u64)"jreturn",
(u64)"jreturnx",
(u64)"jassign",
(u64)"jif",
(u64)"jfor",
(u64)"jwhile",
(u64)"jdowhile",
(u64)"jgoto",
(u64)"jlabelstmt",
(u64)"jcasestmt",
(u64)"jdefaultstmt",
(u64)"jbreak",
(u64)"jcontinue",
(u64)"jswitch",
(u64)"jbreaksw",
(u64)"&& andl",
(u64)"|| orl",
(u64)"! notl",
(u64)"jistruel",
(u64)"jmakelist",
(u64)"jexprlist",
(u64)"jcallfn",
(u64)"jifx",
(u64)"&&",
(u64)"==",
(u64)"!=",
(u64)"<",
(u64)"<=",
(u64)">",
(u64)">=",
(u64)"+ add",
(u64)"- sub",
(u64)"* mul",
(u64)"/ div",
(u64)"% mod",
(u64)"& iand",
(u64)"| ior",
(u64)"^ ixor",
(u64)"<<",
(u64)">>",
(u64)"jdot",
(u64)"jidot",
(u64)"jindex",
(u64)"ptr",
(u64)"addptr",
(u64)"subptr",
(u64)"addrof &",
(u64)"jconvert",
(u64)"jscale",
(u64)"- neg",
(u64)"abs",
(u64)"~ inot",
(u64)"+=",
(u64)"-=",
(u64)"*=",
(u64)"/=",
(u64)"%=",
(u64)"&=",
(u64)"|=",
(u64)"^=",
(u64)"<<=",
(u64)">>=",
(u64)"++ preincr",
(u64)"-- preincr",
(u64)"++ postincr",
(u64)"-- postdecr",
(u64)"setjmp",
(u64)"longjmp",
(u64)"jdummy"}};

static struct $B66 cc_tables_symbolnames = {{
(u64)"errorsym",
(u64)"dotsym",
(u64)"idotsym",
(u64)"lexhashsym",
(u64)"hashsym",
(u64)"lithashsym",
(u64)"hashhashsym",
(u64)"commasym",
(u64)"semisym",
(u64)"colonsym",
(u64)"assignsym",
(u64)"assignsym2",
(u64)"lbracksym",
(u64)"rbracksym",
(u64)"lsqsym",
(u64)"rsqsym",
(u64)"lcurlysym",
(u64)"rcurlysym",
(u64)"questionsym",
(u64)"curlsym",
(u64)"ellipsissym",
(u64)"backslashsym",
(u64)"addsym",
(u64)"subsym",
(u64)"mulsym",
(u64)"divsym",
(u64)"remsym",
(u64)"iorsym",
(u64)"iandsym",
(u64)"ixorsym",
(u64)"orlsym",
(u64)"andlsym",
(u64)"shlsym",
(u64)"shrsym",
(u64)"inotsym",
(u64)"notlsym",
(u64)"incrsym",
(u64)"decrsym",
(u64)"abssym",
(u64)"eqsym",
(u64)"nesym",
(u64)"ltsym",
(u64)"lesym",
(u64)"gesym",
(u64)"gtsym",
(u64)"addtosym",
(u64)"subtosym",
(u64)"multosym",
(u64)"divtosym",
(u64)"remtosym",
(u64)"iortosym",
(u64)"iandtosym",
(u64)"ixortosym",
(u64)"shltosym",
(u64)"shrtosym",
(u64)"eolsym",
(u64)"eofsym",
(u64)"rawnumbersym",
(u64)"intconstsym",
(u64)"realconstsym",
(u64)"charconstsym",
(u64)"wcharconstsym",
(u64)"stringconstsym",
(u64)"wstringconstsym",
(u64)"whitespacesym",
(u64)"placeholdersym",
(u64)"namesym",
(u64)"ksourcedirsym",
(u64)"predefmacrosym",
(u64)"kdeclspecsym",
(u64)"ktypespecsym",
(u64)"kifsym",
(u64)"kelsesym",
(u64)"kcasesym",
(u64)"kdefaultsym",
(u64)"kforsym",
(u64)"kwhilesym",
(u64)"kdosym",
(u64)"kreturnsym",
(u64)"kbreaksym",
(u64)"kcontinuesym",
(u64)"kgotosym",
(u64)"kswitchsym",
(u64)"kstructsym",
(u64)"kunionsym",
(u64)"klinkagesym",
(u64)"ktypequalsym",
(u64)"kstdtypesym",
(u64)"kfnspecsym",
(u64)"kalignassym",
(u64)"kenumsym",
(u64)"ksizeofsym",
(u64)"kdefinedsym",
(u64)"kgenericsym",
(u64)"kalignofsym",
(u64)"ksetjmpsym",
(u64)"kdummysym"}};

static struct $B66 cc_tables_shortsymbolnames = {{
(u64)"",
(u64)".",
(u64)"->",
(u64)"#",
(u64)"#",
(u64)"#",
(u64)"##",
(u64)",",
(u64)";",
(u64)":",
(u64)"=",
(u64)":=",
(u64)"(",
(u64)")",
(u64)"[",
(u64)"]",
(u64)"{",
(u64)"}",
(u64)"?",
(u64)"~",
(u64)"...",
(u64)"\\",
(u64)"+",
(u64)"-",
(u64)"*",
(u64)"/",
(u64)"%",
(u64)"|",
(u64)"&",
(u64)"^",
(u64)"||",
(u64)"&&",
(u64)"<<",
(u64)">>",
(u64)"~",
(u64)"!",
(u64)"++",
(u64)"--",
(u64)"abs",
(u64)"==",
(u64)"!=",
(u64)"<",
(u64)"<=",
(u64)">=",
(u64)">",
(u64)"+=",
(u64)"-=",
(u64)"*=",
(u64)"/=",
(u64)"%=",
(u64)"|=",
(u64)"&=",
(u64)"^=",
(u64)"<<=",
(u64)">>=",
(u64)"",
(u64)"",
(u64)"n",
(u64)"n",
(u64)"n",
(u64)"s",
(u64)"s",
(u64)"s",
(u64)"s",
(u64)"w",
(u64)"",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)""}};

static struct $B67 cc_tables_symboltojtag = {{
0,
49,
50,
0,
0,
0,
0,
0,
0,
0,
11,
11,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
39,
40,
41,
42,
43,
45,
44,
46,
25,
24,
47,
48,
60,
26,
71,
72,
59,
33,
34,
35,
36,
38,
37,
61,
62,
63,
64,
65,
67,
66,
68,
69,
70,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B62 cc_tables_sourcedirnames = {{
(u64)"definedir",
(u64)"emitdir",
(u64)"ifdir",
(u64)"elifdir",
(u64)"elsedir",
(u64)"endifdir",
(u64)"includedir",
(u64)"ifdefdir",
(u64)"ifndefdir",
(u64)"undefdir",
(u64)"errordir",
(u64)"messagedir",
(u64)"blankdir",
(u64)"linedir",
(u64)"pragmadir"}};

static struct $B61 cc_tables_namespacenames = {{
(u64)"ns_none",
(u64)"ns_general",
(u64)"ns_tags",
(u64)"ns_labels",
(u64)"ns_fields"}};

static struct $B62 cc_tables_namenames = {{
(u64)"nullid",
(u64)"macroid",
(u64)"programid",
(u64)"moduleid",
(u64)"extmoduleid",
(u64)"typeid",
(u64)"procid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"fieldid",
(u64)"enumid",
(u64)"enumtagid",
(u64)"structtagid",
(u64)"labelid"}};

static struct $B63 cc_tables_namespaces = {{
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
4,
1,
2,
2,
3}};

static struct $B64 cc_tables_name2pid = {{
0,
0,
0,
0,
0,
0,
2,
3,
4,
5,
0,
0,
0,
0,
6}};

static struct $B20 cc_tables_stnames = {{
(u64)"if",
(u64)"else",
(u64)"case",
(u64)"default",
(u64)"for",
(u64)"do",
(u64)"while",
(u64)"return",
(u64)"break",
(u64)"continue",
(u64)"goto",
(u64)"switch",
(u64)"struct",
(u64)"union",
(u64)"include",
(u64)"define",
(u64)"elif",
(u64)"ifdef",
(u64)"ifndef",
(u64)"endif",
(u64)"undef",
(u64)"error",
(u64)"pragma",
(u64)"line",
(u64)"auto",
(u64)"register",
(u64)"static",
(u64)"extern",
(u64)"typedef",
(u64)"const",
(u64)"volatile",
(u64)"restrict",
(u64)"_Atomic",
(u64)"inline",
(u64)"_Noreturn",
(u64)"_Alignas",
(u64)"enum",
(u64)"void",
(u64)"char",
(u64)"short",
(u64)"long",
(u64)"int",
(u64)"float",
(u64)"double",
(u64)"signed",
(u64)"unsigned",
(u64)"_Bool",
(u64)"__DATE__",
(u64)"__FILE__",
(u64)"__LINE__",
(u64)"__TIME__",
(u64)"__MCC__",
(u64)"__MCCI__",
(u64)"__func__",
(u64)"__FUNCTION__",
(u64)"__declspec",
(u64)"sizeof",
(u64)"lengthof",
(u64)"defined",
(u64)"_Generic",
(u64)"_Alignof",
(u64)"$setjmp",
(u64)"$longjmp",
(u64)"$$dummy"}};

static struct $B16 cc_tables_stsymbols = {{
313532612680,
322122547274,
335007449164,
339302416461,
347892351056,
356482285650,
365072220244,
292057776196,
292057776196,
292057776196,
292057776196,
292057776196,
369367187542,
369367187542,
373662154838,
373662154839,
382252089431,
386547056729,
304942678107,
304942678087,
304942678087,
304942678087,
304942678087,
296352743495,
296352743493,
296352743493,
296352743493,
300647710789,
395136991324,
403726925917,
412316860511,
96}};

static struct $B16 cc_tables_stsubcodes = {{
12,
0,
0,
0,
0,
0,
0,
4294967303,
34359738372,
25769803785,
47244640266,
60129542159,
12884901890,
17179869185,
4294967301,
12884901890,
4294967300,
2,
4294967296,
12884901890,
21474836484,
30064771078,
38654705672,
4294967306,
17179869187,
30064771074,
21474836488,
5,
4294967296,
0,
322122547200,
76}};

static struct $B21 cc_tables_convnames = {{
(u64)"no_conv",
(u64)"soft_c",
(u64)"hard_c",
(u64)"swiden_c",
(u64)"uwiden_c",
(u64)"sfloat_c",
(u64)"ufloat_c",
(u64)"sfix_c",
(u64)"ufix_c",
(u64)"fwiden_c",
(u64)"fnarrow_c",
(u64)"narrow_c",
(u64)"truncate_c",
(u64)"bool_c"}};

static struct $B42 cc_tables_dominantmode;
static struct $B16 cc_tables_conversionops;
static struct $B68 cc_tables_dominantsetuptable = {{
1,
1,
3,
1,
2,
3,
1,
3,
3,
1,
4,
4,
1,
5,
3,
1,
6,
3,
1,
7,
3,
1,
8,
3,
1,
9,
4,
1,
10,
10,
1,
11,
11,
2,
1,
3,
2,
2,
3,
2,
3,
3,
2,
4,
4,
2,
5,
3,
2,
6,
3,
2,
7,
3,
2,
8,
3,
2,
9,
4,
2,
10,
10,
2,
11,
11,
3,
1,
3,
3,
2,
3,
3,
3,
3,
3,
4,
4,
3,
5,
3,
3,
6,
3,
3,
7,
3,
3,
8,
8,
3,
9,
4,
3,
10,
10,
3,
11,
11,
4,
1,
4,
4,
2,
4,
4,
3,
4,
4,
4,
4,
4,
5,
4,
4,
6,
4,
4,
7,
4,
4,
8,
4,
4,
9,
9,
4,
10,
10,
4,
11,
11,
5,
1,
3,
5,
2,
3,
5,
3,
3,
5,
4,
4,
5,
5,
8,
5,
6,
8,
5,
7,
8,
5,
8,
8,
5,
9,
9,
5,
10,
10,
5,
11,
11,
6,
1,
3,
6,
2,
3,
6,
3,
3,
6,
4,
4,
6,
5,
0,
6,
6,
8,
6,
7,
8,
6,
8,
8,
6,
9,
9,
6,
10,
10,
6,
11,
11,
7,
1,
3,
7,
2,
3,
7,
3,
3,
7,
4,
4,
7,
5,
8,
7,
6,
8,
7,
7,
8,
7,
8,
8,
7,
9,
9,
7,
10,
10,
7,
11,
11,
8,
1,
3,
8,
2,
3,
8,
3,
8,
8,
4,
4,
8,
5,
8,
8,
6,
8,
8,
7,
8,
8,
8,
8,
8,
9,
9,
8,
10,
10,
8,
11,
11,
9,
1,
9,
9,
2,
9,
9,
3,
9,
9,
4,
9,
9,
5,
9,
9,
6,
9,
9,
7,
9,
9,
8,
9,
9,
9,
9,
9,
10,
10,
9,
11,
11,
10,
1,
11,
10,
2,
11,
10,
3,
11,
10,
4,
11,
10,
5,
11,
10,
6,
11,
10,
7,
11,
10,
8,
11,
10,
9,
11,
10,
10,
10,
10,
11,
11,
11,
1,
11,
11,
2,
11,
11,
3,
11,
11,
4,
11,
11,
5,
11,
11,
6,
11,
11,
7,
11,
11,
8,
11,
11,
9,
11,
11,
10,
11,
11,
11,
11}};

static struct $B68 cc_tables_convsetuptable = {{
1,
1,
3,
1,
2,
3,
1,
3,
3,
1,
4,
3,
1,
5,
13,
1,
6,
1,
1,
7,
3,
1,
8,
3,
1,
9,
3,
1,
10,
5,
1,
11,
5,
2,
1,
12,
2,
2,
0,
2,
3,
3,
2,
4,
3,
2,
5,
13,
2,
6,
12,
2,
7,
1,
2,
8,
3,
2,
9,
3,
2,
10,
5,
2,
11,
5,
3,
1,
12,
3,
2,
12,
3,
3,
0,
3,
4,
3,
3,
5,
13,
3,
6,
12,
3,
7,
12,
3,
8,
1,
3,
9,
3,
3,
10,
5,
3,
11,
5,
4,
1,
12,
4,
2,
12,
4,
3,
12,
4,
4,
0,
4,
5,
13,
4,
6,
12,
4,
7,
12,
4,
8,
12,
4,
9,
1,
4,
10,
5,
4,
11,
5,
5,
1,
1,
5,
2,
4,
5,
3,
4,
5,
4,
4,
5,
5,
0,
5,
6,
1,
5,
7,
4,
5,
8,
4,
5,
9,
4,
5,
10,
6,
5,
11,
6,
6,
1,
1,
6,
2,
4,
6,
3,
4,
6,
4,
4,
6,
5,
13,
6,
6,
1,
6,
7,
4,
6,
8,
4,
6,
9,
4,
6,
10,
6,
6,
11,
6,
7,
1,
12,
7,
2,
1,
7,
3,
4,
7,
4,
4,
7,
5,
13,
7,
6,
12,
7,
7,
0,
7,
8,
4,
7,
9,
4,
7,
10,
6,
7,
11,
6,
8,
1,
12,
8,
2,
12,
8,
3,
1,
8,
4,
4,
8,
5,
13,
8,
6,
12,
8,
7,
12,
8,
8,
0,
8,
9,
4,
8,
10,
6,
8,
11,
6,
9,
1,
12,
9,
2,
12,
9,
3,
12,
9,
4,
1,
9,
5,
13,
9,
6,
12,
9,
7,
12,
9,
8,
12,
9,
9,
0,
9,
10,
6,
9,
11,
6,
10,
1,
7,
10,
2,
7,
10,
3,
7,
10,
4,
7,
10,
5,
8,
10,
6,
8,
10,
7,
8,
10,
8,
8,
10,
9,
8,
10,
10,
0,
10,
11,
9,
11,
1,
7,
11,
2,
7,
11,
3,
7,
11,
4,
7,
11,
5,
8,
11,
6,
8,
11,
7,
8,
11,
8,
8,
11,
9,
8,
11,
10,
10,
11,
11,
0}};

static struct $B70 cc_tables_badexprs = {{
1,
3,
31,
24,
25,
26,
27,
29,
32,
33,
34,
35,
36,
38,
37,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
58,
59,
60}};

static u64 cc_lex_tkptr = 0;

static i64 cc_lex_dowhitespace = 0;

static i64 cc_lex_nincludes;
static struct $B17 cc_lex_normaltkx;
static u64 cc_lex_normaltk = (u64)&cc_lex_normaltkx;

static i64 cc_lex_noexpand = 0;

static struct $B71 cc_lex_lx_stack;
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel = 0;

static struct $B29 cc_lex_headerpathlist;
static struct $B15 cc_lex_headerpath;
static u64 cc_lex_lxstart;
static u64 cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static u64 cc_lex_lxsvalue;
static struct $B16 cc_lex_alphamap;
static struct $B16 cc_lex_digitmap;
static struct $B16 cc_lex_commentmap;
static struct $B16 cc_lex_linecommentmap;
static struct $B16 cc_lex_spacemap;
static u64 cc_lex_destcopy;
static struct $B72 cc_lex_pastedtokenlist;
static i64 cc_lex_npastedtokens = 0;

static i64 cc_lex_isincludefile = 0;

static i64 cc_lex_firstsymbol = 1;

static u64 cc_lex_reallxsptr;
static i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static struct $B3 cc_lex_lex_preprocess_only_sbuffer;
// Istatic skipped:cc_lex.lex_preprocess_only.dest

static struct $B15 cc_lex_getsourcefile_filespec;
// Istatic skipped:cc_lex.lexm.doreset

static i64 cc_lex_lasttoken = 0;

static struct $B3 cc_lex_showtoken_buffer;
// Istatic skipped:cc_lex.showtoken.dest

static struct $B3 cc_lex_stringify_buffer;
// Istatic skipped:cc_lex.stringify.deststr

// Istatic skipped:cc_lex.expandpredefmacro.monthnames

// Istatic skipped:cc_lex.issimpleconstmacro.specialnames

static u64 cc_parse_ist_symptr;
static struct $B37 cc_parse_looptypestack;
static i64 cc_parse_loopindex;
static struct $B20 cc_parse_casevaluestack;
static u8 cc_parse_ingeneric = 0;

static i64 cc_genpcl_retindex;
static i64 cc_genpcl_initstaticsindex;
static struct $B73 cc_genpcl_loopstack;
static i64 cc_genpcl_loopindex;
static struct $B37 cc_genpcl_zero_unit;
static u64 cc_genpcl_pzero = (u64)&cc_genpcl_zero_unit;

static i64 cc_genpcl_nvarlocals;
static i64 cc_genpcl_nvarparams;
static struct $B20 cc_blockpcl_continuestack;
static struct $B20 cc_blockpcl_breakstack;
static i64 cc_blockpcl_loopindex;
static u64 cc_blockpcl_sw_labeltable;
static u64 cc_blockpcl_sw_valuetable;
static i64 cc_blockpcl_sw_lower;
static i64 cc_blockpcl_sw_ncases;
static u8 cc_blockpcl_sw_defaultseen;
static i64 cc_blockpcl_sw_defaultlabel;
static i64 cc_blockpcl_sw_breaklabel;
static i64 cc_lib_autotypeno = 0;

static i64 cc_lib_nextafindex = 0;

static u64 cc_lib_unitheapptr = 0;

static i64 cc_lib_remainingunits = 0;

static struct $B74 cc_lib_getoptocode_opctotable;
static struct $B17 cc_lib_nextautotype_str;
static struct $B46 cc_lib_getopcjname_str;
static struct $B75 cc_lib_strmode_str;
static struct $B75 cc_lib_strmode2_str;
static struct $B15 cc_lib_typename_str;
static struct $B16 cc_lib_getstname_name;
static u64 cc_support_bytemasks = -9205322385119247871;

static i64 cc_headers_builtinheaders = 1;

static u64 cc_headers_h_assert = (u64)"/* Header assert.h */\r\n\r\n//#define assert(x) 0\r\n#define assert(x)\r\n";

static u64 cc_headers_h_ctype = (u64)"/* Header ctype.h */\r\n\r\nint tolower(int);\r\nint toupper(int);\r\nint isalpha(int);\r\nint isdigit(int);\r\nint isspace(int);\r\nint isalnum(int);\r\nint isupper(int);\r\nint islower(int);\r\n\r\nint isxdigit(int);\r\nint iscntrl(int);\r\nint isgraph(int);\r\nint ispunct(int);\r\nint isprint(int);\r\nint __isascii(int);\r\n#define isascii __isascii\r\n\r\nint __toascii(int);\r\n#define toascii __toascii\r\n";

static u64 cc_headers_h_errno = (u64)"/* Header errno.h */\r\n\r\n#ifndef $errno\r\n#define $errno\r\n\r\nextern int* _errno(void);\r\n#define errno (*_errno())\r\n\r\n#define EPERM 1\r\n#define ENOENT 2\r\n#define ESRCH 3\r\n#define EINTR 4\r\n#define EIO 5\r\n#define ENXIO 6\r\n#define E2BIG 7\r\n#define ENOEXEC 8\r\n#define EBADF 9\r\n#define ECHILD 10\r\n#define EAGAIN 11\r\n#define ENOMEM 12\r\n#define EACCES 13\r\n#define EFAULT 14\r\n#define ENOTBLK 15\r\n#define EBUSY 16\r\n#define EEXIST 17\r\n#define EXDEV 18\r\n#define ENODEV 19\r\n#define ENOTDIR 20\r\n#define EISDIR 21\r\n#define EINVAL 22\r\n#define ENFILE 23\r\n#define EMFILE 24\r\n#define ENOTTY 25\r\n#define ETXTBSY 26\r\n#define EFBIG 27\r\n#define ENOSPC 28\r\n#define ESPIPE 29\r\n#define EROFS 30\r\n#define EMLINK 31\r\n#define EPIPE 32\r\n#define EDOM 33\r\n#define ERANGE 34\r\n#define ENOMSG 35\r\n#define EIDRM 36\r\n#define ECHRNG 37\r\n#define EL2NSYNC 38\r\n#define EL3HLT 39\r\n#define EL3RST 40\r\n#define ELNRNG 41\r\n#define EUNATCH 42\r\n#define ENOCSI 43\r\n#define EL2HLT 44\r\n#define EDEADLK 45\r\n#define ENOLCK 46\r\n#define EBADE 50\r\n#define EBADR 51\r\n#define EXFULL 52\r\n#define ENOANO 53\r\n#define EBADRQC 54\r\n#define EBADSLT 55\r\n#define EDEADLOCK 56\r\n#define EBFONT 57\r\n#define ENOSTR 60\r\n#define ENODATA 61\r\n#define ETIME 62\r\n#define ENOSR 63\r\n#define ENONET 64\r\n#define ENOPKG 65\r\n#define EREMOTE 66\r\n#define ENOLINK 67\r\n#define EADV 68\r\n#define ESRMNT 69\r\n#define ECOMM 70\r\n#define EPROTO 71\r\n#define EMULTIHOP 74\r\n#define ELBIN 75\r\n#define EOVERFLOW 76\r\n#define EBADMSG 77\r\n#define ENOTUNIQ 80\r\n#define EBADFD 81\r\n#define EREMCHG 82\r\n#define ELIBACC 83\r\n#define ELIBBAD 84\r\n#define ELIBSCN 85\r\n#define ELIBMAX 86\r\n#define ELIBEXEC 87\r\n#define ENOSYS 88\r\n#define ENMFILE 89\r\n#define ENOTEMPTY 90\r\n#define ENAMETOOLONG 91\r\n#define EILSEQ 92\r\n#define __ELASTERROR 2000\r\n\r\n#endif\r\n";

static u64 cc_headers_h_fenv = (u64)"/* Header fenv.h */\r\n\r\nint feclearexcept(int);\r\nint fetestexcept(int);\r\n\r\n#define FE_INVALID 1\r\n#define FE_DENORMAL 2\r\n#define FE_INEXACT 32\r\n#define FE_DIVBYZERO 4 \r\n#define FE_OVERFLOW 8\r\n#define FE_UNDERFLOW 16\r\n#define FE_STACKFAULT 64\r\n#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)\r\n";

static u64 cc_headers_h_float = (u64)"/* Header float.h */\r\n\r\n//#define DBL_MAX_10_EXP 308\r\n//#define DBL_MANT_DIG 53\r\n\r\n#define FLT_RADIX 2\r\n\r\n#define FLT_DIG 6\r\n#define FLT_MIN_EXP -125\r\n#define FLT_MIN 1.17549435E-38F // decimal constant\r\n#define FLT_MIN 0X1P-126F // hex constant\r\n#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant\r\n#define FLT_TRUE_MIN 0X1P-149F // hex constant\r\n#define FLT_HAS_SUBNORM 1\r\n#define FLT_MIN_10_EXP -37\r\n#define FLT_MAX_EXP +128\r\n#define FLT_MAX 3.40282347E+38F // decimal constant\r\n#define FLT_MAX 0X1.fffffeP127F // hex constant\r\n#define FLT_MAX_10_EXP +38\r\n#define FLT_EPSILON 1.19209290e-07F\r\n#define FLT_MANT_DIG 23\r\n\r\n#define DBL_MANT_DIG 53\r\n#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant\r\n//#define DBL_EPSILON 0X1P-52 // hex constant\r\n#define DBL_DECIMAL_DIG 17\r\n#define DBL_DIG 15\r\n#define DBL_MIN_EXP -1021\r\n#define DBL_MIN 2.2250738585072014E-308 // decimal constant\r\n//#define DBL_MIN 0X1P-1022 // hex constant\r\n#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant\r\n//#define DBL_TRUE_MIN 0X1P-1074 // hex constant\r\n#define DBL_HAS_SUBNORM 1\r\n#define DBL_MIN_10_EXP -307\r\n#define DBL_MAX_EXP +1024\r\n#define DBL_MAX 1.7976931348623157E+308 // decimal constant\r\n//#define DBL_MAX 0X1.fffffffffffffP1023 // h\r\n#define DBL_MAX_10_EXP +308\r\n\r\n#define LDBL_MIN DBL_MIN\r\n#define LDBL_MAX DBL_MAX\r\n#define LDBL_EPSILON 2.2204460492503131E-16\r\n#define LDBL_MANT_DIG 53\r\n#define LDBL_MIN_EXP -1021\r\n#define LDBL_MAX_EXP +1024\r\n\r\nint     _isnan(double);\r\n#define isnan _isnan\r\n";

static u64 cc_headers_h_inttypes = (u64)"/* Header inttypes.h */\r\n\r\n#include <stdint.h>\r\n\r\n/* fprintf macros for signed types */\r\n#define PRId8 \"d\"\r\n#define PRId16 \"d\"\r\n#define PRId32 \"d\"\r\n#define PRId64 \"I64d\"\r\n\r\n#define PRIdLEAST8 \"d\"\r\n#define PRIdLEAST16 \"d\"\r\n#define PRIdLEAST32 \"d\"\r\n#define PRIdLEAST64 \"I64d\"\r\n\r\n#define PRIdFAST8 \"d\"\r\n#define PRIdFAST16 \"d\"\r\n#define PRIdFAST32 \"d\"\r\n#define PRIdFAST64 \"I64d\"\r\n\r\n#define PRIdMAX \"I64d\"\r\n\r\n#define PRIi8 \"i\"\r\n#define PRIi16 \"i\"\r\n#define PRIi32 \"i\"\r\n#define PRIi64 \"I64i\"\r\n\r\n#define PRIiLEAST8 \"i\"\r\n#define PRIiLEAST16 \"i\"\r\n#define PRIiLEAST32 \"i\"\r\n#define PRIiLEAST64 \"I64i\"\r\n\r\n#define PRIiFAST8 \"i\"\r\n#define PRIiFAST16 \"i\"\r\n#define PRIiFAST32 \"i\"\r\n#define PRIiFAST64 \"I64i\"\r\n\r\n#define PRIiMAX \"I64i\"\r\n\r\n#define PRIo8 \"o\"\r\n#define PRIo16 \"o\"\r\n#define PRIo32 \"o\"\r\n#define PRIo64 \"I64o\"\r\n\r\n#define PRIoLEAST8 \"o\"\r\n#define PRIoLEAST16 \"o\"\r\n#define PRIoLEAST32 \"o\"\r\n#define PRIoLEAST64 \"I64o\"\r\n\r\n#define PRIoFAST8 \"o\"\r\n#define PRIoFAST16 \"o\"\r\n#define PRIoFAST32 \"o\"\r\n#define PRIoFAST64 \"I64o\"\r\n\r\n#define PRIoMAX \"I64o\"\r\n\r\n/* fprintf macros for unsigned types */\r\n#define PRIu8 \"u\"\r\n#define PRIu16 \"u\"\r\n#define PRIu32 \"u\"\r\n#define PRIu64 \"I64u\"\r\n\r\n\r\n#define PRIuLEAST8 \"u\"\r\n#define PRIuLEAST16 \"u\"\r\n#define PRIuLEAST32 \"u\"\r\n#define PRIuLEAST64 \"I64u\"\r\n\r\n#define PRIuFAST8 \"u\"\r\n#define PRIuFAST16 \"u\"\r\n#define PRIuFAST32 \"u\"\r\n#define PRIuFAST64 \"I64u\"\r\n\r\n#define PRIuMAX \"I64u\"\r\n\r\n#define PRIx8 \"x\"\r\n#define PRIx16 \"x\"\r\n#define PRIx32 \"x\"\r\n#define PRIx64 \"I64x\"\r\n\r\n#define PRIxLEAST8 \"x\"\r\n#define PRIxLEAST16 \"x\"\r\n#define PRIxLEAST32 \"x\"\r\n#define PRIxLEAST64 \"I64x\"\r\n\r\n#define PRIxFAST8 \"x\"\r\n#define PRIxFAST16 \"x\"\r\n#define PRIxFAST32 \"x\"\r\n#define PRIxFAST64 \"I64x\"\r\n\r\n#define PRIxMAX \"I64x\"\r\n\r\n#define PRIX8 \"X\"\r\n#define PRIX16 \"X\"\r\n#define PRIX32 \"X\"\r\n#define PRIX64 \"I64X\"\r\n\r\n#define PRIXLEAST8 \"X\"\r\n#define PRIXLEAST16 \"X\"\r\n#define PRIXLEAST32 \"X\"\r\n#define PRIXLEAST64 \"I64X\"\r\n\r\n#define PRIXFAST8 \"X\"\r\n#define PRIXFAST16 \"X\"\r\n#define PRIXFAST32 \"X\"\r\n#define PRIXFAST64 \"I64X\"\r\n\r\n#define PRIXMAX \"I64X\"\r\n\r\n";

static u64 cc_headers_h_stdint = (u64)"/* Header stdint.h */\r\n\r\n#ifndef $stdint\r\n#define $stdint\r\n\r\ntypedef signed char int8_t;\r\ntypedef short int16_t;\r\ntypedef int int32_t;\r\ntypedef long long int int64_t;\r\n\r\ntypedef unsigned char uint8_t;\r\ntypedef unsigned short uint16_t;\r\ntypedef unsigned int uint32_t;\r\ntypedef unsigned long long int uint64_t;\r\n\r\ntypedef long long int intptr_t;\r\ntypedef unsigned long long int uintptr_t;\r\ntypedef long long intmax_t;\r\ntypedef unsigned long long uintmax_t;\r\n\r\ntypedef char int_least8_t;\r\ntypedef unsigned char uint_least8_t;\r\ntypedef short int_least16_t;\r\ntypedef unsigned short uint_least16_t;\r\ntypedef int int_least32_t;\r\ntypedef unsigned int uint_least32_t;\r\ntypedef long long int_least64_t;\r\ntypedef unsigned long long uint_least64_t;\r\n\r\n#define INTMAX_C(a) (a##LL)\r\n#define UINTMAX_C(a) (a##ULL)\r\n\r\ntypedef char int_fast8_t;\r\ntypedef unsigned char uint_fast8_t;\r\ntypedef short int_fast16_t;\r\ntypedef unsigned short uint_fast16_t;\r\ntypedef int int_fast32_t;\r\ntypedef unsigned int uint_fast32_t;\r\ntypedef long long int_fast64_t;\r\ntypedef unsigned long long uint_fast64_t;\r\n\r\n\r\n#define INT8_MIN -128\r\n#define INT8_MAX 127\r\n#define INT16_MIN -32768\r\n#define INT16_MAX 32767\r\n#define INT32_MIN 0x80000000\r\n#define INT32_MAX 0x7FFFFFFF\r\n#define INT64_MIN 0x8000000000000000\r\n#define INT64_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define UINT8_MAX 255\r\n#define UINT16_MAX 65535\r\n#define UINT32_MAX 0xFFFFFFFF\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define INTPTR_MIN 0x8000000000000000\r\n#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF\r\n#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n#define SIZE_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define PTRDIFF_MIN 0x8000000000000000\r\n#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define WCHAR_MIN 0\r\n#define WCHAR_MAX 65535\r\n\r\n#define WINT_MIN 0\r\n#define WINT_MAX 65535\r\n\r\n#define UINT64_C(x) (x##ull)\r\n\r\n#endif\r\n";

static u64 cc_headers_h_limits = (u64)"/* Header limits.h */\n\n#define CHAR_BIT 8\n\n#define CHAR_MIN 0\n#define CHAR_MAX 255\n\n#define UCHAR_MIN 0\n#define UCHAR_MAX 255\n\n#define SCHAR_MIN -128\n#define SCHAR_MAX 127\n\n#define SHRT_MIN -32768\n#define SHRT_MAX 32767\n\n#define USHRT_MIN 0\n#define USHRT_MAX 65535\n\n#define INT_MIN -2147483648\n#define INT_MAX  2147483647\n\n#define UINT_MIN 0\n#define UINT_MAX 4294967295\n\n#define LONG_MIN -2147483648\n#define LONG_MAX  2147483647\n\n#define ULONG_MIN 0\n#define ULONG_MAX 4294967295\n\n#define LLONG_MIN -9223372036854775808LL\n#define LLONG_MAX  9223372036854775807LL\n\n#define ULLONG_MIN 0\n#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL\n\n#define SIZE_MAX ULLONG_MAX\n";

static u64 cc_headers_h_locale = (u64)"/* Header locale.h */\r\n\r\n#ifndef $locale\r\n#define $locale\r\n\r\n#define LC_ALL 0\r\n#define LC_COLLATE 1\r\n#define LC_CTYPE 2\r\n#define LC_MONETARY 3\r\n#define LC_NUMERIC 4\r\n#define LC_TIME 5\r\n\r\nstruct lconv {\r\n\tchar *decimal_point;\r\n\tchar *thousands_sep;\r\n\tchar *grouping;\r\n\tchar *int_curr_symbol;\r\n\tchar *currency_symbol;\r\n\tchar *mon_decimal_point;\r\n\tchar *mon_thousands_sep;\r\n\tchar *mon_grouping;\r\n\tchar *positive_sign;\r\n\tchar *negative_sign;\r\n\tchar int_frac_digits;\r\n\tchar frac_digits;\r\n\tchar p_cs_precedes;\r\n\tchar p_sep_by_space;\r\n\tchar n_cs_precedes;\r\n\tchar n_sep_by_space;\r\n\tchar p_sign_posn;\r\n\tchar n_sign_posn;\r\n};\r\nchar *setlocale(int category, const char *locale);\r\n\r\nstruct lconv *localeconv(void);\r\n\r\nchar * setlocale(int,const char *);\r\n#endif\r\n";

static u64 cc_headers_h__ansi = (u64)"/* Header _ansi.h */\r\n";

static u64 cc_headers_h_math = (u64)"/* Header math.h */\n\n#define HUGE_VAL 1.7976931348623156e+308\n\ndouble floor(double);\ndouble ceil(double);\ndouble sqrt(double);\ndouble sin(double);\ndouble cos(double);\ndouble tan(double);\ndouble fmod(double,double);\ndouble asin(double);\ndouble acos(double);\ndouble atan(double);\ndouble log(double);\ndouble log10(double);\ndouble exp(double);\ndouble modf(double,double*);\ndouble atan2(double,double);\ndouble pow(double,double);\ndouble fabs(double);\ndouble sinh(double);\ndouble cosh(double);\ndouble tanh(double);\ndouble frexp(double,int*);\ndouble ldexp(double,int);\nint isnan(double);\n\n#define ldexpl ldexp\n\nfloat sinf(float);\nfloat cosf(float);\nfloat tanf(float);\nfloat expf(float);\nfloat powf(float, float);\nfloat logf(float);\n\nfloat sqrtf(float);\nfloat acosf(float);\nfloat atan2f(float,float);\nfloat ceilf(float);\n\ndouble acosh (double);\nlong double acoshl(long double);\nlong double acoshl(long double);\nfloat acoshf(float);\n\ndouble asinh (double);\nlong double asinhl(long double);\nlong double sinhl(long double);\nfloat asinhf(float);\n\ndouble atanh(double);\nlong double atanhl(long double);\nfloat atanhf(float);\n\nlong double expm1l(long double);\ndouble expm1(double);\nfloat expm1f(float);\ndouble _expm1i(int);\n\ndouble cbrt(double);\nlong double cbrtl(long double);\nfloat cbrtf(float);\n\ndouble trunc(double x);\nlong double truncl(long double);\nfloat truncf(float);\n\ndouble round(double);\nfloat roundf(float);\nlong double roundl(long double);\ndouble _roundi(int);\n\nlong double fminl(long double,long double);\nfloat fminf(float ,float);\ndouble fmin(double,double);\n\n//float fabsf(float);\n#define fabsf fabs\n\ndouble lgamma (double);\nlong double lgammal(long double);\nfloat lgammaf(float);\n\nlong double tgammal(long double);\ndouble tgamma(double);\nfloat tgammaf(float);\n\ndouble log1p(double);\nlong double log1pl(long double);\nfloat log1pf(float);\n\nlong double log10l(long double);\nfloat log10f(float);\ndouble _log10i(int);\ndouble log10(double);\n\ndouble erf(double);\nlong double erfl(long double);\nfloat erff(float);\n\ndouble hypot (double, double);\ndouble _hypot(double,double);\nlong double hypotl(long double,long double);\nfloat hypotf(float,float);\n\ndouble nextafter (double, double);\nlong double nextafterl(long double,long double);\nfloat nextafterf(float,float);\n\ndouble nexttoward(double,long double);\nlong double nexttowardl(long double,long double);\nfloat nexttowardf(float,long double);\n\ndouble erfc(double);\nlong double erfcl(long double);\nfloat erfcf(float);\n\nint _finite(double);\n#define finite _finite\n\nfloat floorf(float);\n\ndouble _copysign(double,double);\n#define copysign _copysign\n\nlong double fmaxl(long double,long double);\ndouble fmax(double,double);\nfloat fmaxf(float,float);\nfloat fmodf(float,float);\n\n//long double exp2l(long double);\ndouble exp2(double);\nfloat exp2f(float);\n\n//double log2(double);\n#define log2(x) (log(x)*1.442695041)\n\n#define M_PI 3.1415926535897932384625433\n#define M_PI_2 (M_PI/2.0)\n#define M_2_PI 0.63661977236758134308\n\nint isinf(double);\n\nint _finite(double);\n\n#define isfinite _finite\n\nint isfinitef(float);\nint isfinitel(long double);\n\n";

static u64 cc_headers_h_setjmp = (u64)"/* Header setjmp.h */\n\n\n#ifndef $setjmphdr\n#define $setjmphdr 1\n\ntypedef int jmp_buf[128];\n\n//void $mcclongjmp(jmp_buf, int);\n//int $mccsetjmp(jmp_buf);\n\n#define setjmp $setjmp\n#define longjmp $longjmp\n\n#endif\n\n";

static u64 cc_headers_h_signal = (u64)"/* Header signal.h */\r\n\r\n#define SIGINT    2\r\n#define SIGILL    4\r\n#define SIGFPE    8\r\n#define SIGSEGV  11\r\n#define SIGTERM  15\r\n#define SIGBREAK 21\r\n#define SIGABRT  22\r\n\r\n#define SIG_DFL (void (*)(int))0\r\n#define SIG_IGN (void (*)(int))1\r\n#define SIG_SGE (void (*)(int))3\r\n#define SIG_ACK (void (*)(int))4\r\n\r\n#define SIG_ERR (void (*)(int))-1\r\n\r\nextern void (*signal(int, void (*)(int)))(int);\r\n\r\nextern int raise(int);\r\n\r\n\r\ntypedef int sig_atomic_t;\r\n";

static u64 cc_headers_h_stdarg = (u64)"/* Header stdarg.h */\n\n#ifndef $STDARG\n #define $STDARG\n\n//coded for x64 target as used by mcc (with first four params also on stack)\n\n typedef char *\tva_list;\n\n #if __MCCI__\n  #define va_start(ap,v) ap=((va_list)&v-8)\n  #define va_arg(ap,t) *(t*)((ap-=8)+8)\n  #define va_copy(dest,src) (dest=src)\n  #define va_end(ap)\t( ap = (va_list)0 )\n\n #else\n  #define va_start(ap,v) ap=((va_list)&v+8)\n  #define va_arg(ap,t) *(t*)((ap+=8)-8)\n  #define va_copy(dest,src) (dest=src)\n  #define va_end(ap)\t( ap = (va_list)0 )\n\n #endif\n\n#endif\n";

static u64 cc_headers_h_stdbool = (u64)"/* Header stdbool.h */\r\n\r\n#define bool unsigned char\r\n#define true 1\r\n#define false 0\r\n\r\n\r\n";

static u64 cc_headers_h_stddef = (u64)"/* Header stddef.h */\r\n\r\n#ifndef $stddef\r\n#define $stddef\r\n\r\ntypedef signed long long int ssize_t;\r\ntypedef unsigned long long int size_t;\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\n#define NULL ((void*)0)\r\n\r\n#define offsetof(a,b) (size_t) &( ((a*)0) -> b)\r\n\r\ntypedef long long int ptrdiff_t;\r\n\r\n#endif // stddef\r\n";

static u64 cc_headers_h_stdio = (u64)"/* Header stdio.h */\n\n#ifndef $stdio\n#define $stdio 1\n\n#define __attribute__(x)\n\n#ifndef $valist\n\ttypedef char* va_list;\n\t#define $valist\n#endif\n\n#include <stddef.h>\n\ntypedef long long int fpos_t;\n\n#define SEEK_SET 0\n#define SEEK_CUR 1\n#define SEEK_END 2\n\n#define\tSTDIN_FILENO\t0\n#define\tSTDOUT_FILENO\t1\n#define\tSTDERR_FILENO\t2\n\n#define EOF (-1)\n#define FILENAME_MAX 260\n\n#define L_tmpnam 10\n\ntypedef struct {\n\tchar *_ptr;\n\tint   _cnt;\n\tchar *_base;\n\tint   _flag;\n\tint   _file;\n\tint   _charbuf;\n\tint   _bufsiz;\n\tchar *_tmpfname;\n} FILE;\n\nextern char* __iob_func(void);\n\n#define stdin ((FILE*)(__iob_func()))\n#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))\n#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))\n\n#define _IOREAD 0x0001\n#define _IOWRT 0x0002\n\n#define _IOFBF 0x0000\n#define _IOLBF 0x0040\n#define _IONBF 0x0004\n\n#define _IOMYBUF 0x0008\n#define _IOEOF 0x0010\n#define _IOERR 0x0020\n#define _IOSTRG 0x0040\n#define _IORW 0x0080\n\n#define BUFSIZ 512\n\nFILE* fopen(const char*, const char*);\nint fclose(FILE*);\nlong ftell(FILE*);\n//long long int _ftelli64(FILE*);\nint fseek(FILE*,long,int);\nint _fseeki64(FILE*,long long int,int);\n\nsize_t fread(void*, size_t, size_t, FILE*);\nsize_t fwrite(const void*, size_t, size_t, FILE*);\nint remove(const char*);\nint rename(const char *,const char *);\nFILE* freopen(const char*, const char*, FILE*);\nFILE* _wfopen(const wchar_t*,const wchar_t *);\n\nint printf(const char*, ...);\nint sprintf(char*,const char*, ...);\nint fprintf(FILE*,const char*, ...);\nint sscanf(const char*, const char*, ...);\nint scanf(const char*, ...);\nint fscanf(FILE *,const char *, ...);\nint _snprintf(char *,size_t,const char*,...);\n#define snprintf _snprintf\nint _vsnprintf(char*, size_t, const char*, va_list);\nint vsnprintf(char*,size_t,const char*,va_list);\nint vsprintf(char*, const char*, va_list);\nint _wremove(const wchar_t*);\nint _wrename(const wchar_t*,const wchar_t*);\n\ntypedef char* va_list;\n\nint vfprintf(FILE*, const char*, va_list);\nint vprintf(const char*, va_list);\n\nint puts(const char*);\nchar* fgets(char*, int, FILE*);\nint fputs(const char*, FILE*);\nint fgetc(FILE*);\nint fputc(int, FILE*);\nint ungetc(int, FILE*);\nint getchar(void);\nint putchar(int);\nint fflush(FILE *);\nint getc(FILE *);\nint putc(int, FILE *);\n\nint feof(FILE*);\nint ferror(FILE*);\nvoid clearerr(FILE*);\n\nint fileno(FILE*);\nint _fileno(FILE*);\nint setvbuf(FILE*,char*,int,size_t);\nFILE* _popen(const char*, const char*);\nint _pclose(FILE*);\nint _unlink(const char *);\n#define unlink _unlink;\nFILE* _fdopen(int, const char *);\n#define fdopen _fdopen\nint fgetpos(FILE*, fpos_t*);\nint fsetpos(FILE*, const fpos_t*);\nvoid perror(char*);\nvoid setbuf(FILE*, char*);\n\nvoid rewind(FILE*);\n\nFILE* tmpfile(void);\n\nchar* tmpnam(char*);\nwchar_t getwc(FILE *);\n\nextern void* _wenviron;\n\n#endif\n\n";

static u64 cc_headers_h_stdlib = (u64)"/* Header stdlib.h */\n\n#ifndef $stdlib\n#define $stdlib 1\n\n#include <stddef.h>\n\n#define EXIT_FAILURE 1\n#define EXIT_SUCCESS 0\n\n#define RAND_MAX 32767\n\nvoid* malloc(size_t);\nvoid* realloc(void*, size_t);\nvoid* calloc(size_t, size_t);\n\nvoid free(void*);\n\nvoid exit(int);\n\nint system(const char*);\nint _wsystem(const wchar_t*);\n\nint abs(int);\nlong labs(long);\nlong long llabs(long);\nint rand(void);\nvoid srand(unsigned int);\nint atoi(const char*);\nlong atol(const char*);\nlong long atoll(const char*);\nlong long atoi64(const char*);\ndouble atof(const char *);\nint\tatexit(void (*)(void));\nchar *_itoa(int,char *,int);\n\n#define itoa _itoa\n\nvoid qsort(void*, size_t, size_t, int (*)(void*, void*));\n\ntypedef struct {\n\tlong long int quot;\n\tlong long int rem;\n} lldiv_t;\n\nlldiv_t lldiv(long long int, long long int);\n\nchar* getenv(const char*);\nwchar_t* _wgetenv(const wchar_t*);\nint _wputenv(const wchar_t*);\n\n\ndouble strtod(const char*, char**);\n\n//float strtof(const char *, char**);\n#define strtof strtod\n\nlong double strtold(const char*, char**);\nvoid abort(void);\nlong int strtol(const char*, char**, int);\n\nlong double strtold(const char *,char **);\n\nlong long int _strtoi64(const char *,char **,int);\n#define strtoll _strtoi64\n\nunsigned long long int _strtoui64(const char *,char **,int);\n\nunsigned long long int _strtoui64(const char*, char**, int);\n#define strtoull _strtoui64\nunsigned long strtoul(const char*, char**, int);\n\nsize_t _msize(void *);\n#define msize _msize\n\nvoid* bsearch(const void *,const void *, size_t, size_t,\n\t\tint (*_compar)(const void *,const void *));\n\n\nchar* _fullpath(char*, const char*, size_t);\n\n\n#endif\n";

static u64 cc_headers_h__syslist = (u64)"/* Header _syslist.h */\r\n";

static u64 cc_headers_h_string = (u64)"/* Header string.h */\n\n#include <stddef.h>\n\nvoid* memcpy(void*, const void*, size_t);\nvoid* memmove(const void*, const void*, size_t);\nvoid* memset(void*, int, size_t);\nint memcmp(const void*, const void*, size_t);\nvoid* memchr(const void *, int, size_t);\n\nsize_t strlen(const char*);\nchar* strcpy(char*, const char*);\nchar* strncpy(char*, const char*, size_t);\nchar* strcat(char*, const char*);\nint strcmp(const char*, const char*);\nint strncmp(const char*, const char*, size_t);\nchar* strchr(const char*, int);\nchar* strstr(const char*, const char*);\nchar* strrchr(const char*, int);\nint _stricmp(const char*, const char*);\n#define stricmp _stricmp\n#define strcasecmp _stricmp\n\n\n\nint _strnicmp(const char*, const char*, size_t);\n#define strnicmp _strnicmp\nchar* strncat(char*, const char*, size_t);\nchar* strtok(char*, const char*);\n\nsize_t strcspn(const char*, const char*);\nsize_t strspn(const char*, const char*);\nint strcoll(const char *, const char *);\n\nunsigned long strtoul(const char*, char**, int);\n\nchar* strerror(int);\nchar* strpbrk(const char*, const char*);\nsize_t strxfrm(char*, const char *, size_t);\n\nchar* _strupr(char*);\nchar* _strlwr(char*);\n#define strupr _strupr\n#define strlwr _strlwr\n\nchar*strnupr(char*,size_t);\nchar*strnlwr(char*,size_t);\nint strtrim(char*);\nchar*strrev(char*);\n\nchar* _strdup(const char*);\n#define strdup _strdup\n\nint _wcsicmp(const wchar_t *,const wchar_t *);\n\nwchar_t *wcspbrk(const wchar_t*,const wchar_t*);\n\nsize_t wcslen(const wchar_t*);\n";

static u64 cc_headers_h_time = (u64)"/* Header time.h */\r\n\r\n#ifndef $time\r\n#define $time\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long clock_t;\r\nclock_t clock(void);\r\n\r\n//typedef long time_t;\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\ntypedef long long int time_t;\r\n#endif\r\n\r\nstruct tm\r\n{\r\n  int\ttm_sec;\r\n  int\ttm_min;\r\n  int\ttm_hour;\r\n  int\ttm_mday;\r\n  int\ttm_mon;\r\n  int\ttm_year;\r\n  int\ttm_wday;\r\n  int\ttm_yday;\r\n  int\ttm_isdst;\r\n};\r\n\r\n//struct tm *localtime(time_t*);\r\nstruct tm* _localtime32(time_t*);\r\n#define localtime _localtime32\r\n\r\ntime_t _time64(time_t *_timer);\r\n#define time _time64\r\n\r\n#define CLOCKS_PER_SEC 1000\r\n\r\nstruct tm *gmtime(const time_t*);\r\nsize_t strftime(char *, size_t, const char *, const struct tm *);\r\ntime_t mktime(struct tm *);\r\ndouble difftime(time_t, time_t);\r\n\r\nchar* asctime(const struct tm*);\r\n//char* ctime(const time_t *_time);\r\nchar* _ctime64(const time_t *_time);\r\n#define ctime _ctime64\r\n\r\n#endif\r\n";

static u64 cc_headers_h_utime = (u64)"/* sys/utime.h header */\n\n#ifndef $utime\n#define $utime\n\nstruct _utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\n\nstruct utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\nstruct __utimbuf64 {\n  long long int actime;\n  long long int modtime;\n};\n\nint _utime64(const char *_Filename,struct __utimbuf64 *_Time);\n\nint utime(const char *_Filename,struct utimbuf *_Utimbuf) {\n  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);\n}\n\n#endif\n";

static u64 cc_headers_h_unistd = (u64)"/* unistd.h header */\r\n\r\nunsigned int _sleep(unsigned int);\r\n#define sleep _sleep\r\n\r\n#define alarm(x) {puts(\"ALARM\"); exit(1);}\r\n\r\nint _write(int,void*,unsigned int);\r\n#define write _write\r\n\r\nint _close(int);\r\n#define close _close\r\n";

static u64 cc_headers_h_safelib = (u64)"/* Header safelib.h */\r\n";

static u64 cc_headers_h_wchar = (u64)"/* Header wchar.h */\r\n\r\n#include <stddef.h>\r\n\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wint_t;\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\nsize_t wcslen(const wchar_t*);\r\nwchar_t* wcscpy(wchar_t*,const wchar_t*);\r\n//wchar_t* _wgetenv(constwchar_t*);\r\nwchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);\r\nwchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);\r\n\r\nwchar_t* wcschr(wchar_t*,wchar_t);\r\nwchar_t* wcsstr(const wchar_t*,const wchar_t*);\r\n\r\n\r\nint wcscmp(const wchar_t*,const wchar_t*);\r\ntypedef long _off_t;\r\n";

static u64 cc_headers_h_wctype = (u64)"/* Header wctype.h */\r\n";

static u64 cc_headers_h_systypes = (u64)"/* types.h */\r\n#ifndef $systypes\r\n#define $systypes 1\r\n\r\ntypedef long int off_t;\r\ntypedef long int ino_t;\r\ntypedef unsigned int dev_t;\r\n\r\ntypedef long long time_t;\r\n\r\n#endif\r\n";

static u64 cc_headers_h_sysstat = (u64)"/* stat.h */\r\n\r\n#ifndef $sysstat\r\n#define $sysstat\r\n\r\n#include <stddef.h>\r\n\r\nstruct _stat {\r\n\tunsigned int\tst_dev;\r\n\tunsigned short\tst_ino;\r\n\tunsigned short\tst_mode;\r\n\tshort\t\t\tst_nlink;\r\n\tshort\t\t\tst_uid;\r\n\tshort\t\t\tst_gid;\r\n\tunsigned long\tst_rdev;\r\n\tunsigned int\tst_size;\r\n\tunsigned long long int\tst_atime;\r\n\tunsigned long long int\tst_mtime;\r\n\tunsigned long long int\tst_ctime;\r\n};\r\n\r\n#define stat _stat\r\n#define _stati64 _stat\r\n\r\n#define _S_IFMT 0xF000\r\n#define _S_IFDIR 0x4000\r\n#define _S_IFCHR 0x2000\r\n#define _S_IFIFO 0x1000\r\n#define _S_IFREG 0x8000\r\n#define _S_IREAD 0x0100\r\n#define _S_IWRITE 0x0080\r\n#define _S_IEXEC 0x0040\r\n\r\n#define S_IFMT 0xF000\r\n#define S_IFDIR 0x4000\r\n#define S_IFCHR 0x2000\r\n#define S_IFIFO 0x1000\r\n#define S_IFREG 0x8000\r\n#define S_IREAD 0x0100\r\n#define S_IWRITE 0x0080\r\n#define S_IEXEC 0x0040\r\n\r\n#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)\r\n#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)\r\n#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)\r\n#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)\r\n\r\n\r\n#define\t_S_IRWXU\t(_S_IREAD | _S_IWRITE | _S_IEXEC)\r\n#define\t_S_IXUSR\t_S_IEXEC\r\n#define\t_S_IWUSR\t_S_IWRITE\r\n\r\n#define\tS_IRWXU\t\t_S_IRWXU\r\n#define\tS_IXUSR\t\t_S_IXUSR\r\n#define\tS_IWUSR\t\t_S_IWUSR\r\n#define\tS_IRUSR\t\t_S_IRUSR\r\n#define\t_S_IRUSR\t_S_IREAD\r\n\r\n#define S_IRGRP    (S_IRUSR >> 3)\r\n#define S_IWGRP    (S_IWUSR >> 3)\r\n#define S_IXGRP    (S_IXUSR >> 3)\r\n#define S_IRWXG    (S_IRWXU >> 3)\r\n\r\n#define S_IROTH    (S_IRGRP >> 3)\r\n#define S_IWOTH    (S_IWGRP >> 3)\r\n#define S_IXOTH    (S_IXGRP >> 3)\r\n#define S_IRWXO    (S_IRWXG >> 3)\r\n\r\n//#define\tS_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\r\n//#define\tS_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\r\n//#define\tS_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\r\n#define\tS_IFBLK\t0x3000\t/* Block: Is this ever set under w32? */\r\n#define\tS_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\r\n#define\tS_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\r\n\r\n\r\n\r\nint stat(const char *, struct stat*);\r\n\r\nint _fstati64(int, struct stat*);\r\n\r\nint fstat(int, struct stat *);\r\n#define _fstat fstat\r\n\r\nint _wstati64(const wchar_t,struct _stati64 *buffer);  \r\n\r\n\r\n\r\n#endif\r\n";

static u64 cc_headers_h_systimeb = (u64)"/* timeb.h */\r\n\r\n#ifndef $timeb\r\n#define $timeb\r\n\r\n#include <time.h>\r\n\r\nstruct _timeb {\r\n\ttime_t time;\r\n\tunsigned short millitm;\r\n\tshort timezone;\r\n\tshort dstflag;\r\n};\r\n#define timeb _timeb\r\n\r\nvoid _ftime64(struct _timeb*);\r\n#define _ftime _ftime64\r\n#define ftime _ftime64\r\n\r\n#endif\r\n";

static u64 cc_headers_h_sysutime = (u64)"/* sys/utime.h header */\n\n#ifndef $utime\n#define $utime\n\nstruct _utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\n\nstruct utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\nstruct __utimbuf64 {\n  long long int actime;\n  long long int modtime;\n};\n\nint _utime64(const char *_Filename,struct __utimbuf64 *_Time);\n\nint utime(const char *_Filename,struct utimbuf *_Utimbuf) {\n  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);\n}\n\n#endif\n";

static u64 cc_headers_h_memory = (u64)"#include <malloc.h>\r\n";

static u64 cc_headers_h_fcntl = (u64)"/* FCNTL.H */\r\n\r\nint _setmode(int,int);\r\n\r\n#ifndef _INC_FCNTL\r\n#define _INC_FCNTL\r\n\r\n#define _O_RDONLY 0x0000\r\n#define _O_WRONLY 0x0001\r\n#define _O_RDWR 0x0002\r\n#define _O_APPEND 0x0008\r\n#define _O_CREAT 0x0100\r\n#define _O_TRUNC 0x0200\r\n#define _O_EXCL 0x0400\r\n#define _O_TEXT 0x4000\r\n#define _O_BINARY 0x8000\r\n#define _O_WTEXT 0x10000\r\n#define _O_U16TEXT 0x20000\r\n#define _O_U8TEXT 0x40000\r\n#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)\r\n\r\n#define _O_RAW _O_BINARY\r\n#define _O_NOINHERIT 0x0080\r\n#define _O_TEMPORARY 0x0040\r\n#define _O_SHORT_LIVED 0x1000\r\n\r\n#define _O_SEQUENTIAL 0x0020\r\n#define _O_RANDOM 0x0010\r\n\r\n#if !defined(NO_OLDNAMES) || defined(_POSIX)\r\n#define O_RDONLY _O_RDONLY\r\n#define O_WRONLY _O_WRONLY\r\n#define O_RDWR _O_RDWR\r\n#define O_APPEND _O_APPEND\r\n#define O_CREAT _O_CREAT\r\n#define O_TRUNC _O_TRUNC\r\n#define O_EXCL _O_EXCL\r\n#define O_TEXT _O_TEXT\r\n#define O_BINARY _O_BINARY\r\n#define O_RAW _O_BINARY\r\n#define O_TEMPORARY _O_TEMPORARY\r\n#define O_NOINHERIT _O_NOINHERIT\r\n#define O_SEQUENTIAL _O_SEQUENTIAL\r\n#define O_RANDOM _O_RANDOM\r\n#define O_ACCMODE _O_ACCMODE\r\n#endif\r\n\r\n#endif\r\n";

static u64 cc_headers_h_io = (u64)"\r\n#ifndef $io\r\n#define $io\r\n\r\n#include <stdint.h>\r\n#include <wchar.h>\r\n#include <time.h>\r\n\r\n/* io.h */\r\n\r\n#define _A_NORMAL 0x00\r\n#define _A_RDONLY 0x01\r\n#define _A_HIDDEN 0x02\r\n#define _A_SYSTEM 0x04\r\n#define _A_SUBDIR 0x10\r\n#define _A_ARCH 0x20\r\n\r\n\r\n//#message \"IO included\"\r\nstruct _finddata_t {\r\n        unsigned    attrib;\r\n        time_t      time_create;\r\n        time_t      time_access;\r\n        time_t      time_write;\r\n        unsigned long    size;\r\n        char        name[260];\r\n};\r\n\r\nint _isatty(int);\r\n\r\nint _read(int, void*, unsigned int);\r\n#define read _read\r\n\r\nint _open(const char*, int, ...);\r\n#define open _open\r\n\r\nlong _lseek(int, long, int);\r\n#define lseek _lseek\r\n\r\nint _close(int);\r\n#define close _close\r\n\r\nintptr_t _get_osfhandle(int);\r\nint _open_osfhandle(intptr_t,int);\r\n\r\nint _setmode(int,int);\r\n#define setmode _setmode\r\n\r\nint _wchmod(const wchar_t*, int);\r\n\r\nint _chmod(const char *, int);\r\n#define chmod _chmod\r\n\r\nint _dup(int);\r\n#define dup _dup\r\n\r\nintptr_t _findfirst(const char*, struct _finddata_t*);\r\nint _findnext(intptr_t, struct _finddata_t*);\r\nint _findclose(intptr_t);\r\n\r\nint _access(const char*,int);\r\n#define access _access\r\n\r\nint _wunlink(const wchar_t*);\r\n\r\n\r\n#endif\r\n";

static u64 cc_headers_h_direct = (u64)"#ifndef $direct\r\n#define $direct\r\n\r\ntypedef struct {\r\n unsigned int total_clusters;\r\n unsigned int avail_clusters;\r\n unsigned int sectors_per_cluster;\r\n unsigned int bytes_per_sector;\r\n} diskfree_t;\r\n\r\nint chdir(const char *);\r\nchar* _getcwd(char *, int);\r\n#define getcwd _getcwd\r\nint _mkdir(const char *);\r\nint _rmdir(const char *);\r\nint _wrmdir(const wchar_t*);\r\nint _wmkdir(const wchar_t*);\r\n\r\n#define mkdir _mkdir\r\n#define rmdir _rmdir\r\n\r\nint _chdrive(int);\r\nchar* _getdcwd(int, char *, int);\r\nwchar_t* _wgetcwd(wchar_t*, int);\r\nint _wchdir(const wchar_t*);\r\nint _getdrive(void);\r\nint _chdir(const char*);\r\n#define chdir _chdir\r\n\r\nunsigned long _getdrives(void);\r\nunsigned int _getdiskfree(unsigned int, diskfree_t*);\r\n\r\n#endif\r\n\r\n";

static u64 cc_headers_h_process = (u64)"/* Header process.h */\r\n#ifndef $process\r\n#define $process\r\n\r\n#include <stdint.h>\r\n\r\n#define P_WAIT\t\t0\r\n#define P_NOWAIT\t1\r\n#define P_OVERLAY\t2\r\n#define P_DETACH\t4\r\n#define WAIT_CHILD 0\r\n#define _P_WAIT P_WAIT\r\n#define _P_NOWAIT P_NOWAIT\r\n#define _P_OVERLAY P_OVERLAY\r\n\r\nint _spawnvp(int, const char*, const char*const*);\r\n#define spawnvp _spawnvp\r\n\r\nvoid endthread(void);\r\nunsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);\r\nvoid _endthreadex(unsigned);\r\nint _cwait(int*, int, int);\r\n#define cwait _cwait\r\n//int _System(const char *cmd,int nCmdShow);\r\n\r\nintptr_t _execve(const char*, const char*const*, const char*const*);\r\n#define execve _execve\r\n\r\n//#define _WAIT_CHILD\t0\r\n//#endif\r\n#endif\r\n\r\n";

static u64 cc_headers_h_malloc = (u64)"#include <stddef.h>\n\nvoid* malloc(size_t);\nvoid* realloc(void *, size_t);\nvoid  free(void *);\nvoid *_alloca(size_t);\n\n#define alloca malloc\n";

static u64 cc_headers_h_conio = (u64)"/* conio.h */\r\n#include <stddef.h>\r\n#include <wchar.h>\r\n\r\nint _getch(void);\r\nint _kbhit(void);\r\nwint_t _getwch(void);\r\n\r\n#define getch _getch\r\n#define kbhit _kbhit\r\n\r\nint _putch(int);\r\nint _cprintf(char *, ...);\r\nint _getche(void);\r\nint _ungetch(int);\r\n\r\n#define putch _putch\r\n#define cprintf _cprintf\r\n#define getche _getche\r\n#define ungetch _ungetch\r\n";

static u64 cc_headers_h_winsock2 = (u64)"#ifndef _WINSOCK2_H\r\n#define _WINSOCK2_H\r\n\r\n#include <_mingw.h>\r\n#include <windows.h>\r\n\r\n#ifndef FD_SETSIZE\r\n#define FD_SETSIZE 64\r\n#endif\r\n\r\ntypedef unsigned int SOCKET;\r\n\r\ntypedef struct fd_set {\r\n  unsigned int   fd_count;\r\n  SOCKET  fd_array[FD_SETSIZE];\r\n} fd_set;\r\n\r\nextern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);\r\n\r\n#ifndef FD_CLR\r\n#define FD_CLR(fd,set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n    while (__i < ((fd_set *)(set))->fd_count-1) {\\\r\n        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\\\r\n        __i++;\\\r\n    }\\\r\n    ((fd_set*)(set))->fd_count--;\\\r\n    break;\\\r\n    }\\\r\n}\\\r\n} while (0)\r\n#endif\r\n\r\n#ifndef FD_SET\r\n/* this differs from the define in winsock.h and in cygwin sys/types.h */\r\n#define FD_SET(fd, set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n        break;\\\r\n    }\\\r\n}\\\r\nif (__i == ((fd_set *)(set))->fd_count) {\\\r\n    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\\\r\n        ((fd_set *)(set))->fd_array[__i] = (fd);\\\r\n        ((fd_set *)(set))->fd_count++;\\\r\n    }\\\r\n}\\\r\n} while(0)\r\n#endif\r\n\r\n#ifndef FD_ZERO\r\n#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)\r\n#endif\r\n\r\n#ifndef FD_ISSET\r\n#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))\r\n#endif\r\n\r\n#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */\r\n#define _TIMEVAL_DEFINED\r\nstruct timeval {\r\n    long tv_sec;\r\n    long tv_usec;\r\n};\r\n#endif\r\n\r\nstruct in_addr {\r\n    union {\r\n        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;\r\n        struct { unsigned short s_w1,s_w2; } S_un_w;\r\n        unsigned long S_addr;\r\n    } S_un;\r\n};\r\n#define s_addr  S_un.S_addr\r\n\r\nstruct sockaddr_in {\r\n    short sin_family;\r\n    unsigned short sin_port;\r\n    struct in_addr sin_addr;\r\n    char sin_zero[8];\r\n};\r\n\r\nstruct sockaddr {\r\n    unsigned short sa_family;\r\n    char sa_data[14];\r\n};\r\n\r\nstruct hostent {\r\n    char *h_name;\r\n    char **h_aliases;\r\n    short h_addrtype;\r\n    short h_length;\r\n    char **h_addr_list;\r\n};\r\n#define h_addr h_addr_list[0]\r\n\r\n#define WSADESCRIPTION_LEN  256\r\n#define WSASYS_STATUS_LEN   128\r\ntypedef struct WSAData {\r\n    WORD wVersion;\r\n    WORD wHighVersion;\r\n    char szDescription[WSADESCRIPTION_LEN+1];\r\n    char szSystemStatus[WSASYS_STATUS_LEN+1];\r\n    unsigned short iMaxSockets;\r\n    unsigned short iMaxUdpDg;\r\n    char *lpVendorInfo;\r\n} WSADATA;\r\ntypedef WSADATA *LPWSADATA;\r\n\r\n#define INVALID_SOCKET (SOCKET)(~0)\r\n#define SOCK_STREAM  1\r\n#define SO_REUSEADDR 4\r\n#define AF_INET 2\r\n#define MSG_PEEK 0x2\r\n#define INADDR_ANY (unsigned long)0x00000000\r\n#define INADDR_LOOPBACK 0x7f000001\r\n#define SOL_SOCKET 0xffff\r\n\r\n#define SD_RECEIVE  0x00\r\n#define SD_SEND     0x01\r\n#define SD_BOTH     0x02\r\n\r\n#define h_errno WSAGetLastError()\r\n\r\n#define WSABASEERR 10000\r\n#define TRY_AGAIN (WSABASEERR+1002)\r\n\r\nSOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);\r\nint __stdcall bind(SOCKET, const struct sockaddr *, int);\r\nint __stdcall closesocket(SOCKET);\r\nint __stdcall connect(SOCKET, const struct sockaddr *, int);\r\nstruct hostent *__stdcall gethostbyname(const char *);\r\nint __stdcall gethostname(char *, int);\r\nint __stdcall getpeername(SOCKET, struct sockaddr *, int *);\r\nint __stdcall getsockname(SOCKET, struct sockaddr *, int *);\r\nunsigned long __stdcall htonl(unsigned long);\r\nunsigned short __stdcall htons(unsigned short);\r\nint __stdcall listen(SOCKET, int);\r\nunsigned long __stdcall ntohl(unsigned long);\r\nunsigned short __stdcall ntohs(unsigned short);\r\nint __stdcall recv(SOCKET, char *, int, int);\r\nint __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);\r\nint __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);\r\nint __stdcall send(SOCKET, const char *, int, int);\r\nint __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);\r\nint __stdcall setsockopt(SOCKET, int, int, const char *, int);\r\nint __stdcall shutdown(SOCKET, int);\r\nint __stdcall WSACleanup(void);\r\nint __stdcall WSAGetLastError(void);\r\nint __stdcall WSAStartup(WORD, LPWSADATA);\r\n\r\nSOCKET __stdcall socket(int, int, int);\r\n\r\n#endif\r\n\r\n";

static u64 cc_headers_h__mingw = (u64)"/*\r\n * _mingw.h\r\n *\r\n *  This file is for TinyCC and not part of the Mingw32 package.\r\n *\r\n *  THIS SOFTWARE IS NOT COPYRIGHTED\r\n *\r\n *  This source code is offered for use in the public domain. You may\r\n *  use, modify or distribute it freely.\r\n *\r\n *  This code is distributed in the hope that it will be useful but\r\n *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY\r\n *  DISCLAIMED. This includes but is not limited to warranties of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n *\r\n */\r\n\r\n#ifndef __MINGW_H\r\n#define __MINGW_H\r\n\r\n/* some winapi files define these before including _mingw.h --> */\r\n#undef __cdecl\r\n#undef _X86_\r\n#undef WIN32\r\n/* <-- */\r\n\r\n#include <stddef.h>\r\n#include <stdarg.h>\r\n\r\n#define __int8 char\r\n#define __int16 short\r\n#define __int32 int\r\n#define __int64 long long\r\n#define _HAVE_INT64\r\n\r\n#define __cdecl\r\n#define __declspec(x) __attribute__((x))\r\n#define __unaligned __attribute__((packed))\r\n#define __fastcall __attribute__((fastcall))\r\n\r\n#define __MSVCRT__ 1\r\n#undef _MSVCRT_\r\n#define __MINGW_IMPORT extern __declspec(dllimport)\r\n#define __MINGW_ATTRIB_NORETURN\r\n#define __MINGW_ATTRIB_CONST\r\n#define __MINGW_ATTRIB_DEPRECATED\r\n#define __MINGW_ATTRIB_MALLOC\r\n#define __MINGW_ATTRIB_PURE\r\n#define __MINGW_ATTRIB_NONNULL(arg)\r\n#define __MINGW_NOTHROW\r\n#define __GNUC_VA_LIST\r\n\r\n#define _CRTIMP extern\r\n#define __CRT_INLINE extern __inline__\r\n\r\n#define _CRT_ALIGN(x) __attribute__((aligned(x)))\r\n#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))\r\n#define _CRT_PACKING 8\r\n#define __CRT_UNALIGNED\r\n#define _CONST_RETURN\r\n\r\n#ifndef _TRUNCATE\r\n#define _TRUNCATE ((size_t)-1)\r\n#endif\r\n\r\n#define __CRT_STRINGIZE(_Value) #_Value\r\n#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)\r\n#define __CRT_WIDE(_String) L ## _String\r\n#define _CRT_WIDE(_String) __CRT_WIDE(_String)\r\n\r\n#ifdef _WIN64\r\n#define __stdcall\r\n#define _AMD64_ 1\r\n#define __x86_64 1\r\n#define _M_X64 100 /* Visual Studio */\r\n#define _M_AMD64 100 /* Visual Studio */\r\n#define USE_MINGW_SETJMP_TWO_ARGS\r\n#define mingw_getsp tinyc_getbp\r\n#define __TRY__\r\n#else\r\n#define __stdcall __attribute__((__stdcall__))\r\n#define _X86_ 1\r\n#define _M_IX86 300 /* Visual Studio */\r\n#define WIN32 1\r\n#define _USE_32BIT_TIME_T\r\n#ifdef __arm__\r\n#define __TRY__\r\n#else\r\n#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);\r\n#endif\r\n#endif\r\n\r\n/* in stddef.h */\r\n#define _SIZE_T_DEFINED\r\n#define _SSIZE_T_DEFINED\r\n#define _PTRDIFF_T_DEFINED\r\n#define _WCHAR_T_DEFINED\r\n#define _UINTPTR_T_DEFINED\r\n#define _INTPTR_T_DEFINED\r\n#define _INTEGRAL_MAX_BITS 64\r\n\r\n#ifndef _TIME32_T_DEFINED\r\n#define _TIME32_T_DEFINED\r\ntypedef long __time32_t;\r\n#endif\r\n\r\n#ifndef _TIME64_T_DEFINED\r\n#define _TIME64_T_DEFINED\r\ntypedef long long __time64_t;\r\n#endif\r\n\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\n#ifdef _USE_32BIT_TIME_T\r\ntypedef __time32_t time_t;\r\n#else\r\ntypedef __time64_t time_t;\r\n#endif\r\n#endif\r\n\r\n#ifndef _WCTYPE_T_DEFINED\r\n#define _WCTYPE_T_DEFINED\r\ntypedef wchar_t wctype_t;\r\n#endif\r\n\r\n#ifndef _WINT_T\r\n#define _WINT_T\r\ntypedef short wint_t;\r\n#endif\r\n\r\ntypedef int errno_t;\r\n#define _ERRCODE_DEFINED\r\n\r\ntypedef struct threadlocaleinfostruct *pthreadlocinfo;\r\ntypedef struct threadmbcinfostruct *pthreadmbcinfo;\r\ntypedef struct localeinfo_struct _locale_tstruct,*_locale_t;\r\n\r\n/* for winapi */\r\n#define _ANONYMOUS_UNION\r\n#define _ANONYMOUS_STRUCT\r\n#define DECLSPEC_NORETURN\r\n#define DECLARE_STDCALL_P(type) __stdcall type\r\n#define NOSERVICE 1\r\n#define NOMCX 1\r\n#define NOIME 1\r\n#define __INTRIN_H_\r\n#ifndef DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME1\r\n#  define DUMMYUNIONNAME2\r\n#  define DUMMYUNIONNAME3\r\n#  define DUMMYUNIONNAME4\r\n#  define DUMMYUNIONNAME5\r\n#endif\r\n#ifndef DUMMYSTRUCTNAME\r\n#  define DUMMYSTRUCTNAME\r\n#endif\r\n#ifndef WINVER\r\n# define WINVER 0x0502\r\n#endif\r\n#ifndef _WIN32_WINNT\r\n# define _WIN32_WINNT 0x502\r\n#endif\r\n\r\n#define __C89_NAMELESS\r\n#define __MINGW_EXTENSION\r\n#define WINAPI_FAMILY_PARTITION(X) 1\r\n#define MINGW_HAS_SECURE_API\r\n\r\n#endif /* __MINGW_H */\r\n";

static u64 cc_headers_h_windowsx = (u64)"/* Header windowsx.h */\r\n\r\n#ifndef $windowsx\r\n#define $windowsx 1\r\n\r\n#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))\r\n#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))\r\n\r\n#endif // windowsx\r\n\r\n";

static struct $B6 cc_headers_stdhdrnames = {{
(u64)"assert.h",
(u64)"ctype.h",
(u64)"errno.h",
(u64)"fenv.h",
(u64)"float.h",
(u64)"inttypes.h",
(u64)"stdint.h",
(u64)"limits.h",
(u64)"locale.h",
(u64)"_ansi.h",
(u64)"math.h",
(u64)"setjmp.h",
(u64)"signal.h",
(u64)"stdarg.h",
(u64)"stdbool.h",
(u64)"stddef.h",
(u64)"stdio.h",
(u64)"stdlib.h",
(u64)"_syslist.h",
(u64)"string.h",
(u64)"time.h",
(u64)"utime.h",
(u64)"unistd.h",
(u64)"safelib.h",
(u64)"wchar.h",
(u64)"wctype.h",
(u64)"sys/types.h",
(u64)"sys/stat.h",
(u64)"sys/timeb.h",
(u64)"sys/utime.h",
(u64)"malloc.h",
(u64)"fcntl.h",
(u64)"io.h",
(u64)"direct.h",
(u64)"process.h",
(u64)"memory.h",
(u64)"conio.h",
(u64)"winsock2.h",
(u64)"_mingw.h",
(u64)"windowsx.h"}};

static struct $B6 cc_headers_stdhdrtext = {{
(u64)&cc_headers_h_assert,
(u64)&cc_headers_h_ctype,
(u64)&cc_headers_h_errno,
(u64)&cc_headers_h_fenv,
(u64)&cc_headers_h_float,
(u64)&cc_headers_h_inttypes,
(u64)&cc_headers_h_stdint,
(u64)&cc_headers_h_limits,
(u64)&cc_headers_h_locale,
(u64)&cc_headers_h__ansi,
(u64)&cc_headers_h_math,
(u64)&cc_headers_h_setjmp,
(u64)&cc_headers_h_signal,
(u64)&cc_headers_h_stdarg,
(u64)&cc_headers_h_stdbool,
(u64)&cc_headers_h_stddef,
(u64)&cc_headers_h_stdio,
(u64)&cc_headers_h_stdlib,
(u64)&cc_headers_h__syslist,
(u64)&cc_headers_h_string,
(u64)&cc_headers_h_time,
(u64)&cc_headers_h_utime,
(u64)&cc_headers_h_unistd,
(u64)&cc_headers_h_safelib,
(u64)&cc_headers_h_wchar,
(u64)&cc_headers_h_wctype,
(u64)&cc_headers_h_systypes,
(u64)&cc_headers_h_sysstat,
(u64)&cc_headers_h_systimeb,
(u64)&cc_headers_h_sysutime,
(u64)&cc_headers_h_malloc,
(u64)&cc_headers_h_fcntl,
(u64)&cc_headers_h_io,
(u64)&cc_headers_h_direct,
(u64)&cc_headers_h_process,
(u64)&cc_headers_h_memory,
(u64)&cc_headers_h_conio,
(u64)&cc_headers_h_winsock2,
(u64)&cc_headers_h__mingw,
(u64)&cc_headers_h_windowsx}};

static i64 cc_show_currfileno;
static i64 cc_show_currlineno;
static struct $B3 cc_show_sbuffer;
static u64 cc_show_dest = (u64)&cc_show_sbuffer;

static i64 cc_show_destlinestart;
static struct $B3 cc_show_exprstrvar;
static u64 cc_show_exprstr = (u64)&cc_show_exprstrvar;

static struct $B20 cc_show_getprefix_str;
static struct $B16 cc_show_getdottedname_str;
static struct $B61 cc_show_getlineinfok_str;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B61 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B61 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B77 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B17 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B46 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B77 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B77 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B77 str;
	struct $B77 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B20 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L447;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L446;
L447:
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L449;
	asu64(R1) = p;
	free(asu64(R1));
	goto L448;
L449:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L448:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L454;
	goto L452;
L454:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L455:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L459;
L458:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L459:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L458;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L455;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L461:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L465;
	asi64(R1) = i;
	k = asi64(R1);
	goto L463;
L465:
	i += 1; if (i <= 27) goto L461;
L463:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L468;
L466:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L470;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L469;
L470:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L468;
L469:
	i += 1; if (i <= av_1) goto L466;
L468:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L452:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L473;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L471;
L473:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L475;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L471;
L475:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L477;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L471;
L477:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L471;
L471:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L480;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L480:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L482;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L482:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L478;
L478:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L485;
	asi64(R1) = n;
	goto L484;
L485:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L484:
	goto L483;
L483:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L486;
L486:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L489;
	R1 = 0;
	goto L487;
L489:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L492;
	R1 = 0;
	goto L490;
L492:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L490;
L490:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L495;
	R1 = 0;
	goto L493;
L495:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L493;
L493:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L498;
	asu64(R1) = p;
	goto L496;
L498:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L496;
L496:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L501;
	asu64(R1) = p;
	goto L499;
L501:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L499;
L499:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L503;
L503:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L505;
L505:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L510;
	R1 = 0;
	goto L508;
L510:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L512;
	R1 = 0;
	goto L508;
L512:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L508;
L508:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L515;
	R1 = 0;
	goto L513;
L515:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L513;
L513:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L518;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L516;
L518:
	R1 = 0;
	goto L516;
L516:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L521;
	asu64(R1) = mnoos_os_getstdin();
	handlex = asu64(R1);
L521:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L523;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L524:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L527;
L528:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L527:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L530;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L530:
	goto L524;
L523:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L532;
	goto L519;
L532:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L534;
	goto L519;
L534:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L536;
L535:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L540;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L539;
L540:
	R1 = 1;
	crseen = asu8(R1);
L539:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L536:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L535;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L535;
L541:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L543;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L543;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L543:
L519:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L547;
L545:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L545;
L547:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L551;
L549:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L549;
L551:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L554;
L553:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L553;
	asu64(R1) = s0;
	goto L552;
L552:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L558;
L557:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L557;
	asu64(R1) = s0;
	goto L556;
L556:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B17 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L562;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L563;
	goto L564;
L562:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L561;
L563:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L561;
L564:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L561:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L566;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L567;
	goto L568;
L566:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L567:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L568:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L565:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L560;
L560:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L571;
	R1 = tou64("");
	goto L569;
L571:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L573;
L572:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L576;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L578;
	asi64(R1) = period;
	if (!asi64(R1)) goto L580;
	R1 = tou64(".");
	goto L579;
L580:
	R1 = tou64("");
L579:
	goto L569;
L578:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L569;
L576:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L573:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L572;
	R1 = tou64("");
	goto L569;
L569:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L583;
L582:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L586;
	goto L587;
L586:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L581;
	goto L585;
L587:
L585:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L583:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L582;
	R1 = tou64("");
	goto L581;
L581:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L590;
	asu64(R1) = s;
	goto L588;
L590:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L588;
L588:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L593;
	R1 = tou64("");
	goto L591;
L593:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L595;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L595:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L597;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L597:
	asu64(R1) = f;
	goto L591;
L591:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L600;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L598;
L600:
	asu64(R1) = s;
	goto L598;
L598:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L603;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L601;
L603:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L601;
L601:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L613;
	R1 = 1;
	goto L611;
L613:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L611;
L611:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L616;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L616:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L618;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L614;
L618:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L620;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L620:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L614:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L624;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L624:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L633;
L633:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B78 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L636;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L639;
L637:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L637;
L639:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L636:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B78 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L643;
	goto L641;
L643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L646;
L644:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L644;
L646:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L641:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L649;
	goto L647;
L649:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L651;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L650;
L651:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L650:
L647:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L653:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L655;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L657;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L657:
	goto L654;
L655:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L659;
	R1 = 0;
	goto L652;
L659:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L661;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L663;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L663:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L661:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L665;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L652;
L665:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L667;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L669;
	R2 = 0;
	goto L668;
L669:
	R2 = 1;
L668:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L671;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L671:
	asu64(R1) = q;
	if (!asu64(R1)) goto L673;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L673:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L675;
	R1 = 5;
	goto L674;
L675:
	R1 = 1;
L674:
	goto L652;
L667:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L677;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L679;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L679;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L679:
	goto L676;
L677:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L681;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L680;
L681:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L683;
	R1 = 5;
	goto L682;
L683:
	R1 = 3;
L682:
	goto L652;
L680:
L676:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L685;
	R1 = 5;
	goto L684;
L685:
	R1 = 2;
L684:
	goto L652;
L652:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L687:
L688:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L692;
	goto L693;
L691:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L690;
L692:
	R1 = 0;
	goto L686;
	goto L690;
L693:
	goto L689;
L690:
	goto L688;
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L695;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L695;
	goto L696;
L695:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L697:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L699;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L700;
	goto L701;
L699:
	goto L687;
	goto L697;
L700:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L686;
	goto L697;
L701:
	goto L697;
	goto L694;
L696:
L694:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L703;
	goto L704;
L703:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L705:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L709;
	goto L710;
L708:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L707;
L709:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L712;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L712:
	goto L706;
	goto L707;
L710:
L707:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L705;
L706:
	goto L702;
L704:
	asu64(R1) = p;
	pstart = asu64(R1);
L713:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L717;
	goto L718;
L716:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L714;
	goto L715;
L717:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L714;
	goto L715;
L718:
L715:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L713;
L714:
L702:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L720;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L720:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L686;
L686:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L724;
L722:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L722;
L724:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L725;
L725:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L726;
L726:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L729;
	R1 = -1;
	goto L728;
L729:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L730;
	R1 = 1;
	goto L728;
L730:
	R1 = 0;
L728:
	goto L727;
L727:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L733;
	R1 = -1;
	goto L732;
L733:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L734;
	R1 = 1;
	goto L732;
L734:
	R1 = 0;
L732:
	goto L731;
L731:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L735;
L735:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L738;
	R1 = -1;
	goto L737;
L738:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L739;
	R1 = 1;
	goto L737;
L739:
	R1 = 0;
L737:
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L740;
L740:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L743;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L742;
L743:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L742:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L744;
L744:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L745;
L745:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L749;
	R1 = 0;
	goto L747;
L749:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L751:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L751;
	asr64(R1) = x;
	goto L750;
L750:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L754;
L754:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L755;
L755:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L759;
L757:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L761;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L756;
L761:
	i += 1; if (i <= av_1) goto L757;
L759:
	R1 = 0;
	goto L756;
L756:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L764;
	asi64(R1) = n;
	goto L762;
L764:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L762;
L762:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L767;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L767:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L769;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L769:
	asu64(R1) = p;
	goto L765;
L765:
	return asu64(R1);
}

static void mnoos_os_init() {
	return;
}

static i64 mnoos_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1; 
	R1 = 0;
	goto L771;
L771:
	return asi64(R1);
}

static i64 mnoos_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1; 
	R1 = 0;
	goto L772;
L772:
	return asi64(R1);
}

static i64 mnoos_os_getch() {
    u64 R1; 
	R1 = 0;
	goto L773;
L773:
	return asi64(R1);
}

static i64 mnoos_os_kbhit() {
    u64 R1; 
	R1 = 0;
	goto L774;
L774:
	return asi64(R1);
}

static u64 mnoos_os_getdllinst(u64 name) {
    u64 R1; 
	R1 = 0;
	goto L775;
L775:
	return asu64(R1);
}

static u64 mnoos_os_getdllprocaddr(i64 hinst, u64 name) {
    u64 R1; 
	R1 = 0;
	goto L776;
L776:
	return asu64(R1);
}

static void mnoos_os_initwindows() {
	return;
}

static void mnoos_os_gxregisterclass(u64 classname) {
	return;
}

static void mnoos_os_setmesshandler(u64 addr) {
	return;
}

static i64 mnoos_os_getchx() {
    u64 R1; 
	R1 = 27;
	goto L780;
L780:
	return asi64(R1);
}

static u64 mnoos_os_getos() {
    u64 R1; 
	R1 = tou64("NOOS");
	goto L781;
L781:
	return asu64(R1);
}

static i64 mnoos_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L782;
L782:
	return asi64(R1);
}

static i64 mnoos_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L783;
L783:
	return asi64(R1);
}

static void mnoos_os_sleep(i64 a) {
	return;
}

static u64 mnoos_os_getstdin() {
    u64 R1, R2; 
	R1 = tou64("rb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L785;
L785:
	return asu64(R1);
}

static u64 mnoos_os_getstdout() {
    u64 R1, R2; 
	R1 = tou64("wb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L786;
L786:
	return asu64(R1);
}

static u64 mnoos_os_gethostname() {
    u64 R1; 
	R1 = tou64("?");
	goto L787;
L787:
	return asu64(R1);
}

static u64 mnoos_os_getmpath() {
    u64 R1; 
	R1 = tou64("C:\\m\\\"");
	goto L788;
L788:
	return asu64(R1);
}

static i64 mnoos_os_clock() {
    u64 R1; 
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L789;
L789:
	return asi64(R1);
}

static i64 mnoos_os_ticks() {
    u64 R1; 
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L790;
L790:
	return asi64(R1);
}

static i64 mnoos_os_iswindows() {
    u64 R1; 
	R1 = 1;
	goto L791;
L791:
	return asi64(R1);
}

static void mnoos_os_getsystime(u64 $1) {
	return;
}

static void mnoos_os_peek() {
	return;
}

static u64 mnoos_os_allocexecmem(i64 n) {
    u64 R1; 
	R1 = 0;
	goto L794;
L794:
	return asu64(R1);
}

static i64 mnoos_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1; 
	R1 = 0;
	goto L795;
L795:
	return asi64(R1);
}

static i64 mnoos_os_hpcounter() {
    u64 R1; 
	i64 a;
	R1 = 0;
	goto L796;
L796:
	return asi64(R1);
}

static i64 mnoos_os_hpfreq() {
    u64 R1; 
	i64 a;
	R1 = 0;
	goto L797;
L797:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L800;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L799;
L800:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L799:
	goto L798;
L798:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L803;
	R4 = 0;
	goto L802;
L803:
	R4 = 73;
L802:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L801;
L801:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L808;
	case 1: goto L809;
	case 2: goto L810;
	case 3: goto L811;
	case 4: goto L812;
	case 5: goto L813;
	case 6: goto L814;
	case 7: goto L807;
	case 8: goto L815;
	case 9: goto L816;
	case 10: goto L817;
	case 11: goto L818;
	case 12: goto L819;
	default: goto L807;
    };
// SWITCH
L808:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F1)R1)();
	goto L804;
	goto L805;
L809:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F2)R2)(asi64(R1));
	goto L804;
	goto L805;
L810:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F3)R3)(asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L811:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F4)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L812:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F5)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L813:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F6)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L814:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F7)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L815:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F8)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L816:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F9)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L817:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F10)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L818:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F11)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L819:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F12)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L804;
	goto L805;
L807:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L805:
	R1 = 0;
	goto L804;
L804:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L822;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L823;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L824;
	goto L825;
L822:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F13)R1)();
	R1 = toi64(asr64(R1));
	goto L820;
	goto L821;
L823:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F14)R2)(asi64(R1));
	x = asr64(R1);
	goto L821;
L824:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F15)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L821;
L825:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L821:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L820;
L820:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

static u64 pc_api_pcl_start(u64 name, i64 nunits) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_pcldone;
	if (!asu8(R1)) goto L829;
	R1 = tou64("PCL start?");
	pc_api_pclerror(asu64(R1));
L829:
	asu64(R1) = name;
	if (!asu64(R1)) goto L831;
	R1 = 9;
	asu64(R2) = name;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	pc_decls_currprog = asu64(R1);
L831:
	asi64(R1) = pc_api_initpcalloc;
	pc_api_pcalloc = asi64(R1);
	asi64(R1) = nunits;
	if (!asi64(R1)) goto L833;
	asi64(R1) = nunits;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nunits = asi64(R1);
	goto L835;
L834:
	R1 = 2;
	R2 = (u64)&pc_api_pcalloc;
	*toi64p(R2) *= asi64(R1);
L835:
	asi64(R1) = pc_api_pcalloc;
	asi64(R2) = nunits;
	if (asi64(R1) < asi64(R2)) goto L834;
L833:
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pc_api_pcstart = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	asi64(R2) = pc_api_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	R1 = 0;
	pc_api_pcfixed = asu8(R1);
	R1 = 0;
	pc_api_pcseqno = asi64(R1);
	R1 = 0;
	pc_api_pcneedfntable = asi64(R1);
	R1 = 0;
	pc_api_mlabelno = asi64(R1);
	asu64(R1) = pc_decls_currprog;
	goto L827;
L827:
	return asu64(R1);
}

static void pc_api_pcl_end() {
    u64 R1, R2; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) < asu64(R2)) goto L839;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L839;
	R1 = 0;
	R2 = 136;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L839:
	R1 = 1;
	pc_decls_pcldone = asu8(R1);
	return;
}

static u64 pc_api_pcl_writepcl(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writeallpcl();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L842;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L844;
	msysc_m$print_startcon();
	R1 = tou64("Writing PCL");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L844:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L841;
L842:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L841:
	goto L840;
L840:
	return asu64(R1);
}

static u64 pc_api_pcl_writepst(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writepst();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L847;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L849;
	msysc_m$print_startcon();
	R1 = tou64("Writing PST");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L849:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L846;
L847:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L846:
	goto L845;
L845:
	return asu64(R1);
}

static void pc_api_pcl_genmcl() {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	return;
}

static void pc_api_pcl_genss(i64 obj) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_dummy_genss(asi64(R1));
	return;
}

static u64 pc_api_pcl_writess(u64 filename, i64 obj) {
    u64 R1, R2; 
	u64 ssstr;
	u64 f;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = obj;
	asi64(R1) = !asi64(R1);
	asu64(R1) = mc_writess_dummy_writessdata(asi64(R1));
	ssstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L854;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = ssstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = ssstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L853;
L854:
	asu64(R1) = ssstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L853:
	goto L852;
L852:
	return asu64(R1);
}

static u64 pc_api_pcl_writeasm(u64 filename, i64 atype) {
    u64 R1, R2; 
	u64 asmstr;
	u64 f;
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L857;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
L857:
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asu64(R1) = mc_writegas_getassemstr();
	asmstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L859;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L861;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L861:
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = asmstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = asmstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L858;
L859:
	asu64(R1) = asmstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L858:
	goto L855;
L855:
	return asu64(R1);
}

static void pc_api_pcl_writeobj(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 1;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = mnoos_os_clock();
	tt = asi64(R1);
	asu64(R1) = filename;
	mc_writeobj_dummy_writecoff(asu64(R1));
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_objtime = asi64(R1);
	return;
}

static void pc_api_pcl_writedll(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = mnoos_os_clock();
	tt = asi64(R1);
	R1 = 1;
	asu64(R2) = filename;
	mc_writeexe_dummy_writeexe(asu64(R2), asi64(R1));
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writeexe(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = mnoos_os_clock();
	tt = asi64(R1);
	R1 = 0;
	asu64(R2) = filename;
	mc_writeexe_dummy_writeexe(asu64(R2), asi64(R1));
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writemx(u64 filename) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asu64(R1) = filename;
	mx_run_dummy_writemcx(asu64(R1));
	return;
}

static void pc_api_pcl_exec() {
    u64 R1, R2; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	R2 = tou64("dummy");
	mx_run_dummy_runlibfile(asu64(R2), asi64(R1));
	return;
}

static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames) {
    u64 R1, R2; 
	asi64(R1) = highmem;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L869;
	asi64(R1) = highmem;
	pc_api_phighmem = asu8(R1);
L869:
	asi64(R1) = verbose;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L871;
	asi64(R1) = verbose;
	pc_decls_pverbose = asu8(R1);
L871:
	asi64(R1) = shortnames;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L873;
	asi64(R1) = shortnames;
	pc_api_fpshortnames = asu8(R1);
L873:
	return;
}

static void pc_api_extendpclblock() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	i64 lengthused;
	u64 newpcstart;
	asi64(R1) = pc_api_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	lengthused = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	asi64(R1) = lengthused;
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pc_api_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newpcalloc;
	asi64(R2) = lengthused;
	asi64(R1) -= asi64(R2);
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newpcstart;
	asi64(R3) = lengthused;
	R2 += (i64)R3*32;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = pc_api_pccurr;
	asu64(R3) = pc_api_pcstart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 32;
	R1 += (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	pc_api_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	pc_api_pcalloc = asi64(R1);
	return;
}

static u64 pc_api_newpcl() {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcend;
	if (asu64(R1) < asu64(R2)) goto L877;
	pc_api_extendpclblock();
L877:
	R1 = (u64)&pc_api_pccurr;
	(*tou64p(R1)) += 32;
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = pc_api_pccurr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc_api_pclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_decls_npcl;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc_api_pccurr;
	goto L875;
L875:
	return asu64(R1);
}

static void pc_api_pc_gen(i64 opcode, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L880;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L880:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genx(i64 opcode, i64 x, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L884;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L884:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L887;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L887:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L890;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L890:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cond;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 pc_api_genint(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L891;
L891:
	return asu64(R1);
}

static u64 pc_api_genreal(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L894;
	R1 = 5;
	goto L893;
L894:
	R1 = 6;
L893:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L892;
L892:
	return asu64(R1);
}

static u64 pc_api_genrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L897;
	R1 = 10;
	goto L896;
L897:
	R1 = 11;
L896:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L895;
L895:
	return asu64(R1);
}

static u64 pc_api_genstring(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L900;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
L900:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L898;
L898:
	return asu64(R1);
}

static u64 pc_api_genpcstrimm(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L901;
L901:
	return asu64(R1);
}

static u64 pc_api_genlabel(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L902;
L902:
	return asu64(R1);
}

static u64 pc_api_genmem(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L903;
L903:
	return asu64(R1);
}

static u64 pc_api_genmemaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L904;
L904:
	return asu64(R1);
}

static u64 pc_api_gendata(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 12;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L905;
L905:
	return asu64(R1);
}

static void pc_api_gencomment(u64 s) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L909;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L908;
L909:
	goto L906;
L908:
	asu64(R1) = s;
	asu64(R1) = pc_api_genpcstrimm(asu64(R1));
	R2 = 135;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L906:
	return;
}

static u64 pc_api_genname(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L910;
L910:
	return asu64(R1);
}

static u64 pc_api_gennameaddr(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L911;
L911:
	return asu64(R1);
}

static u64 pc_api_genassem(u64 code) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = code;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 9;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L912;
L912:
	return asu64(R1);
}

static u64 pc_api_strpmode(i64 mode, i64 size) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L915;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L916;
	goto L917;
L915:
	R1 = tou64("mem:");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = size;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_strpmode_str;
	goto L914;
L916:
	R1 = tou64("---");
	goto L914;
L917:
	R1 = (u64)&pc_tables_pstdnames;
	asi64(R2) = mode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L914:
	goto L913;
L913:
	return asu64(R1);
}

static void pc_api_pc_setmode(i64 m, i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L920;
	asi64(R1) = size;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L919;
L920:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L919:
	R1 = (u64)&pc_tables_pclhastype;
	asu64(R2) = pc_api_pccurr;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L922;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L922:
	return;
}

static void pc_api_pc_setmode2(i64 m) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void pc_api_pc_setxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setscaleoff(i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = scale;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_addoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	return;
}

static void pc_api_pc_setincr(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnargs(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnvariadics(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setalign(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_perror(u64 mess) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = mess;
	pc_api_perror_s(asu64(R2), asu64(R1));
	return;
}

static void pc_api_perror_s(u64 mess, u64 param) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = param;
	if (!asu64(R1)) goto L935;
	msysc_m$print_startcon();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L935:
	R1 = 1;
	exit(R1);
	return;
}

static u64 pc_api_getbasename(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L938;
L937:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L938:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) <= asu64(R2)) goto L940;
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L937;
L940:
	asu64(R1) = t;
	goto L936;
L936:
	return asu64(R1);
}

static void pc_api_pclerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addsymbol(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_psymboltable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L944;
	asu64(R1) = d;
	R2 = R1;
	pc_decls_psymboltablex = asu64(R2);
	pc_decls_psymboltable = asu64(R1);
	goto L943;
L944:
	asu64(R1) = d;
	asu64(R2) = pc_decls_psymboltablex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	pc_decls_psymboltablex = asu64(R1);
L943:
	return;
}

static u64 pc_api_pc_makesymbol(u64 s, i64 id) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = (u64)&pc_decls_npst;
	(*toi64p(R1)) += 1;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = id;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L947;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L948;
	goto L949;
L947:
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L946;
L948:
	R1 = 1;
	asu64(R2) = d;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	id = asi64(R1);
	goto L946;
L949:
L946:
	asi64(R1) = id;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L952;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L951;
L952:
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L950;
L951:
	asi64(R1) = id;
	if (!asi64(R1)) goto L953;
	asu64(R1) = d;
	pc_api_pc_addsymbol(asu64(R1));
L953:
L950:
	asu64(R1) = d;
	goto L945;
L945:
	return asu64(R1);
}

static u64 pc_api_getfullname(u64 d, i64 backtick) {
    u64 R1, R2, R3; 
	i64 n;
	u64 e;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	R2 = (u64)&pc_api_getfullname_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L956;
	R1 = tou64("`");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L956:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L958;
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L960;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L959;
L960:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L959:
	R1 = (u64)&pc_api_getfullname_str;
	goto L954;
L958:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L963;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L962;
L963:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_getfullname_str;
	goto L954;
L962:
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L965;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L964;
L965:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L964:
	goto L954;
L954:
	return asu64(R1);
}

static void pc_api_pcerrorstop(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addplib(u64 name) {
    u64 R1, R2, R3; 
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L969;
	R1 = tou64("Too many libs");
	pc_api_perror(asu64(R1));
L969:
	R1 = tou64("");
	asu64(R2) = name;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&pc_decls_plibfiles;
	R3 = (u64)&pc_decls_nplibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L972;
	R1 = tou64("Nested proc");
	pc_api_pclerror(asu64(R1));
L972:
	asu64(R1) = d;
	asu64(R1) = pc_api_genmem(asu64(R1));
	asi64(R2) = threaded;
	if (!asi64(R2)) goto L974;
	R2 = 121;
	goto L973;
L974:
	R2 = 120;
L973:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L976;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L976:
	R1 = 0;
	asi64(R2) = mode;
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L978;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl proc:");
	asu64(R1) = pc_api_addstr(asu64(R2), asu64(R1));
	pc_api_pclerror(asu64(R1));
L978:
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L980;
	asi64(R1) = isentry;
	if (!asi64(R1)) goto L980;
	asu64(R1) = d;
	pc_decls_entryproc = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 83;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L980:
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_setimport(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_addparam(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L984;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L984:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L986;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L985;
L986:
	goto L988;
L987:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L988:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L987;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L985:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L991;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L991:
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	return;
}

static void pc_api_pc_addlocal(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L994;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L994:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L996;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L995;
L996:
	goto L998;
L997:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L998:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L997;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L995:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1001;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1001:
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	return;
}

static void pc_api_pc_endproc() {
    u64 R1, R2; 
	asu64(R1) = pc_decls_currfunc;
	if (asu64(R1)) goto L1004;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1004:
	R1 = 0;
	R2 = 122;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_decls_currfunc = asu64(R1);
	return;
}

static u64 pc_api_addstr(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = t;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_addstr_str;
	goto L1005;
L1005:
	return asu64(R1);
}

static void pc_api_merror(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1008;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F16)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L1007;
L1008:
	R1 = 0;
	lineno = asi64(R1);
	R1 = tou64("?");
	filename = asu64(R1);
L1007:
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1010;
	msysc_m$print_startcon();
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1010:
	msysc_m$print_startcon();
	R1 = tou64("MCL Error: # (#) on Line: # in #, PCL:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pc_decls_ppseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	asu64(R2) = filename;
	pc_api_pcerrorstop(asu64(R2), asi64(R1));
	return;
}

static u64 pc_api_pc_duplpst(u64 d) {
    u64 R1, R2, R3; struct $B36 R1_B36; 
	u64 e;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	(R1_B36) = *(struct $B36*)(R1);
	asu64(R2) = e;
	*(struct $B36*)(R2) = (R1_B36);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = e;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L1011;
L1011:
	return asu64(R1);
}

static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip) {
    u64 R1; 
	asi64(R1) = cmdskip;
	pc_decls_pcmdskip = asi64(R1);
	return;
}

static i64 pc_api_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	asu64(R1) = t;
	t0 = asu64(R1);
	goto L1015;
L1014:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1018;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1019;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1020;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1021;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1022;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1023;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1023;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1023;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1023;
	goto L1024;
L1018:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1017;
L1019:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1017;
L1020:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1017;
L1021:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1017;
L1022:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1017;
L1023:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1017;
L1024:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1026;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1026;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1025;
L1026:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 120;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2h");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1025:
L1017:
L1015:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L1014;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1013;
L1013:
	return asi64(R1);
}

static void pc_diags_strpcl(u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	i64 opcode;
	i64 n;
	i64 x;
	i64 y;
	u64 d;
	u64 e;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asi64(R1) = opcode;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1029;
	R2 = 128;
	if (asi64(R1) == asi64(R2)) goto L1030;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1031;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1032;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1032;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1033;
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L1034;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1035;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1036;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1036;
	goto L1037;
L1029:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	pc_diags_strlabel(asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1039;
	R1 = tou64(" NOT USED");
	pc_diags_psstr(asu64(R1));
L1039:
	goto L1027;
	goto L1028;
L1030:
	R1 = tou64("! ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
	goto L1027;
	goto L1028;
L1031:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L1041;
	R1 = tou64("!");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	goto L1040;
L1041:
	R1 = tou64("! - - -");
	pc_diags_psstr(asu64(R1));
L1040:
	goto L1027;
	goto L1028;
L1032:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = opcode;
	R2 = 121;
	if (asi64(R1) != asi64(R2)) goto L1043;
	R1 = tou64("tcproc");
	pc_diags_psstr(asu64(R1));
	goto L1042;
L1043:
	R1 = tou64("proc");
	pc_diags_psstr(asu64(R1));
L1042:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	pc_diags_psname(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1045;
	R1 = tou64("::");
	goto L1044;
L1045:
	R1 = tou64(":");
L1044:
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1047;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1047:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1051;
L1048:
	R1 = tou64("    param    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1051:
	asu64(R1) = e;
	if (asu64(R1)) goto L1048;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1055;
L1052:
	R1 = tou64("    local    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1055:
	asu64(R1) = e;
	if (asu64(R1)) goto L1052;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1057;
	R1 = tou64("    rettype  ");
	pc_diags_psstr(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
L1057:
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1059;
	R1 = tou64("    variadic");
	pc_diags_psstrline(asu64(R1));
L1059:
	goto L1027;
	goto L1028;
L1033:
	R1 = tou64("endproc");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	goto L1027;
	goto L1028;
L1034:
	R1 = tou64("endprog");
	pc_diags_psstr(asu64(R1));
	goto L1027;
	goto L1028;
L1035:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1061;
	asu64(R1) = p;
	pc_diags_psdata(asu64(R1));
	goto L1027;
L1061:
	goto L1028;
L1036:
	goto L1062;
	goto L1028;
L1037:
L1028:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
// pc_diags.strpcl.skiptab:
L1062:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1064;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L1065;
	goto L1066;
L1064:
	R1 = tou64("jump");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1063;
L1065:
	R1 = tou64("set");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1063;
L1066:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L1063:
	R1 = 32;
	R2 = 9;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1068;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pclhastype;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1070;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1070:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1068:
	R1 = 32;
	R2 = 4;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_pclextra;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L1072;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	x = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L1075;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1074;
L1075:
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1074:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1077;
	asi64(R1) = y;
	if (!asi64(R1)) goto L1077;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = y;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1077:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1072:
	R1 = 32;
	R2 = 5;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1079;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	pc_diags_psopnd(asu64(R1));
L1079:
	R1 = 40;
	pc_diags_pstabto(asi64(R1));
L1027:
	return;
}

static u64 pc_diags_stropnd(u64 p) {
    u64 R1, R2, R3; 
	i64 length;
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1082;
	R1 = tou64("");
	goto L1080;
L1082:
	R1 = 0;
	R2 = (u64)&pc_diags_stropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1084;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1085;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1085;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1085;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1085;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1086;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1087;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1088;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1089;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1090;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1091;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1092;
	goto L1093;
L1084:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1080;
	goto L1083;
L1085:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L1095;
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("infinity");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L1094;
L1095:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e16.16");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L1094:
	goto L1083;
L1086:
	asu64(R1) = p;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L1097;
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_diags_stropnd_str;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1096;
L1097:
	asu64(R1) = pc_diags_stropnd_longstring;
	if (!asu64(R1)) goto L1099;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_diags_stropnd_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1099:
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	pc_api_longstringlen = asi64(R1);
	asi64(R1) = pc_api_longstringlen;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_diags_stropnd_longstring = asu64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	length = asi64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+2)) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	goto L1080;
L1096:
	goto L1083;
L1087:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1102;
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L1101;
L1102:
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1104;
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1104:
L1101:
	goto L1083;
L1088:
	R1 = tou64("&");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L1087;
	goto L1083;
L1089:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L1083;
L1090:
	R1 = tou64("");
	goto L1080;
	goto L1083;
L1091:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1080;
	goto L1083;
L1092:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<Data * # (#)>");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L1083;
L1093:
	msysc_m$print_startcon();
	R1 = tou64("---------");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<PCLOPND?>");
	goto L1080;
L1083:
	R1 = (u64)&pc_diags_stropnd_str;
	goto L1080;
L1080:
	return asu64(R1);
}

static void pc_diags_psopnd(u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B20 str;
	i64 length;
	u64 d;
	u64 ss;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1107;
	goto L1105;
L1107:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1109;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1110;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1110;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1110;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1110;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1111;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1112;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1113;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1114;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1115;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1116;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1117;
	goto L1118;
L1109:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	pc_diags_psint(asi64(R1));
	goto L1108;
L1110:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L1120;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("infinity");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L1119;
L1120:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e16.16");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L1119:
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	goto L1108;
L1111:
	asu64(R1) = p;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L1122;
	R1 = tou64("\"");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&str;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = pc_diags_newconvertstring(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	R1 = tou64("\"*");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_diags_psint(asi64(R1));
	goto L1121;
L1122:
	asu64(R1) = pc_diags_psopnd_longstring;
	if (!asu64(R1)) goto L1124;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_diags_psopnd_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1124:
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	pc_api_longstringlen = asi64(R1);
	asi64(R1) = pc_api_longstringlen;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_diags_psopnd_longstring = asu64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_psopnd_longstring;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc_diags_psopnd_longstring;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	length = asi64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_psopnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = pc_diags_psopnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+2)) = asu8(R1);
	asu64(R1) = pc_diags_psopnd_longstring;
	pc_diags_psstr(asu64(R1));
L1121:
	goto L1108;
L1112:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1127;
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L1126;
L1127:
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1129;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1129:
L1126:
	goto L1108;
L1113:
	R1 = tou64("&");
	pc_diags_psstr(asu64(R1));
	goto L1112;
	goto L1108;
L1114:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	goto L1108;
L1115:
	goto L1105;
	goto L1108;
L1116:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	pc_diags_psint(asi64(R1));
	goto L1108;
L1117:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<Data * # (#)>");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	goto L1108;
L1118:
	R1 = tou64("<PCLOPND?>");
	pc_diags_psstr(asu64(R1));
L1108:
L1105:
	return;
}

static u64 pc_diags_strpclstr(u64 p, i64 buffsize) {
    u64 R1, R2; 
	asu64(R1) = pc_diags_dest;
	mlib_gs_free(asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	pc_diags_destlinestart = asi64(R1);
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	R1 = 0;
	asu64(R2) = pc_diags_dest;
	mlib_gs_char(asu64(R2), asi64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = buffsize;
	if (asi64(R1) < asi64(R2)) goto L1132;
	R1 = tou64("<BIGSTR>");
	goto L1130;
L1132:
	asu64(R1) = pc_diags_dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1130;
L1130:
	return asu64(R1);
}

static void pc_diags_writepcl(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1135;
	goto L1136;
L1135:
	goto L1134;
L1136:
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
L1134:
	return;
}

static u64 pc_diags_writeallpcl() {
    u64 R1, R2; 
	u64 p;
	u64 d;
	i64 i;
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = tou64("!PROC PCL");
	asu64(R2) = pc_diags_dest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1140;
L1138:
	R1 = tou64("addlib    \"");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("\"");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	i += 1; if (i <= pc_decls_nplibfiles) goto L1138;
L1140:
	asi64(R1) = pc_decls_nplibfiles;
	if (!asi64(R1)) goto L1142;
	pc_diags_psline();
L1142:
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1146;
L1143:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1148;
	R1 = tou64("extproc    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1150;
	R1 = tou64(" 1");
	pc_diags_psstr(asu64(R1));
L1150:
	pc_diags_psline();
L1148:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1146:
	asu64(R1) = d;
	if (asu64(R1)) goto L1143;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1152;
L1151:
	asu64(R1) = p;
	pc_diags_writepcl(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1152:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1151;
	pc_diags_psline();
	asu64(R1) = pc_api_longstring;
	if (!asu64(R1)) goto L1155;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_api_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1155:
	asu64(R1) = pc_diags_dest;
	goto L1137;
L1137:
	return asu64(R1);
}

static void pc_diags_psstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psstrx(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psstrline(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void pc_diags_psline() {
    u64 R1, R2; 
	R1 = tou64("\n");
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psint(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psname(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_pstabto(i64 n) {
    u64 R1, R2; 
	i64 col;
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = pc_diags_destlinestart;
	asi64(R1) -= asi64(R2);
	col = asi64(R1);
	goto L1164;
L1163:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&col;
	(*toi64p(R1)) += 1;
L1164:
	asi64(R1) = n;
	asi64(R2) = col;
	if (asi64(R1) > asi64(R2)) goto L1163;
	return;
}

static void pc_diags_strlabel(i64 labelno, i64 colon) {
    u64 R1; 
	R1 = tou64("#");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = labelno;
	pc_diags_psint(asi64(R1));
	asi64(R1) = colon;
	if (!asi64(R1)) goto L1168;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1168:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	return;
}

static void pc_diags_psdata(u64 p) {
    u64 R1, R2; 
	i64 n;
	i64 m;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1171;
	goto L1169;
L1171:
	goto L1173;
L1172:
	asi64(R1) = n;
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L1176;
	R1 = 20;
	m = asi64(R1);
L1176:
	asi64(R1) = m;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = tou64("    data mem:");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	pc_diags_psint(asi64(R1));
	R1 = tou64("  ");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L1178;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
L1178:
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1181;
L1179:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L1179;
L1181:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1183;
	pc_diags_psline();
L1183:
L1173:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1172;
L1169:
	return;
}

static u64 pc_diags_writepst() {
    u64 R1, R2; 
	u8 localfile;
	i64 i;
	i64 j;
	u64 d;
	u64 e;
	R1 = 0;
	localfile = asu8(R1);
	R1 = 0;
	i = asi64(R1);
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("PROC PC Symbol table");
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1188;
L1185:
	R1 = tou64("H");
	asu64(R2) = d;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("25jl");
	asu64(R2) = d;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1191;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1190;
L1191:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1195;
L1192:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1195:
	asu64(R1) = e;
	if (asu64(R1)) goto L1192;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1199;
L1196:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1199:
	asu64(R1) = e;
	if (asu64(R1)) goto L1196;
L1190:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1188:
	asu64(R1) = d;
	if (asu64(R1)) goto L1185;
	pc_diags_psline();
	asu64(R1) = pc_diags_dest;
	goto L1184;
L1184:
	return asu64(R1);
}

static void pc_diags_writepsymbol(u64 d, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u8 localfile;
	struct $B16 str;
	i64 av_1;
	R1 = 0;
	localfile = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("4");
	asu64(R2) = d;
	R3 = 120;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = (u64)&pc_tables_idnames;
	asu64(R2) = d;
	R3 = 72;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	R1 = 8;
	R2 = (u64)&pc_tables_idnames;
	asu64(R3) = d;
	R4 = 72;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1203;
L1201:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	if (--asi64(av_1)) goto L1201;
L1203:
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmt;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1205;
	R1 = tou64(" Pm:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" Loc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	pc_diags_psint(asi64(R1));
L1205:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1207;
	R1 = tou64(" Exp");
	pc_diags_psstr(asu64(R1));
L1207:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1209;
	R1 = tou64(" Imp");
	pc_diags_psstr(asu64(R1));
L1209:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1211;
	R1 = tou64(" Var:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
L1211:
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1213;
	R1 = tou64(" TC");
	pc_diags_psstr(asu64(R1));
L1213:
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1215;
	R1 = tou64(" Dot");
	pc_diags_psstr(asu64(R1));
L1215:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1217;
	R1 = tou64(" ENTRY PT");
	pc_diags_psstr(asu64(R1));
L1217:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1219;
	R1 = tou64(" .PCADDR =");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
L1219:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1221;
	R1 = tou64(" (");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1221:
	R1 = 0;
	if (!asu16(R1)) goto L1223;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1223;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1223;
	R1 = tou64(" (Proc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(") (D:");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1223:
	R1 = 0;
	if (!asu16(R1)) goto L1225;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1225;
	asu64(R1) = d;
	R2 = 104;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1225;
	R1 = tou64(" Has statics");
	pc_diags_psstr(asu64(R1));
L1225:
	pc_diags_psline();
	return;
}

static void pc_diags_showprocinfo(u64 d) {
    u64 R1, R2; 
	struct $B16 str;
	u64 p;
	u64 e;
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1228;
	goto L1226;
L1228:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("PROC INFO FOR: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Params:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Locals:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Leaf:     #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Nmaxargs: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Assem:    #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  MCLdone:  #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Hasblocks:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1232;
L1229:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Pm: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1232:
	asu64(R1) = e;
	if (asu64(R1)) goto L1229;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1236;
L1233:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Loc: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1236:
	asu64(R1) = e;
	if (asu64(R1)) goto L1233;
	pc_diags_psline();
L1226:
	return;
}

static i64 pc_diags_newconvertstring(u64 s, u64 t, i64 length) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	i64 av_1;
	asu64(R1) = t;
	t0 = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1240;
L1238:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1242;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1243;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1244;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1245;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1246;
	goto L1247;
L1242:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1241;
L1243:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1241;
L1244:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1241;
L1245:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1241;
L1246:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1241;
L1247:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1249;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1249;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1248;
L1249:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z3x8");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1248:
L1241:
	if (--asi64(av_1)) goto L1238;
L1240:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1237;
L1237:
	return asi64(R1);
}

static void pc_reduce_pcl_reducetest() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 nn;
	i64 seqno;
	i64 lab;
	i64 lab2;
	i64 nargs;
	u64 pc;
	u64 newpc;
	u64 pcnext;
	u64 pcnext2;
	u64 pcproc;
	u64 labelmap;
	u64 pdef;
	struct $B36 callstack;
	i64 ncall;
	i64 nprocs;
	i64 nleaf;
	i64 nallparams;
	i64 nalllocals;
	i64 offset;
	i64 av_1;
	R1 = 0;
	nprocs = asi64(R1);
	R1 = 0;
	nleaf = asi64(R1);
	R1 = 0;
	nallparams = asi64(R1);
	R1 = 0;
	nalllocals = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nn = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	goto L1254;
L1251:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1256;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1257;
	goto L1258;
L1256:
	goto L1255;
L1257:
	asu64(R1) = pc_api_icheckasmlabel;
	if (!asu64(R1)) goto L1260;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_icheckasmlabel;
	asi64(R1) = ((F17)R2)(asu64(R1));
	lab = asi64(R1);
	asi64(R1) = lab;
	if (!asi64(R1)) goto L1262;
	asu64(R1) = labelmap;
	asi64(R2) = lab;
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1262:
L1260:
	goto L1255;
L1258:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1264;
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1264:
L1255:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1254:
	asu64(R1) = pc;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1251;
// pc_reduce.pcl_reducetest.skip:
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	newpc = asu64(R1);
	R1 = 0;
	seqno = asi64(R1);
	asi64(R1) = nn;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1268;
L1266:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcnext = asu64(R1);
	R1 = (u64)&pc_tables_pclargs;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	nargs = asi64(R2);
	if (!asi64(R1)) goto L1270;
	asi64(R1) = nargs;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L1272;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	nargs = asi64(R1);
L1272:
	asu64(R1) = pc_decls_pinfo;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = nargs;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1270:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1274;
	asu64(R1) = pc_decls_pinfo;
	if (!asu64(R1)) goto L1274;
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1274;
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1274:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1276;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1277;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1278;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1278;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L1279;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L1279;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1279;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1279;
	R2 = 131;
	if (asi64(R1) == asi64(R2)) goto L1280;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1281;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1282;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1283;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1283;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L1284;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L1285;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1286;
	goto L1287;
L1276:
	goto L1275;
L1277:
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu16(R1) = *tou16p(((i64)R1+(i64)R2*2-2));
	if (!asu16(R1)) goto L1289;
	goto L1287;
	goto L1287;
L1289:
	goto L1275;
L1278:
	R1 = (u64)&nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdef = asu64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pdef;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	asu64(R2) = pdef;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&nallparams;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&nalllocals;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	ncall = asi64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcproc = asu64(R1);
	goto L1287;
	goto L1287;
	goto L1275;
L1279:
	R1 = 0;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&ncall;
	(*toi64p(R1)) -=1;
	goto L1287;
	goto L1287;
	goto L1275;
L1280:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = newpc;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = (u64)&callstack;
	R3 = (u64)&ncall;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1275;
L1281:
	asu64(R1) = pc_decls_pinfo;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1291;
	R1 = (u64)&nleaf;
	(*toi64p(R1)) += 1;
L1291:
	R1 = 0;
	pc_decls_pinfo = asu64(R1);
	goto L1287;
	goto L1287;
	goto L1275;
L1282:
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1287;
	goto L1287;
	goto L1275;
L1283:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1293;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1293;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = newpc;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1295;
	R1 = 3;
	goto L1294;
L1295:
	R1 = 6;
L1294:
	asu64(R2) = newpc;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1292;
L1293:
	goto L1287;
	goto L1287;
L1292:
	goto L1275;
L1284:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) != asi64(R2)) goto L1297;
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L1297;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1296;
L1297:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1299;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1298;
L1299:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1296;
L1298:
	goto L1287;
	goto L1287;
L1296:
	goto L1275;
L1285:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1302;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1302;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1301;
L1302:
	asu64(R1) = newpc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) != asi64(R2)) goto L1301;
	goto L1300;
L1301:
	goto L1287;
	goto L1287;
L1300:
	goto L1275;
L1286:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1304;
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = newpc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1305;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1305;
	R1 = 1;
	goto L1306;
L1305:
	R1 = 0;
L1306:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L1304;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pcnext;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = pcnext;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = newpc;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1303;
L1304:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1307;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1303;
L1307:
	goto L1287;
	goto L1287;
L1303:
	goto L1275;
L1287:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = newpc;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1309;
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1312;
	asu64(R1) = newpc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1311;
L1312:
	R1 = 1;
	asu64(R2) = newpc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1311:
L1309:
L1275:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	if (--asi64(av_1)) goto L1266;
L1268:
	asu64(R1) = newpc;
	pc_api_pccurr = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void pc_run_dummy_pcl_runpcl() {
	return;
}

static void mc_genmcl_genmcl(u64 dummy) {
    u64 R1, R2, R3; 
	i64 tt;
	i64 i;
	asu8(R1) = pc_decls_mcldone;
	if (!asu8(R1)) goto L1316;
	goto L1314;
L1316:
	asi64(R1) = mnoos_os_clock();
	tt = asi64(R1);
	mc_genmcl_inithandlers();
	R1 = 0;
	mc_libmcl_mclinit(asi64(R1));
	asu64(R1) = pc_api_pcstart;
	mc_decls_currpcl = asu64(R1);
	R1 = 0;
	i = asi64(R1);
L1317:
	asu64(R1) = mc_decls_currpcl;
	mc_genmcl_convertpcl(asu64(R1));
	R1 = 0;
	if (!asu16(R1)) goto L1321;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1321;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1321;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1321;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1321;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1321;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1321;
	mc_stackmcl_showopndstack();
L1321:
	R1 = (u64)&mc_decls_currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = mc_decls_currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1322;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) != asi64(R2)) goto L1317;
L1322:
	mc_auxmcl_genrealtable();
	mc_auxmcl_genabsneg();
	mc_auxmcl_genstringtable();
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L1324;
	mc_optim_peephole();
L1324:
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
L1314:
	return;
}

static void mc_genmcl_convertpcl(u64 p) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 oldregset;
	i64 reg;
	i64 i;
	asu8(R1) = pc_decls_fshowil;
	if (!asu8(R1)) goto L1327;
	asu64(R1) = p;
	mc_genmcl_doshowpcl(asu64(R1));
L1327:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	mc_decls_pmode = asu8(R1);
	asu64(R1) = p;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pc_decls_ppseqno = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	((F18)R2)(asu64(R1));
	(R1_B3) = mc_decls_regset;
	oldregset = (R1_B3);
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1330;
L1328:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L1332;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1334;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1333;
L1334:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1333:
L1332:
	i += 1; if (i <= mc_decls_noperands) goto L1328;
L1330:
	R1 = (u64)&oldregset;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 48;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	R1 = (u64)&oldregset;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 56;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	return;
}

static void mc_genmcl_inithandlers() {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	i64 n;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	i64 k;
// PROC LOCAL STATICS GO HERE
	static u8 mc_genmcl_inithandlers_initdone = 0;
	static struct $B26 mc_genmcl_inithandlers_dupltable = {{
22605,
	16449,
	4629,
	4627,
	4630,
	30327,
	30841,
	12126,
	12383    }};
	asu8(R1) = mc_genmcl_inithandlers_initdone;
	if (!asu8(R1)) goto L1337;
	goto L1335;
L1337:
	asi64(R1) = $nprocs;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1340;
L1338:
	R1 = (u64)&$procname;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 3;
	R2 = tou64("px_");
	asu64(R3) = name;
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L1342;
	R1 = 0;
	k = asi64(R1);
	R1 = 142;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1346;
L1343:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	s = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) != asu64(R2)) goto L1348;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L1348:
	asu64(R1) = name;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1350;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L1345;
L1350:
	k += 1; if (k <= av_1) goto L1343;
L1346:
	asu64(R1) = name;
	R2 = tou64("Invalid handler name:");
	pc_api_merror(asu64(R2), asu64(R1));
L1345:
L1342:
	i += 1; if (i <= n) goto L1338;
L1340:
	R1 = 1;
	i = asi64(R1);
	R1 = 9;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1353;
L1351:
	R1 = (u64)&mc_genmcl_px_handlertable;
	R2 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R3) = i;
	R2 += (i64)R3*2-2;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	R3 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R4) = i;
	R3 += (i64)R4*2-2;
	R4 = 1;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L1351;
L1353:
	R1 = 0;
	i = asi64(R1);
	R1 = 142;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1356;
L1354:
	R1 = (u64)&mc_genmcl_px_handlertable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (asu64(R1)) goto L1358;
	R1 = (u64)&mc_genmcl_unimpl;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L1358:
	i += 1; if (i <= av_3) goto L1354;
L1356:
	R1 = 1;
	mc_genmcl_inithandlers_initdone = asu8(R1);
L1335:
	return;
}

static void mc_genmcl_doshowpcl(u64 p) {
    u64 R1, R2; 
	struct $B79 str;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1361;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1361;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1361;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1361;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1361;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1361;
	goto L1362;
L1361:
	goto L1360;
L1362:
	R1 = tou64("                       ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1256;
	asu64(R2) = p;
	asu64(R1) = pc_diags_strpclstr(asu64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
L1360:
	return;
}

static void mc_genmcl_unimpl(u64 p) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Unimpl: # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_nop(u64 p) {
	return;
}

static void mc_genmcl_px_dupl(u64 p) {
	mc_stackmcl_duplpcl();
	return;
}

static void mc_genmcl_px_double(u64 p) {
    u64 R1, R2; 
	asi64(R1) = mc_decls_ncalldepth;
	if (!asi64(R1)) goto L1368;
	mc_stackmcl_duplpcl();
	goto L1367;
L1368:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L1367:
	return;
}

static void mc_genmcl_px_opnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_type(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_comment(u64 p) {
	return;
}

static void mc_genmcl_px_proc(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_currfunc = asu64(R1);
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 1;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	mc_auxmcl_initproc(asu64(R1));
	R1 = tou64("?>>");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mclprocentry = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1374;
	asu64(R1) = pc_decls_currfunc;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1374;
	asu8(R1) = pepcl_pdcc;
	if (asu8(R1)) goto L1374;
	mc_auxmcl_fixmain();
L1374:
	return;
}

static void mc_genmcl_px_endproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1377;
	msysc_m$print_startcon();
	R1 = tou64("PCL STACK NOT EMPTY");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PCL STACK NOT EMPTY");
	mc_libmcl_mgencomment(asu64(R1));
L1377:
	R1 = 0;
	R2 = 0;
	R3 = 2;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endprog(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_istatic(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_zstatic(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_data(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 opc;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1383;
	asu64(R1) = p;
	mc_auxmcl_do_blockdata(asu64(R1));
	goto L1381;
L1383:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1385;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1386;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1387;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1388;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1389;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1390;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1391;
	goto L1392;
L1385:
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1384;
L1386:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1384;
L1387:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1384;
L1388:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1384;
L1389:
	asu64(R1) = p;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R2), asi64(R1));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1384;
L1390:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1384;
L1391:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1384;
L1392:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("db/dq optype? #");
	pc_api_merror(asu64(R2), asu64(R1));
L1384:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1394;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1395;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1396;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1397;
	goto L1398;
L1394:
	R1 = 116;
	opc = asi64(R1);
	goto L1393;
L1395:
	R1 = 117;
	opc = asi64(R1);
	goto L1393;
L1396:
	R1 = 118;
	opc = asi64(R1);
	goto L1393;
L1397:
	R1 = 119;
	opc = asi64(R1);
	goto L1393;
L1398:
	msysc_m$print_startcon();
	R1 = tou64("P.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STRPMODE(P.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("DATA/not 1248");
	pc_api_merror(asu64(R2), asu64(R1));
L1393:
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1381:
	return;
}

static void mc_genmcl_px_label(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_load(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_stackmcl_pushpcl(asu64(R1));
	return;
}

static void mc_genmcl_px_store(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 d;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1403;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1402;
L1403:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 6;
	asu64(R2) = d;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	asu64(R3) = d;
	R4 = 72;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 5;
	if (asi64(R3) != asi64(R4)) goto L1405;
	R3 = 11;
	goto L1404;
L1405:
	R3 = 14;
L1404:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L1402:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_add(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1408;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1410;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1410;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 52;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1409;
L1410:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1409:
	goto L1407;
L1408:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 65;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1407:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_sub(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1413;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1415;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1415;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1414;
L1415:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1414:
	goto L1412;
L1413:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 67;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1412:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_mul(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	i64 x;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1418;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1420;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1419;
L1420:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1419:
	goto L1417;
L1418:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 69;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1417:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_div(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 71;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_eval(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_widen(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1425;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1425;
	R1 = 0;
	R2 = 5;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1427;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1427:
	goto L1424;
L1425:
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = (u64)&pc_tables_psigned;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	if (!asu8(R3)) goto L1429;
	R3 = 18;
	goto L1428;
L1429:
	R3 = 19;
L1428:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1424:
	return;
}

static void mc_genmcl_px_jump(u64 p) {
    u64 R1, R2, R3; 
	i64 labno;
	u64 q;
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	goto L1432;
L1431:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
L1432:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1431;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1435;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1436;
	goto L1437;
L1435:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1439;
	goto L1430;
L1439:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) != asi64(R2)) goto L1441;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1441;
	goto L1430;
L1441:
	goto L1434;
L1436:
	R1 = 0;
	asu64(R2) = q;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1434;
L1437:
L1434:
	R1 = 0;
	asi64(R2) = labno;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1430:
	return;
}

static void mc_genmcl_px_ijump(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_neg(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1445;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1444;
L1445:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
L1444:
	return;
}

static void mc_genmcl_px_abs(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 lx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1448;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1447;
L1448:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L1447:
	return;
}

static void mc_genmcl_px_bitnot(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_not(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 cx;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1453;
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = cx;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1455;
	R3 = 5;
	goto L1454;
L1455:
	R3 = 4;
L1454:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1452;
L1453:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1457;
	R3 = 5;
	goto L1456;
L1457:
	R3 = 4;
L1456:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-3)) = asu8(R1);
L1452:
	return;
}

static void mc_genmcl_px_sqr(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1460;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1459;
L1460:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 69;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1459:
	return;
}

static void mc_genmcl_px_sqrt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 63;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_jumpcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 mcond;
	u64 ax;
	u64 bx;
	u64 lx;
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	lx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1464;
	R1 = tou64("");
	R2 = tou64("JUMPCC/BLOCK");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1463;
L1464:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1466;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1468;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1468;
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1469;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1468;
L1469:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1467;
L1468:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1471;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
L1471:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1467:
	goto L1465;
L1466:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1465:
	R1 = 0;
	asu64(R2) = lx;
	asi64(R3) = mcond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1473;
	mc_stackmcl_poppcl();
L1473:
L1463:
	return;
}

static void mc_genmcl_px_jumpt(u64 p) {
    u64 R1, R2; 
	R1 = 5;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_jumpf(u64 p) {
    u64 R1, R2; 
	R1 = 4;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitand(u64 p) {
    u64 R1, R2; 
	R1 = 38;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitor(u64 p) {
    u64 R1, R2; 
	R1 = 39;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxor(u64 p) {
    u64 R1, R2; 
	R1 = 40;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shl(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shr(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1482;
	R1 = 44;
	goto L1481;
L1482:
	R1 = 45;
L1481:
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_retproc(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mclprocentry;
	asu64(R2) = mc_decls_mccodex;
	if (asu64(R1) != asu64(R2)) goto L1485;
	R1 = tou64("---");
	mc_libmcl_mgencomment(asu64(R1));
L1485:
	asu64(R1) = p;
	mc_auxmcl_do_procentry(asu64(R1));
	mc_auxmcl_do_procexit();
	return;
}

static void mc_genmcl_px_retfn(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1488;
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 6;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1488:
	asu64(R1) = p;
	mc_genmcl_px_retproc(asu64(R1));
	return;
}

static void mc_genmcl_px_setcall(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	asi64(R1) = mc_decls_ncalldepth;
	R2 = 16;
	if (asi64(R1) < asi64(R2)) goto L1491;
	R1 = tou64("");
	R2 = tou64("Too many nested calls");
	pc_api_merror(asu64(R2), asu64(R1));
L1491:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1493;
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1492;
L1493:
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asi64(R2) = mc_decls_mstackdepth;
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1492:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callblocksize;
	asi64(R3) = mc_decls_ncalldepth;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1495;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
L1495:
	return;
}

static void mc_genmcl_px_setarg(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_callargmode;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*32-32;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*128-128;
	asi64(R3) = n;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1498;
	R1 = 6;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1497;
L1498:
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1497:
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L1500;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	mc_stackmcl_pushopnd(asi64(R3), asi64(R2), asi64(R1));
	goto L1499;
L1500:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1501;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*128-128;
	asi64(R3) = n;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
L1501:
L1499:
	return;
}

static void mc_genmcl_px_callp(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 nargs;
	i64 nregargs;
	i64 slots;
	i64 isptr;
	i64 shadow;
	i64 blockret;
	i64 av_1;
	R1 = 0;
	isptr = asi64(R1);
	R1 = 0;
	shadow = asi64(R1);
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	nargs = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nregargs = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1505;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L1504;
L1505:
	R1 = 1;
	isptr = asi64(R1);
L1504:
	R1 = 0;
	asi64(R2) = isptr;
	asu64(R3) = p;
	R4 = 20;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R4) = nregargs;
	mc_auxmcl_do_pushlowargs(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1507;
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L1509;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	goto L1508;
L1509:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L1508:
	goto L1506;
L1507:
	asi64(R1) = nargs;
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	slots = asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
L1506:
	asi64(R1) = isptr;
	if (!asi64(R1)) goto L1511;
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L1510;
L1511:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1510:
	asi64(R1) = nregargs;
	asi64(R2) = blockret;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1514;
L1512:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L1512;
L1514:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L1516;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L1516:
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1518;
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
L1518:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mc_genmcl_px_jumpret(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1521;
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1523;
	R1 = 1;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
L1523:
L1521:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_jumpretm(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	i64 reg;
	i64 av_1;
	i64 av_2;
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1527;
L1525:
	R1 = 0;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1525;
L1527:
	R1 = 1;
	reg = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1530;
L1528:
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1532;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1532;
	R1 = 11;
	reg = asi64(R1);
L1532:
	asi64(R1) = reg;
	mc_stackmcl_movetoreg(asi64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	if (--asi64(av_2)) goto L1528;
L1530:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_startmx(u64 p) {
    u64 R1; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	return;
}

static void mc_genmcl_px_resetmx(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L1536;
	mc_stackmcl_poppcl();
L1536:
	return;
}

static void mc_genmcl_px_stop(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 11;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = tou64("exit*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_incrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_incrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadincr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loaddecr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_forup(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 14;
	R2 = 28;
	R3 = 52;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fordown(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 13;
	R2 = 29;
	R3 = 53;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_iload(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 px;
	u64 nextpcl;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1548;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1550;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L1549;
L1550:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L1549:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L1552;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L1551;
L1552:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1551:
	goto L1547;
L1548:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
L1547:
	return;
}

static i64 mc_genmcl_getsharereg(u64 ax, i64 mode) {
    u64 R1, R2; 
	u8 reg;
	u8 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	reg = asu8(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	regix = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1555;
	R1 = 0;
	goto L1553;
L1555:
	asu8(R1) = reg;
	if (!asu8(R1)) goto L1557;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = reg;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1558;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L1557;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L1557;
L1558:
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	goto L1553;
	goto L1556;
L1557:
	asu8(R1) = regix;
	if (!asu8(R1)) goto L1559;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = regix;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1560;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L1559;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L1559;
L1560:
	asu8(R1) = regix;
	R1 = toi64(tou8(R1));
	goto L1553;
L1559:
L1556:
	R1 = 0;
	goto L1553;
L1553:
	return asi64(R1);
}

static void mc_genmcl_px_iloadx(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 z;
	u64 nextpcl;
	u64 ax;
	u64 bx;
	u64 px;
	u64 fx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1563;
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1562;
L1563:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L1565;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L1564;
L1565:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1564:
L1562:
	return;
}

static void mc_genmcl_px_istore(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 bx;
	u64 px;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1568;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L1567;
L1568:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L1567:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1570;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1569;
L1570:
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1569:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_istorex(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 px;
	u64 z;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1573;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	cx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = cx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1572;
L1573:
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1572:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_storem(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 z;
	u64 dblock;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1576;
	R1 = tou64("");
	R2 = tou64("Storem not 16");
	pc_api_merror(asu64(R2), asu64(R1));
L1576:
	R1 = 16;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	R2 = 0;
	R3 = 8;
	asu64(R4) = px;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = px;
	R2 = 6;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_addpx(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 cx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	cx = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subpx(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 scale;
	i64 extra;
	i64 offset;
	u64 ax;
	u64 bx;
	u64 z;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1580;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R3) = extra;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1579;
L1580:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = scale;
	asu64(R2) = bx;
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L1582;
	asi64(R1) = scale;
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
L1582:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = extra;
	if (!asi64(R1)) goto L1584;
	msysc_m$print_startcon();
	R1 = tou64("EXTRA=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = extra;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUBREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L1584:
L1579:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_to(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 ax;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	q = asu64(R1);
	R1 = 6;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_iswap(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 qx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	qx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1588;
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qx;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = qx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1587;
L1588:
	R1 = tou64("");
	R2 = tou64("swap/block");
	pc_api_merror(asu64(R2), asu64(R1));
L1587:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swapstk(u64 p) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_noperands;
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_labeldef(u64 p) {
    u64 R1, R2; 
	struct $B5 str;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(":");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_addto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 65;
	R2 = 28;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 67;
	R2 = 29;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_multo(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 cx;
	u64 x;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1595;
	R1 = 69;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L1593;
L1595:
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1597;
	R1 = tou64("");
	R2 = tou64("multo/byte");
	pc_api_merror(asu64(R2), asu64(R1));
L1597:
	R1 = 0;
	R2 = 10;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	x = asu64(R2);
	if (!asu64(R1)) goto L1599;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = cx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1598;
L1599:
	asu64(R1) = bx;
	asu64(R2) = cx;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1598:
	asu64(R1) = cx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L1593:
	return;
}

static void mc_genmcl_px_bitandto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 38;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 39;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 40;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shlto(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shrto(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1606;
	R1 = 44;
	goto L1605;
L1606:
	R1 = 45;
L1605:
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fix(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 fx;
	u64 ax;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&pc_tables_pmin;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = fx;
	asu64(R2) = ax;
	R3 = 84;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_float(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 fx;
	i64 lab;
	i64 lab2;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1610;
	R1 = tou64("");
	R2 = tou64("float/short");
	pc_api_merror(asu64(R2), asu64(R1));
L1610:
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1612;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 86;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L1611;
L1612:
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1613;
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab2 = asi64(R1);
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 12;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab2;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	asi64(R1) = mc_decls_labmask63;
	if (asi64(R1)) goto L1615;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_labmask63 = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_laboffset64 = asi64(R1);
L1615:
	asi64(R1) = mc_decls_labmask63;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_laboffset64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = fx;
	R3 = 66;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab2;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
// mc_genmcl.px_float.reduce:
L1616:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1618;
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1618:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L1611;
L1613:
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1616;
L1611:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_idiv(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_irem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_idivrem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 2;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_clear(u64 p) {
    u64 R1, R2; 
	u64 ax;
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = ax;
	mc_auxmcl_clearblock(asu64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 n;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L1625;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L1627;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1626;
L1627:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUB/REF NOT POWER OF xx");
	pc_api_merror(asu64(R2), asu64(R1));
L1626:
L1625:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_switch(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 elselab;
	i64 reg;
	u64 ax;
	u64 bx;
	u64 ax2;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = mc_decls_currpcl;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	elselab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L1630;
	asu64(R1) = ax;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	ax2 = asu64(R3);
	R3 = 18;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax2;
	ax = asu64(R1);
L1630:
	asi64(R1) = minlab;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1632;
	R1 = 10;
	asi64(R2) = minlab;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1632:
	R1 = 10;
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = elselab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 3;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1634;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	R1 = 6;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1633;
L1634:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1633:
	mc_stackmcl_poppcl();
	R1 = 1;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_switchu(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 reg;
	u64 ax;
	u64 bx;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1637;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1636;
L1637:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1636:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swlabel(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endsw(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fwiden(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 8;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 89;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_fnarrow(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_truncate(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = pmode2;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L1644;
	asu64(R1) = ax;
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = (u64)&mc_decls_ploadop;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1644:
	return;
}

static void mc_genmcl_px_typepun(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_unload(u64 p) {
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_loadbit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 z;
	i64 i;
	i64 m;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1649;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1651;
	R2 = 31;
	if (asi64(R1) > asi64(R2)) goto L1651;
	R1 = 5;
	goto L1650;
L1651:
	R1 = 6;
L1650:
	m = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = i;
	if (!asi64(R1)) goto L1653;
	asi64(R1) = m;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L1655;
	goto L1656;
L1655:
L1653:
	goto L1648;
L1649:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1658;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1658:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1660;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1660:
L1648:
	R1 = 5;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
// mc_genmcl.px_loadbit.skip:
L1656:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_assem(u64 p) {
    u64 R1, R2; 
	asu64(R1) = pc_api_idomcl_assem;
	if (!asu64(R1)) goto L1663;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_idomcl_assem;
	((F18)R2)(asu64(R1));
	goto L1662;
L1663:
	R1 = tou64("");
	R2 = tou64("No Assem handler");
	pc_api_merror(asu64(R2), asu64(R1));
L1662:
	return;
}

static void mc_genmcl_px_sin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("sin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_cos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("cos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_tan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("tan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_asin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("asin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_acos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("acos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("atan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log10(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log10*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_exp(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("exp*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_round(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("round*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_floor(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("floor*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_ceil(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("ceil*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan2(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("atan2*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fmod(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("fmod*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_setcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 cond;
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1680;
	R1 = tou64("");
	R2 = tou64("setcc/block");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1679;
L1680:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1681;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1683;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
L1683:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	cx = asu64(R1);
	goto L1679;
L1681:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	R1 = 10;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
L1679:
	R1 = 0;
	asu64(R2) = cx;
	asi64(R3) = cond;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_min(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1686;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1688;
	R1 = 15;
	goto L1687;
L1688:
	R1 = 7;
L1687:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L1685;
L1686:
	R1 = 112;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L1685:
	return;
}

static void mc_genmcl_px_max(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1691;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1693;
	R1 = 12;
	goto L1692;
L1693:
	R1 = 2;
L1692:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L1690;
L1691:
	R1 = 113;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L1690:
	return;
}

static void mc_genmcl_px_power(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 d;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1696;
	R1 = 82;
	asu64(R1) = mc_auxmcl_gethostfn(asi64(R1));
	d = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	asu64(R2) = d;
	asu64(R3) = p;
	mc_auxmcl_do_host(asu64(R3), asu64(R2), asi64(R1));
	goto L1695;
L1696:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("pow*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
L1695:
	return;
}

static void mc_genmcl_px_minto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1699;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L1701;
	R2 = 14;
	goto L1700;
L1701:
	R2 = 6;
L1700:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L1698;
L1699:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L1698:
	return;
}

static void mc_genmcl_px_maxto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1704;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L1706;
	R2 = 13;
	goto L1705;
L1706:
	R2 = 3;
L1705:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L1703;
L1704:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L1703:
	return;
}

static void mc_genmcl_px_negto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1709;
	R1 = 0;
	asu64(R2) = px;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1708;
L1709:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	fx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = fx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = fx;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
	asu64(R1) = fx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1708:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_absto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 lx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1712;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1711;
L1712:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L1711:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_addpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1715;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1714;
L1715:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1714:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1718;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1717;
L1718:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1720;
	R1 = tou64("");
	R2 = tou64("SUBTOREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L1720:
L1717:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_divto(u64 p) {
    u64 R1, R2; 
	R1 = 71;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitnotto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu64(R2) = px;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_notto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = px;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	R3 = 5;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_sign(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 lx1;
	u64 lx2;
	u64 lx3;
	u8 gtop;
	u8 ltop;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1727;
	R1 = 7;
	gtop = asu8(R1);
	R1 = 2;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asr64(R2) = 0.000000000000000000e+000;
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1726;
L1727:
	R1 = 15;
	gtop = asu8(R1);
	R1 = 12;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1726:
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx1 = asu64(R3);
	asu8(R3) = gtop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx2 = asu64(R3);
	asu8(R3) = ltop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx3 = asu64(R3);
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx1;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = bx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx2;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = bx;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadbf(u64 p) {
    u64 R1, R2, R3; 
	u64 y;
	u64 z;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	y = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	z = asu64(R1);
	asu64(R1) = y;
	if (!asu64(R1)) goto L1730;
	asu64(R1) = z;
	if (!asu64(R1)) goto L1730;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	mc_auxmcl_do_loadbf_const(asu64(R3), asi64(R2), asi64(R1));
	goto L1729;
L1730:
	asu64(R1) = p;
	mc_auxmcl_do_loadbf_var(asu64(R1));
L1729:
	return;
}

static void mc_genmcl_px_storebit(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebit(asu64(R1));
	return;
}

static void mc_genmcl_px_storebf(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebf(asu64(R1));
	return;
}

static void mc_genmcl_px_loadall(u64 p) {
	mc_stackmcl_checkallloaded();
	return;
}

static void mc_genmcl_px_setjmp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 lab;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = lab;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	R2 = 0;
	R3 = 8;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dframeopnd;
	R2 = 0;
	R3 = 16;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	asu64(R1) = p;
	mc_stackmcl_freeworkregs(asu64(R1));
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	return;
}

static void mc_genmcl_px_longjmp(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 16;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	R1 = 1;
	mc_stackmcl_swapopndregs(asi64(R1));
	R1 = 0;
	asu64(R2) = cx;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_initdswx(u64 p) {
	return;
}

static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf) {
    u64 R1, R2, R3; 
	struct $B17 params;
	struct $B17 xparams;
	struct $B17 leafparams;
	struct $B17 xleafparams;
	u32 leafparamno;
	u32 xleafparamno;
	struct $B16 locals;
	struct $B16 xlocals;
	i64 nparams;
	i64 nxparams;
	i64 nleafparams;
	i64 nxleafparams;
	i64 nlocals;
	i64 nxlocals;
	i64 n;
	i64 reg;
	i64 xreg;
	i64 nl;
	i64 np;
	i64 nlx;
	i64 npx;
	u64 d;
	i64 i;
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nxparams = asi64(R1);
	R1 = 0;
	nleafparams = asi64(R1);
	R1 = 0;
	nxleafparams = asi64(R1);
	R1 = 0;
	nlocals = asi64(R1);
	R1 = 0;
	nxlocals = asi64(R1);
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = mc_decls_maxxregvars;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1739;
	goto L1737;
L1739:
	asi64(R1) = skipparams;
	if (asi64(R1)) goto L1741;
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L1745;
L1742:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1747;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1747;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1747;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1747;
	asi64(R1) = isleaf;
	if (asi64(R1)) goto L1749;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1751;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1753;
	asu64(R1) = d;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1753:
	goto L1750;
L1751:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1754;
	asi64(R1) = nxparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1756;
	asu64(R1) = d;
	R2 = (u64)&xparams;
	R3 = (u64)&nxparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1756:
L1754:
L1750:
	goto L1748;
L1749:
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1758;
	asi64(R1) = nleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1760;
	asu64(R1) = d;
	R2 = (u64)&leafparams;
	R3 = (u64)&nleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&leafparamno;
	asi64(R3) = nleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1760:
	goto L1757;
L1758:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1761;
	asi64(R1) = nxleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1763;
	asu64(R1) = d;
	R2 = (u64)&xleafparams;
	R3 = (u64)&nxleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&xleafparamno;
	asi64(R3) = nxleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1763:
L1761:
L1757:
L1748:
L1747:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1745:
	asu64(R1) = d;
	if (asu64(R1)) goto L1742;
L1741:
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L1767;
L1764:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1769;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1769;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1769;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1771;
	asi64(R1) = nlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L1773;
	asu64(R1) = d;
	R2 = (u64)&locals;
	R3 = (u64)&nlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1773:
	goto L1770;
L1771:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1774;
	asi64(R1) = nxlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L1774;
	asu64(R1) = d;
	R2 = (u64)&xlocals;
	R3 = (u64)&nxlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1774:
L1770:
L1769:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1767:
	asu64(R1) = d;
	if (asu64(R1)) goto L1764;
	asi64(R1) = nlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1776;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	np = asi64(R1);
	R1 = 0;
	nl = asi64(R1);
	goto L1775;
L1776:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1777;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nl = asi64(R1);
	R1 = 0;
	np = asi64(R1);
	goto L1775;
L1777:
	asi64(R1) = nlocals;
	nl = asi64(R1);
	asi64(R1) = nparams;
	np = asi64(R1);
	asi64(R1) = np;
	asi64(R2) = nl;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1779;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1781;
	asi64(R1) = np;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1781;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L1781:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1783;
	asi64(R1) = n;
	R2 = (u64)&nl;
	*toi64p(R2) -= asi64(R1);
L1783:
L1779:
L1775:
	R1 = 4;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nl;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1786;
L1784:
	R1 = (u64)&locals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= nl) goto L1784;
L1786:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = np;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1789;
L1787:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= np) goto L1787;
L1789:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1792;
L1790:
	R1 = (u64)&leafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&leafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1794;
	R1 = 1;
	pc_decls_r10used = asu8(R1);
L1794:
	asi64(R1) = reg;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L1796;
	R1 = 1;
	pc_decls_r11used = asu8(R1);
L1796:
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nleafparams) goto L1790;
L1792:
	asi64(R1) = nxlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1798;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npx = asi64(R1);
	R1 = 0;
	nlx = asi64(R1);
	goto L1797;
L1798:
	asi64(R1) = nxparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1799;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nlx = asi64(R1);
	R1 = 0;
	npx = asi64(R1);
	goto L1797;
L1799:
	asi64(R1) = nxlocals;
	nlx = asi64(R1);
	asi64(R1) = nxparams;
	npx = asi64(R1);
	asi64(R1) = npx;
	asi64(R2) = nlx;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1801;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1803;
	asi64(R1) = npx;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1803;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L1803:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1805;
	asi64(R1) = n;
	R2 = (u64)&nlx;
	*toi64p(R2) -= asi64(R1);
L1805:
L1801:
L1797:
	R1 = 16;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1808;
L1806:
	R1 = (u64)&xlocals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= nlx) goto L1806;
L1808:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = npx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1811;
L1809:
	R1 = (u64)&xparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= npx) goto L1809;
L1811:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nxleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1814;
L1812:
	R1 = (u64)&xleafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&xleafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nxleafparams) goto L1812;
L1814:
L1737:
	return;
}

static void mc_auxmcl_initproc(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 e;
	u64 pinfi;
	i64 reg;
	i64 xreg;
	i64 n;
	i64 r;
	i64 npregs;
	i64 av_1;
	i64 av_2;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isregvar;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isxregvar;
	memset(R1, 0, 16);
	R1 = 3;
	mc_decls_nworkregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	mc_decls_maxxregvars = asi64(R2);
	mc_decls_maxregvars = asi64(R1);
	R1 = 0;
	npregs = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1817;
	R1 = 10;
	mc_decls_nworkregs = asi64(R1);
	R1 = 12;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 4;
	r = asi64(R1);
L1818:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 10) goto L1818;
	R1 = 7;
	r = asi64(R1);
L1821:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 16) goto L1821;
	goto L1816;
L1817:
	R1 = 4;
	asu64(R2) = pc_decls_currfunc;
	R3 = 112;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = pc_decls_pinfo;
	R4 = 4;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) = Max(asi64(R2), asi64(R3));
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npregs = asi64(R1);
	R1 = 4;
	mc_decls_nworkregs = asi64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1825;
	R1 = (u64)&mc_decls_nworkregs;
	(*toi64p(R1)) += 1;
L1825:
	R1 = 5;
	mc_decls_nworkxregs = asi64(R1);
	asi64(R1) = mc_decls_nworkregs;
	R2 = 3;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = npregs;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L1827;
	asi64(R1) = n;
	if (!asi64(R1)) goto L1827;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = npregs;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1829;
	asi64(R1) = n;
	if (!asi64(R1)) goto L1829;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L1829:
L1827:
	R1 = 10;
	r = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1832;
L1830:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_1)) goto L1830;
L1832:
	R1 = 7;
	r = asi64(R1);
	asi64(R1) = mc_decls_nworkxregs;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1835;
L1833:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_2)) goto L1833;
L1835:
L1816:
	R1 = 4;
	r = asi64(R1);
L1836:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1840;
	R1 = (u64)&mc_decls_maxregvars;
	(*toi64p(R1)) += 1;
L1840:
	r += 1; if (r <= 10) goto L1836;
	R1 = 7;
	r = asi64(R1);
L1841:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1845;
	R1 = (u64)&mc_decls_maxxregvars;
	(*toi64p(R1)) += 1;
L1845:
	r += 1; if (r <= 16) goto L1841;
	R1 = (u64)&mc_decls_usedregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_usedxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_pcltempflags;
	memset(R1, 0, 50);
	R1 = 0;
	R2 = R1;
	pc_decls_r11used = asu8(R2);
	pc_decls_r10used = asu8(R1);
	R1 = 0;
	mc_decls_mstackdepth = asi64(R1);
	R1 = 0;
	mc_decls_noperands = asi64(R1);
	R1 = 0;
	R2 = R1;
	mc_genmcl_framebytes = asi64(R2);
	R2 = R1;
	mc_genmcl_paramoffset = asi64(R2);
	mc_genmcl_frameoffset = asi64(R1);
	R1 = 0;
	pc_decls_localshadow = asu8(R1);
	R1 = 0;
	mc_decls_nblocktemps = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1847;
	R1 = 8;
	R2 = tou64("$1x");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	asu64(R2) = e;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = e;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = pc_decls_currfunc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	pc_decls_blockretname = asu64(R1);
L1847:
	asu8(R1) = pc_decls_fregoptim;
	if (!asu8(R1)) goto L1850;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1849;
L1850:
	goto L1815;
L1849:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1852;
	goto L1815;
L1852:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_decls_currfunc;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (asu8(R2)) goto L1853;
	asu64(R2) = pc_decls_currfunc;
	R3 = 113;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L1854;
L1853:
	R2 = 1;
	goto L1855;
L1854:
	R2 = 0;
L1855:
	mc_auxmcl_allocregvars(asi64(R2), asi64(R1));
L1815:
	return;
}

static void mc_auxmcl_do_procentry(u64 p) {
    u64 R1, R2, R3; 
	i64 retmode;
	i64 ntemps;
	i64 hasequiv;
	i64 offset;
	i64 size;
	i64 reg;
	u64 ax;
	u64 d;
	struct $B5 str;
	struct $B5 newname;
	i64 rr;
	i64 ff;
	i64 r;
	i64 i;
	asu64(R1) = mc_decls_mclprocentry;
	mc_auxmcl_setmclentry(asu64(R1));
	R1 = 0;
	R2 = R1;
	pc_decls_bxspill = asi64(R2);
	pc_decls_bspill = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1859;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1858;
L1859:
	R1 = 4;
	r = asi64(R1);
L1860:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1865;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1864;
L1865:
	R1 = (u64)&pc_decls_bspill;
	(*toi64p(R1)) += 1;
L1864:
	r += 1; if (r <= 10) goto L1860;
	R1 = 7;
	r = asi64(R1);
L1866:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1871;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1870;
L1871:
	R1 = (u64)&pc_decls_bxspill;
	(*toi64p(R1)) += 1;
L1870:
	r += 1; if (r <= 16) goto L1866;
L1858:
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L1875;
L1872:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1877;
	R1 = tou64("");
	R2 = tou64("@PARAM");
	pc_api_merror(asu64(R2), asu64(R1));
L1877:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1879;
	asi64(R1) = mc_genmcl_paramoffset;
	R2 = 16;
	asi64(R1) += asi64(R2);
	asi64(R2) = pc_decls_bspill;
	asi64(R3) = pc_decls_bxspill;
	asi64(R2) += asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writegas_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1878;
L1879:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1878:
	R1 = 8;
	R2 = (u64)&mc_genmcl_paramoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1875:
	asu64(R1) = d;
	if (asu64(R1)) goto L1872;
	asu64(R1) = pc_decls_currfunc;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	retmode = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L1883;
L1880:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1885;
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	size = asi64(R1);
L1885:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1887;
	goto L1881;
L1887:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1889;
	R1 = 1;
	hasequiv = asi64(R1);
	goto L1888;
L1889:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1890;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1888;
L1890:
	asi64(R1) = size;
	asi64(R1) = mc_libmcl_roundsizetg(asi64(R1));
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writegas_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1888:
L1881:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1883:
	asu64(R1) = d;
	if (asu64(R1)) goto L1880;
	R1 = 0;
	ntemps = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L1891:
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1895;
	R1 = (u64)&ntemps;
	(*toi64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&mc_decls_pcltempopnds;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ax = asu64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = ax;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asi64(R2) = i;
	asu64(R3) = pc_decls_currfunc;
	asu64(R2) = mc_writegas_gettempname(asu64(R3), asi64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1895:
	i += 1; if (i <= 50) goto L1891;
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1897;
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (asi16(R1)) goto L1900;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1899;
L1900:
	R1 = tou64("");
	R2 = tou64("Threaded proc has locals/params");
	pc_api_merror(asu64(R2), asu64(R1));
L1899:
	asi64(R1) = ntemps;
	if (!asi64(R1)) goto L1902;
	R1 = tou64("");
	R2 = tou64("Threaded proc has temps");
	pc_api_merror(asu64(R2), asu64(R1));
L1902:
	asu64(R1) = mc_auxmcl_resetmclentry();
	goto L1856;
L1897:
	asi64(R1) = mc_genmcl_frameoffset;
	asi64(R1) = -asi64(R1);
	mc_genmcl_framebytes = asi64(R1);
	asi64(R1) = pc_decls_bspill;
	asi64(R2) = pc_decls_bxspill;
	asi64(R1) += asi64(R2);
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1904;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L1906;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L1906:
	goto L1903;
L1904:
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L1908;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L1908:
L1903:
	asu8(R1) = pc_decls_localshadow;
	if (!asu8(R1)) goto L1910;
	R1 = 32;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L1910:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L1912;
	R1 = 4;
	r = asi64(R1);
L1913:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1918;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1917;
L1918:
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1917:
	r += 1; if (r <= 10) goto L1913;
L1912:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L1920;
	R1 = 6;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 7;
	r = asi64(R1);
L1921:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1926;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1925;
L1926:
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1925:
	r += 1; if (r <= 16) goto L1921;
L1920:
	R1 = tou64("?]]");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_auxmcl_mclframesetup = asu64(R1);
	mc_auxmcl_spillparams();
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_auxmcl_resetmclentry();
L1856:
	return;
}

static void mc_auxmcl_do_procexit() {
    u64 R1, R2, R3; 
	u64 ax;
	i64 offset;
	i64 r;
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1929;
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1927;
L1929:
	asu64(R1) = mc_auxmcl_mclframesetup;
	mc_auxmcl_setmclentryf(asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L1932;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1932;
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1931;
L1932:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1934;
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_pushstack(asi64(R1));
	goto L1933;
L1934:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L1936;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
L1936:
L1933:
L1931:
	asu64(R1) = mc_auxmcl_resetmclentryf();
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L1939;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1939;
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1938;
L1939:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1941;
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_popstack(asi64(R1));
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1940;
L1941:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L1943;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_popstack(asi64(R1));
L1943:
L1940:
L1938:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L1945;
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 16;
	r = asi64(R1);
L1946:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1950;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	R2 = 8;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1950:
	r += -1; if (r >= 7) goto L1946;
L1945:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L1952;
	R1 = 10;
	r = asi64(R1);
L1953:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1957;
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1957:
	r += -1; if (r >= 4) goto L1953;
L1952:
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1927:
	return;
}

static void mc_auxmcl_spillparams() {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 d;
	u64 ax;
	i64 offset;
	i64 regoffset;
	i64 xregoffset;
	i64 firstoffset;
	i64 i;
	R1 = 16;
	offset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1960;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	firstoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L1963;
L1961:
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asi64(R4) = i;
	R5 = 8;
	asi64(R4) *= asi64(R5);
	asi64(R5) = firstoffset;
	asi64(R4) += asi64(R5);
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = i;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	i += 1; if (i <= 3) goto L1961;
L1963:
L1960:
	goto L1967;
L1964:
	asi64(R1) = regoffset;
	R2 = 3;
	if (asi64(R1) <= asi64(R2)) goto L1969;
	goto L1966;
L1969:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1971;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1973;
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asu64(R4) = d;
	R5 = 76;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1975;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1976;
	goto L1977;
L1975:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1974;
L1976:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 16;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1974;
L1977:
	R1 = 10;
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1974:
	goto L1972;
L1973:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1978;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1980;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L1982;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 8;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1982:
	goto L1979;
L1980:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L1983;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1983:
L1979:
L1978:
L1972:
L1971:
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&regoffset;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1967:
	asu64(R1) = d;
	if (asu64(R1)) goto L1964;
L1966:
	return;
}

static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1986;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1985;
L1986:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1985:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_bitwise(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shift(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 y;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	y = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1990;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1990;
	R1 = 10;
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1989;
L1990:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1992;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1992:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1994;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1994:
L1989:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_setmclentry(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mce_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentry() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mce_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mce_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mce_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L1996;
L1996:
	return asu64(R1);
}

static void mc_auxmcl_setmclentryf(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mcf_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentryf() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mcf_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mcf_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mcf_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L1998;
L1998:
	return asu64(R1);
}

static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr, i64 pstack) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 j;
	i64 k;
	i64 nextireg;
	i64 nextxreg;
	i64 mode;
	i64 imode;
	i64 blockret;
	u64 dblock;
	i64 av_1;
	i64 i;
	asi64(R1) = nargs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2001;
	goto L1999;
L2001:
	asi64(R1) = pstack;
	if (!asi64(R1)) goto L2003;
	R1 = 0;
	blockret = asi64(R1);
	goto L2002;
L2003:
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
L2002:
	R1 = 11;
	nextireg = asi64(R1);
	R1 = 1;
	nextxreg = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = nargs;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) < asi64(R2)) goto L2006;
L2004:
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = k;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2008;
	asi64(R1) = blockret;
	if (!asi64(R1)) goto L2008;
	R1 = (u64)&mc_decls_callblocksize;
	asi64(R2) = mc_decls_ncalldepth;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2007;
L2008:
	asi64(R1) = i;
	asi64(R2) = isptr;
	asi64(R1) -= asi64(R2);
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	j = asi64(R1);
	asi64(R1) = pstack;
	if (!asi64(R1)) goto L2010;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = j;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	goto L2009;
L2010:
	R1 = (u64)&mc_decls_callargmode;
	asi64(R2) = mc_decls_ncalldepth;
	R1 += (i64)R2*32-32;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L2009:
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2012;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2013;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2013;
	goto L2014;
L2012:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = k;
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*128-128;
	asi64(R3) = k;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(tou32(R2));
	asu64(R3) = ax;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
	goto L2011;
L2013:
	asi64(R1) = nextxreg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L2016;
	asi64(R1) = k;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L2016;
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2018;
	R1 = 5;
	goto L2017;
L2018:
	R1 = 6;
L2017:
	imode = asi64(R1);
	asi64(R1) = mode;
	asi64(R2) = nextxreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = imode;
	asi64(R3) = nextireg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2016:
	goto L2011;
L2014:
// mc_auxmcl.do_pushlowargs.doint:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
L2011:
L2007:
	R1 = (u64)&nextireg;
	(*toi64p(R1)) += 1;
	R1 = (u64)&nextxreg;
	(*toi64p(R1)) += 1;
	i += -1; if (i >= av_1) goto L2004;
L2006:
L1999:
	return;
}

static void mc_auxmcl_do_getretvalue(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 xreg;
	i64 i;
	i64 n;
	i64 m;
	struct $B1 modes;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L2022;
	R1 = 0;
	n = asi64(R1);
	goto L2024;
L2023:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&modes;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L2024:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2023;
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2028;
L2026:
	R1 = (u64)&modes;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2030;
	R1 = (u64)&mc_decls_multxregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L2029;
L2030:
	R1 = (u64)&mc_decls_multregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
L2029:
	asi64(R2) = m;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	i += -1; if (i >= 1) goto L2026;
L2028:
	goto L2021;
L2022:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2031;
	R1 = 1;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
L2031:
L2021:
	return;
}

static i64 mc_auxmcl_ismemaddr(i64 n) {
    u64 R1, R2; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2034;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2034;
	R1 = 1;
	goto L2032;
L2034:
	R1 = 0;
	goto L2032;
L2032:
	return asi64(R1);
}

static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 mx;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2037;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2036;
L2037:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2036:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2040;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2039;
L2040:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2039:
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2043;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2042;
L2043:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2042:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 r;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 mx;
	i64 reg;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	r = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2046;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2048;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2047;
L2048:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2047:
	asu64(R1) = mx;
	ax = asu64(R1);
	goto L2045;
L2046:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2050;
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2049;
L2050:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2049:
	asu64(R1) = ax;
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2045:
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2052;
	R1 = 10;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	goto L2051;
L2052:
	R1 = 6;
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	bx = asu64(R1);
L2051:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale) {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2056;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2056;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2056;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2055;
L2056:
	asi64(R1) = scale;
	goto L2053;
L2055:
	asi64(R1) = scale;
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	goto L2053;
L2053:
	return asi64(R1);
}

static void mc_auxmcl_mulimm(u64 ax, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 shifts;
	i64 m;
	u64 bx;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2059;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2060;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L2061;
	goto L2062;
L2059:
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	goto L2057;
	goto L2058;
L2060:
	goto L2057;
	goto L2058;
L2061:
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2057;
	goto L2058;
L2062:
L2058:
	R1 = 0;
	shifts = asi64(R1);
	asi64(R1) = n;
	m = asi64(R1);
	goto L2064;
L2063:
	R1 = 1;
	R2 = (u64)&m;
	*toi64p(R2) >>= asi64(R1);
	R1 = (u64)&shifts;
	(*toi64p(R1)) += 1;
L2064:
	asi64(R1) = m;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2063;
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2067;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2067:
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2069;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2070;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2070;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2070;
	goto L2071;
L2069:
	goto L2057;
	goto L2068;
L2070:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = m;
	R6 = 1;
	asi64(R5) -= asi64(R6);
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2068;
L2071:
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2073;
	R1 = 34;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_mccodex;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2072;
L2073:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2075;
	R1 = 9;
	goto L2074;
L2075:
	R1 = 10;
L2074:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2072:
L2068:
L2057:
	return;
}

static u64 mc_auxmcl_do_addrmode(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 px;
	u64 ax;
	u64 bx;
	i64 scale;
	i64 extra;
	i64 offset;
	i64 reg;
	i64 regix;
	u64 d;
	u64 q;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2078;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
L2078:
	R1 = 0;
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2080;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2082;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2081;
L2082:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2083;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2081;
L2083:
	asi64(R1) = scale;
	R2 = 0;
	R3 = (u64)&mc_decls_pclmode;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2081:
	goto L2079;
L2080:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R1) = mc_auxmcl_ismemaddr(asi64(R1));
	if (!asi64(R1)) goto L2084;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2088;
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2087;
L2088:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2086;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2086;
L2087:
	goto L2089;
L2086:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2091;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2090;
L2091:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2092;
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2090;
L2092:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 10;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2090:
	goto L2079;
L2084:
// mc_auxmcl.do_addrmode.skip:
L2089:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2094;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2093;
L2094:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2095;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2093;
L2095:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2093:
L2079:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = px;
	goto L2076;
L2076:
	return asu64(R1);
}

static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	i64 regix;
	u64 ax;
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2099;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2099;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2099;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2098;
L2099:
	asi64(R1) = reg;
	goto L2096;
L2098:
	asi64(R1) = mc_stackmcl_getworkireg();
	regix = asi64(R1);
	R1 = 10;
	asi64(R2) = regix;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2101;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 1;
	asi64(R6) = reg;
	asi64(R7) = reg;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
	goto L2100;
L2101:
	R1 = 10;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
L2100:
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = regix;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 10;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = regix;
	goto L2096;
L2096:
	return asi64(R1);
}

static void mc_auxmcl_dolea(u64 ax, u64 px) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = px;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2106;
	asu64(R2) = px;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2106;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2106;
	R1 = 1;
	goto L2107;
L2106:
	R1 = 0;
L2107:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2105;
	asu64(R1) = px;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2104;
L2105:
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2104:
	return;
}

static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 rx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2110;
	asi64(R1) = fopc;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2108;
L2110:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2108:
	return;
}

static void mc_auxmcl_do_binto_float(u64 p, i64 opc) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = cx;
	asi64(R3) = opc;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shiftnto(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 cx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2114;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2114;
	R1 = 10;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2113;
L2114:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2116;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2116:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2118;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2118:
L2113:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 q;
	i64 opc;
	i64 n;
	i64 shifts;
	u8 fdivto;
	i64 locyy;
	i64 loczz;
	R1 = 0;
	fdivto = asu8(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	locyy = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	loczz = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L2122;
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L2121;
L2122:
	R1 = (u64)&locyy;
	R2 = (u64)&loczz;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	fdivto = asu8(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2120;
L2121:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
L2120:
	asi64(R1) = loczz;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2124;
	asi64(R1) = isdiv;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2124;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2126;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2127;
	goto L2128;
L2126:
	R1 = tou64("");
	R2 = tou64("Divide by zero");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2125;
L2127:
	mc_stackmcl_poppcl();
	goto L2119;
	goto L2125;
L2128:
	asi64(R1) = n;
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	shifts = asi64(R1);
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2130;
	asu8(R1) = fdivto;
	if (asu8(R1)) goto L2130;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = issigned;
	if (!asi64(R3)) goto L2132;
	R3 = 44;
	goto L2131;
L2132:
	R3 = 45;
L2131:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L2119;
L2130:
L2125:
L2124:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	mc_auxmcl_saverdx();
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_auxmcl_fixdivopnds(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = issigned;
	if (!asi64(R1)) goto L2134;
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2136;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2137;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2138;
	goto L2139;
L2136:
	R1 = 57;
	goto L2135;
L2137:
	R1 = 56;
	goto L2135;
L2138:
	R1 = 55;
	goto L2135;
L2139:
	R1 = tou64("");
	R2 = tou64("div/u8");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
L2135:
	opc = asi64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 36;
	opc = asi64(R1);
	goto L2133;
L2134:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 37;
	opc = asi64(R1);
L2133:
	R1 = 0;
	asu64(R2) = bx;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = isdiv;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2141;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2142;
	goto L2143;
L2141:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2140;
L2142:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	mc_stackmcl_swapopndregs(asi64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2140;
L2143:
L2140:
	mc_auxmcl_restorerdx();
	asu8(R1) = fdivto;
	if (!asu8(R1)) goto L2145;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu64(R2) = bx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = bx;
	asu64(R2) = mc_stackmcl_makeopndind(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
L2145:
	asi64(R1) = isdiv;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2147;
	mc_stackmcl_poppcl();
L2147:
L2119:
	return;
}

static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz) {
    u64 R1, R2, R3; 
	i64 regx;
	i64 regy;
	i64 zop;
	u64 bx;
	u64 ax;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regx = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = loczz;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regy = asi64(R1);
	asi64(R1) = regx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2150;
	goto L2148;
L2150:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = regy;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2152;
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2148;
L2152:
	R1 = (u64)&mc_decls_regset;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2154;
	asu64(R1) = bx;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = regx;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = locyy;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2148;
L2154:
	asi64(R1) = mc_decls_noperands;
	zop = asi64(R1);
	asi64(R1) = zop;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2158;
L2155:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2160;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2160;
	goto L2157;
L2160:
	zop += -1; if (zop >= 1) goto L2155;
L2158:
	goto L2148;
L2157:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = zop;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
L2148:
	return;
}

static void mc_auxmcl_saverdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2163;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2163:
	return;
}

static void mc_auxmcl_restorerdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2166;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2166:
	return;
}

static void mc_auxmcl_clearblock(u64 ax, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 av_1;
	i64 i;
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2169;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L2169;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2172;
L2170:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2170;
L2172:
	goto L2168;
L2169:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2173;
	asi64(R1) = nwords;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2175;
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	goto L2174;
L2175:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	R3 = 4;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
L2176:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= 4) goto L2176;
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2174:
L2173:
L2168:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2180;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2182;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2182:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2184;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2184:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2186;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2186:
L2180:
	return;
}

static void mc_auxmcl_do_blockdata(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 d;
	i64 n;
	i64 nqwords;
	i64 nwords;
	i64 r;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2189;
	goto L2187;
L2189:
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2192;
L2190:
	R1 = 0;
	R2 = 10;
	R3 = (u64)&d;
	asu64(R4) = *tou64p(R3); *(tou64p(R3)) += 8; asu64(R3) = asu64(R4);
	asi64(R3) = *toi64p(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L2190;
L2192:
	asi64(R1) = n;
	asi64(R2) = nwords;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) -= asi64(R2);
	r = asi64(R1);
	asi64(R1) = r;
	if (!asi64(R1)) goto L2194;
	R1 = 66;
	asi64(R2) = r;
	asu64(R3) = d;
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
L2194:
	R1 = tou64("ENDDATA");
	mc_libmcl_mgencomment(asu64(R1));
L2187:
	return;
}

static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 axreg;
	u8 saved;
	i64 av_1;
	R1 = 0;
	saved = asu8(R1);
	asi64(R1) = n;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2197;
	R1 = 2;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2195;
L2197:
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2199;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2199;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 8;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2202;
L2200:
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2200;
L2202:
	goto L2198;
L2199:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2203;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asi64(R1) = savedest;
	if (!asi64(R1)) goto L2205;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	axreg = asi64(R1);
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	saved = asu8(R1);
L2205:
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	bx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2203:
L2198:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2207;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2209;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 4;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2209:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2211;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 2;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2211:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2213;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 1;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2213:
L2207:
	asu8(R1) = saved;
	if (!asu8(R1)) goto L2215;
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2215:
L2195:
	return;
}

static void mc_auxmcl_genstringtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_cstringlist;
	if (asu64(R1)) goto L2218;
	goto L2216;
L2218:
	R1 = tou64("String Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_kk0used;
	if (!asi64(R1)) goto L2220;
	R1 = 0;
	asi64(R2) = mc_decls_kk0used;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2220:
	asu64(R1) = mc_decls_cstringlist;
	p = asu64(R1);
	goto L2224;
L2221:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2224:
	asu64(R1) = p;
	if (asu64(R1)) goto L2221;
L2216:
	return;
}

static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype) {
    u64 R1, R2; 
	i64 i;
	i64 c;
	i64 seqlen;
	u64 seq;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L2227;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2227:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2229;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
	goto L2225;
L2229:
	R1 = 0;
	seqlen = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2232;
L2230:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L2235;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) >= asi64(R2)) goto L2235;
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2236;
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L2234;
L2236:
L2235:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2238;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
	R1 = 0;
	seqlen = asi64(R1);
L2238:
	asi64(R1) = c;
	mc_auxmcl_gendb(asi64(R1));
	goto L2233;
L2234:
	asi64(R1) = seqlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2240;
	R1 = 1;
	seqlen = asi64(R1);
	asu64(R1) = s;
	R2 = 1;
	R1 -= (i64)R2;
	seq = asu64(R1);
	goto L2239;
L2240:
	R1 = (u64)&seqlen;
	(*toi64p(R1)) += 1;
L2239:
L2233:
	if (--asi64(av_1)) goto L2230;
L2232:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2242;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
L2242:
	asi64(R1) = strtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2244;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2244:
L2225:
	return;
}

static void mc_auxmcl_gendb(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendbstring(u64 s, i64 length) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	R3 = 120;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendq(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_genrealtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_creallist;
	if (asu64(R1)) goto L2250;
	asu64(R1) = mc_decls_cr32list;
	if (asu64(R1)) goto L2250;
	goto L2248;
L2250:
	R1 = tou64("Real Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = mc_decls_creallist;
	p = asu64(R1);
	goto L2254;
L2251:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2256;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2255;
L2256:
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2255:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2254:
	asu64(R1) = p;
	if (asu64(R1)) goto L2251;
	R1 = tou64("Real32 Table");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_cr32list;
	p = asu64(R1);
	goto L2260;
L2257:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2262;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
    asr32(R3) = tor32(asr64(R3));
	asi32(R3) = asi32(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2261;
L2262:
	R1 = 0;
	R2 = 1;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2261:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2260:
	asu64(R1) = p;
	if (asu64(R1)) goto L2257;
L2248:
	return;
}

static void mc_auxmcl_genabsneg() {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_lababs32;
	asi64(R2) = mc_decls_lababs64;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg32;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg64;
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L2265;
	R1 = 16;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
L2265:
	asi64(R1) = mc_decls_lababs32;
	if (!asi64(R1)) goto L2267;
	R1 = tou64("lababs32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
L2267:
	asi64(R1) = mc_decls_lababs64;
	if (!asi64(R1)) goto L2269;
	R1 = tou64("lababs64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
L2269:
	asi64(R1) = mc_decls_labneg32;
	if (!asi64(R1)) goto L2271;
	R1 = tou64("labneg32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
L2271:
	asi64(R1) = mc_decls_labneg64;
	if (!asi64(R1)) goto L2273;
	R1 = tou64("labneg64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
L2273:
	asi64(R1) = mc_decls_labzero;
	if (!asi64(R1)) goto L2275;
	R1 = tou64("labzero");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labzero;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendq(asi64(R1));
L2275:
	asi64(R1) = mc_decls_labmask63;
	if (!asi64(R1)) goto L2277;
	R1 = tou64("mask63/offset64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labmask63;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_laboffset64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4890909195324358656;
	mc_auxmcl_gendq(asi64(R1));
L2277:
	return;
}

static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	R2 = 0;
	asu64(R3) = opname;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	asu64(R2) = d;
	R3 = 0;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs) {
    u64 R1, R2, R3, R4; 
	i64 slots;
	i64 av_1;
	asi64(R1) = nargs;
	mc_stackmcl_saveopnds(asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2282;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
	R1 = 1;
	slots = asi64(R1);
L2282:
	R1 = 1;
	R2 = 0;
	R3 = 0;
	asi64(R4) = nargs;
	mc_auxmcl_do_pushlowargs(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L2284;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	goto L2283;
L2284:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L2283:
	asu64(R1) = opname;
	if (!asu64(R1)) goto L2286;
	R1 = 0;
	asu64(R2) = opname;
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2285;
L2286:
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2285:
	asi64(R1) = nargs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2289;
L2287:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L2287;
L2289:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L2291;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L2291:
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
	return;
}

static void mc_auxmcl_do_max_int(i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = cond;
	R4 = 15;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_max_float(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asi64(R1) = mode;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asi64(R4) = mode;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_negreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2298;
	asi64(R1) = mc_decls_labneg64;
	if (asi64(R1)) goto L2300;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg64 = asi64(R1);
L2300:
	asi64(R1) = mc_decls_labneg64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 77;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2297;
L2298:
	asi64(R1) = mc_decls_labneg32;
	if (asi64(R1)) goto L2302;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg32 = asi64(R1);
L2302:
	asi64(R1) = mc_decls_labneg32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 76;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2297:
	return;
}

static void mc_auxmcl_do_absreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2305;
	asi64(R1) = mc_decls_lababs64;
	if (asi64(R1)) goto L2307;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs64 = asi64(R1);
L2307:
	asi64(R1) = mc_decls_lababs64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 79;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2304;
L2305:
	asi64(R1) = mc_decls_lababs32;
	if (asi64(R1)) goto L2309;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs32 = asi64(R1);
L2309:
	asi64(R1) = mc_decls_lababs32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 78;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2304:
	return;
}

static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 mx;
	u64 mask;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2312;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 44;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2311;
L2312:
	asi64(R1) = i;
	if (!asi64(R1)) goto L2314;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2314:
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	asu64(R1) = mask;
	R2 = 2147483647;
	if (asu64(R1) > asu64(R2)) goto L2316;
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2315;
L2316:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2315:
L2311:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_loadbf_var(u64 p) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = tou64("LOADBF_VAR");
	pc_api_merror(asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_do_storebit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 cx;
	u64 ix;
	u64 q;
	u64 r;
	i64 i;
	i64 offset;
	u8 mask1s;
	u8 mask0s;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2320;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	offset = asi64(R1);
	R1 = 7;
	R2 = (u64)&i;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = px;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	mask0s = asu8(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	mask1s = asu8(R1);
	asu64(R1) = r;
	if (!asu64(R1)) goto L2322;
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2324;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2323;
L2324:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask0s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2323:
	goto L2321;
L2322:
	R1 = 0;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2326;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2326:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2321:
	goto L2319;
L2320:
	asu64(R1) = r;
	if (!asu64(R1)) goto L2327;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2329;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2331;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2331:
	R1 = 11;
	R2 = 10;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ix = asu64(R1);
	R1 = 1;
	asu64(R2) = cx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2333;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2333:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2335;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2334;
L2335:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2334:
	goto L2328;
L2329:
	R1 = tou64("");
	R2 = tou64("STOREBIT/VAR");
	pc_api_merror(asu64(R2), asu64(R1));
L2328:
	goto L2319;
L2327:
	R1 = tou64("");
	R2 = tou64("Storebit: both vars");
	pc_api_merror(asu64(R2), asu64(R1));
L2319:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_storebf(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 rx;
	u64 mx;
	u64 mx4;
	u64 dx;
	i64 i;
	i64 j;
	u64 q;
	u64 r;
	u64 mask;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = r;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2338;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2338;
	R1 = tou64("");
	R2 = tou64("storebf not imm");
	pc_api_merror(asu64(R2), asu64(R1));
L2338:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 3;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	dx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	j = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	asi64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2340;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = dx;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2340:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = mx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dx;
	asu64(R2) = rx;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static u64 mc_auxmcl_gethostfn(i64 opc) {
    u64 R1, R2; 
	u64 d;
	u64 name;
	u64 namec;
	u64 ps;
	asu64(R1) = pc_api_igethostfn;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2343;
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2345;
	goto L2346;
L2345:
	R1 = tou64("msys.m$power_i64");
	name = asu64(R1);
	R1 = tou64("msysc.m$power_i64");
	namec = asu64(R1);
	goto L2344;
L2346:
	R1 = 0;
	name = asu64(R1);
L2344:
	asu64(R1) = name;
	if (!asu64(R1)) goto L2348;
	asu64(R1) = pc_decls_psymboltable;
	ps = asu64(R1);
	goto L2352;
L2349:
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L2355;
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = namec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2354;
L2355:
	asu64(R1) = ps;
	goto L2341;
L2354:
	asu64(R1) = ps;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ps = asu64(R1);
L2352:
	asu64(R1) = ps;
	if (asu64(R1)) goto L2349;
L2348:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("gethostfn?");
	pc_api_merror(asu64(R2), asu64(R1));
L2343:
	asi64(R1) = opc;
	asu64(R2) = pc_api_igethostfn;
	asu64(R1) = ((F19)R2)(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2357;
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("No host fn:");
	pc_api_merror(asu64(R2), asu64(R1));
L2357:
	asu64(R1) = d;
	goto L2341;
L2341:
	return asu64(R1);
}

static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 dblock;
	u64 ax;
	u64 bx;
	u64 axi;
	u64 bxi;
	asu64(R1) = px;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2360;
	msysc_m$print_startcon();
	R1 = tou64("High block arg not copied in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("()");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L2358;
L2360:
	asi64(R1) = size;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = px;
	if (!asu64(R1)) goto L2362;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2361;
L2362:
	R1 = 0;
	R2 = 11;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
L2361:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = size;
	R3 = 0;
	R4 = 10;
	asu64(R5) = bx;
	R6 = 10;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asu64(R3) = mc_libmcl_mgenireg(asi64(R5), asi64(R4), asi64(R3));
	R4 = 0;
	R5 = 10;
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R4) = mc_libmcl_mgenireg(asi64(R6), asi64(R5), asi64(R4));
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = px;
	if (!asu64(R1)) goto L2364;
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2364:
	R1 = 0;
	mc_stackmcl_freeworkregs(asu64(R1));
L2358:
	return;
}

static void mc_auxmcl_fixmain() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 dn;
	u64 dargs;
	u64 denv;
	u64 dinfo;
	u64 ax;
	asu64(R1) = pc_decls_currfunc;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dn = asu64(R1);
	asu64(R1) = dn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dargs = asu64(R1);
	R1 = 3;
	R2 = tou64("$env");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	denv = asu64(R1);
	R1 = 6;
	asu64(R2) = denv;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = denv;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = tou64("$info");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	dinfo = asu64(R1);
	R1 = 11;
	asu64(R2) = dinfo;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 128;
	asu64(R2) = dinfo;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 8;
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = dinfo;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 128;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = denv;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 8;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 125;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = denv;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dinfo;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = R1;
	asu64(R3) = d;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = dargs;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = dn;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dn;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = dn;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = dargs;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dn;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = R2;
	ax = asu64(R3);
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dinfo;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dinfo;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dn;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dn;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dargs;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dargs;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = denv;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 13;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = denv;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	R2 = 14;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	R2 = tou64("__getmainargs*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 48;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	if (!asi64(R1)) goto L2367;
	R1 = 9;
	asi64(R2) = pc_decls_pcmdskip;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dn;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dargs;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2367:
	return;
}

static void mc_libmcl_mclinit(i64 bypass) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 r;
	i64 s;
	i64 av_1;
	i64 av_2;
	i64 i;
	R1 = 64;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2370;
	R1 = tou64("MCLREC>64B");
	mlib_abortprogram(asu64(R1));
L2370:
	R1 = 1;
	r = asi64(R1);
L2371:
	R1 = 1;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 2;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 4;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 4;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	r += 1; if (r <= 16) goto L2371;
	R1 = -128;
	i = asi64(R1);
	R1 = 64;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L2376;
L2374:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = i;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_frameregtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+1024)) = asu64(R1);
	i += 1; if (i <= av_1) goto L2374;
L2376:
	R1 = 6;
	R2 = 15;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dframeopnd = asu64(R1);
	R1 = 6;
	R2 = 16;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dstackopnd = asu64(R1);
	mc_libmcl_initmcdest();
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	mc_decls_lab_funcnametable = asi64(R1);
	R1 = 0;
	mc_decls_lab_funcaddrtable = asi64(R1);
	R1 = -1;
	i = asi64(R1);
	R1 = 10;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2379;
L2377:
	R1 = 8;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_libmcl_smallinttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L2377;
L2379:
	asi64(R1) = bypass;
	if (!asi64(R1)) goto L2381;
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
L2381:
	return;
}

static void mc_libmcl_initmcdest() {
    u64 R1, R2; 
	R1 = 0;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
	return;
}

static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 m;
	u64 oldm;
	i64 labno;
	R1 = 64;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	m = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_libmcl_mclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = m;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opcode;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2385;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2386;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2387;
	goto L2388;
L2385:
	asu64(R1) = b;
	if (!asu64(R1)) goto L2390;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2390;
	R1 = 1;
	asu64(R2) = b;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2390:
	goto L2384;
L2386:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	goto L2384;
L2387:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2393;
	asu64(R1) = b;
	if (!asu64(R1)) goto L2392;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2392;
L2393:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2395;
	R1 = 17;
	goto L2394;
L2395:
	R1 = 16;
L2394:
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2392:
	goto L2384;
L2388:
L2384:
	asu64(R1) = mc_decls_mccode;
	if (!asu64(R1)) goto L2397;
	asu64(R1) = mc_decls_mccodex;
	asu64(R2) = m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	mc_decls_mccodex = asu64(R1);
	goto L2396;
L2397:
	asu64(R1) = m;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
L2396:
	return;
}

static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = mc_decls_mccodex;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mc_libmcl_genmc_str(i64 opcode, u64 s) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = -1;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_newmclopnd() {
    u64 R1; 
	u64 a;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	a = asu64(R1);
	R1 = (u64)&mc_libmcl_nmclopnd;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	goto L2400;
L2400:
	return asu64(R1);
}

static u64 mc_libmcl_duplopnd(u64 a) {
    u64 R1, R2; struct $B3 R1_B3; 
	u64 b;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	b = asu64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = b;
	goto L2401;
L2401:
	return asu64(R1);
}

static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = areg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = areg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2405;
	asi64(R1) = ireg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2404;
L2405:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2404:
	asi64(R1) = ireg;
	asu64(R2) = a;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 5;
	R4 = 8;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = labno;
	if (!asi64(R1)) goto L2407;
	asi64(R1) = labno;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2406;
L2407:
	asu64(R1) = def;
	if (!asu64(R1)) goto L2408;
	asu64(R1) = def;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = def;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = def;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2411;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2410;
L2411:
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2410:
L2408:
L2406:
	asu64(R1) = a;
	goto L2402;
L2402:
	return asu64(R1);
}

static void mc_libmcl_mgencomment(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = 3;
	mc_libmcl_genmc_str(asi64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenstring(u64 s, i64 length) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2415;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2415:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = a;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2413;
L2413:
	return asu64(R1);
}

static u64 mc_libmcl_mgenname(u64 s) {
    u64 R1, R2, R3, R4; 
	struct $B37 str;
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2416;
L2416:
	return asu64(R1);
}

static void mc_libmcl_setsegment(i64 seg, i64 align) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 oldalign;
	asi64(R1) = seg;
	asi64(R2) = mc_decls_currsegment;
	if (asi64(R1) == asi64(R2)) goto L2419;
	asi64(R1) = seg;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L2421;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L2422;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L2423;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2424;
	goto L2425;
L2421:
	R1 = 121;
	opc = asi64(R1);
	goto L2420;
L2422:
	R1 = 122;
	opc = asi64(R1);
	goto L2420;
L2423:
	R1 = 123;
	opc = asi64(R1);
	goto L2420;
L2424:
	R1 = tou64("");
	R2 = tou64("CAN'T DO RODATA SEG");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2420;
L2425:
	R1 = tou64("");
	R2 = tou64("BAD SEG CODE");
	pc_api_merror(asu64(R2), asu64(R1));
L2420:
	asu64(R1) = mc_decls_mccodex;
	if (!asu64(R1)) goto L2427;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2428;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L2428;
	R2 = 123;
	if (asi64(R1) != asi64(R2)) goto L2427;
L2428:
	asi64(R1) = opc;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2426;
L2427:
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2426:
	asi64(R1) = seg;
	mc_decls_currsegment = asi64(R1);
L2419:
	asi64(R1) = align;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2430;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L2432;
	asu64(R1) = mc_decls_mccodex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldalign = asi64(R1);
	asi64(R1) = oldalign;
	asi64(R2) = align;
	if (asi64(R1) < asi64(R2)) goto L2434;
	goto L2417;
L2434:
L2432:
	R1 = 0;
	R2 = 10;
	asi64(R3) = align;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2430:
L2417:
	return;
}

static u64 mc_libmcl_changeopndsize(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L2437;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2439;
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	b = asu64(R1);
	goto L2438;
L2439:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2438:
	asu64(R1) = b;
	goto L2435;
L2437:
	asu64(R1) = a;
	goto L2435;
L2435:
	return asu64(R1);
}

static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2442;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2442;
	asu64(R1) = a;
	goto L2440;
L2442:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = b;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L2444;
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2444:
	asu64(R1) = b;
	goto L2440;
L2440:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint(i64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = x;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2447;
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2447;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2447;
	R1 = (u64)&mc_libmcl_smallinttable;
	asi64(R2) = x;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8+8));
	goto L2445;
L2447:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2445;
L2445:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint0(i64 x, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2448;
L2448:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2451;
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getrealindex(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2450;
L2451:
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getr32index(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2450:
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2449;
L2449:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asr64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2452;
L2452:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabel(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2455;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	x = asi64(R1);
L2455:
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2453;
L2453:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabelmem(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asi64(R1) = x;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2456;
L2456:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmem(u64 d, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2459;
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2461;
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenxregvar(asu64(R1));
	goto L2457;
	goto L2460;
L2461:
	asi64(R1) = mode;
	asu64(R2) = d;
	asu64(R1) = mc_libmcl_mgenregvar(asu64(R2), asi64(R1));
	goto L2457;
L2460:
L2459:
	R1 = 0;
	reg = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2464;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2463;
L2464:
	R1 = 15;
	reg = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2463:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	if (!asi64(R1)) goto L2466;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2465;
L2466:
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asu64(R1) = Min(asu64(R1), asu64(R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2465:
	asu64(R1) = a;
	goto L2457;
L2457:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmemaddr(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2467;
L2467:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg0(i64 reg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2470;
	R1 = tou64("");
	R2 = tou64("1:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2470:
	asu64(R1) = a;
	goto L2468;
L2468:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = xreg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2473;
	R1 = tou64("");
	R2 = tou64("2:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2473:
	asu64(R1) = a;
	goto L2471;
L2471:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg(i64 reg, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2476;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedxregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2475;
L2476:
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2478;
	R1 = 8;
	size = asi64(R1);
L2478:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2480;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2480;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2480:
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2474;
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
L2475:
	goto L2474;
L2474:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregi(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	R2 = (u64)&pc_tables_psize;
	asi64(R3) = mode;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2481;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	goto L2481;
L2481:
	return asu64(R1);
}

static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	goto L2482;
L2482:
	return asu64(R1);
}

static u64 mc_libmcl_mgentemp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	i64 size;
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2485;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	goto L2483;
L2485:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pcltempflags;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2483;
L2483:
	return asu64(R1);
}

static i64 mc_libmcl_roundsizetg(i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2488;
	asi64(R1) = size;
	goto L2486;
L2488:
	asi64(R1) = size;
	R2 = 8;
	asi64(R3) = size;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L2486;
L2486:
	return asi64(R1);
}

static void mc_libmcl_merroropnd(u64 mess, i64 opndtype) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MCL Opnd not supported: # (#) [#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asi64(R2) = opndtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 mc_libmcl_mcreatefwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L2490;
L2490:
	return asi64(R1);
}

static void mc_libmcl_mdefinefwdlabel(i64 lab) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenextname(u64 s) {
    u64 R1, R2, R3; 
	struct $B37 str;
	u64 d;
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mc_libmcl_findnamesym(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L2494;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	mc_libmcl_addnamesym(asu64(R1));
L2494:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	goto L2492;
L2492:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregvar(u64 d, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	goto L2495;
L2495:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxregvar(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 8;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2496;
L2496:
	return asu64(R1);
}

static i64 mc_libmcl_getprimreg(u64 ax) {
    u64 R1, R2; 
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2499;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L2498;
L2499:
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
L2498:
	goto L2497;
L2497:
	return asi64(R1);
}

static void mc_libmcl_pushslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) += asi64(R1);
	return;
}

static void mc_libmcl_popslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_popstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) -= asi64(R1);
	return;
}

static void mc_libmcl_pushstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2504;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2504:
	return;
}

static void mc_libmcl_popstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2507;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2507:
	return;
}

static i64 mc_libmcl_getstringindex(u64 s, i64 length) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2510;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_kk0used = asi64(R1);
	asi64(R1) = mc_decls_kk0used;
	goto L2508;
L2510:
	asu64(R1) = mc_decls_cstringlist;
	if (!asu64(R1)) goto L2512;
	asi64(R1) = length;
	asu64(R2) = mc_decls_cstringlist;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L2512;
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = mc_decls_cstringlist;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L2512;
	asu64(R1) = mc_decls_cstringlist;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2508;
L2512:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&mc_decls_cstringlist;
	asi64(R1) = mc_libmcl_addconst(asu64(R3), asi64(R2), asi64(R1));
	goto L2508;
L2508:
	return asi64(R1);
}

static i64 mc_libmcl_addconst(u64 clist, i64 value, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = clist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = clist;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	goto L2513;
L2513:
	return asi64(R1);
}

static i64 mc_libmcl_getrealindex(r64 x) {
    u64 R1, R2, R3; 
	R1 = 0;
	asr64(R2) = x;
	asi64(R2) = asi64(R2);
	R3 = (u64)&mc_decls_creallist;
	asi64(R1) = mc_libmcl_addconst(asu64(R3), asi64(R2), asi64(R1));
	goto L2514;
L2514:
	return asi64(R1);
}

static i64 mc_libmcl_getr32index(r64 x) {
    u64 R1, R2, R3; 
	R1 = 0;
	asr64(R2) = x;
	asi64(R2) = asi64(R2);
	R3 = (u64)&mc_decls_cr32list;
	asi64(R1) = mc_libmcl_addconst(asu64(R3), asi64(R2), asi64(R1));
	goto L2515;
L2515:
	return asi64(R1);
}

static i64 mc_libmcl_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L2517:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L2521;
	asi64(R1) = n;
	goto L2516;
L2521:
	if (--asi64(av_1)) goto L2517;
	R1 = 0;
	goto L2516;
L2516:
	return asi64(R1);
}

static void mc_libmcl_axerror(u64 mess) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	msysc_m$print_startcon();
	R1 = tou64("AX ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("AASEQ:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("AAPOS=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aapos;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L2524;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F16)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L2524:
	R1 = 1;
	exit(R1);
	return;
}

static u64 mc_libmcl_newblocktemp(i64 size) {
    u64 R1, R2, R3; 
	struct $B3 str;
	u64 d;
	asi64(R1) = mc_decls_nblocktemps;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L2527;
	R1 = tou64("");
	R2 = tou64("Too many block temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2527:
	R1 = (u64)&mc_decls_nblocktemps;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$B#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_nblocktemps;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 8;
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 11;
	asu64(R2) = d;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = d;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pc_decls_currfunc;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_decls_blockdefs;
	asi64(R3) = mc_decls_nblocktemps;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	goto L2525;
L2525:
	return asu64(R1);
}

static u64 mc_libmcl_findnamesym(u64 s) {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2531;
L2529:
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2533;
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2528;
L2533:
	i += 1; if (i <= mc_libmcl_nnametable) goto L2529;
L2531:
	R1 = 0;
	goto L2528;
L2528:
	return asu64(R1);
}

static void mc_libmcl_addnamesym(u64 d) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 20;
	if (asi64(R1) >= asi64(R2)) goto L2536;
	asu64(R1) = d;
	R2 = (u64)&mc_libmcl_nametable;
	R3 = (u64)&mc_libmcl_nnametable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L2535;
L2536:
	R1 = tou64("");
	R2 = tou64("Ext nametab overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2535:
	return;
}

static void mc_libmcl_clearreg(u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2539;
	R1 = 4;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2539:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2542;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2542;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2543;
	goto L2544;
L2542:
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2540;
	goto L2541;
L2543:
	asi64(R1) = mode;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgentemp(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	goto L2540;
	goto L2541;
L2544:
L2541:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2546;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2547;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2548;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2549;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2549;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2550;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2551;
	goto L2552;
L2546:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2554;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2554;
	R1 = 6;
	mode = asi64(R1);
	goto L2547;
	goto L2553;
L2554:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2553:
	goto L2545;
L2547:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2556;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2556;
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2555;
L2556:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2555:
	goto L2545;
L2548:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2558;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2559;
	goto L2560;
L2558:
	R1 = 65535;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L2557;
L2559:
	R1 = 4294967295;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L2557;
L2560:
L2557:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2562;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L2562;
	asu64(R1) = bx;
	ax = asu64(R1);
	goto L2561;
L2562:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2561:
	goto L2545;
L2549:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2545;
L2550:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R2), asi64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2545;
L2551:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2545;
L2552:
// mc_stackmcl.getopnd.error:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = a;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("getopnd");
	pc_api_merror(asu64(R2), asu64(R1));
L2545:
	asu64(R1) = ax;
	goto L2540;
L2540:
	return asu64(R1);
}

static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2566;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2568;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L2568:
L2566:
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	goto L2564;
L2564:
	return asu64(R1);
}

static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg_m(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	goto L2569;
L2569:
	return asu64(R1);
}

static void mc_stackmcl_pushopnd(i64 n, i64 mode, i64 size) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2572;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2574;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2575;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2576;
	goto L2577;
L2574:
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2579;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2580;
L2579:
	goto L2573;
L2575:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2582;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L2582;
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2580;
L2582:
	goto L2573;
L2576:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2580;
	goto L2573;
L2577:
L2573:
L2572:
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2584;
	asi64(R1) = n;
	asi64(R2) = size;
	asu64(R3) = ax;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	mode = asi64(R1);
L2584:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2586;
	asu64(R1) = ax;
	bx = asu64(R1);
	asi64(R1) = mode;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2588;
	R1 = 5;
	goto L2587;
L2588:
	R1 = 6;
L2587:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2586:
// mc_stackmcl.pushopnd.pushit:
L2580:
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&mc_decls_mstackdepth;
	(*toi64p(R1)) += 1;
	return;
}

static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2592;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2591;
L2592:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L2595;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L2594;
L2595:
	asu64(R1) = ax;
	goto L2589;
L2594:
L2591:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L2589;
L2589:
	return asu64(R1);
}

static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2599;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2598;
L2599:
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L2601;
	asu64(R1) = ax;
	goto L2596;
L2601:
L2598:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L2596;
L2596:
	return asu64(R1);
}

static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2604;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2604;
	asu64(R1) = ax;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2604;
	R1 = 4;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	goto L2603;
L2604:
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2603:
	return;
}

static void mc_stackmcl_pushpcl(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L2607;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2607:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2609;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2609;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2609:
	return;
}

static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L2612;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2612:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2614;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L2614:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2616;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2615;
L2616:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2615:
	return;
}

static void mc_stackmcl_poppcl() {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L2619;
	R1 = tou64("");
	R2 = tou64("poppcl/underflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2619:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2621;
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	R1 += (i64)R2-1;
	(*tou8p(R1)) -=1;
	goto L2617;
L2621:
	R1 = (u64)&mc_decls_noperands;
	(*toi64p(R1)) -=1;
L2617:
	return;
}

static void mc_stackmcl_duplpcl() {
    u64 R1, R2, R3, R4; 
	i64 mode;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 0;
	asi64(R3) = mode;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_stackmcl_getworkireg() {
    u64 R1, R2, R3; 
	i64 r;
	i64 av_1;
	R1 = 10;
	av_1 = asi64(R1);
L2624:
	R1 = 1;
	r = asi64(R1);
L2627:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2631;
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2631;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L2623;
L2631:
	r += 1; if (r <= 14) goto L2627;
	mc_stackmcl_savenextopnd();
	if (--asi64(av_1)) goto L2624;
	R1 = tou64("");
	R2 = tou64("No more work regs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L2623;
L2623:
	return asi64(R1);
}

static i64 mc_stackmcl_getworkxreg() {
    u64 R1, R2, R3; 
	i64 r;
	R1 = 5;
	r = asi64(R1);
L2633:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2637;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2637;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L2632;
L2637:
	r += 1; if (r <= 16) goto L2633;
	R1 = tou64("");
	R2 = tou64("No more work xregs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L2632;
L2632:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkregm(i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R2) = mode;
	asi64(R2) = mc_stackmcl_getworkreg(asi64(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2638;
L2638:
	return asu64(R1);
}

static i64 mc_stackmcl_getworkreg(i64 mode) {
    u64 R1, R2; 
	i64 reg;
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2641;
	asi64(R1) = mc_stackmcl_getworkxreg();
	goto L2640;
L2641:
	asi64(R1) = mc_stackmcl_getworkireg();
L2640:
	goto L2639;
L2639:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2645;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2644;
L2645:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L2642;
L2644:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2649;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2648;
L2649:
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2647;
L2648:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L2642;
L2647:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2642;
L2642:
	return asu64(R1);
}

static void mc_stackmcl_saveopnd(i64 n, i64 allregs) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 mode;
	u64 tx;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2652;
	goto L2650;
L2652:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2654;
	asi64(R1) = allregs;
	if (asi64(R1)) goto L2657;
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2658;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L2656;
L2658:
L2657:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2656:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2653;
L2654:
	asi64(R1) = allregs;
	if (asi64(R1)) goto L2661;
	asi64(R1) = reg;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2660;
	R2 = 6;
	if (asi64(R1) > asi64(R2)) goto L2660;
L2661:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2660:
	R1 = 0;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2653:
	R1 = 3;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2650:
	return;
}

static void mc_stackmcl_saveopnds(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2665;
L2663:
	R1 = 0;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L2663;
L2665:
	return;
}

static void mc_stackmcl_savenextopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2669;
L2667:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2671;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2671;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L2666;
L2671:
	i += 1; if (i <= mc_decls_noperands) goto L2667;
L2669:
L2666:
	return;
}

static void mc_stackmcl_savenextxopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2675;
L2673:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2677;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2677;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L2672;
L2677:
	i += 1; if (i <= mc_decls_noperands) goto L2673;
L2675:
L2672:
	return;
}

static void mc_stackmcl_movetoreg(i64 newreg) {
    u64 R1, R2, R3; 
	i64 oldreg;
	i64 mode;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
// mc_stackmcl.movetoreg.retry:
L2679:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	oldreg = asi64(R1);
	asi64(R1) = oldreg;
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L2681;
	goto L2678;
L2681:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2683;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2685;
	R1 = tou64("");
	R2 = tou64("MOVE TO REG: XREG IN USE");
	pc_api_merror(asu64(R2), asu64(R1));
L2685:
	goto L2682;
L2683:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2687;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2690;
L2688:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2692;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L2692;
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 6;
	asi64(R2) = newreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asi64(R3) = oldreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2679;
L2692:
	i += 1; if (i <= mc_decls_noperands) goto L2688;
L2690:
L2687:
L2682:
	asi64(R1) = mode;
	asi64(R2) = oldreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newreg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2694;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2693;
L2694:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2693:
L2678:
	return;
}

static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2697;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2699;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2702;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2701;
L2702:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	goto L2695;
L2701:
L2699:
L2697:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2704;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L2704:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L2695;
L2695:
	return asu64(R1);
}

static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2707;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L2707:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L2705;
L2705:
	return asu64(R1);
}

static void mc_stackmcl_swapopnds(i64 m, i64 n) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = m;
	R1 += (i64)R2*8-8;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	R2 += (i64)R3*8-8;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	return;
}

static u64 mc_stackmcl_isimmload(i64 n) {
    u64 R1, R2; 
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2711;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2711;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2711;
	asu64(R1) = p;
	goto L2710;
L2711:
	R1 = 0;
L2710:
	goto L2709;
L2709:
	return asu64(R1);
}

static void mc_stackmcl_setnewzz(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_stackmcl_freeworkregs(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 i;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2716;
L2714:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2718;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2720;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2719;
L2720:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2719:
L2718:
	i += 1; if (i <= mc_decls_noperands) goto L2714;
L2716:
	return;
}

static void mc_stackmcl_swapopndregs(i64 reg2) {
    u64 R1, R2, R3; 
	i64 reg1;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2723;
	R1 = tou64("");
	R2 = tou64("SOR1");
	pc_api_merror(asu64(R2), asu64(R1));
L2723:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg1 = asi64(R1);
	asi64(R1) = reg1;
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L2725;
	goto L2721;
L2725:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2729;
L2726:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2731;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L2731;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	goto L2721;
L2731:
	i += -1; if (i >= 1) goto L2726;
L2729:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg2;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2721:
	return;
}

static u64 mc_stackmcl_makeopndind(u64 a, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2734;
	R1 = tou64("");
	R2 = tou64("makeopndind");
	pc_api_merror(asu64(R2), asu64(R1));
L2734:
	R1 = 0;
	asi64(R2) = mode;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L2732;
L2732:
	return asu64(R1);
}

static u64 mc_stackmcl_makesimpleaddr(u64 ax) {
    u64 R1, R2, R3; 
	u64 bx;
	i64 newreg;
	i64 reg;
	i64 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2737;
	R1 = 0;
	reg = asi64(R1);
L2737:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2739;
	R1 = tou64("");
	R2 = tou64("MSA");
	pc_api_merror(asu64(R2), asu64(R1));
L2739:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2741;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2741;
	asi64(R1) = mc_stackmcl_getworkireg();
	newreg = asi64(R1);
	goto L2740;
L2741:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L2742;
	asu64(R1) = ax;
	goto L2735;
	goto L2740;
L2742:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L2743;
	asi64(R1) = regix;
	newreg = asi64(R1);
	goto L2740;
L2743:
	asi64(R1) = regix;
	newreg = asi64(R1);
L2740:
	R1 = 0;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L2735;
L2735:
	return asu64(R1);
}

static void mc_stackmcl_checkallloaded() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2747;
L2745:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2749;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2749;
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = i;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L2749:
	i += 1; if (i <= mc_decls_noperands) goto L2745;
L2747:
	return;
}

static u64 mc_stackmcl_stropndstack(i64 indent) {
    u64 R1, R2, R3; 
	struct $B20 str2;
	u64 s;
	u64 t;
	i64 i;
	i64 r;
	R1 = (u64)&mc_stackmcl_stropndstack_str;
	s = asu64(R1);
	asi64(R1) = indent;
	if (!asi64(R1)) goto L2752;
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("========================================#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L2751;
L2752:
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L2751:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2755;
L2753:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L2759;
	case 2: goto L2760;
	case 3: goto L2761;
	case 4: goto L2762;
	default: goto L2758;
    };
// SWITCH
L2759:
	R1 = tou64("Z:");
	goto L2756;
L2760:
	R1 = tou64("Y:");
	goto L2756;
L2761:
	R1 = tou64("X:");
	goto L2756;
L2762:
	R1 = tou64("W:");
	goto L2756;
L2758:
	R1 = tou64("");
L2756:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2764;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2764;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2765;
	goto L2766;
L2764:
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2768;
	R1 = (u64)&mc_decls_xregnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2767;
L2768:
	R1 = (u64)&mc_decls_regnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2767:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2770;
	R1 = tou64("*");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2770:
	goto L2763;
L2765:
	R1 = tou64("T");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = i;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2763;
L2766:
	R1 = tou64("(==");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2763:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2772;
	R1 = tou64("@");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2772:
	R1 = tou64("<");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pstdnames;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(">");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = mc_decls_noperands;
	if (asi64(R1) >= asi64(R2)) goto L2774;
	R1 = tou64(", ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2774:
	i += 1; if (i <= mc_decls_noperands) goto L2753;
L2755:
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 50;
	R3 = (u64)&mc_stackmcl_stropndstack_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("WR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
L2775:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2779;
	R1 = tou64("1 ");
	goto L2778;
L2779:
	R1 = tou64("0 ");
L2778:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= 10) goto L2775;
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("XWR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
	asi64(R1) = mc_decls_xregmax;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2782;
L2780:
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2784;
	R1 = tou64("1 ");
	goto L2783;
L2784:
	R1 = tou64("0 ");
L2783:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= mc_decls_xregmax) goto L2780;
L2782:
	R1 = tou64(") hwstack:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_mstackdepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" noperands:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ncalldepth:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_ncalldepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = s;
	goto L2750;
L2750:
	return asu64(R1);
}

static void mc_stackmcl_showopndstack() {
    u64 R1; 
	R1 = 1;
	asu64(R1) = mc_stackmcl_stropndstack(asi64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_optim_peephole() {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 m;
	u64 m2;
	u64 m3;
	i64 lab1;
	i64 lab2;
	asu8(R1) = pc_decls_fpeephole;
	if (asu8(R1)) goto L2788;
	goto L2786;
L2788:
	asu64(R1) = mc_decls_mccode;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L2792;
L2789:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m2 = asu64(R1);
	asu64(R1) = m2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m3 = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2794;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2795;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L2796;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L2797;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L2798;
	goto L2799;
L2794:
	goto L2791;
	goto L2793;
L2795:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2801;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L2802;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L2803;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L2804;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L2804;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L2805;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L2805;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L2806;
	goto L2807;
L2801:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2809;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2809;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2809;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L2811;
	goto L2810;
L2811:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (asi64(R1)) goto L2813;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2812;
L2813:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2812:
L2810:
	goto L2808;
L2809:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2814;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2814;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L2814;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L2814;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2814;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2814:
L2808:
	goto L2800;
L2802:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2816;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2817;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2817;
	R1 = 1;
	goto L2818;
L2817:
	R1 = 0;
L2818:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2816;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2816;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2816;
	R1 = 41;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L2816:
	goto L2800;
L2803:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2820;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2820;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2820;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2820;
	R1 = 42;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2820:
	goto L2800;
L2804:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2822;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2822;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2822;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isconst(asu64(R1));
	if (!asi64(R1)) goto L2822;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 28;
	if (asi64(R4) != asi64(R5)) goto L2824;
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	goto L2823;
L2824:
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	asi64(R4) = -asi64(R4);
L2823:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2822:
	goto L2800;
L2805:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2826;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2826;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2826;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 52;
	if (asi64(R4) != asi64(R5)) goto L2828;
	R4 = 1;
	goto L2827;
L2828:
	R4 = -1;
L2827:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2826:
	goto L2800;
L2806:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2830;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2830;
	R1 = 25;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L2830:
	goto L2800;
L2807:
L2800:
	goto L2793;
L2796:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L2832;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2834;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2835;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2835;
	R1 = 1;
	goto L2836;
L2835:
	R1 = 0;
L2836:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2834;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2834;
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L2834:
L2832:
	goto L2793;
L2797:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2838;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2840;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2840;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2840;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L2840;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2840;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = m;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L2840:
L2838:
	goto L2793;
L2798:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L2842;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L2842;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = m3;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L2842;
	asu64(R1) = m;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L2842;
	R1 = (u64)&mc_decls_asmrevcond;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = m;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L2842:
	goto L2793;
L2799:
L2793:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L2792:
	asu64(R1) = m;
	if (asu64(R1)) goto L2789;
L2791:
L2786:
	return;
}

static i64 mc_optim_isreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L2843;
L2843:
	return asi64(R1);
}

static i64 mc_optim_isreg0(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L2846;
	R1 = 0;
	goto L2844;
L2846:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2848;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2848;
	R1 = 1;
	goto L2844;
L2848:
	R1 = 0;
	goto L2844;
L2844:
	return asi64(R1);
}

static i64 mc_optim_isreg10(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L2851;
	R1 = 0;
	goto L2849;
L2851:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2853;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2853;
	R1 = 1;
	goto L2849;
L2853:
	R1 = 0;
	goto L2849;
L2849:
	return asi64(R1);
}

static i64 mc_optim_isreg00(u64 m) {
    u64 R1, R2, R3; 
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L2856;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2856;
	R1 = 1;
	goto L2854;
L2856:
	R1 = 0;
	goto L2854;
L2854:
	return asi64(R1);
}

static i64 mc_optim_isconst(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L2859;
	R1 = 0;
	goto L2857;
L2859:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2861;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2861;
	R1 = 1;
	goto L2857;
L2861:
	R1 = 0;
	goto L2857;
L2857:
	return asi64(R1);
}

static i64 mc_optim_sameoperand(u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 16;
	asu64(R2) = b;
	asu64(R3) = a;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L2862;
L2862:
	return asi64(R1);
}

static i64 mc_optim_sameregopnd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2866;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2865;
L2866:
	R1 = 0;
	goto L2863;
L2865:
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L2863;
L2863:
	return asi64(R1);
}

static u64 mc_optim_deletemcl(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L2870;
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2869;
L2870:
	R1 = tou64("");
	R2 = tou64("delmcl?");
	pc_api_merror(asu64(R2), asu64(R1));
L2869:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	goto L2867;
L2867:
	return asu64(R1);
}

static i64 mc_optim_endr0(u64 m) {
    u64 R1, R2; 
	asu64(R1) = m;
	R2 = 48;
	R1 += (i64)R2;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L2871;
L2871:
	return asi64(R1);
}

static void mc_genss_dummy_genss(i64 obj) {
	return;
}

static void mc_decls_start() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2876;
L2874:
	R1 = 10;
	R2 = (u64)&mc_decls_ploadop;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L2874;
L2876:
	R1 = 19;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 5;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 4;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 18;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 9;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 8;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 17;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 10;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mc_writegas_getassemstr() {
    u64 R1, R2; 
	u64 d;
	u64 e;
	u64 m;
	struct $B17 str2;
	struct $B17 str3;
	i64 i;
	u8 first;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("    .code64\n");
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("    .intel_syntax prefix\n");
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L2881;
L2878:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2883;
	R1 = tou64("    .global ");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
L2883:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2881:
	asu64(R1) = d;
	if (asu64(R1)) goto L2878;
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L2885;
L2884:
	asu64(R1) = m;
	asi64(R2) = i;
	mc_writegas_writemcl(asi64(R2), asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L2885:
	asu64(R1) = m;
	if (asu64(R1)) goto L2884;
	R1 = 1;
	first = asu8(R1);
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L2890;
L2887:
	asu64(R1) = d;
	R2 = 104;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2892;
	asu8(R1) = first;
	if (!asu8(R1)) goto L2894;
	R1 = 0;
	first = asu8(R1);
	R1 = tou64("    .section .drectve\n");
	mc_writegas_asmstr(asu64(R1));
L2894:
	R1 = tou64("    .ascii \" -export:\\\"");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64("\\\"\"\n");
	mc_writegas_asmstr(asu64(R1));
L2892:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2890:
	asu64(R1) = d;
	if (asu64(R1)) goto L2887;
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	goto L2877;
L2877:
	return asu64(R1);
}

static void mc_writegas_writemcl(i64 index, u64 mcl) {
    u64 R1, R2; 
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2897;
	goto L2898;
L2897:
	goto L2896;
L2898:
	asu64(R1) = mcl;
	mc_writegas_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
L2896:
	return;
}

static void mc_writegas_start() {
    u64 R1, R2, R3; 
	u8 flag;
	i64 av_1;
	i64 i;
	i64 r;
	i64 k;
	R1 = 5456199;
	pc_decls_assemtype = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L2900:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2905;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2905;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2905;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2904;
L2905:
	R1 = 1;
	r = asi64(R1);
L2906:
	R1 = 0;
	flag = asu8(R1);
	R1 = 1;
	k = asi64(R1);
	R1 = 137;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2911;
L2909:
	asu8(R1) = flag;
	if (!asu8(R1)) goto L2913;
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L2915;
	R1 = (u64)&mc_decls_regindices;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = r;
	if (asi64(R1) != asi64(R2)) goto L2915;
	R1 = (u64)&mc_decls_dregnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_writegas_nregnames;
	asi64(R3) = i;
	R2 += (i64)R3*128-128;
	asi64(R3) = r;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2915:
	goto L2912;
L2913:
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2916;
	R1 = 1;
	flag = asu8(R1);
L2916:
L2912:
	k += 1; if (k <= av_1) goto L2909;
L2911:
	r += 1; if (r <= 16) goto L2906;
L2904:
	i += 1; if (i <= 8) goto L2900;
	return;
}

static void mc_writegas_strmcl(u64 mcl) {
    u64 R1, R2, R3; 
	struct $B36 opcname;
	u64 a;
	u64 b;
	i64 opcode;
	i64 cond;
	i64 sizepref;
	u64 s;
	u64 comment;
	u64 d;
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asu64(R1) = mcl;
	R2 = 34;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu64(R1) = mcl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = mcl;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	comment = asu64(R1);
	asi64(R1) = opcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2919;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2920;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2921;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2922;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2923;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2924;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L2925;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2926;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L2927;
	goto L2928;
L2919:
	R1 = tou64("# Proc ");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	goto L2917;
	goto L2918;
L2920:
	R1 = tou64("# End ");
	mc_writegas_asmstr(asu64(R1));
	R1 = 0;
	mc_decls_currasmproc = asu64(R1);
	goto L2917;
	goto L2918;
L2921:
	R1 = 8227;
	mc_writegas_asmchar(asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	goto L2917;
	goto L2918;
L2922:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L2930;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L2931;
	goto L2932;
L2930:
	asu64(R1) = d;
	asu64(R1) = mc_writegas_getdispname(asu64(R1));
	mc_writegas_asmstr(asu64(R1));
	goto L2929;
L2931:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	goto L2917;
	goto L2929;
L2932:
	R1 = tou64("");
	R2 = tou64("strmcl/lab");
	pc_api_merror(asu64(R2), asu64(R1));
L2929:
	R1 = tou64(":");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2934;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2936;
	goto L2935;
L2936:
	R1 = tou64("\n");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64(":");
	mc_writegas_asmstr(asu64(R1));
L2935:
L2934:
	goto L2917;
	goto L2918;
L2923:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L2938;
	R1 = (u64)&mc_writegas_strmcl_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("L#:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L2937;
L2938:
	goto L2922;
L2937:
	R1 = (u64)&mc_writegas_strmcl_str;
	mc_writegas_asmstr(asu64(R1));
	goto L2917;
	goto L2918;
L2924:
	R1 = tou64("    .set ");
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writegas_asmstr(asu64(R1));
	R1 = tou64(", ");
	mc_writegas_asmstr(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L2917;
	goto L2917;
	goto L2918;
L2925:
	R1 = tou64("    .text");
	mc_writegas_asmstr(asu64(R1));
	R1 = 1;
	mc_writegas_currseg = asu8(R1);
	goto L2917;
	goto L2918;
L2926:
	R1 = tou64("    .data");
	mc_writegas_asmstr(asu64(R1));
	R1 = 2;
	mc_writegas_currseg = asu8(R1);
	goto L2917;
	goto L2918;
L2927:
	R1 = tou64("    .bss");
	mc_writegas_asmstr(asu64(R1));
	R1 = 3;
	mc_writegas_currseg = asu8(R1);
	goto L2917;
	goto L2918;
L2928:
L2918:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L2940;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L2941;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2942;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L2943;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2944;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L2945;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L2946;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2947;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L2948;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L2949;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2950;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2951;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L2952;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L2953;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L2954;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L2955;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L2956;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L2957;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L2958;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2959;
	goto L2960;
L2940:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("j");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L2939;
L2941:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("set");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L2939;
L2942:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("cmov");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L2939;
L2943:
	R1 = tou64("and");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2944:
	R1 = tou64("or");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2945:
	R1 = tou64("xor");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2946:
	R1 = tou64("not");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2947:
	R1 = tou64("imul");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2948:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2962;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2962;
	R1 = 4;
	asu64(R2) = a;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	R2 = R1;
	a = asu64(R2);
	asu64(R2) = mcl;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 11;
	opcode = asi64(R1);
L2962:
	goto L2960;
	goto L2960;
	goto L2939;
L2949:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2964;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2964;
	R1 = tou64("movsxd");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2963;
L2964:
	goto L2960;
	goto L2960;
L2963:
	goto L2939;
L2950:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2966;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2966;
	R1 = 17;
	opcode = asi64(R1);
L2966:
	goto L2960;
	goto L2960;
	goto L2939;
L2951:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2968;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2968;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2968;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2969;
	R2 = 2147483647;
	if (asi64(R1) <= asi64(R2)) goto L2968;
L2969:
	R1 = 17;
	asu64(R2) = mcl;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2968:
	goto L2960;
	goto L2960;
	goto L2939;
L2952:
	R1 = tou64(".align");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2953:
	R1 = tou64(".space");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2954:
	R1 = tou64(".byte");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2955:
	R1 = tou64(".word");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2956:
	R1 = tou64(".long");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2957:
	R1 = tou64(".quad");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2958:
	R1 = tou64(".ascii");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2939;
L2959:
	goto L2917;
	goto L2939;
L2960:
	asi64(R1) = opcode;
	R2 = 152;
	if (asi64(R1) <= asi64(R2)) goto L2971;
	R1 = 0;
	asi64(R2) = opcode;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2970;
L2971:
	R1 = (u64)&mc_decls_mclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 2;
	R1 += (i64)R2;
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L2970:
L2939:
	R1 = tou64(" ");
	R2 = 10;
	R3 = (u64)&opcname;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("  ");
	R2 = (u64)&mc_writegas_strmcl_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 4;
	R3 = (u64)&mc_writegas_strmcl_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&opcname;
	R2 = (u64)&mc_writegas_strmcl_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writegas_strmcl_str;
	mc_writegas_asmstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L2973;
	asu64(R1) = b;
	if (!asu64(R1)) goto L2973;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	asi64(R1) = mc_writegas_needsizeprefix(asi64(R3), asu64(R2), asu64(R1));
	sizepref = asi64(R1);
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = a;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64(",\t");
	mc_writegas_asmstr(asu64(R1));
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = b;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = mcl;
	R2 = 32;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2975;
	R1 = tou64(",");
	mc_writegas_asmstr(asu64(R1));
	R1 = 0;
	asu64(R2) = mcl;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	mc_writegas_asmstr(asu64(R1));
L2975:
	goto L2972;
L2973:
	asu64(R1) = a;
	if (!asu64(R1)) goto L2976;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L2976;
	asi64(R1) = opcode;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L2978;
	asi64(R1) = opcode;
	R2 = 0;
	asu64(R3) = a;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L2977;
L2978:
	asi64(R1) = opcode;
	R2 = 1;
	asu64(R3) = a;
	mc_writegas_asmopnd(asu64(R3), asi64(R2), asi64(R1));
L2977:
L2976:
L2972:
L2917:
	return;
}

static u64 mc_writegas_strmclstr(u64 m) {
    u64 R1, R2; 
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = m;
	mc_writegas_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L2979;
L2979:
	return asu64(R1);
}

static u64 mc_writegas_mstropnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3, R4; 
	struct $B36 str2;
	u64 plus;
	u64 t;
	i64 offset;
	i64 tc;
	R1 = 0;
	R2 = (u64)&mc_writegas_mstropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L2982;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L2983;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L2984;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L2985;
	goto L2986;
L2982:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writegas_strreg(asi64(R2), asi64(R1));
	goto L2980;
	goto L2981;
L2983:
	asi64(R1) = opcode;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L2988;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2988;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2990;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L2990;
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2989;
L2990:
	R1 = tou64("0x");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("H");
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2989:
	goto L2987;
L2988:
	asu64(R1) = a;
	asu64(R1) = mc_writegas_strvalue(asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L2987:
	goto L2981;
L2984:
	asi64(R1) = sizeprefix;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = mc_writegas_getsizeprefix(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("[");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2992;
	R1 = 8;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writegas_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
L2992:
	asu64(R1) = a;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2994;
	asu64(R1) = plus;
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = a;
	R3 = 11;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writegas_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2996;
	R1 = tou64("*");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 5;
	R4 = 8;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L2996:
L2994:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2999;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2999;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2998;
L2999:
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	R3 = 11;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3002;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3002;
	R1 = 1;
	goto L3003;
L3002:
	R1 = 0;
L3003:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3001;
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L3001;
	R1 = tou64("%rip+");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3001:
	asu64(R1) = plus;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L3005;
	asu64(R1) = plus;
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3005:
	asu64(R1) = a;
	asu64(R1) = mc_writegas_strvalue(asu64(R1));
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2997;
L2998:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L3006;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" + ");
	asi64(R2) = offset;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3006:
L2997:
	R1 = tou64("]");
	R2 = (u64)&mc_writegas_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L2981;
L2985:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writegas_strxreg(asi64(R2), asi64(R1));
	goto L2980;
	goto L2981;
L2986:
	msysc_m$print_startcon();
	R1 = tou64("BAD OPND");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<BAD OPND>");
	goto L2980;
L2981:
	R1 = (u64)&mc_writegas_mstropnd_str;
	goto L2980;
L2980:
	return asu64(R1);
}

static u64 mc_writegas_strvalue(u64 a) {
    u64 R1, R2, R3; 
	struct $B36 str2;
	u64 def;
	i64 value;
	i64 offset;
	i64 length;
	u64 ss;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	def = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3009;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3010;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3011;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3012;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3013;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L3014;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3015;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3016;
	goto L3017;
L3009:
	asu64(R1) = def;
	asu64(R1) = mc_writegas_getdispname(asu64(R1));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
// mc_writegas.strvalue.addoffset:
L3018:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L3020;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3022;
	R1 = tou64("+");
	goto L3021;
L3022:
	R1 = tou64("");
L3021:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = offset;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3020:
	goto L3008;
L3010:
	R1 = 0;
	asi64(R2) = value;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3008;
L3011:
	R1 = (u64)&mc_writegas_strvalue_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("20.20");
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	goto L3008;
L3012:
	R1 = tou64("M");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3008;
L3013:
	R1 = tou64("\"");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3008;
L3014:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3008;
L3015:
	R1 = tou64("L");
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writegas_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3018;
	goto L3008;
L3016:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_currasmproc;
	asu64(R1) = mc_writegas_gettempname(asu64(R2), asi64(R1));
	goto L3007;
	goto L3008;
L3017:
	R1 = tou64("");
	R2 = tou64("Stropnd?");
	pc_api_merror(asu64(R2), asu64(R1));
L3008:
	R1 = (u64)&mc_writegas_strvalue_str;
	goto L3007;
L3007:
	return asu64(R1);
}

static void mc_writegas_asmopnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	asi64(R2) = sizeprefix;
	asu64(R3) = a;
	asu64(R1) = mc_writegas_mstropnd(asu64(R3), asi64(R2), asi64(R1));
	mc_writegas_asmstr(asu64(R1));
	return;
}

static u64 mc_writegas_getxregname(i64 reg, i64 size) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3026;
	R1 = tou64("-");
	goto L3024;
L3026:
	R1 = (u64)&mc_writegas_getxregname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("%XMM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writegas_getxregname_str;
	goto L3024;
L3024:
	return asu64(R1);
}

static void mc_writegas_asmstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mc_writegas_asmchar(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_char(asu64(R2), asi64(R1));
	return;
}

static u64 mc_writegas_getdispname(u64 d) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = d;
	asu64(R1) = pc_api_getfullname(asu64(R2), asi64(R1));
	goto L3029;
L3029:
	return asu64(R1);
}

static u64 mc_writegas_gettempname(u64 d, i64 n) {
    u64 R1; 
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L3032;
	R1 = (u64)&mc_writegas_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L3031;
L3032:
	R1 = (u64)&mc_writegas_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.$T#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writegas_getdispname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3031:
	R1 = (u64)&mc_writegas_gettempname_str;
	goto L3030;
L3030:
	return asu64(R1);
}

static u64 mc_writegas_strreg(i64 reg, i64 size) {
    u64 R1, R2; 
	R1 = tou64("%");
	R2 = (u64)&mc_writegas_strreg_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writegas_nregnames;
	asi64(R2) = size;
	R1 += (i64)R2*128-128;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_writegas_strreg_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writegas_strreg_str;
	goto L3033;
L3033:
	return asu64(R1);
}

static u64 mc_writegas_strxreg(i64 reg, i64 size) {
    u64 R1, R2; 
	u64 d;
	R1 = 1;
	asi64(R2) = reg;
	asu64(R1) = mc_writegas_checkregvar(asi64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3036;
	asu64(R1) = d;
	if (!asu64(R1)) goto L3036;
	asu64(R1) = d;
	asu64(R1) = mc_writegas_getdispname(asu64(R1));
	goto L3035;
L3036:
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_writegas_getxregname(asi64(R2), asi64(R1));
L3035:
	goto L3034;
L3034:
	return asu64(R1);
}

static i64 mc_writegas_needsizeprefix(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L3039;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L3039;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L3039;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L3039;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L3040;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L3040;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L3040;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L3040;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3041;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L3041;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L3041;
	goto L3042;
L3039:
	R1 = 1;
	goto L3037;
	goto L3038;
L3040:
	R1 = 1;
	goto L3037;
	goto L3038;
L3041:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3044;
	R1 = 1;
	goto L3037;
L3044:
	R1 = 0;
	goto L3037;
	goto L3038;
L3042:
L3038:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3047;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3047;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3047;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3046;
L3047:
	R1 = 0;
	goto L3037;
L3046:
	R1 = 1;
	goto L3037;
L3037:
	return asi64(R1);
}

static u64 mc_writegas_getsizeprefix(i64 size, i64 enable) {
    u64 R1, R2; 
	asi64(R1) = enable;
	if (asi64(R1)) goto L3050;
	R1 = tou64("");
	goto L3048;
L3050:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3052;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3053;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3054;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3055;
	goto L3056;
L3052:
	R1 = tou64("byte ptr");
	goto L3048;
	goto L3051;
L3053:
	R1 = tou64("word ptr");
	goto L3048;
	goto L3051;
L3054:
	R1 = tou64("dword ptr");
	goto L3048;
	goto L3051;
L3055:
	R1 = tou64("qword ptr");
	goto L3048;
	goto L3051;
L3056:
L3051:
	R1 = tou64("");
	goto L3048;
L3048:
	return asu64(R1);
}

static u64 mc_writegas_checkregvar(i64 reg, i64 ispfloat) {
    u64 R1; 
	u64 d;
	R1 = 0;
	goto L3057;
L3057:
	return asu64(R1);
}

static void mc_writeexe_dummy_genexe(u64 entrypoint, u64 outfile, i64 dodll) {
	return;
}

static void mc_writeexe_dummy_writeexe(u64 outfile, i64 dodll) {
	return;
}

static void mc_writeobj_dummy_writecoff(u64 outfile) {
	return;
}

static u64 mc_writess_dummy_writessdata(i64 fexe) {
    u64 R1; 
	R1 = 0;
	goto L3061;
L3061:
	return asu64(R1);
}

static void mx_run_dummy_runlibfile(u64 filename, i64 cmdskip) {
    u64 R1; 
	R1 = tou64("No Run");
	mlib_abortprogram(asu64(R1));
	return;
}

static void mx_run_dummy_writemcx(u64 filename) {
	return;
}

void cc_cli_main() {
    u64 R1, R2; 
	u64 file;
	pepcl_start();
	asi64(R1) = mnoos_os_clock();
	cc_cli_startclock = asi64(R1);
	asi64(R1) = cc_cli_startclock;
	pc_decls_pstartclock = asi64(R1);
	cc_cli_starttiming();
	cc_cli_initdata();
	cc_cli_getinputoptions();
	cc_cli_initsearchdirs();
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3066;
	cc_cli_showsearchdirs();
L3066:
	cc_cli_initlogfile();
	asi64(R1) = cc_cli_gettiming();
	cc_cli_inittime = asi64(R1);
	asu8(R1) = cc_cli_fverbose;
	if (!asu8(R1)) goto L3068;
	msysc_m$print_startcon();
	R1 = tou64("Compiling # to #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_cli_outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3068:
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	pc_decls_$pmodulename = asu64(R1);
	cc_cli_do_loadmodule();
	cc_cli_do_preprocess();
	cc_cli_do_parsemodule();
	cc_cli_do_genpcl();
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3070;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3071;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3072;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3073;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3074;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3075;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3076;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3077;
	goto L3078;
L3070:
	pc_run_dummy_pcl_runpcl();
	goto L3069;
L3071:
	cc_cli_do_genmcl();
	goto L3069;
L3072:
	cc_cli_do_asm();
	goto L3069;
L3073:
	cc_cli_do_obj();
	goto L3069;
L3074:
	cc_cli_do_dll();
	goto L3069;
L3075:
	cc_cli_do_exe();
	goto L3069;
L3076:
	cc_cli_do_mx();
	goto L3069;
L3077:
	cc_cli_do_run();
	goto L3069;
L3078:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L3080;
	msysc_m$print_startcon();
	R1 = (u64)&cc_cli_passnames;
	asu8(R2) = cc_cli_cc_pass;
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("not ready");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3080:
L3069:
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3082;
	msysc_m$print_startcon();
	R1 = tou64("Done.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3082:
	asu8(R1) = cc_cli_fshowtiming;
	if (!asu8(R1)) goto L3084;
	cc_cli_showtiming();
L3084:
	cc_cli_closelogfile();
	R1 = 0;
	exit(R1);
	R1 = 0;
	exit(R1);
	return;
}

static void cc_cli_do_preprocess() {
    u64 R1, R2, R3; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3087;
	asu8(R1) = cc_cli_fstdout;
	R1 = toi64(tou8(R1));
	asu64(R2) = cc_cli_outfile;
	asu64(R3) = cc_decls_inputfile;
	cc_lex_lex_preprocess_only(asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	exit(R1);
L3087:
	return;
}

static void cc_cli_do_loadmodule() {
    u64 R1, R2, R3; 
	u64 modulename;
	struct $B15 path;
	i64 status;
	i64 i;
	i64 flag;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3090;
	msysc_m$print_startcon();
	R1 = tou64("Loading:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3090:
	cc_cli_starttiming();
	R1 = tou64("<dummy file>");
	R2 = (u64)&cc_decls_sourcefilenames;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("<dummy path>");
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("<sourcefile0>");
	R2 = (u64)&cc_decls_sourcefiletext;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilesizes;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 2;
	R2 = tou64("$prog");
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	cc_decls_stprogram = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L3092;
	asu64(R1) = cc_decls_inputfile;
	R2 = tou64("Can't load main module: #");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3092:
	asu64(R1) = cc_decls_inputfile;
	asu64(R2) = cc_decls_inputfile;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	cc_decls_mainfileno = asi64(R1);
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	modulename = asu64(R1);
	R1 = 3;
	asu64(R2) = modulename;
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	asu64(R3) = cc_decls_stprogram;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	cc_decls_stmodule = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&path;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3094;
	R1 = (u64)&cc_decls_nsearchdirs;
	(*toi64p(R1)) += 1;
	asi64(R1) = cc_decls_nsearchdirs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3097;
L3095:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = (u64)&cc_decls_searchdirs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += -1; if (i >= 2) goto L3095;
L3097:
	R1 = (u64)&path;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3094:
	asi64(R1) = cc_cli_gettiming();
	cc_cli_loadtime = asi64(R1);
	return;
}

static void cc_cli_do_parsemodule() {
    u64 R1, R2; 
	i64 tt;
	cc_cli_starttiming();
	asi64(R1) = cc_parse_parsemodule();
	asi64(R1) = cc_cli_gettiming();
	R2 = R1;
	tt = asi64(R2);
	cc_cli_parsetime = asi64(R1);
	return;
}

static void cc_cli_do_genpcl() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) >= asi64(R2)) goto L3101;
	goto L3099;
L3101:
	cc_cli_starttiming();
	cc_genpcl_codegen_pcl();
	asi64(R1) = cc_cli_gettiming();
	cc_cli_pcltime = asi64(R1);
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L3104;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L3103;
L3104:
	pc_reduce_pcl_reducetest();
L3103:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3106;
	asu64(R1) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
L3106:
L3099:
	return;
}

static void cc_cli_do_genmcl() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) >= asi64(R2)) goto L3109;
	goto L3107;
L3109:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L3111;
	R1 = 16705;
	asu64(R2) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L3111:
L3107:
	return;
}

static void cc_cli_do_asm() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L3114;
	goto L3112;
L3114:
	R1 = 16705;
	asu64(R2) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L3112:
	return;
}

static void cc_cli_do_obj() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3117;
	goto L3115;
L3117:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writeobj(asu64(R1));
L3115:
	return;
}

static void cc_cli_do_dll() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3120;
	goto L3118;
L3120:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writedll(asu64(R1));
L3118:
	return;
}

static void cc_cli_do_exe() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3123;
	goto L3121;
L3123:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writeexe(asu64(R1));
L3121:
	return;
}

static void cc_cli_do_mx() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3126;
	goto L3124;
L3126:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writemx(asu64(R1));
L3124:
	return;
}

static void cc_cli_do_run() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3129;
	goto L3127;
L3129:
	pc_api_pcl_exec();
L3127:
	return;
}

static void cc_cli_initlogfile() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_debugmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3132;
	R1 = tou64("mcc.log");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("w");
	R2 = tou64("mcc.log");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	cc_decls_logdev = asu64(R1);
L3132:
	return;
}

static void cc_cli_closelogfile() {
    u64 R1, R2, R3; 
	struct $B5 str;
	i64 pos;
	asu8(R1) = cc_cli_debugmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L3135;
	goto L3133;
L3135:
	asu8(R1) = cc_cli_fshowmcl;
	if (!asu8(R1)) goto L3137;
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L3137;
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC ASM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 16705;
	R2 = 0;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3137:
	asu8(R1) = cc_cli_fshowpcl;
	if (!asu8(R1)) goto L3139;
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L3139;
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("!PROC PCL");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = cc_cli_fshowpst;
	if (!asu8(R1)) goto L3141;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
	asu64(R1) = cc_decls_logdev;
	R2 = tou64("PSYMTAB");
	cc_lib_addtolog(asu64(R2), asu64(R1));
L3141:
L3139:
	cc_cli_showast();
	asu8(R1) = cc_cli_fshowst;
	if (!asu8(R1)) goto L3143;
	R1 = tou64("ST");
	cc_cli_showst(asu64(R1));
L3143:
	asu8(R1) = cc_cli_fshowstflat;
	if (!asu8(R1)) goto L3145;
	R1 = tou64("STFLAT");
	cc_cli_showstflat(asu64(R1));
L3145:
	asu8(R1) = cc_cli_fshowtypes;
	if (!asu8(R1)) goto L3147;
	asu64(R1) = cc_decls_logdev;
	cc_show_printmodelist(asu64(R1));
L3147:
	asu64(R1) = cc_decls_logdev;
	asi32(R1) = fclose(asu64(R1));
	R1 = tou64("cc.m");
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3149;
	msysc_m$print_startcon();
	R1 = tou64("PRESS KEY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mnoos_os_getch();
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L3151;
	R1 = 0;
	exit(R1);
L3151:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\m\\scripts\\med.bat ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mcc.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&str;
	asi64(R1) = mnoos_os_execwait(asu64(R3), asi64(R2), asu64(R1));
	goto L3148;
L3149:
	msysc_m$print_startcon();
	R1 = tou64("Diagnostic outputs written to");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mcc.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3148:
L3133:
	return;
}

static void cc_cli_initdata() {
    u64 R1, R2, R3; 
	mlib_pcm_init();
	cc_lex_lexsetup();
	cc_lib_inittypetables();
	cc_lib_initcclib();
	R1 = 0;
	cc_decls_nlibfiles = asi64(R1);
	R1 = tou64("msvcrt");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("gdi32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("user32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("kernel32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_cli_cgetsourceinfo;
	pc_decls_igetmsourceinfo = asu64(R1);
	asu8(R1) = pepcl_pdcc;
	if (!asu8(R1)) goto L3154;
	R1 = 2;
	cc_cli_highmem = asu8(R1);
L3154:
	return;
}

static i64 cc_cli_cgetsourceinfo(i64 pos, u64 filename, u64 sourceline) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = pos;
	R3 = 24;
	R4 = 32;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = filename;
	*tou64p(R2) = asu64(R1);
	R1 = tou64("<line>");
	asu64(R2) = sourceline;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pos;
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3155;
L3155:
	return asi64(R1);
}

static void cc_cli_initsearchdirs() {
    u64 R1, R2, R3; 
	struct $B15 str1;
	struct $B15 str2;
	i64 i;
	R1 = tou64("");
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = tou64("c:/cx/headers/");
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mnoos_os_gethostname();
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3159;
L3157:
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L3161;
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3161:
	i += 1; if (i <= cc_decls_nincludepaths) goto L3157;
L3159:
	return;
}

static void cc_cli_showsearchdirs() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Include search paths:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = cc_cli_dointheaders;
	if (!asu8(R1)) goto L3164;
	msysc_m$print_startcon();
	R1 = tou64("0: Internal standard headers (disable with -ext)");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3164:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsearchdirs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3167;
L3165:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L3169;
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3168;
L3169:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": .");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3168:
	i += 1; if (i <= cc_decls_nsearchdirs) goto L3165;
L3167:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showast() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_fshowast;
	if (!asu8(R1)) goto L3172;
	R1 = tou64("PROC AST");
	asu64(R2) = cc_decls_logdev;
	cc_show_printcode(asu64(R2), asu64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3172:
	return;
}

static void cc_cli_showstflat(u64 caption) {
    u64 R1; 
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	cc_show_printstflat(asu64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showst(u64 caption) {
    u64 R1, R2, R3; 
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = cc_decls_stmodule;
	asu64(R3) = cc_decls_logdev;
	cc_show_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showfiles() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Sourcefiles:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3178;
L3176:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilesizes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nsourcefiles) goto L3176;
L3178:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showtime(u64 caption, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("# # ms # %");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = caption;
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("5");
	asi64(R2) = t;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("5.1jr");
	asi64(R2) = t;
	asr64(R2) = tor64(asi64(R2));
	asr64(R3) = 1.000000000000000000e+002;
	asr64(R2) *= asr64(R3);
	asi64(R3) = cc_cli_compiletime;
	asr64(R3) = tor64(asi64(R3));
	asr64(R2) /= asr64(R3);
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showtiming() {
    u64 R1, R2; 
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = cc_cli_startclock;
	asi64(R1) -= asi64(R2);
	cc_cli_compiletime = asi64(R1);
	asi64(R1) = cc_cli_inittime;
	R2 = tou64("Init:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_loadtime;
	R2 = tou64("Load:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_parsetime;
	R2 = tou64("Parse:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_pcltime;
	R2 = tou64("PCL:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_mcltime;
	R2 = tou64("MCL:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_sstime;
	R2 = tou64("SS:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_exetime;
	R2 = tou64("EXE:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("-----------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = cc_cli_compiletime;
	R2 = tou64("Total:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	return;
}

static void cc_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 j;
	i64 k;
	i64 paramno;
	i64 pmtype;
	i64 sw;
	i64 ncolons;
	u64 name;
	u64 value;
	u64 ext;
	i64 av_1;
	R1 = 1;
	paramno = asi64(R1);
	R1 = 0;
	ncolons = asi64(R1);
	asu8(R1) = pepcl_pc_userunpcl;
	if (!asu8(R1)) goto L3183;
	R1 = 6;
	cc_cli_cc_pass = asu8(R1);
	R1 = 0;
	cc_cli_fverbose = asu8(R1);
L3183:
	R1 = tou64("cs.exe");
	asu64(R2) = mnoos_os_gethostname();
	asu64(R2) = mlib_extractfile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3185;
	R1 = 0;
	cc_cli_fverbose = asu8(R1);
	R1 = tou64("");
	R2 = 17;
	cc_cli_do_option(asi64(R2), asu64(R1));
L3185:
L3186:
	R1 = tou64(".c");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	pmtype = asi64(R1);
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3189;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3190;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3191;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3192;
	goto L3193;
L3189:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 53;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3197;
L3194:
	R1 = (u64)&cc_cli_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3199;
	asu64(R1) = value;
	asi64(R2) = sw;
	cc_cli_do_option(asi64(R2), asu64(R1));
	goto L3196;
L3199:
	sw += 1; if (sw <= av_1) goto L3194;
L3197:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L3196:
	goto L3188;
L3190:
	asu64(R1) = cc_decls_inputfile;
	if (!asu64(R1)) goto L3201;
	R1 = tou64("");
	R2 = tou64("One input file only");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3201:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_decls_inputfile = asu64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3204;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3203;
L3204:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	cc_cli_cmdskip = asi64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 6;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	cc_decls_pci_target = asu8(R1);
	goto L3187;
L3203:
	goto L3188;
L3191:
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 200;
	if (asi64(R1) < asi64(R2)) goto L3206;
	R1 = tou64("");
	R2 = tou64("Too many lib files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3206:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L3188;
L3192:
	goto L3187;
	goto L3188;
L3193:
L3188:
	goto L3186;
L3187:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3208;
	R1 = 12;
	cc_cli_cc_pass = asu8(R1);
	asu8(R1) = pepcl_asmonly;
	if (!asu8(R1)) goto L3210;
	R1 = 8;
	cc_cli_cc_pass = asu8(R1);
L3210:
L3208:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3213;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3212;
L3213:
	R1 = 2;
	cc_cli_highmem = asu8(R1);
	goto L3211;
L3212:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3215;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L3214;
L3215:
	R1 = 0;
	cc_cli_highmem = asu8(R1);
L3214:
L3211:
	R1 = (u64)&cc_cli_extnames;
	asu8(R2) = cc_cli_cc_pass;
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	cc_cli_outext = asu64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3218;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3217;
L3218:
	asu64(R1) = mc_writegas_asmext;
	cc_cli_outext = asu64(R1);
L3217:
	asu64(R1) = cc_decls_inputfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3220;
	asu8(R1) = cc_cli_fwriteheaders;
	if (asu8(R1)) goto L3220;
	cc_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("   prog[.c]          Compile prog.c to prog.exe");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-r prog[.c]          Compile prog.c and run");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-i prog[.c]          Compile prog.c and interpret");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-help                Show all options");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L3220:
	asu8(R1) = cc_cli_fwriteheaders;
	if (!asu8(R1)) goto L3222;
	cc_headers_writeheaders();
	R1 = 20;
	exit(R1);
L3222:
	asu64(R1) = cc_cli_outfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3224;
	asu64(R1) = cc_cli_outext;
	asu64(R2) = cc_decls_inputfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_cli_outfile = asu64(R1);
L3224:
	asu8(R1) = cc_cli_fshortnames;
	R1 = toi64(tou8(R1));
	R2 = -1;
	asu8(R3) = cc_cli_highmem;
	R3 = toi64(tou8(R3));
	pc_api_pcl_setflags(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cc_cli_cmdskip;
	pc_api_pcl_cmdskip(asi64(R2), asu64(R1));
	return;
}

static void cc_cli_do_option(i64 sw, u64 value) {
    u64 R1, R2, R3; 
	struct $B15 str;
	i64 length;
	u64 p;
	i64 av_1;
	i64 i;
	R1 = (u64)&cc_cli_optvars;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L3227;
	R1 = (u64)&cc_cli_optvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sw;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3229;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L3229;
	R1 = 1;
	R2 = (u64)&cc_cli_debugmode;
	*tou8p(R2) |= asu8(R1);
L3229:
	asi64(R1) = sw;
	R2 = 26;
	if (asi64(R1) < asi64(R2)) goto L3231;
	R2 = 34;
	if (asi64(R1) > asi64(R2)) goto L3231;
	R1 = 2;
	R2 = (u64)&cc_cli_debugmode;
	*tou8p(R2) |= asu8(R1);
L3231:
	asi64(R1) = sw;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3233;
	asu64(R1) = cc_decls_inputfile;
	if (!asu64(R1)) goto L3233;
	R1 = tou64("");
	R2 = tou64("-RUNP OUT OF ORDER");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3233:
	asi64(R1) = sw;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3236;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L3235;
L3236:
	R1 = 1;
	cc_decls_pci_target = asu8(R1);
L3235:
	goto L3225;
L3227:
	asi64(R1) = sw;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L3238;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L3239;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3239;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3240;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L3241;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L3242;
	goto L3243;
L3238:
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L3245;
	R1 = tou64("");
	R2 = tou64("Too many include paths");
	cc_support_loaderror(asu64(R2), asu64(R1));
L3245:
	asu64(R1) = value;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = value;
	asi64(R2) = length;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L3247;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L3247;
	goto L3248;
L3247:
	goto L3246;
L3248:
	asu64(R1) = value;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	value = asu64(R1);
L3246:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_includepaths;
	R3 = (u64)&cc_decls_nincludepaths;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L3237;
L3239:
	cc_cli_showhelp();
	goto L3237;
L3240:
	asu64(R1) = cc_cli_outext;
	asu64(R2) = value;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_cli_outfile = asu64(R1);
	goto L3237;
L3241:
	R1 = 0;
	R2 = R1;
	pc_decls_fpeephole = asu8(R2);
	pc_decls_fregoptim = asu8(R1);
	goto L3237;
L3242:
	R1 = 1;
	i = asi64(R1);
	R1 = 53;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3251;
L3249:
	msysc_m$print_startcon();
	R1 = tou64("   ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_cli_optionnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= av_1) goto L3249;
L3251:
	goto L3237;
L3243:
L3237:
L3225:
	return;
}

static void cc_cli_showincludepaths() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Include paths");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nincludepaths;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3255;
L3253:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nincludepaths) goto L3253;
L3255:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showhelp() {
    u64 R1; 
	cc_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("C Subset Compiler for 64-bit Windows\n\nNormal use:           Compiles prog.c to:\n\n    cc      prog      prog.exe (default)\n    cc -r   prog      in-memory native code then execute\n    cc -i   prog      in-memory IL then interpret\n\n    cc -exe prog      prog.exe\n    cc -dll prog      prog.dll\n    cc -obj prog      prog.obj\n    cc -s   prog      prog.asm (also -a)\n    cc -mx  prog      prog.mx\n    cc -p   prog      prog.pcl (textual IL)\n    cc -e   prog      prog.i   (preprocess only)\n\nOther options:\n\n    -incl:path        Add path to search for includes\n    -ext              Used std headers external to compiler\n    -opt              Optimise native code\n    -o:file           Name output file (extension can be added)\n    -norip            Don't use RIP address modes\n    -himem            Generate PIC code (automatic with -obj/-dll)\n    @file             Read files and options from a file\n    -c                Same as -obj\n    -s                Same as -asm\n    -ei               Same as -e, but when result is interpreted\n\nNotes:\n\n    * Compiles single module only\n    * For -i and -r, options\n    * .c extension is optional on input file\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 23;
	exit(R1);
	return;
}

static void cc_cli_showextrainfo() {
    u64 R1; 
// PROC LOCAL STATICS GO HERE
	static u64 cc_cli_showextrainfo_infotext = (u64)"    The 'MCC' C Compiler comprises:\n\n    mcc.exe            Compiles to .asm files\n    aa.exe             Assembles .asm files to .obj files\n                       Assemblers and links .asm/.dll files to .exe\n    Standard headers   A minimal set inside mcc.exe\n    windows.h          As a standalone file\n\n    Input files:\n\n      prog             This is prog.c as the extension is optional\n      prog.c\n      lib.dll          Include .dll library when generating .exe\n      @file            Read parameters and optons from given file\n\n    Options:\n\n      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files\n      -e               Preprocess each module to .i file\n      -s               Compile each module to .asm file\n      -c               Compile each module .obj via .asm\n\n      -out:file        Specify output file for -exe only\n\n    For .exe output, it will be named based on the first input file. Otherwise\n    use -out option\n\n    .obj files can be linked using gcc on Windows. This option is\n    needed to be able to generate .dll files. However, this will not\n    work on newer gcc versions because mcc's generated code is not position\n    independent, and will only work loaded in the low 2GB of address space.\n\n    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are\n    automatically included as search libraries for imported functions.\n\n    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported.\n\n    Omissions, Restrictions and Bugs (highlights only as there are dozens):\n\n      * No VLAs, compound literals, designated initialisers\n      * Restrictions on complexity of data initialisers\n";
	msysc_m$print_startcon();
	asu64(R1) = cc_cli_showextrainfo_infotext;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 24;
	exit(R1);
	return;
}

static void cc_cli_showcaption() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("CC C Compiler 7.x");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_starttiming() {
    u64 R1; 
	asi64(R1) = mnoos_os_clock();
	cc_cli_ttt = asi64(R1);
	return;
}

static i64 cc_cli_gettiming() {
    u64 R1, R2; 
	asi64(R1) = mnoos_os_clock();
	asi64(R2) = cc_cli_ttt;
	asi64(R1) -= asi64(R2);
	goto L3260;
L3260:
	return asi64(R1);
}

static void cc_lex_lex_preprocess_only(u64 infile, u64 outfile, i64 toconsole) {
    u64 R1, R2, R3; 
	u64 psource;
	i64 ntokens;
	i64 nlines;
	i64 fileno;
	i64 size;
	i64 length;
	i64 nchars;
	i64 t;
	i64 hashtot;
	i64 symtot;
	r64 tsecs;
	u64 f;
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_lex_preprocess_only_dest = (u64)&cc_lex_lex_preprocess_only_sbuffer;
	R1 = 1;
	cc_lex_dowhitespace = asi64(R1);
	asu64(R1) = infile;
	asu64(R2) = infile;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	fileno = asi64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	psource = asu64(R1);
	R1 = (u64)&cc_decls_sourcefilesizes;
	asi64(R2) = fileno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	R1 = 0;
	R2 = R1;
	ntokens = asi64(R2);
	nlines = asi64(R1);
	R1 = 0;
	R2 = R1;
	symtot = asi64(R2);
	hashtot = asi64(R1);
	asi64(R1) = mnoos_os_clock();
	t = asi64(R1);
	asu64(R1) = cc_lex_lex_preprocess_only_dest;
	cc_lex_destcopy = asu64(R1);
	asu64(R1) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = psource;
	cc_lex_lxsptr = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	cc_lex_lxstart = asu64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	cc_lex_setfileno(asi64(R1));
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 1;
	R2 = tou64("mcc.h");
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3262:
	cc_lex_lexm();
	R1 = (u64)&ntokens;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	R3 = (u64)&cc_decls_nextlx;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L3262;
	asi64(R1) = cc_lex_ifcondlevel;
	if (!asi64(R1)) goto L3266;
	R1 = tou64("#endif missing");
	cc_lex_lxerror(asu64(R1));
L3266:
	R1 = (u64)&cc_lex_showtokens;
	if (!asu64(R1)) goto L3268;
	asi64(R1) = toconsole;
	if (!asi64(R1)) goto L3270;
	R1 = 0;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	goto L3269;
L3270:
	R1 = tou64("wb");
	asu64(R2) = outfile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L3269:
L3268:
	return;
}

static void cc_lex_lexreadtoken() {
    u64 R1, R2, R3, R4, R5; 
	u64 c;
	u64 csum;
	u64 hsum;
	u64 dodir;
	u64 p;
	u64 ss;
	u64 searchstr;
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3273;
L3272:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L3273:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L3272;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3272;
L3275:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L3412;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 96: case 127: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: goto L3278;
	case 9: case 32: goto L3397;
	case 10: goto L3398;
	case 12: goto L3416;
	case 13: goto L3406;
	case 33: goto L3407;
	case 34: goto L3396;
	case 35: goto L3305;
	case 36: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L3279;
	case 37: goto L3369;
	case 38: goto L3390;
	case 39: goto L3395;
	case 40: goto L3335;
	case 41: goto L3336;
	case 42: goto L3360;
	case 43: goto L3349;
	case 44: goto L3329;
	case 45: goto L3354;
	case 46: goto L3321;
	case 47: goto L3363;
	case 48: goto L3296;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3292;
	case 58: goto L3331;
	case 59: goto L3330;
	case 60: goto L3376;
	case 61: goto L3372;
	case 62: goto L3383;
	case 63: goto L3347;
	case 64: goto L3411;
	case 91: goto L3337;
	case 92: goto L3309;
	case 93: goto L3338;
	case 94: goto L3344;
	case 123: goto L3319;
	case 124: goto L3339;
	case 125: goto L3320;
	case 126: goto L3348;
	case 239: goto L3417;
	default: goto L3278;
    };
// SWITCH
L3279:
// cc_lex.lexreadtoken.doname:
L3280:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_lxsvalue = asu64(R1);
	asu64(R1) = cc_lex_lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	hsum = asu64(R1);
	goto L3282;
L3281:
	asu64(R1) = hsum;
	R2 = 4;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	asu64(R2) = c;
	asu64(R1) += asu64(R2);
	hsum = asu64(R1);
L3282:
	R1 = (u64)&cc_lex_alphamap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = R2;
	c = asu64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3281;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = c;
	R2 = 39;
	if (asu64(R1) == asu64(R2)) goto L3285;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L3285;
	goto L3286;
L3285:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3288;
	asu64(R1) = cc_lex_lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L3290;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L3290;
	R2 = 117;
	if (asu64(R1) == asu64(R2)) goto L3290;
	R2 = 85;
	if (asu64(R1) == asu64(R2)) goto L3290;
	goto L3291;
L3290:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	asu64(R2) = c;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L3271;
	goto L3289;
L3291:
L3289:
L3288:
	goto L3284;
L3286:
L3284:
	asu64(R1) = hsum;
	R2 = 5;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	cc_lex_lxhashvalue = asi64(R1);
	asi64(R1) = cc_lex_lookup();
	goto L3271;
	goto L3275;
L3292:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3294;
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L3294;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3294;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L3294;
	R2 = 59;
	if (asu64(R1) == asu64(R2)) goto L3294;
	goto L3295;
L3294:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	goto L3293;
L3295:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readdecimal(asu64(R1));
L3293:
	goto L3271;
	goto L3275;
L3296:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 10: case 13: case 32: case 38: case 41: case 44: case 58: case 59: case 61: case 63: case 93: case 125: goto L3304;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 33: case 34: case 35: case 36: case 37: case 39: case 40: case 42: case 43: case 45: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 60: case 62: case 64: case 65: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 89: case 90: case 91: case 92: case 94: case 95: case 96: case 97: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 118: case 119: case 121: case 122: case 123: case 124: goto L3299;
	case 46: goto L3302;
	case 66: case 98: goto L3301;
	case 76: case 85: case 108: case 117: goto L3303;
	case 88: case 120: goto L3300;
	default: goto L3299;
    };
// SWITCH
L3300:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	cc_lex_readhex(asu64(R1));
	goto L3271;
	goto L3297;
L3301:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	cc_lex_readbinary(asu64(R1));
	goto L3271;
	goto L3297;
L3302:
	R1 = 10;
	R2 = 1;
	asu64(R3) = cc_lex_lxsptr;
	R4 = 1;
	R3 -= (i64)R4;
	asu64(R4) = cc_lex_lxsptr;
	R5 = 1;
	R4 -= (i64)R5;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3271;
	goto L3297;
L3303:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readdecimal(asu64(R1));
	goto L3271;
	goto L3297;
L3304:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	goto L3271;
	goto L3297;
L3299:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readoctal(asu64(R1));
	goto L3271;
L3297:
	goto L3275;
L3305:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L3307;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3306;
L3307:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) != asu64(R2)) goto L3308;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 7;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3306;
L3308:
	R1 = 5;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
L3306:
	goto L3275;
L3309:
L3310:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3312;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3312;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3313;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L3313;
	goto L3314;
L3312:
	goto L3311;
	goto L3310;
L3313:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3310;
L3314:
	R1 = 22;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3310;
L3311:
	R1 = 32;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3316;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3317;
	goto L3318;
L3316:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 32;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3315;
L3317:
	R1 = 32;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3315;
L3318:
L3315:
	goto L3275;
L3319:
	R1 = 17;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3320:
	R1 = 18;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3321:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 46: goto L3325;
	case 47: goto L3324;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3328;
	default: goto L3324;
    };
// SWITCH
L3325:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L3327;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 21;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3326;
L3327:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
L3326:
	goto L3271;
	goto L3322;
L3328:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	R2 = 0;
	asu64(R3) = cc_lex_lxsptr;
	asu64(R4) = cc_lex_lxsptr;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3271;
	goto L3322;
L3324:
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
L3322:
	goto L3275;
L3329:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3330:
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3331:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3333;
	goto L3334;
L3333:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3332;
L3334:
	R1 = 10;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3332:
	goto L3271;
	goto L3275;
L3335:
	R1 = 13;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3336:
	R1 = 14;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3337:
	R1 = 15;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3338:
	R1 = 16;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3339:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 124;
	if (asu64(R1) == asu64(R2)) goto L3341;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3342;
	goto L3343;
L3341:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 31;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3340;
L3342:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 51;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3340;
L3343:
	R1 = 28;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3340:
	goto L3271;
	goto L3275;
L3344:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3346;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 53;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3345;
L3346:
	R1 = 30;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3345:
	goto L3271;
	goto L3275;
L3347:
	R1 = 19;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3348:
	R1 = 35;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3349:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L3351;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3352;
	goto L3353;
L3351:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 37;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3350;
L3352:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 46;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3350;
L3353:
	R1 = 23;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3350:
	goto L3271;
	goto L3275;
L3354:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L3356;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L3357;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3358;
	goto L3359;
L3356:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 38;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3355;
L3357:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3355;
L3358:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 47;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3355;
L3359:
	R1 = 24;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3355:
	goto L3271;
	goto L3275;
L3360:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3362;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 48;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3361;
L3362:
	R1 = 25;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3361:
	goto L3271;
	goto L3275;
L3363:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L3365;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L3366;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3367;
	goto L3368;
L3365:
	cc_lex_readlinecomment();
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3271;
	goto L3364;
L3366:
	cc_lex_readblockcomment();
	goto L3364;
L3367:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 49;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3364;
L3368:
	R1 = 26;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
L3364:
	goto L3275;
L3369:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3371;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 50;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3370;
L3371:
	R1 = 27;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3370:
	goto L3271;
	goto L3275;
L3372:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3374;
	goto L3375;
L3374:
	R1 = 40;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3373;
L3375:
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3373:
	goto L3271;
	goto L3275;
L3376:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3378;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L3379;
	goto L3380;
L3378:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 43;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3377;
L3379:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3382;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 54;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3381;
L3382:
	R1 = 33;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3381:
	goto L3377;
L3380:
	R1 = 42;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3377:
	goto L3271;
	goto L3275;
L3383:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3385;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L3386;
	goto L3387;
L3385:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 44;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3384;
L3386:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3389;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 55;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3388;
L3389:
	R1 = 34;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3388:
	goto L3384;
L3387:
	R1 = 45;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3384:
	goto L3271;
	goto L3275;
L3390:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L3392;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3393;
	goto L3394;
L3392:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 32;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3391;
L3393:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 52;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3391;
L3394:
	R1 = 29;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3391:
	goto L3271;
	goto L3275;
L3395:
	R1 = 0;
	R2 = 39;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L3271;
	goto L3275;
L3396:
	R1 = 0;
	R2 = 34;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L3271;
	goto L3275;
L3397:
	goto L3275;
L3398:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_dowhitespace;
	if (!asi64(R1)) goto L3400;
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3401:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 9: case 32: goto L3405;
	case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: goto L3404;
	default: goto L3404;
    };
// SWITCH
L3405:
	goto L3401;
L3404:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3402;
	goto L3401;
L3402:
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3400:
	goto L3271;
	goto L3275;
L3406:
	goto L3275;
L3407:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3409;
	goto L3410;
L3409:
	R1 = 41;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3408;
L3410:
	R1 = 36;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3408:
	goto L3271;
	goto L3275;
L3411:
	msysc_m$print_startcon();
	R1 = tou64("@ SEEN");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_lex_lx_stackindex;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3275;
L3412:
// cc_lex.lexreadtoken.doeof:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = cc_lex_lx_stackindex;
	if (!asi64(R1)) goto L3415;
	cc_lex_unstacksourcefile();
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3414;
L3415:
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3414:
	goto L3271;
	goto L3275;
L3416:
	goto L3275;
L3417:
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	goto L3275;
L3278:
	R1 = 128;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3419;
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L3419;
	goto L3280;
L3419:
	msysc_m$print_startcon();
	R1 = tou64("ERROR CHAR");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = cc_lex_lx_stackindex;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("ERROR CHAR");
	cc_lex_lxerror(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3271;
	goto L3275;
L3271:
	return;
}

static void cc_lex_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base) {
    u64 R1, R2, R3, R4; 
	u64 fractstart;
	i64 fractlen;
	i64 expon;
	i64 i;
	i64 c;
	i64 badexpon;
	i64 n;
	i64 adj;
	r64 basex;
	r64 x;
	r64 expbase;
	r64 f;
	r64 y;
	r64 y2;
	r64 g;
	i64 aa;
	i64 cc;
	i64 pref;
	struct $B20 realstr;
	u64 rs;
	struct $B17 expstr;
	u64 xx1;
	u64 xx2;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3422;
	asi64(R1) = base;
	asi64(R2) = intlen;
	asu64(R3) = intstart;
	asu64(R4) = pstart;
	cc_lex_old_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3420;
L3422:
	R1 = 0;
	fractstart = asu64(R1);
	R1 = 0;
	fractlen = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L3424;
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	fractstart = asu64(R1);
	asi64(R1) = base;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = fractstart;
	asi64(R1) -= asi64(R2);
	fractlen = asi64(R1);
L3424:
	R1 = 0;
	badexpon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 101;
	if (asu64(R1) == asu64(R2)) goto L3426;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L3426;
	R2 = 112;
	if (asu64(R1) == asu64(R2)) goto L3427;
	R2 = 80;
	if (asu64(R1) == asu64(R2)) goto L3427;
	goto L3428;
L3426:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3430;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L3430:
	goto L3425;
L3427:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3432;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L3432:
	goto L3425;
L3428:
L3425:
	asi64(R1) = badexpon;
	if (!asi64(R1)) goto L3434;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L3420;
L3434:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 102;
	if (asu64(R1) == asu64(R2)) goto L3436;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L3436;
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L3436;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L3436;
	goto L3437;
L3436:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3435;
L3437:
	R1 = (u64)&cc_lex_alphamap;
	asu64(R2) = cc_lex_lxsptr;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3439;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L3420;
L3439:
L3435:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3441;
	R1 = 48;
	R2 = (u64)&realstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 120;
	R2 = (u64)&realstr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&realstr;
	R2 = 2;
	R1 += (i64)R2;
	rs = asu64(R1);
	R1 = 2;
	pref = asi64(R1);
	goto L3440;
L3441:
	R1 = (u64)&realstr;
	R2 = 0;
	R1 += (i64)R2;
	rs = asu64(R1);
	R1 = 0;
	pref = asi64(R1);
L3440:
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L3443;
	R1 = tou64("Real too long");
	cc_lex_lxerror(asu64(R1));
L3443:
	asi64(R1) = intlen;
	if (!asi64(R1)) goto L3445;
	asi64(R1) = intlen;
	asu64(R2) = intstart;
	asu64(R3) = rs;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L3445:
	asi64(R1) = fractlen;
	if (!asi64(R1)) goto L3447;
	asi64(R1) = fractlen;
	asu64(R2) = fractstart;
	asu64(R3) = rs;
	asi64(R4) = intlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L3447:
	asi64(R1) = base;
	asr64(R1) = tor64(asi64(R1));
	R2 = R1;
	basex = asr64(R2);
	expbase = asr64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3449;
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	goto L3448;
L3449:
	asi64(R1) = fractlen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 2.000000000000000000e+000;
	expbase = asr64(R1);
L3448:
	R1 = 0;
	R2 = (u64)&realstr;
	asi64(R3) = pref;
	asi64(R4) = intlen;
	asi64(R3) += asi64(R4);
	asi64(R4) = fractlen;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&expstr;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3451;
	R1 = tou64("e");
	goto L3450;
L3451:
	R1 = tou64("p");
L3450:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = expon;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&expstr;
	R2 = (u64)&realstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3453;
	R1 = tou64("Non-base-10 floats temporarily unavailable");
	cc_lex_lxerror(asu64(R1));
L3453:
	R1 = 0;
	R2 = (u64)&realstr;
	asr64(R1) = strtod(asu64(R2), asu64(R1));
	x = asr64(R1);
	R1 = 60;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = intstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = intstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3420:
	return;
}

static i64 cc_lex_readexponent(u64 badexpon) {
    u64 R1, R2; 
	u64 numstart;
	i64 length;
	i64 neg;
	i64 c;
	i64 a;
	i64 av_1;
	R1 = 0;
	neg = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L3456;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L3457;
	goto L3458;
L3456:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3455;
L3457:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	neg = asi64(R1);
	goto L3455;
L3458:
L3455:
	asu64(R1) = cc_lex_lxsptr;
	numstart = asu64(R1);
	R1 = 10;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = numstart;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3460;
	R1 = 1;
	asu64(R2) = badexpon;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	goto L3454;
L3460:
	R1 = 0;
	a = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3463;
L3461:
	R1 = (u64)&numstart;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	if (--asi64(av_1)) goto L3461;
L3463:
	asi64(R1) = neg;
	if (!asi64(R1)) goto L3465;
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	goto L3464;
L3465:
	asi64(R1) = a;
L3464:
	goto L3454;
L3454:
	return asi64(R1);
}

static void cc_lex_lxerror(u64 mess) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("\nLex error");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = cc_lex_getfileno();
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 11;
	exit(R1);
	return;
}

static void cc_lex_printsymbol(u64 lp) {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	struct $B17 l;
	asu64(R1) = lp;
	(R1_B17) = *(struct $B17*)(R1);
	l = (R1_B17);
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("%-18s");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = (u64)&l;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3469;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L3470;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L3471;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L3472;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L3473;
	goto L3474;
L3469:
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 106;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	goto L3468;
L3470:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = lp;
	cc_lex_shownumberstr(asu64(R2), asu64(R1));
	goto L3468;
L3471:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = lp;
	cc_lex_shownumberstr(asu64(R2), asu64(R1));
	goto L3468;
L3472:
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3468;
L3473:
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3468;
L3474:
	R1 = (u64)&l;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3476;
	msysc_m$print_startcon();
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&l;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3476:
L3468:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_lex_lexsetup() {
    u64 R1, R2, R3; 
	i64 i;
	cc_lex_inithashtable();
	cc_lex_fillhashtable();
	R1 = 0;
	i = asi64(R1);
L3478:
	asi64(R1) = i;
	switch (asi64(R1)) {
	case 36: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: case 239: case 240: case 241: case 242: case 243: case 244: case 245: case 246: case 247: case 248: case 249: case 250: case 251: case 252: case 253: case 254: case 255: goto L3484;
	case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 91: case 92: case 93: case 94: case 96: case 123: case 124: case 125: case 126: case 127: goto L3483;
	default: goto L3483;
    };
// SWITCH
L3484:
	R1 = 1;
	R2 = (u64)&cc_lex_alphamap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3481;
L3483:
L3481:
	asi64(R1) = i;
	switch (asi64(R1)) {
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3488;
	default: goto L3487;
    };
// SWITCH
L3488:
	R1 = 1;
	R2 = (u64)&cc_lex_digitmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3485;
L3487:
L3485:
	R1 = 1;
	R2 = (u64)&cc_lex_commentmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_linecommentmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_spacemap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 255) goto L3478;
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 42;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_spacemap;
	R3 = 32;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_spacemap;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 56;
	R2 = (u64)&cc_lex_normaltkx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	cc_lex_npastedtokens = asi64(R1);
	return;
}

static void cc_lex_printstrn(u64 s, i64 length, u64 f) {
    u64 R1, R2; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L3491;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3493;
	msysc_m$print_startcon();
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	goto L3492;
L3493:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
L3492:
L3491:
	return;
}

static u64 cc_lex_scannumber(i64 base) {
    u64 R1, R2, R3; 
	u64 dest;
	i64 c;
	asu64(R1) = cc_lex_lxsptr;
	dest = asu64(R1);
L3495:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 39: case 95: case 96: goto L3505;
	case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: goto L3498;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3499;
	case 65: case 66: case 67: case 68: case 69: case 70: case 97: case 98: case 99: case 100: case 101: case 102: goto L3502;
	default: goto L3498;
    };
// SWITCH
L3499:
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 48;
	asi64(R3) = base;
	asi64(R2) += asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L3501;
	R1 = tou64("Digit out of range");
	cc_lex_lxerror(asu64(R1));
L3501:
	goto L3495;
L3502:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3504;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3503;
L3504:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3496;
L3503:
	goto L3495;
L3505:
	goto L3495;
L3498:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3496;
	goto L3495;
L3496:
	asu64(R1) = dest;
	goto L3494;
L3494:
	return asu64(R1);
}

static i64 cc_lex_lookup() {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 length;
// cc_lex.lookup.retry:
L3507:
	asi64(R1) = cc_lex_lxhashvalue;
	asi64(R2) = cc_decls_hstmask;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L3508:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	length = asi64(R1);
	asi64(R1) = length;
	if (asi64(R1)) goto L3511;
	goto L3509;
L3511:
	asi64(R1) = length;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L3513;
	asi64(R1) = length;
	asu64(R2) = cc_lex_lxsvalue;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3515;
	R1 = 1;
	goto L3506;
L3515:
L3513:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = cc_decls_hstsize;
	if (asi64(R1) < asi64(R2)) goto L3517;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L3519;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L3519:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L3517:
	goto L3508;
L3509:
	asi64(R1) = cc_lex_nhstsymbols;
	asi64(R2) = cc_lex_hstthreshold;
	if (asi64(R1) < asi64(R2)) goto L3521;
	cc_lex_newhashtable();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	goto L3507;
L3521:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 106;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_nhstsymbols;
	(*toi64p(R1)) += 1;
	R1 = 0;
	goto L3506;
L3506:
	return asi64(R1);
}

static u64 cc_lex_gethashvalue(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 c;
	u64 hsum;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L3524;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L3524:
	R1 = 0;
	hsum = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3527;
L3525:
	asu64(R1) = hsum;
	R2 = 4;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asu64(R1) += asu64(R2);
	hsum = asu64(R1);
	if (--asi64(av_1)) goto L3525;
L3527:
	asu64(R1) = hsum;
	R2 = 5;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	goto L3522;
L3522:
	return asu64(R1);
}

static void cc_lex_inithashtable() {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = cc_decls_hstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_decls_hashtable = asu64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cc_decls_hstmask = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3531;
L3529:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= cc_decls_hstmask) goto L3529;
L3531:
	R1 = 0;
	cc_lex_nhstsymbols = asi64(R1);
	R1 = 6;
	asi64(R2) = cc_decls_hstsize;
	asi64(R1) *= asi64(R2);
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	cc_lex_hstthreshold = asi64(R1);
	return;
}

static void cc_lex_fillhashtable() {
    u64 R1, R2, R3; 
	i64 i;
	i64 av_1;
	R1 = 1;
	i = asi64(R1);
	R1 = 64;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3535;
L3533:
	R1 = (u64)&cc_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	cc_lex_lxsvalue = asu64(R1);
	R1 = (u64)&cc_tables_stsymbols;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L3537;
	asu64(R1) = cc_lex_lxsvalue;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_lex_lxsvalue = asu64(R1);
L3537:
	asu64(R1) = cc_lex_lxsvalue;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	asi64(R1) = cc_lex_lookup();
	if (!asi64(R1)) goto L3539;
	msysc_m$print_startcon();
	R1 = (u64)&cc_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Duplicate symbol table entry");
	mlib_abortprogram(asu64(R1));
L3539:
	R1 = (u64)&cc_tables_stsymbols;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_tables_stsubcodes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 100;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	i += 1; if (i <= av_1) goto L3533;
L3535:
	return;
}

static i64 cc_lex_dolexdirective() {
    u64 R1, R2, R3; 
	u64 symptr;
	u64 d;
	u64 p;
	u64 pstart;
	u64 s;
	i64 i;
	i64 cond;
	i64 c;
	i64 syshdr;
	i64 dir;
	i64 length;
	i64 allowmacros;
	struct $B15 filename;
	asu64(R1) = cc_lex_lxsptr;
	pstart = asu64(R1);
	asi64(R1) = cc_lex_getlexdirective();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3542;
	R1 = 0;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = pstart;
	asi64(R2) -= asi64(R3);
	asu64(R3) = pstart;
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Invalid # directive");
	cc_lex_lxerror(asu64(R1));
L3542:
	asi64(R1) = dir;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3544;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3545;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3546;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3547;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3548;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3549;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3550;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3550;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3551;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3552;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3553;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3554;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3555;
	goto L3556;
L3544:
	R1 = 1;
	cc_lex_isincludefile = asi64(R1);
	goto L3558;
L3557:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L3558:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3557;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3557;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 60;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	allowmacros = asi64(R1);
	cc_lex_lexm();
	R1 = 0;
	cc_lex_isincludefile = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L3561;
	R1 = 1;
	syshdr = asi64(R1);
	R1 = (u64)&filename;
	p = asu64(R1);
	asi64(R1) = allowmacros;
	if (!asi64(R1)) goto L3563;
L3564:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L3567;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3567;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L3568;
	goto L3569;
L3567:
	R1 = tou64("Bad include file");
	cc_lex_lxerror(asu64(R1));
	goto L3566;
L3568:
	goto L3565;
	goto L3566;
L3569:
	R1 = (u64)&length;
	R2 = (u64)&cc_decls_nextlx;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
L3566:
	goto L3564;
L3565:
	goto L3562;
L3563:
L3570:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L3573;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3574;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3574;
	goto L3575;
L3573:
	goto L3571;
	goto L3572;
L3574:
	R1 = tou64("include: > expected");
	cc_lex_lxerror(asu64(R1));
	goto L3572;
L3575:
	asi64(R1) = c;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3572:
	goto L3570;
L3571:
L3562:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L3560;
L3561:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L3576;
	R1 = 0;
	syshdr = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3560;
L3576:
	R1 = tou64("include?");
	cc_lex_lxerror(asu64(R1));
L3560:
	cc_lex_lexm();
	asu8(R1) = cc_cli_fshowincludes;
	if (!asu8(R1)) goto L3578;
	msysc_m$print_startcon();
	R1 = tou64("INCLUDE");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("FROM");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = cc_lex_getfileno();
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("NSOURCEFILES=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3578:
	R1 = (u64)&cc_lex_nincludes;
	(*toi64p(R1)) += 1;
	asi64(R1) = syshdr;
	R2 = (u64)&filename;
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	goto L3543;
L3545:
	cc_lex_dodefine();
	goto L3543;
L3546:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3580;
	R1 = tou64("undef: name expected");
	cc_lex_lxerror(asu64(R1));
L3580:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3582;
	goto L3581;
L3582:
	R1 = 0;
	asu64(R2) = d;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L3581:
	goto L3543;
L3547:
	asi64(R1) = cc_lex_getifdef();
	cond = asi64(R1);
	goto L3583;
	goto L3543;
L3548:
	asi64(R1) = cc_lex_getifdef();
	asi64(R1) = !asi64(R1);
	cond = asi64(R1);
	goto L3583;
	goto L3543;
L3549:
	asi64(R1) = cc_lex_getifexpr();
	cond = asi64(R1);
// cc_lex.dolexdirective.doif:
L3583:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) += 1;
	asi64(R1) = cond;
	if (!asi64(R1)) goto L3585;
	R1 = 0;
	goto L3540;
	goto L3584;
L3585:
// cc_lex.dolexdirective.doskipcode:
L3586:
	asi64(R1) = cc_lex_skipcode();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3588;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3589;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3590;
	goto L3591;
L3588:
	asi64(R1) = cc_lex_getifexpr();
	cond = asi64(R1);
	asi64(R1) = cond;
	if (!asi64(R1)) goto L3593;
	R1 = 0;
	goto L3540;
L3593:
	goto L3586;
	goto L3587;
L3589:
	goto L3587;
L3590:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L3587;
L3591:
L3587:
L3584:
	goto L3543;
L3550:
	asi64(R1) = cc_lex_ifcondlevel;
	if (asi64(R1)) goto L3595;
	R1 = tou64("#if missing/elif/else");
	cc_lex_lxerror(asu64(R1));
L3595:
L3596:
	asi64(R1) = cc_lex_skipcode();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3596;
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L3543;
L3551:
	asi64(R1) = cc_lex_ifcondlevel;
	if (asi64(R1)) goto L3600;
	R1 = tou64("#if missing/endif");
	cc_lex_lxerror(asu64(R1));
L3600:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L3543;
L3552:
	goto L3543;
L3553:
L3601:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L3601;
	goto L3543;
L3554:
	cc_lex_lexm();
	msysc_m$print_startcon();
	R1 = tou64("#ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_showtoken(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("ABORTING");
	cc_lex_lxerror(asu64(R1));
	goto L3543;
L3555:
	cc_lex_dopragmadir();
	goto L3543;
L3556:
// cc_lex.dolexdirective.skip:
	msysc_m$print_startcon();
	R1 = tou64("DIRECTIVE NOT IMPL:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_sourcedirnames;
	asi64(R2) = dir;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pstart;
	cc_lex_lxsptr = asu64(R1);
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	goto L3540;
	R1 = tou64("Directive not implemented");
	cc_lex_lxerror(asu64(R1));
L3543:
	R1 = 0;
	goto L3540;
L3540:
	return asi64(R1);
}

static i64 cc_lex_getlexdirective() {
    u64 R1, R2; 
	u64 d;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3607;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3608;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L3609;
	goto L3610;
L3607:
	goto L3606;
L3608:
	R1 = 13;
	goto L3605;
	goto L3606;
L3609:
L3611:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3614;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L3611;
L3614:
	R1 = 13;
	goto L3605;
	goto L3606;
L3610:
	R1 = 0;
	goto L3605;
L3606:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L3616;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L3617;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L3618;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3619;
	goto L3620;
L3616:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L3605;
	goto L3615;
L3617:
	R1 = 3;
	goto L3605;
	goto L3615;
L3618:
	R1 = 5;
	goto L3605;
	goto L3615;
L3619:
	R1 = 13;
	goto L3605;
	goto L3615;
L3620:
L3615:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3622;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L3624;
	asu64(R1) = d;
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L3605;
L3624:
L3622:
	R1 = 0;
	goto L3605;
L3605:
	return asi64(R1);
}

static void cc_lex_startlex(u64 caption, i64 fileno) {
    u64 R1, R2, R3; 
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	R1 = (u64)&cc_lex_normaltkx;
	cc_lex_normaltk = asu64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 1;
	cc_lex_firstsymbol = asi64(R1);
	R1 = 0;
	cc_lex_npastedtokens = asi64(R1);
	R1 = 0;
	cc_lex_isincludefile = asi64(R1);
	R1 = 0;
	cc_lex_tkptr = asu64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	cc_lex_lxsptr = asu64(R2);
	cc_lex_lxstart = asu64(R1);
	asi64(R1) = fileno;
	cc_lex_setfileno(asi64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	return;
}

static void cc_lex_endlex() {
    u64 R1; 
	asi64(R1) = cc_lex_ifcondlevel;
	if (!asi64(R1)) goto L3628;
	msysc_m$print_startcon();
	asi64(R1) = cc_lex_ifcondlevel;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("#endif missing");
	cc_lex_lxerror(asu64(R1));
L3628:
	return;
}

static void cc_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":::");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	cc_lex_printsymbol(asu64(R1));
	return;
}

static void cc_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":##");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_printsymbol(asu64(R1));
	return;
}

static i64 cc_lex_gethashtablesize() {
    u64 R1, R2; 
	i64 i;
	i64 n;
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3634;
L3632:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3636;
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L3636:
	i += 1; if (i <= cc_decls_hstmask) goto L3632;
L3634:
	asi64(R1) = n;
	goto L3631;
L3631:
	return asi64(R1);
}

static void cc_lex_readlinecomment() {
    u64 R1, R2; 
L3638:
	goto L3641;
L3640:
L3641:
	R1 = (u64)&cc_lex_linecommentmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3640;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3644;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3645;
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L3646;
	goto L3647;
L3644:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3639;
	goto L3643;
L3645:
	goto L3639;
	goto L3643;
L3646:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3649;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3650;
	goto L3651;
L3649:
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L3648;
L3650:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L3648;
L3651:
L3648:
	goto L3643;
L3647:
L3643:
	goto L3638;
L3639:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	return;
}

static void cc_lex_readblockcomment() {
    u64 R1, R2; 
L3653:
	goto L3656;
L3655:
L3656:
	R1 = (u64)&cc_lex_commentmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3655;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3659;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3660;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L3661;
	goto L3662;
L3659:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L3658;
L3660:
	R1 = tou64("block comment eof");
	cc_lex_lxerror(asu64(R1));
	goto L3658;
L3661:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) != asu64(R2)) goto L3664;
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	goto L3654;
L3664:
	goto L3658;
L3662:
L3658:
	goto L3653;
L3654:
	return;
}

static void cc_lex_readhex(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	u64 c;
	i64 length;
	i64 leading;
	i64 ll;
	i64 usigned;
	u64 p;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asi64(R2);
	ll = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L3666:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = R1;
	c = asu64(R2);
	switch (asi64(R1)) {
	case 46: case 80: case 112: goto L3676;
	case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 113: case 114: case 115: case 116: goto L3669;
	case 48: goto L3671;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3670;
	case 65: case 66: case 67: case 68: case 69: case 70: goto L3674;
	case 76: case 108: goto L3677;
	case 85: case 117: goto L3680;
	case 97: case 98: case 99: case 100: case 101: case 102: goto L3675;
	default: goto L3669;
    };
// SWITCH
L3670:
	R1 = 0;
	leading = asi64(R1);
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L3666;
L3671:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L3673;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L3672;
L3673:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asu64(R1) *= asu64(R2);
	aa = asu64(R1);
L3672:
	goto L3666;
L3674:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 65;
	asi64(R2) -= asi64(R3);
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	goto L3666;
L3675:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 97;
	asi64(R2) -= asi64(R3);
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	goto L3666;
L3676:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 16;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3665;
	goto L3666;
L3677:
	R1 = (u64)&ll;
	(*toi64p(R1)) += 1;
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3679;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L3679:
	goto L3666;
L3680:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L3682;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L3682:
	R1 = 1;
	usigned = asi64(R1);
	goto L3666;
L3669:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3667;
	goto L3666;
L3667:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L3684;
	R1 = tou64("Overflow in hex number");
	cc_lex_lxerror(asu64(R1));
L3684:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 9223372036854775807;
	if (asu64(R1) <= asu64(R2)) goto L3686;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3685;
L3686:
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) <= asu64(R2)) goto L3687;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3685;
L3687:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) <= asu64(R2)) goto L3688;
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3685;
L3688:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3685:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3691;
	asi64(R1) = ll;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3690;
	asu8(R1) = pc_decls_flong64;
	if (!asu8(R1)) goto L3690;
L3691:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3693;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3694;
	goto L3695;
L3693:
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3692;
L3694:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3692;
L3695:
L3692:
L3690:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L3697;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3699;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3700;
	goto L3701;
L3699:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3698;
L3700:
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3698;
L3701:
L3698:
L3697:
	asi64(R1) = cc_lex_checknumbersuffix();
L3665:
	return;
}

static void cc_lex_readbinary(u64 pstart) {
    u64 R1, R2, R3; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
L3703:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: goto L3712;
	case 47: goto L3706;
	case 48: goto L3708;
	case 49: goto L3707;
	case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3711;
	default: goto L3706;
    };
// SWITCH
L3707:
	R1 = 0;
	leading = asi64(R1);
	goto L3703;
L3708:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L3710;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L3710:
	goto L3703;
L3711:
	R1 = tou64("Binary bad digit");
	cc_lex_lxerror(asu64(R1));
	goto L3703;
L3712:
	R1 = tou64("Binary fp");
	cc_lex_lxerror(asu64(R1));
	goto L3703;
L3706:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3704;
	goto L3703;
L3704:
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L3714;
	R1 = tou64("Overflow in binary number");
	cc_lex_lxerror(asu64(R1));
L3714:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3717;
L3715:
	asu64(R1) = aa;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L3715;
L3717:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L3719;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3719:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
	return;
}

static void cc_lex_readoctal(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	i64 ll;
	i64 usigned;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asi64(R2);
	ll = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L3721:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: goto L3729;
	case 47: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L3724;
	case 48: goto L3726;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L3725;
	case 76: case 108: goto L3730;
	case 85: case 117: goto L3733;
	default: goto L3724;
    };
// SWITCH
L3725:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L3721;
L3726:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L3728;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L3727;
L3728:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L3727:
	goto L3721;
L3729:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3720;
	goto L3721;
L3730:
	R1 = (u64)&ll;
	(*toi64p(R1)) += 1;
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3732;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L3732:
	goto L3721;
L3733:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L3735;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L3735:
	R1 = 1;
	usigned = asi64(R1);
	goto L3721;
L3724:
	R1 = (u64)&cc_lex_alphamap;
	asi64(R2) = c;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3737;
// cc_lex.readoctal.doalpha:
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L3720;
L3737:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3722;
	goto L3721;
L3722:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 22;
	if (asi64(R1) > asi64(R2)) goto L3741;
	asi64(R1) = length;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L3740;
	R1 = 22;
	R2 = tou64("1777777777777777777777");
	asu64(R3) = p;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3740;
L3741:
	R1 = tou64("Overflow in octal number");
	cc_lex_lxerror(asu64(R1));
L3740:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3744;
L3742:
	asu64(R1) = aa;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L3742;
L3744:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L3746;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3746:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
L3720:
	return;
}

static void cc_lex_readdecimal(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	u8 ll;
	u8 usigned;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asu8(R2);
	ll = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) -= 1;
	p = asu64(R1);
	goto L3749;
L3748:
L3749:
	R1 = (u64)&cc_lex_digitmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3748;
	goto L3752;
L3751:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L3752:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L3751;
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
L3754:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: case 69: case 101: goto L3758;
	case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L3757;
	case 76: case 108: goto L3759;
	case 85: case 117: goto L3762;
	default: goto L3757;
    };
// SWITCH
L3758:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3747;
	goto L3754;
L3759:
	R1 = (u64)&ll;
	(*tou8p(R1)) += 1;
	asu8(R1) = ll;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3761;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L3761:
	goto L3754;
L3762:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L3764;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L3764:
	R1 = 1;
	usigned = asu8(R1);
	goto L3754;
L3757:
	R1 = (u64)&cc_lex_alphamap;
	asi64(R2) = c;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3766;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L3747;
L3766:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3755;
	goto L3754;
L3755:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L3769;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L3768;
	R1 = 20;
	R2 = tou64("18446744073709551615");
	asu64(R3) = p;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3768;
L3769:
	R1 = tou64("Overflow in decimal number");
	cc_lex_lxerror(asu64(R1));
L3768:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3772;
L3770:
	asu64(R1) = aa;
	R2 = 10;
	asu64(R1) *= asu64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = 48;
	asu64(R2) -= asu64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L3770;
L3772:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu8(R1) = ll;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3774;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3775;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3776;
	goto L3777;
L3774:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asi64(R1) < asi64(R2)) goto L3779;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3778;
L3779:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3778:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L3781;
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) < asu64(R2)) goto L3783;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3782;
L3783:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3782:
	goto L3780;
L3781:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L3785;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3785:
L3780:
	goto L3773;
L3775:
	asu8(R1) = pc_decls_flong64;
	if (!asu8(R1)) goto L3787;
	goto L3776;
L3787:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L3789;
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) < asu64(R2)) goto L3791;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3790;
L3791:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3790:
	goto L3788;
L3789:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L3793;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3792;
L3793:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3792:
L3788:
	goto L3773;
L3776:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L3795;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3794;
L3795:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3794:
	goto L3773;
L3777:
L3773:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L3747:
	return;
}

static i64 cc_lex_checknumbersuffix() {
    u64 R1, R2; 
	u8 c;
L3797:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = R1;
	c = asu8(R2);
	switch (asi64(R1)) {
	case 76: case 85: case 108: case 117: goto L3801;
	case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L3800;
	default: goto L3800;
    };
// SWITCH
L3801:
	goto L3797;
L3800:
	R1 = (u64)&cc_lex_alphamap;
	asu8(R2) = c;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3803;
L3803:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3798;
	goto L3797;
L3798:
	R1 = 3;
	goto L3796;
L3796:
	return asi64(R1);
}

static void cc_lex_stacksourcefile(u64 file, i64 syshdr) {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	u64 sptr;
	i64 fileno;
	struct $B8 info;
	struct $B80 fullpath;
	asi64(R1) = syshdr;
	asu64(R2) = file;
	asi64(R1) = cc_lex_getsourcefile(asu64(R2), asi64(R1));
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3806;
	msysc_m$print_startcon();
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	asi64(R1) = strlen(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find include file");
	cc_lex_lxerror(asu64(R1));
L3806:
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L3808;
	R1 = tou64("Too many nested includes");
	cc_lex_lxerror(asu64(R1));
L3808:
	R1 = (u64)&cc_lex_lx_stackindex;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&fullpath;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3810;
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = cc_lex_lx_stackindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = (u64)&fullpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L3810:
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3812;
	R1 = (u64)&cc_lex_headerpath;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&fullpath;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3812:
	R1 = (u64)&fullpath;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_lex_headerpathlist;
	asi64(R3) = cc_lex_lx_stackindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = cc_lex_lxstart;
	R2 = (u64)&info;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&info;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&info;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_getfileno();
	R2 = (u64)&info;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	(R1_B8) = info;
	R2 = (u64)&cc_lex_lx_stack;
	asi64(R3) = cc_lex_lx_stackindex;
	*(struct $B8*)(((i64)R2+(i64)R3*24-24)) = (R1_B8);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	cc_lex_lxsptr = asu64(R2);
	cc_lex_lxstart = asu64(R1);
	asi64(R1) = fileno;
	cc_lex_setfileno(asi64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void cc_lex_unstacksourcefile() {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	u64 path;
	struct $B8 info;
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = cc_lex_lx_stackindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	path = asu64(R1);
	asu64(R1) = path;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = path;
	mlib_pcm_free(asu64(R2), asi64(R1));
	R1 = (u64)&cc_lex_lx_stack;
	R2 = (u64)&cc_lex_lx_stackindex;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	(R1_B8) = *(struct $B8*)(((i64)R1+(i64)R2*24-24));
	info = (R1_B8);
	R1 = (u64)&info;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_lxstart = asu64(R1);
	R1 = (u64)&info;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_lxsptr = asu64(R1);
	R1 = (u64)&info;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&info;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_lex_setfileno(asi64(R1));
	return;
}

static i64 cc_lex_getsourcefile(u64 file, i64 syshdr) {
    u64 R1, R2, R3; 
	struct $B15 filespec2;
	u64 hdrtext;
	i64 i;
	R1 = 0;
	R2 = (u64)&cc_lex_headerpath;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3817;
L3815:
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3819;
	asi64(R1) = i;
	goto L3814;
L3819:
	i += 1; if (i <= cc_decls_nsourcefiles) goto L3815;
L3817:
	asu8(R1) = cc_cli_dointheaders;
	if (!asu8(R1)) goto L3821;
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = cc_headers_findheader(asu64(R1));
	hdrtext = asu64(R1);
	asu64(R1) = hdrtext;
	if (!asu64(R1)) goto L3823;
	asu64(R1) = hdrtext;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadbuiltin(asu64(R2), asu64(R1));
	goto L3814;
L3823:
L3821:
	R1 = tou64("mcc.h");
	asu64(R2) = file;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3825;
	R1 = tou64("#define __attribute__(x)\n#define _WIN32\n#define WIN32\n#define __WIN32__\n#define __inline\n#define __dllimport(x)\n//#define __declspec(x)\n#define __stdcall\n#define CALLBACK $callback\n#define __cdecl\n#define EXTERN_C extern\n#define DECLSPEC_IMPORT\n#define __32BIT__\n#define register\n#define __MCCC__\n\n//typedef signed char\t\ti8;\n//typedef short\t\t\ti16;\n//typedef int\t\t\t\ti32;\n//typedef long long int\ti64;\n//typedef unsigned char\t\t\tu8;\n//typedef unsigned short\t\t\tu16;\n//typedef unsigned int\t\t\tu32;\n//typedef unsigned long long int\tu64;\n//\n//typedef unsigned char byte;\n//\n//typedef float r32;\n//typedef double r64;\n\n");
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadbuiltin(asu64(R2), asu64(R1));
	goto L3814;
L3825:
	asu64(R1) = file;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&cc_lex_headerpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3827;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L3830;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L3829;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) != asu64(R2)) goto L3829;
L3830:
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3832;
	asu64(R1) = file;
	asu64(R2) = file;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L3814;
L3832:
	R1 = 0;
	goto L3814;
L3829:
L3827:
	asi64(R1) = cc_lex_lx_stackindex;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3835;
L3833:
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3837;
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L3814;
L3837:
	i += -1; if (i >= 1) goto L3833;
L3835:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsearchdirs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3840;
L3838:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3842;
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&cc_lex_headerpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L3814;
L3842:
	i += 1; if (i <= cc_decls_nsearchdirs) goto L3838;
L3840:
	R1 = 0;
	goto L3814;
L3814:
	return asi64(R1);
}

static void cc_lex_lex() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
// cc_lex.lex.reenter:
	(R1_B17) = cc_decls_nextlx;
	cc_decls_lx = (R1_B17);
	cc_lex_lexm();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L3846;
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3846;
	R1 = 0;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&cc_decls_lx;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3846:
L3847:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3849;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3850;
	goto L3851;
L3849:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L3853;
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3853:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3843;
	goto L3847;
L3850:
	cc_lex_lexm();
	goto L3847;
L3851:
	goto L3843;
	goto L3847;
L3843:
	return;
}

static void cc_lex_shownumberstr(u64 l, u64 f) {
    u64 R1, R2, R3; 
	u64 s;
	asu64(R1) = l;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	if (!asi64(R1)) goto L3856;
	R1 = (u64)&cc_decls_sourcefiletext;
	asu64(R2) = l;
	asi64(R2) = cc_lex_getfilenox(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = l;
	asi64(R2) = cc_lex_getnumberoffsetx(asu64(R2));
	R1 += (i64)R2;
	s = asu64(R1);
	goto L3855;
L3856:
	R1 = (u64)&cc_lex_pastedtokenlist;
	asu64(R2) = l;
	R3 = 28;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	s = asu64(R1);
L3855:
	asu64(R1) = f;
	asu64(R2) = l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = s;
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static u64 cc_lex_addnamestr(u64 name) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	struct $B17 oldlx;
	u64 symptr;
	(R1_B17) = cc_decls_nextlx;
	oldlx = (R1_B17);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = name;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_lex_lxsvalue = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R2) = name;
	asu64(R3) = cc_lex_lxsvalue;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cc_lex_lookup();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B17) = oldlx;
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = symptr;
	goto L3857;
L3857:
	return asu64(R1);
}

static void cc_lex_lxreadstring(i64 termchar, i64 fwide) {
    u64 R1, R2, R3, R4; 
	struct $B41 str;
	u64 dest;
	u64 ws;
	u64 wd;
	u64 wd0;
	i64 c;
	i64 d;
	i64 length;
	i64 useheap;
	i64 av_1;
	i64 av_2;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L3860;
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L3862;
	R1 = 64;
	goto L3861;
L3862:
	R1 = 63;
L3861:
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3859;
L3860:
	R1 = 61;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3859:
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3864;
	asi64(R1) = fwide;
	if (asi64(R1)) goto L3864;
	asu64(R1) = cc_lex_lxsptr;
	dest = asu64(R1);
	asu64(R1) = dest;
	ws = asu64(R1);
	R1 = 0;
	useheap = asi64(R1);
	goto L3863;
L3864:
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	ws = asu64(R1);
	R1 = 1;
	useheap = asi64(R1);
L3863:
	R1 = 0;
	length = asi64(R1);
L3865:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L3868;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L3869;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3869;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3870;
	goto L3871;
L3868:
	asi64(R1) = cc_lex_isincludefile;
	if (!asi64(R1)) goto L3873;
	R1 = 47;
	c = asi64(R1);
	goto L3874;
L3873:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
// cc_lex.lxreadstring.reenter:
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 10: goto L3908;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 93: case 94: case 95: case 96: case 99: case 100: case 101: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 111: case 112: case 113: case 115: case 117: case 119: goto L3878;
	case 13: goto L3905;
	case 34: goto L3902;
	case 39: goto L3904;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L3895;
	case 92: goto L3903;
	case 97: goto L3879;
	case 98: goto L3880;
	case 102: goto L3881;
	case 110: goto L3882;
	case 114: goto L3883;
	case 116: goto L3884;
	case 118: goto L3885;
	case 120: goto L3886;
	default: goto L3878;
    };
// SWITCH
L3879:
	R1 = 7;
	c = asi64(R1);
	goto L3876;
L3880:
	R1 = 8;
	c = asi64(R1);
	goto L3876;
L3881:
	R1 = 12;
	c = asi64(R1);
	goto L3876;
L3882:
	R1 = 10;
	c = asi64(R1);
	goto L3876;
L3883:
	R1 = 13;
	c = asi64(R1);
	goto L3876;
L3884:
	R1 = 9;
	c = asi64(R1);
	goto L3876;
L3885:
	R1 = 11;
	c = asi64(R1);
	goto L3876;
L3886:
	R1 = 0;
	c = asi64(R1);
L3887:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	d = asi64(R2);
	switch (asi64(R1)) {
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L3894;
	case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: goto L3891;
	case 65: case 66: case 67: case 68: case 69: case 70: goto L3892;
	case 97: case 98: case 99: case 100: case 101: case 102: goto L3893;
	default: goto L3891;
    };
// SWITCH
L3892:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L3889;
L3893:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L3889;
L3894:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L3889;
L3891:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3888;
L3889:
	goto L3887;
L3888:
	goto L3876;
L3895:
	R1 = 48;
	R2 = (u64)&c;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	av_1 = asi64(R1);
L3896:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	d = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L3900;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L3900;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L3900;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L3900;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L3900;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L3900;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L3900;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L3900;
	goto L3901;
L3900:
	asi64(R1) = c;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L3899;
L3901:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3898;
L3899:
	if (--asi64(av_1)) goto L3896;
L3898:
	goto L3876;
L3902:
	R1 = 34;
	c = asi64(R1);
	goto L3876;
L3903:
	R1 = 92;
	c = asi64(R1);
	goto L3876;
L3904:
	R1 = 39;
	c = asi64(R1);
	goto L3876;
L3905:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3907;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L3907:
	goto L3865;
	goto L3876;
L3908:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L3865;
	goto L3876;
L3878:
L3876:
	goto L3867;
L3869:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L3910;
	goto L3866;
L3910:
	goto L3867;
L3870:
	msysc_m$print_startcon();
	R1 = tou64("NEXTLX.LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("String not terminated");
	cc_lex_lxerror(asu64(R1));
	goto L3867;
L3871:
L3867:
// cc_lex.lxreadstring.normalchar:
L3874:
	asi64(R1) = useheap;
	if (asi64(R1)) goto L3912;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3911;
L3912:
	R1 = (u64)&length;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L3913;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3911;
L3913:
	R1 = tou64("Local str too long");
	cc_lex_lxerror(asu64(R1));
L3911:
	goto L3865;
L3866:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L3915;
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 2;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	wd = asu64(R2);
	wd0 = asu64(R1);
	asi64(R1) = length;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3918;
L3916:
	R1 = (u64)&ws;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = (u64)&wd;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 2; asu64(R2) = asu64(R3);
	*tou16p(R2) = asu16(R1);
	if (--asi64(av_2)) goto L3916;
L3918:
	R1 = 0;
	asu64(R2) = wd;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = wd0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3914;
L3915:
	asi64(R1) = useheap;
	if (!asi64(R1)) goto L3919;
	asi64(R1) = length;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	R2 = 1;
	asu64(R1) += asu64(R2);
	R2 = (u64)&str;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L3914;
L3919:
	asu64(R1) = dest;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3914:
	return;
}

static void cc_lex_addlisttoken(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3922;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3921;
L3922:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3921:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlisttoken_copy(u64 ulist, u64 ulistx, u64 q) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 p;
	asu64(R1) = cc_lex_alloctoken();
	p = asu64(R1);
	asu64(R1) = q;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = p;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3925;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3924;
L3925:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3924:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlist_nextlx(u64 ulist, u64 ulistx) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 p;
	asu64(R1) = cc_lex_alloctoken();
	p = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	asu64(R2) = p;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3928;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3927;
L3928:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3927:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlisttoken_seq(u64 ulist, u64 ulistx, u64 seq) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 tk;
	goto L3931;
L3930:
	asu64(R1) = cc_lex_alloctoken();
	tk = asu64(R1);
	asu64(R1) = seq;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3934;
	asu64(R1) = tk;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3933;
L3934:
	asu64(R1) = tk;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3933:
	R1 = 0;
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L3931:
	asu64(R1) = seq;
	if (asu64(R1)) goto L3930;
	return;
}

static void cc_lex_addlistmparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3937;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3936;
L3937:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3936:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_dodefine() {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	u64 stlist;
	u64 stlistx;
	u64 p;
	u64 q;
	u64 stname;
	u64 d;
	u64 tklist;
	u64 tklistx;
	u64 tk;
	i64 nparams;
	i64 ntokens;
	i64 paramno;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3940;
	R1 = tou64("define: name expected");
	cc_lex_lxerror(asu64(R1));
L3940:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 92;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = stname;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	nparams = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) != asu64(R2)) goto L3942;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 0;
	R2 = R1;
	stlistx = asu64(R2);
	stlist = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	cc_lex_lexreadtoken();
L3943:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3946;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3947;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L3948;
	goto L3949;
L3946:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = stlist;
	p = asu64(R1);
	goto L3951;
L3950:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L3954;
	R1 = tou64("Dupl macro param");
	cc_lex_lxerror(asu64(R1));
L3954:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L3951:
	asu64(R1) = p;
	if (asu64(R1)) goto L3950;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	cc_lex_addlistmparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3956;
	cc_lex_lexreadtoken();
L3956:
	goto L3945;
L3947:
	goto L3944;
	goto L3945;
L3948:
	R1 = tou64("__VA_ARGS__");
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	d = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3958;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L3958:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	cc_lex_addlistmparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	goto L3944;
	goto L3945;
L3949:
	R1 = tou64("macro params?");
	cc_lex_lxerror(asu64(R1));
L3945:
	goto L3943;
L3944:
	asu64(R1) = stlist;
	asu64(R2) = stname;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3942:
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	R1 = 0;
	ntokens = asi64(R1);
L3959:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3962;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L3962;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3963;
	goto L3964;
L3962:
	goto L3960;
	goto L3961;
L3963:
	asu64(R1) = stname;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = 1;
	paramno = asi64(R1);
	goto L3966;
L3965:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3969;
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	asi64(R1) = paramno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L3967;
L3969:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&paramno;
	(*toi64p(R1)) += 1;
L3966:
	asu64(R1) = p;
	if (asu64(R1)) goto L3965;
L3967:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	if (asu64(R1) != asu64(R2)) goto L3971;
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
L3971:
	goto L3961;
L3964:
L3961:
	R1 = (u64)&ntokens;
	(*toi64p(R1)) += 1;
	asu64(R1) = cc_lex_alloctoken();
	tk = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
	asu64(R1) = tk;
	R2 = (u64)&tklistx;
	R3 = (u64)&tklist;
	cc_lex_addlisttoken(asu64(R3), asu64(R2), asu64(R1));
	goto L3959;
L3960:
	asu64(R1) = tklist;
	asu64(R2) = stname;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nparams;
	asu64(R2) = stname;
	R3 = 111;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void cc_lex_readalphanumeric(u64 pstart) {
    u64 R1, R2, R3; 
	goto L3974;
L3973:
L3974:
	R1 = (u64)&cc_lex_alphamap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3973;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 58;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 cc_lex_inmacrostack(u64 d, u64 macrostack) {
    u64 R1, R2; 
	goto L3978;
L3977:
	asu64(R1) = macrostack;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L3981;
	R1 = 1;
	goto L3976;
L3981:
	asu64(R1) = macrostack;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	macrostack = asu64(R1);
L3978:
	asu64(R1) = macrostack;
	if (asu64(R1)) goto L3977;
	R1 = 0;
	goto L3976;
L3976:
	return asi64(R1);
}

static void cc_lex_showtokens(u64 caption, u64 tk) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("<");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3984;
L3983:
	asu64(R1) = tk;
	cc_lex_showtoken(asu64(R1));
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L3984:
	asu64(R1) = tk;
	if (asu64(R1)) goto L3983;
	msysc_m$print_startcon();
	R1 = tou64(">");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_lex_lexa(u64 tk) {
    u64 R1, R2, R3; struct $B17 R1_B17; 
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = cc_lex_normaltk;
	if (asu64(R1) != asu64(R2)) goto L3988;
	cc_lex_lexreadtoken();
	goto L3986;
L3988:
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3990;
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3986;
L3990:
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	(R1_B17) = *(struct $B17*)(R1);
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	*tou64p(R2) = asu64(R1);
L3986:
	return;
}

static void cc_lex_lexm() {
    u64 R1, R2, R3, R4, R5; struct $B17 R1_B17; 
	u64 d;
	i64 newlineno;
// PROC LOCAL STATICS GO HERE
	static i64 cc_lex_lexm_doreset = 0;
L3992:
	asu64(R1) = cc_lex_tkptr;
	if (!asu64(R1)) goto L3995;
	asu64(R1) = cc_lex_tkptr;
	(R1_B17) = *(struct $B17*)(R1);
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = cc_lex_tkptr;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_tkptr = asu64(R1);
	asu64(R1) = cc_lex_tkptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3997;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L3999;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3999;
	asi64(R1) = cc_lex_peeklb();
	if (!asi64(R1)) goto L3999;
	asi64(R1) = cc_decls_sfileno;
	cc_lex_setfileno(asi64(R1));
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	cc_lex_lexm_doreset = asi64(R1);
	goto L4000;
L3999:
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
L3997:
	goto L3991;
L3995:
	asi64(R1) = cc_lex_lexm_doreset;
	if (!asi64(R1)) goto L4002;
	asi64(R1) = cc_decls_sfileno;
	cc_lex_setfileno(asi64(R1));
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	cc_lex_lexm_doreset = asi64(R1);
L4002:
	asi64(R1) = cc_lex_firstsymbol;
	if (!asi64(R1)) goto L4004;
	R1 = 0;
	cc_lex_firstsymbol = asi64(R1);
	cc_lex_dospecialinclude();
L4004:
	cc_lex_lexreadtoken();
// cc_lex.lexm.test1:
L4000:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4006;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4007;
	goto L4008;
L4006:
	asi64(R1) = cc_lex_dolexdirective();
	if (!asi64(R1)) goto L4010;
	goto L3991;
L4010:
	goto L3992;
	goto L4005;
L4007:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4012;
	goto L4013;
L4012:
	asi64(R1) = cc_lex_getfileno();
	cc_decls_sfileno = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_slineno = asi64(R1);
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	asu64(R3) = d;
	R4 = 100;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	cc_lex_expandpredefmacro(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
	goto L3991;
	goto L4011;
L4013:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4016;
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L4015;
L4016:
	goto L3991;
L4015:
L4011:
	goto L4005;
L4008:
	goto L3991;
L4005:
	asi64(R1) = cc_lex_getfileno();
	cc_decls_sfileno = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_slineno = asi64(R1);
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4018;
	asi64(R1) = cc_lex_peeklb();
	if (asi64(R1)) goto L4020;
	goto L3991;
L4020:
	R1 = (u64)&newlineno;
	R2 = 1;
	R3 = (u64)&cc_lex_normaltk;
	R4 = 0;
	asu64(R5) = d;
	asu64(R1) = cc_lex_expandfnmacro(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	cc_lex_tkptr = asu64(R1);
	asi64(R1) = newlineno;
	cc_decls_slineno = asi64(R1);
	goto L4017;
L4018:
	R1 = 1;
	R2 = (u64)&cc_lex_normaltk;
	R3 = 0;
	asu64(R4) = d;
	asu64(R1) = cc_lex_expandobjmacro(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	cc_lex_tkptr = asu64(R1);
L4017:
	asu64(R1) = cc_lex_tkptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4022;
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
L4022:
	goto L3992;
L3991:
	return;
}

static i64 cc_lex_peeklb() {
    u64 R1, R2; 
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) == asu64(R2)) goto L4026;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) != asu64(R2)) goto L4025;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) != asu64(R2)) goto L4025;
L4026:
	R1 = 1;
	goto L4023;
L4025:
	R1 = 0;
	goto L4023;
L4023:
	return asi64(R1);
}

static i64 cc_lex_peektk(u64 tk) {
    u64 R1, R2; 
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4029;
	R1 = 0;
	goto L4027;
L4029:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4031;
	R1 = 1;
	goto L4027;
L4031:
	R1 = 0;
	goto L4027;
L4027:
	return asi64(R1);
}

static u64 cc_lex_expandobjmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel) {
    u64 R1, R2, R3, R4, R5; 
	u64 tk;
	u64 p;
	u64 repl;
	struct $B17 newmacro;
	i64 iscomplex;
	i64 useshh;
	i64 expanded;
	u64 d;
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	tk = asu64(R2);
	p = asu64(R1);
	R1 = 0;
	R2 = R1;
	useshh = asi64(R2);
	iscomplex = asi64(R1);
	goto L4034;
L4033:
	asu64(R1) = p;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4037;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4040;
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4039;
L4040:
	R1 = 1;
	iscomplex = asi64(R1);
	goto L4035;
L4039:
	goto L4036;
L4037:
	asu64(R1) = p;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4041;
	R1 = 1;
	R2 = R1;
	useshh = asi64(R2);
	iscomplex = asi64(R1);
	goto L4035;
L4041:
L4036:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4034:
	asu64(R1) = p;
	if (asu64(R1)) goto L4033;
L4035:
	asi64(R1) = iscomplex;
	if (asi64(R1)) goto L4043;
	asu64(R1) = tk;
	goto L4032;
L4043:
	asu64(R1) = m;
	R2 = (u64)&newmacro;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = macrostack;
	R2 = (u64)&newmacro;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = useshh;
	if (!asi64(R1)) goto L4045;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asu64(R5) = m;
	asu64(R1) = cc_lex_substituteargs(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	repl = asu64(R1);
	goto L4044;
L4045:
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	repl = asu64(R1);
L4044:
	R1 = (u64)&expanded;
	R2 = (u64)&newmacro;
	asu64(R3) = repl;
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	tk = asu64(R1);
	asu64(R1) = tk;
	goto L4032;
L4032:
	return asu64(R1);
}

static u64 cc_lex_expandfnmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel, u64 endlineno) {
    u64 R1, R2, R3, R4, R5; 
	struct $B73 args;
	struct $B73 expargs;
	u64 repl;
	u64 tk;
	struct $B17 newmacro;
	i64 nargs;
	i64 i;
	i64 expanded;
	asu64(R1) = tksource;
	R2 = (u64)&args;
	asu64(R3) = m;
	asi64(R1) = cc_lex_readmacrocall(asu64(R3), asu64(R2), asu64(R1));
	nargs = asi64(R1);
	asi64(R1) = frombaselevel;
	if (!asi64(R1)) goto L4048;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = endlineno;
	*toi64p(R2) = asi64(R1);
L4048:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4051;
L4049:
	R1 = 0;
	R2 = (u64)&expargs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nargs) goto L4049;
L4051:
	asu64(R1) = macrostack;
	asi64(R2) = nargs;
	R3 = (u64)&expargs;
	R4 = (u64)&args;
	asu64(R5) = m;
	asu64(R1) = cc_lex_substituteargs(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	repl = asu64(R1);
	asu64(R1) = m;
	R2 = (u64)&newmacro;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = macrostack;
	R2 = (u64)&newmacro;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&expanded;
	R2 = (u64)&newmacro;
	asu64(R3) = repl;
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	repl = asu64(R1);
	asu64(R1) = repl;
	goto L4046;
L4046:
	return asu64(R1);
}

static u64 cc_lex_scantokenseq(u64 tk, u64 macrostack, u64 expanded) {
    u64 R1, R2, R3, R4, R5; 
	u64 newtk;
	u64 newtkx;
	u64 expandtk;
	u64 oldtk;
	u64 m;
	struct $B17 newmacro;
	i64 noexpandflag;
	i64 simple;
	i64 dummy;
// cc_lex.scantokenseq.reenter:
L4053:
	R1 = 0;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = R1;
	newtkx = asu64(R2);
	newtk = asu64(R1);
	R1 = 0;
	noexpandflag = asi64(R1);
	R1 = 1;
	simple = asi64(R1);
	asu64(R1) = tk;
	oldtk = asu64(R1);
	goto L4055;
L4054:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4058;
	goto L4059;
L4058:
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4062;
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4061;
L4062:
	R1 = 0;
	simple = asi64(R1);
	goto L4056;
L4061:
	goto L4057;
L4059:
L4057:
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4064;
	goto L4056;
L4064:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L4055:
	asu64(R1) = tk;
	if (asu64(R1)) goto L4054;
L4056:
	asi64(R1) = simple;
	if (!asi64(R1)) goto L4066;
	asu64(R1) = oldtk;
	goto L4052;
L4066:
	asu64(R1) = oldtk;
	tk = asu64(R1);
	goto L4068;
L4067:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4071;
	goto L4072;
L4071:
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4074;
	asi64(R1) = noexpandflag;
	if (asi64(R1)) goto L4074;
	asu64(R1) = tk;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4077;
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L4076;
L4077:
	goto L4078;
L4076:
	asu64(R1) = macrostack;
	asu64(R2) = m;
	asi64(R1) = cc_lex_inmacrostack(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4080;
	asu64(R1) = tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	asu64(R2) = newtkx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	goto L4081;
L4080:
	R1 = 0;
	simple = asi64(R1);
	asu64(R1) = m;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4083;
	asu64(R1) = tk;
	asi64(R1) = cc_lex_peektk(asu64(R1));
	if (asi64(R1)) goto L4085;
	goto L4078;
L4085:
	R1 = (u64)&tk;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&dummy;
	R2 = 1;
	R3 = (u64)&tk;
	asu64(R4) = macrostack;
	asu64(R5) = m;
	asu64(R1) = cc_lex_expandfnmacro(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	expandtk = asu64(R1);
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	goto L4068;
	goto L4082;
L4083:
	R1 = 0;
	R2 = (u64)&tk;
	asu64(R3) = macrostack;
	asu64(R4) = m;
	asu64(R1) = cc_lex_expandobjmacro(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	expandtk = asu64(R1);
	R1 = 1;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
L4082:
	goto L4073;
L4074:
	asu64(R1) = m;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 93;
	if (asi64(R1) != asi64(R2)) goto L4086;
	R1 = 1;
	noexpandflag = asi64(R1);
	goto L4078;
	goto L4073;
L4086:
	asu64(R1) = m;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4087;
	asu64(R1) = cc_lex_alloctokenz();
	expandtk = asu64(R1);
	asi64(R1) = cc_decls_slineno;
	asu64(R2) = expandtk;
	asu64(R3) = m;
	R4 = 100;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	cc_lex_expandpredefmacro(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	goto L4088;
	goto L4073;
L4087:
	R1 = 0;
	noexpandflag = asi64(R1);
	goto L4078;
L4073:
	goto L4070;
L4072:
// cc_lex.scantokenseq.simpletoken:
L4078:
	asu64(R1) = tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
L4070:
// cc_lex.scantokenseq.skip:
L4081:
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4090;
	goto L4069;
L4090:
// cc_lex.scantokenseq.skip2:
L4088:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L4068:
	asu64(R1) = tk;
	if (asu64(R1)) goto L4067;
L4069:
	asu64(R1) = expanded;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L4092;
	asu64(R1) = newtk;
	tk = asu64(R1);
	goto L4053;
L4092:
	asu64(R1) = newtk;
	goto L4052;
L4052:
	return asu64(R1);
}

static i64 cc_lex_readmacrocall(u64 d, u64 args, u64 tksource) {
    u64 R1, R2, R3; 
	i64 nparams;
	i64 lbcount;
	i64 paramno;
	i64 nargs;
	i64 usesvargs;
	i64 varg;
	u64 tklist;
	u64 tklistx;
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4095;
	R1 = tou64("rmc: no '('");
	cc_lex_lxerror(asu64(R1));
L4095:
	asu64(R1) = d;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nparams = asi64(R1);
	R1 = 0;
	nargs = asi64(R1);
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4097;
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4099;
	R1 = tou64("rmc: ')' expected");
	cc_lex_lxerror(asu64(R1));
L4099:
	R1 = 0;
	goto L4093;
L4097:
	R1 = 1;
	paramno = asi64(R1);
	R1 = 1;
	lbcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	usesvargs = asi64(R1);
	R1 = 0;
	varg = asi64(R1);
L4100:
	asi64(R1) = paramno;
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L4103;
	asi64(R1) = usesvargs;
	if (!asi64(R1)) goto L4103;
	R1 = 1;
	varg = asi64(R1);
L4103:
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4105;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4106;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4107;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4108;
	goto L4109;
L4105:
	asi64(R1) = lbcount;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4111;
	asi64(R1) = varg;
	if (asi64(R1)) goto L4111;
	asu64(R1) = tklist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4113;
	asu64(R1) = cc_lex_alloctokenz();
	tklist = asu64(R1);
	asi64(R1) = cc_lex_getfileno();
	asu64(R2) = tklist;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	R1 = 66;
	asu64(R2) = tklist;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4113:
	asu64(R1) = tklist;
	asu64(R2) = args;
	asi64(R3) = paramno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	R1 = (u64)&paramno;
	(*toi64p(R1)) += 1;
	goto L4110;
L4111:
	goto L4114;
L4110:
	goto L4104;
L4106:
	R1 = tou64("EOS in macro call");
	cc_lex_lxerror(asu64(R1));
	goto L4104;
L4107:
	R1 = (u64)&lbcount;
	(*toi64p(R1)) += 1;
	goto L4114;
	goto L4104;
L4108:
	asi64(R1) = lbcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4116;
	R1 = (u64)&lbcount;
	(*toi64p(R1)) -=1;
	R1 = (u64)&tklistx;
	R2 = (u64)&tklist;
	cc_lex_addlist_nextlx(asu64(R2), asu64(R1));
	goto L4115;
L4116:
	asu64(R1) = tklist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4118;
	asu64(R1) = cc_lex_alloctokenz();
	tklist = asu64(R1);
	asi64(R1) = cc_lex_getfileno();
	asu64(R2) = tklist;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	R1 = 66;
	asu64(R2) = tklist;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4118:
	asu64(R1) = tklist;
	asu64(R2) = args;
	asi64(R3) = paramno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4101;
L4115:
	goto L4104;
L4109:
// cc_lex.readmacrocall.addtoken:
L4114:
	R1 = (u64)&tklistx;
	R2 = (u64)&tklist;
	cc_lex_addlist_nextlx(asu64(R2), asu64(R1));
L4104:
	goto L4100;
L4101:
	asi64(R1) = paramno;
	asi64(R2) = nparams;
	if (asi64(R1) == asi64(R2)) goto L4120;
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L4122;
	asi64(R1) = usesvargs;
	if (!asi64(R1)) goto L4122;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4121;
L4122:
	R1 = tou64("Wrong # macro params");
	cc_lex_lxerror(asu64(R1));
L4121:
L4120:
	asi64(R1) = nparams;
	goto L4093;
L4093:
	return asi64(R1);
}

static u64 cc_lex_substituteargs(u64 m, u64 args, u64 expargs, i64 nargs, u64 macrostack) {
    u64 R1, R2, R3, R4; 
	u64 params;
	u64 seq;
	u64 seqstart;
	u64 lasttoken;
	u64 newtk;
	u64 newtkx;
	u64 niltk;
	u64 tkexp;
	struct $B17 tk;
	i64 n;
	i64 i;
	i64 expanded;
	struct $B81 hhpoints;
	i64 nhashhash;
	asu64(R1) = m;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	params = asu64(R1);
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	seqstart = asu64(R2);
	seq = asu64(R1);
	R1 = 0;
	R2 = R1;
	newtkx = asu64(R2);
	newtk = asu64(R1);
	R1 = 0;
	nhashhash = asi64(R1);
	R1 = 0;
	lasttoken = asu64(R1);
	goto L4125;
L4124:
	asu64(R1) = seq;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4128;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4129;
	goto L4130;
L4128:
	asi64(R1) = nargs;
	if (!asi64(R1)) goto L4132;
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
	asu64(R1) = seq;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4134;
	R1 = tou64("# at end");
	cc_lex_lxerror(asu64(R1));
L4134:
	asu64(R1) = seq;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4136;
	R1 = tou64("# not followed by param");
	cc_lex_lxerror(asu64(R1));
L4136:
	asu64(R1) = seq;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	R1 = (u64)&tk;
	asu64(R2) = args;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	cc_lex_stringify(asu64(R2), asu64(R1));
	R1 = (u64)&tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	goto L4131;
L4132:
	asu64(R1) = seq;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken(asu64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = newtkx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4131:
	goto L4127;
L4129:
	asu64(R1) = seq;
	asu64(R2) = seqstart;
	if (asu64(R1) != asu64(R2)) goto L4138;
	R1 = tou64("## at start");
	cc_lex_lxerror(asu64(R1));
L4138:
	asi64(R1) = nhashhash;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L4140;
	R1 = tou64("Too many ##");
	cc_lex_lxerror(asu64(R1));
L4140:
	asu64(R1) = newtkx;
	R2 = (u64)&hhpoints;
	R3 = (u64)&nhashhash;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4127;
L4130:
	asu64(R1) = seq;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4142;
	asu64(R1) = seq;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4142;
	asi64(R1) = nargs;
	if (!asi64(R1)) goto L4142;
	asu64(R1) = seq;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4146;
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4145;
L4146:
	asu64(R1) = lasttoken;
	if (!asu64(R1)) goto L4144;
	asu64(R1) = lasttoken;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4144;
L4145:
	asu64(R1) = args;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
	goto L4143;
L4144:
	asu64(R1) = expargs;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	tkexp = asu64(R1);
	asu64(R1) = tkexp;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4148;
	R1 = (u64)&expanded;
	asu64(R2) = macrostack;
	asu64(R3) = args;
	asi64(R4) = n;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	asu64(R3) = expargs;
	asi64(R4) = n;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	tkexp = asu64(R1);
L4148:
	asu64(R1) = tkexp;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
L4143:
	goto L4141;
L4142:
// cc_lex.substituteargs.doother:
	asu64(R1) = seq;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
L4141:
L4127:
	asu64(R1) = seq;
	lasttoken = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L4125:
	asu64(R1) = seq;
	if (asu64(R1)) goto L4124;
	asi64(R1) = nhashhash;
	if (!asi64(R1)) goto L4151;
	R1 = 0;
	niltk = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nhashhash;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4154;
L4152:
	asi64(R1) = i;
	asi64(R2) = nhashhash;
	if (asi64(R1) >= asi64(R2)) goto L4156;
	R1 = (u64)&hhpoints;
	asi64(R2) = i;
	R1 += (i64)R2*8;
	goto L4155;
L4156:
	R1 = (u64)&niltk;
L4155:
	R2 = (u64)&hhpoints;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	cc_lex_pastetokens(asu64(R2), asu64(R1));
	i += 1; if (i <= nhashhash) goto L4152;
L4154:
L4151:
	asu64(R1) = newtk;
	goto L4123;
L4123:
	return asu64(R1);
}

static u64 cc_lex_strtoken(u64 lp, u64 length) {
    u64 R1, R2, R3, R4, R5; struct $B17 R1_B17; 
	u64 name;
	u64 s;
	struct $B17 l;
	asu64(R1) = lp;
	(R1_B17) = *(struct $B17*)(R1);
	l = (R1_B17);
	R1 = (u64)&l;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4159;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L4160;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L4160;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4161;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L4162;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L4162;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L4163;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4164;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4165;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L4166;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4166;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4166;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L4166;
	goto L4167;
L4159:
// cc_lex.strtoken.doname:
L4168:
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4157;
	goto L4158;
L4160:
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	if (!asi64(R1)) goto L4170;
	R1 = (u64)&cc_decls_sourcefiletext;
	R2 = (u64)&l;
	asi64(R2) = cc_lex_getfilenox(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&l;
	asi64(R2) = cc_lex_getnumberoffsetx(asu64(R2));
	R1 += (i64)R2;
	goto L4157;
	goto L4169;
L4170:
	R1 = (u64)&cc_lex_pastedtokenlist;
	R2 = (u64)&l;
	R3 = 28;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L4157;
L4169:
	goto L4158;
L4161:
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4157;
	goto L4158;
L4162:
	R1 = 34;
	asu64(R2) = length;
	R3 = (u64)&l;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&l;
	R5 = 0;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = cc_lex_strstring(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	goto L4157;
	goto L4158;
L4163:
	R1 = 39;
	asu64(R2) = length;
	R3 = (u64)&l;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&l;
	R5 = 0;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = cc_lex_strstring(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	goto L4157;
	goto L4158;
L4164:
	asi64(R1) = cc_lex_dowhitespace;
	if (!asi64(R1)) goto L4172;
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = length;
	asi64(R1) = *toi64p(R1);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	R1 = 10;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	R4 = 1;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L4171;
L4172:
	R1 = 1;
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = tou64("\n");
	goto L4157;
L4171:
	asu64(R1) = s;
	goto L4157;
	goto L4158;
L4165:
	R1 = 0;
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = tou64("");
	goto L4157;
	goto L4158;
L4166:
	goto L4168;
	goto L4158;
L4167:
	R1 = (u64)&cc_tables_shortsymbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	asu64(R3) = length;
	*toi64p(R3) = asi64(R2);
	if (!asi64(R1)) goto L4174;
	asu64(R1) = name;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L4176;
	asu64(R1) = name;
	goto L4157;
	goto L4175;
L4176:
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2;
	goto L4157;
L4175:
	goto L4173;
L4174:
	R1 = tou64("");
	goto L4157;
L4173:
L4158:
	R1 = tou64("");
	goto L4157;
L4157:
	return asu64(R1);
}

static u64 cc_lex_strstring(u64 s, i64 length, u64 newlength, i64 quotechar) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 4;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	asi64(R1) = quotechar;
	if (!asi64(R1)) goto L4179;
	asi64(R1) = quotechar;
	asu64(R2) = u;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&u;
	(*tou64p(R1)) += 1;
L4179:
	asi64(R1) = length;
	asu64(R2) = u;
	asu64(R3) = s;
	asi64(R1) = cc_lib_convertstringc(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = newlength;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = quotechar;
	if (!asi64(R1)) goto L4181;
	asi64(R1) = quotechar;
	asu64(R2) = t;
	asu64(R3) = newlength;
	asi64(R3) = *toi64p(R3);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newlength;
	(*toi64p(R1)) += 1;
L4181:
	asu64(R1) = t;
	goto L4177;
L4177:
	return asu64(R1);
}

static void cc_lex_emittoken(u64 lp, u64 dest, i64 forcespace) {
    u64 R1, R2, R3; 
	i64 length;
	u64 s;
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L4184;
	asi64(R1) = cc_lex_lasttoken;
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L4184;
	goto L4182;
L4184:
	R1 = (u64)&length;
	asu64(R2) = lp;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = forcespace;
	if (asi64(R1)) goto L4187;
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = cc_lex_lasttoken;
	asi64(R1) = cc_lex_needspace(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L4186;
L4187:
	R1 = 32;
	asu64(R2) = dest;
	mlib_gs_char(asu64(R2), asi64(R1));
L4186:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_gs_strn(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_lex_lasttoken = asi64(R1);
L4182:
	return;
}

static void cc_lex_showtoken(u64 lp) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_showtoken_dest = (u64)&cc_lex_showtoken_buffer;
	asu64(R1) = cc_lex_showtoken_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	asu64(R2) = cc_lex_showtoken_dest;
	asu64(R3) = lp;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("v");
	asu64(R2) = cc_lex_showtoken_dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = cc_lex_showtoken_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static void cc_lex_stringify(u64 seq, u64 dest) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	i64 addspace;
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_stringify_deststr = (u64)&cc_lex_stringify_buffer;
	R1 = 63;
	asu64(R2) = dest;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4191;
	R1 = (u64)&length;
	asu64(R2) = seq;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4189;
L4191:
	asu64(R1) = cc_lex_stringify_deststr;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	cc_lex_lasttoken = asi64(R1);
	R1 = 0;
	addspace = asi64(R1);
	goto L4193;
L4192:
	asi64(R1) = addspace;
	asu64(R2) = cc_lex_stringify_deststr;
	asu64(R3) = seq;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	addspace = asi64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L4193:
	asu64(R1) = seq;
	if (asu64(R1)) goto L4192;
	asi64(R1) = length;
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_stringify_deststr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = cc_lex_stringify_deststr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4189:
	return;
}

static void cc_lex_pastetokens(u64 tk, u64 tknext) {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	u64 tk2;
	i64 length1;
	i64 length2;
	u64 s;
	u64 t;
	u64 u;
	struct $B17 oldtoken;
	struct $B17 token;
	u64 oldlxsptr;
	i64 oldlx_stackindex;
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk2 = asu64(R1);
	asu64(R1) = tk2;
	asu64(R2) = tknext;
	asu64(R2) = *tou64p(R2);
	if (asu64(R1) != asu64(R2)) goto L4197;
	asu64(R1) = tk;
	asu64(R2) = tknext;
	*tou64p(R2) = asu64(R1);
L4197:
	asu64(R1) = tk2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L4199;
	asu64(R1) = tk2;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L4201;
	goto L4200;
L4201:
	asu64(R1) = tk2;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
L4200:
	goto L4198;
L4199:
	asu64(R1) = tk2;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L4202;
	goto L4198;
L4202:
	R1 = (u64)&length1;
	asu64(R2) = tk;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	R1 = (u64)&length2;
	asu64(R2) = tk2;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	t = asu64(R1);
	asi64(R1) = length1;
	asi64(R2) = length2;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
	asi64(R1) = length1;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length2;
	asu64(R2) = t;
	asu64(R3) = u;
	asi64(R4) = length1;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = u;
	asi64(R3) = length1;
	R2 += (i64)R3;
	asi64(R3) = length2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_lex_npastedtokens;
	R2 = 87000;
	if (asi64(R1) < asi64(R2)) goto L4204;
	R1 = tou64("Too many pasted tokens");
	cc_lex_lxerror(asu64(R1));
L4204:
	asu64(R1) = u;
	R2 = (u64)&cc_lex_pastedtokenlist;
	R3 = (u64)&cc_lex_npastedtokens;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	(R1_B17) = cc_decls_nextlx;
	oldtoken = (R1_B17);
	asu64(R1) = cc_lex_lxsptr;
	oldlxsptr = asu64(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	oldlx_stackindex = asi64(R1);
	asu64(R1) = u;
	cc_lex_lxsptr = asu64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_setfileno(asi64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	cc_lex_lexreadtoken();
	(R1_B17) = cc_decls_nextlx;
	token = (R1_B17);
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4206;
L4206:
	(R1_B17) = oldtoken;
	cc_decls_nextlx = (R1_B17);
	asu64(R1) = oldlxsptr;
	cc_lex_lxsptr = asu64(R1);
	asi64(R1) = oldlx_stackindex;
	cc_lex_lx_stackindex = asi64(R1);
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&token;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&token;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	asi64(R1) = cc_lex_npastedtokens;
	R2 = (u64)&token;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 8;
	R2 = (u64)&token;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	(R1_B17) = token;
	asu64(R2) = tk;
	*(struct $B17*)(R2) = (R1_B17);
L4198:
	return;
}

static i64 cc_lex_getifexpr() {
    u64 R1, R2; 
	i64 sx;
	i64 x;
	cc_lex_lexm();
	R1 = (u64)&sx;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	x = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4209;
	R1 = tou64("#if:eol expected");
	cc_lex_lxerror(asu64(R1));
L4209:
	asi64(R1) = x;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L4207;
L4207:
	return asi64(R1);
}

static i64 cc_lex_evalcondexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 z;
	i64 sy;
	i64 sz;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalorexpr(asu64(R1));
	x = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4212;
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	y = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4214;
	R1 = tou64(": expected");
	cc_lex_lxerror(asu64(R1));
L4214:
	cc_lex_lexm();
	R1 = (u64)&sz;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	z = asi64(R1);
	asi64(R1) = x;
	if (!asi64(R1)) goto L4216;
	asi64(R1) = sy;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = y;
	x = asi64(R1);
	goto L4215;
L4216:
	asi64(R1) = sz;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = z;
	x = asi64(R1);
L4215:
L4212:
	asi64(R1) = x;
	goto L4210;
L4210:
	return asi64(R1);
}

static i64 cc_lex_evalorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalandexpr(asu64(R1));
	x = asi64(R1);
	goto L4219;
L4218:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalandexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L4223;
	asi64(R1) = y;
	if (!asi64(R1)) goto L4222;
L4223:
	R1 = 1;
	goto L4221;
L4222:
	R1 = 0;
L4221:
	x = asi64(R1);
L4219:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L4218;
	asi64(R1) = x;
	goto L4217;
L4217:
	return asi64(R1);
}

static i64 cc_lex_evalandexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaliorexpr(asu64(R1));
	x = asi64(R1);
	goto L4226;
L4225:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaliorexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (!asi64(R1)) goto L4229;
	asi64(R1) = y;
	if (!asi64(R1)) goto L4229;
	R1 = 1;
	goto L4228;
L4229:
	R1 = 0;
L4228:
	x = asi64(R1);
L4226:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4225;
	asi64(R1) = x;
	goto L4224;
L4224:
	return asi64(R1);
}

static i64 cc_lex_evaliorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalixorexpr(asu64(R1));
	x = asi64(R1);
	goto L4232;
L4231:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalixorexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) |= asi64(R1);
L4232:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L4231;
	asi64(R1) = x;
	goto L4230;
L4230:
	return asi64(R1);
}

static i64 cc_lex_evalixorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaliandexpr(asu64(R1));
	x = asi64(R1);
	goto L4236;
L4235:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaliandexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
L4236:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L4235;
	asi64(R1) = x;
	goto L4234;
L4234:
	return asi64(R1);
}

static i64 cc_lex_evaliandexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaleqexpr(asu64(R1));
	x = asi64(R1);
	goto L4240;
L4239:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaleqexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) &= asi64(R1);
L4240:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L4239;
	asi64(R1) = x;
	goto L4238;
L4238:
	return asi64(R1);
}

static i64 cc_lex_evaleqexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalcmpexpr(asu64(R1));
	x = asi64(R1);
	goto L4244;
L4243:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalcmpexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4247;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4248;
	goto L4249;
L4247:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	x = asi64(R1);
	goto L4246;
L4248:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	x = asi64(R1);
	goto L4246;
L4249:
L4246:
L4244:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4243;
	asi64(R1) = opc;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4243;
	asi64(R1) = x;
	goto L4242;
L4242:
	return asi64(R1);
}

static i64 cc_lex_evalcmpexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalshiftexpr(asu64(R1));
	x = asi64(R1);
	goto L4252;
L4251:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalshiftexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4255;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4256;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4257;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4258;
	goto L4259;
L4255:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	x = asi64(R1);
	goto L4254;
L4256:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	x = asi64(R1);
	goto L4254;
L4257:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	x = asi64(R1);
	goto L4254;
L4258:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	x = asi64(R1);
	goto L4254;
L4259:
L4254:
L4252:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4251;
	asi64(R1) = opc;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4251;
	asi64(R1) = opc;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4251;
	asi64(R1) = opc;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4251;
	asi64(R1) = x;
	goto L4250;
L4250:
	return asi64(R1);
}

static i64 cc_lex_evalshiftexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaladdexpr(asu64(R1));
	x = asi64(R1);
	goto L4262;
L4261:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaladdexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L4265;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4266;
	goto L4267;
L4265:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) >>= asi64(R2);
	x = asi64(R1);
	goto L4264;
L4266:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) <<= asi64(R2);
	x = asi64(R1);
	goto L4264;
L4267:
L4264:
L4262:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4261;
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L4261;
	asi64(R1) = x;
	goto L4260;
L4260:
	return asi64(R1);
}

static i64 cc_lex_evaladdexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalmulexpr(asu64(R1));
	x = asi64(R1);
	goto L4270;
L4269:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalmulexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4273;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4274;
	goto L4275;
L4273:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) += asi64(R1);
	goto L4272;
L4274:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) -= asi64(R1);
	goto L4272;
L4275:
L4272:
L4270:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4269;
	asi64(R1) = opc;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4269;
	asi64(R1) = x;
	goto L4268;
L4268:
	return asi64(R1);
}

static i64 cc_lex_evalmulexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	x = asi64(R1);
	goto L4278;
L4277:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4281;
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4281;
	R1 = tou64("#if:div by zero");
	cc_lex_lxerror(asu64(R1));
L4281:
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4283;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4284;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L4285;
	goto L4286;
L4283:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) *= asi64(R1);
	goto L4282;
L4284:
	asi64(R1) = x;
	asi64(R2) = y;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	x = asi64(R1);
	goto L4282;
L4285:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) %= asi64(R2);
	x = asi64(R1);
	goto L4282;
L4286:
L4282:
L4278:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4277;
	asi64(R1) = opc;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4277;
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L4277;
	asi64(R1) = x;
	goto L4276;
L4276:
	return asi64(R1);
}

static i64 cc_lex_evalunaryexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 opc;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4289;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4289;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L4289;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L4289;
	goto L4290;
L4289:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lexm();
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	x = asi64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4292;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4293;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L4294;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L4295;
	goto L4296;
L4292:
	asi64(R1) = x;
	goto L4287;
	goto L4291;
L4293:
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L4287;
	goto L4291;
L4294:
	asi64(R1) = x;
	asi64(R1) = !asi64(R1);
	goto L4287;
	goto L4291;
L4295:
	asi64(R1) = x;
	asi64(R1) = ~asi64(R1);
	goto L4287;
	goto L4291;
L4296:
L4291:
	goto L4288;
L4290:
L4288:
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalterm(asu64(R1));
	goto L4287;
L4287:
	return asi64(R1);
}

static i64 cc_lex_evalterm(u64 sx) {
    u64 R1, R2, R3, R4; 
	i64 res;
	i64 lb;
	R1 = 1;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4299;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L4300;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L4301;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4302;
	goto L4303;
L4299:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 93;
	if (asi64(R1) == asi64(R2)) goto L4305;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L4306;
	goto L4307;
L4305:
	R1 = 1;
	cc_lex_noexpand = asi64(R1);
	R1 = 0;
	lb = asi64(R1);
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4309;
	R1 = 1;
	lb = asi64(R1);
	cc_lex_lexm();
L4309:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4311;
	R1 = tou64("defined?");
	cc_lex_lxerror(asu64(R1));
L4311:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	res = asi64(R1);
	cc_lex_lexm();
	asi64(R1) = lb;
	if (!asi64(R1)) goto L4313;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4315;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L4315:
	cc_lex_lexm();
L4313:
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	goto L4304;
L4306:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4317;
	R1 = tou64("'(' expected");
	cc_lex_lxerror(asu64(R1));
L4317:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4319;
	R1 = tou64("name expected");
	cc_lex_lxerror(asu64(R1));
L4319:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L4321;
	goto L4322;
L4321:
	R1 = (u64)&cc_tables_typespecsizes;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 100;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	res = asi64(R1);
	goto L4320;
L4322:
	R1 = tou64("sizeof2");
	cc_lex_lxerror(asu64(R1));
L4320:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4324;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L4324:
	cc_lex_lexm();
	goto L4304;
L4307:
	cc_lex_lexm();
	R1 = 0;
	goto L4297;
L4304:
	goto L4298;
L4300:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	res = asi64(R1);
	cc_lex_lexm();
	goto L4298;
L4301:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4326;
	R1 = 0;
	res = asi64(R1);
	goto L4325;
L4326:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	res = asi64(R1);
L4325:
	cc_lex_lexm();
	goto L4298;
L4302:
	cc_lex_lexm();
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	res = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4328;
	R1 = tou64(") expected");
	cc_lex_lxerror(asu64(R1));
L4328:
	cc_lex_lexm();
	goto L4298;
L4303:
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_printsymbol(asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("evalterm?");
	cc_lex_lxerror(asu64(R1));
L4298:
	asi64(R1) = res;
	goto L4297;
L4297:
	return asi64(R1);
}

static i64 cc_lex_getifdef() {
    u64 R1, R2; 
	i64 res;
	u64 d;
	R1 = 1;
	cc_lex_noexpand = asi64(R1);
	cc_lex_lexreadtoken();
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4331;
	R1 = tou64("Name expected");
	cc_lex_lxerror(asu64(R1));
L4331:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	res = asi64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4333;
	R1 = 1;
	res = asi64(R1);
	goto L4332;
L4333:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4334;
	R1 = 1;
	res = asi64(R1);
L4334:
L4332:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4336;
	R1 = tou64("EOL expected");
	cc_lex_lxerror(asu64(R1));
L4336:
	asi64(R1) = res;
	goto L4329;
L4329:
	return asi64(R1);
}

static i64 cc_lex_skipcode() {
    u64 R1, R2; 
	i64 level;
	i64 dir;
	u64 pp;
	R1 = 0;
	level = asi64(R1);
L4338:
	cc_lex_fastreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4341;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4342;
	goto L4343;
L4341:
	asi64(R1) = cc_lex_getlexdirective();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4345;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4345;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4345;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4346;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4346;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4347;
	goto L4348;
L4345:
	R1 = (u64)&level;
	(*toi64p(R1)) += 1;
	goto L4344;
L4346:
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4350;
	asi64(R1) = dir;
	goto L4337;
L4350:
	goto L4344;
L4347:
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4352;
	asi64(R1) = dir;
	goto L4337;
L4352:
	R1 = (u64)&level;
	(*toi64p(R1)) -=1;
	goto L4344;
L4348:
L4344:
	goto L4340;
L4342:
	R1 = tou64("#if:Unexpected eof");
	cc_lex_lxerror(asu64(R1));
	goto L4340;
L4343:
L4340:
	goto L4338;
	R1 = 0;
	goto L4337;
L4337:
	return asi64(R1);
}

static void cc_lex_freetokens(u64 tk) {
    u64 R1, R2; 
	u64 nexttk;
	goto L4355;
L4354:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nexttk = asu64(R1);
	asu64(R1) = nexttk;
	tk = asu64(R1);
L4355:
	asu64(R1) = tk;
	if (asu64(R1)) goto L4354;
	return;
}

static void cc_lex_fastreadtoken() {
    u64 R1, R2, R3; 
	i64 c;
	i64 csum;
	i64 hsum;
	i64 commentseen;
	i64 dodir;
	i64 j;
	u64 pstart;
	u64 p;
	u64 ss;
L4358:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 0: goto L4383;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: goto L4361;
	case 10: goto L4382;
	case 12: goto L4386;
	case 13: goto L4381;
	case 34: goto L4380;
	case 35: goto L4362;
	case 39: goto L4379;
	case 47: goto L4374;
	default: goto L4361;
    };
// SWITCH
L4362:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	dodir = asi64(R1);
	goto L4364;
L4363:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L4367;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L4368;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L4368;
	goto L4369;
L4367:
	R1 = 1;
	dodir = asi64(R1);
	goto L4365;
	goto L4366;
L4368:
	goto L4366;
L4369:
	goto L4365;
L4366:
	R1 = (u64)&p;
	(*tou64p(R1)) -=1;
L4364:
	asu64(R1) = p;
	asu64(R2) = cc_lex_lxstart;
	if (asu64(R1) >= asu64(R2)) goto L4363;
L4365:
	asi64(R1) = dodir;
	if (asi64(R1)) goto L4372;
	asu64(R1) = p;
	asu64(R2) = cc_lex_lxstart;
	if (asu64(R1) >= asu64(R2)) goto L4371;
L4372:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4357;
	goto L4370;
L4371:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) != asu64(R2)) goto L4373;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L4373:
L4370:
	goto L4358;
L4374:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L4376;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L4377;
	goto L4378;
L4376:
	cc_lex_readlinecomment();
	goto L4375;
L4377:
	cc_lex_readblockcomment();
	goto L4375;
L4378:
L4375:
	goto L4358;
L4379:
	R1 = 0;
	R2 = 39;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L4358;
L4380:
	R1 = 0;
	R2 = 34;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L4358;
L4381:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L4358;
L4382:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4358;
L4383:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = cc_lex_lx_stackindex;
	if (!asi64(R1)) goto L4385;
	cc_lex_unstacksourcefile();
	goto L4384;
L4385:
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4357;
L4384:
	goto L4358;
L4386:
	goto L4358;
L4361:
	goto L4358;
L4357:
	return;
}

static u64 cc_lex_alloctoken() {
    u64 R1; 
	u64 tk;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	tk = asu64(R1);
	asu64(R1) = tk;
	goto L4387;
L4387:
	return asu64(R1);
}

static u64 cc_lex_alloctokenz() {
    u64 R1, R2, R3; 
	u64 tk;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	tk = asu64(R1);
	R1 = 0;
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	goto L4388;
L4388:
	return asu64(R1);
}

static void cc_lex_expandpredefmacro(i64 pdmcode, u64 tk, i64 lineno) {
    u64 R1, R2, R3; 
	struct $B16 str;
	struct $B3 tm;
	u64 s;
	i64 fileno;
// PROC LOCAL STATICS GO HERE
	static struct $B28 cc_lex_expandpredefmacro_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L4391;
	goto L4389;
L4391:
	asi64(R1) = pdmcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4393;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4394;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4395;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4396;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4397;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4398;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4399;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4400;
	goto L4401;
L4393:
	R1 = (u64)&tm;
	mnoos_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_lex_expandpredefmacro_monthnames;
	R2 = (u64)&tm;
	R3 = 2;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4392;
L4394:
	R1 = (u64)&tm;
	mnoos_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("2");
	R2 = (u64)&tm;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 10;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 12;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4392;
L4395:
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = tk;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4403;
	asi64(R1) = cc_decls_sfileno;
	fileno = asi64(R1);
L4403:
	asi64(R1) = cc_decls_sfileno;
	if (!asi64(R1)) goto L4405;
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = cc_decls_sfileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4404;
L4405:
	R1 = tou64("(File not available)");
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4404:
	goto L4392;
L4396:
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L4407;
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4406;
L4407:
	R1 = tou64("???");
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4406:
	goto L4392;
L4397:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = lineno;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4392;
L4398:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4392;
L4399:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4392;
L4400:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu8(R1) = cc_decls_pci_target;
	R1 = toi64(tou8(R1));
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4392;
L4401:
	msysc_m$print_startcon();
	asi64(R1) = pdmcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PDM");
	cc_lex_lxerror(asu64(R1));
L4392:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L4409;
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = tk;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = tk;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4408;
L4409:
	R1 = 3;
	asu64(R2) = tk;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = tk;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = tk;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_npastedtokens;
	R2 = 87000;
	if (asi64(R1) < asi64(R2)) goto L4411;
	R1 = tou64("2:Too many pasted tokens");
	cc_lex_lxerror(asu64(R1));
L4411:
	asu64(R1) = s;
	R2 = (u64)&cc_lex_pastedtokenlist;
	R3 = (u64)&cc_lex_npastedtokens;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = tk;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	asi64(R1) = cc_lex_npastedtokens;
	asu64(R2) = tk;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4408:
L4389:
	return;
}

static void cc_lex_dopragmadir() {
    u64 R1, R2, R3, R4; 
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4414;
	R1 = 4;
	R2 = tou64("pack");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4416;
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4418;
	R1 = tou64("'(' expected");
	cc_lex_lxerror(asu64(R1));
L4418:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L4420;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4422;
	goto L4423;
L4422:
	R1 = 0;
	cc_decls_structpadding = asi64(R1);
	goto L4421;
L4423:
	goto L4424;
	R1 = tou64("Only pack(1) or () allowed");
	cc_lex_lxerror(asu64(R1));
L4421:
	cc_lex_lexm();
	goto L4419;
L4420:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L4425;
	R1 = 1;
	cc_decls_structpadding = asi64(R1);
L4425:
L4419:
	goto L4415;
L4416:
	R1 = 6;
	R2 = tou64("module");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4426;
	R1 = 77;
	cc_lex_addbuildinfo(asi64(R1));
	goto L4415;
L4426:
	R1 = 6;
	R2 = tou64("header");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4427;
	R1 = 72;
	cc_lex_addbuildinfo(asi64(R1));
	goto L4415;
L4427:
	R1 = 4;
	R2 = tou64("link");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4428;
	R1 = 76;
	cc_lex_addbuildinfo(asi64(R1));
L4428:
L4415:
L4414:
// cc_lex.dopragmadir.finish:
L4424:
	goto L4430;
L4429:
	cc_lex_lexm();
L4430:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4432;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L4429;
L4432:
	return;
}

static void cc_lex_addbuildinfo(i64 code) {
    u64 R1, R2, R3; 
	u64 file;
	i64 j;
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L4435;
	R1 = tou64("Str expected");
	cc_lex_lxerror(asu64(R1));
L4435:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file = asu64(R1);
	asi64(R1) = code;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L4437;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L4438;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L4439;
	goto L4440;
L4437:
	asi64(R1) = cc_decls_npmodules;
	R2 = 199;
	if (asi64(R1) < asi64(R2)) goto L4442;
	R1 = tou64("TMM");
	cc_lex_lxerror(asu64(R1));
L4442:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pmodulelist;
	R3 = (u64)&cc_decls_npmodules;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4436;
L4438:
	asi64(R1) = cc_decls_npheaders;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L4444;
	R1 = tou64("TMH");
	cc_lex_lxerror(asu64(R1));
L4444:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pheaderlist;
	R3 = (u64)&cc_decls_npheaders;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4436;
L4439:
	asi64(R1) = cc_decls_nplibs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L4446;
	R1 = tou64("TMLM");
	cc_lex_lxerror(asu64(R1));
L4446:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pliblist;
	R3 = (u64)&cc_decls_nplibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4436;
L4440:
L4436:
	cc_lex_lexm();
	return;
}

static i64 cc_lex_needspace(i64 a, i64 b) {
    u64 R1, R2; 
	u64 aname;
	u64 bname;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4449;
	R1 = 0;
	goto L4447;
L4449:
	R1 = (u64)&cc_tables_shortsymbolnames;
	asi64(R2) = a;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	aname = asu64(R1);
	R1 = (u64)&cc_tables_shortsymbolnames;
	asi64(R2) = b;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	bname = asu64(R1);
	asu64(R1) = bname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L4451;
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L4451;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L4452;
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L4452;
	goto L4453;
L4451:
	asu64(R1) = aname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L4455;
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L4455;
	goto L4456;
L4455:
	R1 = 1;
	goto L4447;
	goto L4454;
L4456:
L4454:
	goto L4450;
L4452:
	asu64(R1) = aname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L4458;
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L4458;
	goto L4459;
L4458:
	R1 = 1;
	goto L4447;
	goto L4457;
L4459:
L4457:
	goto L4450;
L4453:
L4450:
	R1 = 0;
	goto L4447;
L4447:
	return asi64(R1);
}

static void cc_lex_dospecialinclude() {
    u64 R1, R2; 
	R1 = 1;
	R2 = tou64("mcc.h");
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_dheaderfile;
	if (!asu64(R1)) goto L4462;
	R1 = 1;
	asu64(R2) = cc_decls_dheaderfile;
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
L4462:
	return;
}

static void cc_lex_setnumberoffset(i64 offset) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4278190080;
	asi64(R1) &= asi64(R2);
	asi64(R2) = offset;
	R3 = 16777215;
	asi64(R2) &= asi64(R3);
	asi64(R1) |= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void cc_lex_setfileno(i64 fileno) {
    u64 R1, R2, R3; 
	asi64(R1) = fileno;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asi64(R2) = fileno;
	R3 = 65280;
	asi64(R2) &= asi64(R3);
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void cc_lex_setfilenox(u64 tk, i64 fileno) {
    u64 R1, R2, R3; 
	asi64(R1) = fileno;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	asu64(R2) = tk;
	R3 = 20;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asi64(R2) = fileno;
	R3 = 65280;
	asi64(R2) &= asi64(R3);
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = tk;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 cc_lex_getfileno() {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	asi64(R1) >>= asi64(R2);
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	goto L4466;
L4466:
	return asi64(R1);
}

static i64 cc_lex_getfilenox(u64 tk) {
    u64 R1, R2, R3; 
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	asi64(R1) >>= asi64(R2);
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = tk;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	goto L4467;
L4467:
	return asi64(R1);
}

static i64 cc_lex_getnumberoffsetx(u64 tk) {
    u64 R1, R2; 
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	goto L4468;
L4468:
	return asi64(R1);
}

static void cc_lex_freehashtable() {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	u64 f;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4472;
L4470:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4474;
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4474;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4476;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_freetokens(asu64(R1));
L4476:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L4478;
L4477:
	asu64(R1) = f;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 128;
	asu64(R2) = f;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = e;
	f = asu64(R1);
L4478:
	asu64(R1) = f;
	if (asu64(R1)) goto L4477;
	R1 = 128;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	goto L4473;
L4474:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4480;
	R1 = 0;
	asu64(R2) = d;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4480:
L4473:
	i += 1; if (i <= cc_decls_hstmask) goto L4470;
L4472:
	return;
}

static void cc_lex_regenlookup(u64 d) {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 length;
	u64 e;
	asu64(R1) = d;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	asi64(R2) = cc_decls_hstmask;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L4482:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	length = asi64(R1);
	asi64(R1) = length;
	if (asi64(R1)) goto L4485;
	R1 = 128;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = j;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = d;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_lex_nhstsymbols;
	(*toi64p(R1)) += 1;
	goto L4481;
L4485:
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 106;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L4487;
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = e;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4489;
	R1 = tou64("regenhst dupl?");
	cc_lex_lxerror(asu64(R1));
L4489:
L4487:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = cc_decls_hstsize;
	if (asi64(R1) < asi64(R2)) goto L4491;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L4493;
	R1 = tou64("REGENHST FULL?");
	mlib_abortprogram(asu64(R1));
L4493:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L4491:
	goto L4482;
L4481:
	return;
}

static void cc_lex_newhashtable() {
    u64 R1, R2, R3; 
	u64 oldhashtable;
	i64 oldhstsize;
	u64 d;
	i64 av_1;
	i64 i;
	asu64(R1) = cc_decls_hashtable;
	oldhashtable = asu64(R1);
	asi64(R1) = cc_decls_hstsize;
	oldhstsize = asi64(R1);
	R1 = 2;
	R2 = (u64)&cc_decls_hstsize;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cc_decls_hstmask = asi64(R1);
	R1 = 0;
	cc_lex_nhstsymbols = asi64(R1);
	R1 = 6;
	asi64(R2) = cc_decls_hstsize;
	asi64(R1) *= asi64(R2);
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	cc_lex_hstthreshold = asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_decls_hashtable = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4497;
L4495:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= cc_decls_hstmask) goto L4495;
L4497:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = oldhstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4500;
L4498:
	asu64(R1) = oldhashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4502;
	asu64(R1) = d;
	cc_lex_regenlookup(asu64(R1));
L4502:
	i += 1; if (i <= av_1) goto L4498;
L4500:
	asi64(R1) = oldhstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = oldhashtable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void cc_lex_old_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base) {
    u64 R1, R2, R3, R4; 
	u64 fractstart;
	i64 fractlen;
	i64 expon;
	i64 i;
	i64 c;
	i64 badexpon;
	r64 basex;
	r64 x;
	r64 expbase;
	struct $B80 realstr;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	R1 = 0;
	fractstart = asu64(R1);
	R1 = 0;
	fractlen = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L4505;
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	fractstart = asu64(R1);
	asi64(R1) = base;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = fractstart;
	asi64(R1) -= asi64(R2);
	fractlen = asi64(R1);
L4505:
	R1 = 0;
	badexpon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 101;
	if (asu64(R1) == asu64(R2)) goto L4507;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L4507;
	R2 = 112;
	if (asu64(R1) == asu64(R2)) goto L4508;
	R2 = 80;
	if (asu64(R1) == asu64(R2)) goto L4508;
	goto L4509;
L4507:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4511;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L4511:
	goto L4506;
L4508:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L4513;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L4513:
	goto L4506;
L4509:
L4506:
	asi64(R1) = badexpon;
	if (!asi64(R1)) goto L4515;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L4503;
L4515:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 102;
	if (asu64(R1) == asu64(R2)) goto L4517;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L4517;
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L4517;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L4517;
	goto L4518;
L4517:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L4516;
L4518:
	R1 = (u64)&cc_lex_alphamap;
	asu64(R2) = cc_lex_lxsptr;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4520;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L4503;
L4520:
L4516:
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L4522;
	R1 = tou64("Real too long");
	cc_lex_lxerror(asu64(R1));
L4522:
	asi64(R1) = intlen;
	if (!asi64(R1)) goto L4524;
	asi64(R1) = intlen;
	asu64(R2) = intstart;
	R3 = (u64)&realstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L4524:
	asi64(R1) = fractlen;
	if (!asi64(R1)) goto L4526;
	asi64(R1) = fractlen;
	asu64(R2) = fractstart;
	R3 = (u64)&realstr;
	R4 = 0;
	R3 += (i64)R4;
	asi64(R4) = intlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L4526:
	asi64(R1) = base;
	asr64(R1) = tor64(asi64(R1));
	R2 = R1;
	basex = asr64(R2);
	expbase = asr64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4528;
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	goto L4527;
L4528:
	asi64(R1) = fractlen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 2.000000000000000000e+000;
	expbase = asr64(R1);
L4527:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4531;
L4529:
	R1 = (u64)&realstr;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L4533;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L4533;
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	x = asr64(R1);
	goto L4532;
L4533:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) <= asi64(R2)) goto L4534;
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 97;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) += asr64(R2);
	x = asr64(R1);
	goto L4532;
L4534:
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 65;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) += asr64(R2);
	x = asr64(R1);
L4532:
	i += 1; if (i <= av_1) goto L4529;
L4531:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4536;
	asi64(R1) = expon;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4539;
L4537:
	asr64(R1) = expbase;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_2)) goto L4537;
L4539:
	goto L4535;
L4536:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4542;
L4540:
	asr64(R1) = expbase;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_3)) goto L4540;
L4542:
L4535:
	R1 = 60;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = intstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = intstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4503:
	return;
}

static i64 cc_lex_issimpleconstmacro(u64 m) {
    u64 R1, R2, R3; 
	u64 tk;
	i64 av_1;
	i64 i;
// PROC LOCAL STATICS GO HERE
	static struct $B8 cc_lex_issimpleconstmacro_specialnames = {{
	(u64)"stdin",
	(u64)"stdout",
	(u64)"stderr"    }};
	R1 = 1;
	i = asi64(R1);
	R1 = 3;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4546;
L4544:
	asu64(R1) = m;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_lex_issimpleconstmacro_specialnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4548;
	R1 = 2;
	goto L4543;
L4548:
	i += 1; if (i <= av_1) goto L4544;
L4546:
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
	asu64(R1) = tk;
	if (!asu64(R1)) goto L4550;
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4550;
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L4553;
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) != asi64(R2)) goto L4552;
L4553:
	R1 = 1;
	goto L4543;
L4552:
L4550:
	R1 = 0;
	goto L4543;
L4543:
	return asi64(R1);
}

static void cc_parse_readmodule() {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 linkage;
	i64 m;
	i64 mbase;
	i64 commaseen;
	i64 wasdef;
	u64 p;
	u64 d;
	u64 pm;
	i64 t;
	i64 nitems;
	i64 wasenum;
	i64 exported;
	goto L4556;
L4555:
	R1 = 0;
	nitems = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4559;
	goto L4560;
L4559:
	R1 = tou64("Extra semicolon 2");
	cc_support_serror(asu64(R1));
	goto L4558;
L4560:
L4558:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	wasenum = asi64(R1);
	R1 = 0;
	exported = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L4562;
	asi64(R1) = cc_parse_readdllexport();
	exported = asi64(R1);
L4562:
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_stmodule;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L4564;
	asi64(R1) = cc_parse_readdllexport();
	exported = asi64(R1);
L4564:
	R1 = 0;
	commaseen = asi64(R1);
L4565:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4567;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4567;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4567;
	goto L4568;
L4567:
	R1 = (u64)&nitems;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_stmodule;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4570;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L4570:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4572;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L4574;
	asu64(R1) = pm;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	m = asi64(R1);
L4574:
	asi64(R1) = m;
	asu64(R2) = d;
	asu64(R3) = cc_decls_stmodule;
	asu64(R1) = cc_parse_createtypedef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L4571;
L4572:
	asu64(R1) = pm;
	if (!asu64(R1)) goto L4575;
// cc_parse.readmodule.readfn:
L4576:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4578;
	asi64(R1) = commaseen;
	if (!asi64(R1)) goto L4578;
	R1 = tou64("fn def after comma");
	cc_support_serror(asu64(R1));
L4578:
	asi64(R1) = exported;
	R2 = (u64)&wasdef;
	asu64(R3) = pm;
	asi64(R4) = linkage;
	asi64(R5) = m;
	asu64(R6) = d;
	asu64(R1) = cc_parse_readfunction(asu64(R6), asi64(R5), asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = wasdef;
	if (!asi64(R1)) goto L4580;
	goto L4566;
L4580:
	goto L4571;
L4575:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L4581;
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	goto L4576;
	goto L4571;
L4581:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readmodulevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
L4571:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4583;
	goto L4584;
L4583:
	R1 = 1;
	commaseen = asi64(R1);
	cc_lex_lex();
	goto L4582;
L4584:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L4566;
L4582:
	goto L4565;
L4568:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4586;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L4586;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4586;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4587;
	goto L4588;
L4586:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L4566;
	goto L4585;
L4587:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L4566;
	goto L4585;
L4588:
	asi64(R1) = mbase;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4585:
	goto L4565;
L4566:
L4556:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L4555;
	return;
}

static i64 cc_parse_parsemodule() {
    u64 R1, R2, R3; 
	i64 size;
	i64 t;
	u64 owner;
	r64 tsecs;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4591;
	msysc_m$print_startcon();
	R1 = tou64("Parsing:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4591:
	R1 = 0;
	R2 = R1;
	cc_parse_ingeneric = asu8(R2);
	cc_parse_loopindex = asi64(R1);
	R1 = 0;
	cc_parse_ist_symptr = asu64(R1);
	R1 = 512;
	R2 = 0;
	R3 = (u64)&cc_parse_casevaluestack;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asi64(R1) = cc_decls_mainfileno;
	R2 = tou64("PARSETEST");
	cc_lex_startlex(asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	R1 = 0;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	cc_parse_loopindex = asi64(R1);
	cc_lex_lex();
	cc_parse_readmodule();
	cc_lex_endlex();
	R1 = 1;
	goto L4589;
L4589:
	return asi64(R1);
}

static i64 cc_parse_readdeclspec(u64 owner, u64 linkage) {
    u64 R1, R2, R3; 
	struct $B64 d;
	u64 p;
	i64 t;
	i64 mod;
	i64 m;
	i64 fstruct;
	u64 pm;
	u64 e;
	R1 = 15;
	R2 = 0;
	R3 = (u64)&d;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 20;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	mod = asi64(R2);
	fstruct = asi64(R1);
L4593:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 67: goto L4646;
	case 68: case 69: case 70: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 90: goto L4596;
	case 71: goto L4598;
	case 84: case 85: goto L4640;
	case 86: goto L4633;
	case 87: goto L4625;
	case 88: goto L4597;
	case 89: goto L4636;
	case 91: goto L4643;
	default: goto L4596;
    };
// SWITCH
L4597:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	cc_lex_lex();
	goto L4593;
L4598:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: case 2: case 5: case 6: case 7: case 10: goto L4602;
	case 3: goto L4608;
	case 4: goto L4612;
	case 8: goto L4617;
	case 9: goto L4621;
	default: goto L4601;
    };
// SWITCH
L4602:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4604;
	asi64(R1) = fstruct;
	if (!asi64(R1)) goto L4606;
	R1 = 9;
	cc_lib_checksymbol(asi64(R1));
	goto L4605;
L4606:
	goto L4607;
L4605:
L4604:
	R1 = (u64)&cc_tables_typespectypes;
	R2 = (u64)&cc_decls_lx;
	R3 = 22;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4599;
L4608:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4611;
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4611;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4610;
L4611:
	goto L4607;
L4610:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4599;
L4612:
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4615;
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4614;
L4615:
	goto L4607;
	goto L4613;
L4614:
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4616;
	R1 = 0;
	R2 = (u64)&d;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4613;
L4616:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4613:
	R1 = 1;
	mod = asi64(R1);
	goto L4599;
L4617:
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4620;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4619;
L4620:
	goto L4607;
L4619:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4599;
L4621:
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4624;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4623;
L4624:
	goto L4607;
L4623:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4599;
L4601:
// cc_parse.readdeclspec.tserror:
L4607:
	R1 = (u64)&cc_tables_typespecnames;
	R2 = (u64)&cc_decls_lx;
	R3 = 22;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("declspec/ts #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4599:
	cc_lex_lex();
	goto L4593;
L4625:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4627;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4628;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4629;
	goto L4630;
L4627:
	asu8(R1) = pc_decls_fnoconst;
	if (asu8(R1)) goto L4632;
	R1 = 1;
	R2 = (u64)&d;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4632:
	goto L4626;
L4628:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4626;
L4629:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4626;
L4630:
L4626:
	cc_lex_lex();
	goto L4593;
L4633:
	R1 = (u64)&d;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4635;
	R1 = tou64("Dual storage spec");
	cc_support_serror(asu64(R1));
L4635:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&d;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	goto L4593;
L4636:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4638;
	goto L4639;
L4638:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4637;
L4639:
L4637:
	cc_lex_lex();
	goto L4593;
L4640:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4642;
	R1 = tou64("struct?");
	cc_support_serror(asu64(R1));
L4642:
	asu64(R1) = owner;
	asi64(R1) = cc_parse_readstructdecl(asu64(R1));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	fstruct = asi64(R1);
	goto L4593;
L4643:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4645;
	R1 = tou64("enum?");
	cc_support_serror(asu64(R1));
L4645:
	asu64(R1) = owner;
	asi64(R1) = cc_parse_readenumdecl(asu64(R1));
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4593;
L4646:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L4648;
	asu64(R1) = owner;
	asi64(R1) = cc_parse_isusertype(asu64(R1));
	R2 = R1;
	m = asi64(R2);
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4648;
	asi64(R1) = mod;
	if (!asi64(R1)) goto L4650;
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4594;
L4650:
	asi64(R1) = m;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	goto L4647;
L4648:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L4652;
	asi64(R1) = mod;
	if (asi64(R1)) goto L4652;
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Implicit decls not allowed: #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4652:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L4654;
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4654:
	goto L4594;
L4647:
	goto L4593;
L4596:
	goto L4594;
	goto L4593;
L4594:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4656;
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L4655;
L4656:
	R1 = 3;
L4655:
	t = asi64(R1);
	R1 = (u64)&d;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4658;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4660;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4661;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4662;
	goto L4663;
L4660:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4665;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4667;
	R1 = 7;
	goto L4666;
L4667:
	R1 = 2;
L4666:
	t = asi64(R1);
	goto L4664;
L4665:
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4668;
	asu8(R1) = pc_decls_flong64;
	if (!asu8(R1)) goto L4670;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4672;
	R1 = 9;
	goto L4671;
L4672:
	R1 = 4;
L4671:
	t = asi64(R1);
	goto L4669;
L4670:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4674;
	R1 = 8;
	goto L4673;
L4674:
	R1 = 3;
L4673:
	t = asi64(R1);
L4669:
	goto L4664;
L4668:
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4675;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4677;
	R1 = 9;
	goto L4676;
L4677:
	R1 = 4;
L4676:
	t = asi64(R1);
	goto L4664;
L4675:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4678;
	R1 = 8;
	t = asi64(R1);
L4678:
L4664:
	goto L4659;
L4661:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4681;
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4681;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4680;
L4681:
	R1 = tou64("char decl?");
	cc_support_serror(asu64(R1));
L4680:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4683;
	R1 = 6;
	goto L4682;
L4683:
	R1 = 1;
L4682:
	t = asi64(R1);
	goto L4659;
L4662:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4686;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4686;
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4686;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4685;
L4686:
	R1 = tou64("dbl decl?");
	cc_support_serror(asu64(R1));
L4685:
	goto L4659;
L4663:
	asi64(R1) = mod;
	if (!asi64(R1)) goto L4688;
	R1 = tou64("declspec/float");
	cc_support_serror(asu64(R1));
L4688:
L4659:
L4658:
	R1 = (u64)&d;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4690;
	asi64(R1) = t;
	asi64(R1) = cc_lib_createconstmode(asi64(R1));
	t = asi64(R1);
L4690:
	R1 = (u64)&d;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = linkage;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = t;
	goto L4592;
L4592:
	return asi64(R1);
}

static i64 cc_parse_istypestarter() {
    u64 R1, R2, R3, R4; 
	u64 d;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L4693;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L4693;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4694;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4695;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4696;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4696;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L4696;
	goto L4697;
L4693:
	R1 = 1;
	goto L4691;
	goto L4692;
L4694:
	R1 = 1;
	goto L4691;
	goto L4692;
L4695:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L4699;
	asu64(R4) = cc_decls_currproc;
	goto L4698;
L4699:
	asu64(R4) = cc_decls_stmodule;
L4698:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L4701;
	asu64(R1) = d;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L4691;
L4701:
	goto L4692;
L4696:
	R1 = 1;
	goto L4691;
	goto L4692;
L4697:
L4692:
	R1 = 0;
	goto L4691;
L4691:
	return asi64(R1);
}

static i64 cc_parse_istypestarter_next() {
    u64 R1, R2, R3, R4; 
	u64 d;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L4704;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L4704;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4705;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4706;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4707;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4707;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L4707;
	goto L4708;
L4704:
	R1 = 1;
	goto L4702;
	goto L4703;
L4705:
	R1 = 1;
	goto L4702;
	goto L4703;
L4706:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L4710;
	asu64(R4) = cc_decls_currproc;
	goto L4709;
L4710:
	asu64(R4) = cc_decls_stmodule;
L4709:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L4712;
	asu64(R1) = d;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L4702;
L4712:
	goto L4703;
L4707:
	R1 = 1;
	goto L4702;
	goto L4703;
L4708:
L4703:
	R1 = 0;
	goto L4702;
L4702:
	return asi64(R1);
}

static u64 cc_parse_readexpression() {
    u64 R1, R2, R3; 
	u64 p;
	u64 ulist;
	u64 ulistx;
	i64 t;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4715;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4715;
	goto L4716;
L4715:
	asu64(R1) = cc_parse_readterm();
	goto L4713;
	goto L4714;
L4716:
L4714:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4718;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L4719:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4722;
	goto L4720;
L4722:
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	goto L4719;
L4720:
	asu64(R1) = ulist;
	R2 = 29;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = ulistx;
	if (!asu64(R1)) goto L4724;
	asu64(R1) = ulistx;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4724:
	asu64(R1) = p;
	goto L4713;
L4718:
	asu64(R1) = p;
	goto L4713;
L4713:
	return asu64(R1);
}

static u64 cc_parse_readassignexpr() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 r;
	i64 opc;
	i64 oldpmode;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4727;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4727;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4727;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4728;
	goto L4729;
L4727:
	asu64(R1) = cc_parse_readterm();
	goto L4725;
	goto L4726;
L4728:
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L4730;
	goto L4726;
L4729:
L4726:
	asu64(R1) = cc_parse_readcondexpr();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	switch (asi64(R1)) {
	case 11: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L4734;
	case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: goto L4733;
	default: goto L4733;
    };
// SWITCH
L4734:
// cc_parse.readassignexpr.gotp:
L4730:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldpmode = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
	asu64(R1) = cc_parse_readassignexpr();
	q = asu64(R1);
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4736;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = opc;
	asu64(R1) = cc_parse_createassignopref(asi64(R3), asu64(R2), asu64(R1));
	goto L4725;
L4736:
	asi64(R1) = oldpmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = oldpmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4738;
	R1 = tou64("Modifying read-only var");
	cc_support_terror(asu64(R1));
L4738:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L4740;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4740;
	R1 = tou64("Modifying constant?");
	cc_support_terror(asu64(R1));
L4740:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	asi64(R1) = oldpmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L4725;
	goto L4731;
L4733:
L4731:
	asu64(R1) = p;
	goto L4725;
L4725:
	return asu64(R1);
}

static u64 cc_parse_readcondexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	u64 pcond;
	i64 s;
	i64 t;
	i64 u;
	asu64(R1) = cc_parse_readorlexpr();
	pcond = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4743;
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	x = asu64(R1);
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readcondexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4745;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4747;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4747;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4747;
	asu64(R1) = pcond;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4749;
	asu64(R1) = x;
	goto L4748;
L4749:
	asu64(R1) = y;
L4748:
	goto L4741;
L4747:
	goto L4744;
L4745:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4750;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4750;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L4744;
L4750:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4751;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4751;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4751;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4751;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	goto L4744;
L4751:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4752;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4752;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4752;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4752;
	asu64(R1) = y;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	goto L4744;
L4752:
	asi64(R1) = s;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L4753;
	asi64(R1) = t;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L4753;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L4744;
L4753:
	asi64(R1) = s;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4754;
	asi64(R1) = t;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4754;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L4744;
L4754:
	asi64(R1) = s;
	asi64(R2) = t;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L4755;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4755;
	R1 = 0;
	u = asi64(R1);
	goto L4744;
L4755:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("?: incompatible types");
	cc_support_terror(asu64(R1));
L4744:
	asu64(R1) = y;
	asu64(R2) = x;
	asu64(R3) = pcond;
	R4 = 31;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	pcond = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = pcond;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4743:
	asu64(R1) = pcond;
	goto L4741;
L4741:
	return asu64(R1);
}

static u64 cc_parse_readorlexpr() {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = cc_parse_readandlexpr();
	x = asu64(R1);
	goto L4758;
L4757:
	cc_lex_lex();
	asu64(R1) = cc_parse_readandlexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = y;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4761;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4761;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L4764;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4763;
L4764:
	R1 = 1;
	goto L4762;
L4763:
	R1 = 0;
L4762:
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4758;
L4761:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 25;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4758:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L4757;
	asu64(R1) = x;
	goto L4756;
L4756:
	return asu64(R1);
}

static u64 cc_parse_readandlexpr() {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = cc_parse_readiorexpr();
	x = asu64(R1);
	goto L4767;
L4766:
	cc_lex_lex();
	asu64(R1) = cc_parse_readiorexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = y;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4770;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4770;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4772;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L4772;
	R1 = 1;
	goto L4771;
L4772:
	R1 = 0;
L4771:
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4767;
L4770:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 24;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4767:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4766;
	asu64(R1) = x;
	goto L4765;
L4765:
	return asu64(R1);
}

static u64 cc_parse_readiorexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readixorexpr();
	x = asu64(R1);
	goto L4775;
L4774:
	cc_lex_lex();
	asu64(R1) = cc_parse_readixorexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4778;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4780;
	R1 = tou64("float|float");
	cc_support_terror(asu64(R1));
L4780:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4777;
L4778:
	R1 = tou64("invalid | operands");
	cc_support_terror(asu64(R1));
L4777:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4782;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4782;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4784;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4784;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4784;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4784;
	goto L4785;
L4784:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) |= asi64(R1);
	goto L4775;
	goto L4783;
L4785:
L4783:
L4782:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 45;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4775:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L4774;
	asu64(R1) = x;
	goto L4773;
L4773:
	return asu64(R1);
}

static u64 cc_parse_readixorexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readiandexpr();
	x = asu64(R1);
	goto L4788;
L4787:
	cc_lex_lex();
	asu64(R1) = cc_parse_readiandexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4791;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4793;
	R1 = tou64("float^float");
	cc_support_terror(asu64(R1));
L4793:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4790;
L4791:
	R1 = tou64("invalid ^ operands");
	cc_support_terror(asu64(R1));
L4790:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4795;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4795;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4797;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4797;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4797;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4797;
	goto L4798;
L4797:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) ^= asi64(R1);
	goto L4788;
	goto L4796;
L4798:
L4796:
L4795:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 46;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4788:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L4787;
	asu64(R1) = x;
	goto L4786;
L4786:
	return asu64(R1);
}

static u64 cc_parse_readiandexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readeqexpr();
	x = asu64(R1);
	goto L4801;
L4800:
	cc_lex_lex();
	asu64(R1) = cc_parse_readeqexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4804;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4806;
	R1 = tou64("float&float");
	cc_support_terror(asu64(R1));
L4806:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4803;
L4804:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("invalid & operands");
	cc_support_terror(asu64(R1));
L4803:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4808;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4808;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4810;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4810;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4810;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4810;
	goto L4811;
L4810:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) &= asi64(R1);
	goto L4801;
	goto L4809;
L4811:
L4809:
L4808:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 44;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4801:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L4800;
	asu64(R1) = x;
	goto L4799;
L4799:
	return asu64(R1);
}

static u64 cc_parse_readeqexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 s;
	i64 t;
	i64 u;
	i64 ss;
	i64 tt;
	asu64(R1) = cc_parse_readrelexpr();
	x = asu64(R1);
	goto L4814;
L4813:
	cc_lex_lex();
	asu64(R1) = cc_parse_readrelexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4817;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4816;
L4817:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4818;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4818;
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	ss = asi64(R2);
	R2 = (u64)&cc_decls_tttarget;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	tt = asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L4820;
	asi64(R1) = ss;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4822;
	asi64(R1) = tt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4822;
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (asi64(R1)) goto L4824;
	R1 = tou64("Comparing distinct pointers/eq");
	cc_support_terror(asu64(R1));
L4824:
L4822:
L4820:
	goto L4816;
L4818:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4825;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4825;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4828;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4827;
L4828:
	R1 = tou64("Can't compare pointer to int");
	cc_support_terror(asu64(R1));
L4827:
	goto L4816;
L4825:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4829;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4829;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4832;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4831;
L4832:
	R1 = tou64("Can't compare pointer to int2");
	cc_support_terror(asu64(R1));
L4831:
	goto L4816;
L4829:
	msysc_m$print_startcon();
	R1 = tou64("U=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = u;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("invalid == operands");
	cc_support_terror(asu64(R1));
L4816:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4834;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4834;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4836;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4836;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4836;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4836;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4836;
	goto L4837;
L4836:
	asi64(R1) = opc;
	R2 = 40;
	if (asi64(R1) != asi64(R2)) goto L4839;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4838;
L4839:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4838:
	goto L4814;
	goto L4835;
L4837:
L4835:
L4834:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4814:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4813;
	asi64(R1) = opc;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4813;
	asu64(R1) = x;
	goto L4812;
L4812:
	return asu64(R1);
}

static u64 cc_parse_readrelexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 s;
	i64 t;
	i64 u;
	i64 a;
	i64 b;
	i64 c;
	u64 aa;
	u64 bb;
	u64 cc;
	asu64(R1) = cc_parse_readshiftexpr();
	x = asu64(R1);
	goto L4842;
L4841:
	cc_lex_lex();
	asu64(R1) = cc_parse_readshiftexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L4845;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L4844;
L4845:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4846;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4846;
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (asi64(R1)) goto L4848;
	R1 = tou64("Comparing distinct pointers/rel");
	cc_support_terror(asu64(R1));
L4848:
	goto L4844;
L4846:
	R1 = tou64("invalid rel operands");
	cc_support_terror(asu64(R1));
L4844:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4850;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4850;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4852;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4852;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4853;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4853;
	goto L4854;
L4852:
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4856;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4857;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4858;
	goto L4859;
L4856:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	c = asi64(R1);
	goto L4855;
L4857:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	c = asi64(R1);
	goto L4855;
L4858:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	c = asi64(R1);
	goto L4855;
L4859:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	c = asi64(R1);
L4855:
	asi64(R1) = c;
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4842;
	goto L4851;
L4853:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	aa = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	bb = asu64(R1);
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4861;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4862;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4863;
	goto L4864;
L4861:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	cc = asu64(R1);
	goto L4860;
L4862:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	cc = asu64(R1);
	goto L4860;
L4863:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	cc = asu64(R1);
	goto L4860;
L4864:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  >  asu64(R2);
	cc = asu64(R1);
L4860:
	asu64(R1) = cc;
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4842;
	goto L4851;
L4854:
L4851:
L4850:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4842:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4841;
	asi64(R1) = opc;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4841;
	asi64(R1) = opc;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4841;
	asi64(R1) = opc;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4841;
	asu64(R1) = x;
	goto L4840;
L4840:
	return asu64(R1);
}

static u64 cc_parse_readshiftexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 u;
	asu64(R1) = cc_parse_readaddexpr();
	x = asu64(R1);
	goto L4867;
L4866:
	cc_lex_lex();
	asu64(R1) = cc_parse_readaddexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercebasetype(asu64(R1));
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	u = asi64(R2);
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4871;
	asi64(R1) = u;
	R2 = 9;
	if (asi64(R1) <= asi64(R2)) goto L4870;
L4871:
	R1 = tou64("shift:Not an int");
	cc_support_terror(asu64(R1));
L4870:
	R1 = 3;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4873;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4873;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4875;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4875;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4876;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4876;
	goto L4877;
L4875:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L4879;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) <<= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4878;
L4879:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) >>= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4878:
	goto L4867;
	goto L4874;
L4876:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L4881;
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) <<= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4880;
L4881:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) >>= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4880:
	goto L4867;
	goto L4874;
L4877:
L4874:
L4873:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	R4 = 33;
	if (asi64(R3) != asi64(R4)) goto L4883;
	R3 = 47;
	goto L4882;
L4883:
	R3 = 48;
L4882:
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4867:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4866;
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L4866;
	asu64(R1) = x;
	goto L4865;
L4865:
	return asu64(R1);
}

static u64 cc_parse_readaddexpr() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	i64 opc;
	asu64(R1) = cc_parse_readmulexpr();
	p = asu64(R1);
	goto L4886;
L4885:
	cc_lex_lex();
	asu64(R1) = cc_parse_readmulexpr();
	q = asu64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L4889;
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createaddop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4888;
L4889:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsubop(asu64(R2), asu64(R1));
	p = asu64(R1);
L4888:
L4886:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L4885;
	asi64(R1) = opc;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4885;
	asu64(R1) = p;
	goto L4884;
L4884:
	return asu64(R1);
}

static u64 cc_parse_readmulexpr() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	i64 opc;
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L4892;
L4891:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	q = asu64(R1);
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4895;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4896;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L4897;
	goto L4898;
L4895:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createmulop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4894;
L4896:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createdivop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4894;
L4897:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createremop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4894;
L4898:
L4894:
L4892:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4891;
	asi64(R1) = opc;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4891;
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L4891;
	asu64(R1) = p;
	goto L4890;
L4890:
	return asu64(R1);
}

static u64 cc_parse_readterm() {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	i64 t;
	i64 u;
	i64 opc;
	i64 shift;
	i64 newlen;
	i64 slength;
	i64 tbase;
	i64 fwide;
	i64 newmode;
	i64 tag;
	u64 pbyte;
	i64 a;
	u64 d;
	u64 ss;
	u64 s;
	u64 pm;
	i64 av_1;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 13: goto L4949;
	case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 26: case 27: case 28: case 30: case 31: case 33: case 34: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 62: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 93: goto L4902;
	case 23: goto L4936;
	case 24: goto L4937;
	case 25: goto L4946;
	case 29: goto L4942;
	case 32: goto L4945;
	case 35: goto L4941;
	case 36: goto L4938;
	case 37: case 38: goto L4947;
	case 39: goto L4948;
	case 59: case 60: goto L4903;
	case 61: goto L4928;
	case 63: case 64: goto L4922;
	case 67: goto L4904;
	case 92: goto L4954;
	case 94: goto L4965;
	case 95: goto L4966;
	case 96: goto L4967;
	default: goto L4902;
    };
// SWITCH
L4903:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L4900;
L4904:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L4906;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L4908;
	asu64(R4) = cc_decls_currproc;
	goto L4907;
L4908:
	asu64(R4) = cc_decls_stmodule;
L4907:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4910;
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	R2 = tou64("Undefined name \"#\"");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4910:
	goto L4905;
L4906:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4905:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4912;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4913;
	goto L4914;
L4912:
	R1 = 3;
	asu64(R2) = d;
	R3 = 88;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = tou64(toi32(R2));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L4911;
L4913:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4916;
	R1 = 5;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4915;
L4916:
	goto L4917;
L4915:
	goto L4911;
L4914:
// cc_parse.readterm.doname:
L4917:
	asu64(R1) = d;
	asu64(R1) = cc_lib_createname(asu64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = R1;
	t = asi64(R2);
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4919;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R1) = cc_parse_createaddrofop(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4918;
L4919:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4920;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L4920;
	asu64(R1) = p;
	cc_parse_fixmemopnd(asu64(R1));
	goto L4918;
L4920:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4921;
L4921:
L4918:
L4911:
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	cc_lex_lex();
	goto L4900;
L4922:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	fwide = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	slength = asi64(R1);
	goto L4924;
L4923:
	asi64(R1) = slength;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	ss = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R3) = ss;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = ss;
	asi64(R4) = slength;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ss;
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ss;
	s = asu64(R1);
	asi64(R1) = newlen;
	slength = asi64(R1);
	cc_lex_lex();
L4924:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L4923;
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L4927;
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R1) = cc_lib_createwstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefwchar;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4926;
L4927:
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R1) = cc_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4926:
	cc_lex_lex();
	goto L4900;
L4928:
	R1 = 0;
	a = asi64(R1);
	R1 = 0;
	shift = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pbyte = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L4930;
	R1 = tou64("char const too long");
	cc_support_serror(asu64(R1));
L4930:
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4933;
L4931:
	asi64(R1) = a;
	asu64(R2) = pbyte;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	a = asi64(R1);
	R1 = 8;
	R2 = (u64)&shift;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&pbyte;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L4931;
L4933:
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L4935;
	R1 = 3;
	goto L4934;
L4935:
	R1 = 4;
L4934:
	asi64(R2) = a;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L4900;
L4936:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L4900;
L4937:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createnegop(asu64(R1));
	p = asu64(R1);
	goto L4900;
L4938:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	asu64(R1) = p;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = p;
	R2 = 26;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L4940;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L4940;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4940:
	goto L4900;
L4941:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createinotop(asu64(R1));
	p = asu64(R1);
	goto L4900;
L4942:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L4944;
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L4943;
L4944:
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createaddrofop(asu64(R1));
	p = asu64(R1);
L4943:
	goto L4900;
L4945:
	R1 = tou64("rt/&&label");
	cc_support_serror(asu64(R1));
	goto L4900;
L4946:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	p = asu64(R1);
	goto L4900;
L4947:
	R1 = (u64)&cc_tables_symboltojtag;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asi64(R2) = opc;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4900;
L4948:
	cc_lex_lex();
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readexpression();
	asu64(R1) = cc_parse_createabsop(asu64(R1));
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	goto L4900;
L4949:
	cc_lex_lex();
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L4951;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4953;
	R1 = tou64("rt/compound lit");
	cc_support_serror(asu64(R1));
	goto L4952;
L4953:
	R1 = 0;
	R2 = 1;
	asi64(R3) = t;
	asu64(R4) = cc_parse_readterm();
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
L4952:
	goto L4950;
L4951:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
L4950:
	goto L4900;
L4954:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4956;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4958;
	cc_lex_lex();
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L4960;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 9;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L4959;
L4960:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L4959:
	goto L4957;
L4958:
	R1 = 1;
	asu64(R2) = cc_parse_readterm();
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L4957:
	goto L4955;
L4956:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4962;
	asi64(R1) = cc_parse_istypestarter_next();
	if (!asi64(R1)) goto L4964;
	cc_lex_lex();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 9;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = t;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L4963;
L4964:
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L4963:
	goto L4961;
L4962:
	R1 = 0;
	asu64(R2) = cc_parse_readterm();
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L4961:
L4955:
	goto L4900;
L4965:
	asu64(R1) = cc_parse_readgeneric();
	p = asu64(R1);
	goto L4900;
L4966:
	R1 = tou64("rt/alignof");
	cc_support_serror(asu64(R1));
	goto L4900;
L4967:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	tag = asi64(R1);
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = tag;
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L4969;
	R1 = 8;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	q = asu64(R1);
	goto L4968;
L4969:
	R1 = 0;
	q = asu64(R1);
L4968:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = tag;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	goto L4900;
L4902:
	R1 = tou64("RT");
	cc_lex_ps(asu64(R1));
	R1 = tou64("Readterm?");
	cc_support_serror(asu64(R1));
L4900:
L4970:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: case 3: goto L4975;
	case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 14: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: goto L4973;
	case 13: goto L4976;
	case 15: goto L4974;
	case 37: goto L4979;
	case 38: goto L4980;
	default: goto L4973;
    };
// SWITCH
L4974:
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	q = asu64(R1);
	R1 = 16;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createindexop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4970;
L4975:
	R1 = (u64)&cc_tables_symboltojtag;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lex();
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	asu64(R1) = d;
	asu64(R2) = p;
	asi64(R3) = opc;
	asu64(R1) = cc_parse_createdotop(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4970;
L4976:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L4978;
	R1 = 0;
	q = asu64(R1);
	cc_lex_lex();
	goto L4977;
L4978:
	R1 = 0;
	asu64(R1) = cc_parse_readexprlist(asu64(R1));
	q = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
L4977:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createcall(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4970;
L4979:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 73;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4970;
L4980:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 74;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4970;
L4973:
	goto L4971;
	goto L4970;
L4971:
	asu64(R1) = p;
	goto L4899;
L4899:
	return asu64(R1);
}

static u64 cc_parse_readexprlist(u64 p) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L4982:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4985;
	goto L4983;
L4985:
	cc_lex_lex();
	goto L4982;
L4983:
	asu64(R1) = ulist;
	goto L4981;
L4981:
	return asu64(R1);
}

static u64 cc_parse_readmodulevar(u64 d, i64 m, i64 linkage) {
    u64 R1, R2, R3, R4; 
	u64 e;
	i64 scope;
	i64 emode;
	R1 = 0;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = cc_decls_stmodule;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L4988;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4990;
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = e;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("var: name in use # #");
	cc_support_serror_ss(asu64(R3), asu64(R2), asu64(R1));
L4990:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	emode = asi64(R1);
	asi64(R1) = emode;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L4992;
	asi64(R1) = m;
	asi64(R2) = emode;
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L4994;
// cc_parse.readmodulevar.redef:
L4995:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("var: redefining #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L4994:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = emode;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L4997;
	goto L4998;
L4997:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = emode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5000;
	asi64(R1) = m;
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L4999;
L5000:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L5001;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = emode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) == asi64(R2)) goto L5001;
	goto L4995;
L5001:
L4999:
	goto L4996;
L4998:
L4996:
L4992:
	asu64(R1) = e;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5005;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5004;
L5005:
	asi64(R1) = scope;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5006;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5004;
L5006:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5003;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5003;
L5004:
	goto L5002;
L5003:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5007;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5007;
	R1 = 4;
	scope = asi64(R1);
L5007:
L5002:
	goto L4987;
L4988:
	R1 = 7;
	asu64(R2) = d;
	asu64(R3) = cc_decls_stmodule;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5009;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5010;
	goto L5011;
L5009:
	R1 = 2;
	scope = asi64(R1);
	goto L5008;
L5010:
	R1 = 3;
	scope = asi64(R1);
	goto L5008;
L5011:
	R1 = 4;
	scope = asi64(R1);
L5008:
L4987:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5013;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5015;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5015:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5017;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init extern #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5017:
	cc_lex_lex();
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = cc_decls_stmodule;
	asu64(R1) = cc_parse_readinitexpr(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5013:
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	goto L4986;
L4986:
	return asu64(R1);
}

static u64 cc_parse_readframevar(u64 d, i64 m, i64 linkage) {
    u64 R1, R2, R3, R4; 
	u64 pm;
	u64 e;
	i64 scope;
	i64 id;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_checkdupl_inproc(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5020;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("var: name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
	asu64(R1) = e;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5024;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5023;
L5024:
	asi64(R1) = scope;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5025;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5023;
L5025:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5022;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5022;
L5023:
	goto L5021;
L5022:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5026;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5026;
	R1 = 4;
	scope = asi64(R1);
L5026:
L5021:
	goto L5019;
L5020:
	R1 = 8;
	id = asi64(R1);
	R1 = 1;
	scope = asi64(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5028;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5029;
	goto L5030;
L5028:
	R1 = 7;
	id = asi64(R1);
	goto L5027;
L5029:
	R1 = 3;
	scope = asi64(R1);
	R1 = 7;
	id = asi64(R1);
	goto L5027;
L5030:
L5027:
	asi64(R1) = id;
	asu64(R2) = d;
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L5019:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5032;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5034;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5034:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5036;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init extern #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5036:
	cc_lex_lex();
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = cc_decls_currproc;
	asu64(R1) = cc_parse_readinitexpr(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5032:
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	goto L5018;
L5018:
	return asu64(R1);
}

static i64 cc_parse_readtype(u64 owner, u64 d, i64 m, u64 pm) {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 modtype;
	struct $B16 modvalue;
	u64 pmx;
	i64 nmodifiers;
	i64 i;
	R1 = 0;
	nmodifiers = asi64(R1);
	R1 = 0;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&nmodifiers;
	R2 = (u64)&modvalue;
	R3 = (u64)&modtype;
	asu64(R4) = d;
	asu64(R5) = owner;
	cc_parse_readnamedtype(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = nmodifiers;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5040;
L5038:
	R1 = (u64)&modtype;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L5042;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5043;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5044;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L5045;
	goto L5046;
L5042:
	R1 = (u64)&modvalue;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = m;
	asi64(R1) = cc_lib_createarraymode(asi64(R2), asi64(R1));
	m = asi64(R1);
	goto L5041;
L5043:
	asi64(R1) = m;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L5041;
L5044:
	asi64(R1) = m;
	asi64(R1) = cc_lib_createconstmode(asi64(R1));
	m = asi64(R1);
	goto L5041;
L5045:
	R1 = (u64)&modvalue;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pmx = asu64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5048;
	asu64(R1) = pmx;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	goto L5047;
L5048:
	asu64(R1) = pmx;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	m = asi64(R1);
L5047:
	goto L5041;
L5046:
L5041:
	i += -1; if (i >= 1) goto L5038;
L5040:
	asi64(R1) = m;
	goto L5037;
L5037:
	return asi64(R1);
}

static void cc_parse_readnamedtype(u64 owner, u64 d, u64 modtype, u64 modvalue, u64 nmodifiers) {
    u64 R1, R2, R3, R4, R5; 
	i64 length;
	struct $B16 fconst;
	i64 nrefs;
	u64 pdim;
	R1 = 0;
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	nrefs = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 89;
	if (asi64(R1) != asi64(R2)) goto L5051;
	cc_lex_lex();
L5051:
	goto L5053;
L5052:
	R1 = (u64)&nrefs;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&fconst;
	asi64(R3) = nrefs;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	cc_lex_lex();
	goto L5056;
L5055:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5059;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5060;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5060;
	goto L5061;
L5059:
	R1 = 1;
	R2 = (u64)&fconst;
	asi64(R3) = nrefs;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L5058;
L5060:
	goto L5058;
L5061:
	R1 = tou64("rnt1");
	cc_support_serror(asu64(R1));
L5058:
	cc_lex_lex();
L5056:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5055;
L5053:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5052;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5063;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5064;
	goto L5065;
L5063:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	cc_lex_lex();
	goto L5062;
L5064:
	cc_lex_lex();
	asu64(R1) = nmodifiers;
	asu64(R2) = modvalue;
	asu64(R3) = modtype;
	asu64(R4) = d;
	asu64(R5) = owner;
	cc_parse_readnamedtype(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	goto L5062;
L5065:
L5062:
L5066:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5068;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5069;
	goto L5070;
L5068:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L5072;
	R1 = 0;
	length = asi64(R1);
	goto L5071;
L5072:
	asu64(R1) = cc_parse_readassignexpr();
	pdim = asu64(R1);
	asu64(R1) = pdim;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5074;
	asu64(R1) = pdim;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	goto L5073;
L5074:
	R1 = tou64("Can't do VLAs");
	cc_support_serror(asu64(R1));
L5073:
	R1 = 16;
	cc_lib_checksymbol(asi64(R1));
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5076;
	R1 = tou64("ZERO LEN ARRAY");
	cc_support_serror(asu64(R1));
L5076:
L5071:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L5078;
	R1 = tou64("Negative array dim");
	cc_support_terror(asu64(R1));
L5078:
	cc_lex_lex();
	R1 = 65;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = modvalue;
	asu64(R3) = nmodifiers;
	asi64(R3) = *toi64p(R3);
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L5066;
L5069:
	cc_lex_lex();
	R1 = 70;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = owner;
	asu64(R1) = cc_parse_readparams(asu64(R1));
	asu64(R2) = modvalue;
	asu64(R3) = nmodifiers;
	asi64(R3) = *toi64p(R3);
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L5066;
L5070:
	goto L5067;
	goto L5066;
L5067:
	goto L5080;
L5079:
	R1 = (u64)&fconst;
	asi64(R2) = nrefs;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L5083;
	R1 = 67;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L5083:
	R1 = 82;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&nrefs;
	(*toi64p(R1)) -=1;
L5080:
	asi64(R1) = nrefs;
	if (asi64(R1)) goto L5079;
	return;
}

static i64 cc_parse_readconstintexpr() {
    u64 R1, R2, R3; 
	u64 p;
	i64 val;
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5086;
	goto L5087;
L5086:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L5084;
	goto L5085;
L5087:
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("readconstint #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5085:
	R1 = 0;
	goto L5084;
L5084:
	return asi64(R1);
}

static u64 cc_parse_readinitexpr(u64 owner, i64 m) {
    u64 R1, R2, R3; 
	i64 count;
	u64 p;
	R1 = 1;
	asi64(R2) = m;
	asu64(R3) = owner;
	asu64(R1) = cc_parse_readinitexpr2(asu64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L5088;
L5088:
	return asu64(R1);
}

static u64 cc_parse_readinitexpr2(u64 owner, i64 m, i64 istop) {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 mbase;
	i64 melem;
	i64 mm;
	i64 dim;
	i64 count;
	u64 d;
	u64 e;
	i64 braces;
	u64 newstr;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5091;
	cc_lex_lex();
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5093;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5094;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5094;
	goto L5095;
L5093:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	dim = asi64(R1);
	asi64(R1) = istop;
	if (asi64(R1)) goto L5097;
	asi64(R1) = dim;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5097;
	R1 = tou64("init/0-size array");
	cc_support_terror(asu64(R1));
L5097:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	melem = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = melem;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5099;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L5099;
	R1 = 1;
	braces = asi64(R1);
	goto L5100;
L5099:
	goto L5092;
L5094:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5102;
	R1 = tou64("init/Empty struct");
	cc_support_terror(asu64(R1));
L5102:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	melem = asi64(R1);
	goto L5092;
L5095:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L5089;
L5092:
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L5103:
	R1 = 0;
	asi64(R2) = melem;
	asu64(R3) = owner;
	asu64(R1) = cc_parse_readinitexpr2(asu64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5106;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5107;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5108;
	goto L5109;
L5106:
	asi64(R1) = dim;
	if (!asi64(R1)) goto L5111;
	asi64(R1) = count;
	asi64(R2) = dim;
	if (asi64(R1) <= asi64(R2)) goto L5111;
	R1 = tou64("Too many array elems");
	cc_support_terror(asu64(R1));
L5111:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = melem;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5113;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = melem;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5113;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L5113;
	goto L5112;
L5113:
	asi64(R1) = melem;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L5112:
	goto L5105;
L5107:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	mm = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mm;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5115;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = mm;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5115;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L5115;
	goto L5114;
L5115:
	asi64(R1) = mm;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L5114:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5117;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5119;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5119;
	R1 = tou64("Too many struct elems");
	cc_support_terror(asu64(R1));
L5119:
	goto L5116;
L5117:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	melem = asi64(R1);
L5116:
	goto L5105;
L5108:
	asi64(R1) = melem;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	goto L5120;
	goto L5105;
L5109:
L5105:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5122;
	goto L5104;
L5122:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L5124;
	cc_lex_lex();
	goto L5104;
L5124:
	cc_lex_lex();
	goto L5103;
L5104:
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5126;
	asi64(R1) = dim;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5126;
	asi64(R1) = count;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = count;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = melem;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L5126:
// cc_parse.readinitexpr2.donestruct:
L5120:
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = ulist;
	R2 = 28;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = count;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5090;
L5091:
	R1 = 0;
	braces = asi64(R1);
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5128;
	goto L5129;
L5128:
// cc_parse.readinitexpr2.doarraystring:
L5100:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L5131;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L5131;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5131;
	R1 = tou64("{} initialiser expected");
	cc_support_terror(asu64(R1));
L5131:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) == asi64(R2)) goto L5133;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) == asi64(R2)) goto L5134;
	goto L5135;
L5133:
	goto L5132;
L5134:
	goto L5132;
L5135:
	R1 = tou64("Array init");
	cc_support_terror(asu64(R1));
L5132:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	dim = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5137;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	R3 = (u64)&cc_decls_ttsize;
	asi64(R4) = m;
	*toi64p(((i64)R3+(i64)R4*8)) = asi64(R2);
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L5136;
L5137:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = dim;
	if (asi64(R1) <= asi64(R2)) goto L5139;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = dim;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L5139;
	R1 = tou64("Init str too long");
	cc_support_terror(asu64(R1));
L5139:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = dim;
	if (asi64(R1) >= asi64(R2)) goto L5141;
	asi64(R1) = dim;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	newstr = asu64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newstr;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5141:
	asi64(R1) = dim;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5136:
	asi64(R1) = braces;
	if (!asi64(R1)) goto L5143;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
L5143:
	asu64(R1) = p;
	goto L5089;
	goto L5127;
L5129:
L5127:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L5090:
	asu64(R1) = p;
	goto L5089;
L5089:
	return asu64(R1);
}

static void cc_parse_pushblock() {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 m;
	asi64(R1) = cc_decls_blocklevel;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5146;
	R1 = tou64("Too many block levels");
	cc_support_serror(asu64(R1));
L5146:
	asi64(R1) = cc_decls_nextblockno;
	R2 = 2100;
	if (asi64(R1) < asi64(R2)) goto L5148;
	R1 = tou64("Too many blocks");
	cc_support_serror(asu64(R1));
L5148:
	R1 = (u64)&cc_decls_blocklevel;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_nextblockno;
	(*toi64p(R1)) += 1;
	asi64(R1) = cc_decls_currblockno;
	n = asi64(R1);
	asi64(R1) = cc_decls_blocklevel;
	m = asi64(R1);
	goto L5150;
L5149:
	R1 = (u64)&m;
	(*toi64p(R1)) -=1;
	R1 = (u64)&cc_decls_blockstack;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
L5150:
	asi64(R1) = m;
	if (!asi64(R1)) goto L5152;
	R1 = (u64)&cc_decls_blockcounts;
	R2 = (u64)&cc_decls_blockstack;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5149;
L5152:
	asi64(R1) = n;
	R2 = (u64)&cc_decls_blockowner;
	asi64(R3) = cc_decls_nextblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cc_decls_nextblockno;
	R2 = R1;
	R3 = (u64)&cc_decls_blockstack;
	asi64(R4) = cc_decls_blocklevel;
	*toi32p(((i64)R3+(i64)R4*4)) = asi32(R2);
	cc_decls_currblockno = asi64(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	return;
}

static void cc_parse_popblock() {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_blockstack;
	R2 = (u64)&cc_decls_blocklevel;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	cc_decls_currblockno = asi64(R1);
	return;
}

static u64 cc_parse_readcompoundstmt(i64 params) {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	cc_lex_lex();
	cc_parse_pushblock();
	asi64(R1) = params;
	if (!asi64(R1)) goto L5156;
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	R3 = 1;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L5156:
	goto L5158;
L5157:
	asu64(R1) = cc_parse_readstatement();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5161;
	goto L5158;
L5161:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5163;
L5164:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5168;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5168;
	R1 = 8;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L5168:
	asu64(R1) = q;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5164;
	goto L5162;
L5163:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L5162:
L5158:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L5157;
	cc_lex_lex();
	cc_parse_popblock();
	asu64(R1) = ulistx;
	R2 = 0;
	asu64(R3) = ulist;
	R4 = 6;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L5154;
L5154:
	return asu64(R1);
}

static u64 cc_parse_readblock(i64 ifelse) {
    u64 R1, R2; 
	asu64(R1) = cc_parse_readstatement();
	goto L5169;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 72;
	if (asi64(R1) != asi64(R2)) goto L5171;
	asi64(R1) = ifelse;
	if (!asi64(R1)) goto L5171;
	asu64(R1) = cc_parse_readstatement();
	goto L5169;
L5171:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5173;
	R1 = tou64("{...} statement expected");
	cc_support_serror(asu64(R1));
L5173:
	R1 = 0;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	goto L5169;
L5169:
	return asu64(R1);
}

static u64 cc_parse_readstatement() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 ss;
	u64 d;
	i64 index;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 9: goto L5200;
	case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 70: case 73: case 90: goto L5177;
	case 17: goto L5184;
	case 67: goto L5201;
	case 71: case 84: case 85: case 86: case 87: case 88: case 89: case 91: goto L5217;
	case 72: goto L5178;
	case 74: goto L5198;
	case 75: goto L5199;
	case 76: goto L5179;
	case 77: goto L5180;
	case 78: goto L5181;
	case 79: goto L5182;
	case 80: goto L5186;
	case 81: goto L5191;
	case 82: goto L5185;
	case 83: goto L5183;
	default: goto L5177;
    };
// SWITCH
L5178:
	asu64(R1) = cc_parse_readifstmt();
	goto L5174;
	goto L5175;
L5179:
	asu64(R1) = cc_parse_readforstmt();
	goto L5174;
	goto L5175;
L5180:
	asu64(R1) = cc_parse_readwhilestmt();
	goto L5174;
	goto L5175;
L5181:
	asu64(R1) = cc_parse_readdostmt();
	goto L5174;
	goto L5175;
L5182:
	asu64(R1) = cc_parse_readreturnstmt();
	goto L5174;
	goto L5175;
L5183:
	asu64(R1) = cc_parse_readswitchstmt();
	goto L5174;
	goto L5175;
L5184:
	R1 = 0;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	goto L5174;
	goto L5175;
L5185:
	asu64(R1) = cc_parse_readgotostmt();
	goto L5174;
	goto L5175;
L5186:
	asi64(R1) = cc_parse_loopindex;
	if (!asi64(R1)) goto L5188;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = cc_parse_loopindex;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L5190;
	R1 = 20;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L5189;
L5190:
	R1 = 23;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
L5189:
	goto L5187;
L5188:
	R1 = tou64("break outside loop/sw");
	cc_support_serror(asu64(R1));
L5187:
	goto L5175;
L5191:
	asi64(R1) = cc_parse_loopindex;
	index = asi64(R1);
	goto L5193;
L5192:
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
L5193:
	asi64(R1) = index;
	if (!asi64(R1)) goto L5195;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L5192;
L5195:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5197;
	R1 = tou64("continue outside loop");
	cc_support_serror(asu64(R1));
L5197:
	R1 = 21;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L5175;
L5198:
	asu64(R1) = cc_parse_readcaselabel();
	goto L5174;
	goto L5175;
L5199:
	cc_lex_lex();
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readstatement();
	R2 = 19;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	goto L5174;
	goto L5175;
L5200:
	cc_lex_lex();
	R1 = 0;
	goto L5174;
	goto L5175;
L5201:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5203;
	R1 = 0;
	R2 = 17;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 3;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5205;
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5207;
	msysc_m$print_startcon();
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("2:Duplicate label");
	cc_support_terror(asu64(R1));
L5207:
	goto L5204;
L5205:
	R1 = 14;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L5204:
	R1 = -1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_lex_lex();
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L5209;
	goto L5208;
L5209:
	asi64(R1) = cc_parse_istypestarter();
	if (asi64(R1)) goto L5211;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) != asi64(R2)) goto L5210;
L5211:
	goto L5208;
L5210:
	asu64(R1) = cc_parse_readstatement();
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5208:
	asu64(R1) = p;
	goto L5174;
	goto L5202;
L5203:
	R1 = 0;
	cc_parse_ist_symptr = asu64(R1);
	asu64(R1) = cc_decls_currproc;
	asi64(R1) = cc_parse_isusertype(asu64(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5213;
	goto L5214;
L5213:
	asu64(R1) = cc_parse_ist_symptr;
	if (!asu64(R1)) goto L5216;
	asu64(R1) = cc_parse_ist_symptr;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5216:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
L5202:
	goto L5175;
L5217:
// cc_parse.readstatement.doreaddecl:
L5214:
	asu64(R1) = cc_parse_readlocaldecl();
	goto L5174;
	goto L5175;
L5177:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
L5175:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L5174;
L5174:
	return asu64(R1);
}

static u64 cc_parse_readifstmt() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 pcond;
	u64 pbody;
	u64 pelse;
	i64 lineno;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	lineno = asi64(R1);
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	pelse = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L5220;
	cc_lex_lex();
	R1 = 1;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pelse = asu64(R1);
L5220:
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	asu64(R3) = pcond;
	R4 = 12;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = lineno;
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L5222;
	asu64(R1) = pbody;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5224;
	R1 = 6;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pbody = asu64(R1);
L5224:
	asu64(R1) = pbody;
	asu64(R2) = p;
	cc_parse_deleteunit(asu64(R2), asu64(R1));
	goto L5221;
L5222:
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L5225;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5227;
	R1 = 6;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pelse = asu64(R1);
L5227:
	asu64(R1) = pelse;
	asu64(R2) = p;
	cc_parse_deleteunit(asu64(R2), asu64(R1));
L5225:
L5221:
	asu64(R1) = p;
	goto L5218;
L5218:
	return asu64(R1);
}

static i64 cc_parse_iscondtrue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5229;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5229;
	R1 = 1;
	goto L5230;
L5229:
	R1 = 0;
L5230:
	goto L5228;
L5228:
	return asi64(R1);
}

static i64 cc_parse_iscondfalse(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5232;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5232;
	R1 = 1;
	goto L5233;
L5232:
	R1 = 0;
L5233:
	goto L5231;
L5231:
	return asi64(R1);
}

static void cc_parse_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B37 R1_B37; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B37) = *(struct $B37*)(R1);
	asu64(R2) = p;
	*(struct $B37*)(R2) = (R1_B37);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_parse_readforstmt() {
    u64 R1, R2, R3, R4; 
	u64 pinit;
	u64 pcond;
	u64 pincr;
	u64 pbody;
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 linkage;
	i64 hasblock;
	i64 m;
	i64 mbase;
	u64 pm;
	u64 d;
	cc_lex_lex();
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 0;
	hasblock = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5237;
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L5239;
	R1 = 1;
	hasblock = asi64(R1);
	cc_parse_pushblock();
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_currproc;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L5240:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5242;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5242;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5242;
	goto L5243;
L5242:
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_currproc;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5245;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L5245:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5248;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L5247;
L5248:
	R1 = tou64("Not allowed in for stmt");
	cc_support_serror(asu64(R1));
L5247:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readframevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5250;
	R1 = 8;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L5250:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5252;
	goto L5253;
L5252:
	cc_lex_lex();
	goto L5251;
L5253:
	goto L5241;
L5251:
	goto L5240;
L5243:
	R1 = tou64("For decl error");
	cc_support_serror(asu64(R1));
	goto L5240;
L5241:
	asu64(R1) = ulistx;
	R2 = 0;
	asu64(R3) = ulist;
	R4 = 6;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	pinit = asu64(R1);
	goto L5238;
L5239:
	asu64(R1) = cc_parse_readexpression();
	pinit = asu64(R1);
L5238:
	goto L5236;
L5237:
	R1 = 2;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pinit = asu64(R1);
L5236:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5255;
	asu64(R1) = cc_parse_readexpression();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	goto L5254;
L5255:
	R1 = 2;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pcond = asu64(R1);
L5254:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5257;
	asu64(R1) = cc_parse_readexprstmt();
	pincr = asu64(R1);
	goto L5256;
L5257:
	R1 = 0;
	pincr = asu64(R1);
L5256:
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	asi64(R1) = hasblock;
	if (!asi64(R1)) goto L5259;
	cc_parse_popblock();
L5259:
	asu64(R1) = pcond;
	asu64(R2) = pinit;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pincr;
	asu64(R2) = pcond;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pinit;
	R3 = 13;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L5235;
L5235:
	return asu64(R1);
}

static u64 cc_parse_readwhilestmt() {
    u64 R1, R2, R3; 
	u64 pcond;
	u64 pbody;
	cc_lex_lex();
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 14;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L5260;
L5260:
	return asu64(R1);
}

static u64 cc_parse_readdostmt() {
    u64 R1, R2, R3; 
	u64 pbody;
	u64 pcond;
	cc_lex_lex();
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	R1 = 77;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 15;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L5261;
L5261:
	return asu64(R1);
}

static u64 cc_parse_readreturnstmt() {
    u64 R1, R2; 
	u64 p;
	cc_lex_lex();
	R1 = 0;
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5264;
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5266;
	R1 = tou64("Can't return value in void function");
	cc_support_terror(asu64(R1));
L5266:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 9;
	cc_lib_checksymbol(asi64(R1));
	goto L5263;
L5264:
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5267;
	R1 = tou64("Return value needed");
	cc_support_terror(asu64(R1));
L5267:
L5263:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 9;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	goto L5262;
L5262:
	return asu64(R1);
}

static u64 cc_parse_readgotostmt() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 p;
	cc_lex_lex();
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 3;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5270;
	R1 = 14;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L5270:
	R1 = 0;
	R2 = 16;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_lex_lex();
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L5268;
L5268:
	return asu64(R1);
}

static u64 cc_parse_readswitchstmt() {
    u64 R1, R2, R3; 
	u64 pindex;
	u64 pstmt;
	u64 p;
	cc_lex_lex();
	asu64(R1) = cc_parse_readcond();
	pindex = asu64(R1);
	R1 = 3;
	asu64(R2) = pindex;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	R1 = 83;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pstmt = asu64(R1);
	asu64(R1) = pstmt;
	asu64(R2) = pindex;
	R3 = 22;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&cc_parse_casevaluestack;
	asi64(R2) = cc_parse_loopindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_parse_poploop();
	asu64(R1) = p;
	goto L5271;
L5271:
	return asu64(R1);
}

static u64 cc_parse_readcaselabel() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 value;
	cc_lex_lex();
	asi64(R1) = cc_parse_readconstintexpr();
	value = asi64(R1);
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readstatement();
	R2 = 18;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = value;
	cc_parse_addcasevalue(asi64(R1));
	asu64(R1) = p;
	goto L5272;
L5272:
	return asu64(R1);
}

static u64 cc_parse_readexprstmt() {
    u64 R1; 
	asu64(R1) = cc_parse_readexpression();
	goto L5273;
L5273:
	return asu64(R1);
}

static u64 cc_parse_readcond() {
    u64 R1; 
	u64 pcond;
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readexpression();
	pcond = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = pcond;
	goto L5274;
L5274:
	return asu64(R1);
}

static i64 cc_parse_isusertype(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5277;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5279;
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5275;
L5279:
	asu64(R1) = d;
	cc_parse_ist_symptr = asu64(R1);
L5277:
	R1 = 20;
	goto L5275;
L5275:
	return asi64(R1);
}

static u64 cc_parse_readlocaldecl() {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 m;
	i64 mbase;
	i64 linkage;
	i64 nitems;
	i64 wasenum;
	i64 wasdef;
	u64 d;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 pm;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	wasenum = asi64(R1);
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_currproc;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	nitems = asi64(R1);
L5281:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5283;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5283;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5283;
	goto L5284;
L5283:
	R1 = (u64)&nitems;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_currproc;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5286;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L5286:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5288;
	asi64(R1) = m;
	asu64(R2) = d;
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_parse_createtypedef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L5287;
L5288:
	asu64(R1) = pm;
	if (!asu64(R1)) goto L5289;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5291;
	R1 = tou64("Nested function");
	cc_support_serror(asu64(R1));
L5291:
	R1 = 0;
	R2 = (u64)&wasdef;
	asu64(R3) = pm;
	asi64(R4) = linkage;
	asi64(R5) = m;
	asu64(R6) = d;
	asu64(R1) = cc_parse_readfunction(asu64(R6), asi64(R5), asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L5287;
L5289:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readframevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 7;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L5287:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5293;
	goto L5294;
L5293:
	cc_lex_lex();
	goto L5292;
L5294:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5282;
L5292:
	goto L5281;
L5284:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5296;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5296;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5296;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5297;
	goto L5298;
L5296:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5282;
	goto L5295;
L5297:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5282;
	goto L5295;
L5298:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Local decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5295:
	goto L5281;
L5282:
	asu64(R1) = ulist;
	goto L5280;
L5280:
	return asu64(R1);
}

static u64 cc_parse_createtypedef(u64 owner, u64 symptr, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	asu64(R3) = symptr;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5301;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5303;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Typedef name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5303:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R2) = mode;
	if (asi64(R1) == asi64(R2)) goto L5305;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L5307;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Typedef redefined or can't match types #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5307:
L5305:
	asu64(R1) = d;
	goto L5299;
L5301:
	R1 = 5;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = d;
	R2 = (u64)&cc_decls_tttypedef;
	asi64(R3) = mode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = d;
	goto L5299;
L5299:
	return asu64(R1);
}

static u64 cc_parse_readparams(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	u64 ulist;
	u64 ulistx;
	u64 pm;
	u64 q;
	i64 m;
	i64 lastbasetype;
	i64 nparams;
	i64 variadic;
	i64 flags;
	i64 nnames;
	u64 d;
	i64 names;
	i64 nonames;
	i64 reported;
	R1 = 0;
	d = asu64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	R2 = R1;
	nnames = asi64(R2);
	R2 = R1;
	nparams = asi64(R2);
	variadic = asi64(R1);
	R1 = 0;
	lastbasetype = asi64(R1);
	R1 = 0;
	names = asi64(R1);
	R1 = 0;
	nonames = asi64(R1);
	R1 = 0;
	reported = asi64(R1);
	goto L5310;
L5309:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L5313;
	R1 = 1;
	variadic = asi64(R1);
	cc_lex_lex();
	goto L5311;
L5313:
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L5315;
	R1 = (u64)&lastbasetype;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 1;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = pm;
	if (!asu64(R1)) goto L5317;
	asu64(R1) = pm;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
L5317:
	goto L5314;
L5315:
	asi64(R1) = lastbasetype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5319;
	R1 = tou64("Param type missing or misspelt");
	cc_support_serror(asu64(R1));
L5319:
	R1 = 0;
	asi64(R2) = lastbasetype;
	R3 = (u64)&pm;
	R4 = 1;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
L5314:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5321;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5322;
	goto L5323;
L5321:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L5320;
L5322:
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L5320;
L5323:
L5320:
	R1 = 24;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pm;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	if (!asu64(R1)) goto L5325;
	R1 = 1;
	names = asi64(R1);
	goto L5324;
L5325:
	R1 = 1;
	nonames = asi64(R1);
L5324:
	asi64(R1) = names;
	if (!asi64(R1)) goto L5327;
	asi64(R1) = nonames;
	if (!asi64(R1)) goto L5327;
	asi64(R1) = reported;
	if (asi64(R1)) goto L5327;
	R1 = 1;
	reported = asi64(R1);
L5327:
	asu64(R1) = d;
	if (!asu64(R1)) goto L5329;
	R1 = (u64)&nnames;
	(*toi64p(R1)) += 1;
	asu64(R1) = ulist;
	q = asu64(R1);
	goto L5331;
L5330:
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L5334;
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Param name reused # #");
	cc_support_serror_ss(asu64(R3), asu64(R2), asu64(R1));
L5334:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5331:
	asu64(R1) = q;
	if (asu64(R1)) goto L5330;
L5329:
	asu64(R1) = pm;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5336;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L5337;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5337;
	goto L5338;
L5336:
	cc_lex_lex();
	goto L5335;
L5337:
	goto L5335;
L5338:
	R1 = tou64("bad symbol in paramlist");
	cc_support_serror(asu64(R1));
L5335:
L5310:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5309;
L5311:
	R1 = 0;
	flags = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	asi64(R1) = variadic;
	if (!asi64(R1)) goto L5340;
	R1 = 3;
	flags = asi64(R1);
	goto L5339;
L5340:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5341;
	R1 = 1;
	flags = asi64(R1);
	goto L5339;
L5341:
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5342;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5342;
	R1 = 2;
	flags = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	asu64(R2) = ulist;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5342:
L5339:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5344;
	R1 = 24;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	ulist = asu64(R1);
L5344:
	asi64(R1) = nparams;
	asu64(R2) = ulist;
	R3 = 20;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = flags;
	asu64(R2) = ulist;
	R3 = 22;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = ulist;
	goto L5308;
L5308:
	return asu64(R1);
}

static i64 cc_parse_readcasttype(u64 d, i64 allowname, u64 pm, i64 m, u64 mbase) {
    u64 R1, R2, R3, R4; 
	u64 owner;
	i64 linkage;
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L5347;
	asu64(R1) = cc_decls_currproc;
	goto L5346;
L5347:
	asu64(R1) = cc_decls_stmodule;
L5346:
	owner = asu64(R1);
	R1 = 0;
	linkage = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5349;
	R1 = (u64)&linkage;
	asu64(R2) = owner;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = mbase;
	if (!asu64(R1)) goto L5351;
	asi64(R1) = m;
	asu64(R2) = mbase;
	*toi64p(R2) = asi64(R1);
L5351:
L5349:
	R1 = 0;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5353;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5353;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5353;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5353;
	goto L5354;
L5353:
	asu64(R1) = pm;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R4) = owner;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	asu64(R1) = *tou64p(R1);
	if (!asu64(R1)) goto L5356;
	asi64(R1) = allowname;
	if (asi64(R1)) goto L5356;
	asu64(R1) = d;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("NAME not allowed in cast type #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5356:
	goto L5352;
L5354:
L5352:
	asi64(R1) = m;
	goto L5345;
L5345:
	return asi64(R1);
}

static u64 cc_parse_readfunction(u64 d, i64 m, i64 linkage, u64 pm, u64 wasdef, i64 exported) {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 owner;
	i64 scope;
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	R1 = 0;
	asu64(R2) = wasdef;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L5359;
	asu64(R1) = f;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5361;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("fn: name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5361:
	asu64(R1) = f;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5363;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5363;
	R1 = 4;
	scope = asi64(R1);
	goto L5362;
L5363:
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5364;
	R1 = 2;
	scope = asi64(R1);
L5364:
L5362:
	goto L5358;
L5359:
	R1 = 6;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5366;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5367;
	goto L5368;
L5366:
	R1 = 2;
	scope = asi64(R1);
	goto L5365;
L5367:
	R1 = 3;
	scope = asi64(R1);
	goto L5365;
L5368:
	R1 = 4;
	scope = asi64(R1);
L5365:
L5358:
	asu64(R1) = pm;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = exported;
	if (!asi64(R1)) goto L5370;
	R1 = 1;
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5370:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5372;
	R1 = 1;
	asu64(R2) = wasdef;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5374;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't define function twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5374:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5376;
	R1 = 4;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5376:
	asu64(R1) = d;
	cc_parse_readfunctionbody(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L5378;
	R1 = tou64("; after function def");
	cc_support_serror(asu64(R1));
L5378:
L5372:
	asu64(R1) = d;
	goto L5357;
L5357:
	return asu64(R1);
}

static void cc_parse_readfunctionbody(u64 f) {
    u64 R1, R2, R3; 
	u64 e;
	u64 p;
	u64 pm;
	i64 pmcount;
	i64 av_1;
	asu64(R1) = f;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	R2 = R1;
	cc_decls_currblockno = asi64(R2);
	cc_decls_nextblockno = asi64(R1);
	R1 = 0;
	pmcount = asi64(R1);
	asu64(R1) = f;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5382;
L5380:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5384;
	goto L5383;
L5384:
	R1 = 9;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = f;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) != asu64(R2)) goto L5386;
	R1 = 1;
	asu64(R2) = e;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5386:
	R1 = 1;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = pm;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L5383:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 1;
	pmcount = asi64(R1);
	if (--asi64(av_1)) goto L5380;
L5382:
	asi64(R1) = pmcount;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = cc_decls_currproc;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	cc_decls_currproc = asu64(R1);
	return;
}

static u64 cc_parse_createnegop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5389;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5391;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5391;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5391;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5392;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5393;
	goto L5394;
L5391:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L5387;
	goto L5390;
L5392:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	R2 = 4294967295;
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L5387;
	goto L5390;
L5393:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R1) = -asr64(R1);
	asu64(R2) = p;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = p;
	goto L5387;
	goto L5390;
L5394:
L5390:
L5389:
// cc_parse.createnegop.retry:
L5395:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5397;
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L5397;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 58;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L5396;
L5397:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5398;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L5395;
	goto L5396;
L5398:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("neg bad type");
	cc_support_terror(asu64(R1));
L5396:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L5387;
L5387:
	return asu64(R1);
}

static u64 cc_parse_createabsop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5401;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5403;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5403;
	goto L5404;
L5403:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L5399;
	goto L5402;
L5404:
L5402:
L5401:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5406;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 59;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L5405;
L5406:
	R1 = tou64("abs bad type");
	cc_support_terror(asu64(R1));
L5405:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L5399;
L5399:
	return asu64(R1);
}

static u64 cc_parse_createinotop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5409;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5411;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5411;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5411;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5411;
	goto L5412;
L5411:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = ~asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L5407;
	goto L5410;
L5412:
L5410:
L5409:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5414;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 60;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L5413;
L5414:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("! bad type");
	cc_support_terror(asu64(R1));
L5413:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L5407;
L5407:
	return asu64(R1);
}

static u64 cc_parse_createptrop(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 t;
	i64 m;
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5417;
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("* not pointer");
	cc_support_terror(asu64(R1));
L5417:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5419;
	goto L5420;
L5419:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = q;
	goto L5415;
	goto L5418;
L5420:
L5418:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R1) = cc_parse_arraytopointer(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = q;
	goto L5415;
L5415:
	return asu64(R1);
}

static u64 cc_parse_createincrop(i64 opc, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5424;
	asi64(R1) = t;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5423;
L5424:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5423;
	R1 = tou64("++ bad type");
	cc_support_terror(asu64(R1));
L5423:
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L5421;
L5421:
	return asu64(R1);
}

static u64 cc_parse_createaddrofop(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 q;
	i64 t;
	i64 u;
	i64 alength;
	R1 = 0;
	alength = asi64(R1);
// cc_parse.createaddrofop.restartx:
L5426:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5428;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
L5428:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5430;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5431;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5432;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5433;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5434;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5435;
	goto L5436;
L5430:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 108;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5438;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	alength = asi64(R1);
L5438:
	goto L5429;
L5431:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5440;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5440;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5425;
L5440:
	goto L5429;
L5432:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L5442;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5442;
	R1 = 3;
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R2) += asu64(R3);
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L5425;
L5442:
	goto L5443;
	goto L5429;
L5433:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5445;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&cc_decls_tttarget;
	asu64(R3) = p;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = cc_lib_createarraymode(asi64(R2), asi64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5425;
L5445:
	goto L5429;
L5434:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L5426;
	goto L5429;
L5435:
	asu64(R1) = p;
	goto L5425;
	goto L5429;
L5436:
// cc_parse.createaddrofop.cad1:
L5443:
	R1 = 0;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
L5429:
	asu64(R1) = p;
	R2 = 55;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = alength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5425;
L5425:
	return asu64(R1);
}

static u64 cc_parse_createaddop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	i64 elemsize;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 39;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5448;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5447;
L5448:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5449;
// cc_parse.createaddop.doaddref:
L5450:
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = u;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5452;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5452;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L5446;
L5452:
	R1 = 4;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 53;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemsize;
	asu64(R2) = z;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5446;
	goto L5447;
L5449:
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5453;
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	goto L5450;
	R1 = tou64("Sub bad types");
	cc_support_terror(asu64(R1));
L5453:
L5447:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5455;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5457;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_add(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5446;
	goto L5456;
L5457:
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L5456:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5459;
	asu64(R1) = x;
	goto L5446;
L5459:
L5455:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5446;
L5446:
	return asu64(R1);
}

static u64 cc_parse_createsubop(u64 x, u64 y) {
    u64 R1, R2, R3, R4, R5; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	i64 elemsize;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 40;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5462;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5461;
L5462:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5463;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5465;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = u;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	R1 = 4;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 54;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemsize;
	asu64(R2) = z;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5460;
	goto L5464;
L5465:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5467;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5467;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asu64(R4) = x;
	R5 = 52;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) -= asi64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = x;
	goto L5460;
	goto L5466;
L5467:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	R1 = 4;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = z;
	asu64(R1) = cc_parse_divunit(asu64(R2), asi64(R1));
	z = asu64(R1);
	R1 = 4;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5460;
L5466:
L5464:
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = y;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5461;
L5463:
	R1 = tou64("Sub bad types");
	cc_support_terror(asu64(R1));
L5461:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5469;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5469;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_sub(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5460;
L5469:
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5471;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5471;
L5471:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5460;
L5460:
	return asu64(R1);
}

static u64 cc_parse_createmulop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 41;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5474;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5473;
L5474:
	R1 = tou64("Mul bad types");
	cc_support_terror(asu64(R1));
L5473:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5476;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5478;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_mul(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5472;
	goto L5477;
L5478:
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L5477:
L5476:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5472;
L5472:
	return asu64(R1);
}

static u64 cc_parse_createdivop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 42;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5481;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5480;
L5481:
	R1 = tou64("Div bad types");
	cc_support_terror(asu64(R1));
L5480:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5483;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5483;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_div(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5479;
	goto L5482;
L5483:
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5484;
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5484;
	R1 = 41;
	opc = asi64(R1);
	asr64(R1) = 1.000000000000000000e+000;
	asu64(R2) = y;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) /= asr64(R2);
	asu64(R2) = y;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
L5484:
L5482:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5479;
L5479:
	return asu64(R1);
}

static u64 cc_parse_createremop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 43;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L5487;
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5490;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5489;
L5490:
	R1 = 3;
	u = asi64(R1);
L5489:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L5486;
L5487:
	R1 = tou64("Rem bad types");
	cc_support_terror(asu64(R1));
L5486:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5492;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5492;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_rem(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5485;
L5492:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5485;
L5485:
	return asu64(R1);
}

static void cc_parse_insertunit(u64 p, i64 tag) {
    u64 R1, R2, R3, R4; struct $B37 R1_B37; 
	u64 q;
	R1 = 0;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B37) = *(struct $B37*)(R1);
	asu64(R2) = q;
	*(struct $B37*)(R2) = (R1_B37);
	asi64(R1) = tag;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 56;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_parse_eval_add(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5496;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5496;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5496;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5496;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5497;
	goto L5498;
L5496:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L5494;
	goto L5495;
L5497:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) += asr64(R1);
	asu64(R1) = x;
	goto L5494;
	goto L5495;
L5498:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5500;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L5494;
L5500:
L5495:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5494;
L5494:
	return asu64(R1);
}

static u64 cc_parse_eval_sub(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5503;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5503;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5503;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5503;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5504;
	goto L5505;
L5503:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = x;
	goto L5501;
	goto L5502;
L5504:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) -= asr64(R1);
	asu64(R1) = x;
	goto L5501;
	goto L5502;
L5505:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5507;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5509;
	R1 = tou64("EVALSUB/REF");
	cc_support_terror(asu64(R1));
L5509:
	asu64(R1) = x;
	goto L5501;
L5507:
L5502:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5501;
L5501:
	return asu64(R1);
}

static u64 cc_parse_eval_mul(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5512;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5512;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5512;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5512;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5513;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5513;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5513;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5513;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5514;
	goto L5515;
L5512:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) *= asi64(R1);
	asu64(R1) = x;
	goto L5510;
	goto L5511;
L5513:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) *= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = x;
	goto L5510;
	goto L5511;
L5514:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) *= asr64(R1);
	asu64(R1) = x;
	goto L5510;
	goto L5511;
L5515:
L5511:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5510;
L5510:
	return asu64(R1);
}

static u64 cc_parse_eval_div(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5518;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5518;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5519;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5519;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5520;
	goto L5521;
L5518:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5523;
	R1 = tou64("div 0");
	cc_support_serror(asu64(R1));
L5523:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	goto L5516;
	goto L5517;
L5519:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5525;
	R1 = tou64("div 0");
	cc_support_serror(asu64(R1));
L5525:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = x;
	goto L5516;
	goto L5517;
L5520:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) /= asr64(R1);
	asu64(R1) = x;
	goto L5516;
	goto L5517;
L5521:
L5517:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5516;
L5516:
	return asu64(R1);
}

static u64 cc_parse_eval_rem(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5528;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5528;
	goto L5529;
L5528:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5531;
	R1 = tou64("rem 0");
	cc_support_serror(asu64(R1));
L5531:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) %= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	goto L5526;
	goto L5527;
L5529:
L5527:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L5526;
L5526:
	return asu64(R1);
}

static i64 cc_parse_eval_convert(u64 p, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	i64 s;
	asi64(R1) = opc;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5534;
// cc_parse.eval_convert.dosoft:
L5535:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
L5534:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5537;
	R1 = 1;
	goto L5532;
L5537:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5539;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5539;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5539;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5539;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5540;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5540;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5540;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5540;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5541;
	goto L5542;
L5539:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5544;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5544;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5545;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5545;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5545;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5545;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5545;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5545;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5545;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5545;
	goto L5546;
L5544:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = p;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
	goto L5543;
L5545:
// cc_parse.eval_convert.dotrunc:
L5547:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5549;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5550;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5551;
	goto L5552;
L5549:
	R1 = 255;
	asu64(R2) = p;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5554;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi8(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5554:
	goto L5548;
L5550:
	R1 = 65535;
	asu64(R2) = p;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5556;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi16(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5556:
	goto L5548;
L5551:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4294967295;
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5558;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5558:
	goto L5548;
L5552:
L5548:
	goto L5535;
	goto L5543;
L5546:
L5543:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5560;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
L5560:
	goto L5538;
L5540:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5562;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5562;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5563;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5563;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5563;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5563;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5563;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5563;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5563;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5563;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5563;
	goto L5564;
L5562:
	R1 = 0;
	goto L5532;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
	goto L5561;
L5563:
	goto L5547;
	goto L5561;
L5564:
L5561:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5566;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
L5566:
	goto L5538;
L5541:
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5568;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5568;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5569;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5569;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5570;
	goto L5571;
L5568:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
	goto L5567;
L5569:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
	goto L5567;
L5570:
	R1 = 10;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
	goto L5567;
L5571:
L5567:
	goto L5538;
L5542:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5573;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5575;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5577;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5577;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5577;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5577;
	goto L5578;
L5577:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L5532;
	goto L5576;
L5578:
L5576:
L5575:
L5573:
L5538:
	R1 = 0;
	goto L5532;
L5532:
	return asi64(R1);
}

static void cc_parse_coercecond(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5581;
	goto L5579;
L5581:
// cc_parse.coercecond.retry:
L5582:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5584;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5584;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5584;
	goto L5585;
L5584:
	goto L5586;
	goto L5583;
L5585:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5588;
// cc_parse.coercecond.doint:
L5586:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5590;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L5590;
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5589;
L5590:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5591;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L5591;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5589;
L5591:
	R1 = 27;
	asu64(R2) = p;
	cc_parse_insertunit(asu64(R2), asi64(R1));
L5589:
	goto L5587;
L5588:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5592;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L5582;
	goto L5587;
L5592:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	R2 = tou64("Invalid condition #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5587:
L5583:
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5579:
	return;
}

static void cc_parse_coercebasetype(u64 p) {
    u64 R1, R2; 
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5595;
	asi64(R1) = t;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L5595;
	R1 = 3;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L5594;
L5595:
	asi64(R1) = t;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L5596;
	asi64(R1) = t;
	R2 = 7;
	if (asi64(R1) > asi64(R2)) goto L5596;
	R1 = 8;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L5596:
L5594:
	return;
}

static void cc_parse_checklvalue(u64 p, i64 assign) {
    u64 R1, R2, R3, R4; struct $B37 R1_B37; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5599;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5600;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5601;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5602;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5603;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5604;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5605;
	goto L5606;
L5599:
	goto L5598;
L5600:
	goto L5598;
L5601:
	asi64(R1) = assign;
	if (!asi64(R1)) goto L5608;
	goto L5609;
L5608:
	goto L5598;
L5602:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5611;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5611;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5611;
	goto L5612;
L5611:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B37) = *(struct $B37*)(R1);
	asu64(R2) = p;
	*(struct $B37*)(R2) = (R1_B37);
	goto L5610;
L5612:
	R1 = tou64("CHECKLV/WIDEN");
	cc_support_terror(asu64(R1));
L5610:
	goto L5598;
L5603:
	goto L5598;
L5604:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5614;
	goto L5609;
L5614:
	goto L5598;
L5605:
	asi64(R1) = assign;
	if (!asi64(R1)) goto L5616;
	goto L5609;
L5616:
	goto L5598;
L5606:
// cc_parse.checklvalue.notlv:
L5609:
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("value: #");
	cc_support_terror_s(asu64(R2), asu64(R1));
L5598:
	return;
}

static u64 cc_parse_createcall(u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	u64 r;
	u64 s;
	u64 u;
	u64 d;
	u64 pm;
	i64 i;
	i64 nparams;
	i64 aparams;
	i64 retmode;
	i64 mproc;
	i64 m;
	i64 c;
	struct $B42 str;
	u64 ss;
	u64 tt;
	u64 uu;
	u64 exprstr;
	R1 = 0;
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5619;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5620;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5620;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5621;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L5621;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L5621;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5621;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L5621;
	goto L5622;
L5619:
// cc_parse.createcall.doptr:
L5623:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mproc = asi64(R1);
	goto L5625;
L5624:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mproc = asi64(R1);
	asi64(R1) = mproc;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	p = asu64(R1);
L5625:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5624;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5628;
	asi64(R1) = mproc;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Not function pointer: #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5628:
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = mproc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	retmode = asi64(R1);
	goto L5618;
L5620:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5630;
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	retmode = asi64(R1);
	goto L5629;
L5630:
	goto L5623;
L5629:
	goto L5618;
L5621:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	p = asu64(R1);
	goto L5623;
	goto L5618;
L5622:
	msysc_m$print_startcon();
	R1 = tou64("JTAGNAMES[P.TAG]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("ccall?");
	cc_support_serror(asu64(R1));
L5618:
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nparams = asi64(R1);
	R1 = 0;
	aparams = asi64(R1);
	asu64(R1) = q;
	s = asu64(R1);
	goto L5632;
L5631:
	R1 = (u64)&aparams;
	(*toi64p(R1)) += 1;
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
L5632:
	asu64(R1) = s;
	if (asu64(R1)) goto L5631;
	asi64(R1) = aparams;
	asi64(R2) = nparams;
	if (asi64(R1) >= asi64(R2)) goto L5635;
	R1 = tou64("1:Too few args");
	cc_support_terror(asu64(R1));
	goto L5634;
L5635:
	asi64(R1) = aparams;
	asi64(R2) = nparams;
	if (asi64(R1) <= asi64(R2)) goto L5636;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5636;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5636;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5638;
	msysc_m$print_startcon();
	asi64(R1) = aparams;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many args");
	cc_support_terror(asu64(R1));
L5638:
L5636:
L5634:
	asu64(R1) = q;
	s = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = aparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5641;
L5639:
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L5643;
	asu64(R1) = pm;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	cc_parse_coercemode_inplace(asu64(R2), asi64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	goto L5642;
L5643:
	asu64(R1) = s;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5645;
	R1 = tou64("Variadic param is void");
	cc_support_terror(asu64(R1));
L5645:
	asu64(R1) = s;
	cc_parse_coercebasetype(asu64(R1));
L5642:
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	i += 1; if (i <= aparams) goto L5639;
L5641:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 30;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	asi64(R1) = retmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	cc_parse_fixmemopnd(asu64(R1));
	asi64(R1) = aparams;
	asu64(R2) = r;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L5617;
L5617:
	return asu64(R1);
}

static u64 cc_parse_arraytopointer(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 offset;
	i64 t;
	i64 elemmode;
	i64 refmode;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5648;
	asi64(R1) = elemmode;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	refmode = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5650;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5651;
	goto L5652;
L5650:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L5649;
L5651:
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	R1 = 53;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 55;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = refmode;
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5649;
L5652:
	msysc_m$print_startcon();
	R1 = tou64("ATP:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("ATP?");
	cc_support_terror(asu64(R1));
L5649:
	asi64(R1) = refmode;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5648:
	asu64(R1) = p;
	goto L5646;
L5646:
	return asu64(R1);
}

static u64 cc_parse_createindexop(u64 p, u64 q) {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createaddop(asu64(R2), asu64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	goto L5653;
L5653:
	return asu64(R1);
}

static i64 cc_parse_readstructdecl(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 currrecord;
	u64 ulist;
	u64 ulistx;
	u64 tagowner;
	i64 funion;
	i64 linkage;
	i64 mbase;
	i64 m;
	i64 offset;
	i64 recsize;
	i64 maxsize;
	i64 maxalignment;
	i64 alignment;
	i64 size;
	u64 pm;
	u64 fieldlist;
	u64 fl;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 85;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	funion = asi64(R1);
	cc_lex_lex();
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L5656;
	asu64(R1) = cc_decls_currproc;
	goto L5655;
L5656:
	asu64(R1) = cc_decls_stmodule;
L5655:
	tagowner = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5658;
	asu64(R1) = cc_lib_nextautotype();
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	d = asu64(R1);
	goto L5657;
L5658:
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5660;
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = tagowner;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5662;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5664;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Struct tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5664:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5654;
L5662:
	R1 = 13;
	asu64(R2) = d;
	asu64(R3) = tagowner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = funion;
	if (!asi64(R1)) goto L5666;
	R1 = 19;
	goto L5665;
L5666:
	R1 = 18;
L5665:
	asu64(R2) = e;
	asi64(R1) = cc_lib_createstructmode(asu64(R2), asi64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5654;
L5660:
L5657:
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = tagowner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5668;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5670;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Struct tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5670:
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5672;
	msysc_m$print_startcon();
	R1 = tou64("Prev");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1677215;
	asi64(R1) &= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asu64(R2) = e;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asu64(R2) = e;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Redefining struct #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5672:
	goto L5667;
L5668:
	R1 = 13;
	asu64(R2) = d;
	asu64(R3) = tagowner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = funion;
	if (!asi64(R1)) goto L5674;
	R1 = 19;
	goto L5673;
L5674:
	R1 = 18;
L5673:
	asu64(R2) = e;
	asi64(R1) = cc_lib_createstructmode(asu64(R2), asi64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L5667:
	cc_lex_lex();
	asu64(R1) = e;
	currrecord = asu64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	R2 = R1;
	recsize = asi64(R2);
	R2 = R1;
	maxsize = asi64(R2);
	offset = asi64(R1);
	R1 = 1;
	maxalignment = asi64(R1);
	R1 = 0;
	fieldlist = asu64(R1);
	R1 = -1;
	m = asi64(R1);
	goto L5676;
L5675:
	R1 = (u64)&linkage;
	asu64(R2) = currrecord;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
L5678:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5680;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5680;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5680;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5681;
	goto L5682;
L5680:
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = currrecord;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5684;
	R1 = tou64("Field name expected");
	cc_support_serror(asu64(R1));
L5684:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5687;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L5686;
L5687:
	R1 = tou64("typedef or function inside struct");
	cc_support_serror(asu64(R1));
L5686:
	R1 = 0;
	R2 = 4;
	asu64(R3) = d;
	asu64(R4) = currrecord;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5689;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("member name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5689:
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5691;
	R1 = tou64("Can't use ss in struct");
	cc_support_serror(asu64(R1));
L5691:
// cc_parse.readstructdecl.addanonfield:
L5692:
	R1 = 10;
	asu64(R2) = d;
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = d;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistdef(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ulist;
	asu64(R2) = currrecord;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulistx;
	asu64(R2) = currrecord;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = currrecord;
	asu64(R2) = d;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asi64(R2) = maxalignment;
	if (asi64(R1) <= asi64(R2)) goto L5694;
	asi64(R1) = alignment;
	maxalignment = asi64(R1);
L5694:
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = cc_parse_roundoffset(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&recsize;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	asu64(R2) = d;
	R3 = (u64)&fieldlist;
	cc_parse_addnewfield(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = funion;
	if (!asi64(R1)) goto L5696;
	asi64(R1) = maxsize;
	asi64(R2) = size;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxsize = asi64(R1);
	goto L5695;
L5696:
	asi64(R1) = size;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&recsize;
	*toi64p(R2) += asi64(R1);
L5695:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5698;
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
L5698:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5700;
	goto L5701;
L5700:
	cc_lex_lex();
	goto L5699;
L5701:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5679;
L5699:
	goto L5678;
L5681:
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L5679;
	goto L5678;
L5682:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5703;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5703;
	goto L5704;
L5703:
	asu64(R1) = cc_lib_getautofieldname();
	d = asu64(R1);
	asi64(R1) = mbase;
	m = asi64(R1);
	goto L5692;
	goto L5702;
L5704:
	asi64(R1) = m;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5706;
	R1 = tou64("Struct decl error");
	cc_support_serror(asu64(R1));
	goto L5705;
L5706:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Struct decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5705:
L5702:
	goto L5678;
L5679:
L5676:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L5675;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = fieldlist;
	asu64(R2) = currrecord;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = maxalignment;
	asi64(R2) = funion;
	if (!asi64(R2)) goto L5708;
	asi64(R2) = maxsize;
	goto L5707;
L5708:
	asi64(R2) = recsize;
L5707:
	asi64(R1) = cc_parse_roundoffset(asi64(R2), asi64(R1));
	R2 = (u64)&cc_decls_ttsize;
	asu64(R3) = currrecord;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = maxalignment;
	asu64(R2) = currrecord;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = currrecord;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	m = asi64(R1);
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L5710;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_ttconsttype;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L5710:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = currrecord;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5713;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5713;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5713;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5712;
L5713:
	R1 = 0;
	R2 = (u64)&cc_decls_ttisblock;
	asu64(R3) = currrecord;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5712:
	asu64(R1) = currrecord;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5654;
L5654:
	return asi64(R1);
}

static i64 cc_parse_checkpointertypes(i64 s, i64 t, i64 hard) {
    u64 R1, R2, R3; 
	i64 starget;
	i64 ttarget;
	i64 sbase;
	i64 tbase;
	i64 sconst;
	i64 tconst;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	R1 = 0;
	sconst = asi64(R1);
	R1 = 0;
	tconst = asi64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = starget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5716;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = starget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = 1;
	sconst = asi64(R1);
L5716:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = ttarget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5718;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = ttarget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	R1 = 1;
	tconst = asi64(R1);
L5718:
	asi64(R1) = hard;
	if (asi64(R1)) goto L5720;
	asi64(R1) = sconst;
	if (!asi64(R1)) goto L5720;
	asi64(R1) = tconst;
	if (asi64(R1)) goto L5720;
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("const to non-const pointer");
	cc_support_terror(asu64(R1));
L5720:
	asi64(R1) = starget;
	asi64(R2) = ttarget;
	if (asi64(R1) != asi64(R2)) goto L5722;
	R1 = 1;
	goto L5714;
L5722:
	asi64(R1) = starget;
	s = asi64(R1);
	asi64(R1) = ttarget;
	t = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	sbase = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5724;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L5724;
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5724;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L5724;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = sbase;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = tbase;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) != asi64(R2)) goto L5726;
	R1 = 1;
	goto L5714;
L5726:
L5724:
	asi64(R1) = sbase;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5729;
	asi64(R1) = tbase;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5728;
L5729:
	R1 = 1;
	goto L5714;
L5728:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5731;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5731;
	asi64(R1) = hard;
	asi64(R2) = t;
	asi64(R3) = s;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L5714;
	goto L5730;
L5731:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5732;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5732;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) == asi64(R2)) goto L5734;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L5736;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L5736;
	msysc_m$print_startcon();
	R1 = tou64("BAD REF[]");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	goto L5714;
	R1 = 0;
	goto L5714;
L5736:
L5734:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	asi64(R1) = starget;
	asi64(R2) = ttarget;
	if (asi64(R1) != asi64(R2)) goto L5738;
	R1 = 1;
	goto L5714;
L5738:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = starget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5740;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = ttarget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5740;
	asi64(R1) = hard;
	asi64(R2) = ttarget;
	asi64(R3) = starget;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L5714;
L5740:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = starget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5742;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = ttarget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5742;
	asi64(R1) = hard;
	asi64(R2) = ttarget;
	asi64(R3) = starget;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L5714;
L5742:
	goto L5730;
L5732:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5743;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5743;
	R1 = 1;
	goto L5714;
L5743:
L5730:
	R1 = 0;
	goto L5714;
L5714:
	return asi64(R1);
}

static i64 cc_parse_comparemode(i64 s, i64 t) {
    u64 R1, R2, R3; 
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5746;
	R1 = 1;
	goto L5744;
L5746:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5748;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5748;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = s;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5750;
	R1 = 0;
	goto L5744;
L5750:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5753;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5753;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) != asi64(R2)) goto L5752;
L5753:
	R1 = 1;
	goto L5744;
L5752:
L5748:
	R1 = 0;
	goto L5744;
L5744:
	return asi64(R1);
}

static i64 cc_parse_readenumdecl(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5756;
	asu64(R1) = owner;
	cc_parse_readenumnames(asu64(R1));
	R1 = 12;
	goto L5754;
L5756:
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5758;
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5760;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5762;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Enum tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5762:
L5760:
	R1 = 12;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asi64(R1) = cc_lib_createenummode(asu64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5754;
L5758:
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L5764;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5766;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Enum tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5766:
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5768;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Redefining enum #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5768:
	goto L5763;
L5764:
	R1 = 12;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asi64(R1) = cc_lib_createenummode(asu64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L5763:
	asu64(R1) = owner;
	cc_parse_readenumnames(asu64(R1));
	asu64(R1) = e;
	R2 = (u64)&cc_decls_ttnamedef;
	asu64(R3) = e;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L5754;
L5754:
	return asi64(R1);
}

static void cc_parse_readenumnames(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 ulist;
	u64 ulistx;
	i64 enumseq;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	enumseq = asi64(R1);
	cc_lex_lex();
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5771;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5771;
	goto L5772;
L5771:
	goto L5770;
L5772:
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L5774;
	asu64(R1) = cc_decls_currproc;
	goto L5773;
L5774:
	asu64(R1) = cc_decls_stmodule;
L5773:
	owner = asu64(R1);
L5770:
	goto L5776;
L5775:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5779;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("enum name reused #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L5779:
	R1 = 11;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5781;
	cc_lex_lex();
	asi64(R1) = cc_parse_readconstintexpr();
	enumseq = asi64(R1);
L5781:
	asi64(R1) = enumseq;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&enumseq;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5783;
	cc_lex_lex();
L5783:
L5776:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5775;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	return;
}

static u64 cc_parse_createdotop(i64 opc, u64 p, u64 d) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 poffset;
	u64 pb;
	u64 pc;
	u64 e;
	u64 f;
	u64 prec;
	u64 panon;
	u64 pfield;
	u64 gend;
	i64 m;
	i64 offset;
	i64 scale;
	u64 fl;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = opc;
	R2 = 50;
	if (asi64(R1) != asi64(R2)) goto L5786;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5788;
	R1 = tou64("-> needs pointer");
	cc_support_serror(asu64(R1));
L5788:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
L5786:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5790;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5790;
	goto L5791;
L5790:
	goto L5789;
L5791:
	R1 = tou64(". -> not a struct");
	cc_support_serror(asu64(R1));
L5789:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	prec = asu64(R1);
	asu64(R1) = d;
	f = asu64(R1);
	goto L5793;
L5792:
	asu64(R1) = f;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = prec;
	if (asu64(R1) != asu64(R2)) goto L5796;
	asu64(R1) = f;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	goto L5794;
L5796:
L5793:
	asu64(R1) = f;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L5792;
L5794:
	asu64(R1) = f;
	if (asu64(R1)) goto L5798;
	asu64(R1) = d;
	gend = asu64(R1);
	goto L5800;
L5799:
	asu64(R1) = gend;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	gend = asu64(R1);
L5800:
	asu64(R1) = gend;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5799;
	asu64(R1) = prec;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fl = asu64(R1);
	goto L5803;
L5802:
	asu64(R1) = fl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = gend;
	if (asu64(R1) != asu64(R2)) goto L5806;
	asu64(R1) = fl;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	asu64(R1) = fl;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	offset = asi64(R1);
	goto L5804;
L5806:
	asu64(R1) = fl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fl = asu64(R1);
L5803:
	asu64(R1) = fl;
	if (asu64(R1)) goto L5802;
L5804:
L5798:
	asu64(R1) = f;
	if (asu64(R1)) goto L5808;
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field of struct # #");
	cc_support_terror_ss(asu64(R3), asu64(R2), asu64(R1));
L5808:
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	poffset = asu64(R1);
	asi64(R1) = opc;
	R2 = 50;
	if (asi64(R1) != asi64(R2)) goto L5810;
	asu64(R1) = p;
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	p = asu64(R1);
L5810:
	asu64(R1) = p;
	R2 = 49;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = f;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R1) = cc_parse_arraytopointer(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = p;
	goto L5784;
L5784:
	return asu64(R1);
}

static u64 cc_parse_mulunit(u64 p, i64 elemtype) {
    u64 R1, R2, R3; 
	i64 elemsize;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5813;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5815;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5814;
L5815:
	asu64(R1) = p;
	R2 = 57;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = elemsize;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5814:
L5813:
	asu64(R1) = p;
	goto L5811;
L5811:
	return asu64(R1);
}

static u64 cc_parse_divunit(u64 p, i64 elemtype) {
    u64 R1, R2, R3; 
	i64 elemsize;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5818;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5820;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5819;
L5820:
	asu64(R1) = p;
	R2 = 57;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = elemsize;
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5819:
L5818:
	asu64(R1) = p;
	goto L5816;
L5816:
	return asu64(R1);
}

static u64 cc_parse_createassignopref(i64 opc, u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	i64 pmode;
	i64 qmode;
	i64 rmode;
	i64 elemmode;
	u64 r;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	rmode = asi64(R2);
	pmode = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = pmode;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	asu64(R1) = q;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qmode = asi64(R1);
	asi64(R1) = opc;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5823;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5824;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5825;
	goto L5826;
L5823:
	asi64(R1) = pmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 11;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	goto L5822;
L5824:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = qmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5828;
	R1 = tou64("ptr+=ptr");
	cc_support_serror(asu64(R1));
L5828:
	R1 = 4;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 61;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	goto L5822;
L5825:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = qmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5830;
	asi64(R1) = qmode;
	asi64(R2) = pmode;
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L5832;
	R1 = tou64("-= refs don't match");
	cc_support_serror(asu64(R1));
L5832:
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R3) = p;
	R4 = 40;
	asu64(R2) = cc_lib_createunit2(asi64(R4), asu64(R3), asu64(R2));
	asu64(R1) = cc_parse_divunit(asu64(R2), asi64(R1));
	r = asu64(R1);
	R1 = 3;
	rmode = asi64(R1);
	goto L5829;
L5830:
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 62;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
L5829:
	goto L5822;
L5826:
	R1 = tou64("Not allowed on ptrs");
	cc_support_serror(asu64(R1));
L5822:
	asi64(R1) = rmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L5821;
L5821:
	return asu64(R1);
}

static void cc_parse_addnewfield(u64 flist, u64 d, i64 offset) {
    u64 R1, R2, R3; 
	u64 e;
	u64 f;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5835;
	R1 = 32;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	f = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = f;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5837;
L5836:
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L5837:
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5836;
	asu64(R1) = d;
	asu64(R2) = f;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = f;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = flist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = f;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = flist;
	*tou64p(R2) = asu64(R1);
	goto L5834;
L5835:
	R1 = (u64)&cc_decls_ttnamedef;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5840;
L5839:
	asi64(R1) = offset;
	asu64(R2) = e;
	R3 = 88;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	asu64(R3) = flist;
	cc_parse_addnewfield(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5840:
	asu64(R1) = e;
	if (asu64(R1)) goto L5839;
L5834:
	return;
}

static void cc_parse_pushloop(i64 looptype) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_parse_loopindex;
	R2 = 64;
	if (asi64(R1) < asi64(R2)) goto L5844;
	R1 = tou64("Too many nested loop or switch");
	cc_support_serror(asu64(R1));
L5844:
	R1 = (u64)&cc_parse_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = looptype;
	R2 = (u64)&cc_parse_looptypestack;
	asi64(R3) = cc_parse_loopindex;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_parse_casevaluestack;
	asi64(R3) = cc_parse_loopindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void cc_parse_poploop() {
    u64 R1; 
	asi64(R1) = cc_parse_loopindex;
	if (!asi64(R1)) goto L5847;
	R1 = (u64)&cc_parse_loopindex;
	(*toi64p(R1)) -=1;
	goto L5846;
L5847:
	R1 = tou64("poploop?");
	cc_support_serror(asu64(R1));
L5846:
	return;
}

static void cc_parse_addcasevalue(i64 value) {
    u64 R1, R2, R3; 
	u64 p;
	i64 index;
	asi64(R1) = cc_parse_loopindex;
	index = asi64(R1);
	goto L5850;
L5849:
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
L5850:
	asi64(R1) = index;
	if (!asi64(R1)) goto L5852;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L5849;
L5852:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5854;
	R1 = tou64("case not inside switch stmt");
	cc_support_serror(asu64(R1));
L5854:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&cc_parse_casevaluestack;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&cc_parse_casevaluestack;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static i64 cc_parse_roundoffset(i64 offset, i64 alignment) {
    u64 R1, R2; 
	i64 mask;
	asi64(R1) = cc_decls_structpadding;
	if (!asi64(R1)) goto L5857;
	asi64(R1) = alignment;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5859;
	asi64(R1) = offset;
	goto L5855;
L5859:
	asi64(R1) = alignment;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mask = asi64(R1);
	goto L5861;
L5860:
	R1 = (u64)&offset;
	(*toi64p(R1)) += 1;
L5861:
	asi64(R1) = offset;
	asi64(R2) = mask;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L5860;
L5857:
	asi64(R1) = offset;
	goto L5855;
L5855:
	return asi64(R1);
}

static void cc_parse_fixmemopnd(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	asu8(R1) = cc_parse_ingeneric;
	if (!asu8(R1)) goto L5865;
	goto L5863;
L5865:
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5867;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5867;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5867;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5867;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5867;
	goto L5868;
L5867:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 56;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5866;
L5868:
L5866:
L5863:
	return;
}

static u64 cc_parse_docast(u64 p, i64 t, i64 hard, i64 inplace) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 s;
	i64 opc;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
// cc_parse.docast.retry:
L5870:
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5872;
	asu64(R1) = p;
	goto L5869;
L5872:
	R1 = 0;
	opc = asi64(R1);
	asi64(R1) = s;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L5874;
	asi64(R1) = t;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L5874;
	R1 = (u64)&cc_tables_conversionops;
	asi64(R2) = s;
	R1 += (i64)R2*16;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L5873;
L5874:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5875;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5875;
	asi64(R1) = hard;
	asi64(R2) = t;
	asi64(R3) = s;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L5877;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5869;
L5877:
	goto L5873;
L5875:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5878;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	goto L5870;
	goto L5873;
L5878:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5879;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L5870;
	goto L5873;
L5879:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5880;
	asi64(R1) = s;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L5880;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5880;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5880;
	R1 = 1;
	opc = asi64(R1);
L5880:
L5873:
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5882;
	asi64(R1) = hard;
	if (asi64(R1)) goto L5884;
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = t;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asi64(R2) = s;
	asu64(R2) = cc_lib_typename(asi64(R2));
	R3 = tou64("Can't do conversion # => #");
	cc_support_terror_ss(asu64(R3), asu64(R2), asu64(R1));
L5884:
	R1 = 2;
	opc = asi64(R1);
L5882:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5886;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5887;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5888;
	goto L5889;
L5886:
	asi64(R1) = opc;
	asi64(R2) = t;
	asu64(R3) = p;
	asi64(R1) = cc_parse_eval_convert(asu64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L5891;
	asu64(R1) = p;
	goto L5869;
L5891:
	goto L5885;
L5887:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5869;
	goto L5885;
L5888:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5893;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5893;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L5869;
L5893:
	goto L5885;
L5889:
L5885:
	asi64(R1) = inplace;
	if (!asi64(R1)) goto L5895;
	R1 = 56;
	asu64(R2) = p;
	cc_parse_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 58;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = t;
	asi64(R1) = cc_parse_getpromotedtype(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	goto L5869;
	goto L5894;
L5895:
	asu64(R1) = p;
	R2 = 56;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = q;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asu64(R2) = q;
	R3 = 58;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = t;
	asi64(R1) = cc_parse_getpromotedtype(asi64(R1));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5894:
	asu64(R1) = q;
	goto L5869;
L5869:
	return asu64(R1);
}

static u64 cc_parse_coercemode(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 s;
	i64 opc;
	u64 q;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5898;
	asu64(R1) = p;
	goto L5896;
L5898:
	R1 = 1;
	R2 = 0;
	asi64(R3) = t;
	asu64(R4) = p;
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	goto L5896;
L5896:
	return asu64(R1);
}

static void cc_parse_coercemode_inplace(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 s;
	i64 opc;
	u64 q;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L5901;
	goto L5899;
L5901:
	R1 = 1;
	R2 = 0;
	asi64(R3) = t;
	asu64(R4) = p;
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L5899:
	return;
}

static u64 cc_parse_createsizeofop(u64 p, i64 islength) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 t;
	i64 size;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L5904;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5904;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5904;
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("Not array");
	cc_support_serror(asu64(R1));
L5904:
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5906;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5907;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5908;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5909;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5910;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5911;
	goto L5912;
L5906:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5914;
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	goto L5913;
L5914:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5913:
	goto L5905;
L5907:
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) == asi64(R2)) goto L5916;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) == asi64(R2)) goto L5917;
	goto L5918;
L5916:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L5915;
L5917:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	goto L5915;
L5918:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5915:
	goto L5905;
L5908:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5920;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5920;
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	goto L5919;
L5920:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5919:
	goto L5905;
L5909:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5922;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L5924;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L5923;
L5924:
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
L5923:
	goto L5921;
L5922:
	goto L5925;
L5921:
	goto L5905;
L5910:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5927;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5927;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L5929;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L5928;
L5929:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5928:
	goto L5926;
L5927:
	R1 = 8;
	size = asi64(R1);
L5926:
	goto L5905;
L5911:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	goto L5902;
	goto L5905;
L5912:
// cc_parse.createsizeofop.cad1:
L5925:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L5905:
	R1 = 9;
	asi64(R2) = size;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	goto L5902;
L5902:
	return asu64(R1);
}

static u64 cc_parse_readgeneric() {
    u64 R1, R2, R3, R4, R5; 
	u64 pexpr;
	u64 pmatch;
	u64 p;
	u64 pm;
	i64 m;
	i64 t;
	i64 def;
	i64 oldingeneric;
	i64 count;
	u64 d;
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu8(R1) = cc_parse_ingeneric;
	R1 = toi64(tou8(R1));
	oldingeneric = asi64(R1);
	R1 = 1;
	cc_parse_ingeneric = asu8(R1);
	asu64(R1) = cc_parse_readassignexpr();
	pexpr = asu64(R1);
	asi64(R1) = oldingeneric;
	cc_parse_ingeneric = asu8(R1);
	asu64(R1) = pexpr;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = 0;
	pmatch = asu64(R1);
	R1 = 0;
	def = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	R1 = 8;
	cc_lib_checksymbol(asi64(R1));
L5931:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) != asi64(R2)) goto L5935;
	asi64(R1) = def;
	if (!asi64(R1)) goto L5937;
	R1 = tou64("generic/default twice");
	cc_support_serror(asu64(R1));
L5937:
	R1 = 1;
	def = asi64(R1);
	asi64(R1) = count;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5939;
	R1 = -1;
	t = asi64(R1);
	goto L5938;
L5939:
	R1 = -2;
	t = asi64(R1);
L5938:
	cc_lex_lex();
	goto L5934;
L5935:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
L5934:
	R1 = 10;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = t;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L5942;
	asi64(R1) = t;
	asi64(R2) = m;
	if (asi64(R1) != asi64(R2)) goto L5941;
L5942:
	asu64(R1) = p;
	pmatch = asu64(R1);
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
L5941:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5931;
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = pmatch;
	if (asu64(R1)) goto L5944;
	R1 = tou64("Generic: no type match");
	cc_support_serror(asu64(R1));
L5944:
	asi64(R1) = count;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L5946;
	R1 = tou64("Generic: multiple types match");
	cc_support_serror(asu64(R1));
L5946:
	asu64(R1) = pmatch;
	goto L5930;
L5930:
	return asu64(R1);
}

static i64 cc_parse_getmemmode(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5949;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L5948;
L5949:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
L5948:
	goto L5947;
L5947:
	return asi64(R1);
}

static i64 cc_parse_getpromotedtype(i64 t) {
    u64 R1, R2; 
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5952;
	R1 = 0;
	goto L5950;
L5952:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L5954;
	R1 = 3;
	goto L5950;
L5954:
	asi64(R1) = t;
	goto L5950;
L5950:
	return asi64(R1);
}

static i64 cc_parse_readdllexport() {
    u64 R1, R2, R3; 
	i64 exported;
	R1 = 0;
	exported = asi64(R1);
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L5957;
	R1 = tou64("dllexport");
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5957;
	R1 = 1;
	exported = asi64(R1);
L5957:
	cc_lex_lex();
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asi64(R1) = exported;
	goto L5955;
L5955:
	return asi64(R1);
}

static void cc_genpcl_codegen_pcl() {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	u64 pp;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5960;
	msysc_m$print_startcon();
	R1 = tou64("GenPCL:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5960:
	asi64(R1) = cc_decls_nunits;
	R2 = 0;
	asu64(R1) = pc_api_pcl_start(asu64(R2), asi64(R1));
	cc_genpcl_dolibs();
	R1 = tou64("1:Start of code");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5962;
L5961:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5965;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5966;
	goto L5967;
L5965:
	asu64(R1) = d;
	cc_genpcl_dostaticvar(asu64(R1));
	goto L5964;
L5966:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5969;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5970;
	goto L5971;
L5969:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5973;
	R1 = 3;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5973:
	goto L5968;
L5970:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5975;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Static fn not defined: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5975:
	goto L5968;
L5971:
L5968:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5977;
L5976:
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5980;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5981;
	goto L5982;
L5980:
	asu64(R1) = e;
	cc_genpcl_dostaticvar(asu64(R1));
	goto L5979;
L5981:
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5984;
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5987;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = e;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5986;
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5986;
L5987:
	asu64(R1) = e;
	cc_genpcl_dostaticvar(asu64(R1));
L5986:
L5984:
	goto L5979;
L5982:
L5979:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5977:
	asu64(R1) = e;
	if (asu64(R1)) goto L5976;
	goto L5964;
L5967:
L5964:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L5962:
	asu64(R1) = d;
	if (asu64(R1)) goto L5961;
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5989;
L5988:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5992;
	goto L5993;
L5992:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5995;
	asu64(R1) = d;
	cc_genpcl_genprocdef(asu64(R1));
L5995:
	goto L5991;
L5993:
L5991:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L5989:
	asu64(R1) = d;
	if (asu64(R1)) goto L5988;
	pc_api_pcl_end();
	return;
}

static void cc_genpcl_genprocdef(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	u64 e;
	u64 pm;
	i64 ismain;
	R1 = 0;
	ismain = asi64(R1);
	R1 = tou64("main");
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5998;
	R1 = 1;
	ismain = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5998:
	asu64(R1) = p;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	asi64(R2) = ismain;
	R3 = 0;
	asu64(R4) = p;
	asu64(R4) = cc_libpcl_getpsymbol(asu64(R4));
	R5 = R4;
	e = asu64(R5);
	pc_api_pc_defproc(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = e;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L6002;
L5999:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6004;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6005;
	goto L6006;
L6004:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	goto L6003;
L6005:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addlocal(asu64(R1));
	goto L6003;
L6006:
L6003:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L6002:
	asu64(R1) = d;
	if (asu64(R1)) goto L5999;
	asi64(R1) = cc_libpcl_createfwdlabel();
	cc_genpcl_retindex = asi64(R1);
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_stmt(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = ismain;
	if (!asi64(R1)) goto L6008;
	asu8(R1) = pepcl_pdcc;
	if (!asu8(R1)) goto L6008;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = cc_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
L6008:
	asi64(R1) = cc_genpcl_retindex;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = ismain;
	if (!asi64(R1)) goto L6010;
	asu8(R1) = pepcl_pdcc;
	if (asu8(R1)) goto L6010;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6010:
	R1 = 0;
	asu64(R2) = p;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	if (asi64(R2) == asi64(R3)) goto L6012;
	R2 = 23;
	goto L6011;
L6012:
	R2 = 20;
L6011:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	pc_api_pc_endproc();
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	return;
}

static void cc_genpcl_dostaticvar(u64 d) {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 str;
	i64 align;
	u64 e;
	u64 p;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6015;
	goto L6013;
L6015:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	align = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6017;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L6019;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$#.#.#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 7;
	R2 = (u64)&str;
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = d;
	R3 = 114;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6018;
L6019:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6018:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = align;
	pc_api_pc_setalign(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 1;
	asu64(R4) = d;
	R5 = 72;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L6016;
L6017:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 124;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = align;
	pc_api_pc_setalign(asi64(R1));
L6016:
L6013:
	return;
}

static void cc_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset) {
    u64 R1, R2, R3, R4, R5; 
	i64 t;
	i64 length;
	i64 n;
	i64 i;
	i64 j;
	i64 nwords;
	i64 offset1;
	i64 offset2;
	i64 size;
	i64 padding;
	i64 isunion;
	u64 q;
	u64 a;
	u64 b;
	u64 d;
	r32 sx;
	struct $B16 str;
	struct $B3 str2;
	i64 av_1;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6022;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6023;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6024;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6024;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6025;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L6026;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6027;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L6027;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6028;
	goto L6029;
L6022:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6031;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6034;
L6032:
	R1 = 0;
	R2 = 1;
	R3 = 1;
	asu64(R4) = q;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= n) goto L6032;
L6034:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L6036;
	asi64(R1) = length;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
L6036:
	goto L6030;
L6031:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 19;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isunion = asi64(R1);
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	R1 = 0;
	R2 = R1;
	offset2 = asi64(R2);
	offset1 = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6039;
L6037:
	R1 = 0;
	R2 = 1;
	R3 = 0;
	asu64(R4) = q;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = q;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&offset1;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L6041;
	asi64(R1) = isunion;
	if (asi64(R1)) goto L6041;
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset2 = asi64(R1);
	goto L6040;
L6041:
	asi64(R1) = size;
	offset2 = asi64(R1);
L6040:
	asi64(R1) = offset2;
	asi64(R2) = offset1;
	asi64(R1) -= asi64(R2);
	padding = asi64(R1);
	asi64(R1) = padding;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6043;
	asi64(R1) = offset2;
	asi64(R2) = offset1;
	asi64(R1) -= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
	asi64(R1) = offset2;
	offset1 = asi64(R1);
L6043:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= n) goto L6037;
L6039:
	asi64(R1) = offset2;
	asi64(R2) = size;
	if (asi64(R1) >= asi64(R2)) goto L6045;
	asi64(R1) = size;
	asi64(R2) = offset2;
	asi64(R1) -= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
L6045:
L6030:
	goto L6020;
	goto L6021;
L6023:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (asi64(R1)) goto L6048;
	asi64(R1) = t;
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L6047;
L6048:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6050;
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	sx = asr32(R1);
	R1 = (u64)&sx;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6049;
L6050:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6049:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	goto L6046;
L6047:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6051;
	R1 = 0;
	padding = asi64(R1);
// cc_genpcl.genidata.doref:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6054;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6053;
L6054:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6055;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genstring(asu64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6053;
L6055:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6056;
	R1 = 0;
	R2 = tou64("GENIDATA/WSTRING2");
	cc_support_gerror(asu64(R2), asu64(R1));
	asi64(R1) = padding;
	cc_genpcl_doresb(asi64(R1));
	goto L6053;
L6056:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6053:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	goto L6046;
L6051:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6057;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	padding = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6060;
L6058:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 6;
	cc_libpcl_setmode(asi64(R1));
	i += 1; if (i <= av_1) goto L6058;
L6060:
	asi64(R1) = padding;
	cc_genpcl_doresb(asi64(R1));
	goto L6046;
L6057:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("IDATA/SCALAR");
	cc_support_gerror(asu64(R2), asu64(R1));
L6046:
	goto L6020;
	goto L6021;
L6024:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6062;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6062;
	goto L6063;
L6062:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L6061;
L6063:
	asu64(R1) = p;
	R2 = tou64("Idata &frame");
	cc_support_gerror(asu64(R2), asu64(R1));
L6061:
	goto L6020;
	goto L6021;
L6025:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6065;
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6065;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6067;
	goto L6068;
L6067:
	R1 = tou64("`");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6070;
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(",");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6070:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("+");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	asu64(R2) = b;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = pc_api_genname(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6066;
L6068:
	R1 = 0;
	R2 = tou64("Add/Idata &frame");
	cc_support_gerror(asu64(R2), asu64(R1));
L6066:
	goto L6064;
L6065:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6071;
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6071;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6071;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64("+");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = pc_api_genname(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6064;
L6071:
	R1 = 0;
	R2 = tou64("1:Runtime or unsupported expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L6064:
	goto L6020;
	goto L6021;
L6026:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L6073;
	asi64(R1) = offset;
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L6072;
L6073:
	asi64(R1) = offset;
	R2 = 0;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L6072:
	goto L6021;
L6027:
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6075;
	R1 = 0;
	R2 = tou64("Complex ptr expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L6075:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L6021;
L6028:
	asi64(R1) = offset;
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L6021;
L6029:
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = tou64("2:Runtime expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L6021:
L6020:
	return;
}

static void cc_genpcl_doresb(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	goto L6078;
L6077:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
L6078:
	asi64(R1) = n;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L6077;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6082;
L6080:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 6;
	cc_libpcl_setmode(asi64(R1));
	if (--asi64(av_1)) goto L6080;
L6082:
	return;
}

static void cc_genpcl_pushint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_genpcl_dolibs() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6087;
L6085:
	R1 = (u64)&cc_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pc_api_pc_addplib(asu64(R1));
	i += 1; if (i <= cc_decls_nlibfiles) goto L6085;
L6087:
	return;
}

static void cc_blockpcl_do_stmt(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 oldclineno;
	u64 a;
	u64 b;
	u64 d;
	asu64(R1) = p;
	if (asu64(R1)) goto L6090;
	goto L6088;
L6090:
	asi64(R1) = cc_decls_clineno;
	oldclineno = asi64(R1);
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_clineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_decls_cfileno = asi64(R1);
	asi64(R1) = cc_decls_cfileno;
	R2 = 24;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = cc_decls_clineno;
	asi64(R1) += asi64(R2);
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 6: goto L6094;
	case 7: case 10: case 24: case 25: case 26: case 27: case 28: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: goto L6093;
	case 8: goto L6098;
	case 9: goto L6100;
	case 11: goto L6101;
	case 12: case 31: goto L6102;
	case 13: goto L6103;
	case 14: goto L6104;
	case 15: goto L6105;
	case 16: goto L6106;
	case 17: goto L6107;
	case 18: goto L6108;
	case 19: goto L6109;
	case 20: goto L6111;
	case 21: goto L6112;
	case 22: goto L6113;
	case 23: goto L6110;
	case 29: goto L6128;
	case 30: goto L6099;
	case 61: goto L6114;
	case 62: goto L6115;
	case 63: goto L6116;
	case 64: goto L6117;
	case 65: goto L6120;
	case 66: goto L6121;
	case 67: goto L6122;
	case 68: goto L6123;
	case 69: goto L6124;
	case 70: goto L6125;
	case 71: case 73: goto L6126;
	case 72: case 74: goto L6127;
	default: goto L6093;
    };
// SWITCH
L6094:
	goto L6096;
L6095:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L6096:
	asu64(R1) = a;
	if (asu64(R1)) goto L6095;
	goto L6091;
L6098:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_decl(asu64(R1));
	goto L6091;
L6099:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_call(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6091;
L6100:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_do_return(asu64(R2), asu64(R1));
	goto L6091;
L6101:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_assign(asu64(R3), asu64(R2), asi64(R1));
	goto L6091;
L6102:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_if(asu64(R3), asu64(R2), asu64(R1));
	goto L6091;
L6103:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_for(asu64(R2), asu64(R1));
	goto L6091;
L6104:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_while(asu64(R2), asu64(R1));
	goto L6091;
L6105:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_dowhile(asu64(R2), asu64(R1));
	goto L6091;
L6106:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_goto(asu64(R1));
	goto L6091;
L6107:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_labeldef(asu64(R1));
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L6091;
L6108:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_do_casestmt(asu64(R2), asu64(R1));
	goto L6091;
L6109:
	R1 = 1;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = cc_blockpcl_sw_defaultlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L6091;
L6110:
	asi64(R1) = cc_blockpcl_sw_breaklabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L6091;
L6111:
	R1 = (u64)&cc_blockpcl_breakstack;
	asi64(R2) = cc_blockpcl_loopindex;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	cc_blockpcl_genjumpl(asi64(R1));
	goto L6091;
L6112:
	R1 = (u64)&cc_blockpcl_continuestack;
	asi64(R2) = cc_blockpcl_loopindex;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	cc_blockpcl_genjumpl(asi64(R1));
	goto L6091;
L6113:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_do_switch(asu64(R3), asu64(R2), asu64(R1));
	goto L6091;
L6114:
	R1 = 0;
	R2 = 90;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6115:
	R1 = 0;
	R2 = 91;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6116:
	R1 = 0;
	R2 = 92;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6117:
	R1 = 0;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = cc_lib_isrealcc(asi64(R2));
	if (!asi64(R2)) goto L6119;
	R2 = 93;
	goto L6118;
L6119:
	R2 = 94;
L6118:
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6120:
	R1 = 0;
	R2 = 95;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6121:
	R1 = 0;
	R2 = 96;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6122:
	R1 = 0;
	R2 = 97;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6123:
	R1 = 0;
	R2 = 98;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6124:
	R1 = 0;
	R2 = 99;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6125:
	R1 = 0;
	R2 = 100;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6091;
L6126:
	R1 = 84;
	asu64(R2) = a;
	cc_blockpcl_do_preincr(asu64(R2), asi64(R1));
	goto L6091;
L6127:
	R1 = 85;
	asu64(R2) = a;
	cc_blockpcl_do_preincr(asu64(R2), asi64(R1));
	goto L6091;
L6128:
	goto L6130;
L6129:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L6130:
	asu64(R1) = a;
	if (asu64(R1)) goto L6129;
	goto L6091;
L6093:
	R1 = 0;
	asu64(R2) = p;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L6133;
	asu64(R1) = a;
	goto L6132;
L6133:
	asu64(R1) = p;
L6132:
	cc_libpcl_setmode_u(asu64(R1));
L6091:
L6088:
	return;
}

static void cc_blockpcl_dx_expr(u64 p, i64 am) {
    u64 R1, R2, R3, R4, R5; 
	i64 oldclineno;
	i64 value;
	i64 m;
	u64 a;
	u64 b;
	struct $B16 str;
	u64 d;
	asu64(R1) = p;
	if (asu64(R1)) goto L6136;
	goto L6134;
L6136:
	asi64(R1) = cc_decls_clineno;
	oldclineno = asi64(R1);
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_clineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_decls_cfileno = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 1: goto L6140;
	case 2: case 6: case 7: case 8: case 9: case 10: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 28: case 32: case 50: case 51: case 59: goto L6139;
	case 3: goto L6141;
	case 4: goto L6142;
	case 5: goto L6143;
	case 11: goto L6144;
	case 24: case 25: goto L6145;
	case 26: goto L6146;
	case 27: goto L6153;
	case 29: goto L6156;
	case 30: goto L6167;
	case 31: goto L6168;
	case 33: case 34: case 35: case 36: case 37: case 38: goto L6169;
	case 39: goto L6170;
	case 40: goto L6173;
	case 41: goto L6174;
	case 42: goto L6175;
	case 43: goto L6178;
	case 44: goto L6179;
	case 45: goto L6180;
	case 46: goto L6181;
	case 47: goto L6182;
	case 48: goto L6183;
	case 49: goto L6206;
	case 52: goto L6184;
	case 53: goto L6185;
	case 54: goto L6186;
	case 55: goto L6205;
	case 56: goto L6187;
	case 57: goto L6190;
	case 58: goto L6191;
	case 60: goto L6192;
	case 61: goto L6195;
	case 62: goto L6196;
	case 63: goto L6197;
	case 64: goto L6198;
	case 65: goto L6199;
	case 66: goto L6200;
	case 67: goto L6201;
	case 68: goto L6202;
	case 69: goto L6203;
	case 70: goto L6204;
	case 71: case 72: goto L6193;
	case 73: case 74: goto L6194;
	case 75: goto L6207;
	case 76: goto L6208;
	default: goto L6139;
    };
// SWITCH
L6140:
	asu64(R1) = p;
	cc_blockpcl_dx_const(asu64(R1));
	goto L6137;
L6141:
	asi64(R1) = am;
	asu64(R2) = p;
	cc_blockpcl_dx_name(asu64(R2), asi64(R1));
	goto L6137;
L6142:
	asi64(R1) = am;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	goto L6137;
L6143:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L6137;
L6144:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_assign(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6145:
	asu64(R1) = p;
	cc_blockpcl_dx_andorl(asu64(R1));
	goto L6137;
L6146:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L6148;
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = cc_blockpcl_isboolexpr(asu64(R1));
	if (asi64(R1)) goto L6150;
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode2(asi64(R1));
L6150:
	goto L6147;
L6148:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_blockpcl_isboolexpr(asu64(R1));
	if (asi64(R1)) goto L6152;
	R1 = 0;
	R2 = 65;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6151;
L6152:
	R1 = 0;
	R2 = 63;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6151:
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
L6147:
	goto L6137;
L6153:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_blockpcl_isboolexpr(asu64(R1));
	if (asi64(R1)) goto L6155;
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode2(asi64(R1));
L6155:
	goto L6137;
L6156:
	goto L6160;
L6157:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L6162;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6163;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6163;
	R2 = 31;
	if (asi64(R1) != asi64(R2)) goto L6162;
L6163:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L6161;
L6162:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L6165;
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6166;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L6165;
L6166:
	R1 = 0;
	R2 = 134;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6165:
L6161:
	asu64(R1) = b;
	a = asu64(R1);
L6160:
	asu64(R1) = a;
	if (asu64(R1)) goto L6157;
	goto L6137;
L6167:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_call(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6168:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_ifx(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6137;
L6169:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_eq(asu64(R3), asu64(R2), asu64(R1));
	goto L6137;
L6170:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6172;
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = b;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L6172;
	R1 = 9;
	asu64(R2) = b;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6172:
	R1 = 43;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6173:
	R1 = 44;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6174:
	R1 = 45;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6175:
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L6177;
	R1 = 46;
	goto L6176;
L6177:
	R1 = 47;
L6176:
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6178:
	R1 = 48;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6179:
	R1 = 50;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6180:
	R1 = 51;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6181:
	R1 = 52;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6182:
	R1 = 53;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6183:
	R1 = 54;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6184:
	asi64(R1) = am;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_ptr(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6185:
	asi64(R1) = am;
	R2 = 57;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	cc_blockpcl_dx_addptr(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6186:
	asi64(R1) = am;
	R2 = 58;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	cc_blockpcl_dx_addptr(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6187:
	asu64(R1) = p;
	R2 = 58;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6189;
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	goto L6188;
L6189:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 58;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_convert(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L6188:
	goto L6137;
L6190:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_scale(asu64(R3), asu64(R2), asu64(R1));
	goto L6137;
L6191:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 60;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	goto L6137;
L6192:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 62;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	goto L6137;
L6193:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_dx_preincrx(asu64(R2), asu64(R1));
	goto L6137;
L6194:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_dx_postincrx(asu64(R2), asu64(R1));
	goto L6137;
L6195:
	R1 = 1;
	R2 = 90;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6196:
	R1 = 1;
	R2 = 91;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6197:
	R1 = 1;
	R2 = 92;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6198:
	R1 = 1;
	R2 = 93;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6199:
	R1 = 1;
	R2 = 95;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6200:
	R1 = 1;
	R2 = 96;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6201:
	R1 = 1;
	R2 = 97;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6202:
	R1 = 1;
	R2 = 98;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6203:
	R1 = 1;
	R2 = 99;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6204:
	R1 = 1;
	R2 = 100;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6137;
L6205:
	asi64(R1) = am;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_addrof(asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6206:
	asi64(R1) = am;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_dot(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6137;
L6207:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 129;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6137;
L6208:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 130;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6137;
L6139:
	R1 = 0;
	R2 = (u64)&cc_tables_jtagnames;
	asu64(R3) = p;
	R4 = 40;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("DX-EXPR: can't do tag: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6137:
	asi64(R1) = oldclineno;
	cc_decls_clineno = asi64(R1);
L6134:
	return;
}

static void cc_blockpcl_dx_const(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6211;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L6211;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6210;
L6211:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6213;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6214;
	goto L6215;
L6213:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6212;
L6214:
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6212;
L6215:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L6217;
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L6217;
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6216;
L6217:
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6218;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6220;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genstring(asu64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6219;
L6220:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6221;
	R1 = 0;
	R2 = tou64("CONST/WSTRING");
	cc_support_gerror(asu64(R2), asu64(R1));
	goto L6219;
L6221:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6219:
	goto L6216;
L6218:
	R1 = 0;
	R2 = tou64("const?");
	cc_support_gerror(asu64(R2), asu64(R1));
L6216:
L6212:
L6210:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_name(u64 p, i64 am) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6224;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6224;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6224;
	goto L6225;
L6224:
	asi64(R1) = am;
	if (!asi64(R1)) goto L6227;
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L6226;
L6227:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L6226:
	goto L6223;
L6225:
	R1 = 0;
	R2 = tou64("dxname");
	cc_support_gerror(asu64(R2), asu64(R1));
L6223:
	return;
}

static void cc_blockpcl_dx_bin(u64 a, u64 b, i64 opc) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_binto(u64 a, u64 b, i64 opc, i64 res) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = res;
	if (asi64(R1)) goto L6231;
	asi64(R1) = opc;
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L6231;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L6231;
	cc_blockpcl_do_setinplace();
L6231:
	asi64(R1) = res;
	if (!asi64(R1)) goto L6233;
	R1 = 0;
	R2 = 8;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 3;
	R3 = 2;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
L6233:
	R1 = 0;
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = res;
	if (!asi64(R1)) goto L6235;
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
L6235:
	return;
}

static void cc_blockpcl_do_assign(u64 a, u64 b, i64 res) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = res;
	if (!asi64(R1)) goto L6238;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6238:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6240;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6241;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6242;
	goto L6243;
L6240:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6239;
L6241:
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 5;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6239;
L6242:
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 5;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6239;
L6243:
	R1 = 0;
	R2 = (u64)&cc_tables_jtagnames;
	asu64(R3) = a;
	R4 = 40;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("DOASSIGN not ready: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6239:
	return;
}

static void cc_blockpcl_dx_ptr(u64 p, u64 a, i64 am) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = am;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6246;
	R1 = 0;
	R2 = 1;
	R3 = 2;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L6246:
	return;
}

static void cc_blockpcl_dx_addptr(u64 p, u64 a, u64 b, i64 opc, i64 am) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asi64(R3) = opc;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_addrof(u64 p, u64 a, i64 am) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	return;
}

static void cc_blockpcl_dx_convert(u64 p, u64 a, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	i64 s;
	i64 ssize;
	i64 tsize;
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	ssize = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	tsize = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6251;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6252;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6253;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6253;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6254;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6254;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6255;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6255;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6256;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6257;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6258;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6258;
	goto L6259;
L6251:
	goto L6249;
	goto L6250;
L6252:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6262;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6261;
L6262:
	R1 = 0;
	R2 = tou64("Bad cast");
	cc_support_gerror(asu64(R2), asu64(R1));
L6261:
	asi64(R1) = tsize;
	asi64(R2) = ssize;
	if (asi64(R1) <= asi64(R2)) goto L6264;
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6263;
L6264:
	asi64(R1) = tsize;
	asi64(R2) = ssize;
	if (asi64(R1) >= asi64(R2)) goto L6265;
	goto L6266;
	goto L6249;
L6265:
L6263:
	goto L6250;
L6253:
	asi64(R1) = ssize;
	asi64(R2) = tsize;
	if (asi64(R1) != asi64(R2)) goto L6268;
	goto L6249;
L6268:
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6250;
L6254:
	R1 = 0;
	R2 = 111;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6250;
L6255:
	R1 = 0;
	R2 = 112;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6250;
L6256:
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6250;
L6257:
	R1 = 0;
	R2 = 116;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6250;
L6258:
// cc_blockpcl.dx_convert.dotruncate:
L6266:
	R1 = 0;
	R2 = 113;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = t;
	cc_libpcl_setmode2(asi64(R1));
	goto L6249;
	goto L6250;
L6259:
	R1 = 0;
	R2 = (u64)&cc_tables_convnames;
	asi64(R3) = opc;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Convert op not implem: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6250:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = s;
	cc_libpcl_setmode2(asi64(R1));
L6249:
	return;
}

static void cc_blockpcl_do_if(u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = b;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = c;
	if (!asu64(R1)) goto L6271;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = c;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L6270;
L6271:
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
L6270:
	return;
}

static void cc_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	i64 lab2;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 24: goto L6276;
	case 25: goto L6281;
	case 26: goto L6286;
	case 27: goto L6291;
	case 28: case 30: case 31: case 32: goto L6275;
	case 29: goto L6293;
	case 33: case 34: case 35: case 36: case 37: case 38: goto L6292;
	default: goto L6275;
    };
// SWITCH
L6276:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6278;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6279;
	goto L6280;
L6278:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6277;
L6279:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L6277;
L6280:
L6277:
	goto L6273;
L6281:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6283;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6284;
	goto L6285;
L6283:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L6282;
L6284:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6282;
L6285:
L6282:
	goto L6273;
L6286:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6288;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6289;
	goto L6290;
L6288:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6287;
L6289:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6287;
L6290:
L6287:
	goto L6273;
L6291:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6273;
L6292:
	asi64(R1) = lab;
	asu64(R2) = r;
	asu64(R3) = q;
	asu64(R4) = p;
	asi64(R5) = opc;
	cc_blockpcl_gcomparejump(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6273;
L6293:
	goto L6295;
L6294:
	asu64(R1) = q;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L6295:
	asu64(R1) = q;
	if (!asu64(R1)) goto L6297;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	r = asu64(R2);
	if (asu64(R1)) goto L6294;
L6297:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6273;
L6275:
	R1 = 0;
	asu64(R2) = p;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L6273:
	return;
}

static void cc_blockpcl_gcomparejump(i64 jumpopc, u64 p, u64 lhs, u64 rhs, i64 lab) {
    u64 R1, R2, R3; 
	i64 cond;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_blockpcl_getpclcond(asi64(R1));
	cond = asi64(R1);
	asi64(R1) = jumpopc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L6300;
	asi64(R1) = cond;
	asi64(R1) = cc_blockpcl_reversecond(asi64(R1));
	cond = asi64(R1);
L6300:
	asu64(R1) = rhs;
	asu64(R2) = lhs;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lhs;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = rhs;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 26;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = lhs;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static i64 cc_blockpcl_getpclcond(i64 op) {
    u64 R1, R2; 
	asi64(R1) = op;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6303;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6304;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6305;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6306;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L6307;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6308;
	goto L6309;
L6303:
	R1 = 1;
	goto L6301;
	goto L6302;
L6304:
	R1 = 2;
	goto L6301;
	goto L6302;
L6305:
	R1 = 3;
	goto L6301;
	goto L6302;
L6306:
	R1 = 4;
	goto L6301;
	goto L6302;
L6307:
	R1 = 5;
	goto L6301;
	goto L6302;
L6308:
	R1 = 6;
	goto L6301;
	goto L6302;
L6309:
L6302:
	R1 = 0;
	goto L6301;
L6301:
	return asi64(R1);
}

static i64 cc_blockpcl_reversecond(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6312;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6313;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6314;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6315;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6316;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6317;
	goto L6318;
L6312:
	R1 = 2;
	cc = asi64(R1);
	goto L6311;
L6313:
	R1 = 1;
	cc = asi64(R1);
	goto L6311;
L6314:
	R1 = 5;
	cc = asi64(R1);
	goto L6311;
L6315:
	R1 = 6;
	cc = asi64(R1);
	goto L6311;
L6316:
	R1 = 3;
	cc = asi64(R1);
	goto L6311;
L6317:
	R1 = 4;
	cc = asi64(R1);
	goto L6311;
L6318:
L6311:
	asi64(R1) = cc;
	goto L6310;
L6310:
	return asi64(R1);
}

static void cc_blockpcl_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_do_while(u64 pcond, u64 pbody) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6322;
	asu64(R1) = pcond;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6322;
	asu64(R1) = pbody;
	cc_blockpcl_do_while1(asu64(R1));
	goto L6320;
L6322:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = lab_c;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
L6320:
	return;
}

static void cc_blockpcl_do_while1(u64 pbody) {
    u64 R1, R2; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_do_dowhile(u64 pbody, u64 pcond) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondfalse(asu64(R1));
	if (asi64(R1)) goto L6326;
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
L6326:
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_stacklooplabels(i64 a, i64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = a;
	R2 = (u64)&cc_blockpcl_continuestack;
	R3 = (u64)&cc_blockpcl_loopindex;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&cc_blockpcl_breakstack;
	asi64(R3) = cc_blockpcl_loopindex;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static void cc_blockpcl_do_return(u64 p, u64 a) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = a;
	if (!asu64(R1)) goto L6330;
	asu64(R1) = cc_decls_currproc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6332;
	asu8(R1) = pepcl_pdcc;
	if (asu8(R1)) goto L6332;
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6331;
L6332:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = cc_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
L6331:
	goto L6329;
L6330:
	asi64(R1) = cc_genpcl_retindex;
	cc_blockpcl_genjumpl(asi64(R1));
L6329:
	return;
}

static void cc_blockpcl_dx_call(u64 p, u64 a, u64 b, i64 res) {
    u64 R1, R2, R3, R4; 
	u64 pm;
	i64 isfnptr;
	i64 variadic;
	i64 nparams;
	i64 retmode;
	i64 nbytes;
	i64 retsize;
	i64 m;
	i64 nvariadics;
	i64 nfixedparams;
	i64 isfn;
	i64 blockret;
	struct $B16 paramlist;
	struct $B17 paramconst;
	struct $B17 argattr;
	i64 iparams;
	i64 fparams;
	u64 dblock;
	u64 dtemp;
	u64 q;
	i64 i;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	retmode = asi64(R1);
	asi64(R1) = retmode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6335;
	R1 = 3;
	retmode = asi64(R1);
L6335:
	R1 = 0;
	isfn = asi64(R1);
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6337;
	goto L6338;
L6337:
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	goto L6340;
L6339:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
L6340:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6339;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = 1;
	isfnptr = asi64(R1);
	goto L6336;
L6338:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	isfnptr = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
L6336:
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	variadic = asi64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nfixedparams = asi64(R1);
	R1 = 0;
	R2 = R1;
	nvariadics = asi64(R2);
	nparams = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	goto L6345;
L6342:
	asi64(R1) = nparams;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L6347;
	R1 = 0;
	R2 = tou64("maxparams");
	cc_support_gerror(asu64(R2), asu64(R1));
L6347:
	asu64(R1) = q;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&paramconst;
	asi64(R3) = nparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = variadic;
	if (!asi64(R1)) goto L6349;
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) <= asi64(R2)) goto L6349;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L6349;
	asi64(R1) = nvariadics;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6349;
	asi64(R1) = nparams;
	nvariadics = asi64(R1);
L6349:
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) > asi64(R2)) goto L6351;
	R1 = (u64)&cc_decls_ttconst;
	asu64(R2) = pm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&paramconst;
	asi64(R3) = nparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L6351:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6345:
	asu64(R1) = q;
	if (asu64(R1)) goto L6342;
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	fparams = asi64(R2);
	iparams = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6354;
L6352:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6357;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6356;
L6357:
	R1 = (u64)&fparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R1) = -asi64(R1);
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	goto L6355;
L6356:
	R1 = (u64)&iparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L6355:
	i += 1; if (i <= nparams) goto L6352;
L6354:
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6360;
L6358:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L6362;
	asi64(R1) = i;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L6362;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6362;
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 2;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L6362:
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = i;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	R1 = toi64(toi8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += -1; if (i >= 1) goto L6358;
L6360:
	asi64(R1) = isfnptr;
	if (asi64(R1)) goto L6364;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L6366;
	R2 = 21;
	goto L6365;
L6366:
	R2 = 18;
L6365:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6363;
L6364:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L6368;
	R2 = 22;
	goto L6367;
L6368:
	R2 = 19;
L6367:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6363:
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = nvariadics;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L6370;
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = res;
	if (asi64(R1)) goto L6372;
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6371;
L6372:
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L6371:
L6370:
	return;
}

static void cc_blockpcl_do_decl(u64 d) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6375;
	R1 = 1;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6375:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6377;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6379;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6379;
	goto L6380;
L6379:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6373;
L6377:
// cc_blockpcl.do_decl.copyl:
L6380:
	asu64(R1) = d;
	R2 = 114;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
L6373:
	return;
}

static void cc_blockpcl_do_for(u64 pinit, u64 pbody) {
    u64 R1, R2, R3; 
	u64 pcond;
	u64 pincr;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_cond;
	asu64(R1) = pinit;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcond = asu64(R1);
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pincr = asu64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_cond = asi64(R1);
	asu64(R1) = pinit;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6383;
	asu64(R1) = pinit;
	cc_blockpcl_do_stmt(asu64(R1));
L6383:
	asi64(R1) = lab_cond;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_cond;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6385;
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L6384;
L6385:
	asi64(R1) = lab_b;
	cc_blockpcl_genjumpl(asi64(R1));
L6384:
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_do_preincr(u64 a, i64 incrop) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asi64(R2) = incrop;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	return;
}

static void cc_blockpcl_setincrstep(i64 m) {
    u64 R1, R2, R3; 
	R1 = 1;
	pc_api_pc_setincr(asi64(R1));
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6389;
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	pc_api_pc_setincr(asi64(R1));
L6389:
	return;
}

static void cc_blockpcl_dx_preincrx(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 71;
	if (asi64(R2) != asi64(R3)) goto L6392;
	R2 = 86;
	goto L6391;
L6392:
	R2 = 87;
L6391:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	asu64(R1) = a;
	cc_blockpcl_widen(asu64(R1));
	return;
}

static void cc_blockpcl_dx_postincrx(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 73;
	if (asi64(R2) != asi64(R3)) goto L6395;
	R2 = 88;
	goto L6394;
L6395:
	R2 = 89;
L6394:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	asu64(R1) = a;
	cc_blockpcl_widen(asu64(R1));
	return;
}

static void cc_blockpcl_dx_dot(u64 p, u64 a, u64 b, i64 am) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = am;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6398;
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 2;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
	goto L6397;
L6398:
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L6397:
	return;
}

static void cc_blockpcl_dx_eq(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 31;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_blockpcl_getpclcond(asi64(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static void cc_blockpcl_do_labeldef(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L6402;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6402:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_api_gencomment(asu64(R1));
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_do_goto(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6405;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Label not defined: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L6404;
L6405:
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6406;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6406:
L6404:
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_dx_ifx(u64 p, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	i64 ismult;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	ismult = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6409;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6409:
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6411;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L6411:
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = c;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6413;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L6413:
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	return;
}

static void cc_blockpcl_do_casestmt(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 value;
	i64 i;
	asi64(R1) = cc_blockpcl_sw_ncases;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6416;
	asu64(R1) = cc_blockpcl_sw_labeltable;
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = cc_blockpcl_sw_lower;
	asi64(R2) -= asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6415;
L6416:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6420;
L6417:
	asu64(R1) = cc_blockpcl_sw_valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asi64(R2) = value;
	if (asi64(R1) != asi64(R2)) goto L6422;
	asu64(R1) = cc_blockpcl_sw_labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6419;
L6422:
	i += 1; if (i <= cc_blockpcl_sw_ncases) goto L6417;
L6420:
	R1 = 0;
	R2 = tou64("case: serial switch not found");
	cc_support_gerror(asu64(R2), asu64(R1));
L6419:
L6415:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	return;
}

static void cc_blockpcl_do_switch(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	struct $B81 labeltable;
	struct $B81 valuetable;
	struct $B80 flags;
	i64 defaultlabel;
	i64 breakswlabel;
	i64 switchlabel;
	i64 lower;
	i64 upper;
	i64 length;
	i64 value;
	i64 ncases;
	u8 serialsw;
	i64 i;
	i64 index;
	u64 pcase;
	u64 old_labeltable;
	u64 old_valuetable;
	i64 old_ncases;
	i64 old_lower;
	u8 old_defaultseen;
	i64 old_defaultlabel;
	i64 old_breaklabel;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcase = asu64(R1);
	R1 = 0;
	R2 = R1;
	length = asi64(R2);
	ncases = asi64(R1);
	goto L6425;
L6424:
	R1 = (u64)&ncases;
	(*toi64p(R1)) += 1;
	asi64(R1) = ncases;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L6428;
	R1 = 0;
	R2 = tou64("Too many cases on one switch");
	cc_support_gerror(asu64(R2), asu64(R1));
L6428:
	asu64(R1) = pcase;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	value = asi64(R2);
	R2 = (u64)&valuetable;
	asi64(R3) = ncases;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6430;
	asi64(R1) = value;
	R2 = R1;
	upper = asi64(R2);
	lower = asi64(R1);
	goto L6429;
L6430:
	asi64(R1) = lower;
	asi64(R2) = value;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	lower = asi64(R1);
	asi64(R1) = upper;
	asi64(R2) = value;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	upper = asi64(R1);
L6429:
	asu64(R1) = pcase;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcase = asu64(R1);
L6425:
	asu64(R1) = pcase;
	if (asu64(R1)) goto L6424;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6432;
	asi64(R1) = upper;
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	goto L6431;
L6432:
	R1 = 0;
	length = asi64(R1);
L6431:
	asi64(R1) = cc_libpcl_createfwdlabel();
	defaultlabel = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	breakswlabel = asi64(R1);
	asi64(R1) = length;
	R2 = 500;
	if (asi64(R1) > asi64(R2)) goto L6435;
	asi64(R1) = ncases;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L6434;
L6435:
	R1 = 1;
	serialsw = asu8(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6438;
L6436:
	asi64(R1) = cc_libpcl_createfwdlabel();
	R2 = (u64)&labeltable;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = (u64)&labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 26;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = i;
	asi64(R2) = ncases;
	if (asi64(R1) >= asi64(R2)) goto L6440;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6440:
	i += 1; if (i <= ncases) goto L6436;
L6438:
	asi64(R1) = defaultlabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L6433;
L6434:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6441;
	asi64(R1) = defaultlabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L6433;
L6441:
	R1 = 0;
	serialsw = asu8(R1);
	asi64(R1) = length;
	R2 = 0;
	R3 = (u64)&flags;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6444;
L6442:
	asi64(R1) = defaultlabel;
	R2 = (u64)&labeltable;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	i += 1; if (i <= length) goto L6442;
L6444:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6447;
L6445:
	R1 = (u64)&valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	value = asi64(R1);
	asi64(R1) = value;
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	index = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	R2 = (u64)&labeltable;
	asi64(R3) = index;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&flags;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L6449;
	R1 = 0;
	R2 = 0;
	asi64(R3) = value;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Dupl case value: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6449:
	R1 = 1;
	R2 = (u64)&flags;
	asi64(R3) = index;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= ncases) goto L6445;
L6447:
	asi64(R1) = cc_libpcl_createfwdlabel();
	switchlabel = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = switchlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 37;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = lower;
	asi64(R2) = length;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = lower;
	pc_api_pc_setxy(asi64(R2), asi64(R1));
	asi64(R1) = defaultlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = switchlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6452;
L6450:
	R1 = (u64)&labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	i += 1; if (i <= length) goto L6450;
L6452:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6433:
	asu64(R1) = cc_blockpcl_sw_labeltable;
	old_labeltable = asu64(R1);
	asu64(R1) = cc_blockpcl_sw_valuetable;
	old_valuetable = asu64(R1);
	asi64(R1) = cc_blockpcl_sw_lower;
	old_lower = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_ncases;
	old_ncases = asi64(R1);
	asu8(R1) = cc_blockpcl_sw_defaultseen;
	old_defaultseen = asu8(R1);
	asi64(R1) = cc_blockpcl_sw_defaultlabel;
	old_defaultlabel = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_breaklabel;
	old_breaklabel = asi64(R1);
	R1 = (u64)&labeltable;
	cc_blockpcl_sw_labeltable = asu64(R1);
	R1 = (u64)&valuetable;
	cc_blockpcl_sw_valuetable = asu64(R1);
	asi64(R1) = lower;
	cc_blockpcl_sw_lower = asi64(R1);
	asu8(R1) = serialsw;
	if (!asu8(R1)) goto L6454;
	asi64(R1) = ncases;
	goto L6453;
L6454:
	R1 = 0;
L6453:
	cc_blockpcl_sw_ncases = asi64(R1);
	R1 = 0;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = defaultlabel;
	cc_blockpcl_sw_defaultlabel = asi64(R1);
	asi64(R1) = breakswlabel;
	cc_blockpcl_sw_breaklabel = asi64(R1);
	asu64(R1) = b;
	cc_blockpcl_do_stmt(asu64(R1));
	asu8(R1) = cc_blockpcl_sw_defaultseen;
	if (asu8(R1)) goto L6456;
	asi64(R1) = defaultlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
L6456:
	asi64(R1) = breakswlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = old_labeltable;
	cc_blockpcl_sw_labeltable = asu64(R1);
	asu64(R1) = old_valuetable;
	cc_blockpcl_sw_valuetable = asu64(R1);
	asi64(R1) = old_lower;
	cc_blockpcl_sw_lower = asi64(R1);
	asi64(R1) = old_ncases;
	cc_blockpcl_sw_ncases = asi64(R1);
	asu8(R1) = old_defaultseen;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = old_defaultlabel;
	cc_blockpcl_sw_defaultlabel = asi64(R1);
	asi64(R1) = old_breaklabel;
	cc_blockpcl_sw_breaklabel = asi64(R1);
	return;
}

static void cc_blockpcl_dx_andorl(u64 p) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = lab1;
	asu64(R2) = p;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	R1 = 1;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	return;
}

static void cc_blockpcl_dx_scale(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	i64 opc;
	i64 scale;
	i64 n;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6460;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 45;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6459;
L6460:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 47;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6459:
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static void cc_blockpcl_widen(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6463;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L6461;
L6463:
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	cc_libpcl_setmode(asi64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L6465;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6466;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6466;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6466;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L6466;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L6466;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L6466;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L6466;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L6465;
L6466:
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6469;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6468;
L6469:
	R1 = 3;
	goto L6467;
L6468:
	R1 = 8;
L6467:
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = mode;
	cc_libpcl_setmode2(asi64(R1));
L6465:
L6461:
	return;
}

static void cc_blockpcl_do_setinplace() {
    u64 R1, R2, R3; 
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6472;
	asu64(R1) = pc_api_pccurr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6472;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6472:
	return;
}

static void cc_blockpcl_do_fixwiden(u64 a, u64 b) {
	goto L6473;
L6473:
	return;
}

static i64 cc_blockpcl_isboolexpr(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6476;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6476;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6476;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6476;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6476;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6476;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6476;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L6476;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6476;
	goto L6477;
L6476:
	R1 = 1;
	goto L6475;
L6477:
	R1 = 0;
L6475:
	goto L6474;
L6474:
	return asi64(R1);
}

static u64 cc_libpcl_getpsymbol(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 e;
	u64 name;
	struct $B16 str;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6480;
	R1 = 0;
	goto L6478;
L6480:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6482;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6478;
L6482:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6485;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L6484;
L6485:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6487;
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6487:
	goto L6483;
L6484:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L6488;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6488;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6488;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6490;
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6490:
	goto L6483;
L6488:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6483:
	R1 = (u64)&cc_tables_name2pid;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	R2 = R1;
	p = asu64(R2);
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6492;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6492;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6492:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6494;
	R1 = 1;
	asu64(R2) = p;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6494:
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6496;
	R1 = 1;
	asu64(R2) = p;
	R3 = 104;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L6496:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6498;
	R1 = 1;
	asu64(R2) = p;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6498:
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6500;
	R1 = tou64("main");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6500;
	R1 = 1;
	R2 = R1;
	asu64(R3) = p;
	R4 = 110;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L6500:
	asu64(R1) = p;
	goto L6478;
L6478:
	return asu64(R1);
}

static void cc_libpcl_setmode(i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = mode;
	asi64(R2) = cc_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static void cc_libpcl_setmode2(i64 mode) {
    u64 R1; 
	asi64(R1) = mode;
	asi64(R1) = cc_lib_getpclmode(asi64(R1));
	pc_api_pc_setmode2(asi64(R1));
	return;
}

static void cc_libpcl_setmode_u(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = mode;
	asi64(R2) = cc_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static u64 cc_libpcl_genmem_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L6504;
L6504:
	return asu64(R1);
}

static u64 cc_libpcl_genmemaddr_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L6505;
L6505:
	return asu64(R1);
}

static i64 cc_libpcl_definelabel() {
    u64 R1, R2; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = pc_api_mlabelno;
	goto L6506;
L6506:
	return asi64(R1);
}

static i64 cc_libpcl_createfwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L6507;
L6507:
	return asi64(R1);
}

static void cc_libpcl_definefwdlabel(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static u64 cc_lib_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 128;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	memset(R1, 0, 128);
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L6509;
L6509:
	return asu64(R1);
}

static void cc_lib_initcclib() {
	return;
}

static u64 cc_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 3;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L6511;
L6511:
	return asu64(R1);
}

static u64 cc_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = u;
	goto L6512;
L6512:
	return asu64(R1);
}

static u64 cc_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L6513;
L6513:
	return asu64(R1);
}

static u64 cc_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L6514;
L6514:
	return asu64(R1);
}

static u64 cc_lib_createunit3(i64 tag, u64 p, u64 q, u64 r) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = u;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L6515;
L6515:
	return asu64(R1);
}

static u64 cc_lib_createconstunit(u64 a, i64 t) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	asu64(R2) = u;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = u;
	goto L6516;
L6516:
	return asu64(R1);
}

static u64 cc_lib_createstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L6519;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6518;
L6519:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6518:
	R1 = 1;
	asu64(R2) = u;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L6517;
L6517:
	return asu64(R1);
}

static u64 cc_lib_createwstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_decls_trefwchar;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L6520;
L6520:
	return asu64(R1);
}

static i64 cc_lib_getoptocode(i64 opc) {
    u64 R1, R2, R3; 
	i64 n;
	i64 opcto;
	i64 i;
	struct $B46 str;
	i64 av_1;
	R1 = (u64)&cc_lib_getoptocode_opctotable;
	asi64(R2) = opc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	opcto = asi64(R1);
	asi64(R1) = opcto;
	if (!asi64(R1)) goto L6523;
	asi64(R1) = opcto;
	goto L6521;
L6523:
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("to");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	i = asi64(R1);
	R1 = 77;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6526;
L6524:
	R1 = (u64)&str;
	R2 = (u64)&cc_tables_jtagnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6528;
	asi64(R1) = i;
	R2 = (u64)&cc_lib_getoptocode_opctotable;
	asi64(R3) = opc;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = i;
	goto L6521;
L6528:
	i += 1; if (i <= av_1) goto L6524;
L6526:
	msysc_m$print_startcon();
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find -to version");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L6521;
L6521:
	return asi64(R1);
}

static i64 cc_lib_getconstvalue(u64 p, i64 id) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L6531;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6531;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6529;
L6531:
	R1 = tou64("GCV Not constant");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L6529;
L6529:
	return asi64(R1);
}

static u64 cc_lib_nextautotype() {
    u64 R1; 
	R1 = (u64)&cc_lib_nextautotype_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_lib_autotypeno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_lib_nextautotype_str;
	goto L6532;
L6532:
	return asu64(R1);
}

static i64 cc_lib_createconstmode(i64 m) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6535;
	asi64(R1) = m;
	goto L6533;
L6535:
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L6537;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	goto L6533;
L6537:
	asi64(R1) = m;
	asi64(R1) = cc_lib_copymode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = newm;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttconst;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = newm;
	goto L6533;
L6533:
	return asi64(R1);
}

static i64 cc_lib_createrefmode(i64 m) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L6540;
	R1 = (u64)&cc_decls_ttshared;
	R2 = (u64)&cc_decls_ttreftype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*4;
	(*toi32p(R1)) += 1;
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	goto L6538;
L6540:
	R1 = 13;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = newm;
	R2 = (u64)&cc_decls_ttreftype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisref;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L6538;
L6538:
	return asi64(R1);
}

static i64 cc_lib_createprocmode(i64 m, u64 pm) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 14;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = pm;
	R2 = (u64)&cc_decls_ttparams;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = newm;
	goto L6541;
L6541:
	return asi64(R1);
}

static i64 cc_lib_createarraymode(i64 m, i64 length) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 17;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = length;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = newm;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = newm;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L6542;
L6542:
	return asi64(R1);
}

static i64 cc_lib_createenummode(u64 e) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 12;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = e;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = newm;
	goto L6543;
L6543:
	return asi64(R1);
}

static i64 cc_lib_createstructmode(u64 s, i64 smode) {
    u64 R1, R2, R3; 
	i64 newm;
	asi64(R1) = smode;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L6544;
L6544:
	return asi64(R1);
}

static void cc_lib_setnameptr(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_lib_getautofieldname() {
    u64 R1; 
	struct $B17 str;
	u64 name;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$F");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_lib_nextafindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	goto L6546;
L6546:
	return asu64(R1);
}

static i64 cc_lib_convertstringc(u64 s, u64 t, i64 length) {
    u64 R1, R2, R3; 
	i64 c;
	struct $B46 str;
	u64 t0;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L6549;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L6549:
	asu64(R1) = t;
	t0 = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6552;
L6550:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 7: goto L6562;
	case 8: goto L6563;
	case 9: goto L6560;
	case 10: goto L6558;
	case 11: goto L6565;
	case 12: goto L6564;
	case 13: goto L6559;
	case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: goto L6555;
	case 34: goto L6556;
	case 39: goto L6557;
	case 92: goto L6561;
	default: goto L6555;
    };
// SWITCH
L6556:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6557:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 39;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6558:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6559:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6560:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6561:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6562:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 97;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6563:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 98;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6564:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 102;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6565:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 118;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6553;
L6555:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L6568;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) < asi64(R2)) goto L6567;
L6568:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\#o");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("z3");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6566;
L6567:
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6566:
L6553:
	if (--asi64(av_1)) goto L6550;
L6552:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L6547;
L6547:
	return asi64(R1);
}

static u64 cc_lib_getopcjname(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	name = asu64(R1);
	R1 = 32;
	asu64(R2) = name;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (!asu64(R1)) goto L6571;
	asu64(R1) = s;
	asu64(R2) = name;
	asu64(R1) -= asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&cc_lib_getopcjname_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_lib_getopcjname_str;
	asu64(R3) = s;
	asu64(R4) = name;
	asi64(R3) -= asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lib_getopcjname_str;
	goto L6570;
L6571:
	asu64(R1) = name;
L6570:
	goto L6569;
L6569:
	return asu64(R1);
}

static u64 cc_lib_strmode(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_lib_strmode_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_lib_strmode_str;
	goto L6572;
L6572:
	return asu64(R1);
}

static u64 cc_lib_strmode2(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_lib_strmode2_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_lib_strmode2_str;
	goto L6573;
L6573:
	return asu64(R1);
}

static void cc_lib_istrmode(i64 m, i64 expand, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 q;
	i64 value;
	i64 needcomma;
	i64 x;
	i64 i;
	i64 target;
	i64 t;
	i64 n;
	struct $B3 sxx;
	u64 xx;
	u64 sdim;
	u64 slength;
	struct $B5 strdim;
	struct $B5 strlength;
	u64 pm;
	R1 = (u64)&sxx;
	xx = asu64(R1);
	asi64(R1) = m;
	R2 = 21;
	if (asi64(R1) >= asi64(R2)) goto L6576;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6574;
L6576:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6578;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6579;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6580;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6581;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6581;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6583;
	goto L6584;
L6578:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6586;
	R1 = tou64("const ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6585;
L6586:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6585:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	target = asi64(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6588;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6588;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L6587;
L6588:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L6587:
	goto L6577;
L6579:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6590;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6589;
L6590:
	R1 = tou64("[]");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6589:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L6577;
L6580:
	R1 = tou64("enum ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L6577;
L6581:
	asi64(R1) = expand;
	if (asi64(R1)) goto L6592;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6574;
L6592:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6594;
L6593:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L6597;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6597:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6594:
	asu64(R1) = q;
	if (asu64(R1)) goto L6593;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L6577;
L6582:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6577;
L6583:
	R1 = tou64("proc(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6600;
L6598:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = pm;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = n;
	if (asi64(R1) == asi64(R2)) goto L6602;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6602:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	i += 1; if (i <= n) goto L6598;
L6600:
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L6577;
L6584:
	asi64(R1) = t;
	R2 = 21;
	if (asi64(R1) >= asi64(R2)) goto L6604;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L6574;
	goto L6603;
L6604:
	msysc_m$print_startcon();
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("NEWSTRMODE");
	cc_support_mcerror(asu64(R1));
L6603:
L6577:
L6574:
	return;
}

static u64 cc_lib_typename(i64 m) {
    u64 R1, R2, R3; 
	i64 basem;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	basem = asi64(R1);
	asi64(R1) = basem;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6607;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6607;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6608;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6609;
	goto L6610;
L6607:
	asi64(R1) = basem;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6612;
	R1 = tou64("struct ");
	goto L6611;
L6612:
	R1 = tou64("union ");
L6611:
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6614;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6614:
	R1 = (u64)&cc_lib_typename_str;
	goto L6605;
	goto L6606;
L6608:
	R1 = tou64("<array>");
	goto L6605;
	goto L6606;
L6609:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6616;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6605;
L6616:
	R1 = tou64("<enum>");
	goto L6605;
	goto L6606;
L6610:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6618;
	R1 = tou64("const ");
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_tables_stdtypenames;
	asi64(R2) = basem;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lib_typename_str;
	goto L6605;
L6618:
	R1 = (u64)&cc_tables_stdtypenames;
	asi64(R2) = basem;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L6605;
L6606:
	R1 = tou64("");
	goto L6605;
L6605:
	return asu64(R1);
}

static u64 cc_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 nwords;
	R1 = (u64)&cc_decls_nunits;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_lib_remainingunits;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) -= 1; asi64(R1) = asi64(R2);
	if (!asi64(R1)) goto L6621;
	asu64(R1) = cc_lib_unitheapptr;
	p = asu64(R1);
	R1 = (u64)&cc_lib_unitheapptr;
	(*tou64p(R1)) += 64;
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L6623;
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6623:
	asu64(R1) = p;
	goto L6619;
L6621:
	R1 = 3200000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	cc_lib_unitheapptr = asu64(R2);
	p = asu64(R1);
	R1 = 3200000;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 49999;
	cc_lib_remainingunits = asi64(R1);
	R1 = (u64)&cc_lib_unitheapptr;
	(*tou64p(R1)) += 64;
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L6625;
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6625:
	asu64(R1) = p;
	goto L6619;
L6619:
	return asu64(R1);
}

static i64 cc_lib_copymode(i64 m) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_decls_ntypes;
	R2 = 80000;
	if (asi64(R1) < asi64(R2)) goto L6628;
	R1 = tou64("Too many types");
	cc_support_serror(asu64(R1));
L6628:
	R1 = (u64)&cc_decls_ntypes;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = cc_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttconst;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttparams;
	asi64(R3) = cc_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttisref;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_decls_ntypes;
	goto L6626;
L6626:
	return asi64(R1);
}

static i64 cc_lib_createnewmode(i64 m) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_decls_ntypes;
	R2 = 80000;
	if (asi64(R1) < asi64(R2)) goto L6631;
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(M)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many types/cnm");
	cc_support_serror(asu64(R1));
L6631:
	R1 = (u64)&cc_decls_ntypes;
	(*toi64p(R1)) += 1;
	asi64(R1) = m;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = cc_decls_ntypes;
	goto L6629;
L6629:
	return asi64(R1);
}

static void cc_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6634;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6633;
L6634:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6633:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_addlistdef(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6637;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6636;
L6637:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6636:
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_addlistparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6640;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L6639;
L6640:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6639:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_checksymbol(i64 symbol) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L6643;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asi64(R2) = symbol;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6645;
	R1 = tou64(" \"");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6645:
	R1 = (u64)&str;
	cc_support_serror(asu64(R1));
L6643:
	return;
}

static void cc_lib_skipsymbol(i64 symbol) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L6648;
	asi64(R1) = symbol;
	cc_lib_checksymbol(asi64(R1));
L6648:
	cc_lex_lex();
	return;
}

static void cc_lib_inittypetables() {
    u64 R1, R2, R3; 
	i64 i;
	i64 j;
	i64 size;
	i64 bitsize;
	i64 s;
	i64 t;
	i64 u;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	R1 = 0;
	i = asi64(R1);
	R1 = 20;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6652;
L6650:
	asi64(R1) = i;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_tables_stdtypewidths;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = i;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6655;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6654;
L6655:
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6654:
	i += 1; if (i <= av_1) goto L6650;
L6652:
	R1 = 20;
	cc_decls_ntypes = asi64(R1);
	R1 = 1;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	cc_decls_trefchar = asi64(R1);
	R1 = 7;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	cc_decls_trefwchar = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 121;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6658;
L6656:
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = (u64)&cc_tables_dominantmode;
	asi64(R3) = s;
	R2 += (i64)R3*32;
	asi64(R3) = t;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_2) goto L6656;
L6658:
	R1 = 1;
	i = asi64(R1);
	R1 = 121;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6661;
L6659:
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = (u64)&cc_tables_conversionops;
	asi64(R3) = s;
	R2 += (i64)R3*16;
	asi64(R3) = t;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_3) goto L6659;
L6661:
	return;
}

static u64 cc_lib_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	asu64(R1) = cc_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 106;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_tables_namespaces;
	asi64(R2) = id;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 98;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (!asu64(R1)) goto L6664;
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6664:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	asu64(R2) = p;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L6666;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6668;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6667;
L6668:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6667:
L6666:
	asu64(R1) = p;
	goto L6662;
L6662:
	return asu64(R1);
}

static u64 cc_lib_createnewmoduledef(u64 owner, u64 symptr) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	R1 = 3;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L6669;
L6669:
	return asu64(R1);
}

static u64 cc_lib_createnewproc(u64 owner, u64 symptr) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	R1 = 6;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	q = asu64(R1);
	goto L6672;
L6671:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L6675;
	msysc_m$print_startcon();
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Dupl proc name");
	cc_support_serror(asu64(R1));
L6675:
L6672:
	asu64(R1) = q;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (asu64(R1)) goto L6671;
	asu64(R1) = p;
	goto L6670;
L6670:
	return asu64(R1);
}

static u64 cc_lib_resolvename(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6678;
	asu64(R1) = symptr;
	goto L6676;
L6678:
	asi64(R1) = ns;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6680;
	asu64(R1) = symptr;
	asu64(R2) = owner;
	asu64(R1) = cc_lib_resolvelabel(asu64(R2), asu64(R1));
	goto L6676;
L6680:
	asi64(R1) = blockno;
	if (!asi64(R1)) goto L6682;
	R1 = (u64)&cc_decls_blockcounts;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6682;
	R1 = (u64)&cc_decls_blockowner;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	blockno = asi64(R1);
L6682:
L6683:
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	asu64(R1) = symptr;
	d = asu64(R1);
	goto L6686;
L6685:
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6689;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L6689;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6689;
	goto L6687;
L6689:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L6691;
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L6691;
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) >= asi64(R2)) goto L6693;
	asu64(R1) = d;
	R2 = 122;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
L6693:
	asu64(R1) = d;
	goto L6676;
L6691:
L6686:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L6685;
L6687:
	asi64(R1) = blockno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6695;
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6697;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6698;
	goto L6699;
L6697:
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	goto L6683;
	goto L6696;
L6698:
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6701;
	R1 = 0;
	goto L6676;
L6701:
	goto L6696;
L6699:
	R1 = 0;
	goto L6676;
L6696:
	goto L6694;
L6695:
	R1 = (u64)&cc_decls_blockowner;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	blockno = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6702;
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
L6702:
L6694:
	goto L6683;
	R1 = 0;
	goto L6676;
L6676:
	return asu64(R1);
}

static u64 cc_lib_resolvelabel(u64 owner, u64 symptr) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	goto L6705;
L6704:
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6708;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L6708;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6708;
	goto L6706;
L6708:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L6710;
	asu64(R1) = d;
	R2 = 98;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6710;
	asu64(R1) = d;
	goto L6703;
L6710:
L6705:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L6704;
L6706:
	R1 = 0;
	goto L6703;
L6703:
	return asu64(R1);
}

static u64 cc_lib_checkdupl(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	goto L6713;
L6712:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L6716;
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L6716;
	asu64(R1) = d;
	goto L6711;
L6716:
L6713:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L6712;
	R1 = 0;
	goto L6711;
L6711:
	return asu64(R1);
}

static u64 cc_lib_checkdupl_inproc(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	goto L6719;
L6718:
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L6722;
	asu64(R1) = d;
	goto L6717;
L6722:
L6719:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (!asu64(R1)) goto L6723;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L6718;
L6723:
	R1 = 0;
	goto L6717;
L6717:
	return asu64(R1);
}

static i64 cc_lib_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6726;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6727;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6727;
	goto L6728;
L6726:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	goto L6724;
	goto L6725;
L6727:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6730;
	R1 = 16;
	goto L6724;
L6730:
	asi64(R1) = a;
	goto L6724;
	goto L6725;
L6728:
L6725:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6732;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6732;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6732;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6732;
	goto L6733;
L6732:
	asi64(R1) = a;
	goto L6724;
	goto L6731;
L6733:
L6731:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = a;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("GETALIGN SIZE NOT 1248");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L6724;
L6724:
	return asi64(R1);
}

static i64 cc_lib_isexported(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6736;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6738;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6739;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6738;
L6739:
	R1 = 1;
	goto L6734;
L6738:
	goto L6735;
L6736:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6741;
	R1 = 1;
	goto L6734;
L6741:
L6735:
	R1 = 0;
	goto L6734;
L6734:
	return asi64(R1);
}

static i64 cc_lib_isimported(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6744;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6746;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6747;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6746;
L6747:
	R1 = 1;
	goto L6742;
L6746:
	goto L6743;
L6744:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6749;
	R1 = 1;
	goto L6742;
L6749:
L6743:
	R1 = 0;
	goto L6742;
L6742:
	return asi64(R1);
}

static u64 cc_lib_getstname(u64 d) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = d;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&cc_lib_getstname_name;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_lib_getstname_name;
	asu64(R3) = d;
	R4 = 106;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lib_getstname_name;
	goto L6750;
L6750:
	return asu64(R1);
}

static i64 cc_lib_isrealcc(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	R1 = 10;
	asi64(R2) = m;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L6752;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L6752;
	R1 = 1;
	goto L6753;
L6752:
	R1 = 0;
L6753:
	goto L6751;
L6751:
	return asi64(R1);
}

static i64 cc_lib_isintcc(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	R1 = 1;
	asi64(R2) = m;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L6755;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L6755;
	R1 = 1;
	goto L6756;
L6755:
	R1 = 0;
L6756:
	goto L6754;
L6754:
	return asi64(R1);
}

static void cc_lib_writegsfile(u64 filename, u64 d) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	return;
}

static void cc_lib_pause(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asi64(R1) = mnoos_os_getch();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static i64 cc_lib_getpclmode(i64 t) {
    u64 R1, R2, R3; 
	i64 u;
	R1 = (u64)&cc_tables_stdpcl;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6761;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6763;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6764;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6765;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6766;
	goto L6767;
L6763:
	R1 = 6;
	u = asi64(R1);
	goto L6762;
L6764:
	R1 = 5;
	u = asi64(R1);
	goto L6762;
L6765:
	R1 = 4;
	u = asi64(R1);
	goto L6762;
L6766:
	R1 = 3;
	u = asi64(R1);
	goto L6762;
L6767:
L6762:
L6761:
	asi64(R1) = u;
	goto L6759;
L6759:
	return asi64(R1);
}

static void cc_lib_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6770;
	msysc_m$print_startcon();
	R1 = tou64("ATL ERROR");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L6768;
L6770:
L6771:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L6774;
	goto L6772;
L6774:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L6771;
L6772:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L6768:
	return;
}

static void cc_support_stopcompiler(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	asu8(R1) = cc_cli_fwriteerrors;
	if (!asu8(R1)) goto L6777;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L6777:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void cc_support_mcerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("\nMC Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 40;
	exit(R1);
	return;
}

static void cc_support_serror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_serror_gen(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L6782;
	msysc_m$print_startcon();
	R1 = tou64("\nIn function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6781;
L6782:
	msysc_m$print_startcon();
	R1 = tou64("OUTSIDE PROC");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6781:
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	cc_support_showmacrolineno();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Syntax Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = (u64)&cc_decls_lx;
	R4 = 20;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_serror_ss(u64 mess, u64 a, u64 b) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_serror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_terror_gen(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L6787;
	msysc_m$print_startcon();
	R1 = tou64("\nIn function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6787:
	msysc_m$print_startcon();
	R1 = tou64("Type error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("on line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	cc_support_showmacrolineno();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = (u64)&cc_decls_lx;
	R4 = 20;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_terror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_terror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_terror_ss(u64 mess, u64 a, u64 b) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_gerror_gen(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	i64 lineno;
	i64 fileno;
	asu64(R1) = p;
	if (!asu64(R1)) goto L6793;
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	lineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	fileno = asi64(R1);
	goto L6792;
L6793:
	asi64(R1) = cc_decls_clineno;
	lineno = asi64(R1);
	asi64(R1) = cc_decls_cfileno;
	fileno = asi64(R1);
L6792:
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L6795;
	msysc_m$print_startcon();
	R1 = tou64("In function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6795:
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Code Gen Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = fileno;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_gerror(u64 mess, u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = mess;
	cc_support_gerror_gen(asu64(R2), asu64(R1));
	return;
}

static void cc_support_gerror_s(u64 mess, u64 s, u64 p) {
    u64 R1, R2; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	cc_support_gerror_gen(asu64(R2), asu64(R1));
	return;
}

static i64 cc_support_nextpoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6800;
	R1 = 0;
	goto L6798;
L6800:
	R1 = 1;
	a = asi64(R1);
	goto L6802;
L6801:
	R1 = 1;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
L6802:
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) < asi64(R2)) goto L6801;
	asi64(R1) = a;
	goto L6798;
L6798:
	return asi64(R1);
}

static void cc_support_loaderror(u64 mess, u64 mess2) {
    u64 R1; 
	struct $B20 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	exit(R1);
	return;
}

static i64 cc_support_loadsourcefile(u64 file, u64 shortfile) {
    u64 R1, R2, R3; 
	u64 s;
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L6807;
	R1 = tou64("");
	R2 = tou64("Too many source files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L6807:
	R1 = (u64)&cc_decls_nsourcefiles;
	(*toi64p(R1)) += 1;
	asu64(R1) = file;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = shortfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = file;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L6809;
	asu64(R1) = file;
	R2 = tou64("LSF can't load ");
	cc_support_loaderror(asu64(R2), asu64(R1));
L6809:
	asu64(R1) = s;
	R2 = (u64)&cc_decls_sourcefiletext;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	R2 = (u64)&cc_decls_sourcefilesizes;
	asi64(R3) = cc_decls_nsourcefiles;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	goto L6805;
L6805:
	return asi64(R1);
}

static u64 cc_support_splicelines(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	goto L6812;
L6811:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L6815;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6815;
	R1 = 2;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	goto L6814;
L6815:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L6816;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6816;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6816;
	R1 = 3;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	goto L6814;
L6816:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6814:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L6812:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L6811;
	asu64(R1) = u;
	goto L6810;
L6810:
	return asu64(R1);
}

static i64 cc_support_loadbuiltin(u64 shortfile, u64 hdrtext) {
    u64 R1, R2, R3; 
	u64 s;
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L6819;
	R1 = tou64("");
	R2 = tou64("Too many source files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L6819:
	R1 = (u64)&cc_decls_nsourcefiles;
	(*toi64p(R1)) += 1;
	R1 = tou64("<builtin>");
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = shortfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = hdrtext;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefiletext;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = hdrtext;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilesizes;
	asi64(R3) = cc_decls_nsourcefiles;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	goto L6817;
L6817:
	return asi64(R1);
}

static void cc_support_gs_copytostr(u64 source, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6822;
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = source;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = s;
	asu64(R3) = source;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6821;
L6822:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L6821:
	return;
}

static void cc_support_gs_additem(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6825;
	asu64(R1) = d;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = cc_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L6827;
	asi64(R1) = nextchar;
	asi64(R1) = cc_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L6827;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L6827:
L6825:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 cc_support_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L6832;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L6831;
L6832:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L6833;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L6831;
L6833:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L6830;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L6830;
L6831:
	R1 = 1;
	goto L6828;
L6830:
	R1 = 0;
	goto L6828;
L6828:
	return asi64(R1);
}

static void cc_support_showmacrolineno() {
    u64 R1; 
	asi64(R1) = cc_decls_slineno;
	if (!asi64(R1)) goto L6836;
L6836:
	return;
}

static u64 cc_headers_findheader(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	struct $B16 newname;
	u64 s;
	u64 t;
	i64 av_1;
	R1 = 92;
	asu64(R2) = name;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	if (!asu64(R1)) goto L6839;
	asu64(R1) = name;
	s = asu64(R1);
	R1 = (u64)&newname;
	t = asu64(R1);
	goto L6841;
L6840:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L6844;
	R1 = 47;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6843;
L6844:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6843:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L6841:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L6840;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&newname;
	name = asu64(R1);
L6839:
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6847;
L6845:
	R1 = (u64)&cc_headers_stdhdrnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6849;
	R1 = (u64)&cc_headers_stdhdrtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = *tou64p(R1);
	goto L6837;
L6849:
	i += 1; if (i <= av_1) goto L6845;
L6847:
	R1 = 0;
	goto L6837;
L6837:
	return asu64(R1);
}

static void cc_headers_writeheaders() {
    u64 R1, R2, R3, R4, R5; 
	u64 f;
	u64 ifile;
	i64 i;
	i64 av_1;
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6853;
L6851:
	R1 = tou64("hdr");
	R2 = (u64)&cc_headers_stdhdrnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	ifile = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Writing internal");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_headers_stdhdrnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("as");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ifile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("wb");
	asu64(R2) = ifile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = (u64)&cc_headers_stdhdrtext;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R2) = *tou64p(R2);
	asu64(R2) = strlen(asu64(R2));
	R3 = 1;
	R4 = (u64)&cc_headers_stdhdrtext;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R4) = *tou64p(R4);
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	i += 1; if (i <= av_1) goto L6851;
L6853:
	return;
}

static i64 cc_headers_isheaderfile(u64 file) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6857;
L6855:
	asu64(R1) = file;
	R2 = (u64)&cc_headers_stdhdrnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6859;
	R1 = 1;
	goto L6854;
L6859:
	i += 1; if (i <= av_1) goto L6855;
L6857:
	R1 = 0;
	goto L6854;
L6854:
	return asi64(R1);
}

static void cc_show_printcode(u64 f, u64 caption) {
    u64 R1, R2, R3, R4; 
	i64 i;
	u64 p;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L6862;
L6861:
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6865;
	goto L6866;
L6865:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6868;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_scopenames;
	asu64(R2) = p;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	R2 = 0;
	asu64(R3) = p;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6868:
	goto L6864;
L6866:
L6864:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6862:
	asu64(R1) = p;
	if (asu64(R1)) goto L6861;
	return;
}

static void cc_show_printunit(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	i64 t;
	i64 n;
	i64 lincr;
	u64 idname;
	u64 pc;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6871;
	goto L6869;
L6871:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 77;
	if (asi64(R1) < asi64(R2)) goto L6873;
	msysc_m$print_startcon();
	R1 = tou64("print unit: bad tag");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 30;
	exit(R1);
L6873:
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	if (!asu32(R1)) goto L6875;
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_show_currlineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_show_currfileno = asi64(R1);
L6875:
	R1 = 1;
	lincr = asi64(R1);
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6877;
	R1 = -1;
	lincr = asi64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("             ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6877:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = prefix;
	asi64(R3) = level;
	if (asi64(R3) < 0) asi64(R3) = -asi64(R3);
	asu64(R1) = cc_show_getprefix(asi64(R3), asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	idname = asu64(R1);
	asu64(R1) = idname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 106;
	if (asu64(R1) != asu64(R2)) goto L6879;
	R1 = (u64)&idname;
	(*tou64p(R1)) += 1;
L6879:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = idname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6881;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6881;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6882;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6882;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6882;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6883;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6884;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6885;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6886;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6887;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6888;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6889;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L6889;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L6890;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L6891;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6892;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6893;
	goto L6894;
L6881:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6896;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" {");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = d;
	R3 = 72;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("}");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6896:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = d;
	asu64(R1) = cc_show_getdottedname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6898;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Lastcall:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L6898:
	goto L6880;
L6882:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = d;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L6869;
	goto L6880;
L6883:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6880;
L6884:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6880;
L6885:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Value:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6880;
L6886:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L6900;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6902;
	goto L6903;
L6902:
// cc_show.printunit.dostring:
L6904:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 256;
	if (asi64(R1) <= asi64(R2)) goto L6906;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("(LONGSTR)");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6905;
L6906:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6905:
	goto L6899;
L6900:
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) != asi64(R2)) goto L6907;
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6909;
	goto L6903;
L6909:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("(WSTRING)");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6899;
L6907:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6910;
	asi64(R1) = t;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L6910;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6899;
L6910:
	asi64(R1) = t;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L6911;
	asi64(R1) = t;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L6911;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6899;
L6911:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L6912;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6899;
L6912:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6913;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6915;
	goto L6904;
L6915:
// cc_show.printunit.doref:
L6903:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	goto L6899;
L6913:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6916;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6918;
	goto L6904;
L6918:
	R1 = tou64("PRINTUNIT/CONST/aRRAY");
	cc_support_serror(asu64(R1));
	goto L6899;
L6916:
	msysc_m$print_startcon();
	asi64(R1) = t;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("PRINTUNIT BAD CONST");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6899:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6920;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<STRCONST>");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6920:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6922;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<WSTRCONST>");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6922:
	goto L6880;
L6887:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&cc_tables_convnames;
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" => ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 58;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6880;
L6888:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Scale:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6880;
L6889:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Ptrscale:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6880;
L6890:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L6924;
L6923:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L6924:
	asu64(R1) = pc;
	if (asu64(R1)) goto L6923;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6880;
L6891:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Aparams:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6880;
L6892:
	goto L6880;
L6893:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Offset:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6880;
L6894:
L6880:
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L6927;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Widen from:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 56;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6927:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6929;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ALENGTH=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6929:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("2");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6931;
	R1 = tou64("3");
	asi64(R2) = level;
	asi64(R3) = lincr;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 32;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	cc_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L6931:
L6869:
	return;
}

static void cc_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6934;
	goto L6932;
L6934:
	goto L6936;
L6935:
	asu64(R1) = prefix;
	asi64(R2) = level;
	asu64(R3) = p;
	asu64(R4) = dev;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6936:
	asu64(R1) = p;
	if (asu64(R1)) goto L6935;
L6932:
	return;
}

static u64 cc_show_getprefix(i64 level, u64 prefix, u64 p) {
    u64 R1, R2, R3; 
	struct $B20 indentstr;
	u64 modestr;
	i64 length;
	i64 av_1;
	R1 = 0;
	R2 = (u64)&indentstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = level;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L6940;
	R1 = 10;
	level = asi64(R1);
L6940:
	R1 = tou64("-----------------------");
	R2 = (u64)&indentstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	modestr = asu64(R1);
	asu64(R1) = modestr;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&indentstr;
	asi64(R2) = strlen(asu64(R2));
	if (asi64(R1) >= asi64(R2)) goto L6942;
	asi64(R1) = length;
	asu64(R2) = modestr;
	R3 = (u64)&indentstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L6941;
L6942:
	asu64(R1) = modestr;
	R2 = (u64)&indentstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L6941:
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6945;
L6943:
	R1 = tou64("|---");
	R2 = (u64)&indentstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L6943;
L6945:
	asu64(R1) = cc_show_getlineinfok();
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&indentstr;
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L6947;
	R1 = tou64(" ");
	R2 = (u64)&cc_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6947:
	R1 = (u64)&cc_show_getprefix_str;
	goto L6938;
L6938:
	return asu64(R1);
}

static u64 cc_show_getdottedname(u64 p) {
    u64 R1, R2; 
	struct $B16 str2;
	u64 owner;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	goto L6950;
L6949:
	R1 = (u64)&cc_show_getdottedname_str;
	R2 = (u64)&str2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
L6950:
	asu64(R1) = owner;
	if (!asu64(R1)) goto L6952;
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6949;
L6952:
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L6954;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&cc_show_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6954:
	R1 = (u64)&cc_show_getdottedname_str;
	goto L6948;
L6948:
	return asu64(R1);
}

static u64 cc_show_getlineinfok() {
    u64 R1, R2; 
	R1 = (u64)&cc_show_getlineinfok_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = cc_show_currfileno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("z5");
	asi64(R2) = cc_show_currlineno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	R1 = (u64)&cc_show_getlineinfok_str;
	goto L6955;
L6955:
	return asu64(R1);
}

static void cc_show_printst(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = p;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6958;
	R1 = tou64("PRINTST not name");
	cc_support_mcerror(asu64(R1));
L6958:
	asi64(R1) = level;
	asu64(R2) = p;
	asu64(R3) = f;
	cc_show_printstrec(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6960;
L6959:
	asi64(R1) = level;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	asu64(R3) = f;
	cc_show_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6960:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6959;
	return;
}

static void cc_show_printstrec(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	struct $B3 v;
	u64 d;
	i64 col;
	i64 offset;
	struct $B16 str;
	i64 scope;
	u64 pm;
	i64 av_1;
	R1 = (u64)&v;
	d = asu64(R1);
	asu64(R1) = d;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6965;
L6963:
	R1 = tou64("    ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L6963;
L6965:
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L6967;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 45;
	R2 = 28;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6966;
L6967:
	R1 = 45;
	R2 = 28;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L6966:
	R1 = 46;
	R2 = 12;
	R3 = (u64)&cc_tables_namenames;
	asu64(R4) = p;
	R5 = 109;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	asi64(R1) = mlib_gs_getcol(asu64(R1));
	col = asi64(R1);
	R1 = tou64("[");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_tables_scopenames;
	asu64(R2) = p;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 108;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 4;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6969;
	R1 = tou64("@@");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6969:
	asu64(R1) = p;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6971;
	R1 = tou64("Var ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6971:
	asu64(R1) = p;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6973;
	R1 = tou64("Used ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6973:
	asu64(R1) = p;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6975;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Pm:# ");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6975:
	R1 = tou64("]");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 61;
	asi64(R2) = col;
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R3) = d;
	mlib_gs_padto(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6977;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 32;
	R2 = 18;
	R3 = (u64)&str;
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6976;
L6977:
	R1 = 32;
	R2 = 18;
	R3 = tou64("()");
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L6976:
	asu64(R1) = p;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6979;
	goto L6980;
L6979:
	R1 = tou64("Void ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6978;
L6980:
	R1 = 1;
	asu64(R2) = p;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	mlib_gs_strsp(asu64(R2), asu64(R1));
L6978:
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6982;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6983;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6983;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6984;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6985;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6986;
	goto L6987;
L6982:
	R1 = tou64("Offset:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6981;
L6983:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6989;
	R1 = tou64("=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_show_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6989:
	R1 = tou64(" Offset: ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6981;
L6984:
	R1 = tou64("Index:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6981;
L6985:
	R1 = tou64("Enum:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6981;
L6986:
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6991;
	R1 = tou64("=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_show_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6991:
	R1 = tou64("STATIC********");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6981;
L6987:
L6981:
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("Lineno:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 92;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asu64(R2) = p;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6993;
	asu64(R1) = d;
	mlib_gs_line(asu64(R1));
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	goto L6995;
L6994:
	R1 = tou64("\t\tParam: ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 45;
	R2 = 10;
	asu64(R3) = pm;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	if (!asu64(R3)) goto L6998;
	asu64(R3) = pm;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	goto L6997;
L6998:
	R3 = tou64("Anon");
L6997:
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&cc_tables_pmflagnames;
	asu64(R2) = pm;
	R3 = 22;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" Mode:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" Code:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = d;
	mlib_gs_line(asu64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L6995:
	asu64(R1) = pm;
	if (asu64(R1)) goto L6994;
L6993:
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7000;
	asu64(R1) = p;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7002;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7002;
	goto L7003;
L7002:
	R1 = tou64("*");
	R2 = -3;
	asu64(R3) = p;
	R4 = 72;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	cc_show_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L7001;
L7003:
L7001:
L7000:
	return;
}

static void cc_show_printstflat(u64 f) {
    u64 R1, R2, R3; 
	i64 i;
	u64 p;
	u64 lx;
	i64 av_1;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("GLOBAL SYMBOL TABLE:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7007;
L7005:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7009;
	asu64(R1) = p;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7011;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L7011;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L7011;
	goto L7012;
L7011:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = cc_lib_getstname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asu64(R2) = p;
	R3 = 107;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = p;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L7014;
L7013:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = cc_lib_getstname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asu64(R2) = p;
	R3 = 107;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = p;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("(From");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7017;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	goto L7016;
L7017:
	R1 = tou64("-");
L7016:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(")");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7014:
	asu64(R1) = p;
	if (asu64(R1)) goto L7013;
	goto L7010;
L7012:
L7010:
L7009:
	i += 1; if (i <= av_1) goto L7005;
L7007:
	return;
}

static u64 cc_show_strexpr(u64 p) {
    u64 R1, R2; 
	asu64(R1) = cc_show_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = cc_show_exprstr;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = cc_show_exprstr;
	goto L7018;
L7018:
	return asu64(R1);
}

static void cc_show_jeval(u64 dest, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B82 str;
	i64 lb;
	i64 t;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7021;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7022;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7023;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L7024;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L7025;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L7025;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L7025;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L7025;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7025;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L7026;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7027;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L7028;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7029;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L7029;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7030;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L7031;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L7032;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7033;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7034;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L7035;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L7036;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L7037;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L7038;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7039;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L7040;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L7041;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7042;
	goto L7043;
L7021:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L7045;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7047;
	goto L7048;
L7047:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7050;
	goto L7048;
L7050:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8000;
	if (asi64(R1) <= asi64(R2)) goto L7052;
	R1 = tou64("LONGSTR)");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7051;
L7052:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
L7051:
	R1 = tou64("\"");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7019;
	goto L7044;
L7045:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7053;
	asi64(R1) = t;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L7053;
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L7044;
L7053:
	asi64(R1) = t;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L7054;
	asi64(R1) = t;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L7054;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7044;
L7054:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7056;
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L7055;
L7056:
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7044;
L7055:
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7058;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7059;
	goto L7060;
L7058:
// cc_show.jeval.doref:
L7048:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	goto L7057;
L7059:
	R1 = tou64("ARRAY");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7057;
L7060:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("EVAL/C");
	mlib_abortprogram(asu64(R1));
L7057:
L7044:
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7022:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7023:
	R1 = tou64("&");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7024:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_getopcjname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7025:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = cc_lib_getopcjname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7026:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L7062;
L7061:
	asu64(R1) = q;
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L7065;
	R1 = tou64(",");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
L7065:
L7062:
	asu64(R1) = q;
	if (asu64(R1)) goto L7061;
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7027:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("???");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L7020;
L7028:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("->");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L7020;
L7029:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 29;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	lb = asi64(R1);
	asi64(R1) = lb;
	if (!asi64(R1)) goto L7067;
	R1 = tou64("(");
	goto L7066;
L7067:
	R1 = tou64("{");
L7066:
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L7069;
L7068:
	asu64(R1) = q;
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L7072;
	R1 = tou64(",");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
L7072:
L7069:
	asu64(R1) = q;
	if (asu64(R1)) goto L7068;
	asi64(R1) = lb;
	if (!asi64(R1)) goto L7074;
	R1 = tou64(")");
	goto L7073;
L7074:
	R1 = tou64("}");
L7073:
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7030:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("=");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L7020;
L7031:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("?");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(":");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L7020;
L7032:
	R1 = 1;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7033:
	R1 = tou64("*(");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7076;
	R1 = tou64("+");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
L7076:
	R1 = tou64(")");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7034:
	R1 = tou64("<JBLOCK>");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7035:
	R1 = tou64("++");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L7020;
L7036:
	R1 = tou64("--");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L7020;
L7037:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("++");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7038:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("--");
	asu64(R2) = dest;
	cc_support_gs_additem(asu64(R2), asu64(R1));
	goto L7020;
L7039:
	R1 = tou64("<nullunit>");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L7020;
L7040:
	R1 = tou64("scale((");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7078;
	R1 = tou64(")*");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L7077;
L7078:
	R1 = tou64(")/");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R2) = dest;
	mlib_gs_strint(asu64(R2), asi64(R1));
L7077:
	R1 = tou64(")");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L7020;
L7041:
	R1 = tou64("(");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64("+");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	R1 = tou64(")");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L7020;
L7042:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	cc_show_jeval(asu64(R2), asu64(R1));
	goto L7020;
L7043:
	R1 = tou64("<CAN'T DO JEVAL>");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L7020:
L7019:
	return;
}

static void cc_show_printfilelist(u64 f) {
    u64 R1, R2, R3; 
	i64 i;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Source files");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7082;
L7080:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# # (#)");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("12jl");
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nsourcefiles) goto L7080;
L7082:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\nInput file:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\nLibfiles");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nlibfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7085;
L7083:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nlibfiles) goto L7083;
L7085:
	return;
}

static void cc_show_printmodelist(u64 f) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mbase;
	u64 d;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC MODELIST");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	m = asi64(R1);
	asi64(R1) = cc_decls_ntypes;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7089;
L7087:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("4");
	asi64(R2) = m;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	R1 = (u64)&cc_decls_tttypedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L7091;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Typedef:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_tttypedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7091:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Basetype:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mbase;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = 1;
	asi64(R2) = mbase;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Name:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("ttnamedef:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	if (!asu64(R1)) goto L7093;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7092;
L7093:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7092:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Target:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Length:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isblock:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Const:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Signed:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttsigned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Ref:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Constver:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Shared:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_ttshared;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	m += 1; if (m <= cc_decls_ntypes) goto L7087;
L7089:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void pepcl_start() {
	mc_decls_start();
	mc_writegas_start();
	return;
}

static struct $B76 $procaddr = {{
(u64)&mc_genmcl_px_nop,
(u64)&mc_genmcl_px_dupl,
(u64)&mc_genmcl_px_double,
(u64)&mc_genmcl_px_opnd,
(u64)&mc_genmcl_px_type,
(u64)&mc_genmcl_px_comment,
(u64)&mc_genmcl_px_proc,
(u64)&mc_genmcl_px_endproc,
(u64)&mc_genmcl_px_endprog,
(u64)&mc_genmcl_px_istatic,
(u64)&mc_genmcl_px_zstatic,
(u64)&mc_genmcl_px_data,
(u64)&mc_genmcl_px_label,
(u64)&mc_genmcl_px_load,
(u64)&mc_genmcl_px_store,
(u64)&mc_genmcl_px_add,
(u64)&mc_genmcl_px_sub,
(u64)&mc_genmcl_px_mul,
(u64)&mc_genmcl_px_div,
(u64)&mc_genmcl_px_eval,
(u64)&mc_genmcl_px_widen,
(u64)&mc_genmcl_px_jump,
(u64)&mc_genmcl_px_ijump,
(u64)&mc_genmcl_px_neg,
(u64)&mc_genmcl_px_abs,
(u64)&mc_genmcl_px_bitnot,
(u64)&mc_genmcl_px_not,
(u64)&mc_genmcl_px_toboolt,
(u64)&mc_genmcl_px_sqr,
(u64)&mc_genmcl_px_sqrt,
(u64)&mc_genmcl_px_jumpcc,
(u64)&mc_genmcl_px_jumpt,
(u64)&mc_genmcl_px_jumpf,
(u64)&mc_genmcl_px_bitand,
(u64)&mc_genmcl_px_bitor,
(u64)&mc_genmcl_px_bitxor,
(u64)&mc_genmcl_px_shl,
(u64)&mc_genmcl_px_shr,
(u64)&mc_genmcl_px_retproc,
(u64)&mc_genmcl_px_retfn,
(u64)&mc_genmcl_px_setcall,
(u64)&mc_genmcl_px_setarg,
(u64)&mc_genmcl_px_callp,
(u64)&mc_genmcl_px_jumpret,
(u64)&mc_genmcl_px_jumpretm,
(u64)&mc_genmcl_px_startmx,
(u64)&mc_genmcl_px_resetmx,
(u64)&mc_genmcl_px_stop,
(u64)&mc_genmcl_px_incrto,
(u64)&mc_genmcl_px_decrto,
(u64)&mc_genmcl_px_incrload,
(u64)&mc_genmcl_px_decrload,
(u64)&mc_genmcl_px_loadincr,
(u64)&mc_genmcl_px_loaddecr,
(u64)&mc_genmcl_px_forup,
(u64)&mc_genmcl_px_fordown,
(u64)&mc_genmcl_px_iload,
(u64)&mc_genmcl_px_iloadx,
(u64)&mc_genmcl_px_istore,
(u64)&mc_genmcl_px_istorex,
(u64)&mc_genmcl_px_storem,
(u64)&mc_genmcl_px_addpx,
(u64)&mc_genmcl_px_subpx,
(u64)&mc_genmcl_px_to,
(u64)&mc_genmcl_px_iswap,
(u64)&mc_genmcl_px_swapstk,
(u64)&mc_genmcl_px_labeldef,
(u64)&mc_genmcl_px_addto,
(u64)&mc_genmcl_px_subto,
(u64)&mc_genmcl_px_multo,
(u64)&mc_genmcl_px_bitandto,
(u64)&mc_genmcl_px_bitorto,
(u64)&mc_genmcl_px_bitxorto,
(u64)&mc_genmcl_px_shlto,
(u64)&mc_genmcl_px_shrto,
(u64)&mc_genmcl_px_fix,
(u64)&mc_genmcl_px_float,
(u64)&mc_genmcl_px_idiv,
(u64)&mc_genmcl_px_irem,
(u64)&mc_genmcl_px_idivrem,
(u64)&mc_genmcl_px_clear,
(u64)&mc_genmcl_px_subp,
(u64)&mc_genmcl_px_switch,
(u64)&mc_genmcl_px_switchu,
(u64)&mc_genmcl_px_swlabel,
(u64)&mc_genmcl_px_endsw,
(u64)&mc_genmcl_px_fwiden,
(u64)&mc_genmcl_px_fnarrow,
(u64)&mc_genmcl_px_truncate,
(u64)&mc_genmcl_px_typepun,
(u64)&mc_genmcl_px_unload,
(u64)&mc_genmcl_px_loadbit,
(u64)&mc_genmcl_px_assem,
(u64)&mc_genmcl_px_sin,
(u64)&mc_genmcl_px_cos,
(u64)&mc_genmcl_px_tan,
(u64)&mc_genmcl_px_asin,
(u64)&mc_genmcl_px_acos,
(u64)&mc_genmcl_px_atan,
(u64)&mc_genmcl_px_log,
(u64)&mc_genmcl_px_log10,
(u64)&mc_genmcl_px_exp,
(u64)&mc_genmcl_px_round,
(u64)&mc_genmcl_px_floor,
(u64)&mc_genmcl_px_ceil,
(u64)&mc_genmcl_px_atan2,
(u64)&mc_genmcl_px_fmod,
(u64)&mc_genmcl_px_setcc,
(u64)&mc_genmcl_px_min,
(u64)&mc_genmcl_px_max,
(u64)&mc_genmcl_px_power,
(u64)&mc_genmcl_px_minto,
(u64)&mc_genmcl_px_maxto,
(u64)&mc_genmcl_px_negto,
(u64)&mc_genmcl_px_absto,
(u64)&mc_genmcl_px_addpxto,
(u64)&mc_genmcl_px_subpxto,
(u64)&mc_genmcl_px_divto,
(u64)&mc_genmcl_px_bitnotto,
(u64)&mc_genmcl_px_notto,
(u64)&mc_genmcl_px_toboolto,
(u64)&mc_genmcl_px_sign,
(u64)&mc_genmcl_px_loadbf,
(u64)&mc_genmcl_px_storebit,
(u64)&mc_genmcl_px_storebf,
(u64)&mc_genmcl_px_loadall,
(u64)&mc_genmcl_px_setjmp,
(u64)&mc_genmcl_px_longjmp,
(u64)&mc_genmcl_px_initdswx,
(u64)&mc_auxmcl_do_addrmode}};

static struct $B76 $procname = {{
(u64)"px_nop",
(u64)"px_dupl",
(u64)"px_double",
(u64)"px_opnd",
(u64)"px_type",
(u64)"px_comment",
(u64)"px_proc",
(u64)"px_endproc",
(u64)"px_endprog",
(u64)"px_istatic",
(u64)"px_zstatic",
(u64)"px_data",
(u64)"px_label",
(u64)"px_load",
(u64)"px_store",
(u64)"px_add",
(u64)"px_sub",
(u64)"px_mul",
(u64)"px_div",
(u64)"px_eval",
(u64)"px_widen",
(u64)"px_jump",
(u64)"px_ijump",
(u64)"px_neg",
(u64)"px_abs",
(u64)"px_bitnot",
(u64)"px_not",
(u64)"px_toboolt",
(u64)"px_sqr",
(u64)"px_sqrt",
(u64)"px_jumpcc",
(u64)"px_jumpt",
(u64)"px_jumpf",
(u64)"px_bitand",
(u64)"px_bitor",
(u64)"px_bitxor",
(u64)"px_shl",
(u64)"px_shr",
(u64)"px_retproc",
(u64)"px_retfn",
(u64)"px_setcall",
(u64)"px_setarg",
(u64)"px_callp",
(u64)"px_jumpret",
(u64)"px_jumpretm",
(u64)"px_startmx",
(u64)"px_resetmx",
(u64)"px_stop",
(u64)"px_incrto",
(u64)"px_decrto",
(u64)"px_incrload",
(u64)"px_decrload",
(u64)"px_loadincr",
(u64)"px_loaddecr",
(u64)"px_forup",
(u64)"px_fordown",
(u64)"px_iload",
(u64)"px_iloadx",
(u64)"px_istore",
(u64)"px_istorex",
(u64)"px_storem",
(u64)"px_addpx",
(u64)"px_subpx",
(u64)"px_to",
(u64)"px_iswap",
(u64)"px_swapstk",
(u64)"px_labeldef",
(u64)"px_addto",
(u64)"px_subto",
(u64)"px_multo",
(u64)"px_bitandto",
(u64)"px_bitorto",
(u64)"px_bitxorto",
(u64)"px_shlto",
(u64)"px_shrto",
(u64)"px_fix",
(u64)"px_float",
(u64)"px_idiv",
(u64)"px_irem",
(u64)"px_idivrem",
(u64)"px_clear",
(u64)"px_subp",
(u64)"px_switch",
(u64)"px_switchu",
(u64)"px_swlabel",
(u64)"px_endsw",
(u64)"px_fwiden",
(u64)"px_fnarrow",
(u64)"px_truncate",
(u64)"px_typepun",
(u64)"px_unload",
(u64)"px_loadbit",
(u64)"px_assem",
(u64)"px_sin",
(u64)"px_cos",
(u64)"px_tan",
(u64)"px_asin",
(u64)"px_acos",
(u64)"px_atan",
(u64)"px_log",
(u64)"px_log10",
(u64)"px_exp",
(u64)"px_round",
(u64)"px_floor",
(u64)"px_ceil",
(u64)"px_atan2",
(u64)"px_fmod",
(u64)"px_setcc",
(u64)"px_min",
(u64)"px_max",
(u64)"px_power",
(u64)"px_minto",
(u64)"px_maxto",
(u64)"px_negto",
(u64)"px_absto",
(u64)"px_addpxto",
(u64)"px_subpxto",
(u64)"px_divto",
(u64)"px_bitnotto",
(u64)"px_notto",
(u64)"px_toboolto",
(u64)"px_sign",
(u64)"px_loadbf",
(u64)"px_storebit",
(u64)"px_storebf",
(u64)"px_loadall",
(u64)"px_setjmp",
(u64)"px_longjmp",
(u64)"px_initdswx",
(u64)"do_addrmode"}};

static i64 $nprocs = 130;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

