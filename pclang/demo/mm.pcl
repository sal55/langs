; mm.m
    zstatic  u8:160 mm_blockpcl.casestmt 
    zstatic  u8:160 mm_blockpcl.caseelse 
    zstatic  i64   mm_blockpcl.casedepth 
    zstatic  u64   mm_blockpcl.sw_labeltable 
    zstatic  u64   mm_blockpcl.sw_valuetable 
    zstatic  i64   mm_blockpcl.sw_lower 
    zstatic  i64   mm_blockpcl.sw_ncases 
    zstatic  u8    mm_blockpcl.sw_defaultseen 
    zstatic  i64   mm_blockpcl.sw_defaultlabel 
    zstatic  i64   mm_blockpcl.sw_breaklabel 
    istatic  i64   mm_blockpcl.maxreg 
    data     u64   0 
    zstatic  u8:1024 mm_blockpcl.handlertable 
    istatic  u8:22 mm_blockpcl.start.dupltable 
    data     u8    29 
    data     u8    88 
    data     u8    94 
    data     u8    93 
    data     u8    113 
    data     u8    112 
    data     u8    114 
    data     u8    112 
    data     u8    115 
    data     u8    112 
    data     u8    108 
    data     u8    107 
    data     u8    106 
    data     u8    105 
    data     u8    101 
    data     u8    103 
    data     u8    102 
    data     u8    103 
    data     u8    50 
    data     u8    49 
    data     u8    30 
    data     u8    32 
    zstatic  u64   mm_decls.stprogram 
    zstatic  u64   mm_decls.stmodule 
    zstatic  u64   mm_decls.stsubprog 
    zstatic  u64   mm_decls.stsysmodule 
    zstatic  u64   mm_decls.alldeflist 
    zstatic  i64   mm_decls.currmoduleno 
    zstatic  u8:16 mm_decls.lx 
    zstatic  u8:16 mm_decls.nextlx 
    zstatic  u8:14070 mm_decls.moduletable 
    zstatic  u8:201 mm_decls.moduletosub 
    zstatic  u8:1302 mm_decls.subprogtable 
    zstatic  u8:408 mm_decls.libfiles 
    zstatic  u8:51 mm_decls.libtypes 
    zstatic  u8:8008 mm_decls.sourcefilespecs 
    zstatic  u8:8008 mm_decls.sourcefilepaths 
    zstatic  u8:8008 mm_decls.sourcefilenames 
    zstatic  u8:1001 mm_decls.sourcefilesys 
    zstatic  u8:1001 mm_decls.sourcefilesupport 
    zstatic  u8:8008 mm_decls.sourcefiletext 
    zstatic  u8:8008 mm_decls.sourcefiledupl 
    zstatic  u8:8008 mm_decls.sourcefilesizes 
    zstatic  i64   mm_decls.nmodules 
    zstatic  i64   mm_decls.nsubprogs 
    zstatic  i64   mm_decls.nsourcefiles 
    zstatic  i64   mm_decls.nlibfiles 
    zstatic  i64   mm_decls.mainmoduleno 
    zstatic  i64   mm_decls.ntypes 
    zstatic  u8:48008 mm_decls.ttnamedef 
    zstatic  u8:48008 mm_decls.ttowner 
    zstatic  u8:24004 mm_decls.ttbasetype 
    zstatic  u8:48008 ttname 
    zstatic  u8:24004 mm_decls.ttsize 
    zstatic  u8:6001 mm_decls.ttsizeset 
    zstatic  u8:24004 mm_decls.ttlower 
    zstatic  u8:24004 mm_decls.ttlength 
    zstatic  u8:48008 mm_decls.ttmult 
    zstatic  u8:48008 mm_decls.ttdimexpr 
    zstatic  u8:24004 mm_decls.tttarget 
    zstatic  u8:6001 mm_decls.ttusercat 
    zstatic  u8:24004 mm_decls.ttlineno 
    zstatic  u8:6001 mm_decls.ttsigned 
    zstatic  u8:6001 mm_decls.ttisreal 
    zstatic  u8:6001 mm_decls.ttisinteger 
    zstatic  u8:6001 mm_decls.ttisshort 
    zstatic  u8:6001 mm_decls.ttisref 
    zstatic  u8:6001 mm_decls.ttisblock 
    zstatic  u8:256032 mm_decls.typenames 
    zstatic  u8:32004 mm_decls.typenamepos 
    zstatic  i64   mm_decls.ntypenames 
    zstatic  u8:167 mm_decls.typestarterset 
    zstatic  u64   mm_decls.currproc 
    zstatic  u64   mm_decls.currsubprog 
    istatic  i64   mm_decls.debug 
    data     u64   0 
    istatic  i64   mm_decls.assemmode 
    data     u64   0 
    istatic  i64   mm_decls.headermode 
    data     u64   0 
    zstatic  u64   mm_decls.proclist 
    zstatic  u64   mm_decls.proclistx 
    zstatic  u64   mm_decls.staticlist 
    zstatic  u64   mm_decls.staticlistx 
    zstatic  u64   mm_decls.constlist 
    zstatic  u64   mm_decls.constlistx 
    zstatic  u64   mm_decls.nullunit 
    istatic  i64   mm_decls.targetbits 
    data     u64   64 
    istatic  i64   mm_decls.targetsize 
    data     u64   8 
    zstatic  u8:160 mm_decls.docstrings 
    zstatic  i64   mm_decls.ndocstrings 
    zstatic  i64   mm_decls.ndllproctable 
    zstatic  u8:8000 mm_decls.dllproctable 
    istatic  i64   mm_decls.fverbose 
    data     u64   1 
    istatic  u8    mm_decls.msyslevel 
    data     u8    2 
    istatic  u8    mm_decls.mvarlib 
    data     u8    0 
    istatic  u8    mm_decls.fvarnames 
    data     u8    0 
    istatic  u8    mm_decls.minos 
    data     u8    0 
    zstatic  u8    mm_decls.freadma 
    zstatic  u8    mm_decls.fwritema 
    zstatic  u8    mm_decls.fwriteexports 
    zstatic  u8    mm_decls.fwritedocs 
    zstatic  u8    mm_decls.fexe 
    zstatic  u8    mm_decls.fobj 
    zstatic  u8    mm_decls.fwritelibs 
    zstatic  u8    mm_decls.fshowtiming 
    zstatic  u8    mm_decls.fshowss 
    zstatic  u8    mm_decls.fshowmx 
    zstatic  u8    mm_decls.fshowpcl 
    zstatic  u8    mm_decls.fshowasm 
    zstatic  u8    mm_decls.fshowast1 
    zstatic  u8    mm_decls.fshowast2 
    zstatic  u8    mm_decls.fshowast3 
    zstatic  u8    mm_decls.fshowst 
    zstatic  u8    mm_decls.fshowstflat 
    zstatic  u8    mm_decls.fshowtypes 
    zstatic  u8    mm_decls.fshowoverloads 
    zstatic  u8    mm_decls.fshowmodules 
    zstatic  u8    mm_decls.foptim 
    istatic  u8    mm_decls.fcheckunusedlocals 
    data     u8    0 
    zstatic  u8    mm_decls.fnowindll 
    zstatic  u8    mm_decls.ffuntab 
    istatic  u8    mm_decls.fwindows 
    data     u8    1 
    zstatic  u8    mm_decls.flinux 
    zstatic  u8    mm_decls.fnofile 
    istatic  u8    mm_decls.dointlibs 
    data     u8    1 
    istatic  u8:112 mm_decls.passnames 
    data     u64   "header_pass"
    data     u64   "load_pass"
    data     u64   "parse_pass"
    data     u64   "fixup_pass"
    data     u64   "name_pass"
    data     u64   "type_pass"
    data     u64   "pcl_pass"
    data     u64   "mcl_pass"
    data     u64   "asm_pass"
    data     u64   "objpass"
    data     u64   "exe_pass"
    data     u64   "lib_pass"
    data     u64   "run_pass"
    data     u64   "clang_pass"
    istatic  u8:32 mm_decls.ccnames 
    data     u64   "gcc_cc"
    data     u64   "tcc_cc"
    data     u64   "tc_cc"
    data     u64   "bcc_cc"
    istatic  i64   mm_decls.passlevel 
    data     u64   0 
    istatic  i64   mm_decls.prodmode 
    data     u64   0 
    istatic  i64   mm_decls.debugmode 
    data     u64   0 
    istatic  i64   mm_decls.libmode 
    data     u64   0 
    istatic  i64   mm_decls.mxstub 
    data     u64   0 
    istatic  i64   mm_decls.ccompiler 
    data     u64   1 
    zstatic  u64   mm_decls.outfile 
    zstatic  u64   mm_decls.destfilename 
    zstatic  u64   mm_decls.destfilepath 
    zstatic  u64   mm_decls.asmfilename 
    zstatic  u64   mm_decls.pclfilename 
    zstatic  u64   mm_decls.exefilename 
    zstatic  u64   mm_decls.libfilename 
    zstatic  u64   mm_decls.objfilename 
    zstatic  u64   mm_decls.mafilename 
    zstatic  u64   mm_decls.expfilename 
    zstatic  u64   mm_decls.extendtypelist 
    zstatic  u8:1024 mm_decls.overloadtable 
    zstatic  i64   mm_decls.nunits 
    zstatic  i64   mm_decls.nstrecs 
    zstatic  i64   mm_decls.nreadassign 
    zstatic  i64   mm_decls.nsimple 
    zstatic  i64   mm_decls.nlbrack 
    zstatic  i64   mm_decls.nincr 
    zstatic  i64   mm_diags.currlineno 
    zstatic  i64   mm_diags.currfileno 
    istatic  i64   mm_diags.printunit.cmpchain 
    data     u64   0 
    zstatic  u8:1024 mm_diags.getprefix.str 
    zstatic  u8:40 mm_diags.getlineinfok.str 
    istatic  u64   mm_diags.printmodelist.tab 
    data     u64   "\t"
    istatic  u64   mm_diags.showprojectinfo.tab 
    data     u64   "    "
    zstatic  u8:32 mm_diags.strpmode.str 
    zstatic  u8:1024 mm_diags.strstringc.str 
    zstatic  u8:16 mm_export.sbuffer 
    istatic  u64   mm_export.dest 
    data     u64   mm_export.sbuffer 
    zstatic  u8:160 mm_lex.lxstart_stack 
    zstatic  u8:160 mm_lex.lxsource_stack 
    zstatic  u8:160 mm_lex.lxsptr_stack 
    zstatic  u8:160 mm_lex.lxfileno_stack 
    zstatic  u8:320 mm_lex.lxnextlx_stack 
    zstatic  u8:20 mm_lex.lximport_stack 
    istatic  i64   mm_lex.sourcelevel 
    data     u64   0 
    zstatic  i64   mm_lex.lximport 
    zstatic  u64   mm_lex.lxsource 
    zstatic  u64   mm_lex.lxstart 
    zstatic  u64   mm_lex.lxsptr 
    zstatic  i64   mm_lex.lxifcond 
    zstatic  i64   mm_lex.longsuffix 
    zstatic  i64   mm_lex.lxalllines 
    zstatic  i64   mm_lex.lxfileno 
    zstatic  u8:524288 mm_lex.hashtable 
    zstatic  i64   mm_lex.astringlength 
    istatic  u64   mm_lex.u64maxstr 
    data     u64   "18446744073709551615"
    zstatic  u8:256 mm_lex.alphamap 
    istatic  i64   mm_lib.autotypeno 
    data     u64   0 
    istatic  i64   mm_lib.nextavindex 
    data     u64   0 
    istatic  i64   mm_lib.nextsvindex 
    data     u64   0 
    zstatic  i64   mm_lib.readflag 
    zstatic  i64   mm_lib.parsedone 
    zstatic  u8:16 mm_lib.exprstrvar 
    istatic  u64   mm_lib.exprstr 
    data     u64   mm_lib.exprstrvar 
    istatic  u64   mm_lib.unitheapptr 
    data     u64   0 
    istatic  i64   mm_lib.remainingunits 
    data     u64   0 
    zstatic  u8:16 mm_lib.sbuffer 
    istatic  u64   mm_lib.dest 
    data     u64   mm_lib.sbuffer 
    zstatic  u64   mm_lib.framevarname 
    zstatic  u8:32 mm_lib.nextautotype.str 
    zstatic  u8:256 mm_lib.getdottedname.str 
    istatic  u8:16 mm_lib.getintintmode.elems 
    data     u64   3 
    data     u64   3 
    zstatic  u8:4096 mm_lib.strmode.str 
    zstatic  u8:4096 mm_lib.strmode2.str 
    zstatic  u8:128 mm_lib.getfullname.str 
    zstatic  u8:256 mm_lib.addstr.str 
    zstatic  u8:1600 mm_libpcl.loopstack 
    zstatic  i64   mm_libpcl.loopindex 
    zstatic  u64   mm_libpcl.stnprocs 
    zstatic  u64   mm_libpcl.stprocname 
    zstatic  u64   mm_libpcl.stprocaddr 
    zstatic  u8:400 mm_libpcl.blockdefs 
    zstatic  i64   mm_libpcl.nblocktemps 
    zstatic  u64   mm_libpcl.blockretname 
    zstatic  u8:256 mm_libpcl.getdispname.str 
    zstatic  u8:16 mm_libpcl.strvalue.str 
    istatic  u8:40 mm_libsources.syslibnames 
    data     u64   "msys.m"
    data     u64   "mlib.m"
    data     u64   "mclib.m"
    data     u64   "mwindows.m"
    data     u64   "mwindll.m"
    istatic  u8:40 mm_libsources.libtext 
    data     u64   "global record procinforec=\n\tword16\t\tfnindex\n\tbyte\t\trettype\n\tbyte\t\tnparams\n\t[12]byte\tparamlist\nend\n\n!for print/read routines\n!------------------------------------------\nrecord fmtrec=\t! (default)\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\n\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\n\tchar\tpadchar\t\t! Pc, Z (' ')\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\n\n\tchar\tplus\t\t! (0)   0 or '+'\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\n\tchar\tcharmode\t! C,D (0)  0 or 'C' or 'D'\to/p int as int or single char or double/multi-char\n\tchar\theapmode\t! M (0)  'M' for str-functions, return ptr tp heap string\n\tchar\tparam\t\t! Use int value for <fmtparam>\n\tbyte\tspare\nend\n\nint fmtparam\t\t\t!as set with :'V'\n\nenumdata =\n\tstd_io,file_io,str_io\nend\n\nconst comma = ','\n\nexport int $cmdskip\t\t\t!0 unless set by READMCX/etc\n\nexport int needgap\t\t\t= 0\nint outdev\t\t\t= std_io\nfilehandle outchan\t= nil\nref char fmtstr \t= nil\n\nconst maxiostack=10\narray [maxiostack]filehandle\toutchan_stack\narray [maxiostack]int\t\t\toutdev_stack\narray [maxiostack]ref char\tfmtstr_stack\narray [maxiostack]byte\t\tneedgap_stack\n\narray [maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\nint niostack=0\n\narray [0:]char digits=A\"0123456789ABCDEF\"\nconst onesixty=360\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\n\n!Read buffer vars\nconst rd_buffersize = 16384\t!total capacity of line buffer\n!const rd_buffersize = 524288\t!total capacity of line buffer\n\n!global ref char rd_buffer\t\t! point to start of read buffer\nexport ref char rd_buffer\t\t! point to start of read buffer\nexport int rd_length\t\t\t! length of this line (as read by readln)\nref char rd_pos\t\t\t! current position it's up to (next read starts here)\nref char rd_lastpos\t\t! set by sread() just before reading used for reread()\nint termchar\t\t\t! terminator char set by readxxx()\nint itemerror\t\t\t!\tset by some read functions, eg for reals\n\narray [4096]char printbuffer\nichar printptr\nint printlen\n\n!------------------------------------------\n\nconst maxparam=128\nexport int nsysparams\nexport int ncmdparams\nexport int nenvstrings\nexport [maxparam]ichar sysparams\n!export ref[]ichar cmdparams\nexport ref[0:]ichar cmdparams\nexport ref[]ichar envstrings\n!export [maxparam]ichar envstrings\n\nconst maxcallback=8\narray [0..maxcallback,8]word64 callbackstack\nint ncallbacks=0\n\nword64 mask63\t= 0x7FFF'FFFF'FFFF'FFFF\nreal offset64\t= 9223372036854775808.0\t\t! 2**63 as r64\nreal offset32\t= 9223372036854775808.0\t\t! 2**63 as r32\n\n!global proc m$init=\nproc start=\n\tint32 nargs\n\tint nargs64\n\tref[]ichar args\n\tstatic [128]byte startupinfo\t\t\t! 68 or 104 bytes\n\tint res\n!\tichar s\n\t\n!CPL \"MSYS\"\n\n\tres:=__getmainargs(&nargs,cast(&args),cast(&envstrings),0,cast(&startupinfo))\n\t\n\tnsysparams:=nargs\n\n\tif nsysparams>maxparam then\n\t\tprintf(\"Too many params\\n\")\n\t\tstop 50\n\tfi\n\n\tnargs64:=nargs\t\t\t!bug when using 32-bit limit when compiled with mm\n\tfor i:=1 to nargs64 do\n\t\tsysparams[i]:=args[i]\n\tod\n\t\n!assume nsysparams is >=1, since first is always the program name\n\tncmdparams:=nsysparams-($cmdskip+1)\n\tcmdparams:=cast(&sysparams[$cmdskip+1])\n\n\tint j:=1\n\tnenvstrings:=0\n\twhile envstrings[j] do\n\t\t++nenvstrings\n\t\t++j\n\tod\n\n!\t_setmode(0,32768);\n!\t_setmode(1,32768);\n!\t_setmode(2,32768);\n\nend\n\nproc pushio=\n\tif niostack>=maxiostack then\n\t\tprintf(\"Too many io levels\\n\")\n\t\tstop 53\n\tfi\n\t++niostack\n\toutchan_stack[niostack]\t:= outchan\n\toutdev_stack[niostack]\t:= outdev\n\tfmtstr_stack[niostack]\t:= fmtstr\n\tneedgap_stack[niostack]\t:= needgap\n\tneedgap:=0\n\tfmtstr:=nil\n\toutchan:=nil\nend\n\nexport proc m$print_startfile(ref void dev)=\n\tpushio()\n\toutchan:=cast(dev)\n\tif dev then\n\t\toutdev:=file_io\n\telse\n\t\toutdev:=std_io\n\tfi\n\tresetprintbuffer()\nend\n\nexport proc m$print_startstr(ref char s)=\n\tref ref char p\n\tpushio()\n\n\tptr_stack[niostack]:=s\n\tp:=&ptr_stack[niostack]\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startptr(ref ref char p)=\n\tpushio()\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startcon=\n!PRINTF(\"STARTCON %d\\n\",NIOSTACK);\n\tpushio()\n\toutdev:=std_io\n\tresetprintbuffer()\nend\n\nexport proc m$print_setfmt(ref char format)=\n\tfmtstr:=format\nend\n\nexport proc m$print_end=\n\tneedgap:=0\n\tnextfmtchars(1)\n\n\tif niostack=1 and outdev in [std_io,file_io] then\n!*!\t\tdumpprintbuffer()\n\tfi\n\n\tif niostack=0 then return fi\n\toutchan\t:= outchan_stack[niostack]\n\toutdev\t:= outdev_stack[niostack]\n\tfmtstr\t:= fmtstr_stack[niostack]\n\tneedgap\t:= needgap_stack[niostack]\n\n\n\t--niostack\n!PRINTF(\"ENDCON %d\\n\",NIOSTACK);\nend\n\nexport proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n\tarray [20]char s\n\n\tif fmtstyle=nil then\n\t\tfmtstyle:=\"z8H\"\n\tfi\n\tm$print_u64(a,fmtstyle)\nend\n\nexport proc m$print_ptr_nf(u64 a)=\n\tm$print_ptr(a)\nend\n\nexport proc m$print_i64(int64 a,ichar fmtstyle=nil)=\n\tarray [40]char s\n\tfmtrec fmt\n\tint n\n!PRINTF(\"M$PRTI64 NG=%lld\\n\",NEEDGAP)\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tif a>=0 then\n\t\t\tn:=u64tostr(a,&.s,10,0)\n\t\telse\n\t\t\ts[1]:='-'\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\n\t\tfi\n\n\t\tprintstr_n(&.s,n)\n\n\telse\n\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\tif fmt.param='V' then\n\t\t\tfmtparam:=a\n!CPL \"V:\",=FMTPARAM\n\t\t\tneedgap:=0\n\t\telse\n\t\t\ttostr_i64(a,&fmt)\n\t\tfi\n\tfi\n\tneedgap:=1\nend\n!PRINTF(\"....M$PRTI64 NG=%lld\\n\",NEEDGAP)\n\nexport proc m$print_i64_nf(int64 a)=\n\tm$print_i64(a)\nend\n\nexport proc m$print_bool(int64 a, ichar fmtstyle=nil)=\n\tif a then\n\t\tm$print_str(\"True\",fmtstyle)\n\telse\n\t\tm$print_str(\"False\",fmtstyle)\n\tfi\nend\n\nexport proc m$print_u64(word64 a,ichar fmtstyle=nil)=\n\tarray [40]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%llu\",a)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_u64(a,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_r64(real x,ichar fmtstyle=nil)=\n\tarray [360]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%f\",x)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_r64(x,&fmt)\n\tfi\n\n\tneedgap:=1\nend\n\nexport proc m$print_r32(real32 x,ichar fmtstyle=nil)=\n\tm$print_r64(x,fmtstyle)\nend\n\nglobal proc m$print_c8(int64 a,ichar fmtstyle=nil)=\n\tarray [40]char s\n\tfmtrec fmt\n\tint n\n\n\tnextfmtchars()\n\n\ts[1]:=a\n\ts[2]:=0\n\tprintstr(&.s)\n\tneedgap:=1\nend\n\nexport proc m$print_str(ichar s, fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr(s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,-1,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr_n(s,length)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,length,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_str_nf(ichar s)=\n\tm$print_str(s)\nend\n\nexport proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tfmtrec fmt\n!\tif fmtstyle=nil then\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\n!\telse\n\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\n!\t\tstrtofmt(fmtstyle,-1,&fmt)\n!\t\ttostr_str(s,s.len,&fmt)\n!\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_newline=\n\tneedgap:=0\n\tnextfmtchars(1)\n!RETURN\n\tprintstr(\"\\w\")\n!\tprintstr(\"\\n\")\nend\n\nexport proc m$print_nogap=\n\tneedgap:=0\nend\n\nexport proc m$print_space=\n\tneedgap:=0\n!RETURN\n\tprintstr(\" \")\nend\n\nexport proc printstr(ichar s)=\n\tprintstr_n(s,strlen(s))\nend\n\nexport proc printstr_n(ichar s,int n)=\n\tref ref char p\n\tFILEHANDLE F\n\n!RETURN\n\treturn when n=0\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\t\tRETURN\n\telse\t\t\t\t\t\t!assume str_io\n\t\tp:=cast(outchan)\n\t\tmemcpy(p^,s,n)\n\t\tp^+:=n\n\t\tp^^:=0\n\tesac\n\n!\tif niostack=1 and outdev in [std_io,file_io] then\n!\t\taddtobuffer(s,n)\n!\telse\n!\t\tdumpstr(s,n)\n!\tfi\nend\n\nexport proc printstrn_app(ichar s, int length, filehandle f=nil)=\n\tif length then\n\t\tif f=nil then\n\t\t\tprintf(\"%.*s\",length,s)\n\t\telse\n\t\t\tfprintf(f,\"%.*s\",length,s)\n\t\tfi\n\tfi\nend\n\nproc printchar(int ch)=\n\tref ref char p\n\tarray [4]char str\n!RETURN\n\n\tstr[1]:=ch\n\tstr[0]:=ch\n\tprintstr_n(str,1)\nend\n\nglobal proc nextfmtchars(int lastx=0)=\n\tchar c\n\tref char pstart\n\tint n\n\tif not fmtstr then\t\t\t!format not in use\n\t\tif needgap then\n\t\t\tprintchar(' ')\n\t\tfi\n\t\tneedgap:=0\n\t\treturn\n\tfi\n\n\tpstart:=fmtstr\n\tn:=0\n\n\tdo\n\t\tc:=fmtstr^\n\t\tswitch c\n\t\twhen '#' then\n\t\t\tif lastx then\n\t\t\t\tgoto skip\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\tfi\n\t\t\treturn\n\t\twhen 0 then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\telsif not lastx then\n\t\t\t\tprintstr_n(\"|\",1)\n\t\t\tfi\n\t\t\treturn\n\t\twhen '~' then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\t\tn:=0\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tc:=fmtstr^\n\t\t\tif c then\n\t\t\t\t++fmtstr\n\t\t\t\tprintchar(c)\n\t\t\tfi\n\t\t\tpstart:=fmtstr\n\t\telse\n\tskip::\n\t\t\t++n\n\t\t\t++fmtstr\n\t\tend switch\n\tod\nend\n\nproc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\n!convert format code string in s, to fmtrec at fmt^\n!Format code is a string containing the following char codes (upper or lower when mostly)\n!n\tWidth\n!.n\tMax width/precision\n!A\tConvert to upper when\n!a\tConvert to lower when\n!B\tBinary\n!C\tShow int as single n-bit (unicode) character\n!D\tShow int as multi-bit (unicode) character\n!E,F,G\tSpecify format for double (corresponds to C format codes)\n!F\n!G\n!H\tHex\n!JC\tJustify centre\n!JL\tJustify left\n!JR\tJustify right\n!M\tHEAPMODE???\n!O\tOctal\n!Pc\tUse padding char c\n!Q\tAdd double quotes around string (and deal with embedded quotes)\n!'\tAdd single quotes around string (and deal with embedded quotes)\n!Sc\tUse separator char c between every 3 or 4 digits\n!Tc\tUse terminator char c (typically B or H)\n!U\tShow ints as unsigned\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\n!W\tUnsigned\n!Xn\tUse base n (n is hex 0 to F)\n!Z\tUse \"0\" padding\n!+\tAlways have + or - in front of integers\n!~\tQuote char is ~\n!*\tSame as n but uses parameter set with :'V' on previous int\n\n\tint c, base\n\tbyte wset\n\tint n\n\tarray [0:100]char str\n\n\tfmt^:=defaultfmt\n\n\tif s=nil then return fi\n\n\tif slen=-1 then slen:=strlen(s) fi\n\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\n\tstr[slen]:=0\n\ts:=&.str\n\n\twset:=0\n\twhile s^ do\n\t\tc:=s^\n\t\t++s\n\t\tswitch c\n\t\twhen 'B', 'b' then fmt.base:=2\n\t\twhen 'H', 'h' then fmt.base:=16\n\t\twhen 'O', 'o' then fmt.base:=8\n\t\twhen 'X', 'x' then\n\t\t\tbase:=0\n\t\t\tdo\n\t\t\t\tc:=s^\n\t\t\t\tif c in '0'..'9' then\n\t\t\t\t\tbase:=base*10+c-'0'\n\t\t\t\t\t++s\n\t\t\t\telse\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\tod\n\t\t\tif base in 2..16 then\n\t\t\t\tfmt.base:=base\n\t\t\tfi\n\n\t\twhen 'Q', 'q' then fmt.quotechar:='\"'\n\t\twhen '~' then fmt.quotechar:='~'\n\t\twhen 'J', 'j' then\n\t\t\tfmt.justify:=toupper(s^)\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'A' then fmt.lettercase:='A'\n\t\twhen 'a' then fmt.lettercase:='a'\n\t\twhen 'Z', 'z' then fmt.padchar:='0'\n\t\twhen 'S', 's' then\n\t\t\tfmt.sepchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'P', 'p' then\n\t\t\tfmt.padchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'T', 't' then\n\t\t\tfmt.suffix:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'W', 'w' then fmt.usigned:='W'\n\t\twhen 'E', 'e' then fmt.realfmt:='e'\n\t\twhen 'F', 'f' then fmt.realfmt:='f'\n\t\twhen 'G', 'g' then fmt.realfmt:='g'\n! when '0','1','2','3','4','5','6','7','8','9' then\n\t\twhen '.' then\n\t\t\twset:=1\n\t\twhen comma,'_' then fmt.sepchar:=c\n\t\twhen '+' then fmt.plus:='+'\n\t\tWHEN 'D', 'd' then fmt.charmode:='M'\n\t\twhen 'C', 'c' then fmt.charmode:='C'\n\t\twhen 'M', 'm' then fmt.charmode:='M'\n\n\t\twhen 'V','v' then fmt.param:='V'\n\t\twhen '*' then\n\t\t\tn:=fmtparam\n\t\t\tgoto gotwidth\n\t\telse\n\t\t\tif c>='0' and c<='9' then\n\t\t\t\tn:=c-'0'\n\t\t\t\tdo\n\t\t\t\t\tc:=s^\n\t\t\t\t\tif s^=0 then\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tif c>='0' and c<='9' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\tn:=n*10+c-'0'\n\t\t\t\t\telse\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\tod\ngotwidth::\n\t\t\t\tif not wset then\n\t\t\t\t\tfmt.minwidth:=n\n\t\t\t\t\twset:=1\n\t\t\t\telse\n\t\t\t\t\tfmt.precision:=n\n\t\t\t\tfi\n\t\t\tfi\n\t\tend switch\n\tod\nend\n\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\n!there are n (4 or 8) chars at p.!\n!There could be 0 to 4 or 8 printable chars converted to string at dest\n\tarray [0:20]char str\n\tref char q\n\tint i,nchars\n\n\tq:=&.str\n\n\tnchars:=n\n\n\tto n do\n\t\tif p^=0 then exit fi\n\t\tq^:=p^\n\t\t++q\n\t\t++p\n\tod\n\tq^:=0\n\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\nend\n\nfunction expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\n!s contains a partly stringified value.\n!widen s if necessary, according to fmt, and copy result to t\n!n is current length of s\n!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving\n!a leading +/- when right-justifying with '0' padding.\n!t MUST be big enough for the expanded string; caller must take care of this\n!result will be zero-terminated, for use in this module\n\n\tint i,w,m\n\n!check to see if result is acceptable as it is\n\tw:=fmt.minwidth\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\n\t\tstrncpy(t,s,n)\n\t\t(t+n)^:=0\n\t\treturn n\n\tfi\n\n\tif fmt.justify='L' then\t! left-justify\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tfor i:=1 to w-n do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\telsif fmt.justify='R' then\n\t\tif fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside \n\t\t\tt^:=s^\n\t\t\t++t\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s+1,n-1)\n\t\t\t(t+n-1)^:=0\n\t\telse\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s,n)\n\t\t\t(t+n)^:=0\n\t\tfi\n\n\telse\t\t\t\t! centre-justify?\n\n\t\tm:=(w-n+1)/2\n\t\tto m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tto w-n-m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\n\tfi\n\treturn w\nend\n\nfunction u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\n!convert 64-bit int a to string in s^\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\n!result when a=minint (will give \"<minint>\")\n\tarray [0:onesixty]char t\n\tu64 dd\n\tint i,j,k,g\n\tint cc\n\tint dummy\n\tref char s0\n\n\ti:=0\n\tk:=0\n\tg:=(base=10|3|4)\n\n\trepeat\n!\t\tif base=10 then\n!\t\t\tassem\n!\t\t\t\tmov\t\trcx, [aa]\n!\t\t\t\tmov\t\trax, rcx\n!\t\t\t\tmov\t\trdx, 7378697629483820647\n!\t\t\t\timul\trdx\n!\t\t\t\tmov\t\trax, rdx\n!\t\t\t\tmov\t\trdx, rcx\n!\t\t\t\tsar\t\trdx, 63\n!\t\t\t\tsar\t\trax, 2\n!\t\t\t\tsub\t\trax, rdx\n!\t\t\t\tlea\t\trdx, [rax+rax*4]\n!\t\t\t\tadd\t\trdx, rdx\n!\t\t\t\tsub\t\trcx, rdx\n!\t\t\t\tmov\t\t[dd], rcx\n!\t\t\t\tmov\t\t[aa], rax\n!\t\t\tend\n!\t\telse\n\t\t\tdd:=aa rem base\n\t\t\taa:=aa/base\n!\t\tfi\n\n\t\tt[++i]:=digits[dd]\n\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\n!out a full length binary\n!so perhaps move this out to expandstr\n\t\t++k\n\t\tif sep and aa<>0 and k=g then\n\t\t\tt[++i]:=sep\n\t\t\tk:=0\n\t\tfi\n\tuntil aa=0\n\n\tj:=i\n\ts0:=s\n\twhile i do\n\t\ts^:=t[i--]\n\t\t++s\n\tod\n\ts^:=0\n\n\treturn j\nend\n\nfunction i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\n!convert a to a string in s, according to fmt\n!a basic conversion is done first,: the field manipulation is done\n!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)\n!returns length of s\n\tarray [0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint i,j,k,n,w,usigned\n\tconst i64 mindint=0x8000'0000'0000'0000\n\n\n\n\tusigned:=0\n\tif fmt.usigned then\n\t\tusigned:=1\n\tfi\n!PUTS(\"I64TOSTR\")\n\tif aa=mindint and not usigned then\t\t! minint\n\n\t\tstr[0]:='-'\n\t\tn:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1\n!CPL =INT(STR[0])\n!CPL =INT(STR[1])\n\n\telse\n\t\tif (not usigned and aa<-0) or fmt.plus then\n\t\t\tif aa<0 then\n\t\t\t\taa:=-aa\n\t\t\t\tstr[0]:='-'\n\t\t\telse\n\t\t\t\tstr[0]:='+'\n\t\t\tfi\n\t\t\tn:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1\n\t\telse\n\t\t\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\t\tfi\n\tfi\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'\tthen\t! need lower when\n\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nfunction u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\n!see i64tostrfmt\n\tarray [0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint i,j,k,n,w\n\n\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif fmt.base>10 or fmt.suffix and fmt.lettercase='a'\tthen\t! need lower when\n!\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nfunction i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\n!convert minint to string in s do not include minus sign\n!return number of chars in string\n\tarray [0:onesixty]char t\n\tint i,j,k,g,neg\n\n\tswitch base\n\twhen 10 then\n\t\tstrcpy(&t[0],\"9223372036854775808\")\n\t\tj:=3\n\twhen 16 then\n\t\tstrcpy(&t[0],\"8000000000000000\")\n\t\tj:=1\n\twhen 2 then\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\n\t\tj:=7\n\telse\n\t\tstrcpy(&t[0],\"<mindint>\")\n\tend switch\n\n\ti:=strlen(&t[0])\n\ts+:=i\n\tif sep then\n\t\ts+:=j\n\tfi\n\ts^:=0\n\n\tk:=0\n\tg:=(base=10|3|4)\n\n\twhile i do\n\t\t--s\n\t\ts^:=t[i-- -1]\n\t\tif sep and i and ++k=g then\n\t\t\t--s\n\t\t\ts^:=sep\n\t\t\tk:=0\n\t\tfi\n\tod\n\treturn strlen(s)\nend\n\nfunction strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\n!s is a string process according to fmtrec fmt^, and return result in t\n!caller should check whether any changes are required to s (now it can just use s), but this\n!check is done here anyway (with a simple copy to t)\n!n is current length of s\n!return length of t\n!Three processing stages:\n!1 Basic input string s\n!2 Additions or mods: quotes, suffix, when conversion\n!3 Width adjustment\n!1 is detected here, 2 is done here, 3 is done by expandstr\n\tref char u,v\n\tarray [256]char str\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\n\n\tnheap:=0\n\n\tif fmt.quotechar or fmt.lettercase then\t\t! need local copy\n\t\tif n<256 then\n\t\t\tu:=&.str\n\t\telse\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\n\t\t\tu:=pcm_alloc(nheap)\n\t\tfi\n\t\tif fmt.quotechar then\n\t\t\tv:=u\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tif n then\n\t\t\t\tstrcpy(v,s)\n\t\t\t\tv+:=n\n\t\t\tfi\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tv^:=0\n\t\t\tn+:=2\n\t\telse\n\t\t\tmemcpy(u,s,n)\n\t\tfi\n\t\tswitch fmt.lettercase\n\t\twhen 'a' then\t! need lower when\n\t\t\tconvlcstring(u)\n\t\twhen 'A' then\n\t\t\tconvucstring(u)\n\t\tend switch\n\t\ts:=u\n\tfi\n\n\tw:=fmt.minwidth\n\tif w>n then\n\t\tn:=expandstr(s,t,n,fmt)\n\telse\n\t\tmemcpy(t,s,n)\n\tfi\n\tif nheap then\n\t\tpcm_free(u,nheap)\n\tfi\n\treturn n\nend\n\nproc tostr_i64(int64 a, ref fmtrec fmt)=\n\tarray [360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 0 then\n\t\tn:=i64tostrfmt(a,&.str,fmt)\n!\twhen 'D','d' then\n\twhen 'M','m' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\telse\t\t\t\t\t\t!assume 'C'\n\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_u64(word64 a, ref fmtrec fmt)=\n\tarray [360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 'D','d' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\twhen 'C','c' then\n\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\n\telse\n\t\tn:=u64tostrfmt(a,&.str,fmt)\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_r64(real x,ref fmtrec fmt) =\n\tarray [360]char str,str2\n\tarray [0:10]char cfmt\n\tint n\n\n\tcfmt[0]:='%'\n\n\tif fmt.precision then\n\t\tcfmt[1]:='.'\n\t\tcfmt[2]:='*'\n\t\tcfmt[3]:=fmt.realfmt\n\t\tcfmt[4]:=0\n\t\tsprintf(&.str,&.cfmt,fmt.precision,x)\n\telse\n\t\tcfmt[1]:=fmt.realfmt\n\t\tcfmt[2]:=0\n\t\tsprintf(&.str,&.cfmt,x)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\n\tn:=strlen(&.str)\t\t! current length\n\n\tif n<fmt.minwidth then\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\n\t\tstrcpy(&.str,&.str2)\n\tfi\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_str(ref char s, int oldlen, ref fmtrec fmt) =\n\tint newlen,n\n\tref char t\n\n!try and work out size of formatted string\n\tif oldlen=-1 then\n\t\toldlen:=strlen(s)\n\tfi\n\tnewlen:=oldlen\n\n\tif fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then\n\t\tif fmt.quotechar then\n\t\t\tnewlen+:=2\n\t\tfi\n\t\tif fmt.minwidth>newlen then\n\t\t\tnewlen:=fmt.minwidth\n\t\tfi\n\t\tt:=pcm_alloc(newlen+1)\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\n\t\tif fmt.precision then\n\t\t\tn min:=fmt.precision\n\t\tfi\n\n\t\tprintstr_n(t,n)\n\t\tpcm_free(t,newlen+1)\n\telse\n\t\tprintstr_n(s,oldlen)\n\tfi\nend\n\nfunction getfmt(ichar fmtstyle)ref fmtrec=\n\tstatic fmtrec fmt\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\treturn &fmt\n\telse\n\t\treturn &defaultfmt\n\tfi\nend\n\nexport function strint(int64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport proc getstrint(int64 a, ichar dest)=\n\tm$print_startstr(dest)\n\ttostr_i64(a,getfmt(nil))\n\tm$print_end()\nend\n\nexport function strword(word64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function strreal(real a, ichar fmtstyle=nil)ichar=\n\tstatic [320]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function getstr(ichar s, ref fmtrec fmt)ichar=\n\tif fmt.heapmode then\n\t\treturn pcm_copyheapstring(s)\n\telse\n\t\treturn s\n\tfi\nend\n\nproc initreadbuffer=\n\tif rd_buffer then return fi\n\trd_buffer:=pcm_alloc(rd_buffersize)\n\trd_buffer^:=0\n\trd_pos:=rd_lastpos:=rd_buffer\nend\n\nglobal proc m$read_conline=\n\tinitreadbuffer()\n\n\treadlinen(nil,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_fileline(filehandle f)=\n\tichar p\n\tinitreadbuffer()\n\n\tif f=filehandle(1) then\nABORTPROGRAM(\"READ CMDLINE\")\n!\t\trd_buffer^:=0\n!\t\tp:=getcommandlinea()\n!\t\trepeat\n!\t\t\t++p\n!\t\tuntil p^ in [' ','\\t',0]\n!\t\tstrcpy(rd_buffer, p)\n!\t\trd_length:=strlen(rd_buffer)\n!\t\trd_pos:=rd_buffer\n!\t\trd_lastpos:=nil\n\t\treturn\n\tfi\n\n\treadlinen(f,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_strline(ichar s)=\n\tint n\n\n\tinitreadbuffer()\n\tn:=strlen(s)\n\n\tif n<rd_buffersize then\n\t\tstrcpy(rd_buffer,s)\n\telse\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\n\t\t(rd_buffer+rd_buffersize-1)^:=0\n\tfi\n\trd_length:=n\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nfunction readitem(int &itemlength)ref char =\n!read next item from rd_buffer\n!identify a substring that can contain a name, int, real, string or filename\n!return updated position of s that points past the item and past the immediate\n!terminator \n!information about the read item is returned in itemstr, which points to\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\n!Item can be quoted, then the item points inside the quotes\n!Any embedded quotes are removed, and the characters moved up. The item will\n!be that reduced subsequence\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\n!I can mitigate this by adding spaces between the end of the item, and the next item,\n!overwriting also the terminator. But this won't restore the line if one of the next\n!reads is literal, using 'L' or 'C' codes.\n\tref char p,s,itemstr\n\tchar quotechar, c\n\n\tunless rd_buffer then \n\t\tinitreadbuffer()\n\tend unless\n\n\ts:=rd_pos\n\n!scan string, eliminating leading white space\n\twhile s^=' ' or s^=9 do\n\t\t++s\n\tod\n\n\titemstr:=s\t\t\t\t!assume starts here\n\trd_lastpos:=rd_pos:=s\n\n\tif s^=0 then\t\t\t! No more chars left to read return null string\n\t\ttermchar:=0\n\t\titemlength:=0\n\t\treturn s\n\tfi\n\n\tquotechar:=0\t\t\t! Allow possible enclosing single or double quotes\n\tif s^='\"' then\n\t\tquotechar:='\"'\n\t\t++s\n\telsif s^='\\'' then\n\t\tquotechar:='\\''\n\t\t++s\n\tfi\n\n!loop reading characters until separator or end reached\n\tp:=itemstr:=s\n\n\twhile s^ do\n\t\tc:=s++^\n\t\tswitch c\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\n\t\t\t\tgoto normalchar\n\t\t\tfi\n\t\t\ttermchar:=c\n\t\t\texit\n\t\telse\n\tnormalchar::\n\t\t\tif c=quotechar then\n\t\t\t\tif s^=quotechar then\t! embedded quote\n\t\t\t\t\tp^:=c\n\t\t\t\t\t++s\n\t\t\t\t\t++p\n\t\t\t\telse\t\t\t\t\t! end of name\n\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tif termchar=',' or termchar='=' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tfi\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tp^:=c\n\t\t\t\t++p\n\t\t\tfi\n\t\tend switch\n\tod\n\n\tif s^=0 then\n\t\ttermchar:=0\n\tfi\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\n\trd_pos:=s\n\n\treturn itemstr\nend\n\nexport function strtoint(ichar s,int length=-1, word base=10)int64=\n!return point to next char after terminator (which can be just off length of string)\n\tbyte signd\n\tword64 aa\n\tword c,d\n\n\titemerror:=0\n\n\tif length=-1 then\n\t\tlength:=strlen(s)\n\tfi\n!check for sign\n\tsignd:=0\n\tif length and s^='-' then\n\t\tsignd:=1; ++s; --length\n\telsif length and s^='+' then\n\t\t++s; --length\n\tfi\n\n\taa:=0\n\twhile length do\n\t\tc:=s++^\n\t\t--length\n\t\tswitch c\n\t\twhen 'A'..'F' then d:=c-'A'+10\n\t\twhen 'a'..'f' then d:=c-'a'+10\n\t\twhen '0'..'9' then d:=c-'0'\n\t\twhen '_', '\\'' then\n\t\t\tnext\n\t\telse\n\t\t\titemerror:=1\n\t\t\texit\n\t\tend switch\n\n\t\tif d>=base then\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\t\taa:=aa*base+d\n\tod\n\n\tif signd then\n\t\treturn -aa\n\telse\n\t\treturn aa\n\tfi\nend\n\nglobal function m$read_i64(int fmt=0)int64=\n\tref char s\n\tint length,c\n\tint64 aa\n\n\tcase fmt\n\twhen 'C','c' then\n\t\trd_lastpos:=rd_pos\n\t\tif rd_pos^ then\n\t\t\treturn rd_pos++^\n\t\telse\n\t\t\treturn 0\n\t\tfi\n\twhen 'T','t' then\n\t\treturn termchar\n\twhen 'E','e' then\n\t\treturn itemerror\n\tesac\n\n\ts:=readitem(length)\n\n\tcase fmt\n\twhen 0,'I','i' then\n\t\treturn strtoint(s,length)\n\twhen 'B','b' then\n\t\treturn strtoint(s,length,2)\n\twhen 'H','h' then\n\t\treturn strtoint(s,length,16)\n\tesac\n\treturn 0\nend\n\nglobal function m$read_r64(int fmt=0)real=\n\tarray [512]char str\n\tref char s\n\tint length\n\tint32 numlength\n\treal x\n\n\ts:=readitem(length)\n\n\tif length=0 or length>=str.len then\t\t!assume not a real\n\t\treturn 0.0\n\tfi\n\tmemcpy(&.str,s,length)\n\tstr[length+1]:=0\n\n\titemerror:=0\n\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\n\t\tx:=0.0\n\t\titemerror:=1\n\tfi\n\n\treturn x\nend\n\nglobal proc m$read_str(ref char dest, int destlen=0,fmt=0)=\n\tref char s\n\tint length,numlength\n\treal x\n\n\titemerror:=0\n\tif fmt='L' or fmt='l' then\n\t\ts:=rd_pos\n\t\tlength:=rd_buffer+rd_length-rd_pos\n\n\telse\n\t\ts:=readitem(length)\n\n\t\tif fmt='N' or fmt='n' then\n\t\t\ticonvlcn(s,length)\n\t\tfi\n\tfi\n\n\tif destlen>0 then\n\t\tif length>=destlen then\n\t\t\tlength:=destlen-1\n\t\t\titemerror:=1\n\t\tfi\n\tfi\n\tmemcpy(dest,s,length)\n\t(dest+length)^:=0\nend\n\nexport proc readstr(ref char dest, int fmt=0,destlen=0)=\n\tm$read_str(dest,destlen,fmt)\nend\n\nexport proc rereadln=\n\trd_pos:=rd_buffer\n\trd_lastpos:=rd_pos\nend\n\nexport proc reread=\n\trd_pos:=rd_lastpos\nend\n\nexport function valint(ichar s, int fmt=0)int64=\n\tref char old_pos, old_lastpos\n\tint64 aa\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\taa:=m$read_i64(fmt)\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn aa\nend\n\nexport function valreal(ichar s)real=\n\tref char old_pos, old_lastpos\n\treal x\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\tx:=m$read_r64()\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn x\nend\n\nproc mclunimpl(ichar mess)=\n\tprintf(\"MCL-UNIMPL: %s\\n\",mess)\n\tstop 1\nend\n\nproc dumpstr(ichar s, int n, fbuffer=0)=\n!fbuffer=1 when outputting contents of buffer\n\n\tref ref char p\n\n\treturn when n=0\n\n\tif outdev=str_io then\n\t\tp:=cast(outchan)\n\t\tmemcpy(p^,s,n)\n\t\tp^+:=n\n\t\tp^^:=0\n\t\treturn\n\tfi\n\n\tif fbuffer and n>=2 and outdev=std_io then\n\t\t--printptr\t\t\t\t!point to last char\n\t\tif printptr^=10 then\n\t\t\tif (printptr-1)^=13 then\t\t!crlf\n!PUTS(\"<CRLF>\")\n\t\t\t\t(printptr-1)^:=0\n\t\t\telse\t\t\t\t\t\t\t!lf only\n!PUTS(\"<LF>\")\n\t\t\t\tprintptr^:=0\n\t\t\tfi\n\t\t\tputs(printbuffer)\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\tesac\nend\n\nproc dumpprintbuffer=\n\tif printlen then\n\t\tdumpstr(&.printbuffer,printlen,1)\n\tfi\n\n\tresetprintbuffer()\nend\n\nproc resetprintbuffer=\n\tprintptr:=&.printbuffer\n\tprintlen:=0\nend\n\nproc addtobuffer(ichar s, int n)=\n!RETURN\n\tif printlen+n>=(printbuffer.len-8) then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif n<printbuffer.len then\n\t\tmemcpy(printptr,s,n)\n\t\tprintptr+:=n\n\t\tprintlen+:=n\n\t\treturn\n\tfi\n\n\tdumpstr(s, n)\t\t\t!don't bother with buffer\nend\n\nglobal function m$power_i64(int64 a,n)int64=\n\tif n<0 then\n\t\treturn 0\n\telsif n=0 then\n\t\treturn 1\n\telsif n=1 then\n\t\treturn a\n\telsif (n iand 1)=0 then\n\t\treturn m$power_i64(sqr a,n/2)\n\telse\t\t\t!assume odd\n\t\treturn m$power_i64(sqr a,(n-1)/2)*a\n\tfi\nend\n\n!export function vector_dupl(ref void p, int size)ref void=\n!\tCPL \"VECTOR_DUPL\",P,SIZE\n!\tp\n!end\n"
    data     u64   "!const mem_check=1\nconst mem_check=0\n\nglobal [0..300]u64 allocupper\nglobal int alloccode\t\t\t\t!set by heapalloc\nexport int allocbytes\t\t\t\t!set by heapalloc\nexport int fdebug=0\nexport int rfsize\n\nconst threshold=1<<25\nconst alloc_step=1<<25\nword maxmemory\nint  maxalloccode\n\nGLOBAL REF VOID ALLOCBASE\n\nbyte pcm_setup=0\n\nint show=0\n\nexport int memtotal=0\nexport int64 smallmemtotal=0\nglobal int smallmemobjs=0\nglobal int maxmemtotal=0\n\n!store all allocated pointers\nconst int maxmemalloc=(mem_check|500000|2)\narray [maxmemalloc+1]ref int32 memalloctable\narray [maxmemalloc+1]int32 memallocsize\n\nconst pcheapsize=1048576*2\nref byte pcheapstart\nref byte pcheapend\t\t\t!points to first address past heap\nref byte pcheapptr\n\nconst int maxblockindex = 8 \t\t!2048\nexport const int maxblocksize = 2048\nexport const int $maxblocksizexx = 2048\n\narray [0:maxblocksize+1]byte sizeindextable\t!convert byte size to block index 1..maxblockindex\n\nconst int size16   = 1\t\t\t!the various index codes\nconst int size32   = 2\nconst int size64   = 3\nconst int size128  = 4\nconst int size256  = 5\nconst int size512  = 6\nconst int size1024 = 7\nconst int size2048 = 8\n\nexport [0:9]ref word freelist\n\nexport record strbuffer =\n\tichar strptr\n\tint32 length\n\tint32 allocated\nend\n\n!export tabledata() [0:]ichar pmnames=\nexport enumdata [0:]ichar pmnames=\n\t(pm_end=0,\t\t$),\n\t(pm_option,\t\t$),\n\t(pm_sourcefile,\t$),\n\t(pm_libfile,\t$),\n\t(pm_colon,\t\t$),\n\t(pm_extra,\t\t$),\nend\n\n[2]word seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)\n!array [2]int seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)\n\nexport function pcm_alloc(int n)ref void =\n\tref byte p\n\n\tif not pcm_setup then\n\t\tpcm_init()\n\tfi\n\n\tif n>maxblocksize then\t\t\t!large block allocation\n\t\talloccode:=pcm_getac(n)\n\t\tallocbytes:=allocupper[alloccode]\n\n\t\tp:=allocmem(allocbytes)\n\t\tif not p then\n\t\t\tabortprogram(\"pcm_alloc failure\")\n\t\tfi\n\n!\t\tif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\n\n\t\treturn p\n\tfi\n\n\talloccode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\tallocbytes:=allocupper[alloccode]\n\tsmallmemtotal+:=allocbytes\n\n\tif p:=ref byte(freelist[alloccode]) then\t\t!Items of this block size available\n!\t\tif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\n\t\tfreelist[alloccode]:=ref word(int((freelist[alloccode])^))\n\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\tp:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\n\tpcheapptr+:=allocbytes\t\t\t!Shrink remaining pool\n\n\tif pcheapptr>=pcheapend then\t\t!Overflows?\n\t\tp:=pcm_newblock(allocbytes)\t\t!Create new heap block, and allocate from start of that\n\t\treturn p\n\tfi\n!\tif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\n\n\treturn p\nend\n\nexport proc pcm_free(ref void p,int n) =\n!n can be the actual size requested it does not need to be the allocated size\n\tint acode\n\n\tif n=0 then return fi\n\n\tif n>maxblocksize then\t\t!large block\n!\t\tif mem_check then removefrommemalloc(p,n) fi\nMEMTOTAL-:=N\n\t\tfree(p)\n\t\treturn\n\tfi\n\n\tif p then\n\t\tacode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\n\t\tsmallmemtotal-:=allocupper[acode]\n\n!\t\tif mem_check then removefrommemalloc(p,allocupper[acode]) fi\n\n\t\tcast(p,ref word)^:=word(int(freelist[acode]))\n\t\tfreelist[acode]:=p\n\tfi\nend\n\nexport proc pcm_freeac(ref void p,int alloc) =\n\tpcm_free(p,allocupper[alloc])\nend\n\n!export proc pcm_copymem4(ref void p,q,int n) =\t!PCM_COPYMEM4\n!!copy n bytes of memory from q to p.\n!!the memory spaces used are multiples of 16 bytes, but n itself could be anything\n!!n can be zero, and need not be a multiple of 4 bytes\n!\n!\tmemcpy(p,q,n)\n!end\n\nexport proc pcm_clearmem(ref void p,int n) =\n\tmemset(p,0,n)\nend\n\nexport proc pcm_init =\n!set up sizeindextable too\n\tint j,k,k1,k2\n\tint64 size\n\tconst limit=1<<33\n\n\talloccode:=0\n\tif pcm_setup then\n\t\treturn\n\tfi\n\n\tpcm_newblock(0)\n\n\tfor i to maxblocksize do\t!table converts eg. 78 to 4 (4th of 16,32,64,128)\n!CPL \"PCMI\",i\n\t\tj:=1\n\t\tk:=16\n\t\twhile i>k do\n\t\t\tk:=k<<1\n\t\t\t++j\n\t\tod\n\t\tsizeindextable[i]:=j\n\tod\n\n\tallocupper[1]:=16\n\tsize:=16\n\n\tfor i:=2 to 27 do\n\t\tsize*:=2\n\t\tallocupper[i]:=size\n\t\tif size>=threshold then\n\t\t\t\tk:=i\n\t\t\texit\n\t\tfi\n\tod\n\n\tfor i:=k+1 to allocupper.upb do\n\t\tsize+:=alloc_step\n\t\tif size<limit then\n\t\t\tallocupper[i]:=size\n\t\t\tmaxmemory:=size\n\t\telse\n\t\t\tmaxalloccode:=i-1\n\t\t\texit\n\t\tfi\n\t\t\n\tod\n!CPL \"PCLINIT END\"\n\tpcm_setup:=1\nend\n\nexport function pcm_getac(int size)int =\n! convert linear blocksize from 0..approx 2GB to 8-bit allocation code\n\n!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]\t\t!size 0 to 2KB\n\tfi\n\n\tsize:=(size+255)>>8\t\t\t\t\t!scale by 256\n\n!now same sizetable can be used for 2KB to 512KB (288 to 2KB)\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+8\n\tfi\n\n!sizetable now used for 512KB to 128MB (to 2KB)\n\tsize:=(size+63)>>6\t\t\t\t\t!scale by 256\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+14\n\tfi\n\n!size>2048, which means it had been over 128MB.\n\tsize:=(size-2048+2047)/2048+22\n\treturn size\nend\n\nexport function pcm_newblock(int itemsize)ref void=\n!create new heap block (can be first)\n!also optionally allocate small item at start\n!return pointer to this item (and to the heap block)\n\tstatic int totalheapsize\n\tref byte p\n\n\ttotalheapsize+:=pcheapsize\n\talloccode:=0\n\tp:=allocmem(pcheapsize)\t!can't free this block until appl terminates\n\tif p=nil then\n\t\tabortprogram(\"Can't alloc pc heap\")\n\tfi\n\n\tpcheapptr:=p\n\tpcheapend:=p+pcheapsize\n\n\tif pcheapstart=nil then\t\t!this is first block\n\t\tpcheapstart:=p\n\tfi\n\tpcheapptr+:=itemsize\n\treturn ref u32(p)\nend\n\nexport function pcm_round(int n)int =\n!for any size n, return actual number of bytes that would be allocated\n\tstatic [0:maxblockindex+1]int32 allocbytes=(0,16,32,64,128,256,512,1024,2048)\n\n\tif n>maxblocksize then\n\t\treturn n\n\telse\n\t\treturn allocbytes[sizeindextable[n]]\n\tfi\nend\n\nexport function pcm_allocz(int n)ref void =\n\tref void p\n\tp:=pcm_alloc(n)\n\n\tmemset(p,0,n)\n\treturn p\nend\n\nexport function pcm_copyheapstring(ref char s)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tint n\n\tif s=nil then return nil fi\n\n\tn:=strlen(s)+1\n\tq:=pcm_alloc(n)\n\tmemcpy(q,s,n)\n\treturn q\nend\n\nexport function pcm_copyheapstringn(ref char s,int n)ref char =\n\tref char q\n\tif s=nil then return nil fi\n\n\tq:=pcm_alloc(n+1)\n\tmemcpy(q,s,n)\n\t(q+n)^:=0\n\treturn q\nend\n\nexport function pcm_copyheapblock(ref char s, int length)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tif length=0 then return nil fi\n\n\tq:=pcm_alloc(length)\n\tmemcpy(q,s,length)\n\treturn q\nend\n\n!proc addtomemalloc(ref int32 ptr,int size)=\n!!add ptr to allocated table\n!\tint allocated, code\n!\n!!CPL \"***************ADD TO ALLOC:\",ptr,size\n!\tfor i to maxmemalloc do\n!\t\tif memalloctable[i]=ptr then\n!\t\t\tCPL \"ALLOC ERROR:\",ptr,\"ALREADY ALLOCATED\\n\\n\\n\"\n!\t\t\tstop 2\n!\t\tfi\n!\n!\t\tif memalloctable[i]=nil then\t\t!unused entry\n!\t\t\tmemalloctable[i]:=ptr\n!\n!\t\t\tcode:=pcm_getac(size)\n!\t\t\tallocated:=allocupper[code]\n!\n!\t\t\tmemallocsize[i]:=allocated\n!\t\t\treturn\n!\t\tfi\n!\tod\n!\tCPL \"MEMALLOCTABLE FULL\\n\\n\\n\\n\"; os_getch()\n!\tCPL\n!\tstop 3\n!end\n\n!proc removefrommemalloc(ref int32 ptr,int size)=\n!!remove ptr to allocated table\n!\tint allocated, code\n!\n!!CPL \"------------------************REMOVE FROM ALLOC:\",ptr,size\n!\tcode:=pcm_getac(size)\n!\tallocated:=allocupper[code]\n!\n!\tfor i to maxmemalloc do\n!\t\tif memalloctable[i]=ptr then\n!\t\t\tif memallocsize[i]<>ALLOCATED then\n!!\t\t\t\tCPL \"REMOVE:FOUND\",ptr,\"IN MEMALLOCTABLE, FREESIZE=\",size,\", BUT STORED AS BLOCK SIZE:\",memallocsize[i]\n!\t\t\t\tCPL \"REMOVE:FOUND\",ptr,\"IN MEMALLOCTABLE, ROUNDED FREESIZE=\",ALLOCATED,\", BUT STORED AS BLOCK SIZE:\",memallocsize[i]\n!\t\t\t\tabortprogram(\"MEMSIZE\")\n!\t\t\tfi\n!\t\t\tmemalloctable[i]:=nil\n!\t\t\treturn\n!\t\tfi\n!\tod\n!\tCPL \"CAN'T FIND\",ptr,\"IN MEMALLOCTABLE\",size\n!\tCPL \n!OS_GETCH()\n!\tabortprogram(\"MEM\")\n!\tstop 4\n!end\n\nexport function allocmem(int n)ref void =\n\tref void p\n\n\tp:=malloc(n)\n\tif p then\nMEMTOTAL+:=N\n\t\treturn p\n\tfi\n\n\tprintln n,memtotal\n\tabortprogram(\"Alloc mem failure\")\n\treturn nil\nend\n\nglobal function reallocmem(ref void p,int n)ref void =\n\tp:=realloc(p,n)\n\treturn p when p\n\tprintln n\n\tabortprogram(\"Realloc mem failure\")\n\treturn nil\nend\n\nexport proc abortprogram(ref char s) =\n\tprintln s\n\tprintln   \"ABORTING: Press key...\"\n\tcpl \n\tcpl \n!os_getch()\n\tstop 5\nend\n\nexport function getfilesize(filehandle handlex)int=\n\tword32 p,size\n\n\tp:=ftell(handlex)\t\t!current position\n\tfseek(handlex,0,2)\t\t!get to eof\n\tsize:=ftell(handlex)\t\t!size in bytes\n\tfseek(handlex,p,seek_set)\t!restore position\n\treturn size\nend\n\nexport proc readrandom(filehandle handlex, ref byte mem, int offset, size) =\n\tint a\n\tfseek(handlex,offset,seek_set)\n\ta:=fread(mem,1,size,handlex)\t\t\t!assign so as to remove gcc warning\nend\n\nexport function writerandom(filehandle handlex, ref byte mem, int offset,size)int =\n\tfseek(handlex,offset,seek_set)\n\treturn fwrite(mem,1,size,handlex)\nend\n\nexport function setfilepos(filehandle file,int offset)int=\n\treturn fseek(file,offset,0)\nend\n\nexport function getfilepos(filehandle file)int=\n\treturn ftell(file)\nend\n\nexport function readfile(ref char filename)ref byte =\n\tfilehandle f\n\tint size\n\tref byte m,p\n\n\tf:=fopen(filename,\"rb\")\n\tif f=nil then\n\t\treturn nil\n\tfi\n\trfsize:=size:=getfilesize(f)\n\n\tm:=pcm_alloc(size+2)\t\t!allow space for etx/zeof etc\n\n\tif m=nil then\n\t\treturn nil\n\tfi\n\n\treadrandom(f,m,0,size)\n\tp:=m+size\t\t\t!point to following byte\n\t(ref u16(p)^:=0)\t!add two zero bytes\n\n\tfclose(f)\n\treturn m\nend\n\nexport function writefile(ref char filename,ref byte data,int size)int =\n\tfilehandle f\n\tint n\n\n\tf:=fopen(filename,\"wb\")\n\tif f=nil then\n\t\treturn 0\n\tfi\n\n\tn:=writerandom(f,data,0,size)\n\tfclose(f)\n\treturn n\nend\n\nexport function checkfile(ref char file)int=\n\tfilehandle f\n\tif f:=fopen(file,\"rb\") then\n\t\tfclose(f)\n\t\treturn 1\n\tfi\n\treturn 0\nend\n\nexport proc readlinen(filehandle handlex,ref char buffer,int size) =\n!size>2\n\tint ch\n\tref char p\n\tint n\n\tarray [0:100]char buff\n\tbyte crseen\n\n\tif handlex=nil then\n\t\thandlex:=filehandle(os_getstdin())\n\tfi\n\tif handlex=nil then\n\t\tn:=0\n\t\tp:=buffer\n\t\tdo\n\t\t\tch:=getchar()\n\t\t\tif ch=13 or ch=10 or ch=-1 then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\t\tp++^:=ch\n\t\t\t++n\n\t\t\tif n>=(size-2) then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\tod\n\tfi\n\n\tbuffer^:=0\n\tif fgets(buffer,size-2,handlex)=nil then\n\t\treturn\n\tfi\n\n\tn:=strlen(buffer)\n\tif n=0 then\n\t\treturn\n\tfi\n\n\tp:=buffer+n-1\t\t!point to last char\n\tcrseen:=0\n\twhile (p>=buffer and (p^=13 or p^=10)) do\n\t\tif p^=13 or p^=10 then crseen:=1 fi\n\t\tp--^ :=0\n\tod\n\n!NOTE: this check doesn't work when a line simply doesn't end with cr-lf\n\n\tif not crseen and (n+4>size) then\n\t\tcpl size,n\n\t\tabortprogram(\"line too long\")\n\tfi\nend\n\nexport proc iconvlcn(ref char s,int n) =\n\tto n do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\nend\n\nexport proc iconvucn(ref char s,int n) =\n\tto n do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\nend\n\nexport function convlcstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function convucstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function changeext(ref char s,newext)ichar=\n!whether filespec has an extension or not, change it to newext\n!newext should start with \".\"\n!return new string (locally stored static string, so must be used before calling again)\n\tstatic [260]char newfile\n\tarray [32]char newext2\n\tref char sext\n\tint n\n\n\tstrcpy(&newfile[1],s)\n\n\tcase newext^\n\twhen 0 then\n\t\tnewext2[1]:=0\n\t\tnewext2[2]:=0\n\twhen '.' then\n\t\tstrcpy(&newext2[1],newext)\n\telse\n\t\tstrcpy(&newext2[1],\".\")\n\t\tstrcat(&newext2[1],newext)\n\tesac\n\n\n\tsext:=extractext(s,1)\t\t\t!include \".\" when it is only extension\n\n\tcase sext^\n\twhen 0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[1])\n\twhen '.' then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[2])\n\telse\t\t\t\t\t\t\t!has extension\n\t\tn:=sext-s-2\t\t\t!n is number of chars before the \".\"\n\t\tstrcpy(&newfile[1]+n+1,&newext2[1])\n\tesac\n\n\treturn &newfile[1]\nend\n\nexport function extractext(ref char s,int period=0)ichar=\n!if filespec s has an extension, then return pointer to it otherwise return \"\"\n!if s ends with \".\", then returns \".\"\n\tref char t,u\n\n\tt:=extractfile(s)\n\n\tif t^=0 then\t\t\t!s contains no filename\n\t\treturn \"\"\n\tfi\n\n!t contains filename+ext\n\tu:=t+strlen(t)-1\t\t!u points to last char of t\n\n\twhile u>=t do\n\t\tif u^='.' then\t\t!start extension found\n\t\t\tif (u+1)^=0 then\t\t!null extension\n\t\t\t\treturn (period|\".\"|\"\")\n\t\t\tfi\n\t\t\treturn u+1\t\t\t!return last part of filename as extension exclude the dot\n\t\tfi\n\t\t--u\n\tod\n\treturn \"\"\t\t\t!no extension seen\nend\n\nexport function extractpath(ref char s)ichar=\n\tstatic [0:260]char str\n\tref char t\n\tint n\n\n\tt:=s+strlen(s)-1\t\t!t points to last char\n\n\twhile (t>=s) do\n\t\tswitch t^\n\t\twhen '\\\\','/',':' then\t\t!path separator or drive letter terminator assume no extension\n\t\t\tn:=t-s+1\t\t\t!n is number of chars in path, which includes rightmost / or \\ or :\n\t\t\tmemcpy(&.str,s,n)\n\t\t\tstr[n]:=0\n\t\t\treturn &.str\n\t\tend switch\n\t\t--t\n\tod\n\treturn \"\"\t\t\t!no path found\nend\n\nexport function extractfile(ref char s)ichar=\n\tref char t\n\n\tt:=extractpath(s)\n\n\tif t^=0 then\t\t\t!s contains no path\n\t\treturn s\n\tfi\n\n\treturn s+strlen(t)\t\t!point to last part of s that contains the file\n\tend\n\nexport function extractbasefile(ref char s)ichar=\n\tstatic [0:100]char str\n\tref char f,e\n\tint n,flen\n\n\tf:=extractfile(s)\n\tflen:=strlen(f)\n\tif flen=0 then\t\t!s contains no path\n\t\treturn \"\"\n\tfi\n\te:=extractext(f,0)\n\n\tif e^ then\t\t\t!not null extension\n\t\tn:=flen-strlen(e)-1\n\t\tmemcpy(&str,f,n)\n\t\tstr[n]:=0\n\t\treturn &.str\n\tfi\n\tif (f+flen-1)^='.' then\n\t\tmemcpy(&str,f,flen-1)\n\t\tstr[flen-1]:=0\n\t\treturn &.str\n\tfi\n\treturn f\nend\n\nexport function addext(ref char s,ref char newext)ichar=\n!when filespec has no extension of its own, add newext\n\tref char sext\n\n\tsext:=extractext(s,1)\n\n\tif sext^=0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\treturn changeext(s,newext)\n\tfi\n\n\treturn s\t\t\t\t\t\t\t!has own extension; use that\nend\n\nexport function pcm_alloc32:ref void =\n\tref byte p\n\n\tallocbytes:=32\n\tsmallmemtotal+:=32\n\n\tif p:=ref byte(freelist[2]) then\t\t!Items of this block size available\n\t\tfreelist[2]:=ref word(int((freelist[2])^))\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\treturn pcm_alloc(32)\nend\n\nexport proc pcm_free32(ref void p) =\n!n can be the actual size requested it does not need to be the allocated size\n\n\tsmallmemtotal-:=32\n!\tif mem_check then removefrommemalloc(p,32) fi\n\n\tcast(p,ref word)^:=word(int(freelist[2]))\n\tfreelist[2]:=p\nend\n\nexport proc outbyte(filehandle f,int x)=\n\tfwrite(&x,1,1,f)\nend\n\nexport proc outword16(filehandle f,word x)=\n\tfwrite(&x,2,1,f)\nend\n\nexport proc outword32(filehandle f,word x)=\n\tfwrite(&x,4,1,f)\nend\n\nexport proc outword64(filehandle f,word64 x)=\n\tfwrite(&x,8,1,f)\nend\n\nexport proc outstring(filehandle f, ichar s)=\n\tfwrite(s,strlen(s)+1,1,f)\nend\n\nexport proc outblock(filehandle f, ref void p, int n)=\n\tfwrite(p,n,1,f)\nend\n\nexport function myeof(filehandle f)int=\n\tint c\n\n\tc:=fgetc(f)\n\tif c=c_eof then return 1 fi\n\tungetc(c,f)\n\treturn 0;\nend\n\nexport proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)=\n\tint newlen,oldlen\n\tichar newptr\n\n\tIF N=0 THEN CPL \"N=0\" FI\n\n\tif n=-1 then\n\t\tn:=strlen(s)\n\tfi\n\n\toldlen:=dest.length\n\n\tif oldlen=0 then\t\t\t\t!first string\n\t\tdest.strptr:=pcm_alloc(n+1)\n\t\tdest.allocated:=allocbytes\n\t\tdest.length:=n\t\t\t\t!length always excludes terminator\n\t\tmemcpy(dest.strptr,s,n)\n\t\t(dest.strptr+n)^:=0\n\t\treturn\n\tfi\n\n\tnewlen:=oldlen+n\n\tif newlen+1>dest.allocated then\n\t\tnewptr:=pcm_alloc(newlen+1)\n\t\tmemcpy(newptr,dest.strptr,oldlen)\n\t\tdest.strptr:=newptr\n\t\tdest.allocated:=allocbytes\n\tfi\n\n\tmemcpy(dest.strptr+oldlen,s,n)\n\t(dest.strptr+newlen)^:=0\n\n\tdest.length:=newlen\nend\n\nexport proc gs_init(ref strbuffer dest)=\n\tpcm_clearmem(dest,strbuffer.bytes)\nend\n\nexport proc gs_free(ref strbuffer dest)=\n\tif dest.allocated then\n\t\tpcm_free(dest.strptr,dest.allocated)\n\tfi\nend\n\nexport proc gs_str(ref strbuffer dest,ichar s)=\n\tstrbuffer_add(dest,s)\nend\n\nexport proc gs_char(ref strbuffer dest,int c)=\n\tarray [16]char s\n\n\ts[1]:=c\n\ts[2]:=0\n\n\tstrbuffer_add(dest,&.s,1)\nend\n\nexport proc gs_strn(ref strbuffer dest,ichar s,int length)=\n\tstrbuffer_add(dest,s,length)\nend\n\nexport proc gs_strvar(ref strbuffer dest,s)=\n\tstrbuffer_add(dest,s.strptr)\nend\n\nexport proc gs_strint(ref strbuffer dest,int64 a)=\n\tstrbuffer_add(dest,strint(a))\nend\n\nexport proc gs_strln(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_line(dest)\nend\n\nexport proc gs_strsp(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_str(dest,\" \")\nend\n\nexport proc gs_line(ref strbuffer dest)=\n\tstrbuffer_add(dest,\"\\w\")\nend\n\nexport function gs_getcol(ref strbuffer dest)int=\n\treturn dest.length\nend\n\nexport proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')=\n\tint col,i,n,slen\n\tarray [2560]char str\n\tcol:=dest.length\n\tstrcpy(&.str,s)\n\tslen:=strlen(s)\n\tn:=w-slen\n\tif n>0 then\n\t\tfor i:=1 to n do\n\t\t\tstr[slen+i]:=padch\n\t\tod\n\t\tstr[slen+n+1]:=0\n\tfi\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')=\n\tgs_leftstr(dest,strint(a),w,padch)\nend\n\nexport proc gs_padto(ref strbuffer dest,int col, ch=' ')=\n\tint n\n\tarray [2560]char str\n\n\tn:=col-dest.length\n\tif n<=0 then return fi\n\tfor i:=1 to n do\n\t\tstr[i]:=ch\n\tod\n\tstr[n+1]:=0\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_println(ref strbuffer dest,filehandle f=nil)=\n\tif dest.length=0 then return fi\n\t(dest.strptr+dest.length)^:=0\n\n\tif f=nil then\n!\t\tprintln dest.strptr,,\"\\c\"\n\t\tprintln dest.strptr\n\telse\n!\t\tprintln @f,dest.strptr,,\"\\c\"\n\t\tprintln @f,dest.strptr\n\tfi\nend\n\nexport function nextcmdparamnew(int &paramno, ichar &name, &value, ichar defext=nil)int=\n\tstatic int infile=0\n\tstatic ichar filestart=nil\n\tstatic ichar fileptr=nil\n\tstatic byte colonseen=0\n\tref char q\n\tichar item,fileext\n\tichar rest\n\tstatic int atsize\n\tstatic [300]char str\n\n\treenter::\n\tvalue:=nil\n\tname:=nil\n\n\tif infile then\n\t\tif readnextfileitem(fileptr,item)=0 then\t\t!eof\n\t\t\tpcm_free(filestart,atsize)\t\t\t\t\t!file allocated via malloc\n\t\t\tinfile:=0\n\t\t\tgoto reenter\n\t\tfi\n\telse\n\t\tif paramno>ncmdparams then\n\t\t\treturn pm_end\n\t\tfi\n\t\titem:=cmdparams[paramno]\n\t\t++paramno\n\n\t\tif item^='@' then\t\t!@ file\n\t\t\tif infile then println \"Nested @\"; stop 1 fi\n\t\t\tfilestart:=fileptr:=cast(readfile(item+1))\n\t\t\tif filestart=nil then\n\t\t\t\tprintln \"Can't open\",item\n\t\t\t\tstop 7\n\t\t\tfi\n\t\t\tinfile:=1\n\t\t\tatsize:=allocbytes\n\t\t\tgoto reenter\n\t\tfi\n\n\t\tif item^=':' then\n\t\t\tcolonseen:=1\n\t\t\treturn pm_colon\n\t\tfi\n\tfi\n\n\tvalue:=nil\n\tif item^='-' then\n\t\tname:=item+(colonseen|0|1)\n\t\tq:=strchr(item,':')\n\t\tif not q then\n\t\t\tq:=strchr(item,'=')\n\t\tfi\n\t\tif q then\n\t\t\tvalue:=q+1\n\t\t\tq^:=0\n\t\tfi\n\t\treturn (colonseen|pm_extra|pm_option)\n\tfi\n\n\tfileext:=extractext(item,0)\n\tname:=item\n\n\tif fileext^=0 then\t\t\t\t\t\t\t!no extension\n\t\tstrcpy(&.str,name)\n\t\tif defext and not colonseen then\n\t\t\tname:=addext(&.str,defext)\t\t\t\t!try .c\n\t\tfi\n!\telsif eqstring(fileext,\"dll\") then\n\telsif eqstring(fileext,\"dll\") or eqstring(fileext,\"mcx\") then\n\t\treturn (colonseen|pm_extra|pm_libfile)\n\tfi\n\treturn (colonseen|pm_extra|pm_sourcefile)\nend\n\nfunction readnextfileitem(ichar &fileptr,&item)int=\n\tref char p,pstart,pend\n\tint n\n\tstatic [256]char str\n\n\tp:=fileptr\n\n\n\treenter::\n\tdo\n\t\tcase p^\n\t\twhen ' ','\\t',13,10 then\t!skip white space\n\t\t\t++p\n\t\twhen 26,0 then\t\t\t\t!eof\n\t\t\treturn 0\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\n\tcase p^\n\twhen '!', '#' then\t\t\t!comment\n\t\t++p\n\t\tdocase p++^\n\t\twhen 10 then\n\t\t\tgoto reenter\n\t\twhen 26,0 then\n\t\t\tfileptr:=p-1\n\t\t\treturn 0\n\t\telse\n\t\tend docase\n\tesac\n\n\tcase p^\n\twhen '\"' then\t\t\t\t!read until closing \"\n\t\tpstart:=++p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tprintln \"Unexpected EOF in @file\"\n\t\t\t\tstop 8\n\t\t\twhen '\"' then\n\t\t\t\tpend:=p++\n\t\t\t\tif p^=',' then ++p fi\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\telse\n\t\tpstart:=p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tpend:=p\n\t\t\t\texit\n\t\t\twhen ' ','\\t',',',13,10 then\n\t\t\t\tpend:=p++\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\tesac\n\n\tn:=pend-pstart\n\tif n>=str.len then\n\t\tprintln \"@file item too long\"\n\t\tstop 9\n\tfi\n\tmemcpy(&.str,pstart,n)\n\tstr[n+1]:=0\n\titem:=&.str\n\tfileptr:=p\n\n\treturn 1\nend\n\nexport proc ipadstr(ref char s,int width,ref char padchar=\" \")=\n\tint n\n\n\tn:=strlen(s)\n\tto width-n do\n\t\tstrcat(s,padchar)\n\tod\nend\n\nexport function padstr(ref char s,int width,ref char padchar=\" \")ichar=\n\tstatic [256]char str\n\n\tstrcpy(&.str,s)\n\tipadstr(&.str,width,padchar)\n\treturn &.str\nend\n\nexport function chr(int c)ichar=\n\tstatic [8]char str\n\n\tstr[1]:=c\n\tstr[2]:=0\n\treturn &.str\nend\n\nexport function cmpstring(ichar s,t)int=\n\tint res\n\tif (res:=strcmp(s,t))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function cmpstringn(ichar s,t,int n)int=\n\tint res\n\tif (res:=strncmp(s,t,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqstring(ichar s,t)int=\n\treturn strcmp(s,t)=0\nend\n\nexport function cmpbytes(ref void p,q,int n)int=\n\tint res\n\tif (res:=memcmp(p,q,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqbytes(ref void p,q,int n)int=\n\treturn memcmp(p,q,n)=0\nend\n\nexport proc mseed(word64 a,b=0)=\n\tseed[1]:=a\n\tif b then\n\t\tseed[2]:=b\n\telse\n\t\tseed[2] ixor:=a\n\tfi\nend\n\nexport function mrandom:word =\n!return pure 64-bit word value, 0 to 2**64-1\n!(cast result for signed value)\n!\tword64 x,y\n\tint x,y\n\tx:=seed[1]\n\ty:=seed[2]\n\tseed[1]:=y\n\tx ixor:=(x<<23)\n\tseed[2]:= x ixor y ixor (x>>17) ixor (y>>26)\n\treturn seed[2]+y\nend\n\nexport function mrandomp:int =\n!pure 64-bit int value, positive only, 0 to 2**63-1\n\treturn mrandom() iand 0x7FFF'FFFF'FFFF'FFFF\nend\n\nexport function mrandomint(int n)int=\n!positive random int value from 0 to n-1\n\treturn mrandomp() rem n\nend\n\nexport function mrandomrange(int a,b)int=\n!random int value from a to b inclusive\n!span extent must be 1 to 2**63-1\n\tint span\n\tspan:=b-a+1\n\tif span<=0 then\n\t\treturn 0\n\tfi\n\treturn (mrandomp() rem span)+a\nend\n\nexport function mrandomreal:real x=\n!positive random real value from 0 to just under (but not including) 1.0\n\trepeat x:=mrandomp()/9223372036854775808.0 until x<>1.0\n\treturn x\nend\n\nexport function mrandomreal1:real=\n!positive random real value from 0 to 1.0 inclusive\n\treturn mrandomp()/9223372036854775807\nend\n\n!export function checkpackfile:ref byte=\n!!find out if this executable contains extra packed files\n!!return 1 or 0\n!\n!\tint a,offset,i,size\n!\t[100]char name\n!\t[300]char exefile\n!\tref byte packexeptr\t\t\t!for embedded pack files, contains pointer to in-memory version of this .exe file plus extras; else nil\n!\tint packexesize\t\t\t\t!byte size\n!\tref char packfilename\n!\tint packfilesize\n!\tref byte packfileptr\n!\n!!macro getfileint(data,offset)=(ref int32(data+offset))^\n!\tmacro getfileint(data,offset)=cast(data+offset,ref int32)^\n!\n!\tstrcpy(&exefile[1],os_gethostname())\n!\tprintln \"Attempting to open\",&.exefile\n!\tpackexeptr:=readfile(&exefile[1])\n!\n!\tif not packexeptr then\n!\t\tcpl \"Can't open\",&.exefile,packexeptr\n!\t\tstop\n!\tfi\n!\n!\tpackexesize:=rfsize\n!\tcpl \"File read OK. Size\",packexesize\n!\n!\ta:=getfileint(packexeptr,packexesize-int32.bytes)\n!\tif a<>'PCAK' then\n!\t\tfree(packexeptr)\n!\t\tpackfileptr:=nil\n!\t\treturn nil\n!\tfi\n!\n!\toffset:=getfileint(packexeptr,packexesize-int32.bytes*2)\n!\n!\tpackfilename:=cast(packexeptr+offset)\n!\toffset+:=strlen(packfilename)+1\n!\tpackfilesize:=getfileint(packexeptr,offset)\n!\tpackfileptr:=packexeptr+offset+int32.bytes\n!\n!\treturn packfileptr\n!end\n\nexport function readline:ichar=\n\treadln\n\treturn rd_buffer\nend\n\nexport function findfunction(ichar name)ref void=\n\tfor i to $getnprocs() do\n\t\tif eqstring($getprocname(i),name) then\n\t\t\treturn $getprocaddr(i)\n\t\tfi\n\tod\n\treturn nil\nend\n\nexport function roundtoblock(int n,align)int=\n!round up n until it is a multiple of align (which is a power of two)\n!return aligned value. Returns original if already aligned\n\tif n iand (align-1)=0 then return n fi\n\treturn n+(align-(n iand (align-1)))\nend\n\n"
    data     u64   "export type filehandle=ref void\n\nimportdll $cstd=\n\tfunc  malloc\t\t(word64)ref void\n\tfunc  realloc\t(ref void, word)ref void\n\tproc free\t\t(ref void)\n\tproc memset\t\t(ref void, int32, word)\n\tproc memcpy\t\t(ref void, ref void, word)\n\tproc memmove\t\t(ref void, ref void, word)\n\tfunc  clock\t\t:int32\n\tfunc  ftell\t\t(filehandle)int32\n\tfunc  fseek\t\t(filehandle, int32, int32)int32\n\tfunc  fread\t\t(ref void, word, word, filehandle)word\n\tfunc  fwrite\t\t(ref void, word, word, filehandle)word\n\tfunc  getc\t\t(filehandle)int32\n\tfunc  ungetc\t\t(int32, filehandle)int32\n\tfunc  fopen\t\t(ichar a, b=\"rb\")filehandle\n\tfunc  fclose\t\t(filehandle)int32\n\tfunc  fgets\t\t(ichar, int, filehandle)ichar\n\tfunc  remove\t\t(ichar)int32\n\tfunc  rename\t\t(ichar, ichar)int32\n\tfunc  getchar\t:int32\n\tproc putchar\t(int32)\n\tproc setbuf\t\t(filehandle, ref byte)\n\n\tfunc  strlen\t\t(ichar)int\n\tfunc  strcpy\t\t(ichar, ichar)ichar\n\tfunc  strcmp\t\t(ichar, ichar)int32\n\tfunc  strncmp\t(ichar, ichar, word)int32\n\tfunc  strncpy\t(ichar, ichar, word)word\n\tfunc  memcmp\t\t(ref void, ref void, word)int32\n\tfunc  strcat\t\t(ichar, ichar)ichar\n\tfunc  tolower\t(int32)int32\n\tfunc  toupper\t(int32)int32\n\tfunc  isalpha\t(int32)int32\n\tfunc  isupper\t(int32)int32\n\tfunc  islower\t(int32)int32\n\tfunc  isalnum\t(int32)int32\n\tfunc  isspace\t(int32)int32\n\tfunc  strstr\t\t(ichar, ichar)ichar\n\tfunc  atol\t\t(ichar)int\n\tfunc  atoi\t\t(ichar)int32\n!\tfunc  strtod\t\t(ichar,ref ref char)real64\n\tfunc  strtod\t\t(ichar,ref ref char)real64\n\tfunc  _strdup\t(ichar)ichar\n\n\tfunc  puts\t\t(ichar)int32\n\tfunc  printf\t\t(ichar, ...)int32\n\n\tfunc  sprintf\t(ichar, ichar, ...)int32\n\n\tfunc  sscanf\t\t(ichar, ichar, ...)int32\n\tfunc  scanf\t\t(ichar, ...)int32\n\n\tfunc  rand\t\t:int32\n\tproc srand\t\t(word32)\n\tfunc  system\t\t(ichar)int32\n\n\tfunc  fgetc\t\t(filehandle)int32\n\tfunc  fputc\t\t(int32,  filehandle)int32\n\tfunc  fprintf\t(filehandle, ichar, ...)int32\n\tfunc  fputs\t\t(ichar,  filehandle)int32\n\tfunc  feof\t\t(filehandle)int32\n\tfunc  getch\t\t:int32\n\tfunc  _getch\t\t:int32\n\tfunc  kbhit\t\t:int32\n\tfunc  _mkdir\t\t(ichar)int32\n\tfunc  mkdir\t\t(ichar)int32\n\tfunc  strchr\t\t(ichar,int32)ichar\n\n\tfunc  _setmode\t(int32,int32)int32\n\n\tproc _exit\t\t(int32)\n\tproc \"exit\"\t\t(int32)\n!\tproc `exit\t\t(int32)\n\tfunc  pow\t\t(real,real)real\n\n\tfunc  `sin \t\t(real)real\n\tfunc  `cos\t\t(real)real\n\tfunc  `tan\t\t(real)real\n\tfunc  `asin\t\t(real)real\n\tfunc  `acos\t\t(real)real\n\tfunc  `atan \t\t(real)real\n\tfunc  `log\t\t(real)real\n\tfunc  `log10\t\t(real)real\n\tfunc  `exp\t\t(real)real\n\tfunc  `floor\t\t(real)real\n\tfunc  `ceil\t\t(real)real\n\n\tfunc  `llabs\t(i64)i64\n\n\tproc  qsort   \t(ref void, word64, word64, ref proc)\n!\tproc  sleep\t\t(word32)\n\nend\n\nexport macro strdup=_strdup\n\nimportdll $cstdextra=\n\tfunc  __getmainargs(ref int32, ref void, ref void, int, ref void)int32\nend\n\nexport const c_eof\t\t=-1\nexport const seek_set\t= 0\nexport const seek_curr\t= 1\nexport const seek_end\t= 2\n"
    data     u64   "const wm_destroy=2\n\ntype wt_word\t= word16\ntype wt_wordpm\t= word32\ntype wt_bool\t= word32\ntype wt_dword\t= word32\ntype wt_wchar\t= word16\ntype wt_wcharpm\t= word32\ntype wt_char\t= byte\ntype wt_ichar\t= ref char\ntype wt_ptr\t\t= ref void\ntype wt_wndproc\t= ref proc\ntype wt_handle\t= ref void\ntype wt_int\t\t= int32\ntype wt_uint\t= word32\ntype wt_long\t= int32\ntype wt_wparam\t= word\ntype wt_lparam\t= word\ntype wt_point\t= rpoint\n\nexport record rsystemtime =\n\twt_word year\n\twt_word month\n\twt_word dayofweek\n\twt_word day\n\twt_word hour\n\twt_word minute\n\twt_word second\n\twt_word milliseconds\nend\n\nimportdll $windowsdlls=\n!\twindows function  \"VirtualAlloc\"(wt_ptr, dint,wt_dword,wt_dword)wt_ptr\n\twindows function  \"GetStdHandle\"(wt_dword)wt_handle\n\twindows function  \"GetConsoleScreenBufferInfo\"(wt_handle,wt_ptr)int\n\twindows function  \"SetConsoleCtrlHandler\"(wt_wndproc,int)int\n\twindows function  \"SetConsoleMode\"(wt_handle,wt_dword)int\n\twindows function  \"CreateProcessA\"(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,\n\t\t\t\t\t\twt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int\n\twindows function  \"GetLastError\":wt_dword\n\twindows function  \"WaitForSingleObject\"(wt_handle,wt_dword)wt_dword\n\twindows function  \"GetExitCodeProcess\"(wt_handle,wt_ptr)int\n\twindows function  \"CloseHandle\"(wt_handle)int\n\twindows function  \"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)int\n\twindows function  \"FlushConsoleInputBuffer\"(wt_handle)int\n\twindows function  \"LoadLibraryA\"(wt_ichar)wt_handle\n!\twindows function  \"GetProcAddress\"(wt_handle,wt_ichar)wt_wndproc\n\twindows function  \"GetProcAddress\"(wt_handle,wt_ichar)ref void\n\twindows function  \"LoadCursorA\"(wt_handle,wt_ichar)wt_handle\n\twindows function  \"RegisterClassExA\"(wt_ptr)wt_wordpm\n\twindows function  \"DefWindowProcA\"(wt_handle,wt_uint,wt_wparam,wt_lparam)int\n\twindows function  \"ReadConsoleInputA\"(wt_handle,wt_ptr,wt_dword,wt_ptr)int\n\twindows procedure \"Sleep\"(wt_dword)\n\twindows function  \"GetModuleFileNameA\"(wt_handle,wt_ichar,wt_dword)wt_dword\n\n\twindows procedure \"ExitProcess\"(wt_uint)\n\twindows proc\t \"PostQuitMessage\"(wt_int)\n\n\twindows proc\t \"MessageBoxA\"(wt_int x=0,wt_ichar message, caption=\"Caption\",wt_int y=0)\n\n\twindows function  \"QueryPerformanceCounter\"(ref int64)wt_bool\n\twindows function  \"QueryPerformanceFrequency\"(ref int64)wt_bool\n\n\twindows function  \"CreateFileA\"(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle\n\twindows function  \"GetFileTime\"(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool\n\n\twindows procedure \"GetSystemTime\"(ref rsystemtime)\n\twindows procedure \"GetLocalTime\"(ref rsystemtime)\n\n\twindows function  \"GetTickCount64\":u64\n\twindows function  \"PeekMessageA\"\t\t(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool\n\n\twindows function  \"GetCommandLineA\":ichar\n\n\twindows function  \"VirtualAlloc\" (ref void, wt_dword, wt_dword, wt_dword)ref void\n\twindows function  \"VirtualProtect\" (ref void, wt_dword, wt_dword, ref wt_dword)wt_bool\n\nend\n\nrecord input_record = $caligned\n\twt_word\teventtype\n!\tword16\tpadding\n\t\twt_bool\tkeydown\t\t\t!key event record (was inside 'Event' union in win32)\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nrecord rspoint=(int16 x,y)\n\nrecord rsrect=\n\tint16 leftx,top,rightx,bottom\nend\n\nglobal record rpoint =\n\twt_long x,y\nend\n\nrecord rconsole=\n\trspoint size,pos\n\tword16 attributes\n\trsrect window\n\trspoint maxwindowsize\nend\n\nrecord rstartupinfo =\n\twt_dword\tsize\n\tword32 dummy1\n\twt_ichar\treserved\n\twt_ichar\tdesktop\n\twt_ichar\ttitle\n\twt_dword\tx\n\twt_dword\ty\n\twt_dword\txsize\n\twt_dword\tysize\n\twt_dword\txcountchars\n\twt_dword\tycountchars\n\twt_dword\tfillattribute\n\twt_dword\tflags\n\twt_word\t\tshowwindow\n\twt_word\t\treserved2\n\tword32 dummy2\n\twt_ptr\t\treserved4\n\twt_handle\tstdinput\n\twt_handle\tstdoutput\n\twt_handle\tstderror\nend\n\nrecord rprocess_information =\n\twt_handle process\n\twt_handle thread\n\twt_dword processid\n\twt_dword threadid\nend\n\nrecord rwndclassex =\n\twt_uint\t\tsize\n\twt_uint\t\tstyle\n\twt_wndproc\twndproc\n\twt_int\t\tclsextra\n\twt_int\t\twndextra\n\twt_handle\tinstance\n\twt_handle\ticon\n\twt_handle\tcursor\n\twt_handle\tbackground\n\twt_ichar\tmenuname\n\twt_ichar\tclassname\n\twt_handle\ticonsm\nend\n\nglobal record rmsg =\n\twt_handle\thwnd\n\twt_uint\t\tmessage\n\tword32\t\tdummy1\n\twt_wparam\twParam\n\twt_lparam\tlParam\n\twt_dword\ttime\n\tword32\t\tdummy2\n\twt_point\tpt\nend\n\nconst NORMAL_PRIORITY_CLASS=32\nconst CREATE_NEW_CONSOLE=16\nconst DETACHED_PROCESS=16\n\nconst MEM_COMMIT\t\t\t\t= 4096\nconst MEM_RESERVE\t\t\t\t= 8192\nconst PAGE_EXECUTE\t\t\t\t= 16\nconst PAGE_EXECUTE_READ\t\t\t= 32\nconst PAGE_EXECUTE_READWRITE\t= 64\nconst PAGE_NOACCESS\t\t\t\t= 1\n\n\nwt_handle hconsole, hconsolein\n\ninput_record lastkey, pendkey\nint keypending\t\t\t!whether pendkey contains a new key event detected by flushkbd\n\nref function (ref void)int wndproc_callbackfn=nil\t!windows call-back: address of handler\n\nint init_flag=0\n\nexport proc os_init=\n\tint i,count\n\trconsole info\n\n!general initialisation\n\thconsole:=GetStdHandle(u32(-11))\n\thconsolein:=GetStdHandle(u32(-10))\n\n\tlastkey.repeatcount:=0\n\tkeypending:=0\n\n\tSetConsoleCtrlHandler(nil,1)\n\n\tSetConsoleMode(hconsole,1 ior 2)\n\n\tinit_flag:=1\n\nend\n\nexport function  os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\n\twt_dword exitcode\n\tint status\n\tint cflags:=0\n\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tswitch newconsole\n\twhen 0 then cflags := NORMAL_PRIORITY_CLASS\n\twhen 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE\n\twhen 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS\n\tend switch\n\n\tsi.size := rstartupinfo.bytes\n\n\tstatus:=CreateProcessA(\n\t\tnil,\n\t\tcmdline,\n\t\tnil,\n\n\t\tnil,\n\t\t1,\n\t\tcflags,\n\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tif status=0 then\t\t!fails\n\t\tstatus:=GetLastError()\n\t\tprintf(\"Winexec error: %lld\\n\",status)\n\t\treturn -1\n\tfi\n\n\tWaitForSingleObject(xpi.process, 0xFFFF'FFFF)\n\tGetExitCodeProcess(xpi.process,&exitcode)\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn exitcode\nend\n\nexport function  os_execcmd(ichar cmdline, int newconsole=0)int =\n\twt_dword exitcode\n\tint i,j,k\n\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tsi.size := rstartupinfo.bytes\n\n\tCreateProcessA( nil,\n\t\tcmdline,\n\t\tnil,\n\t\tnil,\n\t\t1,\n\t\tNORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn 1\nend\n\nexport function  os_getch:int=\n\tint k\n\n\tk:=os_getchx() iand 255\n\n\treturn k\nend\n\nexport function  os_kbhit:int=\n\twt_dword count\n\n\tunless init_flag then os_init() end\n\n\tGetNumberOfConsoleInputEvents(hconsolein,&count)\n\treturn count>1\nend\n\nexport function  os_getdllinst(ichar name)u64=\n\twt_handle hinst\n\n\thinst:=LoadLibraryA(name)\n\treturn cast(hinst)\nend\n\nexport function  os_getdllprocaddr(int hinst,ichar name)ref void=\n\treturn GetProcAddress(cast(hinst),name)\nend\n\nexport proc os_initwindows=\n\tos_init()\n!\tos_gxregisterclass(\"m2022\")\n\tos_gxregisterclass(\"pcc001\")\nend\n\nexport proc os_gxregisterclass(ichar classname)=\n\tconst idcarrow=32512\n\trwndclassex r\n\tstatic byte registered\n\n\tif registered then\n\t\treturn\n\tfi\n\n\tclear r\n\n\tr.size:=r.bytes\n\tr.style:=8 ior 32\t\t!CS_DBLCLKS | CS_OWNDC\n\tr.wndproc:=cast(&mainwndproc)\n\tr.instance:=nil\n\n\tr.icon:=nil\t\t!loadicon(proginstance,\"SCW32\")\n\tr.cursor:=LoadCursorA(nil,ref void(idcarrow))\t\t!IDC_ARROW)\n\tr.background:=cast(15+1)\t\t\t\t\t!COLOR_BTNFACE+1\n\tr.menuname:=nil\n\tr.classname:=classname\n\tr.iconsm:=nil\t!loadicon(proginstance,\"SCW32\")\n\n\tif RegisterClassExA(&r)=0 then\n\t\tprintf(\"Regclass error: %lld %lld\\n\",classname,GetLastError())\n\t\tstop 1\n\tend\n\tregistered:=1\nend\n\nglobal callback function  mainwndproc (\n\t\twt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)int=\n\trmsg m\n\tint i,result\n\tint l\n\tstatic int count=0\n\n!CPL \"MAINWNDPROC\",MESSAGE\n!RETURN 0\n\tm.hwnd:=hwnd\n\tm.message:=message\n\tm.wParam:=wParam\n\tm.lParam:=lParam\n\tm.pt.x:=0\n\tm.pt.y:=0\n\t\n\tif (wndproc_callbackfn) then\n\t\tresult:=(wndproc_callbackfn^)(&m)\n\telse\n\t\tresult:=0\n\tfi\n\n\tif m.message=wm_destroy then\n\t\treturn 0\n\tfi\n\n\tif not result then\n\t\treturn DefWindowProcA(hwnd,message,wParam,lParam)\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport proc os_setmesshandler(ref void addr)=\n\twndproc_callbackfn:=addr\nend\n\nexport function  os_getchx:int=\n!Q! function  os_getchx_c:int\n!return a 32-bit value containing:\n! 15..B0:\tchar code\n! 23..16\tvirtual keycode\n! 31..24\tshift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)\n\tconst rightaltmask\t= 1\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\tint count\n\tint charcode,keyshift,keycode\n\tint altdown,ctrldown,shiftdown,capslock\n\n\tunless init_flag then os_init() end\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\tReadConsoleInputA(hconsolein,&lastkey,1,&count)\n\t\t\tuntil (lastkey.eventtype=1 and lastkey.keydown=1)\n\t\tfi\n\tfi\n\n!set shift flags\n\n\taltdown\t\t:= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)\n\tctrldown\t:= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)\n\tshiftdown\t:= ((lastkey.controlkeystate iand shiftmask)|1|0)\n\tcapslock\t:= ((lastkey.controlkeystate iand capsmask)|1|0)\n\n\t--lastkey.repeatcount\t\t!count this key out\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n\tif charcode<0 then\n\t\tif charcode<-128 then\n\t\t\tcharcode:=0\n\t\telse\n\t\t\tcharcode+:=256\n\t\tfi\n\tfi\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!....\n\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\treturn keyshift<<24 ior keycode<<16 ior charcode\nend\n\nexport function  os_getos=>ichar=\n\tif $targetbits=32 then\n\t\treturn \"W32\"\n\telse\n\t\treturn \"W64\"\n\tfi\nend\n\nexport function  os_gethostsize=>int=\n\treturn $targetbits\nend\n\nexport function  os_shellexec(ichar opc, file)int=\n\treturn system(file)\nend\n\nexport proc  os_sleep(int a)=\n\tSleep(a)\nend\n\nexport function  os_getstdin:filehandle =\n\treturn fopen(\"con\",\"rb\")\nend\n\nexport function  os_getstdout:filehandle =\n\treturn fopen(\"con\",\"wb\")\nend\n\nexport function  os_gethostname:ichar=\n\tstatic [300]char name\n\tstatic int n\n\n\tGetModuleFileNameA(nil,&.name,name.bytes)\n\treturn &.name\nend\n\nexport function  os_getmpath:ichar=\n\treturn F\"C:\\m\\\"\nend\n\n!export proc os_exitprocess(int x)=\n!\tstop x\n!end\n\nexport function  os_clock:int64=\n\treturn clock()\nend\n\nexport function  os_ticks:int64=\n\treturn GetTickCount64()\nend\n\nexport function  os_hptimer:int64 t=\n\tqueryperformancecounter(&t)\n\tt\nend\n\nexport function os_iswindows:int=\n\treturn 1\nend\n\nexport proc os_getsystime(ref rsystemtime tm)=\n\tGetLocalTime(tm)\nend\n\nexport proc os_peek=\n\tint ticks\n\tstatic int lastticks\n\tarray [100]byte m\n\tticks:=GetTickCount64()\n\tif ticks-lastticks>=1000 then\n\t\tlastticks:=ticks\n\t\tPeekMessageA(&m,nil,0,0,0)\n\tfi\nend\n\nexport function  os_allocexecmem(int n)ref byte=\n\tref byte p\n\tu32 oldprot\n\tint status\n\n\tp := VirtualAlloc(nil, n, MEM_RESERVE ior MEM_COMMIT, PAGE_NOACCESS);\n\tif p = nil then return nil fi\n\n\tstatus := VirtualProtect(p, n, PAGE_EXECUTE_READWRITE, &oldprot);\n\tif status = 0 then return nil fi\n\n\treturn p\nend\n\nproc start=\nend\n\n"
    data     u64   "export function os_calldllfunction(ref proc fnaddr,\n\t\tint retcode, nargs, ref[]i64 args, ref[]byte argcodes)word64 =\n\tword64 a\n\treal64 x\n\tint nextra, pushedbytes\n\n\tnextra:=0\n\n\tif nargs<4 then\n\t\tnextra:=4-nargs\t\t\t!need at least 4 slots for shadow space\n\telsif nargs.odd then\t\t!need one more for a 16-byte-aligned stack\n\t\tnextra:=1\n\tfi\n\n\tpushedbytes:=(nextra+nargs)*8\n\n\tto nextra do\n\t\tasm push 0\n\tod\n\n\tfor i:=nargs downto 1 do\n\t\ta:=args^[i]\t\t\t\t\t!get generic 64-bit value to push\n\t\tasm push word64 [a]\n\tod\n\n!load first 4 args to registers; this first version will blindly load 4 args\n!(even if there are less) to both integer and xmm registers. Should be int/pointer\n!types to integer regs; float types to xmm; and variadic to both\n!This requires the flags in argcodes[], currently not used\n\n\tassem\n\t\tmov D10,[Dstack]\n\t\tmovq XMM0,[Dstack]\n\t\tmov D11,[Dstack+8]\n\t\tmovq XMM1,[Dstack+8]\n\t\tmov D12,[Dstack+16]\n\t\tmovq XMM2,[Dstack+16]\n\t\tmov D13,[Dstack+24]\n\t\tmovq XMM3,[Dstack+24]\n\tend\n\n\tif retcode='I' then\n\t\ta:=((ref function:int64(fnaddr))^())\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn a\n\telse\n\t\tx:=((ref function:real64(fnaddr))^())\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn word64@(x)\n\tfi\nend\t\n\nglobal function os_pushargs(ref[]word64 args, int nargs, nextra,\n\t\t\t\t\tref proc fnaddr, int isfloat)word64=\n!implements central part of 'callapplproc' which needs to be in asm\n\tword64 a\n\treal64 x\n\n\tto nextra do\n\t\tasm\tpush 0\n\tend\n\n\tfor i to nargs do\n\t\ta:=args[i]\n\t\tasm push word64 [a]\n\tod\n\n\tif isfloat then\n\t\tx:=((ref function:real64(fnaddr))^())\n\t\ta:=int64@(x)\n\telse\n\t\ta:=((ref function:int64(fnaddr))^())\n\tfi\n\n\treturn a\nend\n"
    zstatic  u8:5  mm_libsources.syslibfileno 
    istatic  u64   mm_modules.headerpathx 
    data     u64   ""
    istatic  u64   mm_modules.altpathx 
    data     u64   ""
    istatic  u64   mm_modules.importpathx 
    data     u64   ""
    istatic  u64   mm_modules.subprogpath 
    data     u64   ""
    zstatic  i64   mm_modules.dirpos 
    zstatic  i64   mm_modules.issyslib 
    zstatic  u8:80 mm_modules.headervars 
    zstatic  u64   mm_name.currstproc 
    istatic  i64   mm_name.allowmodname 
    data     u64   0 
    zstatic  i64   mm_name.noexpand 
    zstatic  i64   mm_name.noassem 
    zstatic  i64   mm_name.macrolevels 
    zstatic  u8:400 mm_name.macroparams 
    zstatic  u8:400 mm_name.macroparamsgen 
    zstatic  u8:400 mm_name.macroargs 
    zstatic  i64   mm_name.nmacroparams 
    zstatic  i64   mm_name.nmacroargs 
    istatic  i64   mm_parse.intabledata 
    data     u64   0 
    istatic  i64   mm_parse.inreadprint 
    data     u64   0 
    istatic  i64   mm_parse.inparamlist 
    data     u64   0 
    istatic  i64   mm_parse.inrecordbody 
    data     u64   0 
    istatic  i64   mm_parse.inimportmodule 
    data     u64   0 
    istatic  i64   mm_parse.labelseen 
    data     u64   0 
    istatic  u64   mm_parse.tabledataname 
    data     u64   0 
    zstatic  u8:80 mm_parse.procstack 
    istatic  i64   mm_parse.nprocstack 
    data     u64   0 
    zstatic  u64   mm_parse.unionstring 
    zstatic  u64   mm_parse.unionpend 
    istatic  u64   mm_parse.unionlastvar 
    data     u64   0 
    zstatic  u64   mm_parse.dretvar 
    istatic  i64   mm_parse.try_level 
    data     u64   0 
    istatic  i64   mm_parse.varattribs 
    data     u64   0 
    zstatic  u8:80 mm_parse.dollarstack 
    istatic  i64   mm_parse.ndollar 
    data     u64   0 
    istatic  i64   mm_parse.insiderecord 
    data     u64   0 
    istatic  i64   mm_parse.insidedllimport 
    data     u64   0 
    zstatic  u8:80 mm_parse.forindexvars 
    zstatic  i64   mm_parse.nforloops 
    zstatic  u64   mm_parse.docfile 
    istatic  u8:96 mm_parse.readcompilervar.monthnames 
    data     u64   "Jan"
    data     u64   "Feb"
    data     u64   "Mar"
    data     u64   "Apr"
    data     u64   "May"
    data     u64   "Jun"
    data     u64   "Jul"
    data     u64   "Aug"
    data     u64   "Sep"
    data     u64   "Oct"
    data     u64   "Nov"
    data     u64   "Dec"
    zstatic  u64   mm_pcl.pccode 
    zstatic  u64   mm_pcl.pccodex 
    zstatic  i64   mm_pcl.pclseqno 
    istatic  u8:1408 mm_pcl.pclnames 
    data     u64   "kproc"
    data     u64   "kparam"
    data     u64   "klocal"
    data     u64   "krettype"
    data     u64   "kprocent"
    data     u64   "kend"
    data     u64   "kistatic"
    data     u64   "kzstatic"
    data     u64   "kdata"
    data     u64   "kextproc"
    data     u64   "kextparam"
    data     u64   "kextvariadic"
    data     u64   "kextend"
    data     u64   "klinkdll"
    data     u64   "kstartmx"
    data     u64   "kresetmx"
    data     u64   "kendmx"
    data     u64   "kload"
    data     u64   "kloadref"
    data     u64   "kloadimm"
    data     u64   "kstore"
    data     u64   "kunload"
    data     u64   "kdouble"
    data     u64   "kswapopnds"
    data     u64   "kswapmem"
    data     u64   "kclear"
    data     u64   "kiload"
    data     u64   "kistore"
    data     u64   "kiloadx"
    data     u64   "kistorex"
    data     u64   "kaddptrx"
    data     u64   "ksubptrx"
    data     u64   "ksubptr"
    data     u64   "kcallp"
    data     u64   "kcallf"
    data     u64   "kicallp"
    data     u64   "kicallf"
    data     u64   "ksetcall"
    data     u64   "ksetarg"
    data     u64   "ksetret"
    data     u64   "kreturn"
    data     u64   "kstop"
    data     u64   "kstopx"
    data     u64   "kjump"
    data     u64   "kijump"
    data     u64   "kjumpeq"
    data     u64   "kjumpne"
    data     u64   "kjumplt"
    data     u64   "kjumple"
    data     u64   "kjumpge"
    data     u64   "kjumpgt"
    data     u64   "kjumpt"
    data     u64   "kjumpf"
    data     u64   "kforup"
    data     u64   "kfordown"
    data     u64   "kto"
    data     u64   "kswitch"
    data     u64   "kswlabel"
    data     u64   "kendsw"
    data     u64   "kloadbit"
    data     u64   "kstorebit"
    data     u64   "kloadbf"
    data     u64   "kstorebf"
    data     u64   "kadd"
    data     u64   "ksub"
    data     u64   "kmul"
    data     u64   "kdiv"
    data     u64   "krem"
    data     u64   "kdivrem"
    data     u64   "kbitand"
    data     u64   "kbitor"
    data     u64   "kbitxor"
    data     u64   "kshl"
    data     u64   "kshr"
    data     u64   "kmin"
    data     u64   "kmax"
    data     u64   "keq"
    data     u64   "kne"
    data     u64   "klt"
    data     u64   "kle"
    data     u64   "kge"
    data     u64   "kgt"
    data     u64   "kpower"
    data     u64   "katan2"
    data     u64   "kaddto"
    data     u64   "ksubto"
    data     u64   "kmulto"
    data     u64   "kdivto"
    data     u64   "kremto"
    data     u64   "kbitandto"
    data     u64   "kbitorto"
    data     u64   "kbitxorto"
    data     u64   "kshlto"
    data     u64   "kshrto"
    data     u64   "kminto"
    data     u64   "kmaxto"
    data     u64   "kaddpxto"
    data     u64   "ksubpxto"
    data     u64   "kneg"
    data     u64   "kabs"
    data     u64   "kbitnot"
    data     u64   "knot"
    data     u64   "knotnot"
    data     u64   "ksqr"
    data     u64   "ksign"
    data     u64   "ksqrt"
    data     u64   "ksin"
    data     u64   "kcos"
    data     u64   "ktan"
    data     u64   "kasin"
    data     u64   "kacos"
    data     u64   "katan"
    data     u64   "kln"
    data     u64   "klog"
    data     u64   "kexp"
    data     u64   "kround"
    data     u64   "kfloor"
    data     u64   "kceil"
    data     u64   "kfract"
    data     u64   "knegto"
    data     u64   "kabsto"
    data     u64   "kbitnotto"
    data     u64   "knotto"
    data     u64   "knotnotto"
    data     u64   "kincrto"
    data     u64   "kincrload"
    data     u64   "kloadincr"
    data     u64   "kdecrto"
    data     u64   "kdecrload"
    data     u64   "kloaddecr"
    data     u64   "kfloat"
    data     u64   "kfix"
    data     u64   "ktruncate"
    data     u64   "kfwiden"
    data     u64   "kfnarrow"
    data     u64   "ktypepun"
    data     u64   "kwiden"
    data     u64   "kfdtoaddr"
    data     u64   "kaddrtofd"
    data     u64   "ksliceptr"
    data     u64   "kslicelen"
    data     u64   "kcallargs"
    data     u64   "kassem"
    data     u64   "kdebug"
    data     u64   "klabelx"
    data     u64   "ktype"
    data     u64   "kopnd"
    data     u64   "kendprogram"
    data     u64   "kprocentry"
    data     u64   "kcomment"
    data     u64   "kin"
    data     u64   "knotin"
    data     u64   "klwb"
    data     u64   "kupb"
    data     u64   "klen"
    data     u64   "kminvalue"
    data     u64   "kmaxvalue"
    data     u64   "kbounds"
    data     u64   "kandto"
    data     u64   "korto"
    data     u64   "kand"
    data     u64   "kor"
    data     u64   "kfmod"
    data     u64   "kbitwidth"
    data     u64   "kbytesize"
    data     u64   "ktypestr"
    data     u64   "ksoftconv"
    data     u64   "kerror"
    data     u64   "kharderror"
    data     u64   "ksofttruncshort"
    data     u64   "kichartoslice"
    data     u64   "karraytoslice"
    data     u64   "kcharaxtoichar"
    data     u64   "kzero"
    data     u64   "kdivf"
    data     u64   "kdivfto"
    istatic  u8:176 mm_pcl.pclmain 
    data     u8    16 
    data     u8    16 
    data     u8    16 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    16 
    data     u8    16 
    data     u8    79 
    data     u8    16 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    24 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    16 
    data     u8    16 
    data     u8    14 
    data     u8    16 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    16 
    data     u8    16 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    8 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:176 mm_pcl.pclattr 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    2 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    zstatic  u64   mm_pcl.cstringlist 
    zstatic  u64   mm_pcl.creallist 
    zstatic  u64   mm_pcl.creal32list 
    istatic  u8:8  mm_support.bytemasks 
    data     u8    1 
    data     u8    2 
    data     u8    4 
    data     u8    8 
    data     u8    16 
    data     u8    32 
    data     u8    64 
    data     u8    128 
    istatic  u8:248 mm_tables.stdnames 
    data     u64   "void"
    data     u64   "c64"
    data     u64   "u64"
    data     u64   "i64"
    data     u64   "r32"
    data     u64   "r64"
    data     u64   "bool64"
    data     u64   "ref"
    data     u64   "rec"
    data     u64   "range"
    data     u64   "array"
    data     u64   "slice"
    data     u64   "block"
    data     u64   "c8"
    data     u64   "b8"
    data     u64   "i8"
    data     u64   "i16"
    data     u64   "i32"
    data     u64   "u8"
    data     u64   "u16"
    data     u64   "u32"
    data     u64   "ichar"
    data     u64   "auto"
    data     u64   "any"
    data     u64   "proc"
    data     u64   "label"
    data     u64   "type"
    data     u64   "bitfl"
    data     u64   "tuple"
    data     u64   "pend"
    data     u64   "last "
    istatic  u8:31 mm_tables.stdbits 
    data     u8    0 
    data     u8    64 
    data     u8    64 
    data     u8    64 
    data     u8    32 
    data     u8    64 
    data     u8    64 
    data     u8    64 
    data     u8    0 
    data     u8    128 
    data     u8    0 
    data     u8    128 
    data     u8    0 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    16 
    data     u8    32 
    data     u8    8 
    data     u8    16 
    data     u8    32 
    data     u8    64 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    64 
    data     u8    8 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:31 mm_tables.stdpclmode 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    3 
    data     u8    4 
    data     u8    5 
    data     u8    2 
    data     u8    2 
    data     u8    12 
    data     u8    12 
    data     u8    12 
    data     u8    12 
    data     u8    12 
    data     u8    18 
    data     u8    18 
    data     u8    15 
    data     u8    16 
    data     u8    17 
    data     u8    18 
    data     u8    19 
    data     u8    20 
    data     u8    2 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    zstatic  i64   mm_tables.trefproc 
    zstatic  i64   mm_tables.treflabel 
    zstatic  i64   mm_tables.tintint 
    istatic  u8:288 mm_tables.sysfnnames 
    data     u64   "sf_init"
    data     u64   "sf_print_startfile"
    data     u64   "sf_print_startstr"
    data     u64   "sf_print_startptr"
    data     u64   "sf_print_startcon"
    data     u64   "sf_print_setfmt"
    data     u64   "sf_print_nogap"
    data     u64   "sf_print_space"
    data     u64   "sf_print_i64"
    data     u64   "sf_print_i64_nf"
    data     u64   "sf_print_u64"
    data     u64   "sf_print_r64"
    data     u64   "sf_print_r32"
    data     u64   "sf_print_str"
    data     u64   "sf_print_str_nf"
    data     u64   "sf_print_strsl"
    data     u64   "sf_print_ptr"
    data     u64   "sf_print_ptr_nf"
    data     u64   "sf_print_c8"
    data     u64   "sf_print_bool"
    data     u64   "sf_print_newline"
    data     u64   "sf_print_end"
    data     u64   "sf_read_i64"
    data     u64   "sf_read_r64"
    data     u64   "sf_read_str"
    data     u64   "sf_read_fileline"
    data     u64   "sf_read_strline"
    data     u64   "sf_read_conline"
    data     u64   "sf_get_nprocs"
    data     u64   "sf_get_procname"
    data     u64   "sf_get_procaddr"
    data     u64   "sf_gettttable"
    data     u64   "sf_getsttable"
    data     u64   "sf_getfftable"
    data     u64   "sf_power_i64"
    data     u64   "sf_unimpl"
    istatic  u8:36 mm_tables.sysfnparams 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:36 mm_tables.sysfnres 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    zstatic  u8:288 mm_tables.sysfnhandlers 
    zstatic  i64   mm_tables.mlineno 
    istatic  u8:1024 mm_tables.jtagnames 
    data     u64   "jnone"
    data     u64   "jconst"
    data     u64   "jnull"
    data     u64   "jname"
    data     u64   "jblock"
    data     u64   "jassem"
    data     u64   "jassemmacro"
    data     u64   "jassemreg"
    data     u64   "jassemxreg"
    data     u64   "jassemmem"
    data     u64   "jstrinclude"
    data     u64   "jdebug"
    data     u64   "jandl"
    data     u64   "jorl"
    data     u64   "jnotl"
    data     u64   "jistruel"
    data     u64   "jmakelist"
    data     u64   "jmakerange"
    data     u64   "jmakeset"
    data     u64   "jmakedict"
    data     u64   "jmakeslice"
    data     u64   "jreturnmult"
    data     u64   "jkeyword"
    data     u64   "jkeyvalue"
    data     u64   "jassign"
    data     u64   "jassignmm"
    data     u64   "jassignms"
    data     u64   "jassignmdrem"
    data     u64   "jcopy"
    data     u64   "jcallfn"
    data     u64   "jcmp"
    data     u64   "jcmpchain"
    data     u64   "jbin"
    data     u64   "junary"
    data     u64   "jbinto"
    data     u64   "junaryto"
    data     u64   "jincrto"
    data     u64   "jmaths"
    data     u64   "jmaths2"
    data     u64   "jinrev"
    data     u64   "jinrange"
    data     u64   "jinset"
    data     u64   "jclamp"
    data     u64   "jindex"
    data     u64   "jslice"
    data     u64   "jdot"
    data     u64   "jdotindex"
    data     u64   "jdotslice"
    data     u64   "jptr"
    data     u64   "jaddrof"
    data     u64   "jaddroffirst"
    data     u64   "jconvert"
    data     u64   "jshorten"
    data     u64   "jautocast"
    data     u64   "jtypepun"
    data     u64   "jtypeconst"
    data     u64   "joperator"
    data     u64   "jupper"
    data     u64   "jbitwidth"
    data     u64   "jbytesize"
    data     u64   "jtypeof"
    data     u64   "jtypestr"
    data     u64   "jbitfield"
    data     u64   "jminvalue"
    data     u64   "jmaxvalue"
    data     u64   "jcvlineno"
    data     u64   "jcvstrlineno"
    data     u64   "jcvmodulename"
    data     u64   "jcvfilename"
    data     u64   "jcvfunction"
    data     u64   "jcvdate"
    data     u64   "jcvtime"
    data     u64   "jcvversion"
    data     u64   "jcvtargetbits"
    data     u64   "jcvtargetsize"
    data     u64   "jcvtargetcode"
    data     u64   "jcvwindows"
    data     u64   "jcvlinux"
    data     u64   "jcvnil"
    data     u64   "jcvpi"
    data     u64   "jcvinfinity"
    data     u64   "jcvtrue"
    data     u64   "jcvfalse"
    data     u64   "jcvdebug"
    data     u64   "jwhenthen"
    data     u64   "jfmtitem"
    data     u64   "jnogap"
    data     u64   "jspace"
    data     u64   "jcallproc"
    data     u64   "jreturn"
    data     u64   "jsyscall"
    data     u64   "jto"
    data     u64   "jif"
    data     u64   "jforup"
    data     u64   "jfordown"
    data     u64   "jforall"
    data     u64   "jforallrev"
    data     u64   "jwhile"
    data     u64   "jrepeat"
    data     u64   "jgoto"
    data     u64   "jlabeldef"
    data     u64   "jredo"
    data     u64   "jnext"
    data     u64   "jexit"
    data     u64   "jdo"
    data     u64   "jcase"
    data     u64   "jdocase"
    data     u64   "jswitch"
    data     u64   "jdoswitch"
    data     u64   "jswap"
    data     u64   "jselect"
    data     u64   "jrecase"
    data     u64   "jprint"
    data     u64   "jprintln"
    data     u64   "jfprint"
    data     u64   "jfprintln"
    data     u64   "jsprint"
    data     u64   "jsfprint"
    data     u64   "jread"
    data     u64   "jreadln"
    data     u64   "jsread"
    data     u64   "jsreadln"
    data     u64   "jstop"
    data     u64   "jeval"
    data     u64   "jempty"
    data     u64   "jemitc"
    data     u64   "jinfinity"
    data     u64   "jdummy"
    istatic  u8:128 mm_tables.jsubs 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    3 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    3 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    2 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    2 
    data     u8    3 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    3 
    data     u8    3 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:128 mm_tables.jisexpr 
    data     u8    0 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    2 
    data     u8    1 
    data     u8    2 
    data     u8    1 
    data     u8    2 
    data     u8    1 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    1 
    data     u8    1 
    data     u8    3 
    data     u8    1 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    0 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    0 
    data     u8    0 
    data     u8    3 
    data     u8    0 
    data     u8    3 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    3 
    data     u8    0 
    data     u8    3 
    data     u8    0 
    data     u8    0 
    data     u8    3 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    3 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    3 
    istatic  u8:64 mm_tables.bitfieldnames 
    data     u64   "bf_msb"
    data     u64   "bf_lsb"
    data     u64   "bf_msbit"
    data     u64   "bf_lsbit"
    data     u64   "bf_msw"
    data     u64   "bf_lsw"
    data     u64   "bf_odd"
    data     u64   "bf_even"
    istatic  u8:32 mm_tables.optypenames 
    data     u64   "no_op"
    data     u64   "bin_op"
    data     u64   "mon_op"
    data     u64   "prokop"
    istatic  u8:1328 mm_tables.symbolnames 
    data     u64   "errorsym"
    data     u64   "."
    data     u64   "lexdotsym"
    data     u64   "&."
    data     u64   ","
    data     u64   ";"
    data     u64   ":"
    data     u64   "::"
    data     u64   ":="
    data     u64   "::="
    data     u64   "=>"
    data     u64   "->"
    data     u64   "("
    data     u64   ")"
    data     u64   "["
    data     u64   "]"
    data     u64   "{"
    data     u64   "}"
    data     u64   "^"
    data     u64   "|"
    data     u64   "||"
    data     u64   "@"
    data     u64   "@@"
    data     u64   "?"
    data     u64   "&"
    data     u64   "&&"
    data     u64   "~"
    data     u64   ".."
    data     u64   "..."
    data     u64   "#"
    data     u64   "+"
    data     u64   "-"
    data     u64   "*"
    data     u64   "/"
    data     u64   "%"
    data     u64   "rem"
    data     u64   "divrem"
    data     u64   "iand"
    data     u64   "ior"
    data     u64   "ixor"
    data     u64   "<<"
    data     u64   ">>"
    data     u64   "min"
    data     u64   "max"
    data     u64   "and"
    data     u64   "or"
    data     u64   "xor"
    data     u64   "="
    data     u64   "cmp"
    data     u64   "**"
    data     u64   "in"
    data     u64   "notin"
    data     u64   "inrev"
    data     u64   "$neg"
    data     u64   "not"
    data     u64   "istrue"
    data     u64   "inot"
    data     u64   "abs"
    data     u64   "sign"
    data     u64   "sqrt"
    data     u64   "sqr"
    data     u64   "propsym"
    data     u64   "mathsopsym"
    data     u64   "maths2opsym"
    data     u64   "bitfieldsym"
    data     u64   "eolsym"
    data     u64   "eofsym"
    data     u64   "rawxnamesym"
    data     u64   "docstringsym"
    data     u64   "incrsym"
    data     u64   "intconstsym"
    data     u64   "decimalconstsym"
    data     u64   "realconstsym"
    data     u64   "charconstsym"
    data     u64   "wcharconstsym"
    data     u64   "stringconstsym"
    data     u64   "astringconstsym"
    data     u64   "wstringconstsym"
    data     u64   "unitnamesym"
    data     u64   "namesym"
    data     u64   "ksourcedirsym"
    data     u64   "kstrincludesym"
    data     u64   "regsym"
    data     u64   "xregsym"
    data     u64   "fregsym"
    data     u64   "mregsym"
    data     u64   "jmpccsym"
    data     u64   "setccsym"
    data     u64   "movccsym"
    data     u64   "segnamesym"
    data     u64   "asmopcodesym"
    data     u64   "stdtypesym"
    data     u64   "ktypeofsym"
    data     u64   "ksubrangesym"
    data     u64   "koutsym"
    data     u64   "kicharsym"
    data     u64   "kifsym"
    data     u64   "kthensym"
    data     u64   "kelsifsym"
    data     u64   "kelsesym"
    data     u64   "kelsecasesym"
    data     u64   "kelseswitchsym"
    data     u64   "kelseselectsym"
    data     u64   "kendsym"
    data     u64   "kunlesssym"
    data     u64   "kcasesym"
    data     u64   "kdocasesym"
    data     u64   "krecasesym"
    data     u64   "kwhensym"
    data     u64   "kforsym"
    data     u64   "ktosym"
    data     u64   "kbysym"
    data     u64   "kdosym"
    data     u64   "kwhilesym"
    data     u64   "krepeatsym"
    data     u64   "kuntilsym"
    data     u64   "kreturnsym"
    data     u64   "kstopsym"
    data     u64   "kloopsym"
    data     u64   "kstepsym"
    data     u64   "kgotosym"
    data     u64   "kswitchsym"
    data     u64   "kdoswitchsym"
    data     u64   "kprintsym"
    data     u64   "ksprintsym"
    data     u64   "kreadsym"
    data     u64   "ksreadsym"
    data     u64   "ksreadlnsym"
    data     u64   "kprocsym"
    data     u64   "kfunctionsym"
    data     u64   "klabelsym"
    data     u64   "krecordsym"
    data     u64   "kstructsym"
    data     u64   "kunionsym"
    data     u64   "kimportmodulesym"
    data     u64   "ktypesym"
    data     u64   "krefsym"
    data     u64   "kmutsym"
    data     u64   "kletsym"
    data     u64   "kslicesym"
    data     u64   "karraysym"
    data     u64   "kdictsym"
    data     u64   "kmacrosym"
    data     u64   "kconstsym"
    data     u64   "knewsym"
    data     u64   "kclearsym"
    data     u64   "kheadersym"
    data     u64   "kheadervarsym"
    data     u64   "kfflangsym"
    data     u64   "kglobalsym"
    data     u64   "kstaticsym"
    data     u64   "kcastsym"
    data     u64   "compilervarsym"
    data     u64   "dollarsym"
    data     u64   "kevalsym"
    data     u64   "ktabledatasym"
    data     u64   "kstacksym"
    data     u64   "kclampsym"
    data     u64   "kswapsym"
    data     u64   "kerrorsym"
    data     u64   "kassemsym"
    data     u64   "ksyscallsym"
    data     u64   "kemitcsym"
    data     u64   "kemptysym"
    data     u64   "kcopysym"
    data     u64   "kdummysym"
    istatic  u8:166 mm_tables.symboloptypes 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    3 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:166 mm_tables.symbolgenops 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    64 
    data     u8    65 
    data     u8    66 
    data     u8    175 
    data     u8    67 
    data     u8    68 
    data     u8    69 
    data     u8    70 
    data     u8    71 
    data     u8    72 
    data     u8    73 
    data     u8    74 
    data     u8    75 
    data     u8    76 
    data     u8    161 
    data     u8    162 
    data     u8    0 
    data     u8    77 
    data     u8    0 
    data     u8    83 
    data     u8    151 
    data     u8    152 
    data     u8    0 
    data     u8    99 
    data     u8    102 
    data     u8    103 
    data     u8    101 
    data     u8    100 
    data     u8    105 
    data     u8    106 
    data     u8    104 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:166 mm_tables.symbolgentoops 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    85 
    data     u8    86 
    data     u8    87 
    data     u8    176 
    data     u8    88 
    data     u8    89 
    data     u8    0 
    data     u8    90 
    data     u8    91 
    data     u8    92 
    data     u8    93 
    data     u8    94 
    data     u8    95 
    data     u8    96 
    data     u8    159 
    data     u8    160 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    123 
    data     u8    124 
    data     u8    122 
    data     u8    121 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:166 mm_tables.symbolopprios 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    5 
    data     u8    0 
    data     u8    0 
    data     u8    4 
    data     u8    4 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    3 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    3 
    data     u8    3 
    data     u8    4 
    data     u8    4 
    data     u8    7 
    data     u8    8 
    data     u8    8 
    data     u8    6 
    data     u8    6 
    data     u8    2 
    data     u8    6 
    data     u8    6 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:166 mm_tables.exprstarter 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    istatic  u8:16 mm_tables.sourcedirnames 
    data     u64   "includedir"
    data     u64   "binincludedir"
    istatic  u8:128 mm_tables.headerdirnames 
    data     u64   "hdr_module"
    data     u64   "hdr_import"
    data     u64   "hdr_subprog"
    data     u64   "hdr_sysmodule"
    data     u64   "hdr_sysimport"
    data     u64   "hdr_syssubprog"
    data     u64   "hdr_minclude"
    data     u64   "hdr_altpath"
    data     u64   "hdr_importpath"
    data     u64   "hdr_linkdll"
    data     u64   "hdr_linklib"
    data     u64   "hdr_exportmodule"
    data     u64   "hdr_file"
    data     u64   "hdr_runexe"
    data     u64   "hdr_setvar"
    data     u64   "hdr_showvar"
    istatic  u8:80 mm_tables.headervarnames 
    data     u64   "hv_devpath"
    data     u64   "hv_mmpath"
    data     u64   "hv_hdrpath"
    data     u64   "hv_windows"
    data     u64   "hv_linux"
    data     u64   "hv_optim"
    data     u64   "hv_mainmodule"
    data     u64   "hv_a"
    data     u64   "hv_b"
    data     u64   "hv_c"
    istatic  u8:40 mm_tables.fflangnames 
    data     u64   "noff"
    data     u64   "windowsff"
    data     u64   "clangff"
    data     u64   "mlangff"
    data     u64   "callbackff"
    istatic  u8:32 mm_tables.scopenames 
    data     u64   "Local"
    data     u64   "Global"
    data     u64   "Program"
    data     u64   "Export"
    istatic  u8:32 mm_tables.parammodenames 
    data     u64   "Var "
    data     u64   "In "
    data     u64   "Out "
    data     u64   "Opt "
    istatic  u8:168 mm_tables.namenames 
    data     u64   "nullid"
    data     u64   "programid"
    data     u64   "subprogid"
    data     u64   "moduleid"
    data     u64   "dllmoduleid"
    data     u64   "typeid"
    data     u64   "procid"
    data     u64   "dllprocid"
    data     u64   "dllvarid"
    data     u64   "genprocid"
    data     u64   "constid"
    data     u64   "staticid"
    data     u64   "frameid"
    data     u64   "paramid"
    data     u64   "fieldid"
    data     u64   "genfieldid"
    data     u64   "enumid"
    data     u64   "labelid"
    data     u64   "macroid"
    data     u64   "macroparamid"
    data     u64   "linkid"
    istatic  u8:1960 mm_tables.stnames 
    data     u64   "if"
    data     u64   "then"
    data     u64   "elsif"
    data     u64   "else"
    data     u64   "elsecase"
    data     u64   "elseswitch"
    data     u64   "case"
    data     u64   "docase"
    data     u64   "recase"
    data     u64   "when"
    data     u64   "for"
    data     u64   "forall"
    data     u64   "to"
    data     u64   "downto"
    data     u64   "by"
    data     u64   "do"
    data     u64   "end"
    data     u64   "while"
    data     u64   "repeat"
    data     u64   "until"
    data     u64   "always"
    data     u64   "return"
    data     u64   "stop"
    data     u64   "redo"
    data     u64   "next"
    data     u64   "exit"
    data     u64   "$step"
    data     u64   "goto"
    data     u64   "go"
    data     u64   "switch"
    data     u64   "doswitch"
    data     u64   "doswitchu"
    data     u64   "tabledata"
    data     u64   "enumdata"
    data     u64   "clamp"
    data     u64   "eval"
    data     u64   "evalloadref"
    data     u64   "evalgetref"
    data     u64   "evalget"
    data     u64   "evalload"
    data     u64   "print"
    data     u64   "println"
    data     u64   "fprint"
    data     u64   "fprintln"
    data     u64   "sprint"
    data     u64   "sfprint"
    data     u64   "cp"
    data     u64   "cpl"
    data     u64   "read"
    data     u64   "readln"
    data     u64   "cast"
    data     u64   "function"
    data     u64   "func"
    data     u64   "procedure"
    data     u64   "proc"
    data     u64   "fun"
    data     u64   "sub"
    data     u64   "threadedproc"
    data     u64   "type"
    data     u64   "record"
    data     u64   "struct"
    data     u64   "union"
    data     u64   "ref"
    data     u64   "pointer"
    data     u64   "returning"
    data     u64   "mut"
    data     u64   "var"
    data     u64   "let"
    data     u64   "include"
    data     u64   "strinclude"
    data     u64   "bininclude"
    data     u64   "emitc"
    data     u64   "macro"
    data     u64   "assem"
    data     u64   "asm"
    data     u64   "static"
    data     u64   "const"
    data     u64   "$get_nprocs"
    data     u64   "$getnprocs"
    data     u64   "$get_procname"
    data     u64   "$getprocname"
    data     u64   "$get_procaddr"
    data     u64   "$getprocaddr"
    data     u64   "$gettttable"
    data     u64   "$getsttable"
    data     u64   "$getfftable"
    data     u64   "importdll"
    data     u64   "importlib"
    data     u64   "unless"
    data     u64   "out"
    data     u64   "global"
    data     u64   "export"
    data     u64   "clang"
    data     u64   "mlang"
    data     u64   "windows"
    data     u64   "callback"
    data     u64   "swap"
    data     u64   "void"
    data     u64   "int"
    data     u64   "word"
    data     u64   "real"
    data     u64   "ichar"
    data     u64   "int8"
    data     u64   "int16"
    data     u64   "int32"
    data     u64   "int64"
    data     u64   "i8"
    data     u64   "i16"
    data     u64   "i32"
    data     u64   "i64"
    data     u64   "real32"
    data     u64   "real64"
    data     u64   "r32"
    data     u64   "r64"
    data     u64   "float32"
    data     u64   "float64"
    data     u64   "byte"
    data     u64   "u8"
    data     u64   "u16"
    data     u64   "u32"
    data     u64   "u64"
    data     u64   "word8"
    data     u64   "word16"
    data     u64   "word32"
    data     u64   "word64"
    data     u64   "char"
    data     u64   "char64"
    data     u64   "bool64"
    data     u64   "bool"
    data     u64   "bool8"
    data     u64   "range"
    data     u64   "auto"
    data     u64   "label"
    data     u64   "slice"
    data     u64   "array"
    data     u64   "typeof"
    data     u64   "million"
    data     u64   "billion"
    data     u64   "thousand"
    data     u64   "$lineno"
    data     u64   "$strlineno"
    data     u64   "$filename"
    data     u64   "$modulename"
    data     u64   "$function"
    data     u64   "$date"
    data     u64   "$time"
    data     u64   "$version"
    data     u64   "$targetbits"
    data     u64   "$targetsize"
    data     u64   "$targetcode"
    data     u64   "$windows"
    data     u64   "$linux"
    data     u64   "nil"
    data     u64   "pi"
    data     u64   "true"
    data     u64   "false"
    data     u64   "infinity"
    data     u64   "$debug"
    data     u64   "$"
    data     u64   "and"
    data     u64   "or"
    data     u64   "xor"
    data     u64   "iand"
    data     u64   "ior"
    data     u64   "ixor"
    data     u64   "in"
    data     u64   "notin"
    data     u64   "inrev"
    data     u64   "rem"
    data     u64   "divrem"
    data     u64   "min"
    data     u64   "max"
    data     u64   "not"
    data     u64   "inot"
    data     u64   "istrue"
    data     u64   "abs"
    data     u64   "$neg"
    data     u64   "sqr"
    data     u64   "sqrt"
    data     u64   "sign"
    data     u64   "sin"
    data     u64   "cos"
    data     u64   "tan"
    data     u64   "asin"
    data     u64   "acos"
    data     u64   "atan"
    data     u64   "ln"
    data     u64   "log"
    data     u64   "exp"
    data     u64   "round"
    data     u64   "floor"
    data     u64   "ceil"
    data     u64   "fract"
    data     u64   "atan2"
    data     u64   "fmod"
    data     u64   "sliceptr"
    data     u64   "len"
    data     u64   "lwb"
    data     u64   "upb"
    data     u64   "bounds"
    data     u64   "bitwidth"
    data     u64   "bytes"
    data     u64   "minvalue"
    data     u64   "maxvalue"
    data     u64   "typestr"
    data     u64   "msb"
    data     u64   "lsb"
    data     u64   "msbit"
    data     u64   "lsbit"
    data     u64   "msw"
    data     u64   "lsw"
    data     u64   "odd"
    data     u64   "even"
    data     u64   "fi"
    data     u64   "esac"
    data     u64   "od"
    data     u64   "$caligned"
    data     u64   "empty"
    data     u64   "clear"
    data     u64   "copy"
    data     u64   "module"
    data     u64   "sysmodule"
    data     u64   "import"
    data     u64   "sysimport"
    data     u64   "minclude"
    data     u64   "subprog"
    data     u64   "syssubprog"
    data     u64   "altpath"
    data     u64   "importpath"
    data     u64   "linkdll"
    data     u64   "linklib"
    data     u64   "exportmodule"
    data     u64   "runexe"
    data     u64   "setvar"
    data     u64   "showvar"
    data     u64   "$devpath"
    data     u64   "$mmpath"
    data     u64   "$hdrpath"
    data     u64   "$$windows"
    data     u64   "$$linux"
    data     u64   "$mainmodule"
    data     u64   "$a"
    data     u64   "$b"
    data     u64   "$c"
    data     u64   "$$dummy"
    istatic  u8:1960 mm_tables.stsymbols 
    data     u64   97 
    data     u64   98 
    data     u64   99 
    data     u64   100 
    data     u64   101 
    data     u64   102 
    data     u64   106 
    data     u64   107 
    data     u64   108 
    data     u64   109 
    data     u64   110 
    data     u64   110 
    data     u64   111 
    data     u64   111 
    data     u64   112 
    data     u64   113 
    data     u64   104 
    data     u64   114 
    data     u64   115 
    data     u64   116 
    data     u64   116 
    data     u64   117 
    data     u64   118 
    data     u64   119 
    data     u64   119 
    data     u64   119 
    data     u64   120 
    data     u64   121 
    data     u64   121 
    data     u64   122 
    data     u64   123 
    data     u64   123 
    data     u64   156 
    data     u64   156 
    data     u64   158 
    data     u64   155 
    data     u64   155 
    data     u64   155 
    data     u64   155 
    data     u64   155 
    data     u64   124 
    data     u64   124 
    data     u64   124 
    data     u64   124 
    data     u64   125 
    data     u64   125 
    data     u64   124 
    data     u64   124 
    data     u64   126 
    data     u64   126 
    data     u64   152 
    data     u64   130 
    data     u64   130 
    data     u64   129 
    data     u64   129 
    data     u64   130 
    data     u64   129 
    data     u64   129 
    data     u64   136 
    data     u64   132 
    data     u64   133 
    data     u64   134 
    data     u64   137 
    data     u64   137 
    data     u64   11 
    data     u64   138 
    data     u64   138 
    data     u64   139 
    data     u64   81 
    data     u64   82 
    data     u64   81 
    data     u64   163 
    data     u64   143 
    data     u64   161 
    data     u64   161 
    data     u64   151 
    data     u64   144 
    data     u64   162 
    data     u64   162 
    data     u64   162 
    data     u64   162 
    data     u64   162 
    data     u64   162 
    data     u64   162 
    data     u64   162 
    data     u64   162 
    data     u64   135 
    data     u64   135 
    data     u64   105 
    data     u64   95 
    data     u64   150 
    data     u64   150 
    data     u64   149 
    data     u64   149 
    data     u64   149 
    data     u64   149 
    data     u64   159 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   96 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   92 
    data     u64   140 
    data     u64   141 
    data     u64   93 
    data     u64   79 
    data     u64   79 
    data     u64   79 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   153 
    data     u64   154 
    data     u64   45 
    data     u64   46 
    data     u64   47 
    data     u64   38 
    data     u64   39 
    data     u64   40 
    data     u64   51 
    data     u64   52 
    data     u64   53 
    data     u64   36 
    data     u64   37 
    data     u64   43 
    data     u64   44 
    data     u64   55 
    data     u64   57 
    data     u64   56 
    data     u64   58 
    data     u64   54 
    data     u64   61 
    data     u64   60 
    data     u64   59 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   63 
    data     u64   64 
    data     u64   64 
    data     u64   62 
    data     u64   62 
    data     u64   62 
    data     u64   62 
    data     u64   62 
    data     u64   62 
    data     u64   62 
    data     u64   62 
    data     u64   62 
    data     u64   62 
    data     u64   65 
    data     u64   65 
    data     u64   65 
    data     u64   65 
    data     u64   65 
    data     u64   65 
    data     u64   65 
    data     u64   65 
    data     u64   104 
    data     u64   104 
    data     u64   104 
    data     u64   22 
    data     u64   164 
    data     u64   164 
    data     u64   165 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   147 
    data     u64   148 
    data     u64   148 
    data     u64   148 
    data     u64   148 
    data     u64   148 
    data     u64   148 
    data     u64   148 
    data     u64   148 
    data     u64   148 
    data     u64   0 
    istatic  u8:1960 mm_tables.stsubcodes 
    data     u64   92 
    data     u64   0 
    data     u64   92 
    data     u64   0 
    data     u64   105 
    data     u64   107 
    data     u64   105 
    data     u64   106 
    data     u64   111 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   1 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   1 
    data     u64   0 
    data     u64   0 
    data     u64   101 
    data     u64   102 
    data     u64   103 
    data     u64   0 
    data     u64   0 
    data     u64   1 
    data     u64   107 
    data     u64   108 
    data     u64   108 
    data     u64   0 
    data     u64   1 
    data     u64   0 
    data     u64   0 
    data     u64   2 
    data     u64   3 
    data     u64   1 
    data     u64   0 
    data     u64   112 
    data     u64   113 
    data     u64   114 
    data     u64   115 
    data     u64   116 
    data     u64   117 
    data     u64   112 
    data     u64   113 
    data     u64   118 
    data     u64   119 
    data     u64   51 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   1 
    data     u64   1 
    data     u64   2 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   1 
    data     u64   0 
    data     u64   2 
    data     u64   0 
    data     u64   0 
    data     u64   1 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   29 
    data     u64   29 
    data     u64   30 
    data     u64   30 
    data     u64   31 
    data     u64   31 
    data     u64   32 
    data     u64   33 
    data     u64   34 
    data     u64   68 
    data     u64   76 
    data     u64   0 
    data     u64   0 
    data     u64   1 
    data     u64   3 
    data     u64   2 
    data     u64   3 
    data     u64   1 
    data     u64   4 
    data     u64   0 
    data     u64   0 
    data     u64   3 
    data     u64   2 
    data     u64   5 
    data     u64   0 
    data     u64   15 
    data     u64   16 
    data     u64   17 
    data     u64   3 
    data     u64   15 
    data     u64   16 
    data     u64   17 
    data     u64   3 
    data     u64   4 
    data     u64   5 
    data     u64   4 
    data     u64   5 
    data     u64   4 
    data     u64   5 
    data     u64   18 
    data     u64   18 
    data     u64   19 
    data     u64   20 
    data     u64   2 
    data     u64   18 
    data     u64   19 
    data     u64   20 
    data     u64   2 
    data     u64   13 
    data     u64   1 
    data     u64   6 
    data     u64   6 
    data     u64   14 
    data     u64   9 
    data     u64   22 
    data     u64   25 
    data     u64   11 
    data     u64   0 
    data     u64   0 
    data     u64   2 
    data     u64   3 
    data     u64   1 
    data     u64   65 
    data     u64   66 
    data     u64   68 
    data     u64   67 
    data     u64   69 
    data     u64   70 
    data     u64   71 
    data     u64   72 
    data     u64   73 
    data     u64   74 
    data     u64   75 
    data     u64   76 
    data     u64   77 
    data     u64   78 
    data     u64   79 
    data     u64   81 
    data     u64   82 
    data     u64   80 
    data     u64   83 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   151 
    data     u64   152 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   100 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   107 
    data     u64   108 
    data     u64   109 
    data     u64   110 
    data     u64   111 
    data     u64   112 
    data     u64   113 
    data     u64   114 
    data     u64   115 
    data     u64   116 
    data     u64   117 
    data     u64   118 
    data     u64   119 
    data     u64   84 
    data     u64   163 
    data     u64   140 
    data     u64   155 
    data     u64   153 
    data     u64   154 
    data     u64   158 
    data     u64   164 
    data     u64   165 
    data     u64   156 
    data     u64   157 
    data     u64   166 
    data     u64   1 
    data     u64   2 
    data     u64   3 
    data     u64   4 
    data     u64   5 
    data     u64   6 
    data     u64   7 
    data     u64   8 
    data     u64   97 
    data     u64   106 
    data     u64   113 
    data     u64   1 
    data     u64   0 
    data     u64   0 
    data     u64   0 
    data     u64   1 
    data     u64   4 
    data     u64   2 
    data     u64   5 
    data     u64   7 
    data     u64   3 
    data     u64   6 
    data     u64   8 
    data     u64   9 
    data     u64   10 
    data     u64   11 
    data     u64   12 
    data     u64   14 
    data     u64   15 
    data     u64   16 
    data     u64   1 
    data     u64   2 
    data     u64   3 
    data     u64   4 
    data     u64   5 
    data     u64   7 
    data     u64   8 
    data     u64   9 
    data     u64   10 
    data     u64   0 
    istatic  u8:72 mm_tables.d_typestarterset 
    data     u64   92 
    data     u64   15 
    data     u64   137 
    data     u64   132 
    data     u64   96 
    data     u64   93 
    data     u64   140 
    data     u64   142 
    data     u64   141 
    istatic  u8:7  mm_tables.intresultlist 
    data     u8    151 
    data     u8    152 
    data     u8    153 
    data     u8    154 
    data     u8    155 
    data     u8    164 
    data     u8    165 
    istatic  u8:50 mm_tables.softconvtable 
    data     u16   167 
    data     u16   167 
    data     u16   167 
    data     u16   131 
    data     u16   131 
    data     u16   167 
    data     u16   167 
    data     u16   167 
    data     u16   131 
    data     u16   131 
    data     u16   167 
    data     u16   167 
    data     u16   167 
    data     u16   131 
    data     u16   131 
    data     u16   132 
    data     u16   132 
    data     u16   132 
    data     u16   167 
    data     u16   134 
    data     u16   132 
    data     u16   132 
    data     u16   132 
    data     u16   135 
    data     u16   167 
    zstatic  u8:176 mm_tables.intresult 
    zstatic  u8:166 mm_tables.endsexpr 
    istatic  u8:12 mm_tables.exprendsymbols 
    data     u8    14 
    data     u8    16 
    data     u8    98 
    data     u8    99 
    data     u8    100 
    data     u8    116 
    data     u8    113 
    data     u8    104 
    data     u8    5 
    data     u8    20 
    data     u8    6 
    data     u8    111 
    zstatic  u8:128 mm_tables.isbooltag 
    zstatic  u8:128 mm_tables.ismemtag 
    zstatic  u8:128 mm_tables.islvalue 
    zstatic  i64   mm_type.countedfields 
    zstatic  i64   mm_type.inassem 
    zstatic  i64   mm_type.inidata 
    zstatic  i64   mm_type.deb 
    zstatic  i64   mm_topcl.cmdskip 
    zstatic  u8    mm_topcl.fshortnames 
    istatic  u8:88 mc_decls.valtypenames 
    data     u64   "no_val"
    data     u64   "intimm_val"
    data     u64   "realimm_val"
    data     u64   "stringimm_val"
    data     u64   "def_val"
    data     u64   "label_val"
    data     u64   "name_val"
    data     u64   "assem_val"
    data     u64   "string_val"
    data     u64   "real_val"
    data     u64   "real32_val"
    istatic  u8:48 opndnames 
    data     u64   "a_none"
    data     u64   "a_reg"
    data     u64   "a_xreg"
    data     u64   "a_imm"
    data     u64   "a_mem"
    data     u64   "a_assem"
    istatic  u8:1208 mclnames 
    data     u64   "m_procstart"
    data     u64   "m_procend"
    data     u64   "m_programend"
    data     u64   "m_comment"
    data     u64   "m_blank"
    data     u64   "m_deleted"
    data     u64   "m_labelname"
    data     u64   "m_define"
    data     u64   "m_definereg"
    data     u64   "m_evalx"
    data     u64   "m_labelx"
    data     u64   "m_nop"
    data     u64   "m_mov"
    data     u64   "m_push"
    data     u64   "m_pop"
    data     u64   "m_lea"
    data     u64   "m_cmovcc"
    data     u64   "m_movd"
    data     u64   "m_movq"
    data     u64   "m_movsx"
    data     u64   "m_movzx"
    data     u64   "m_movsxd"
    data     u64   "m_call"
    data     u64   "m_ret"
    data     u64   "m_leave"
    data     u64   "m_retn"
    data     u64   "m_jmp"
    data     u64   "m_jmpcc"
    data     u64   "m_xchg"
    data     u64   "m_add"
    data     u64   "m_sub"
    data     u64   "m_adc"
    data     u64   "m_sbb"
    data     u64   "m_imul"
    data     u64   "m_mul"
    data     u64   "m_imul2"
    data     u64   "m_imul3"
    data     u64   "m_idiv"
    data     u64   "m_div"
    data     u64   "m_andx"
    data     u64   "m_orx"
    data     u64   "m_xorx"
    data     u64   "m_test"
    data     u64   "m_cmp"
    data     u64   "m_shl"
    data     u64   "m_sar"
    data     u64   "m_shr"
    data     u64   "m_rol"
    data     u64   "m_ror"
    data     u64   "m_rcl"
    data     u64   "m_rcr"
    data     u64   "m_neg"
    data     u64   "m_notx"
    data     u64   "m_inc"
    data     u64   "m_dec"
    data     u64   "m_cbw"
    data     u64   "m_cwd"
    data     u64   "m_cdq"
    data     u64   "m_cqo"
    data     u64   "m_setcc"
    data     u64   "m_bsf"
    data     u64   "m_bsr"
    data     u64   "m_sqrtsd"
    data     u64   "m_sqrtss"
    data     u64   "m_addss"
    data     u64   "m_subss"
    data     u64   "m_mulss"
    data     u64   "m_divss"
    data     u64   "m_addsd"
    data     u64   "m_subsd"
    data     u64   "m_mulsd"
    data     u64   "m_divsd"
    data     u64   "m_comiss"
    data     u64   "m_comisd"
    data     u64   "m_xorpd"
    data     u64   "m_xorps"
    data     u64   "m_andpd"
    data     u64   "m_andps"
    data     u64   "m_pxor"
    data     u64   "m_pand"
    data     u64   "m_cvtss2si"
    data     u64   "m_cvtsd2si"
    data     u64   "m_cvttss2si"
    data     u64   "m_cvttsd2si"
    data     u64   "m_cvtsi2ss"
    data     u64   "m_cvtsi2sd"
    data     u64   "m_cvtsd2ss"
    data     u64   "m_cvtss2sd"
    data     u64   "m_movdqa"
    data     u64   "m_movdqu"
    data     u64   "m_pcmpistri"
    data     u64   "m_pcmpistrm"
    data     u64   "m_fld"
    data     u64   "m_fst"
    data     u64   "m_fstp"
    data     u64   "m_fild"
    data     u64   "m_fist"
    data     u64   "m_fistp"
    data     u64   "m_fadd"
    data     u64   "m_fsub"
    data     u64   "m_fmul"
    data     u64   "m_fdiv"
    data     u64   "m_fsqrt"
    data     u64   "m_fsin"
    data     u64   "m_fcos"
    data     u64   "m_fsincos"
    data     u64   "m_fptan"
    data     u64   "m_fpatan"
    data     u64   "m_fabs"
    data     u64   "m_fchs"
    data     u64   "m_minss"
    data     u64   "m_maxss"
    data     u64   "m_minsd"
    data     u64   "m_maxsd"
    data     u64   "m_db"
    data     u64   "m_dw"
    data     u64   "m_dd"
    data     u64   "m_dq"
    data     u64   "m_ddoffset"
    data     u64   "m_segment"
    data     u64   "m_isegment"
    data     u64   "m_zsegment"
    data     u64   "m_csegment"
    data     u64   "m_align"
    data     u64   "m_resb"
    data     u64   "m_resw"
    data     u64   "m_resd"
    data     u64   "m_resq"
    data     u64   "m_xlat"
    data     u64   "m_loopnz"
    data     u64   "m_loopz"
    data     u64   "m_loopcx"
    data     u64   "m_jecxz"
    data     u64   "m_jrcxz"
    data     u64   "m_cmpsb"
    data     u64   "m_cmpsw"
    data     u64   "m_cmpsd"
    data     u64   "m_cmpsq"
    data     u64   "m_rdtsc"
    data     u64   "m_popcnt"
    data     u64   "m_finit"
    data     u64   "m_fldz"
    data     u64   "m_fld1"
    data     u64   "m_fldpi"
    data     u64   "m_fld2t"
    data     u64   "m_fld2e"
    data     u64   "m_fldlg2"
    data     u64   "m_fldln2"
    data     u64   "m_cpuid"
    data     u64   "m_halt"
    data     u64   "m_last"
    istatic  u8:151 mclnopnds 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    1 
    data     u8    1 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    3 
    data     u8    3 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    2 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    istatic  u8:151 mclcodes 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    144 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    232 
    data     u8    195 
    data     u8    201 
    data     u8    0 
    data     u8    233 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    5 
    data     u8    2 
    data     u8    3 
    data     u8    5 
    data     u8    4 
    data     u8    0 
    data     u8    0 
    data     u8    7 
    data     u8    6 
    data     u8    4 
    data     u8    1 
    data     u8    6 
    data     u8    0 
    data     u8    7 
    data     u8    4 
    data     u8    7 
    data     u8    5 
    data     u8    0 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    3 
    data     u8    2 
    data     u8    0 
    data     u8    1 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    188 
    data     u8    189 
    data     u8    81 
    data     u8    81 
    data     u8    88 
    data     u8    92 
    data     u8    89 
    data     u8    94 
    data     u8    88 
    data     u8    92 
    data     u8    89 
    data     u8    94 
    data     u8    0 
    data     u8    0 
    data     u8    87 
    data     u8    87 
    data     u8    84 
    data     u8    84 
    data     u8    239 
    data     u8    219 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    102 
    data     u8    243 
    data     u8    99 
    data     u8    98 
    data     u8    0 
    data     u8    2 
    data     u8    3 
    data     u8    0 
    data     u8    2 
    data     u8    3 
    data     u8    193 
    data     u8    233 
    data     u8    201 
    data     u8    249 
    data     u8    250 
    data     u8    254 
    data     u8    255 
    data     u8    251 
    data     u8    242 
    data     u8    243 
    data     u8    225 
    data     u8    224 
    data     u8    93 
    data     u8    95 
    data     u8    93 
    data     u8    95 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    1 
    data     u8    2 
    data     u8    4 
    data     u8    8 
    data     u8    215 
    data     u8    224 
    data     u8    225 
    data     u8    226 
    data     u8    227 
    data     u8    227 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    49 
    data     u8    0 
    data     u8    0 
    data     u8    238 
    data     u8    232 
    data     u8    235 
    data     u8    233 
    data     u8    234 
    data     u8    236 
    data     u8    237 
    data     u8    0 
    data     u8    244 
    data     u8    0 
    istatic  u8:168 regnames 
    data     u64   "rnone"
    data     u64   "r0"
    data     u64   "r1"
    data     u64   "r2"
    data     u64   "r3"
    data     u64   "r4"
    data     u64   "r5"
    data     u64   "r6"
    data     u64   "r7"
    data     u64   "r8"
    data     u64   "r9"
    data     u64   "r10"
    data     u64   "r11"
    data     u64   "r12"
    data     u64   "r13"
    data     u64   "r14"
    data     u64   "r15"
    data     u64   "r16"
    data     u64   "r17"
    data     u64   "r18"
    data     u64   "r19"
    istatic  u8:21 regcodes 
    data     u8    0 
    data     u8    0 
    data     u8    10 
    data     u8    11 
    data     u8    7 
    data     u8    3 
    data     u8    6 
    data     u8    12 
    data     u8    13 
    data     u8    14 
    data     u8    15 
    data     u8    1 
    data     u8    2 
    data     u8    8 
    data     u8    9 
    data     u8    5 
    data     u8    4 
    data     u8    4 
    data     u8    7 
    data     u8    5 
    data     u8    6 
    istatic  u8:160 mc_decls.condnames 
    data     u64   "ov"
    data     u64   "nov"
    data     u64   "ltu"
    data     u64   "geu"
    data     u64   "eq"
    data     u64   "ne"
    data     u64   "leu"
    data     u64   "gtu"
    data     u64   "s"
    data     u64   "ns"
    data     u64   "p"
    data     u64   "np"
    data     u64   "lt"
    data     u64   "ge"
    data     u64   "le"
    data     u64   "gt"
    data     u64   "flt"
    data     u64   "fge"
    data     u64   "fle"
    data     u64   "fgt"
    istatic  u8:160 mc_decls.asmcondnames 
    data     u64   "o"
    data     u64   "no"
    data     u64   "b"
    data     u64   "ae"
    data     u64   "z"
    data     u64   "nz"
    data     u64   "be"
    data     u64   "a"
    data     u64   "s"
    data     u64   "ns"
    data     u64   "p"
    data     u64   "np"
    data     u64   "l"
    data     u64   "ge"
    data     u64   "le"
    data     u64   "g"
    data     u64   "b"
    data     u64   "ae"
    data     u64   "be"
    data     u64   "a"
    istatic  u8:160 mc_decls.asmrevcond 
    data     u64   1 
    data     u64   0 
    data     u64   3 
    data     u64   2 
    data     u64   5 
    data     u64   4 
    data     u64   7 
    data     u64   6 
    data     u64   9 
    data     u64   8 
    data     u64   11 
    data     u64   10 
    data     u64   13 
    data     u64   12 
    data     u64   15 
    data     u64   14 
    data     u64   17 
    data     u64   16 
    data     u64   19 
    data     u64   18 
    istatic  u8:1088 dregnames 
    data     u64   "d0"
    data     u64   "d1"
    data     u64   "d2"
    data     u64   "d3"
    data     u64   "d4"
    data     u64   "d5"
    data     u64   "d6"
    data     u64   "d7"
    data     u64   "d8"
    data     u64   "d9"
    data     u64   "d10"
    data     u64   "d11"
    data     u64   "d12"
    data     u64   "d13"
    data     u64   "d14"
    data     u64   "d15"
    data     u64   "a0"
    data     u64   "a1"
    data     u64   "a2"
    data     u64   "a3"
    data     u64   "a4"
    data     u64   "a5"
    data     u64   "a6"
    data     u64   "a7"
    data     u64   "a8"
    data     u64   "a9"
    data     u64   "a10"
    data     u64   "a11"
    data     u64   "a12"
    data     u64   "a13"
    data     u64   "a14"
    data     u64   "a15"
    data     u64   "w0"
    data     u64   "w1"
    data     u64   "w2"
    data     u64   "w3"
    data     u64   "w4"
    data     u64   "w5"
    data     u64   "w6"
    data     u64   "w7"
    data     u64   "w8"
    data     u64   "w9"
    data     u64   "w10"
    data     u64   "w11"
    data     u64   "w12"
    data     u64   "w13"
    data     u64   "w14"
    data     u64   "w15"
    data     u64   "b0"
    data     u64   "b1"
    data     u64   "b2"
    data     u64   "b3"
    data     u64   "b4"
    data     u64   "b5"
    data     u64   "b6"
    data     u64   "b7"
    data     u64   "b8"
    data     u64   "b9"
    data     u64   "b10"
    data     u64   "b11"
    data     u64   "b12"
    data     u64   "b13"
    data     u64   "b14"
    data     u64   "b15"
    data     u64   "b16"
    data     u64   "b17"
    data     u64   "b18"
    data     u64   "b19"
    data     u64   "rax"
    data     u64   "rbx"
    data     u64   "rcx"
    data     u64   "rdx"
    data     u64   "rsi"
    data     u64   "rdi"
    data     u64   "rbp"
    data     u64   "rsp"
    data     u64   "r8"
    data     u64   "r9"
    data     u64   "r10"
    data     u64   "r11"
    data     u64   "r12"
    data     u64   "r13"
    data     u64   "r14"
    data     u64   "r15"
    data     u64   "eax"
    data     u64   "ebx"
    data     u64   "ecx"
    data     u64   "edx"
    data     u64   "esi"
    data     u64   "edi"
    data     u64   "ebp"
    data     u64   "esp"
    data     u64   "r8d"
    data     u64   "r9d"
    data     u64   "r10d"
    data     u64   "r11d"
    data     u64   "r12d"
    data     u64   "r13d"
    data     u64   "r14d"
    data     u64   "r15d"
    data     u64   "ax"
    data     u64   "bx"
    data     u64   "cx"
    data     u64   "dx"
    data     u64   "si"
    data     u64   "di"
    data     u64   "bp"
    data     u64   "sp"
    data     u64   "r8w"
    data     u64   "r9w"
    data     u64   "r10w"
    data     u64   "r11w"
    data     u64   "r12w"
    data     u64   "r13w"
    data     u64   "r14w"
    data     u64   "r15w"
    data     u64   "al"
    data     u64   "bl"
    data     u64   "cl"
    data     u64   "dl"
    data     u64   "ah"
    data     u64   "bh"
    data     u64   "ch"
    data     u64   "dh"
    data     u64   "sil"
    data     u64   "dil"
    data     u64   "bpl"
    data     u64   "spl"
    data     u64   "r8b"
    data     u64   "r9b"
    data     u64   "r10b"
    data     u64   "r11b"
    data     u64   "r12b"
    data     u64   "r13b"
    data     u64   "r14b"
    data     u64   "r15b"
    istatic  u8:136 regsizes 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    8 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    4 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    2 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    data     u8    1 
    istatic  u8:136 regindices 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    4 
    data     u8    5 
    data     u8    6 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    11 
    data     u8    12 
    data     u8    13 
    data     u8    14 
    data     u8    15 
    data     u8    16 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    4 
    data     u8    5 
    data     u8    6 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    11 
    data     u8    12 
    data     u8    13 
    data     u8    14 
    data     u8    15 
    data     u8    16 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    4 
    data     u8    5 
    data     u8    6 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    11 
    data     u8    12 
    data     u8    13 
    data     u8    14 
    data     u8    15 
    data     u8    16 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    4 
    data     u8    5 
    data     u8    6 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    11 
    data     u8    12 
    data     u8    13 
    data     u8    14 
    data     u8    15 
    data     u8    16 
    data     u8    17 
    data     u8    18 
    data     u8    19 
    data     u8    20 
    data     u8    1 
    data     u8    5 
    data     u8    11 
    data     u8    12 
    data     u8    6 
    data     u8    4 
    data     u8    15 
    data     u8    16 
    data     u8    13 
    data     u8    14 
    data     u8    2 
    data     u8    3 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    1 
    data     u8    5 
    data     u8    11 
    data     u8    12 
    data     u8    6 
    data     u8    4 
    data     u8    15 
    data     u8    16 
    data     u8    13 
    data     u8    14 
    data     u8    2 
    data     u8    3 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    1 
    data     u8    5 
    data     u8    11 
    data     u8    12 
    data     u8    6 
    data     u8    4 
    data     u8    15 
    data     u8    16 
    data     u8    13 
    data     u8    14 
    data     u8    2 
    data     u8    3 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    1 
    data     u8    5 
    data     u8    11 
    data     u8    12 
    data     u8    17 
    data     u8    18 
    data     u8    19 
    data     u8    20 
    data     u8    6 
    data     u8    4 
    data     u8    15 
    data     u8    16 
    data     u8    13 
    data     u8    14 
    data     u8    2 
    data     u8    3 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    istatic  u8:128 xmmregnames 
    data     u64   "xmm0"
    data     u64   "xmm1"
    data     u64   "xmm2"
    data     u64   "xmm3"
    data     u64   "xmm4"
    data     u64   "xmm5"
    data     u64   "xmm6"
    data     u64   "xmm7"
    data     u64   "xmm8"
    data     u64   "xmm9"
    data     u64   "xmm10"
    data     u64   "xmm11"
    data     u64   "xmm12"
    data     u64   "xmm13"
    data     u64   "xmm14"
    data     u64   "xmm15"
    istatic  u8:64 fregnames 
    data     u64   "st0"
    data     u64   "st1"
    data     u64   "st2"
    data     u64   "st3"
    data     u64   "st4"
    data     u64   "st5"
    data     u64   "st6"
    data     u64   "st7"
    istatic  u8:64 mregnames 
    data     u64   "mmx0"
    data     u64   "mmx1"
    data     u64   "mmx2"
    data     u64   "mmx3"
    data     u64   "mmx4"
    data     u64   "mmx5"
    data     u64   "mmx6"
    data     u64   "mmx7"
    istatic  u8:144 jmpccnames 
    data     u64   "jo"
    data     u64   "jno"
    data     u64   "jb"
    data     u64   "jae"
    data     u64   "jz"
    data     u64   "jnz"
    data     u64   "jbe"
    data     u64   "ja"
    data     u64   "js"
    data     u64   "jns"
    data     u64   "jp"
    data     u64   "jnp"
    data     u64   "jl"
    data     u64   "jge"
    data     u64   "jle"
    data     u64   "jg"
    data     u64   "jc"
    data     u64   "jnc"
    istatic  u8:18 jmpcccodes 
    data     u8    0 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    4 
    data     u8    5 
    data     u8    6 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    11 
    data     u8    12 
    data     u8    13 
    data     u8    14 
    data     u8    15 
    data     u8    2 
    data     u8    3 
    istatic  u8:128 setccnames 
    data     u64   "seto"
    data     u64   "setno"
    data     u64   "setb"
    data     u64   "setae"
    data     u64   "setz"
    data     u64   "setnz"
    data     u64   "setbe"
    data     u64   "seta"
    data     u64   "sets"
    data     u64   "setns"
    data     u64   "setp"
    data     u64   "setnp"
    data     u64   "setl"
    data     u64   "setge"
    data     u64   "setle"
    data     u64   "setg"
    istatic  u8:16 setcccodes 
    data     u8    0 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    4 
    data     u8    5 
    data     u8    6 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    11 
    data     u8    12 
    data     u8    13 
    data     u8    14 
    data     u8    15 
    istatic  u8:128 cmovccnames 
    data     u64   "cmovo"
    data     u64   "cmovno"
    data     u64   "cmovb"
    data     u64   "cmovae"
    data     u64   "cmovz"
    data     u64   "cmovnz"
    data     u64   "cmovbe"
    data     u64   "cmova"
    data     u64   "cmovs"
    data     u64   "cmovns"
    data     u64   "cmovp"
    data     u64   "cmovnp"
    data     u64   "cmovl"
    data     u64   "cmovge"
    data     u64   "cmovle"
    data     u64   "cmovg"
    istatic  u8:16 cmovcccodes 
    data     u8    0 
    data     u8    1 
    data     u8    2 
    data     u8    3 
    data     u8    4 
    data     u8    5 
    data     u8    6 
    data     u8    7 
    data     u8    8 
    data     u8    9 
    data     u8    10 
    data     u8    11 
    data     u8    12 
    data     u8    13 
    data     u8    14 
    data     u8    15 
    istatic  u8:24 reftypenames 
    data     u64   "extern_ref"
    data     u64   "fwd_ref"
    data     u64   "back_ref"
    zstatic  i64   mc_decls.mlabelno 
    zstatic  u8:200 mc_decls.pcltempflags 
    zstatic  u8:1600 mc_decls.pcltemps 
    zstatic  u8:200 mc_decls.pclregs 
    zstatic  u8:200 mc_decls.pcllocs 
    zstatic  u8:200 mc_decls.pclcats 
    zstatic  u8:200 mc_decls.pclcounts 
    zstatic  u8:1600 mc_decls.pclopnds 
    zstatic  i64   mc_decls.noperands 
    zstatic  i64   mc_decls.mstackdepth 
    zstatic  i64   mc_decls.retindex 
    istatic  u8:104 mc_decls.locnames 
    data     u64   "no_loc"
    data     u64   "reg_loc"
    data     u64   "xreg_loc"
    data     u64   "immd64_loc"
    data     u64   "immx64_loc"
    data     u64   "immx32_loc"
    data     u64   "memaddr_loc"
    data     u64   "label_loc"
    data     u64   "mem_loc"
    data     u64   "ilabel_loc"
    data     u64   "temp_loc"
    data     u64   "regvar_loc"
    data     u64   "xregvar_loc"
    zstatic  u8:16 mc_decls.regset 
    zstatic  u8:16 mc_decls.xregset 
    zstatic  u8:16 mc_decls.isregvar 
    zstatic  u8:16 mc_decls.isxregvar 
    zstatic  i64   mc_decls.maxpclstack 
    zstatic  i64   mc_decls.inf_proccalls 
    zstatic  i64   mc_decls.inf_proclocals 
    zstatic  i64   mc_decls.inf_procxlocals 
    zstatic  i64   mc_decls.inf_leafproc 
    zstatic  i64   mc_decls.inf_highreg 
    zstatic  i64   mc_decls.inf_highxreg 
    zstatic  i64   mc_decls.inf_maxargs 
    zstatic  i64   inf_assem 
    zstatic  i64   mc_decls.inf_r10used 
    zstatic  i64   mc_decls.inf_r11used 
    zstatic  i64   mc_decls.inf_r13used 
    zstatic  u8:128 mc_decls.dsaveregs 
    zstatic  u8:128 mc_decls.xsaveregs 
    zstatic  i64   mc_decls.ndsaveregs 
    zstatic  i64   mc_decls.ndsavepush 
    zstatic  i64   mc_decls.nxsaveregs 
    zstatic  i64   mc_decls.dsaveoffset 
    zstatic  i64   mc_decls.xsaveoffset 
    zstatic  i64   mc_decls.needstackframe 
    zstatic  i64   mc_decls.framebytes 
    zstatic  i64   mc_decls.parambytes 
    zstatic  i64   mc_decls.needshadow48 
    zstatic  i64   mc_decls.needshadow32 
    zstatic  i64   mc_decls.dspillbytes 
    zstatic  i64   mc_decls.xspillbytes 
    zstatic  i64   mc_decls.alignbytes 
    zstatic  i64   mc_decls.localbytes 
    zstatic  i64   mc_decls.shadowbytes 
    zstatic  u8    mc_decls.noxorclear 
    istatic  u8:136 mc_decls.xregnames 
    data     u64   "xnone"
    data     u64   "xr0"
    data     u64   "xr1"
    data     u64   "xr2"
    data     u64   "xr3"
    data     u64   "xr4"
    data     u64   "xr5"
    data     u64   "xr6"
    data     u64   "xr7"
    data     u64   "xr8"
    data     u64   "xr9"
    data     u64   "xr10"
    data     u64   "xr11"
    data     u64   "xr12"
    data     u64   "xr13"
    data     u64   "xr14"
    data     u64   "xr15"
    zstatic  u64   mc_decls.procdef 
    zstatic  u8:256 mc_decls.paramdefs 
    zstatic  u8:2048 mc_decls.localdefs 
    zstatic  i64   mc_decls.nparams 
    zstatic  i64   mc_decls.nlocals 
    zstatic  i64   mc_decls.retmode 
    zstatic  i64   mc_decls.passno 
    zstatic  i64   mc_decls.sa_nargs 
    istatic  u8:48 mc_decls.multregs 
    data     u64   1 
    data     u64   2 
    data     u64   3 
    data     u64   11 
    data     u64   12 
    data     u64   13 
    istatic  u8:48 mc_decls.multxregs 
    data     u64   1 
    data     u64   2 
    data     u64   3 
    data     u64   4 
    data     u64   5 
    data     u64   6 
    zstatic  i64   mc_decls.paramoffset 
    zstatic  i64   mc_decls.lababs32 
    zstatic  i64   mc_decls.lababs64 
    zstatic  i64   mc_decls.labneg32 
    zstatic  i64   mc_decls.labneg64 
    zstatic  i64   mc_decls.labmask63 
    zstatic  i64   mc_decls.laboffset64 
    zstatic  i64   mc_decls.labzero 
    zstatic  i64   mc_decls.stackaligned 
    zstatic  u64   mccode 
    zstatic  u64   mccodex 
    istatic  i64   mc_decls.currsegment 
    data     u64   0 
    istatic  i64   mc_decls.currzdataalign 
    data     u64   0 
    istatic  i64   mc_decls.curridataalign 
    data     u64   0 
    zstatic  i64   mc_decls.frameoffset 
    zstatic  i64   mc_decls.isthreadedproc 
    zstatic  i64   mc_decls.structretoffset 
    zstatic  u64   mc_decls.stacksetinstr 
    zstatic  i64   mc_decls.currblocksize 
    zstatic  u64   mc_decls.allasmstr 
    zstatic  i64   mc_decls.allasmstrlen 
    zstatic  u64   mc_decls.dstackopnd 
    zstatic  u64   mc_decls.distackopnd 
    zstatic  u64   mc_decls.dframeopnd 
    istatic  u64   mc_decls.zero_opnd 
    data     u64   0 
    zstatic  u8:1024 mc_decls.regtable 
    zstatic  u8:1544 mc_decls.frameregtable 
    zstatic  i64   mc_decls.destlinestart 
    zstatic  u64   mc_decls.currasmproc 
    zstatic  i64   mc_decls.noregvar 
    zstatic  i64   mc_decls.ss_zdatalen 
    zstatic  u64   mc_decls.ss_zdata 
    zstatic  u64   mc_decls.ss_idata 
    zstatic  u64   mc_decls.ss_code 
    zstatic  u64   mc_decls.ss_idatarelocs 
    zstatic  u64   mc_decls.ss_coderelocs 
    zstatic  i64   mc_decls.ss_nidatarelocs 
    zstatic  i64   mc_decls.ss_ncoderelocs 
    zstatic  u64   mc_decls.ss_symboltable 
    zstatic  i64   mc_decls.ss_nsymbols 
    zstatic  i64   mc_decls.ss_symboltablesize 
    zstatic  u64   mc_decls.labeldeftable 
    zstatic  i64   mc_decls.alineno 
    istatic  u8:40 segmentnames 
    data     u64   "code"
    data     u64   "idata"
    data     u64   "zdata"
    data     u64   "rodata"
    data     u64   "impdata_seg"
    istatic  u8:32 mc_decls.loadnames 
    data     u64   "load_op"
    data     u64   "get_op"
    data     u64   "loadref_op"
    data     u64   "getref_op"
    zstatic  i64   msys.fmtparam 
    zstatic  i64   $cmdskip 
    istatic  i64   msys.needgap 
    data     u64   0 
    istatic  i64   msys.outdev 
    data     u64   1 
    istatic  u64   msys.outchan 
    data     u64   0 
    istatic  u64   msys.fmtstr 
    data     u64   0 
    zstatic  u8:80 msys.outchan_stack 
    zstatic  u8:80 msys.outdev_stack 
    zstatic  u8:80 msys.fmtstr_stack 
    zstatic  u8:10 msys.needgap_stack 
    zstatic  u8:80 msys.ptr_stack 
    istatic  i64   msys.niostack 
    data     u64   0 
    istatic  u8:16 msys.digits 
    data     u8    48 
    data     u8    49 
    data     u8    50 
    data     u8    51 
    data     u8    52 
    data     u8    53 
    data     u8    54 
    data     u8    55 
    data     u8    56 
    data     u8    57 
    data     u8    65 
    data     u8    66 
    data     u8    67 
    data     u8    68 
    data     u8    69 
    data     u8    70 
    istatic  u8:16 msys.defaultfmt 
    data     u8    0 
    data     u8    0 
    data     u8    10 
    data     u8    0 
    data     u8    32 
    data     u8    102 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    82 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    data     u8    0 
    zstatic  u64   msys.rd_buffer 
    zstatic  i64   msys.rd_length 
    zstatic  u64   msys.rd_pos 
    zstatic  u64   msys.rd_lastpos 
    zstatic  i64   msys.termchar 
    zstatic  i64   msys.itemerror 
    zstatic  u8:4096 msys.printbuffer 
    zstatic  u64   msys.printptr 
    zstatic  i64   msys.printlen 
    zstatic  i64   msys.nsysparams 
    zstatic  i64   msys.ncmdparams 
    zstatic  i64   msys.nenvstrings 
    zstatic  u8:1024 msys.sysparams 
    zstatic  u64   msys.cmdparams 
    zstatic  u64   msys.envstrings 
    zstatic  u8:576 msys.callbackstack 
    istatic  i64   msys.ncallbacks 
    data     u64   0 
    istatic  u64   msys.mask63 
    data     u64   9223372036854775807 
    istatic  r64   msys.offset64 
    data     r64   9223372036854775800.00000000000000000000 
    istatic  r64   msys.offset32 
    data     r64   9223372036854775800.00000000000000000000 
    zstatic  u8:128 msys.start.startupinfo 
    zstatic  u8:16 msys.getfmt.fmt 
    zstatic  u8:100 msys.strint.str 
    zstatic  u8:100 msys.strword.str 
    zstatic  u8:320 msys.strreal.str 
    zstatic  u8:2408 mlib.allocupper 
    zstatic  i64   mlib.alloccode 
    zstatic  i64   mlib.allocbytes 
    istatic  i64   mlib.fdebug 
    data     u64   0 
    zstatic  i64   mlib.rfsize 
    zstatic  u64   mlib.maxmemory 
    zstatic  i64   mlib.maxalloccode 
    zstatic  u64   mlib.allocbase 
    istatic  u8    mlib.pcm_setup 
    data     u8    0 
    istatic  i64   mlib.show 
    data     u64   0 
    istatic  i64   mlib.memtotal 
    data     u64   0 
    istatic  i64   mlib.smallmemtotal 
    data     u64   0 
    istatic  i64   mlib.smallmemobjs 
    data     u64   0 
    istatic  i64   mlib.maxmemtotal 
    data     u64   0 
    zstatic  u8:24 mlib.memalloctable 
    zstatic  u8:12 mlib.memallocsize 
    zstatic  u64   mlib.pcheapstart 
    zstatic  u64   mlib.pcheapend 
    zstatic  u64   mlib.pcheapptr 
    zstatic  u8:2049 mlib.sizeindextable 
    zstatic  u8:72 mlib.freelist 
    istatic  u8:48 mlib.pmnames 
    data     u64   "pm_end"
    data     u64   "pm_option"
    data     u64   "pm_sourcefile"
    data     u64   "pm_libfile"
    data     u64   "pm_colon"
    data     u64   "pm_extra"
    istatic  u8:16 mlib.seed 
    data     u64   2993073034246558322 
    data     u64   1617678968452121188 
    zstatic  i64   mlib.pcm_newblock.totalheapsize 
    istatic  u8:36 mlib.pcm_round.allocbytes 
    data     u32   0 
    data     u32   16 
    data     u32   32 
    data     u32   64 
    data     u32   128 
    data     u32   256 
    data     u32   512 
    data     u32   1024 
    data     u32   2048 
    zstatic  u8:260 mlib.changeext.newfile 
    zstatic  u8:260 mlib.extractpath.str 
    zstatic  u8:100 mlib.extractbasefile.str 
    istatic  i64   mlib.nextcmdparamnew.infile 
    data     u64   0 
    istatic  u64   mlib.nextcmdparamnew.filestart 
    data     u64   0 
    istatic  u64   mlib.nextcmdparamnew.fileptr 
    data     u64   0 
    istatic  u8    mlib.nextcmdparamnew.colonseen 
    data     u8    0 
    zstatic  i64   mlib.nextcmdparamnew.atsize 
    zstatic  u8:300 mlib.nextcmdparamnew.str 
    zstatic  u8:256 mlib.readnextfileitem.str 
    zstatic  u8:256 mlib.padstr.str 
    zstatic  u64   mlib.chr.str 
    zstatic  u64   mwindows.hconsole 
    zstatic  u64   mwindows.hconsolein 
    zstatic  u8:20 mwindows.lastkey 
    zstatic  u8:20 mwindows.pendkey 
    zstatic  i64   mwindows.keypending 
    istatic  u64   mwindows.wndproc_callbackfn 
    data     u64   0 
    istatic  i64   mwindows.init_flag 
    data     u64   0 
    zstatic  u8    mwindows.os_gxregisterclass.registered 
    istatic  i64   mwindows.mainwndproc.count 
    data     u64   0 
    zstatic  u8:300 mwindows.os_gethostname.name 
    zstatic  i64   mwindows.os_gethostname.n 
    zstatic  i64   mwindows.os_peek.lastticks 
    zstatic  u8    mm_cli.fmodinfo 
    zstatic  u64   mm_cli.projectmodule 
    istatic  u8:520 mm_cli.optionnames 
    data     u64   "header"
    data     u64   "load"
    data     u64   "fixup"
    data     u64   "parse"
    data     u64   "name"
    data     u64   "type"
    data     u64   "dparse"
    data     u64   "dname"
    data     u64   "dtype"
    data     u64   "pcl"
    data     u64   "dpcl"
    data     u64   "asm"
    data     u64   "c"
    data     u64   "mcl"
    data     u64   "obj"
    data     u64   "mx"
    data     u64   "ml"
    data     u64   "exe"
    data     u64   "mexe"
    data     u64   "run"
    data     u64   "sys"
    data     u64   "minsys"
    data     u64   "nosys"
    data     u64   "minos"
    data     u64   "nofile"
    data     u64   "gcc"
    data     u64   "tcc"
    data     u64   "tc"
    data     u64   "bcc"
    data     u64   "ma"
    data     u64   "mas"
    data     u64   "docs"
    data     u64   "exp"
    data     u64   "lib"
    data     u64   "opt"
    data     u64   "opt1"
    data     u64   "opt2"
    data     u64   "ast1"
    data     u64   "ast2"
    data     u64   "ast3"
    data     u64   "showmx"
    data     u64   "showasm"
    data     u64   "showpcl"
    data     u64   "st"
    data     u64   "stflat"
    data     u64   "types"
    data     u64   "overloads"
    data     u64   "ss"
    data     u64   "modules"
    data     u64   "shortnames"
    data     u64   "modinfo"
    data     u64   "funtab"
    data     u64   "time"
    data     u64   "v"
    data     u64   "vv"
    data     u64   "q"
    data     u64   "h"
    data     u64   "help"
    data     u64   "ext"
    data     u64   "out"
    data     u64   "outpath"
    data     u64   "unused"
    data     u64   "set"
    data     u64   "linux"
    data     u64   "nowindll"
    zstatic  u8    mm_cli.fasmexe 
    istatic  u64   mm_cli.outext 
    data     u64   ""
    zstatic  i64   mm_cli.startclock 
    zstatic  i64   mm_cli.endclock 
    zstatic  i64   mm_cli.rpclock 
    zstatic  u8    mm_cli.msfile 
    zstatic  u64   mm_cli.inputfile 
    zstatic  u8    mm_cli.do_option.outused 
    zstatic  u8    mm_cli.do_option.outpathused 
    istatic  u64   mm_cli.showhelp.helptext 
    data     u64   "M Compiler Generating x64 native code - Windows Version\n\nWhole-program compiler builds entire program from the lead module\ninto a executable file.\n\n    mm main              # Create main.exe from lead module main.m\n    mm main.m            # Same (.m extension is default)\n    mm -c main           # Create single-file main.asm intermediate ASM\n\nOptions:\n\n    -exe                 # Generate .exe executable file (default)\n    -dll                 # Generate .dll library and .exp file\n    -pcl                 # Generate intermediate PCL file only\n    -asm                 # Generate intermediate ASM file only\n\n    -opt                 # Apply simple optimiser\n\n    -out:file            # Name of output file \n\n    -ma                  # Create .ma file combining source/support files\n    -docs                # Create .txt with docstrings of exported files (not finished)\n    -run                 # For -exe mode only: run resulting executable\n\n    @file                # Read options from file\n\nExample:\n\n     mm -run prog : abc def\n\nAny parameters for the new program must follow \" : \" (spaces needed).\n"
    istatic  u8:48 mm_cli.initassemsymbols.regnames 
    data     u64   "aframe"
    data     u64   "dframe"
    data     u64   "astack"
    data     u64   "dstack"
    data     u64   "dprog"
    data     u64   "dsptr"
    istatic  u8:6  mm_cli.initassemsymbols.regnos 
    data     u8    15 
    data     u8    15 
    data     u8    16 
    data     u8    16 
    data     u8    9 
    data     u8    10 
    istatic  u8:6  mm_cli.initassemsymbols.sizes 
    data     u8    4 
    data     u8    8 
    data     u8    4 
    data     u8    8 
    data     u8    8 
    data     u8    8 
proc mm_assem.readassemline
    rettype  u64   
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_assem.assembleline 1 0
    setret   u64   
    jump           #1469 
;------------------------
#1469:
    return         
end

proc mm_assem.readassemblock
    rettype  u64   
    local    u64   .ulist 
    local    u64   .ulistx 
    local    u64   .u 
;------------------------
    loadimm  u64   0 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
#1471:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   67 
    jumpeq   i64   #1474 1
    loadimm  i64   104 
    jumpeq   i64   #1475 1
    loadimm  i64   6 
    jumpeq   i64   #1476 
    jump           #1477 
#1474:
    setcall        1
    loadimm  u64   "EOF: 'End' missing in Assembler code"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #1473 
#1475:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   161 
    setarg   i64   2
    loadref  u64   mm_decls.lx 
    iload    u8    
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #1472 
    jump           #1473 
#1476:
    jump           #1473 
#1477:
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_assem.assembleline 1 0
    store    u64   .u 
    setcall        3
    load     u64   .u 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#1473:
    jump           #1471 
#1472:
    setcall        1
    load     u64   .ulist 
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    setret   u64   
    jump           #1470 
;------------------------
#1470:
    return         
end

proc mm_assem.assembleline
    rettype  u64   
    param    i64   .oneline 
    local    u64   .dlist 
    local    u64   .dlistx 
    local    u64   .p 
    local    u64   .pname 
    local    u64   .q 
    local    u64   .name 
    local    i64   .opc 
    local    i64   .noperands 
    local    u64   .stname 
;------------------------
    loadimm  u64   0 
    double         
    store    u64   .dlistx 
    store    u64   .dlist 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #1481 
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   7 
    jumpeq   i64   #1482 1
    loadimm  i64   8 
    jumpne   i64   #1481 
#1482:
    setcall        1
    loadimm  i64   100 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    setcall        3
    loadimm  i64   17 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    load     u64   .stname 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .oneline 
    jumpf    i64   #1484 
    setcall        0
    callp          mm_lex.lex 0 0
#1484:
#1483:
    load     u64   .p 
    setret   u64   
    jump           #1479 
    jump           #1480 
#1481:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   33 
    jumpne   i64   #1485 
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    store    u64   .pname 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    load     u64   .pname 
    loadimm  i64   4 
    istorex  u32   1 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpeq   i64   #1487 
#1488:
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    loadref  u64   .dlistx 
    setarg   u64   2
    loadref  u64   .dlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #1492 
    setcall        0
    callp          mm_lex.lex 0 0
#1492:
#1491:
#1489:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpeq   i64   #1493 1
    loadimm  i64   67 
    jumpne   i64   #1488 
#1493:
#1490:
#1487:
#1486:
    setcall        3
    load     u64   .dlist 
    setarg   u64   3
    load     u64   .pname 
    setarg   u64   2
    loadimm  i64   6 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    setret   u64   
    jump           #1479 
#1485:
#1480:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   45 
    jumpeq   i64   #1495 1
    loadimm  i64   46 
    jumpeq   i64   #1496 1
    loadimm  i64   47 
    jumpeq   i64   #1497 1
    loadimm  i64   55 
    jumpeq   i64   #1498 1
    loadimm  i64   129 
    jumpeq   i64   #1499 
    jump           #1500 
#1495:
    loadimm  i64   40 
    store    i64   .opc 
;doop::
#1501:
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    load     i64   .opc 
    load     u64   .p 
    loadimm  i64   40 
    istorex  i16   1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #1494 
#1496:
    loadimm  i64   41 
    store    i64   .opc 
    jump           #1501 
    jump           #1494 
#1497:
    loadimm  i64   42 
    store    i64   .opc 
    jump           #1501 
    jump           #1494 
#1498:
    loadimm  i64   53 
    store    i64   .opc 
    jump           #1501 
    jump           #1494 
#1499:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpne   i64   #1503 
    loadimm  i64   31 
    store    i64   .opc 
    jump           #1501 
#1503:
#1502:
    jump           #1504 
    unload   u64   
    jump           #1494 
#1500:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #1506 
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   91 
    jumpeq   i64   #1508 1
    loadimm  i64   87 
    jumpeq   i64   #1509 1
    loadimm  i64   88 
    jumpeq   i64   #1510 1
    loadimm  i64   89 
    jumpeq   i64   #1511 
    jump           #1512 
#1508:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  i16   1 0
    jump           #1507 
#1509:
    loadimm  i64   28 
    load     u64   .p 
    loadimm  i64   40 
    istorex  i16   1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   45 
    istorex  u8    1 0
    jump           #1507 
#1510:
    loadimm  i64   60 
    load     u64   .p 
    loadimm  i64   40 
    istorex  i16   1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   45 
    istorex  u8    1 0
    jump           #1507 
#1511:
    loadimm  i64   17 
    load     u64   .p 
    loadimm  i64   40 
    istorex  i16   1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   45 
    istorex  u8    1 0
    jump           #1507 
#1512:
    setcall        1
    loadimm  u64   "ASM"
    setarg   u64   1
    callp          mm_lex.ps 1 0
    setcall        1
    loadimm  u64   "x64 op expected"
    setarg   u64   1
    callp          mm_support.serror 1 0
#1507:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #1505 
#1506:
;$else::
#1504:
    setcall        1
    loadimm  u64   "ASM"
    setarg   u64   1
    callp          mm_lex.ps 1 0
    setcall        1
    loadimm  u64   "ASM???"
    setarg   u64   1
    callp          mm_support.serror 1 0
#1505:
#1494:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpeq   i64   #1518 1
    loadimm  i64   67 
    jumpeq   i64   #1518 
    loadimm  i64   0 
    store    i64   .noperands 
#1519:
    setcall        0
    callf    u64   mm_assem.readassemopnd 0 0
    store    u64   .q 
    loadref  u64   .noperands 
    incrload i64   1
    loadimm  i64   3 
    jumpgt   i64   #1522 
    load     u64   .q 
    load     u64   .p 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .noperands 
    istorex  u64   8 -8
    jump           #1521 
#1522:
    setcall        1
    loadimm  u64   "Too many asm opnds"
    setarg   u64   1
    callp          mm_support.serror 1 0
#1521:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #1525 
    jump           #1520 
    jump           #1524 
#1525:
    setcall        0
    callp          mm_lex.lex 0 0
#1524:
    jump           #1519 
#1520:
#1518:
#1517:
    setcall        1
    loadimm  i64   6 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    load     u64   .p 
    setret   u64   
    jump           #1479 
;------------------------
#1479:
    return         
end

proc mm_assem.readassemopnd
    rettype  u64   
    local    u64   .p 
    local    i64   .reg 
    local    i64   .regix 
    local    i64   .scale 
    local    i64   .prefixmode 
    local    u64   .pcode 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   71 
    jumpeq   i64   #1528 1
    loadimm  i64   73 
    jumpeq   i64   #1528 1
    loadimm  i64   80 
    jumpeq   i64   #1529 1
    loadimm  i64   31 
    jumpeq   i64   #1530 1
    loadimm  i64   32 
    jumpeq   i64   #1530 1
    loadimm  i64   92 
    jumpeq   i64   #1531 1
    loadimm  i64   15 
    jumpeq   i64   #1532 
    jump           #1533 
#1528:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setret   u64   
    jump           #1526 
    jump           #1527 
#1529:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   71 
    iloadx   u8    1 0
    loadimm  i64   83 
    jumpeq   i64   #1535 1
    loadimm  i64   84 
    jumpeq   i64   #1536 
    jump           #1537 
#1535:
    setcall        1
    loadimm  i64   7 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  i32   1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   158 
    iloadx   i16   1 0
    load     u64   .p 
    loadimm  i64   44 
    istorex  u8    1 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #1526 
    jump           #1534 
#1536:
    setcall        1
    loadimm  i64   8 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  i32   1 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #1526 
    jump           #1534 
#1537:
#1534:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setret   u64   
    jump           #1526 
    jump           #1527 
#1530:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setret   u64   
    jump           #1526 
    jump           #1527 
#1531:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   18 
    jumpeq   i64   #1539 1
    loadimm  i64   19 
    jumpeq   i64   #1539 1
    loadimm  i64   20 
    jumpeq   i64   #1539 1
    loadimm  i64   2 
    jumpeq   i64   #1539 
    jump           #1540 
#1539:
    jump           #1538 
#1540:
    setcall        1
    loadimm  u64   "Bad prefix"
    setarg   u64   1
    callp          mm_support.serror 1 0
#1538:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .prefixmode 
    setcall        1
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    jump           #1542 
    jump           #1527 
#1532:
    loadimm  i64   0 
    store    i64   .prefixmode 
;gotprefix::
#1542:
    loadimm  i64   0 
    double         
    store    i64   .regix 
    store    i64   .reg 
    loadimm  u64   0 
    store    u64   .pcode 
    loadimm  i64   1 
    store    i64   .scale 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #1544 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   71 
    iloadx   u8    1 0
    loadimm  i64   83 
    jumpne   i64   #1544 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    store    i64   .reg 
    setcall        0
    callp          mm_lex.lex 0 0
#1544:
#1543:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   31 
    jumpne   i64   #1546 
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #1546 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   71 
    iloadx   u8    1 0
    loadimm  i64   83 
    jumpne   i64   #1546 
    setcall        0
    callp          mm_lex.lex 0 0
#1546:
#1545:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #1548 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   71 
    iloadx   u8    1 0
    loadimm  i64   83 
    jumpne   i64   #1548 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    store    i64   .regix 
    setcall        0
    callp          mm_lex.lex 0 0
#1548:
#1547:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   33 
    jumpne   i64   #1550 
    setcall        1
    loadimm  i64   71 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   i64   1 0
    double         
    store    i64   .scale 
    loadimm  i64   1 
    jumpeq   i64   #1552 1
    loadimm  i64   2 
    jumpeq   i64   #1552 1
    loadimm  i64   4 
    jumpeq   i64   #1552 1
    loadimm  i64   8 
    jumpeq   i64   #1552 
    jump           #1553 
#1552:
    jump           #1551 
#1553:
    setcall        1
    loadimm  u64   "Bad scale"
    setarg   u64   1
    callp          mm_support.serror 1 0
#1551:
    setcall        0
    callp          mm_lex.lex 0 0
#1550:
#1549:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   31 
    jumpeq   i64   #1556 1
    loadimm  i64   32 
    jumpeq   i64   #1556 1
    loadimm  i64   71 
    jumpeq   i64   #1556 1
    loadimm  i64   80 
    jumpeq   i64   #1556 1
    loadimm  i64   13 
    jumpeq   i64   #1556 1
    loadimm  i64   162 
    jumpeq   i64   #1556 
    jump           #1557 
#1556:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pcode 
    jump           #1555 
#1557:
#1555:
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    load     u64   .pcode 
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     i64   .regix 
    loadimm  i64   0 
    jumpne   i64   #1559 
    load     i64   .scale 
    loadimm  i64   1 
    jumple   i64   #1559 
    load     i64   .reg 
    store    i64   .regix 
    loadimm  i64   0 
    store    i64   .reg 
#1559:
#1558:
    load     u64   .pcode 
    loadimm  u64   0 
    jumpne   u64   #1561 
    load     i64   .reg 
    load     i64   .regix 
    add      i64   
    loadimm  i64   0 
    jumpne   i64   #1561 
    setcall        1
    loadimm  u64   "Empty []"
    setarg   u64   1
    callp          mm_support.serror 1 0
#1561:
#1560:
    load     i64   .reg 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u8    1 0
    load     i64   .regix 
    load     u64   .p 
    loadimm  i64   41 
    istorex  u8    1 0
    load     i64   .scale 
    load     u64   .p 
    loadimm  i64   42 
    istorex  u8    1 0
    load     i64   .prefixmode 
    load     u64   .p 
    loadimm  i64   43 
    istorex  u8    1 0
    load     u64   .p 
    setret   u64   
    jump           #1526 
    jump           #1527 
#1533:
    setcall        1
    loadimm  u64   "BAD OPND"
    setarg   u64   1
    callp          mm_lex.ps 1 0
    setcall        1
    loadimm  u64   "ASM: Bad operand?"
    setarg   u64   1
    callp          mm_support.serror 1 0
#1527:
    loadimm  u64   0 
    setret   u64   
    jump           #1526 
;------------------------
#1526:
    return         
end

proc mm_blockpcl.evalunit
    param    u64   .p 
    local    u64   .fnptr 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #1567 
    jump           #1565 
#1567:
#1566:
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    loadref  u64   mm_blockpcl.handlertable 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    store    u64   .fnptr 
    setcall        4
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    setarg   u64   4
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   3
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    load     u64   .fnptr 
    icallp         4 0
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpeq   i64   #1569 
    load     u64   .p 
    loadimm  i64   60 
    iloadx   u8    1 0
    jumpt    i64   #1569 
    load     u64   .p 
    iload    u8    
    loadimm  i64   24 
    jumpeq   i64   #1571 1
    loadimm  i64   88 
    jumpeq   i64   #1571 1
    loadimm  i64   90 
    jumpeq   i64   #1571 1
    loadimm  i64   26 
    jumpeq   i64   #1571 
    jump           #1572 
#1571:
    jump           #1570 
#1572:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   28 
    jumpne   i64   #1574 
    loadimm  i64   1 
    store    i64   .i 
    loadref  u64   mm_decls.ttlength 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #1577 
#1575:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   22 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadref  u64   mm_decls.ttmult 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u64   8 0
    load     i64   .i 
    iloadx   i32   4 -4
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#1576:
    forup          #1575 1
    opnd           .i 
    opnd           .$av_1 
#1577:
    jump           #1573 
#1574:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   22 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
#1573:
#1570:
#1569:
#1568:
;------------------------
#1565:
    return         
end

proc mm_blockpcl.evalunitx
    param    u64   .p 
    param    i64   .isref 
;------------------------
    load     i64   .isref 
    jumpf    i64   #1580 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    jump           #1579 
#1580:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
#1579:
;------------------------
#1578:
    return         
end

proc mm_blockpcl.evalref
    param    u64   .p 
    local    u64   .a 
    local    u64   .b 
    local    u64   .c 
    local    i64   .oldisref 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .b 
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .c 
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    load     u64   .p 
    iload    u8    
    switch         #1583 3 48
    opnd           #1584 
#1583:
    swlabel        #1585 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1586 
    swlabel        #1584 
    swlabel        #1587 
    swlabel        #1584 
    swlabel        #1584 
    swlabel        #1588 
    endsw          
#1585:
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   19 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #1582 
#1586:
    setcall        4
    load     u64   .c 
    setarg   u64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.do_indexref 4 0
    jump           #1582 
#1587:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.do_dotref 1 0
    jump           #1582 
#1588:
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    jump           #1582 
#1584:
    load     u64   .p 
    iload    u8    
    loadimm  i64   92 
    jumpeq   i64   #1590 
    jump           #1591 
#1590:
    load     u64   .p 
    loadimm  i64   3 
    iloadx   u8    1 0
    loadimm  i64   0 
    loadbit        
    store    i64   .oldisref 
    loadimm  u64   1 
    load     u64   .p 
    loadimm  i64   3 
    addptrx  u64   1 0
    loadimm  i64   0 
    storebit       
    setcall        4
    load     u64   .c 
    setarg   u64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.dx_if 4 0
    load     i64   .oldisref 
    load     u64   .p 
    loadimm  i64   3 
    addptrx  u64   1 0
    loadimm  i64   0 
    storebit       
    jump           #1589 
#1591:
    setcall        4
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   "*"
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_diags.printunit 4 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "evalref"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1589:
#1582:
;------------------------
#1581:
    return         
end

proc mm_blockpcl.pushunit
    param    u64   .p 
;------------------------
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    loadref  u64   mc_decls.mstackdepth 
    incrto   i64   1
;------------------------
#1594:
    return         
end

proc mm_blockpcl.start
    local    u64   .name 
    local    i64   .$av_1 
    local    i64   .$av_2 
    local    i64   .$av_3 
    local    i64   .$av_4 
    local    i64   .i 
    local    i64   .k 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
;SYSCALL
    load     i64   $nprocs 
    store    i64   .$av_2 
    load     i64   .$av_2 
    loadimm  i64   1 
    jumplt   i64   #1598 
#1596:
;SYSCALL
    loadref  u64   $procname 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .name 
    setcall        3
    loadimm  i64   3 
    setarg   i64   3
    loadimm  u64   "dx_"
    setarg   u64   2
    load     u64   .name 
    setarg   u64   1
    callf    i64   mlib.eqbytes 3 0
    jumpf    i64   #1600 
    loadimm  i64   0 
    store    i64   .k 
#1602:
    setcall        2
    loadref  u64   mm_tables.jtagnames 
    load     i64   .k 
    iloadx   u64   8 0
    loadimm  i64   1 
    addptrx  u64   1 0
    setarg   u64   2
    load     u64   .name 
    loadimm  i64   3 
    addptrx  u64   1 0
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #1607 
;SYSCALL
    loadref  u64   $procaddr 
    load     i64   .i 
    iloadx   u64   8 -8
    loadref  u64   mm_blockpcl.handlertable 
    load     i64   .k 
    istorex  u64   8 0
    jump           #1604 
#1607:
#1606:
#1603:
    forup          #1602 1
    opnd           .k 
    opnd           127 
#1605:
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    load     u64   .name 
    setarg   u64   2
    loadimm  u64   "Unknown handler: #"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#1604:
#1600:
#1599:
#1597:
    forup          #1596 1
    opnd           .i 
    opnd           .$av_2 
#1598:
    loadimm  i64   1 
    store    i64   .i 
#1610:
    loadref  u64   mm_blockpcl.handlertable 
    loadref  u64   mm_blockpcl.start.dupltable 
    load     i64   .i 
    addptrx  u16   2 -2
    loadimm  i64   2 
    iloadx   u8    1 -1
    iloadx   u64   8 0
    loadref  u64   mm_blockpcl.handlertable 
    loadref  u64   mm_blockpcl.start.dupltable 
    load     i64   .i 
    addptrx  u16   2 -2
    loadimm  i64   1 
    iloadx   u8    1 -1
    istorex  u64   8 0
#1611:
    forup          #1610 1
    opnd           .i 
    opnd           11 
#1612:
    loadimm  i64   0 
    store    i64   .i 
#1613:
    loadref  u64   mm_blockpcl.handlertable 
    load     i64   .i 
    iloadx   u64   8 0
    loadimm  u64   0 
    jumpne   u64   #1617 
    loadref  u64   mm_blockpcl.unimpl 
    loadref  u64   mm_blockpcl.handlertable 
    load     i64   .i 
    istorex  u64   8 0
#1617:
#1616:
#1614:
    forup          #1613 1
    opnd           .i 
    opnd           127 
#1615:
;------------------------
#1595:
    return         
end

;
proc mm_blockpcl.unimpl
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    loadref  u64   mm_tables.jtagnames 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    setarg   u64   2
    loadimm  u64   "No DX handler for "
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
;------------------------
#1618:
    return         
end

proc mm_blockpcl.dx_block
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    jump           #1624 
#1621:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
#1622:
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .a 
#1624:
    load     u64   .a 
    jumpt    u64   #1621 
#1623:
;------------------------
#1620:
    return         
end

proc mm_blockpcl.dx_eval
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   22 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1625:
    return         
end

proc mm_blockpcl.dx_const
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .mode 
    local    u64   .px 
;------------------------
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .mode 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .mode 
    iloadx   u8    1 0
    jumpt    i64   #1629 
    load     i64   .mode 
    loadimm  i64   6 
    jumpne   i64   #1628 
#1629:
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    jump           #1627 
#1628:
    loadref  u64   mm_decls.ttisreal 
    load     i64   .mode 
    iloadx   u8    1 0
    jumpf    i64   #1630 
    setcall        2
    setcall        2
    loadimm  i64   5 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   r64   1 0
    setarg   r64   1
    callf    u64   mm_libpcl.genrealimm 2 0
    setarg   u64   2
    loadimm  i64   20 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #1627 
#1630:
    loadref  u64   mm_decls.ttisref 
    load     i64   .mode 
    iloadx   u8    1 0
    jumpf    i64   #1631 
    load     u64   .p 
    loadimm  i64   44 
    iloadx   u8    1 0
    jumpf    i64   #1633 
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genstring 1 0
    setarg   u64   2
    loadimm  i64   20 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #1632 
#1633:
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
#1632:
    jump           #1627 
#1631:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "do_const"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1627:
    setcall        1
    load     i64   .mode 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#1626:
    return         
end

proc mm_blockpcl.dx_name
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u64   .d 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpeq   i64   #1637 1
    loadimm  i64   7 
    jumpeq   i64   #1637 1
    loadimm  i64   17 
    jumpeq   i64   #1638 
    jump           #1639 
#1637:
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   19 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #1636 
#1638:
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #1641 
    loadref  u64   mc_decls.mlabelno 
    incrload i64   1
    load     u64   .d 
    loadimm  i64   72 
    istorex  i32   1 0
#1641:
#1640:
    load     u64   .p 
    loadimm  i64   60 
    iloadx   u8    1 0
    jumpf    i64   #1643 
    setcall        2
    setcall        1
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   19 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #1642 
#1643:
    setcall        1
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
#1642:
    loadimm  i64   2 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #1636 
#1639:
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   18 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#1636:
;------------------------
#1635:
    return         
end

proc mm_blockpcl.genjumpl
    param    i64   .lab 
;------------------------
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   44 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#1644:
    return         
end

proc mm_blockpcl.dx_bin
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .offset 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   175 
    jumpeq   i64   #1647 
    jump           #1648 
#1647:
    loadimm  i64   67 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #1646 
#1648:
#1646:
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   31 
    jumpeq   i64   #1651 1
    loadimm  i64   32 
    jumpeq   i64   #1651 1
    loadimm  i64   33 
    jumpne   i64   #1650 
#1651:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    iloadx   u32   4 0
    setarg   i64   1
    callf    u64   mm_libpcl.genscaleoffset 2 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   24 
    istorex  u8    1 0
#1650:
#1649:
;------------------------
#1645:
    return         
end

proc mm_blockpcl.dx_binto
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   176 
    jumpne   i64   #1654 
    loadimm  i64   88 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
#1654:
#1653:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   97 
    jumpeq   i64   #1656 1
    loadimm  i64   98 
    jumpeq   i64   #1656 
    jump           #1657 
#1656:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    iloadx   u32   4 0
    setarg   i64   1
    callf    u64   mm_libpcl.genscaleoffset 2 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   8 
    istorex  u64   1 0
    jump           #1655 
#1657:
#1655:
;------------------------
#1652:
    return         
end

proc mm_blockpcl.dx_unary
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1658:
    return         
end

proc mm_blockpcl.dx_unaryto
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1659:
    return         
end

proc mm_blockpcl.dx_maths
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1660:
    return         
end

proc mm_blockpcl.dx_maths2
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1661:
    return         
end

proc mm_blockpcl.dx_labeldef
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u64   .d 
    local    u8:256 .str 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #1664 
    loadref  u64   mc_decls.mlabelno 
    incrload i64   1
    load     u64   .d 
    loadimm  i64   72 
    istorex  i32   1 0
#1664:
#1663:
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .d 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   "::"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        2
    setcall        1
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   145 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#1662:
    return         
end

proc mm_blockpcl.dx_goto
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u64   .ax 
    local    u64   .d 
;------------------------
    load     u64   .a 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #1668 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   17 
    jumpne   i64   #1668 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #1670 
    loadref  u64   mc_decls.mlabelno 
    incrload i64   1
    load     u64   .d 
    loadimm  i64   72 
    istorex  i32   1 0
#1670:
#1669:
    setcall        2
    setcall        1
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   44 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #1667 
#1668:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   45 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1667:
;------------------------
#1666:
    return         
end

proc mm_blockpcl.docond
    param    i64   .opc 
    param    u64   .p 
    param    i64   .lab 
;------------------------
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .p 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
;------------------------
#1671:
    return         
end

proc mm_blockpcl.genjumpcond
    param    i64   .opc 
    param    u64   .p 
    param    i64   .lab 
    local    u64   .q 
    local    u64   .r 
    local    u64   .s 
    local    u64   .a 
    local    u64   .b 
    local    i64   .lab2 
    local    i64   .i 
    local    i64   .nolab 
    local    u64   .ax 
    local    u64   .bx 
    local    u64   .cx 
    local    u64   .lx 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .r 
    load     u64   .p 
    iload    u8    
    switch         #1674 4 41
    opnd           #1675 
#1674:
    swlabel        #1694 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1676 
    swlabel        #1681 
    swlabel        #1686 
    swlabel        #1691 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1699 
    swlabel        #1720 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1675 
    swlabel        #1700 
    swlabel        #1703 
    endsw          
#1676:
    load     i64   .opc 
    loadimm  i64   53 
    jumpeq   i64   #1678 1
    loadimm  i64   52 
    jumpeq   i64   #1679 
    jump           #1680 
#1678:
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .r 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    jump           #1677 
#1679:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab2 
    setcall        3
    load     i64   .lab2 
    setarg   i64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .r 
    setarg   u64   2
    loadimm  i64   52 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    jump           #1677 
#1680:
#1677:
    jump           #1673 
#1681:
    load     i64   .opc 
    loadimm  i64   53 
    jumpeq   i64   #1683 1
    loadimm  i64   52 
    jumpeq   i64   #1684 
    jump           #1685 
#1683:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab2 
    setcall        3
    load     i64   .lab2 
    setarg   i64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   52 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .r 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    jump           #1682 
#1684:
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   52 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .r 
    setarg   u64   2
    loadimm  i64   52 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    jump           #1682 
#1685:
#1682:
    jump           #1673 
#1686:
    load     i64   .opc 
    loadimm  i64   53 
    jumpeq   i64   #1688 1
    loadimm  i64   52 
    jumpeq   i64   #1689 
    jump           #1690 
#1688:
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   52 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    jump           #1687 
#1689:
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    jump           #1687 
#1690:
#1687:
    jump           #1673 
#1691:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    startmx        
    load     i64   .opc 
    loadimm  i64   52 
    jumpne   i64   #1693 
    loadimm  i64   52 
    resetmx        
    jump           #1692 
#1693:
    loadimm  i64   53 
    endmx          
#1692:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    jump           #1673 
#1694:
    jump           #1696 
#1695:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#1696:
    load     u64   .q 
    jumpf    u64   #1698 
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpt    u64   #1695 
#1698:
#1697:
    setcall        3
    load     i64   .lab 
    setarg   i64   3
    load     u64   .q 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    jump           #1673 
#1699:
    setcall        5
    load     i64   .lab 
    setarg   i64   5
    load     u64   .r 
    setarg   u64   4
    load     u64   .q 
    setarg   u64   3
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   2
    load     i64   .opc 
    setarg   i64   1
    callp          mm_blockpcl.gcomparejump 5 0
    jump           #1673 
#1700:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     i64   .opc 
    loadimm  i64   52 
    jumpne   i64   #1702 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab2 
    setcall        1
    load     u64   .r 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   48 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
    setcall        1
    load     u64   .r 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   49 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    jump           #1701 
#1702:
    setcall        1
    load     u64   .r 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   48 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
    setcall        1
    load     u64   .r 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   51 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
#1701:
    jump           #1673 
#1703:
    load     u64   .r 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .s 
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #1705 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "empty set"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1705:
#1704:
    load     i64   .opc 
    loadimm  i64   53 
    jumpne   i64   #1708 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab2 
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    jump           #1710 
#1709:
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .s 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .s 
    load     u64   .s 
    jumpf    u64   #1713 
    setcall        2
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
    jump           #1712 
#1713:
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   47 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1712:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
#1710:
    load     u64   .s 
    jumpt    u64   #1709 
#1711:
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    jump           #1707 
#1708:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    jump           #1717 
#1714:
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    load     u64   .s 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #1719 
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
#1719:
#1718:
#1715:
    load     u64   .s 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .s 
#1717:
    load     u64   .s 
    jumpt    u64   #1714 
#1716:
#1707:
    jump           #1673 
#1720:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
    loadimm  i64   1 
    store    i64   .i 
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     i64   .opc 
    loadimm  i64   53 
    jumpne   i64   #1722 
    jump           #1724 
#1723:
    setcall        1
    load     u64   .r 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .r 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #1727 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        3
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   3
    setcall        1
    setcall        1
    load     u64   .p 
    loadimm  i64   40 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   1
    callf    i64   mm_blockpcl.reversecond 1 0
    setarg   i64   1
    callf    i64   mm_blockpcl.reversecond_order 1 0
    setarg   i64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc_cond 3 0
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
    jump           #1726 
#1727:
    setcall        3
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   3
    setcall        1
    load     u64   .p 
    loadimm  i64   40 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   1
    callf    i64   mm_blockpcl.reversecond 1 0
    setarg   i64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc_cond 3 0
#1726:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    loadref  u64   .i 
    incrto   i64   1
    load     u64   .r 
    store    u64   .q 
    load     u64   .r 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
#1724:
    load     u64   .r 
    jumpt    u64   #1723 
#1725:
    jump           #1721 
#1722:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab2 
    jump           #1729 
#1728:
    setcall        1
    load     u64   .r 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .r 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #1732 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        3
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   3
    setcall        1
    setcall        1
    load     u64   .p 
    loadimm  i64   40 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   1
    callf    i64   mm_blockpcl.reversecond 1 0
    setarg   i64   1
    callf    i64   mm_blockpcl.reversecond_order 1 0
    setarg   i64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc_cond 3 0
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
    jump           #1731 
#1732:
    setcall        3
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   3
    load     u64   .p 
    loadimm  i64   40 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc_cond 3 0
#1731:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    loadref  u64   .i 
    incrto   i64   1
    load     u64   .r 
    store    u64   .q 
    load     u64   .r 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
#1729:
    load     u64   .r 
    jumpt    u64   #1728 
#1730:
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
#1721:
    jump           #1673 
#1675:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   3 
    jumpeq   i64   #1734 1
    loadimm  i64   2 
    jumpeq   i64   #1734 1
    loadimm  i64   6 
    jumpeq   i64   #1734 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "jumptrue/not i64:"
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#1734:
#1733:
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#1673:
;------------------------
#1672:
    return         
end

proc mm_blockpcl.gcomparejump
    param    i64   .jumpopc 
    param    i64   .cond 
    param    u64   .lhs 
    param    u64   .rhs 
    param    i64   .lab 
    local    u64   .ax 
    local    u64   .bx 
    local    i64   .rev 
    local    i64   .opc 
;------------------------
    load     i64   .jumpopc 
    loadimm  i64   53 
    jumpne   i64   #1738 
    setcall        1
    load     i64   .cond 
    setarg   i64   1
    callf    i64   mm_blockpcl.reversecond 1 0
    store    i64   .cond 
#1738:
#1737:
    setcall        1
    load     u64   .lhs 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .rhs 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        3
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   3
    load     i64   .cond 
    setarg   i64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc_cond 3 0
    setcall        1
    load     u64   .lhs 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1736:
    return         
end

proc mm_blockpcl.reversecond
    rettype  i64   
    param    i64   .pclop 
;------------------------
    load     i64   .pclop 
    loadimm  i64   77 
    jumpeq   i64   #1741 1
    loadimm  i64   78 
    jumpeq   i64   #1742 1
    loadimm  i64   79 
    jumpeq   i64   #1743 1
    loadimm  i64   80 
    jumpeq   i64   #1744 1
    loadimm  i64   81 
    jumpeq   i64   #1745 1
    loadimm  i64   82 
    jumpeq   i64   #1746 
    jump           #1747 
#1741:
    loadimm  i64   78 
    store    i64   .pclop 
    jump           #1740 
#1742:
    loadimm  i64   77 
    store    i64   .pclop 
    jump           #1740 
#1743:
    loadimm  i64   81 
    store    i64   .pclop 
    jump           #1740 
#1744:
    loadimm  i64   82 
    store    i64   .pclop 
    jump           #1740 
#1745:
    loadimm  i64   79 
    store    i64   .pclop 
    jump           #1740 
#1746:
    loadimm  i64   80 
    store    i64   .pclop 
    jump           #1740 
#1747:
#1740:
    load     i64   .pclop 
    setret   i64   
    jump           #1739 
;------------------------
#1739:
    return         
end

proc mm_blockpcl.reversecond_order
    rettype  i64   
    param    i64   .pclop 
;------------------------
    load     i64   .pclop 
    loadimm  i64   77 
    jumpeq   i64   #1750 1
    loadimm  i64   78 
    jumpeq   i64   #1751 1
    loadimm  i64   79 
    jumpeq   i64   #1752 1
    loadimm  i64   80 
    jumpeq   i64   #1753 1
    loadimm  i64   81 
    jumpeq   i64   #1754 1
    loadimm  i64   82 
    jumpeq   i64   #1755 
    jump           #1756 
#1750:
    loadimm  i64   77 
    store    i64   .pclop 
    jump           #1749 
#1751:
    loadimm  i64   78 
    store    i64   .pclop 
    jump           #1749 
#1752:
    loadimm  i64   82 
    store    i64   .pclop 
    jump           #1749 
#1753:
    loadimm  i64   81 
    store    i64   .pclop 
    jump           #1749 
#1754:
    loadimm  i64   80 
    store    i64   .pclop 
    jump           #1749 
#1755:
    loadimm  i64   79 
    store    i64   .pclop 
    jump           #1749 
#1756:
#1749:
    load     i64   .pclop 
    setret   i64   
    jump           #1748 
;------------------------
#1748:
    return         
end

proc mm_blockpcl.dx_while
    param    u64   .p 
    param    u64   .pcond 
    param    u64   .pbody 
    param    u64   .pincr 
    local    i64   .lab_b 
    local    i64   .lab_c 
    local    i64   .lab_d 
    local    i64   .lab_incr 
;------------------------
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_b 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_c 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
    load     u64   .pincr 
    jumpf    u64   #1759 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_incr 
    jump           #1758 
#1759:
    load     i64   .lab_c 
    store    i64   .lab_incr 
#1758:
    setcall        3
    load     i64   .lab_d 
    setarg   i64   3
    load     i64   .lab_c 
    setarg   i64   2
    load     i64   .lab_b 
    setarg   i64   1
    callp          mm_libpcl.stacklooplabels 3 0
    setcall        1
    load     i64   .lab_incr 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    setcall        1
    load     i64   .lab_b 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    load     u64   .pbody 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     i64   .lab_c 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    load     u64   .pincr 
    jumpf    u64   #1761 
    setcall        1
    load     u64   .pincr 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     i64   .lab_incr 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
#1761:
#1760:
    setcall        3
    load     i64   .lab_b 
    setarg   i64   3
    load     u64   .pcond 
    setarg   u64   2
    loadimm  i64   52 
    setarg   i64   1
    callp          mm_blockpcl.docond 3 0
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadref  u64   mm_libpcl.loopindex 
    decrto   i64   1
;------------------------
#1757:
    return         
end

proc mm_blockpcl.dx_repeat
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .lab_ab 
    local    i64   .lab_c 
    local    i64   .lab_d 
;------------------------
    setcall        0
    callf    i64   mm_libpcl.definelabel 0 0
    store    i64   .lab_ab 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_c 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
    setcall        3
    load     i64   .lab_d 
    setarg   i64   3
    load     i64   .lab_c 
    setarg   i64   2
    load     i64   .lab_ab 
    setarg   i64   1
    callp          mm_libpcl.stacklooplabels 3 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     i64   .lab_c 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    load     u64   .b 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #1765 
    load     u64   .b 
    loadimm  i64   16 
    iloadx   i64   1 0
    loadimm  i64   0 
    jumpeq   i64   #1764 
#1765:
    setcall        3
    load     i64   .lab_ab 
    setarg   i64   3
    load     u64   .b 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.docond 3 0
#1764:
#1763:
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadref  u64   mm_libpcl.loopindex 
    decrto   i64   1
;------------------------
#1762:
    return         
end

proc mm_blockpcl.dx_print
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u64   .q 
    local    u64   .r 
    local    u64   .fmt 
    local    i64   .m 
    local    i64   .fn 
    local    i64   .needprintend 
    local    u64   .ax 
    local    u64   .bx 
    local    u64   .z 
;------------------------
    load     u64   .a 
    jumpf    u64   #1768 
    loadimm  i64   1 
    store    i64   .needprintend 
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   7 
    jumpeq   i64   #1770 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "@dev no ref"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1770:
#1769:
    loadref  u64   mm_decls.ttbasetype 
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpeq   i64   #1773 1
    loadimm  i64   13 
    jumpeq   i64   #1774 1
    loadimm  i64   7 
    jumpeq   i64   #1775 
    jump           #1776 
#1773:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    jump           #1772 
#1774:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    jump           #1772 
#1775:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    loadimm  i64   4 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    jump           #1772 
#1776:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "@dev?"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1772:
    jump           #1767 
#1768:
    loadimm  i64   1 
    store    i64   .needprintend 
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
#1767:
    load     u64   .b 
    store    u64   .q 
    load     u64   .p 
    iload    u8    
    loadimm  i64   114 
    jumpeq   i64   #1779 1
    loadimm  i64   115 
    jumpeq   i64   #1779 
    jump           #1780 
#1779:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   7 
    jumpne   i64   #1783 
    loadref  u64   mm_decls.ttbasetype 
    loadref  u64   mm_decls.tttarget 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    iloadx   i32   4 0
    loadimm  i64   13 
    jumpeq   i64   #1782 
#1783:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "string expected"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1782:
#1781:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   6 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #1778 
#1780:
#1778:
    jump           #1786 
#1785:
    load     u64   .q 
    iload    u8    
    loadimm  i64   85 
    jumpeq   i64   #1789 1
    loadimm  i64   86 
    jumpeq   i64   #1790 1
    loadimm  i64   87 
    jumpeq   i64   #1791 
    jump           #1792 
#1789:
    load     u64   .q 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .fmt 
    load     u64   .q 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .r 
    load     u64   .r 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
    jump           #1788 
#1790:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   7 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #1786 
    jump           #1788 
#1791:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   8 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #1786 
    jump           #1788 
#1792:
    loadimm  u64   0 
    store    u64   .fmt 
    load     u64   .q 
    store    u64   .r 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
#1788:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    switch         #1794 1 11
    opnd           #1795 
#1794:
    swlabel        #1819 
    swlabel        #1799 
    swlabel        #1796 
    swlabel        #1800 
    swlabel        #1801 
    swlabel        #1810 
    swlabel        #1802 
    swlabel        #1813 
    swlabel        #1795 
    swlabel        #1811 
    swlabel        #1815 
    endsw          
#1796:
    loadimm  i64   9 
    store    i64   .fn 
    load     u64   .fmt 
    jumpt    u64   #1798 
    loadimm  i64   10 
    store    i64   .fn 
#1798:
#1797:
    jump           #1793 
#1799:
    loadimm  i64   11 
    store    i64   .fn 
    jump           #1793 
#1800:
    loadimm  i64   13 
    store    i64   .fn 
    jump           #1793 
#1801:
    loadimm  i64   12 
    store    i64   .fn 
    jump           #1793 
#1802:
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   13 
    jumpeq   i64   #1805 
    loadref  u64   mm_decls.ttbasetype 
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpne   i64   #1804 
    loadref  u64   mm_decls.tttarget 
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    iloadx   i32   4 0
    loadimm  i64   13 
    jumpne   i64   #1804 
#1805:
    loadimm  i64   14 
    store    i64   .fn 
    load     u64   .fmt 
    jumpt    u64   #1807 
    loadimm  i64   15 
    store    i64   .fn 
#1807:
#1806:
    jump           #1803 
#1804:
    loadimm  i64   17 
    store    i64   .fn 
    load     u64   .fmt 
    jumpt    u64   #1809 
    loadimm  i64   18 
    store    i64   .fn 
#1809:
#1808:
#1803:
    jump           #1793 
#1810:
    loadimm  i64   20 
    store    i64   .fn 
    jump           #1793 
#1811:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "PRINTARRAY"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #1793 
#1813:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "PRINTRECORD"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    jump           #1793 
#1815:
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   13 
    jumpne   i64   #1817 
    loadimm  i64   16 
    store    i64   .fn 
    jump           #1816 
#1817:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "PRINTSLICE"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1816:
    jump           #1793 
#1819:
    loadimm  i64   19 
    store    i64   .fn 
    jump           #1793 
#1795:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "PRINT/T=#"
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#1793:
    load     i64   .fn 
    loadimm  i64   10 
    jumpeq   i64   #1822 1
    loadimm  i64   15 
    jumpeq   i64   #1822 1
    loadimm  i64   18 
    jumpeq   i64   #1822 
    jump           #1823 
#1822:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .r 
    setarg   u64   2
    load     i64   .fn 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    jump           #1821 
#1823:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .z 
    loadimm  i64   1 
    load     u64   .z 
    loadimm  i64   60 
    istorex  u8    1 0
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    startmx        
    load     u64   .fmt 
    jumpf    u64   #1825 
    load     u64   .fmt 
    resetmx        
    jump           #1824 
#1825:
    load     u64   .z 
    endmx          
#1824:
    setarg   u64   3
    load     u64   .r 
    setarg   u64   2
    load     i64   .fn 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
#1821:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#1786:
    load     u64   .q 
    jumpt    u64   #1785 
#1787:
    load     u64   .p 
    iload    u8    
    loadimm  i64   113 
    jumpeq   i64   #1827 1
    loadimm  i64   115 
    jumpeq   i64   #1827 
    jump           #1828 
#1827:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   21 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    jump           #1826 
#1828:
#1826:
    load     i64   .needprintend 
    jumpf    i64   #1830 
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   22 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
#1830:
#1829:
;------------------------
#1766:
    return         
end

proc mm_blockpcl.dx_do
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .lab_abc 
    local    i64   .lab_d 
;------------------------
    setcall        0
    callf    i64   mm_libpcl.definelabel 0 0
    store    i64   .lab_abc 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
    setcall        3
    load     i64   .lab_d 
    setarg   i64   3
    load     i64   .lab_abc 
    setarg   i64   2
    load     i64   .lab_abc 
    setarg   i64   1
    callp          mm_libpcl.stacklooplabels 3 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     i64   .lab_abc 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadref  u64   mm_libpcl.loopindex 
    decrto   i64   1
;------------------------
#1831:
    return         
end

proc mm_blockpcl.dx_exit
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .n 
    local    i64   .index 
    local    i64   .k 
;------------------------
    startmx        
    load     u64   .p 
    iload    u8    
    loadimm  i64   101 
    jumpeq   i64   #1834 1
    loadimm  i64   102 
    jumpeq   i64   #1835 
    jump           #1836 
#1834:
    loadimm  i64   1 
    resetmx        
    jump           #1833 
#1835:
    loadimm  i64   2 
    resetmx        
    jump           #1833 
#1836:
    loadimm  i64   3 
    endmx          
#1833:
    store    i64   .k 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i32   1 0
    store    i64   .index 
    load     i64   .index 
    loadimm  i64   0 
    jumpne   i64   #1838 
    load     i64   mm_libpcl.loopindex 
    store    i64   .index 
#1838:
#1837:
    setcall        2
    load     i64   .index 
    setarg   i64   2
    load     i64   .k 
    setarg   i64   1
    callf    i64   mm_libpcl.findlooplabel 2 0
    store    i64   .n 
    load     i64   .n 
    loadimm  i64   0 
    jumpne   i64   #1840 
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  u64   "Bad exit/loop index"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    jump           #1839 
#1840:
    setcall        1
    load     i64   .n 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
#1839:
;------------------------
#1832:
    return         
end

proc mm_blockpcl.dx_return
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    load     u64   .a 
    jumpf    u64   #1844 
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   40 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#1844:
#1843:
    setcall        2
    setcall        1
    load     i64   mc_decls.retindex 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   44 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#1842:
    return         
end

proc mm_blockpcl.dx_returnmult
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u8:800 .params 
    local    u64   .ax 
    local    u64   .q 
    local    i64   .i 
;------------------------
    load     u64   .a 
    store    u64   .q 
    loadimm  i64   0 
    store    i64   mc_decls.nparams 
    jump           #1847 
#1846:
    load     i64   mc_decls.nparams 
    loadimm  i64   100 
    jumplt   i64   #1850 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Mult?"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1850:
#1849:
    load     u64   .q 
    loadref  u64   .params 
    loadref  u64   mc_decls.nparams 
    incrload i64   1
    istorex  u64   8 -8
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#1847:
    load     u64   .q 
    jumpt    u64   #1846 
#1848:
    load     i64   mc_decls.nparams 
    store    i64   .i 
    load     i64   .i 
    loadimm  i64   1 
    jumplt   i64   #1854 
#1852:
    setcall        1
    loadref  u64   .params 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
#1853:
    fordown        #1852 1
    opnd           .i 
    opnd           1 
#1854:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   40 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        2
    setcall        1
    load     i64   mc_decls.retindex 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   44 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#1845:
    return         
end

proc mm_blockpcl.dx_read
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .m 
    local    i64   .opc 
;------------------------
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
    load     u64   .a 
    loadimm  u64   0 
    jumpne   u64   #1857 
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .a 
    loadimm  i64   1 
    load     u64   .a 
    loadimm  i64   60 
    istorex  u8    1 0
#1857:
#1856:
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #1859 
    loadimm  i64   23 
    store    i64   .opc 
    jump           #1858 
#1859:
    loadref  u64   mm_decls.ttisreal 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #1860 
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    iloadx   u32   4 0
    loadimm  i64   8 
    jumpne   i64   #1860 
    loadimm  i64   24 
    store    i64   .opc 
    jump           #1858 
#1860:
    load     i64   .m 
    loadimm  i64   21 
    jumpne   i64   #1861 
    loadimm  i64   25 
    store    i64   .opc 
    jump           #1858 
#1861:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  u64   "Read:"
    setarg   u64   1
    callp          mm_support.gerror_t 2 0
#1858:
    setcall        5
    startmx        
    loadref  u64   mm_decls.ttisreal 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #1864 
    loadimm  i64   2 
    resetmx        
    jump           #1863 
#1864:
    loadimm  i64   1 
    endmx          
#1863:
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1855:
    return         
end

proc mm_blockpcl.dx_readln
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    load     u64   .a 
    jumpf    u64   #1867 
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   7 
    jumpeq   i64   #1869 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "@dev no ref"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1869:
#1868:
    loadref  u64   mm_decls.ttbasetype 
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpeq   i64   #1872 1
    loadimm  i64   18 
    jumpeq   i64   #1873 1
    loadimm  i64   13 
    jumpeq   i64   #1873 
    jump           #1874 
#1872:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    loadimm  i64   26 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    jump           #1871 
#1873:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    loadimm  i64   27 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
    jump           #1871 
#1874:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "rd@dev?"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1871:
    jump           #1866 
#1867:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   28 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
#1866:
;------------------------
#1865:
    return         
end

proc mm_blockpcl.dx_assign
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u64   .d 
    local    i64   .offset 
;------------------------
    load     u64   .b 
    iload    u8    
    loadimm  i64   20 
    jumpne   i64   #1878 
    load     u64   .a 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #1878 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "MAKESLICE"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    jump           #1876 
#1878:
#1877:
    load     u64   .a 
    iload    u8    
    loadimm  i64   43 
    jumpeq   i64   #1881 1
    loadimm  i64   44 
    jumpeq   i64   #1882 1
    loadimm  i64   45 
    jumpeq   i64   #1883 
    jump           #1884 
#1881:
    setcall        4
    load     u64   .b 
    setarg   u64   4
    load     u64   .a 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   3
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.do_storeindex 4 0
    jump           #1876 
    jump           #1880 
#1882:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "ASS/SLICE"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    jump           #1880 
#1883:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.do_storedot 3 0
    jump           #1876 
    jump           #1880 
#1884:
#1880:
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .p 
    loadimm  i64   60 
    iloadx   u8    1 0
    jumpf    i64   #1887 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   23 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1887:
#1886:
    load     u64   .a 
    iload    u8    
    switch         #1889 3 48
    opnd           #1890 
#1889:
    swlabel        #1891 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1890 
    swlabel        #1895 
    swlabel        #1896 
    swlabel        #1892 
    endsw          
#1891:
    setcall        2
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   21 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #1888 
#1892:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   28 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    startmx        
    load     u64   .a 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #1894 
    load     u64   .a 
    loadimm  i64   63 
    iloadx   u8    1 0
    resetmx        
    jump           #1893 
#1894:
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    endmx          
#1893:
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #1888 
#1895:
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        1
    load     u64   .a 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   61 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #1876 
    jump           #1888 
#1896:
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        1
    load     u64   .a 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .a 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   63 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    jump           #1876 
    jump           #1888 
#1890:
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_tables.jtagnames 
    load     u64   .a 
    iload    u8    
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Can't assign"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1888:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1876:
    return         
end

proc mm_blockpcl.dx_if
    param    u64   .p 
    param    u64   .pcond 
    param    u64   .plist 
    param    u64   .pelse 
    local    i64   .labend 
    local    i64   .i 
    local    i64   .lab2 
    local    i64   .ismult 
;------------------------
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labend 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   0 
    ne       i64   
    store    i64   .ismult 
    loadimm  i64   0 
    store    i64   .i 
    load     i64   .ismult 
    jumpf    i64   #1900 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1900:
#1899:
    jump           #1904 
#1901:
    loadref  u64   .i 
    incrto   i64   1
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab2 
    setcall        3
    load     i64   .lab2 
    setarg   i64   3
    load     u64   .pcond 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.docond 3 0
    setcall        2
    load     u64   .p 
    loadimm  i64   3 
    iloadx   u8    1 0
    loadimm  i64   0 
    loadbit        
    setarg   i64   2
    load     u64   .plist 
    setarg   u64   1
    callp          mm_blockpcl.evalunitx 2 0
    load     i64   .ismult 
    jumpf    i64   #1906 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1906:
#1905:
    load     u64   .pcond 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpt    u64   #1909 
    load     u64   .pelse 
    jumpf    u64   #1908 
#1909:
    setcall        1
    load     i64   .labend 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
#1908:
#1907:
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
#1902:
    load     u64   .pcond 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pcond 
    load     u64   .plist 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .plist 
#1904:
    load     u64   .pcond 
    jumpt    u64   #1901 
#1903:
    load     u64   .pelse 
    jumpf    u64   #1911 
    setcall        2
    load     u64   .p 
    loadimm  i64   3 
    iloadx   u8    1 0
    loadimm  i64   0 
    loadbit        
    setarg   i64   2
    load     u64   .pelse 
    setarg   u64   1
    callp          mm_blockpcl.evalunitx 2 0
    load     i64   .ismult 
    jumpf    i64   #1913 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1913:
#1912:
#1911:
#1910:
    setcall        1
    load     i64   .labend 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
;------------------------
#1898:
    return         
end

proc mm_blockpcl.dx_istruel
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   6 
    jumpne   i64   #1916 
    jump           #1914 
#1916:
#1915:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1914:
    return         
end

proc mm_blockpcl.dx_incrto
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .f 
    local    i64   .opc 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_blockpcl.getincrstep 1 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  i32   1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#1917:
    return         
end

proc mm_blockpcl.getincrstep
    rettype  i64   
    param    i64   .m 
;------------------------
    startmx        
    loadref  u64   mm_decls.ttisref 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #1920 
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    iloadx   u32   4 0
    resetmx        
    jump           #1919 
#1920:
    loadimm  i64   1 
    endmx          
#1919:
    setret   i64   
    jump           #1918 
;------------------------
#1918:
    return         
end

proc mm_blockpcl.dx_callproc
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u8:800 .paramlist 
    local    i64   .nparams 
    local    i64   .nmult 
    local    i64   .isptr 
    local    i64   .nvariadics 
    local    i64   .blockret 
    local    i64   .nret 
    local    i64   .size 
    local    i64   .isfn 
    local    i64   .oldstackdepth 
    local    i64   .widen 
    local    u64   .d 
    local    u64   .dblock 
    local    u64   .dtemp 
    local    u64   .pmult 
    local    u64   .q 
    local    i64   .i 
;------------------------
    loadimm  i64   0 
    store    i64   .isptr 
    load     u64   .p 
    iload    u8    
    loadimm  i64   29 
    eq       i64   
    store    i64   .isfn 
    load     u64   .a 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #1923 1
    loadimm  i64   48 
    jumpeq   i64   #1924 
    jump           #1925 
#1923:
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    jump           #1922 
#1924:
    loadref  u64   mm_decls.ttnamedef 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u64   8 0
    store    u64   .d 
    loadimm  i64   1 
    store    i64   .isptr 
    jump           #1922 
#1925:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "call/not ptr"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1922:
    loadimm  i64   0 
    store    i64   .nparams 
    loadimm  i64   0 
    store    i64   .nvariadics 
    loadimm  i64   0 
    store    i64   .blockret 
    loadref  u64   mm_decls.ttisblock 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #1928 
    loadimm  i64   1 
    store    i64   .blockret 
    loadimm  i64   1 
    store    i64   .nparams 
    loadimm  u64   0 
    loadref  u64   .paramlist 
    loadimm  i64   1 
    istorex  u64   8 -8
#1928:
#1927:
    load     u64   .b 
    store    u64   .q 
    jump           #1932 
#1929:
    load     i64   .nparams 
    loadimm  i64   100 
    jumplt   i64   #1934 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "maxparams"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1934:
#1933:
    load     u64   .q 
    loadref  u64   .paramlist 
    loadref  u64   .nparams 
    incrload i64   1
    istorex  u64   8 -8
    load     u64   .d 
    loadimm  i64   116 
    iloadx   u8    1 0
    jumpf    i64   #1937 
    load     i64   .nparams 
    load     u64   .d 
    loadimm  i64   116 
    iloadx   u8    1 0
    jumplt   i64   #1937 
    load     i64   .nparams 
    loadimm  i64   4 
    jumpgt   i64   #1937 
    load     i64   .nvariadics 
    loadimm  i64   0 
    jumpne   i64   #1937 
    load     i64   .nparams 
    store    i64   .nvariadics 
#1937:
#1936:
#1930:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#1932:
    load     u64   .q 
    jumpt    u64   #1929 
#1931:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   38 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     i64   .nparams 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  i8    1 0
    load     i64   .nparams 
    store    i64   .i 
    load     i64   .i 
    loadimm  i64   1 
    jumplt   i64   #1940 
#1938:
    loadref  u64   .paramlist 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .q 
    load     u64   .q 
    jumpf    u64   #1942 
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     i64   .nvariadics 
    jumpf    i64   #1944 
    load     i64   .i 
    load     i64   .nvariadics 
    jumplt   i64   #1944 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   25 
    iloadx   u8    1 0
    loadimm  i64   4 
    jumpne   i64   #1944 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   134 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   5 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   25 
    istorex  u8    1 0
    loadimm  i64   4 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
#1944:
#1943:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   39 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    load     i64   .i 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
    jump           #1941 
#1942:
    setcall        1
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.newblocktemp 1 0
    store    u64   .dblock 
    setcall        2
    setcall        1
    load     u64   .dblock 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   18 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#1941:
#1939:
    fordown        #1938 1
    opnd           .i 
    opnd           1 
#1940:
    load     i64   .isptr 
    jumpt    i64   #1946 
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmemaddr 1 0
    setarg   u64   2
    startmx        
    load     i64   .isfn 
    jumpf    i64   #1948 
    loadimm  i64   35 
    resetmx        
    jump           #1947 
#1948:
    loadimm  i64   34 
    endmx          
#1947:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #1945 
#1946:
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    startmx        
    load     i64   .isfn 
    jumpf    i64   #1950 
    loadimm  i64   37 
    resetmx        
    jump           #1949 
#1950:
    loadimm  i64   36 
    endmx          
#1949:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1945:
    load     i64   .nparams 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  i8    1 0
    load     i64   .nvariadics 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   21 
    istorex  u8    1 0
    loadimm  i64   0 
    store    i64   .widen 
    load     i64   .isfn 
    jumpf    i64   #1952 
    setcall        1
    startmx        
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #1954 
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    resetmx        
    jump           #1953 
#1954:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    endmx          
#1953:
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    load     u64   .p 
    loadimm  i64   60 
    iloadx   u8    1 0
    jumpt    i64   #1956 
    jump           #1955 
#1956:
    loadref  u64   mm_decls.ttisshort 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   25 
    iloadx   u8    1 0
    iloadx   u8    1 0
    jumpf    i64   #1958 
    startmx        
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #1960 
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    resetmx        
    jump           #1959 
#1960:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    endmx          
#1959:
    store    i64   .widen 
#1958:
#1957:
#1955:
#1952:
#1951:
    load     i64   .widen 
    jumpf    i64   #1962 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   137 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    startmx        
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #1964 
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    resetmx        
    jump           #1963 
#1964:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    endmx          
#1963:
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#1962:
#1961:
;------------------------
#1921:
    return         
end

proc mm_blockpcl.dx_forup
    param    u64   .p 
    param    u64   .pindex 
    param    u64   .pfrom 
    param    u64   .pbody 
    local    u64   .pto 
    local    u64   .pstep 
    local    u64   .pelse 
    local    u64   .px 
    local    u64   .plimit 
    local    u64   .ptoinit 
    local    u64   .ptemp 
    local    i64   .lab_b 
    local    i64   .lab_c 
    local    i64   .lab_d 
    local    i64   .lab_e 
    local    i64   .a 
    local    i64   .b 
    local    i64   .stepx 
    local    i64   .down 
    local    u64   .d 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   94 
    eq       i64   
    store    i64   .down 
    load     u64   .pfrom 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pto 
    load     u64   .pto 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pstep 
    load     u64   .pbody 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pelse 
    load     u64   .pindex 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .ptoinit 
    load     u64   .pto 
    iload    u8    
    loadimm  i64   48 
    jumpeq   i64   #1967 1
    loadimm  i64   1 
    jumpeq   i64   #1968 1
    loadimm  i64   3 
    jumpeq   i64   #1968 
    jump           #1969 
#1967:
    load     u64   .pto 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .px 
    load     u64   .px 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #1971 
    load     u64   .px 
    loadimm  i64   16 
    iloadx   u64   1 0
    double         
    store    u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   13 
    jumpne   i64   #1971 
    load     u64   .d 
    loadimm  i64   152 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpne   i64   #1971 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Possibly using &param as for-loop limit"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1971:
#1970:
    jump           #1966 
#1968:
    jump           #1966 
#1969:
    load     u64   .pto 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   3 
    jumpne   i64   #1974 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "NEWBLOCKTEMP"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    jump           #1973 
#1974:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Complex TO"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1973:
#1966:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_b 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_c 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
    load     u64   .pelse 
    jumpf    u64   #1978 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_e 
    jump           #1977 
#1978:
    load     i64   .lab_d 
    store    i64   .lab_e 
#1977:
    setcall        3
    load     i64   .lab_d 
    setarg   i64   3
    load     i64   .lab_c 
    setarg   i64   2
    load     i64   .lab_b 
    setarg   i64   1
    callp          mm_libpcl.stacklooplabels 3 0
    setcall        1
    load     u64   .pfrom 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     u64   .pindex 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   21 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    load     u64   .ptoinit 
    jumpf    u64   #1980 
    loadimm  i64   0 
    load     u64   .ptoinit 
    loadimm  i64   60 
    istorex  u8    1 0
    setcall        1
    load     u64   .ptoinit 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
#1980:
#1979:
    load     u64   .pfrom 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #1982 
    load     u64   .pto 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #1982 
    load     u64   .pfrom 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .a 
    load     u64   .pto 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .b 
    load     i64   .down 
    jumpf    i64   #1986 
    load     i64   .a 
    load     i64   .b 
    jumpge   i64   #1985 
#1986:
    load     i64   .down 
    jumpt    i64   #1984 
    load     i64   .a 
    load     i64   .b 
    jumpgt   i64   #1984 
#1985:
    jump           #1983 
#1984:
    setcall        2
    setcall        1
    load     i64   .lab_e 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   44 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1983:
    jump           #1981 
#1982:
    load     u64   .pfrom 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #1988 
    setcall        1
    load     u64   .pto 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .pfrom 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab_e 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    startmx        
    load     i64   .down 
    jumpf    i64   #1990 
    loadimm  i64   51 
    resetmx        
    jump           #1989 
#1990:
    loadimm  i64   48 
    endmx          
#1989:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #1987 
#1988:
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .pto 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab_e 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    startmx        
    load     i64   .down 
    jumpf    i64   #1992 
    loadimm  i64   48 
    resetmx        
    jump           #1991 
#1992:
    loadimm  i64   51 
    endmx          
#1991:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#1987:
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
#1981:
    setcall        1
    load     i64   .lab_b 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    load     u64   .pbody 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     i64   .lab_c 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    load     u64   .pstep 
    jumpf    u64   #1994 
    load     u64   .pstep 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #1996 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "for/step non-const not ready"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1996:
#1995:
    load     u64   .pstep 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .stepx 
    load     i64   .stepx 
    loadimm  i64   0 
    jumpgt   i64   #1999 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Bad for-step"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#1999:
#1998:
    jump           #1993 
#1994:
    loadimm  i64   1 
    store    i64   .stepx 
#1993:
    setcall        2
    setcall        1
    load     i64   .lab_b 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    startmx        
    load     i64   .down 
    jumpf    i64   #2002 
    loadimm  i64   55 
    resetmx        
    jump           #2001 
#2002:
    loadimm  i64   54 
    endmx          
#2001:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     i64   .stepx 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  i32   1 0
    setcall        2
    setcall        1
    load     u64   .pindex 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     u64   .pto 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #2004 1
    loadimm  i64   3 
    jumpeq   i64   #2005 
    jump           #2006 
#2004:
    setcall        2
    setcall        1
    load     u64   .pto 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2003 
#2005:
    setcall        2
    setcall        1
    load     u64   .pto 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2003 
#2006:
#2003:
    load     u64   .pelse 
    jumpf    u64   #2008 
    setcall        1
    load     i64   .lab_e 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    load     u64   .pelse 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
#2008:
#2007:
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadref  u64   mm_libpcl.loopindex 
    decrto   i64   1
;------------------------
#1965:
    return         
end

proc mm_blockpcl.dx_to
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u64   .cvar 
    local    i64   .lab_b 
    local    i64   .lab_c 
    local    i64   .lab_d 
    local    i64   .count 
;------------------------
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .cvar 
    loadimm  i64   3 
    load     u64   .a 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     u64   .cvar 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   21 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_b 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_c 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
    setcall        3
    load     i64   .lab_d 
    setarg   i64   3
    load     i64   .lab_c 
    setarg   i64   2
    load     i64   .lab_b 
    setarg   i64   1
    callp          mm_libpcl.stacklooplabels 3 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #2011 
    setcall        1
    load     u64   .cvar 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   49 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #2010 
#2011:
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .count 
    load     i64   .count 
    loadimm  i64   0 
    jumpgt   i64   #2013 
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
#2013:
#2012:
#2010:
    setcall        1
    load     i64   .lab_b 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     i64   .lab_c 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        2
    setcall        1
    load     i64   .lab_b 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   56 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        2
    setcall        1
    load     u64   .cvar 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadref  u64   mm_libpcl.loopindex 
    decrto   i64   1
;------------------------
#2009:
    return         
end

proc mm_blockpcl.dx_index
    param    u64   .p 
    param    u64   .parray 
    param    u64   .pindex 
    param    u64   .c 
    local    i64   .addoffset 
    local    i64   .scale 
;------------------------
    loadref  u64   mm_decls.ttisblock 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #2016 
    setcall        4
    load     u64   .c 
    setarg   u64   4
    load     u64   .pindex 
    setarg   u64   3
    load     u64   .parray 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.do_indexref 4 0
    jump           #2014 
#2016:
#2015:
    setcall        2
    loadref  u64   .pindex 
    setarg   u64   2
    load     u64   .parray 
    setarg   u64   1
    callf    i64   mm_blockpcl.getindexoffset 2 0
    store    i64   .addoffset 
    setcall        1
    load     u64   .parray 
    setarg   u64   1
    callp          mm_blockpcl.evalarray 1 0
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        2
    load     i64   .addoffset 
    setarg   i64   2
    load     u64   .parray 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_blockpcl.getscx 2 0
    setarg   u64   2
    loadimm  i64   29 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    startmx        
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #2018 
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    resetmx        
    jump           #2017 
#2018:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    endmx          
#2017:
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#2014:
    return         
end

proc mm_blockpcl.getscx
    rettype  u64   
    param    i64   .axmode 
    param    i64   .offset 
    local    i64   .scale 
;------------------------
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     i64   .axmode 
    iloadx   i32   4 0
    iloadx   u32   4 0
    store    i64   .scale 
    setcall        2
    loadref  u64   mm_decls.ttlower 
    load     i64   .axmode 
    iloadx   i32   4 0
    neg      i64   
    load     i64   .scale 
    mul      i64   
    load     i64   .offset 
    load     i64   .scale 
    mul      i64   
    add      i64   
    setarg   i64   2
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     i64   .axmode 
    iloadx   i32   4 0
    iloadx   u32   4 0
    setarg   i64   1
    callf    u64   mm_libpcl.genscaleoffset 2 0
    setret   u64   
    jump           #2019 
;------------------------
#2019:
    return         
end

proc mm_blockpcl.do_indexref
    param    u64   .p 
    param    u64   .parray 
    param    u64   .pindex 
    param    u64   .c 
    local    i64   .addoffset 
    local    i64   .scale 
;------------------------
    setcall        2
    loadref  u64   .pindex 
    setarg   u64   2
    load     u64   .parray 
    setarg   u64   1
    callf    i64   mm_blockpcl.getindexoffset 2 0
    store    i64   .addoffset 
    setcall        1
    load     u64   .parray 
    setarg   u64   1
    callp          mm_blockpcl.evalarray 1 0
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        2
    load     i64   .addoffset 
    setarg   i64   2
    load     u64   .parray 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_blockpcl.getscx 2 0
    setarg   u64   2
    loadimm  i64   31 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadref  u64   mm_decls.tttarget 
    load     u64   .parray 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#2020:
    return         
end

proc mm_blockpcl.do_storeindex
    param    u64   .p 
    param    u64   .parray 
    param    u64   .pindex 
    param    u64   .rhs 
    local    i64   .addoffset 
    local    i64   .scale 
;------------------------
    setcall        2
    loadref  u64   .pindex 
    setarg   u64   2
    load     u64   .parray 
    setarg   u64   1
    callf    i64   mm_blockpcl.getindexoffset 2 0
    store    i64   .addoffset 
    setcall        1
    load     u64   .rhs 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .p 
    loadimm  i64   60 
    iloadx   u8    1 0
    jumpf    i64   #2023 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   23 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2023:
#2022:
    setcall        1
    load     u64   .parray 
    setarg   u64   1
    callp          mm_blockpcl.evalarray 1 0
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        2
    load     i64   .addoffset 
    setarg   i64   2
    load     u64   .parray 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_blockpcl.getscx 2 0
    setarg   u64   2
    loadimm  i64   30 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#2021:
    return         
end

proc mm_blockpcl.getindexoffset
    rettype  i64   
    param    u64   .parray 
    param    u64   .pindex 
    local    i64   .offset 
    local    i64   .addoffset 
;------------------------
    loadimm  i64   0 
    store    i64   .addoffset 
    load     u64   .pindex 
    iload    u64   
    iload    u8    
    loadimm  i64   32 
    jumpne   i64   #2026 
    load     u64   .pindex 
    iload    u64   
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   64 
    jumpeq   i64   #2027 1
    loadimm  i64   65 
    jumpne   i64   #2026 
#2027:
    load     u64   .pindex 
    iload    u64   
    loadimm  i64   24 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #2029 
    startmx        
    load     u64   .pindex 
    iload    u64   
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   64 
    jumpne   i64   #2031 
    load     u64   .pindex 
    iload    u64   
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    resetmx        
    jump           #2030 
#2031:
    load     u64   .pindex 
    iload    u64   
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    neg      i64   
    endmx          
#2030:
    store    i64   .addoffset 
    load     u64   .pindex 
    iload    u64   
    loadimm  i64   16 
    iloadx   u64   1 0
    load     u64   .pindex 
    istore   u64   
#2029:
#2028:
#2026:
#2025:
    load     i64   .addoffset 
    setret   i64   
    jump           #2024 
;------------------------
#2024:
    return         
end

proc mm_blockpcl.evalarray
    param    u64   .p 
;------------------------
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   11 
    jumpeq   i64   #2034 
    jump           #2035 
#2034:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "SLICE PTR"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #2033 
#2035:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   21 
    jumpne   i64   #2038 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    jump           #2037 
#2038:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
#2037:
#2033:
;------------------------
#2032:
    return         
end

proc mm_blockpcl.dx_addrof
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
;------------------------
#2039:
    return         
end

proc mm_blockpcl.dx_swap
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   25 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#2040:
    return         
end

proc mm_blockpcl.dx_stop
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    load     u64   .a 
    loadimm  u64   0 
    jumpeq   u64   #2044 
    load     u64   .a 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #2043 
#2044:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   42 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    startmx        
    load     u64   .a 
    jumpf    u64   #2046 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    resetmx        
    jump           #2045 
#2046:
    loadimm  i64   0 
    endmx          
#2045:
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
    jump           #2042 
#2043:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   43 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2042:
;------------------------
#2041:
    return         
end

proc mm_blockpcl.dx_ptr
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   27 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    startmx        
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #2049 
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    resetmx        
    jump           #2048 
#2049:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    endmx          
#2048:
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#2047:
    return         
end

proc mm_blockpcl.dx_dot
    param    u64   .pdot 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .offset 
    local    u64   .pname 
;------------------------
    loadimm  u64   1 
    jumpf    i64   #2052 
    loadimm  u64   0 
    store    u64   .pname 
    setcall        2
    loadref  u64   .pname 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_blockpcl.checkdotchain 2 0
    store    i64   .offset 
    loadref  u64   .offset 
    load     u64   .pdot 
    loadimm  i64   40 
    iloadx   u32   1 0
    addto    i64   
    load     u64   .pname 
    store    u64   .a 
    jump           #2051 
#2052:
    load     u64   .pdot 
    loadimm  i64   40 
    iloadx   u32   1 0
    store    i64   .offset 
#2051:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    load     i64   .offset 
    jumpf    i64   #2054 
    setcall        1
    load     i64   .offset 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_libpcl.genscaleoffset 2 0
    setarg   u64   2
    loadimm  i64   29 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2053 
#2054:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   27 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2053:
    setcall        1
    startmx        
    load     u64   .pdot 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #2056 
    load     u64   .pdot 
    loadimm  i64   63 
    iloadx   u8    1 0
    resetmx        
    jump           #2055 
#2056:
    load     u64   .pdot 
    loadimm  i64   48 
    iloadx   i32   1 0
    endmx          
#2055:
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#2050:
    return         
end

proc mm_blockpcl.do_dotref
    param    u64   .pdot 
    local    i64   .offset 
    local    u64   .pname 
    local    u64   .a 
;------------------------
    load     u64   .pdot 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    loadimm  u64   1 
    jumpf    i64   #2059 
    loadimm  u64   0 
    store    u64   .pname 
    setcall        2
    loadref  u64   .pname 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_blockpcl.checkdotchain 2 0
    store    i64   .offset 
    loadref  u64   .offset 
    load     u64   .pdot 
    loadimm  i64   40 
    iloadx   u32   1 0
    addto    i64   
    load     u64   .pname 
    store    u64   .a 
    jump           #2058 
#2059:
    load     u64   .pdot 
    loadimm  i64   40 
    iloadx   u32   1 0
    store    i64   .offset 
#2058:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    load     i64   .offset 
    jumpf    i64   #2061 
    setcall        1
    load     i64   .offset 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_libpcl.genscaleoffset 2 0
    setarg   u64   2
    loadimm  i64   31 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2061:
#2060:
    setcall        1
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .pdot 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#2057:
    return         
end

proc mm_blockpcl.do_storedot
    param    u64   .pdot 
    param    u64   .pfield 
    param    u64   .rhs 
    local    i64   .offset 
    local    u64   .a 
    local    u64   .pname 
;------------------------
    setcall        1
    load     u64   .rhs 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .pdot 
    loadimm  i64   60 
    iloadx   u8    1 0
    jumpf    i64   #2064 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   23 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2064:
#2063:
    load     u64   .pdot 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    loadimm  u64   1 
    jumpf    i64   #2066 
    loadimm  u64   0 
    store    u64   .pname 
    setcall        2
    loadref  u64   .pname 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_blockpcl.checkdotchain 2 0
    store    i64   .offset 
    loadref  u64   .offset 
    load     u64   .pdot 
    loadimm  i64   40 
    iloadx   u32   1 0
    addto    i64   
    load     u64   .pname 
    store    u64   .a 
    jump           #2065 
#2066:
    load     u64   .pdot 
    loadimm  i64   40 
    iloadx   u32   1 0
    store    i64   .offset 
#2065:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        1
    load     i64   .offset 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_libpcl.genscaleoffset 2 0
    setarg   u64   2
    loadimm  i64   30 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .pdot 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#2062:
    return         
end

proc mm_blockpcl.checkdotchain
    rettype  i64   
    param    u64   .p 
    param    u64   .pname 
    local    i64   .offset 
    local    i64   .axmode 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   45 
    jumpeq   i64   #2069 
    jump           #2070 
#2069:
    setcall        2
    load     u64   .pname 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_blockpcl.checkdotchain 2 0
    store    i64   .offset 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    load     i64   .offset 
    add      i64   
    setret   i64   
    jump           #2067 
    jump           #2068 
#2070:
    load     u64   .p 
    load     u64   .pname 
    istore   u64   
    loadimm  i64   0 
    setret   i64   
    jump           #2067 
#2068:
    loadimm  i64   0 
    setret   i64   
    jump           #2067 
;------------------------
#2067:
    return         
end

proc mm_blockpcl.dx_convert
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    setcall        1
    load     u64   .p 
    loadimm  i64   52 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_libpcl.getpclmode 1 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
;------------------------
#2071:
    return         
end

proc mm_blockpcl.dx_shorten
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
;------------------------
#2072:
    return         
end

proc mm_blockpcl.dx_empty
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   26 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;------------------------
#2073:
    return         
end

proc mm_blockpcl.dx_switch
    param    u64   .p 
    param    u64   .pindex 
    param    u64   .pwhenthen 
    param    u64   .pelse 
    local    i64   .minlab 
    local    i64   .maxlab 
    local    i64   .n 
    local    i64   .iscomplex 
    local    i64   .i 
    local    i64   .lab_a 
    local    i64   .lab_b 
    local    i64   .lab_d 
    local    i64   .labjump 
    local    i64   .elselab 
    local    i64   .labstmt 
    local    i64   .ax 
    local    i64   .bx 
    local    i64   .ismult 
    local    i64   .loopsw 
    local    i64   .isref 
    local    u8:8008 .labels 
    local    u64   .w 
    local    u64   .wt 
;------------------------
    loadimm  i64   0 
    store    i64   .isref 
    load     u64   .p 
    iload    u8    
    loadimm  i64   108 
    eq       i64   
    store    i64   .loopsw 
    startmx        
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpeq   i64   #2075 
    load     i64   .loopsw 
    jumpt    i64   #2075 
    loadimm  i64   1 
    resetmx        
    jump           #2076 
#2075:
    loadimm  i64   0 
    endmx          
#2076:
    store    i64   .ismult 
    loadimm  i64   1000000 
    store    i64   .minlab 
    loadimm  i64   -1000000 
    store    i64   .maxlab 
    loadimm  i64   0 
    store    i64   .n 
    loadimm  i64   0 
    store    i64   .iscomplex 
    load     u64   .pwhenthen 
    store    u64   .wt 
    jump           #2078 
#2077:
    load     u64   .wt 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .w 
    jump           #2081 
#2080:
    load     u64   .w 
    iload    u8    
    loadimm  i64   17 
    jumpeq   i64   #2084 1
    loadimm  i64   1 
    jumpeq   i64   #2085 
    jump           #2086 
#2084:
    load     u64   .w 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .ax 
    load     u64   .w 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .bx 
;dorange::
#2087:
    load     i64   .ax 
    store    i64   .i 
    load     i64   .i 
    load     i64   .bx 
    jumpgt   i64   #2090 
#2088:
    load     i64   .i 
    load     i64   .minlab 
    min      i64   
    store    i64   .minlab 
    load     i64   .i 
    load     i64   .maxlab 
    max      i64   
    store    i64   .maxlab 
#2089:
    forup          #2088 1
    opnd           .i 
    opnd           .bx 
#2090:
    jump           #2083 
#2085:
    load     u64   .w 
    loadimm  i64   16 
    iloadx   i64   1 0
    double         
    store    i64   .bx 
    store    i64   .ax 
    jump           #2087 
    jump           #2083 
#2086:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        1
    load     u64   .w 
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Switch when2: not const: #"
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#2083:
    load     u64   .w 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .w 
#2081:
    load     u64   .w 
    jumpt    u64   #2080 
#2082:
    load     u64   .wt 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .wt 
#2078:
    load     u64   .wt 
    jumpt    u64   #2077 
#2079:
    load     i64   .maxlab 
    load     i64   .minlab 
    sub      i64   
    loadimm  i64   1 
    add      i64   
    store    i64   .n 
    load     i64   .n 
    loadimm  i64   1000 
    jumple   i64   #2093 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Switch too big"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2093:
#2092:
    load     i64   .loopsw 
    jumpf    i64   #2096 
    setcall        0
    callf    i64   mm_libpcl.definelabel 0 0
    store    i64   .lab_a 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
    setcall        3
    load     i64   .lab_d 
    setarg   i64   3
    load     i64   .lab_a 
    setarg   i64   2
    load     i64   .lab_a 
    setarg   i64   1
    callp          mm_libpcl.stacklooplabels 3 0
    jump           #2095 
#2096:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
#2095:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labjump 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .elselab 
    load     i64   .ismult 
    jumpf    i64   #2098 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2098:
#2097:
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .labjump 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   57 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     i64   .minlab 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  i16   1 0
    load     i64   .maxlab 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   22 
    istorex  i16   1 0
    setcall        2
    setcall        1
    load     i64   .elselab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .labjump 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    load     i64   .minlab 
    store    i64   .i 
    load     i64   .i 
    load     i64   .maxlab 
    jumpgt   i64   #2101 
#2099:
    setcall        2
    setcall        1
    load     i64   .elselab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   58 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     u64   mm_pcl.pccodex 
    loadref  u64   .labels 
    load     i64   .i 
    istorex  u64   8 0
#2100:
    forup          #2099 1
    opnd           .i 
    opnd           .maxlab 
#2101:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   59 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     u64   .pwhenthen 
    store    u64   .wt 
    jump           #2103 
#2102:
    setcall        0
    callf    i64   mm_libpcl.definelabel 0 0
    store    i64   .labstmt 
    load     u64   .wt 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .w 
    jump           #2106 
#2105:
    load     u64   .w 
    iload    u8    
    loadimm  i64   17 
    jumpeq   i64   #2109 1
    loadimm  i64   1 
    jumpeq   i64   #2110 
    jump           #2111 
#2109:
    load     u64   .w 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .ax 
    load     u64   .w 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .bx 
    jump           #2108 
#2110:
    load     u64   .w 
    loadimm  i64   16 
    iloadx   i64   1 0
    double         
    store    i64   .bx 
    store    i64   .ax 
    jump           #2108 
#2111:
#2108:
    load     i64   .ax 
    store    i64   .i 
    load     i64   .i 
    load     i64   .bx 
    jumpgt   i64   #2114 
#2112:
    load     i64   .labstmt 
    loadref  u64   .labels 
    load     i64   .i 
    iloadx   u64   8 0
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   0 
    istorex  i64   1 0
#2113:
    forup          #2112 1
    opnd           .i 
    opnd           .bx 
#2114:
    load     u64   .w 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .w 
#2106:
    load     u64   .w 
    jumpt    u64   #2105 
#2107:
    setcall        2
    load     i64   .isref 
    setarg   i64   2
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunitx 2 0
    load     i64   .ismult 
    jumpf    i64   #2116 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2116:
#2115:
    setcall        1
    startmx        
    load     i64   .loopsw 
    jumpf    i64   #2118 
    load     i64   .lab_a 
    resetmx        
    jump           #2117 
#2118:
    load     i64   .lab_d 
    endmx          
#2117:
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    load     u64   .wt 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .wt 
#2103:
    load     u64   .wt 
    jumpt    u64   #2102 
#2104:
    setcall        1
    load     i64   .elselab 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    load     u64   .pelse 
    jumpf    u64   #2120 
    setcall        2
    load     i64   .isref 
    setarg   i64   2
    load     u64   .pelse 
    setarg   u64   1
    callp          mm_blockpcl.evalunitx 2 0
    load     i64   .ismult 
    jumpf    i64   #2122 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2122:
#2121:
#2120:
#2119:
    load     i64   .loopsw 
    jumpf    i64   #2124 
    setcall        1
    load     i64   .lab_a 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadref  u64   mm_libpcl.loopindex 
    decrto   i64   1
    jump           #2123 
#2124:
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
#2123:
;------------------------
#2074:
    return         
end

proc mm_blockpcl.dx_assem
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        2
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_libpcl.genassem 1 0
    setarg   u64   2
    loadimm  i64   143 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#2125:
    return         
end

proc mm_blockpcl.dx_case
    param    u64   .p 
    param    u64   .pindex 
    param    u64   .pwhenthen 
    param    u64   .pelse 
    local    u8:4000 .labtable 
    local    u8:4000 .unittable 
    local    i64   .ncases 
    local    i64   .opc 
    local    i64   .ismult 
    local    i64   .isref 
    local    i64   .loopsw 
    local    i64   .lab_abc 
    local    i64   .lab_d 
    local    i64   .fmult 
    local    i64   .labnextwhen 
    local    i64   .labstmtstart 
    local    i64   .labelse 
    local    u64   .w 
    local    u64   .wt 
    local    i64   .i 
;------------------------
    loadimm  i64   0 
    store    i64   .isref 
    load     u64   .p 
    iload    u8    
    loadimm  i64   106 
    eq       i64   
    store    i64   .loopsw 
    load     u64   .pindex 
    loadimm  u64   0 
    jumpne   u64   #2128 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "EMPTY CASE NOT DONE"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2128:
#2127:
    startmx        
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpeq   i64   #2130 
    load     i64   .loopsw 
    jumpt    i64   #2130 
    loadimm  i64   1 
    resetmx        
    jump           #2131 
#2130:
    loadimm  i64   0 
    endmx          
#2131:
    store    i64   .ismult 
    load     i64   .loopsw 
    jumpf    i64   #2133 
    setcall        0
    callf    i64   mm_libpcl.definelabel 0 0
    store    i64   .lab_abc 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
    setcall        3
    load     i64   .lab_d 
    setarg   i64   3
    load     i64   .lab_abc 
    setarg   i64   2
    load     i64   .lab_abc 
    setarg   i64   1
    callp          mm_libpcl.stacklooplabels 3 0
    jump           #2132 
#2133:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
#2132:
    load     i64   .ismult 
    jumpf    i64   #2135 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2135:
#2134:
    loadimm  i64   0 
    store    i64   .ncases 
    load     u64   .pwhenthen 
    loadimm  u64   0 
    jumpne   u64   #2137 
    load     i64   .ismult 
    jumpf    i64   #2139 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "case"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2139:
#2138:
    jump           #2141 
#2137:
#2136:
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     i64   mm_blockpcl.casedepth 
    loadimm  i64   20 
    jumplt   i64   #2143 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "case nested too deeply"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2143:
#2142:
    load     u64   .p 
    loadref  u64   mm_blockpcl.casestmt 
    loadref  u64   mm_blockpcl.casedepth 
    incrload i64   1
    istorex  u64   8 -8
    load     u64   .pwhenthen 
    store    u64   .wt 
    jump           #2146 
#2145:
    load     u64   .wt 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .w 
    load     i64   .ncases 
    loadimm  i64   500 
    jumplt   i64   #2149 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "too many cases"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2149:
#2148:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    loadref  u64   .labtable 
    loadref  u64   .ncases 
    incrload i64   1
    istorex  i64   8 -8
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadref  u64   .unittable 
    load     i64   .ncases 
    istorex  u64   8 -8
    jump           #2152 
#2151:
    setcall        1
    load     u64   .w 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    loadref  u64   .labtable 
    load     i64   .ncases 
    iloadx   i64   8 -8
    double         
    load     u64   .w 
    loadimm  i64   40 
    istorex  i32   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     u64   .w 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpt    u64   #2156 
    load     u64   .wt 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #2155 
#2156:
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
#2155:
#2154:
    setcall        1
    load     u64   .w 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    load     u64   .w 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .w 
#2152:
    load     u64   .w 
    jumpt    u64   #2151 
#2153:
    load     u64   .wt 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .wt 
#2146:
    load     u64   .wt 
    jumpt    u64   #2145 
#2147:
;skip::
#2141:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labelse 
    load     i64   .labelse 
    loadref  u64   mm_blockpcl.caseelse 
    load     i64   mm_blockpcl.casedepth 
    istorex  i64   8 -8
    setcall        1
    load     i64   .labelse 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .ncases 
    loadimm  i64   1 
    jumplt   i64   #2159 
#2157:
    setcall        1
    loadref  u64   .labtable 
    load     i64   .i 
    iloadx   i64   8 -8
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        2
    load     i64   .isref 
    setarg   i64   2
    loadref  u64   .unittable 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_blockpcl.evalunitx 2 0
    load     i64   .ismult 
    jumpf    i64   #2161 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2161:
#2160:
    load     i64   .loopsw 
    jumpf    i64   #2163 
    setcall        1
    load     i64   .lab_abc 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    jump           #2162 
#2163:
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
#2162:
#2158:
    forup          #2157 1
    opnd           .i 
    opnd           .ncases 
#2159:
    setcall        1
    load     i64   .labelse 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    load     u64   .pelse 
    jumpf    u64   #2165 
    setcall        2
    load     i64   .isref 
    setarg   i64   2
    load     u64   .pelse 
    setarg   u64   1
    callp          mm_blockpcl.evalunitx 2 0
    load     i64   .ismult 
    jumpf    i64   #2167 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2167:
#2166:
#2165:
#2164:
    load     i64   .loopsw 
    jumpf    i64   #2169 
    setcall        1
    load     i64   .lab_abc 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadref  u64   mm_libpcl.loopindex 
    decrto   i64   1
    jump           #2168 
#2169:
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
#2168:
    loadref  u64   mm_blockpcl.casedepth 
    decrto   i64   1
;------------------------
#2126:
    return         
end

proc mm_blockpcl.dx_syscall
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .opc 
;------------------------
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "SYSCALL"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    loadimm  i64   29 
    jumpeq   i64   #2173 1
    loadimm  i64   30 
    jumpeq   i64   #2174 1
    loadimm  i64   31 
    jumpeq   i64   #2175 
    jump           #2176 
#2173:
    setcall        2
    setcall        1
    load     u64   mm_libpcl.stnprocs 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   18 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #2172 
#2174:
    setcall        2
    setcall        1
    load     u64   mm_libpcl.stprocname 
    setarg   u64   1
    callf    u64   mm_libpcl.genmemaddr 1 0
    setarg   u64   2
    loadimm  i64   19 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;doprocname::
#2177:
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        2
    loadimm  i64   -8 
    setarg   i64   2
    loadimm  i64   8 
    setarg   i64   1
    callf    u64   mm_libpcl.genscaleoffset 2 0
    setarg   u64   2
    loadimm  i64   29 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #2172 
#2175:
    setcall        2
    setcall        1
    load     u64   mm_libpcl.stprocaddr 
    setarg   u64   1
    callf    u64   mm_libpcl.genmemaddr 1 0
    setarg   u64   2
    loadimm  i64   19 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2177 
    unload   u64   
    jump           #2172 
#2176:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    loadref  u64   mm_tables.sysfnnames 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    iloadx   u64   8 -8
    setarg   u64   2
    loadimm  u64   "Syscall? "
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#2172:
;------------------------
#2170:
    return         
end

proc mm_blockpcl.dx_dotindex
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   60 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#2179:
    return         
end

proc mm_blockpcl.dx_dotslice
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .b 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   62 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#2180:
    return         
end

proc mm_blockpcl.dx_typepun
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    jumpne   i64   #2183 
    jump           #2181 
#2183:
#2182:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   136 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    setcall        1
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_libpcl.getpclmode 1 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
;------------------------
#2181:
    return         
end

proc mm_blockpcl.dx_select
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    u8:2048 .labels 
    local    i64   .labend 
    local    i64   .labjump 
    local    i64   .n 
    local    i64   .i 
    local    i64   .elselab 
    local    i64   .labstmt 
    local    i64   .ismult 
    local    i64   .isref 
    local    u64   .q 
;------------------------
    loadimm  i64   0 
    store    i64   .isref 
    startmx        
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpeq   i64   #2185 
    load     u64   .p 
    loadimm  i64   60 
    iloadx   u8    1 0
    jumpf    i64   #2185 
    loadimm  i64   1 
    resetmx        
    jump           #2186 
#2185:
    loadimm  i64   0 
    endmx          
#2186:
    store    i64   .ismult 
    load     u64   .b 
    store    u64   .q 
    loadimm  i64   0 
    store    i64   .n 
    jump           #2188 
#2187:
    load     i64   .n 
    loadimm  i64   256 
    jumplt   i64   #2191 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "selectx: too many labels"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2191:
#2190:
    loadref  u64   .n 
    incrto   i64   1
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#2188:
    load     u64   .q 
    jumpt    u64   #2187 
#2189:
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labend 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labjump 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .elselab 
    load     i64   .ismult 
    jumpf    i64   #2194 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2194:
#2193:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .labjump 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   57 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  i16   1 0
    load     i64   .n 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   22 
    istorex  i16   1 0
    setcall        2
    setcall        1
    load     i64   .elselab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .labjump 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    load     u64   .b 
    store    u64   .q 
    loadimm  i64   0 
    store    i64   .i 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .n 
    loadimm  i64   1 
    jumplt   i64   #2197 
#2195:
    setcall        2
    setcall        1
    load     i64   .elselab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   58 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     u64   mm_pcl.pccodex 
    loadref  u64   .labels 
    load     i64   .i 
    istorex  u64   8 -8
#2196:
    forup          #2195 1
    opnd           .i 
    opnd           .n 
#2197:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   59 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     u64   .b 
    store    u64   .q 
    loadimm  i64   0 
    store    i64   .i 
    jump           #2199 
#2198:
    setcall        0
    callf    i64   mm_libpcl.definelabel 0 0
    store    i64   .labstmt 
    loadref  u64   .i 
    incrto   i64   1
    load     i64   .labstmt 
    loadref  u64   .labels 
    load     i64   .i 
    iloadx   u64   8 -8
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   0 
    istorex  i64   1 0
    setcall        2
    load     i64   .isref 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunitx 2 0
    load     i64   .ismult 
    jumpf    i64   #2202 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2202:
#2201:
    setcall        1
    load     i64   .labend 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#2199:
    load     u64   .q 
    jumpt    u64   #2198 
#2200:
    setcall        1
    load     i64   .elselab 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        2
    load     i64   .isref 
    setarg   i64   2
    load     u64   .c 
    setarg   u64   1
    callp          mm_blockpcl.evalunitx 2 0
    load     i64   .ismult 
    jumpf    i64   #2204 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2204:
#2203:
    setcall        1
    load     i64   .labend 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
;------------------------
#2184:
    return         
end

proc mm_blockpcl.dx_cmpchain
    param    u64   .p 
    param    u64   .q 
    param    u64   .b 
    param    u64   .c 
    local    i64   .lab1 
    local    i64   .lab2 
    local    i64   .i 
    local    i64   .cond 
    local    u64   .r 
;------------------------
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab1 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab2 
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
    loadimm  i64   1 
    store    i64   .i 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    jump           #2207 
#2206:
    setcall        1
    load     u64   .r 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .p 
    loadimm  i64   40 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   1
    callf    i64   mm_blockpcl.reversecond 1 0
    store    i64   .cond 
    load     u64   .r 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #2210 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .cond 
    setarg   i64   1
    callf    i64   mm_blockpcl.reversecond_order 1 0
    store    i64   .cond 
#2210:
#2209:
    setcall        3
    setcall        1
    load     i64   .lab1 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   3
    load     i64   .cond 
    setarg   i64   2
    loadimm  i64   46 
    setarg   i64   1
    callp          mm_libpcl.genpc_cond 3 0
    load     u64   .r 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #2212 
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
#2212:
#2211:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    loadref  u64   .i 
    incrto   i64   1
    load     u64   .r 
    store    u64   .q 
    load     u64   .r 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
#2207:
    load     u64   .r 
    jumpt    u64   #2206 
#2208:
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        2
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   44 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .lab1 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .lab2 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
;------------------------
#2205:
    return         
end

proc mm_blockpcl.genloadint
    param    i64   .n 
;------------------------
    setcall        2
    setcall        1
    load     i64   .n 
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   20 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#2213:
    return         
end

proc mm_blockpcl.dx_andl
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .labfalse 
    local    i64   .labend 
;------------------------
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labfalse 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labend 
    setcall        3
    load     i64   .labfalse 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        3
    load     i64   .labfalse 
    setarg   i64   3
    load     u64   .b 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .labend 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    setcall        1
    load     i64   .labfalse 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .labend 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
;------------------------
#2214:
    return         
end

proc mm_blockpcl.dx_orl
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .labtrue 
    local    i64   .labfalse 
    local    i64   .labend 
;------------------------
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labtrue 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labfalse 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .labend 
    setcall        3
    load     i64   .labtrue 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    loadimm  i64   52 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        3
    load     i64   .labfalse 
    setarg   i64   3
    load     u64   .b 
    setarg   u64   2
    loadimm  i64   53 
    setarg   i64   1
    callp          mm_blockpcl.genjumpcond 3 0
    setcall        1
    load     i64   .labtrue 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .labend 
    setarg   i64   1
    callp          mm_blockpcl.genjumpl 1 0
    setcall        1
    load     i64   .labfalse 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          mm_blockpcl.genloadint 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .labend 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
;------------------------
#2215:
    return         
end

proc mm_blockpcl.dx_notl
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#2216:
    return         
end

proc mm_blockpcl.dx_forall
    param    u64   .p 
    param    u64   .pindex 
    param    u64   .plist 
    param    u64   .pbody 
    local    u64   .plocal 
    local    u64   .pfrom 
    local    u64   .pto 
    local    u64   .pelse 
    local    u64   .px 
    local    u64   .plimit 
    local    u64   .passign 
    local    i64   .lab_b 
    local    i64   .lab_c 
    local    i64   .lab_d 
    local    i64   .lab_e 
    local    i64   .a 
    local    i64   .b 
    local    i64   .down 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   96 
    eq       i64   
    store    i64   .down 
    load     u64   .pindex 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .plocal 
    load     u64   .plocal 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pfrom 
    load     u64   .pfrom 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pto 
    load     u64   .plist 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .passign 
    load     u64   .pbody 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pelse 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_b 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_c 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_d 
    load     u64   .pelse 
    jumpf    u64   #2219 
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   .lab_e 
    jump           #2218 
#2219:
    load     i64   .lab_d 
    store    i64   .lab_e 
#2218:
    setcall        3
    load     i64   .lab_d 
    setarg   i64   3
    load     i64   .lab_c 
    setarg   i64   2
    load     i64   .lab_b 
    setarg   i64   1
    callp          mm_libpcl.stacklooplabels 3 0
    setcall        1
    load     u64   .pfrom 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     u64   .pindex 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   21 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
    load     u64   .pfrom 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #2221 
    load     u64   .pto 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #2221 
    load     u64   .pfrom 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .a 
    load     u64   .pto 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .b 
    load     i64   .down 
    jumpf    i64   #2225 
    load     i64   .a 
    load     i64   .b 
    jumpge   i64   #2224 
#2225:
    load     i64   .down 
    jumpt    i64   #2223 
    load     i64   .a 
    load     i64   .b 
    jumpgt   i64   #2223 
#2224:
    jump           #2222 
#2223:
    setcall        2
    setcall        1
    load     i64   .lab_e 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   44 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2222:
    jump           #2220 
#2221:
    load     u64   .pfrom 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #2227 
    setcall        1
    load     u64   .pfrom 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .pto 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab_e 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    startmx        
    load     i64   .down 
    jumpf    i64   #2229 
    loadimm  i64   51 
    resetmx        
    jump           #2228 
#2229:
    loadimm  i64   48 
    endmx          
#2228:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2226 
#2227:
    setcall        1
    load     u64   .pfrom 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .pto 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    setcall        1
    load     i64   .lab_e 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    startmx        
    load     i64   .down 
    jumpf    i64   #2231 
    loadimm  i64   48 
    resetmx        
    jump           #2230 
#2231:
    loadimm  i64   51 
    endmx          
#2230:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#2226:
    setcall        1
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
#2220:
    setcall        1
    load     i64   .lab_b 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadimm  i64   0 
    load     u64   .passign 
    loadimm  i64   60 
    istorex  u8    1 0
    setcall        1
    load     u64   .passign 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     u64   .pbody 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        1
    load     i64   .lab_c 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        2
    setcall        1
    load     i64   .lab_b 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    startmx        
    load     i64   .down 
    jumpf    i64   #2233 
    loadimm  i64   55 
    resetmx        
    jump           #2232 
#2233:
    loadimm  i64   54 
    endmx          
#2232:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   1 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  i32   1 0
    setcall        2
    setcall        1
    load     u64   .pindex 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     u64   .pto 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #2235 1
    loadimm  i64   3 
    jumpeq   i64   #2236 
    jump           #2237 
#2235:
    setcall        2
    setcall        1
    load     u64   .pto 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2234 
#2236:
    setcall        2
    setcall        1
    load     u64   .pto 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   147 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2234 
#2237:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "forall/to: not const or name"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2234:
    load     u64   .pelse 
    jumpf    u64   #2240 
    setcall        1
    load     i64   .lab_e 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        1
    load     u64   .pelse 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
#2240:
#2239:
    setcall        1
    load     i64   .lab_d 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    loadref  u64   mm_libpcl.loopindex 
    decrto   i64   1
;------------------------
#2217:
    return         
end

proc mm_blockpcl.dx_assignmm
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        1
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.pushrhs 1 0
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.poptomult 1 0
;------------------------
#2241:
    return         
end

proc mm_blockpcl.pushrhs
    param    u64   .a 
;------------------------
    load     u64   .a 
    loadimm  u64   0 
    jumpne   u64   #2244 
    jump           #2242 
#2244:
#2243:
    setcall        1
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.pushrhs 1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
;------------------------
#2242:
    return         
end

proc mm_blockpcl.poptomult
    param    u64   .a 
;------------------------
#2246:
    load     u64   .a 
    iload    u8    
    switch         #2250 3 110
    opnd           #2251 
#2250:
    swlabel        #2252 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2253 
    swlabel        #2253 
    swlabel        #2253 
    swlabel        #2256 
    swlabel        #2251 
    swlabel        #2254 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2255 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2255 
    swlabel        #2251 
    swlabel        #2255 
    swlabel        #2251 
    swlabel        #2251 
    swlabel        #2255 
    endsw          
#2252:
    setcall        2
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   21 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2249 
#2253:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   28 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2249 
#2254:
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   28 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2249 
#2255:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   28 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2249 
#2256:
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalref 1 0
    setcall        1
    load     u64   .a 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   63 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #2257 
    unload   u64   
    jump           #2249 
#2251:
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_tables.jtagnames 
    load     u64   .a 
    iload    u8    
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Bad mult assign element"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2249:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_libpcl.setmode_u 1 0
;skipmode::
#2257:
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .a 
#2247:
    load     u64   .a 
    loadimm  u64   0 
    jumpne   u64   #2246 
#2248:
;------------------------
#2245:
    return         
end

proc mm_blockpcl.dx_debug
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   144 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  u8    1 0
;------------------------
#2259:
    return         
end

proc mm_blockpcl.dx_assignms
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    local    i64   .nlhs 
    local    i64   .nrhs 
    local    i64   .bmode 
    local    u64   .d 
    local    i64   .i 
;------------------------
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .bmode 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .bmode 
    iloadx   i32   4 0
    loadimm  i64   28 
    jumpeq   i64   #2262 1
    loadimm  i64   11 
    jumpeq   i64   #2263 
    jump           #2264 
#2262:
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #2266 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "multassign from fn: not simple fn"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2266:
#2265:
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    loadref  u64   mm_decls.ttlength 
    load     i64   .bmode 
    iloadx   i32   4 0
    store    i64   .nrhs 
    jump           #2261 
#2263:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "DECONSTR SLICE NOT READY"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    jump           #2261 
#2264:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "(a,b):=x; var only"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#2261:
    load     u64   .a 
    iload    u8    
    loadimm  i64   16 
    jumpne   i64   #2271 
    load     u64   .a 
    loadimm  i64   40 
    iloadx   u32   1 0
    store    i64   .nlhs 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    jump           #2270 
#2271:
    loadimm  i64   1 
    store    i64   .nlhs 
#2270:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.poptomult 1 0
    load     i64   .nrhs 
    load     i64   .nlhs 
    jumple   i64   #2273 
    load     i64   .nlhs 
    loadimm  i64   1 
    add      i64   
    store    i64   .i 
    load     i64   .i 
    load     i64   .nrhs 
    jumpgt   i64   #2276 
#2274:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   22 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadref  u64   mm_decls.ttmult 
    load     i64   .bmode 
    iloadx   u64   8 0
    load     i64   .i 
    iloadx   i32   4 -4
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#2275:
    forup          #2274 1
    opnd           .i 
    opnd           .nrhs 
#2276:
#2273:
#2272:
;------------------------
#2260:
    return         
end

proc mm_diags.printoverloads
    param    u64   .f 
    local    u64   .p 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "OVERLOADS"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
#2279:
    loadref  u64   mm_decls.overloadtable 
    load     i64   .i 
    iloadx   u64   8 0
    store    u64   .p 
    load     u64   .p 
    jumpf    u64   #2283 
    jump           #2285 
#2284:
    load     u64   .p 
    loadimm  i64   4 
    iloadx   i32   1 0
    jumpf    i64   #2288 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "operator (#)(#,#)#"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_tables.jtagnames 
    load     i64   .i 
    iloadx   u64   8 0
    loadimm  i64   2 
    addptrx  u64   1 0
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    iload    i32   
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   4 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   8 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2287 
#2288:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "operator (#)(#)#"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_tables.jtagnames 
    load     i64   .i 
    iloadx   u64   8 0
    loadimm  i64   2 
    addptrx  u64   1 0
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    iload    i32   
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   8 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2287:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    jumpf    u64   #2292 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "="
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    callp          msys.m$print_ptr_nf 1 0
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2292:
#2291:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .p 
#2285:
    load     u64   .p 
    jumpt    u64   #2284 
#2286:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2283:
#2282:
#2280:
    forup          #2279 1
    opnd           .i 
    opnd           127 
#2281:
;------------------------
#2277:
    return         
end

proc mm_diags.printst
    param    u64   .f 
    param    u64   .p 
    param    i64   .level 
    local    u64   .q 
;------------------------
    load     u64   .p 
    loadimm  i64   69 
    iloadx   u8    1 0
    loadimm  i64   80 
    jumpeq   i64   #2296 
    setcall        1
    loadimm  u64   "PRINTST not name"
    setarg   u64   1
    callp          mm_support.mcerror 1 0
#2296:
#2295:
    setcall        3
    load     i64   .level 
    setarg   i64   3
    load     u64   .p 
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callp          mm_diags.printstrec 3 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #2299 
#2298:
    setcall        3
    load     i64   .level 
    loadimm  i64   1 
    add      i64   
    setarg   i64   3
    load     u64   .q 
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callp          mm_diags.printst 3 0
    load     u64   .q 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .q 
#2299:
    load     u64   .q 
    loadimm  u64   0 
    jumpne   u64   #2298 
#2300:
;------------------------
#2294:
    return         
end

proc mm_diags.printstrec
    param    u64   .f 
    param    u64   .p 
    param    i64   .level 
    local    u8:193 .dd 
    local    u64   .q 
    local    u8:16 .v 
    local    u64   .d 
    local    i64   .col 
    local    i64   .offset 
    local    i64   .n 
    local    u8:256 .str 
    local    i64   .$av_1 
;------------------------
    loadref  u64   .v 
    store    u64   .d 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_init 1 0
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .p 
    callp          msys.m$print_ptr_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    loadimm  i64   0 
    store    i64   .offset 
    load     i64   .level 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #2305 
#2303:
    setcall        2
    loadimm  u64   "    "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    loadref  u64   .offset 
    loadimm  i64   4 
    addto    i64   
#2304:
    to             #2303 
    opnd           .$av_1 
#2305:
    setcall        2
    loadimm  u64   ":"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        4
    loadimm  i64   45 
    setarg   i64   4
    loadimm  i64   28 
    load     i64   .offset 
    sub      i64   
    setarg   i64   3
    load     u64   .p 
    iload    u64   
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_leftstr 4 0
    setcall        4
    loadimm  i64   46 
    setarg   i64   4
    loadimm  i64   12 
    setarg   i64   3
    loadref  u64   mm_tables.namenames 
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    iloadx   u64   8 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_leftstr 4 0
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    i64   mlib.gs_getcol 1 0
    store    i64   .col 
    load     u64   .p 
    iload    u8:193 
    store    u8:193 .dd 
    setcall        2
    loadimm  u64   "["
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    load     u64   .p 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   7 
    loadbit        
    jumpf    u64   #2310 
    setcall        2
    loadimm  u64   "Imp "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    jump           #2309 
#2310:
    setcall        2
    startmx        
    load     u64   .p 
    loadimm  i64   191 
    iloadx   u8    1 0
    switch         #2313 1 3
    opnd           #2314 
#2313:
    swlabel        #2315 
    swlabel        #2317 
    swlabel        #2319 
    endsw          
#2315:
    loadimm  u64   "Sub "
    resetmx        
    jump           #2312 
#2317:
    loadimm  u64   "Prog "
    resetmx        
    jump           #2312 
#2319:
    loadimm  u64   "Exp "
    resetmx        
    jump           #2312 
#2314:
    loadimm  u64   "Mod "
    endmx          
#2312:
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2309:
    loadref  u64   mm_decls.ttisblock 
    loadref  u64   .dd 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #2323 
    loadref  u64   .dd 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpeq   i64   #2324 1
    loadimm  i64   7 
    jumpne   i64   #2323 
#2324:
    setcall        2
    loadimm  u64   "PROC/DLL HAS Block MODE "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2323:
#2322:
    loadref  u64   .dd 
    loadimm  i64   114 
    iloadx   u8    1 0
    jumpf    i64   #2327 
    setcall        2
    loadref  u64   mm_tables.fflangnames 
    loadref  u64   .dd 
    loadimm  i64   114 
    iloadx   u8    1 0
    iloadx   u64   8 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strsp 2 0
#2327:
#2326:
    loadref  u64   .dd 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   13 
    jumpne   i64   #2329 
    loadref  u64   .dd 
    loadimm  i64   152 
    iloadx   u8    1 0
    jumpf    i64   #2329 
    setcall        2
    loadref  u64   mm_tables.parammodenames 
    loadref  u64   .dd 
    loadimm  i64   152 
    iloadx   u8    1 0
    iloadx   u64   8 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2329:
#2328:
    loadref  u64   .dd 
    loadimm  i64   141 
    iloadx   u8    1 0
    jumpf    i64   #2331 
    setcall        2
    loadimm  u64   "@@"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadref  u64   .dd 
    loadimm  i64   141 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    setcall        2
    loadimm  u64   " maxalign:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadref  u64   .dd 
    loadimm  i64   160 
    iloadx   i16   1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2331:
#2330:
    loadref  u64   .dd 
    loadimm  i64   153 
    iloadx   u8    1 0
    jumpf    i64   #2336 
    setcall        2
    loadimm  u64   "Opt "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2336:
#2335:
    loadref  u64   .dd 
    loadimm  i64   116 
    iloadx   u8    1 0
    jumpf    i64   #2339 
    setcall        2
    loadimm  u64   "Var:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadref  u64   .dd 
    loadimm  i64   116 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2339:
#2338:
    loadref  u64   .dd 
    loadimm  i64   86 
    iloadx   u8    1 0
    jumpf    i64   #2343 
    loadref  u64   .dd 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpeq   i64   #2345 
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "Modno#"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadref  u64   .dd 
    loadimm  i64   86 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2344 
#2345:
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "Subno#"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadref  u64   .dd 
    loadimm  i64   87 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#2344:
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2343:
#2342:
    loadref  u64   .dd 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   0 
    loadbit        
    jumpf    u64   #2349 
    setcall        2
    loadimm  u64   "U "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2349:
#2348:
    loadref  u64   .dd 
    loadimm  i64   117 
    iloadx   u8    1 0
    jumpf    i64   #2352 
    setcall        2
    loadimm  u64   "Threaded "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2352:
#2351:
    setcall        2
    loadimm  u64   "]"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        3
    loadimm  i64   61 
    setarg   i64   3
    load     i64   .col 
    loadimm  i64   10 
    add      i64   
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_padto 3 0
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #2356 
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "(#)"
    callp          msys.m$print_setfmt 1 0
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        4
    loadimm  i64   45 
    setarg   i64   4
    loadimm  i64   18 
    setarg   i64   3
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_leftstr 4 0
    jump           #2355 
#2356:
    setcall        4
    loadimm  i64   45 
    setarg   i64   4
    loadimm  i64   18 
    setarg   i64   3
    loadimm  u64   "()"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_leftstr 4 0
#2355:
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpeq   i64   #2360 
    jump           #2361 
#2360:
    setcall        2
    loadimm  u64   "Void "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    jump           #2359 
#2361:
    setcall        2
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    setcall        2
    loadimm  u64   ":"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2359:
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   14 
    jumpeq   i64   #2366 1
    loadimm  i64   13 
    jumpeq   i64   #2366 1
    loadimm  i64   15 
    jumpeq   i64   #2367 1
    loadimm  i64   6 
    jumpeq   i64   #2368 1
    loadimm  i64   9 
    jumpeq   i64   #2368 1
    loadimm  i64   7 
    jumpeq   i64   #2369 1
    loadimm  i64   11 
    jumpeq   i64   #2370 1
    loadimm  i64   12 
    jumpeq   i64   #2371 1
    loadimm  i64   10 
    jumpeq   i64   #2372 1
    loadimm  i64   5 
    jumpeq   i64   #2373 1
    loadimm  i64   16 
    jumpeq   i64   #2374 1
    loadimm  i64   4 
    jumpeq   i64   #2375 
    jump           #2376 
#2366:
    setcall        2
    loadimm  u64   " Offset:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   76 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   27 
    jumpne   i64   #2379 
    setcall        2
    loadimm  u64   " Bitoffset:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   142 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    setcall        2
    loadimm  u64   ":"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   140 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
#2379:
#2378:
    setcall        4
    load     u64   .p 
    loadimm  i64   128 
    addptrx  u64   1 0
    setarg   u64   4
    load     u64   .p 
    loadimm  i64   135 
    iloadx   u8    1 0
    setarg   i64   3
    loadimm  u64   "%.*s"
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          sprintf 4 3
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "v"
    load     u64   .p 
    loadimm  i64   135 
    iloadx   u8    1 0
    callp          msys.m$print_i64 2 0
    loadimm  u64   ".*"
    load     u64   .p 
    loadimm  i64   128 
    addptrx  u64   1 0
    callp          msys.m$print_str 2 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   " UFLAGS:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadimm  u64   "-"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   135 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #2388 
    setcall        2
    loadimm  u64   "/:="
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strvar 2 0
#2388:
#2387:
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   13 
    jumpne   i64   #2391 
    load     u64   .p 
    loadimm  i64   154 
    iloadx   u8    1 0
    jumpf    i64   #2391 
    setcall        2
    loadimm  u64   "..."
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2391:
#2390:
    jump           #2365 
#2367:
    setcall        2
    loadimm  u64   "Index:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   76 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    jump           #2365 
#2368:
    setcall        2
    loadimm  u64   "Index:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   72 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    setcall        2
    loadimm  u64   " Nret:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   115 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    jump           #2365 
#2369:
    setcall        2
    loadimm  u64   "Index/PCaddr:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   72 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    load     u64   .p 
    loadimm  i64   96 
    iloadx   u64   1 0
    jumpf    u64   #2397 
    setcall        2
    loadimm  u64   " Truename:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   96 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2397:
#2396:
    jump           #2365 
#2370:
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #2400 
    setcall        2
    loadimm  u64   "="
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strvar 2 0
#2400:
#2399:
    jump           #2365 
#2371:
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #2403 
    setcall        2
    loadimm  u64   ":="
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strvar 2 0
#2403:
#2402:
    jump           #2365 
#2372:
    setcall        2
    loadimm  u64   "Const:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strvar 2 0
    jump           #2365 
#2373:
    load     u64   .p 
    loadimm  i64   136 
    iloadx   i32   1 0
    jumpf    i64   #2407 
    setcall        2
    loadimm  u64   "Baseclass:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadimm  u64   "<HAS BASECLASS>"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#2407:
#2406:
    jump           #2365 
#2374:
    setcall        2
    loadimm  u64   "Enum:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   72 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    jump           #2365 
#2375:
    setcall        2
    loadimm  u64   "DLL#:"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   113 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
    jump           #2365 
#2376:
#2365:
    load     u64   .p 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   4 
    loadbit        
    jumpf    u64   #2413 
    setcall        2
    loadimm  u64   " @"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   120 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadimm  u64   " +"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   143 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
#2413:
#2412:
    load     u64   .p 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   5 
    loadbit        
    jumpf    u64   #2417 
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   88 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_strvar 2 0
#2417:
#2416:
    setcall        2
    loadimm  u64   " Lineno: ???"
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .f 
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_println 2 0
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   10 
    jumpeq   i64   #2420 1
    loadimm  i64   12 
    jumpeq   i64   #2420 1
    loadimm  i64   11 
    jumpeq   i64   #2420 1
    loadimm  i64   18 
    jumpeq   i64   #2420 
    jump           #2421 
#2420:
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #2423 
    setcall        4
    load     u64   .f 
    setarg   u64   4
    loadimm  u64   "*"
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_diags.printunit 4 0
#2423:
#2422:
    jump           #2419 
#2421:
#2419:
;------------------------
#2301:
    return         
end

proc mm_diags.printstflat
    param    u64   .f 
    local    i64   .i 
    local    u64   .p 
    local    i64   .$av_1 
;------------------------
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "GLOBAL SYMBOL TABLE:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   0 
    store    i64   .i 
#2427:
    loadref  u64   mm_lex.hashtable 
    load     i64   .i 
    addptrx  u64   8 0
    store    u64   .p 
    load     u64   .p 
    iload    u64   
    jumpf    u64   #2431 
    load     u64   .p 
    loadimm  i64   69 
    iloadx   u8    1 0
    loadimm  i64   80 
    jumpeq   i64   #2433 
    jump           #2434 
#2433:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     i64   .i 
    callp          msys.m$print_i64_nf 1 0
    load     u64   .p 
    callp          msys.m$print_ptr_nf 1 0
    loadimm  u64   ":"
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.symbolnames 
    load     u64   .p 
    loadimm  i64   69 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.namenames 
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .p 
    jump           #2437 
#2436:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "\t"
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    callp          msys.m$print_ptr_nf 1 0
    load     u64   .p 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.symbolnames 
    load     u64   .p 
    loadimm  i64   69 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.namenames 
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "(From"
    callp          msys.m$print_str_nf 1 0
    startmx        
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #2442 
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    resetmx        
    jump           #2441 
#2442:
    loadimm  u64   "-"
    endmx          
#2441:
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   ")"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .p 
#2437:
    load     u64   .p 
    jumpt    u64   #2436 
#2438:
    jump           #2432 
#2434:
#2432:
#2431:
#2430:
#2428:
    forup          #2427 1
    opnd           .i 
    opnd           65534 
#2429:
;------------------------
#2425:
    return         
end

proc mm_diags.printcode
    param    u64   .f 
    param    u64   .caption 
    local    u64   .p 
    local    u64   .pp 
;------------------------
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #2447 
#2446:
    load     u64   .pp 
    iload    u64   
    store    u64   .p 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   .p 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   "="
    callp          msys.m$print_str_nf 1 0
    startmx        
    load     u64   .p 
    loadimm  i64   191 
    iloadx   u8    1 0
    switch         #2451 1 3
    opnd           #2452 
#2451:
    swlabel        #2453 
    swlabel        #2455 
    swlabel        #2457 
    endsw          
#2453:
    loadimm  u64   "Sub"
    resetmx        
    jump           #2450 
#2455:
    loadimm  u64   "Prog"
    resetmx        
    jump           #2450 
#2457:
    loadimm  u64   "Exp"
    resetmx        
    jump           #2450 
#2452:
    loadimm  u64   "Mod"
    endmx          
#2450:
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   5 
    jumpne   i64   #2461 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " in record"
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2461:
#2460:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        4
    load     u64   .f 
    setarg   u64   4
    loadimm  u64   "1"
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_diags.printunit 4 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#2447:
    load     u64   .pp 
    jumpt    u64   #2446 
#2448:
;------------------------
#2445:
    return         
end

proc mm_diags.printunit
    param    u64   .p 
    param    i64   .level 
    param    u64   .prefix 
    param    u64   .dev 
    local    u64   .q 
    local    u64   .d 
    local    i64   .t 
    local    u64   .idname 
    local    i64   .a 
    local    r32   .x32 
    local    i64   .$av_1 
    local    u8:16 .opndno 
    local    i64   .$av_2 
    local    i64   .i 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #2466 
    jump           #2464 
#2466:
#2465:
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    jumpf    i64   #2468 
    setcall        1
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    store    i64   mm_diags.currlineno 
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    loadimm  i64   24 
    loadimm  i64   31 
    loadbf         
    store    i64   mm_diags.currfileno 
#2468:
#2467:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     u64   .p 
    callp          msys.m$print_ptr_nf 1 0
    loadimm  u64   ":"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    setcall        3
    load     u64   .p 
    setarg   u64   3
    load     u64   .prefix 
    setarg   u64   2
    load     i64   .level 
    setarg   i64   1
    callf    u64   mm_diags.getprefix 3 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    loadref  u64   mm_tables.jtagnames 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    loadimm  i64   1 
    addptrx  u64   1 0
    store    u64   .idname 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     u64   .idname 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   ":"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #2471 1
    loadimm  i64   100 
    jumpeq   i64   #2472 1
    loadimm  i64   1 
    jumpeq   i64   #2473 1
    loadimm  i64   125 
    jumpeq   i64   #2473 1
    loadimm  i64   55 
    jumpeq   i64   #2474 1
    loadimm  i64   62 
    jumpeq   i64   #2475 1
    loadimm  i64   51 
    jumpeq   i64   #2476 1
    loadimm  i64   54 
    jumpeq   i64   #2476 1
    loadimm  i64   16 
    jumpeq   i64   #2477 1
    loadimm  i64   45 
    jumpeq   i64   #2478 1
    loadimm  i64   43 
    jumpeq   i64   #2479 1
    loadimm  i64   48 
    jumpeq   i64   #2479 1
    loadimm  i64   103 
    jumpeq   i64   #2480 1
    loadimm  i64   101 
    jumpeq   i64   #2480 1
    loadimm  i64   102 
    jumpeq   i64   #2480 1
    loadimm  i64   90 
    jumpeq   i64   #2481 1
    loadimm  i64   5 
    jumpeq   i64   #2482 1
    loadimm  i64   7 
    jumpeq   i64   #2483 1
    loadimm  i64   8 
    jumpeq   i64   #2484 1
    loadimm  i64   9 
    jumpeq   i64   #2485 1
    loadimm  i64   31 
    jumpeq   i64   #2486 
    jump           #2487 
#2471:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     u64   .d 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.namenames 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #2489 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " {"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadref  u64   mm_tables.jtagnames 
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    iload    u8    
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   "}"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2489:
#2488:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_lib.getdottedname 1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    startmx        
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u8    1 0
    jumpf    i64   #2494 
    loadimm  u64   " {Dotted}"
    resetmx        
    jump           #2493 
#2494:
    loadimm  u64   ""
    endmx          
#2493:
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    jumpf    u64   #2498 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " Lastcall:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    callp          msys.m$print_ptr_nf 1 0
    callp          msys.m$print_end 0 0
#2498:
#2497:
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u8    1 0
    jumpf    i64   #2501 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " Addroffirst."
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2501:
#2500:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " Moduleno:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    loadimm  i64   41 
    iloadx   u8    1 0
    jumpf    i64   #2505 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " AV:"
    callp          msys.m$print_str_nf 1 0
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   41 
    iloadx   u8    1 0
    truncate u64 u8 
    callp          msys.m$print_c8 2 0
    callp          msys.m$print_end 0 0
#2505:
#2504:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "P.INDEX="
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i32   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2472:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2473:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .t 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .a 
    load     i64   .t 
    loadimm  i64   21 
    jumpne   i64   #2509 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    loadimm  i64   256 
    jumple   i64   #2511 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "\""
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   "(LS1:LONGSTR)"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "\" *"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2510 
#2511:
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    jumpf    i64   #2515 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "\""
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   "\" *"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2510 
#2515:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "\"\""
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2510:
    jump           #2508 
#2509:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    loadimm  i64   3 
    jumpeq   i64   #2520 1
    loadimm  i64   17 
    jumpeq   i64   #2520 1
    loadimm  i64   16 
    jumpeq   i64   #2520 1
    loadimm  i64   15 
    jumpeq   i64   #2520 1
    loadimm  i64   2 
    jumpeq   i64   #2521 1
    loadimm  i64   20 
    jumpeq   i64   #2521 1
    loadimm  i64   19 
    jumpeq   i64   #2521 1
    loadimm  i64   18 
    jumpeq   i64   #2521 1
    loadimm  i64   1 
    jumpeq   i64   #2522 1
    loadimm  i64   13 
    jumpeq   i64   #2522 1
    loadimm  i64   4 
    jumpeq   i64   #2523 1
    loadimm  i64   5 
    jumpeq   i64   #2524 1
    loadimm  i64   7 
    jumpeq   i64   #2525 1
    loadimm  i64   6 
    jumpeq   i64   #2526 
    jump           #2527 
#2520:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     i64   .a 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2519 
#2521:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  i64   0 
    load     i64   .a 
    callp          msys.m$print_u64 2 0
    callp          msys.m$print_end 0 0
    jump           #2519 
#2522:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    setcall        1
    load     i64   .a 
    setarg   i64   1
    callf    u64   mlib.chr 1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2519 
#2523:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   r64   1 0
    fnarrow  r32 r64 
    store    r32   .x32 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  i64   0 
    load     r32   .x32 
    fwiden   r64 r32 
    callp          msys.m$print_r64 2 0
    callp          msys.m$print_end 0 0
    jump           #2519 
#2524:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   r64   1 0
    callp          msys.m$print_r64 2 0
    callp          msys.m$print_end 0 0
    jump           #2519 
#2525:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    jumpf    i64   #2529 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "#"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    callp          msys.m$print_i64_nf 1 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2528 
#2529:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "NIL"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2528:
    jump           #2519 
#2526:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    startmx        
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    jumpf    i64   #2533 
    loadimm  u64   "True"
    resetmx        
    jump           #2532 
#2533:
    loadimm  u64   "False"
    endmx          
#2532:
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2519 
#2527:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "TYPENAME(T)="
    callp          msys.m$print_str_nf 1 0
    setcall        1
    load     i64   .t 
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    callp          msys.m$print_str_nf 1 0
    setcall        1
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "<PRINTUNIT BAD CONST PROBABLY VOID"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2519:
#2508:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    setcall        1
    load     i64   .t 
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    loadimm  i64   44 
    iloadx   u8    1 0
    jumpf    i64   #2540 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " <isstr>"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2540:
#2539:
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i32   1 0
    jumpf    i64   #2543 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " *L"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i32   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#2543:
#2542:
    jump           #2470 
#2474:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    setcall        1
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    callp          msys.m$print_str_nf 1 0
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2475:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadref  u64   mm_tables.bitfieldnames 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    iloadx   u64   8 -8
    loadimm  i64   3 
    addptrx  u64   1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2476:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " Convmode:"
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   52 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2477:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "Len:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   " Makeax:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2478:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "Offset:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2479:
    jump           #2470 
#2480:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "#"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i32   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2481:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadref  u64   mm_tables.sysfnnames 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    iloadx   u64   8 -8
    loadimm  i64   3 
    addptrx  u64   1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2470 
#2482:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadref  u64   mclnames 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    iloadx   u64   8 -8
    loadimm  i64   2 
    addptrx  u64   1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i32   1 0
    loadimm  i64   28 
    jumpeq   i64   #2552 1
    loadimm  i64   60 
    jumpeq   i64   #2552 1
    loadimm  i64   17 
    jumpne   i64   #2551 
#2552:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " "
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mc_decls.condnames 
    load     u64   .p 
    loadimm  i64   45 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "P.COND="
    callp          msys.m$print_str_nf 1 0
    load     u64   .p 
    loadimm  i64   45 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#2551:
#2550:
    jump           #2470 
#2483:
    jump           #2470 
#2484:
    jump           #2470 
#2485:
    jump           #2470 
#2486:
    loadimm  i64   1 
    store    i64   .i 
#2555:
    load     u64   .p 
    loadimm  i64   40 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u8    1 -1
    loadimm  i64   0 
    jumpne   i64   #2559 
    jump           #2557 
#2559:
#2558:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadref  u64   mm_pcl.pclnames 
    load     u64   .p 
    loadimm  i64   40 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u8    1 -1
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   " "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2556:
    forup          #2555 1
    opnd           .i 
    opnd           4 
#2557:
    jump           #2470 
#2487:
#2470:
    load     u64   .p 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #2562 1
    loadimm  i64   48 
    jumpeq   i64   #2562 1
    loadimm  i64   43 
    jumpeq   i64   #2562 1
    loadimm  i64   45 
    jumpeq   i64   #2562 1
    loadimm  i64   88 
    jumpeq   i64   #2562 1
    loadimm  i64   29 
    jumpeq   i64   #2562 1
    loadimm  i64   24 
    jumpeq   i64   #2562 
    jump           #2563 
#2562:
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpne   i64   #2565 
    jump           #2564 
#2565:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " WIDEN FROM:"
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2564:
    jump           #2561 
#2563:
#2561:
    load     u64   .p 
    loadimm  i64   59 
    iloadx   u8    1 0
    jumpf    i64   #2568 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " Is const"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2567 
#2568:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " Not const"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2567:
    load     u64   .p 
    iload    u8    
    loadimm  i64   32 
    jumpeq   i64   #2572 1
    loadimm  i64   34 
    jumpeq   i64   #2572 1
    loadimm  i64   33 
    jumpeq   i64   #2572 1
    loadimm  i64   35 
    jumpeq   i64   #2572 1
    loadimm  i64   30 
    jumpeq   i64   #2572 1
    loadimm  i64   36 
    jumpeq   i64   #2572 1
    loadimm  i64   51 
    jumpeq   i64   #2572 1
    loadimm  i64   12 
    jumpeq   i64   #2572 1
    loadimm  i64   13 
    jumpeq   i64   #2572 1
    loadimm  i64   14 
    jumpeq   i64   #2572 1
    loadimm  i64   15 
    jumpeq   i64   #2572 
    jump           #2573 
#2572:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    jumpf    i64   #2575 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " Pcl<#>"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_pcl.pclnames 
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2574 
#2575:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " no-op"
    callp          msys.m$print_setfmt 1 0
    callp          msys.m$print_end 0 0
#2574:
    jump           #2571 
#2573:
#2571:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    loadref  u64   mm_tables.jsubs 
    load     u64   .p 
    iload    u8    
    iloadx   u8    1 0
    store    i64   .$av_2 
    load     i64   .$av_2 
    loadimm  i64   1 
    jumplt   i64   #2580 
#2578:
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .i 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadref  u64   .opndno 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        4
    loadref  u64   .opndno 
    setarg   u64   4
    load     i64   .level 
    loadimm  i64   1 
    add      i64   
    setarg   i64   3
    load     u64   .p 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   2
    load     u64   .dev 
    setarg   u64   1
    callp          mm_diags.printunitlist 4 0
#2579:
    forup          #2578 1
    opnd           .i 
    opnd           .$av_2 
#2580:
;------------------------
#2464:
    return         
end

proc mm_diags.printunitlist
    param    u64   .dev 
    param    u64   .p 
    param    i64   .level 
    param    u64   .prefix 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #2583 
    jump           #2581 
#2583:
#2582:
    jump           #2585 
#2584:
    setcall        4
    load     u64   .dev 
    setarg   u64   4
    load     u64   .prefix 
    setarg   u64   3
    load     i64   .level 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_diags.printunit 4 0
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .p 
#2585:
    load     u64   .p 
    jumpt    u64   #2584 
#2586:
;------------------------
#2581:
    return         
end

proc mm_diags.getprefix
    rettype  u64   
    param    i64   .level 
    param    u64   .prefix 
    param    u64   .p 
    local    u8:1024 .indentstr 
    local    u8:16384 .modestr 
    local    u64   .isexpr 
    local    i64   .$av_1 
;------------------------
    loadimm  u64   0 
    loadref  u64   .indentstr 
    loadimm  i64   1 
    istorex  u8    1 -1
    load     i64   .level 
    loadimm  i64   10 
    jumple   i64   #2589 
    loadimm  i64   10 
    store    i64   .level 
#2589:
#2588:
    load     i64   .level 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #2592 
#2590:
    setcall        2
    loadimm  u64   "- "
    setarg   u64   2
    loadref  u64   .indentstr 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#2591:
    to             #2590 
    opnd           .$av_1 
#2592:
    loadimm  u64   "-"
    store    u64   .isexpr 
    loadref  u64   mm_tables.jisexpr 
    load     u64   .p 
    iload    u8    
    iloadx   u8    1 0
    jumpf    i64   #2596 
    loadimm  u64   "x"
    store    u64   .isexpr 
#2596:
#2595:
    load     u64   .p 
    iload    u8    
    loadimm  i64   92 
    jumpeq   i64   #2599 1
    loadimm  i64   107 
    jumpeq   i64   #2599 1
    loadimm  i64   105 
    jumpeq   i64   #2599 1
    loadimm  i64   110 
    jumpeq   i64   #2599 
    jump           #2600 
#2599:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #2602 
    loadimm  u64   "x"
    store    u64   .isexpr 
#2602:
#2601:
    jump           #2598 
#2600:
#2598:
    loadref  u64   .modestr 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "#<#> #:#"
    callp          msys.m$print_setfmt 1 0
    load     u64   .isexpr 
    callp          msys.m$print_str_nf 1 0
    startmx        
    load     u64   .p 
    loadimm  i64   60 
    iloadx   u8    1 0
    jumpf    i64   #2605 
    loadimm  u64   "RES"
    resetmx        
    jump           #2604 
#2605:
    loadimm  u64   "---"
    endmx          
#2604:
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    loadimm  u64   0 
    loadref  u64   .modestr 
    loadimm  i64   256 
    istorex  u8    1 -1
    setcall        2
    loadimm  u64   "-----------------------------"
    setarg   u64   2
    loadref  u64   .modestr 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    loadimm  u64   32 
    loadref  u64   .modestr 
    loadimm  i64   17 
    istorex  u8    1 -1
    loadimm  u64   0 
    loadref  u64   .modestr 
    loadimm  i64   18 
    istorex  u8    1 -1
    setcall        2
    setcall        0
    callf    u64   mm_diags.getlineinfok 0 0
    setarg   u64   2
    loadref  u64   mm_diags.getprefix.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadref  u64   .modestr 
    setarg   u64   2
    loadref  u64   mm_diags.getprefix.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadref  u64   .indentstr 
    setarg   u64   2
    loadref  u64   mm_diags.getprefix.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    load     u64   .prefix 
    setarg   u64   2
    loadref  u64   mm_diags.getprefix.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    load     u64   .prefix 
    iload    u8    
    jumpf    u64   #2610 
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    loadref  u64   mm_diags.getprefix.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#2610:
#2609:
    loadref  u64   mm_diags.getprefix.str 
    setret   u64   
    jump           #2587 
;------------------------
#2587:
    return         
end

proc mm_diags.getlineinfok
    rettype  u64   
;------------------------
    loadref  u64   mm_diags.getlineinfok.str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "# # "
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   mm_diags.currfileno 
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "z4"
    load     i64   mm_diags.currlineno 
    callp          msys.m$print_i64 2 0
    callp          msys.m$print_end 0 0
    loadref  u64   mm_diags.getlineinfok.str 
    setret   u64   
    jump           #2612 
;------------------------
#2612:
    return         
end

proc mm_diags.printmodelist
    param    u64   .f 
    local    i64   .mbase 
    local    i64   .$av_1 
    local    i64   .i 
    local    i64   .m 
;------------------------
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "NTYPENAMES="
    callp          msys.m$print_str_nf 1 0
    load     i64   mm_decls.ntypenames 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.ntypenames 
    loadimm  i64   1 
    jumplt   i64   #2619 
#2617:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     i64   .i 
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.typenames 
    load     i64   .i 
    addptrx  u8:32 32 0
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2618:
    forup          #2617 1
    opnd           .i 
    opnd           mm_decls.ntypenames 
#2619:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "MODELIST"
    callp          msys.m$print_str_nf 1 0
    load     i64   mm_decls.ntypes 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   0 
    store    i64   .m 
    load     i64   mm_decls.ntypes 
    loadimm  i64   0 
    jumplt   i64   #2623 
#2621:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "4"
    load     i64   .m 
    callp          msys.m$print_i64 2 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .mbase 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Basetype:"
    callp          msys.m$print_str_nf 1 0
    load     i64   .mbase 
    callp          msys.m$print_i64_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .mbase 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "ttname:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   ttname 
    load     i64   .m 
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "ttnamedef:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    callp          msys.m$print_ptr_nf 1 0
    startmx        
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    jumpf    u64   #2629 
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    iload    u64   
    resetmx        
    jump           #2628 
#2629:
    loadimm  u64   "-"
    endmx          
#2628:
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Target:"
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Size:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    iloadx   u32   4 0
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   "Sizeset"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttsizeset 
    load     i64   .m 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "# Bounds: #..#  Length:#"
    callp          msys.m$print_setfmt 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    add      i64   
    loadimm  i64   1 
    sub      i64   
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     i64   .mbase 
    loadimm  i64   28 
    jumpne   i64   #2636 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Mult:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #2640 
#2638:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    loadref  u64   mm_decls.ttmult 
    load     i64   .m 
    iloadx   u64   8 0
    load     i64   .i 
    iloadx   i32   4 -4
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   " "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2639:
    forup          #2638 1
    opnd           .i 
    opnd           .$av_1 
#2640:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2636:
#2635:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Signed:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttsigned 
    load     i64   .m 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Isreal:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttisreal 
    load     i64   .m 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Isinteger:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .m 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Isshort:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttisshort 
    load     i64   .m 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Isref:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttisref 
    load     i64   .m 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.printmodelist.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Isblock:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2622:
    forup          #2621 1
    opnd           .m 
    opnd           mm_decls.ntypes 
#2623:
;------------------------
#2615:
    return         
end

proc mm_diags.showprojectinfo
    param    u64   .dev 
    local    u64   .pm 
    local    u64   .ps 
    local    i64   .i 
    local    i64   .j 
;------------------------
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "Project Structure:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "---------------------------------------"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "Modules"
    callp          msys.m$print_str_nf 1 0
    load     i64   mm_decls.nmodules 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   1 
    jumplt   i64   #2654 
#2652:
    loadref  u64   mm_decls.moduletable 
    load     i64   .i 
    addptrx  u8:70 70 0
    store    u64   .pm 
    load     i64   .i 
    loadimm  i64   1 
    jumple   i64   #2656 
    load     u64   .pm 
    loadimm  i64   68 
    iloadx   i16   1 0
    loadref  u64   mm_decls.moduletable 
    load     i64   .i 
    addptrx  u8:70 70 -70
    loadimm  i64   68 
    iloadx   i16   1 0
    jumpeq   i64   #2656 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2656:
#2655:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.showprojectinfo.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "2"
    load     i64   .i 
    callp          msys.m$print_i64 2 0
    callp          msys.m$print_nogap 0 0
    startmx        
    loadref  u64   mm_decls.subprogtable 
    loadref  u64   mm_decls.moduletosub 
    load     i64   .i 
    iloadx   u8    1 0
    addptrx  u8:42 42 0
    loadimm  i64   32 
    iloadx   i16   1 0
    load     i64   .i 
    jumpne   i64   #2659 
    loadimm  u64   "*"
    resetmx        
    jump           #2658 
#2659:
    loadimm  u64   " "
    endmx          
#2658:
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "16jl"
    load     u64   .pm 
    iload    u64   
    callp          msys.m$print_str 2 0
    loadimm  u64   "Sys:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .pm 
    loadimm  i64   66 
    iloadx   i16   1 0
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   "Path:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .pm 
    loadimm  i64   24 
    iloadx   u64   1 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Sub:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.subprogtable 
    load     u64   .pm 
    loadimm  i64   68 
    iloadx   i16   1 0
    addptrx  u8:42 42 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Fileno:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .pm 
    loadimm  i64   64 
    iloadx   i16   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .pm 
    loadimm  i64   48 
    iloadx   u64   1 0
    jumpf    u64   #2668 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   " Alias:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .pm 
    loadimm  i64   48 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2668:
#2667:
    load     u64   .pm 
    loadimm  i64   40 
    iloadx   u64   1 0
    jumpf    u64   #2671 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_space 0 0
    load     u64   .pm 
    loadimm  i64   40 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   ":"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.scopenames 
    load     u64   .pm 
    loadimm  i64   40 
    iloadx   u64   1 0
    loadimm  i64   191 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    load     u64   .pm 
    loadimm  i64   40 
    iloadx   u64   1 0
    callp          msys.m$print_ptr_nf 1 0
    callp          msys.m$print_end 0 0
#2671:
#2670:
    load     u64   .pm 
    loadimm  i64   32 
    iloadx   u64   1 0
    jumpf    u64   #2674 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_space 0 0
    load     u64   .pm 
    loadimm  i64   32 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   ":"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.scopenames 
    load     u64   .pm 
    loadimm  i64   32 
    iloadx   u64   1 0
    loadimm  i64   191 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    load     u64   .pm 
    loadimm  i64   32 
    iloadx   u64   1 0
    callp          msys.m$print_ptr_nf 1 0
    callp          msys.m$print_end 0 0
#2674:
#2673:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2653:
    forup          #2652 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#2654:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "Subprograms"
    callp          msys.m$print_str_nf 1 0
    load     i64   mm_decls.nsubprogs 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nsubprogs 
    loadimm  i64   1 
    jumplt   i64   #2678 
#2676:
    loadref  u64   mm_decls.subprogtable 
    load     i64   .i 
    addptrx  u8:42 42 0
    store    u64   .ps 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.showprojectinfo.tab 
    callp          msys.m$print_str_nf 1 0
    load     i64   .i 
    callp          msys.m$print_i64_nf 1 0
    load     u64   .ps 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Sys:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .ps 
    loadimm  i64   16 
    iloadx   i64   1 0
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   "Path:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .ps 
    loadimm  i64   24 
    iloadx   u64   1 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Fileno:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .ps 
    loadimm  i64   34 
    iloadx   i64   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .ps 
    loadimm  i64   32 
    iloadx   i16   1 0
    jumpf    i64   #2683 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.showprojectinfo.tab 
    callp          msys.m$print_str_nf 1 0
    load     u64   mm_diags.showprojectinfo.tab 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .j 
    load     i64   mm_decls.nmodules 
    loadimm  i64   1 
    jumplt   i64   #2686 
#2684:
    loadref  u64   mm_decls.moduletable 
    load     i64   .j 
    addptrx  u8:70 70 0
    loadimm  i64   68 
    iloadx   i16   1 0
    load     i64   .i 
    jumpne   i64   #2688 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_space 0 0
    loadref  u64   mm_decls.moduletable 
    load     i64   .j 
    addptrx  u8:70 70 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     u64   .ps 
    loadimm  i64   32 
    iloadx   i16   1 0
    load     i64   .j 
    jumpne   i64   #2690 
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "*"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2690:
#2689:
#2688:
#2687:
#2685:
    forup          #2684 1
    opnd           .j 
    opnd           mm_decls.nmodules 
#2686:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2683:
#2682:
#2677:
    forup          #2676 1
    opnd           .i 
    opnd           mm_decls.nsubprogs 
#2678:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "Link files"
    callp          msys.m$print_str_nf 1 0
    load     i64   mm_decls.nlibfiles 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nlibfiles 
    loadimm  i64   1 
    jumplt   i64   #2695 
#2693:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    load     u64   mm_diags.showprojectinfo.tab 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "16jl"
    loadref  u64   mm_decls.libfiles 
    load     i64   .i 
    iloadx   u64   8 0
    callp          msys.m$print_str 2 0
    startmx        
    loadref  u64   mm_decls.libtypes 
    load     i64   .i 
    iloadx   u8    1 0
    loadimm  i64   68 
    jumpne   i64   #2698 
    loadimm  u64   "DLL"
    resetmx        
    jump           #2697 
#2698:
    loadimm  u64   "LIB"
    endmx          
#2697:
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2694:
    forup          #2693 1
    opnd           .i 
    opnd           mm_decls.nlibfiles 
#2695:
    load     u64   .dev 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;------------------------
#2648:
    return         
end

proc mm_diags.showlogfile
    local    u8:256 .str 
    local    u64   .logdev 
    local    i64   .size 
;------------------------
    load     i64   mm_decls.debugmode 
    jumpt    i64   #2703 
    jump           #2701 
#2703:
#2702:
    setcall        2
    loadimm  u64   "w"
    setarg   u64   2
    loadimm  u64   "mx.log"
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .logdev 
    load     u8    mm_decls.fshowmodules 
    jumpf    i64   #2707 
    setcall        1
    load     u64   .logdev 
    setarg   u64   1
    callp          mm_diags.showprojectinfo 1 0
#2707:
#2706:
    load     u8    mm_decls.fshowasm 
    jumpf    i64   #2709 
    load     i64   mm_decls.passlevel 
    loadimm  i64   8 
    jumplt   i64   #2709 
    load     u64   .logdev 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "PROC"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "ASSEMBLY"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    load     u64   .logdev 
    setarg   u64   2
    load     u64   mm_decls.asmfilename 
    setarg   u64   1
    callp          mm_lib.addtolog 2 0
#2709:
#2708:
    load     u8    mm_decls.fshowpcl 
    jumpf    i64   #2713 
    load     i64   mm_decls.passlevel 
    loadimm  i64   7 
    jumplt   i64   #2713 
    setcall        2
    load     u64   .logdev 
    setarg   u64   2
    load     u64   mm_decls.pclfilename 
    setarg   u64   1
    callp          mm_lib.addtolog 2 0
#2713:
#2712:
    load     u8    mm_decls.fshowast3 
    jumpf    i64   #2715 
    load     i64   mm_decls.passlevel 
    loadimm  i64   6 
    jumplt   i64   #2715 
    setcall        2
    load     u64   .logdev 
    setarg   u64   2
    loadimm  u64   "AST3"
    setarg   u64   1
    callp          mm_lib.addtolog 2 0
#2715:
#2714:
    load     u8    mm_decls.fshowast2 
    jumpf    i64   #2718 
    load     i64   mm_decls.passlevel 
    loadimm  i64   5 
    jumplt   i64   #2718 
    setcall        2
    load     u64   .logdev 
    setarg   u64   2
    loadimm  u64   "AST2"
    setarg   u64   1
    callp          mm_lib.addtolog 2 0
#2718:
#2717:
    load     u8    mm_decls.fshowast1 
    jumpf    i64   #2721 
    load     i64   mm_decls.passlevel 
    loadimm  i64   3 
    jumplt   i64   #2721 
    setcall        2
    load     u64   .logdev 
    setarg   u64   2
    loadimm  u64   "AST1"
    setarg   u64   1
    callp          mm_lib.addtolog 2 0
#2721:
#2720:
    load     u8    mm_decls.fshowst 
    jumpf    i64   #2724 
    setcall        2
    load     u64   .logdev 
    setarg   u64   2
    loadimm  u64   "SYMBOL TABLE"
    setarg   u64   1
    callp          mm_diags.showsttree 2 0
#2724:
#2723:
    load     u8    mm_decls.fshowstflat 
    jumpf    i64   #2727 
    setcall        2
    load     u64   .logdev 
    setarg   u64   2
    loadimm  u64   "FLAT SYMBOL TABLE"
    setarg   u64   1
    callp          mm_diags.showstflat 2 0
#2727:
#2726:
    load     u8    mm_decls.fshowtypes 
    jumpf    i64   #2730 
    setcall        1
    load     u64   .logdev 
    setarg   u64   1
    callp          mm_diags.printmodelist 1 0
#2730:
#2729:
    load     u8    mm_decls.fshowoverloads 
    jumpf    i64   #2732 
    setcall        1
    load     u64   .logdev 
    setarg   u64   1
    callp          mm_diags.printoverloads 1 0
#2732:
#2731:
    setcall        1
    load     u64   .logdev 
    setarg   u64   1
    callf    i64   mlib.getfilesize 1 0
    store    i64   .size 
    setcall        1
    load     u64   .logdev 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
    load     i64   .size 
    jumpf    i64   #2734 
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "c:\\m\\ed.bat -w "
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "mx.log"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "mm.m"
    setarg   u64   1
    callf    i64   mlib.checkfile 1 0
    jumpf    i64   #2738 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    loadimm  i64   1 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   mwindows.os_execwait 3 0
    unload   i64   
    jump           #2737 
#2738:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Diagnostic outputs written to"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "mx.log"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2737:
#2734:
#2733:
;------------------------
#2701:
    return         
end

proc mm_diags.showstflat
    param    u64   .caption 
    param    u64   .f 
;------------------------
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "PROC"
    callp          msys.m$print_str_nf 1 0
    load     u64   .caption 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callp          mm_diags.printstflat 1 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;------------------------
#2742:
    return         
end

proc mm_diags.showsttree
    param    u64   .caption 
    param    u64   .f 
    local    u64   .pp 
    local    u64   .d 
    local    i64   .i 
;------------------------
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "PROC"
    callp          msys.m$print_str_nf 1 0
    load     u64   .caption 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   mm_decls.stprogram 
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callp          mm_diags.printst 3 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "Proc List:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #2747 
#2746:
    load     u64   .pp 
    iload    u64   
    store    u64   .d 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "#\t#.# (#) Mod:"
    callp          msys.m$print_setfmt 1 0
    load     u64   .d 
    callp          msys.m$print_ptr_nf 1 0
    load     u64   .d 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "20jl"
    load     u64   .d 
    iload    u64   
    callp          msys.m$print_str 2 0
    loadref  u64   mm_tables.namenames 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    load     u64   .d 
    loadimm  i64   86 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#2747:
    load     u64   .pp 
    jumpt    u64   #2746 
#2748:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "End\n"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "DLL Proc List:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.ndllproctable 
    loadimm  i64   1 
    jumplt   i64   #2755 
#2753:
    loadref  u64   mm_decls.dllproctable 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .d 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "#\t#.# (#) Mod: # # #"
    callp          msys.m$print_setfmt 1 0
    load     u64   .d 
    callp          msys.m$print_ptr_nf 1 0
    load     u64   .d 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "20jl"
    load     u64   .d 
    iload    u64   
    callp          msys.m$print_str 2 0
    loadref  u64   mm_tables.namenames 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    load     u64   .d 
    loadimm  i64   86 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.libfiles 
    load     u64   .d 
    loadimm  i64   113 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "c"
    loadref  u64   mm_decls.libtypes 
    load     u64   .d 
    loadimm  i64   113 
    iloadx   u8    1 0
    iloadx   u8    1 0
    callp          msys.m$print_i64 2 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#2754:
    forup          #2753 1
    opnd           .i 
    opnd           mm_decls.ndllproctable 
#2755:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "End\n"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;------------------------
#2744:
    return         
end

proc mm_diags.showast
    param    u64   .filename 
    local    u64   .f 
;------------------------
    setcall        2
    loadimm  u64   "w"
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    load     u64   .f 
    jumpt    u64   #2763 
    jump           #2760 
#2763:
#2762:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "PROC"
    callp          msys.m$print_str_nf 1 0
    load     u64   .filename 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   ""
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callp          mm_diags.printcode 2 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
;------------------------
#2760:
    return         
end

proc mm_diags.printsymbol
    param    u64   .lp 
    local    u8:16 .l 
;------------------------
    load     u64   .lp 
    iload    u8:16 
    store    u8:16 .l 
    setcall        2
    loadref  u64   mm_tables.symbolnames 
    loadref  u64   .l 
    iload    u8    
    iloadx   u64   8 -8
    setarg   u64   2
    loadimm  u64   "%-18s"
    setarg   u64   1
    callp          printf 2 2
    loadref  u64   .l 
    iload    u8    
    switch         #2769 9 80
    opnd           #2770 
#2769:
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2789 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2789 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2789 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2770 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2770 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2789 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2775 
    swlabel        #2787 
    swlabel        #2782 
    swlabel        #2785 
    swlabel        #2770 
    swlabel        #2783 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2770 
    swlabel        #2771 
    endsw          
#2771:
    setcall        2
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   68 
    iloadx   u8    1 0
    setarg   i64   2
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callp          mm_lex.printstrn 2 0
    loadref  u64   .l 
    loadimm  i64   1 
    iloadx   u8    1 0
    jumpf    i64   #2773 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   " [#]"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_tables.symbolnames 
    loadref  u64   .l 
    loadimm  i64   1 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#2773:
#2772:
    jump           #2768 
#2775:
    loadref  u64   .l 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpeq   i64   #2777 1
    loadimm  i64   2 
    jumpeq   i64   #2778 
    jump           #2779 
#2777:
    callp          msys.m$print_startcon 0 0
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   i64   1 0
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   "int"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2776 
#2778:
    callp          msys.m$print_startcon 0 0
    loadimm  i64   0 
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   u64   1 0
    callp          msys.m$print_u64 2 0
    loadimm  u64   "word"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2776 
#2779:
    callp          msys.m$print_startcon 0 0
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   i64   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#2776:
    jump           #2768 
#2782:
    callp          msys.m$print_startcon 0 0
    loadimm  i64   0 
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   r64   1 0
    callp          msys.m$print_r64 2 0
    callp          msys.m$print_end 0 0
    jump           #2768 
#2783:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "\""
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          msys.printstr 1 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "\""
    callp          msys.m$print_str_nf 1 0
    setcall        1
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2768 
#2785:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "'"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          msys.printstr 1 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "'"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2768 
#2787:
    setcall        1
    loadref  u64   .l 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          msys.printstr 1 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "L"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2768 
#2789:
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_tables.symbolnames 
    loadref  u64   .l 
    iload    u8    
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #2768 
#2770:
    loadref  u64   .l 
    loadimm  i64   1 
    iloadx   u8    1 0
    jumpf    i64   #2791 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "SUBCODE:"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   .l 
    loadimm  i64   1 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#2791:
#2790:
#2768:
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;------------------------
#2766:
    return         
end

proc mm_diags.getpclstr
    rettype  u64   
    local    u64   .pc 
;------------------------
    setcall        1
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_init 1 0
    load     i64   mm_decls.debugmode 
    jumpf    i64   #2795 
    setcall        2
    loadimm  u64   "!PROC PCL CODE"
    setarg   u64   2
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_strln 2 0
#2795:
#2794:
    setcall        2
    setcall        2
    load     u64   mm_cli.inputfile 
    setarg   u64   2
    loadimm  u64   "; "
    setarg   u64   1
    callf    u64   mm_lib.addstr 2 0
    setarg   u64   2
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_strln 2 0
    load     u64   mm_pcl.pccode 
    store    u64   .pc 
    jump           #2801 
#2798:
    setcall        1
    load     u64   .pc 
    setarg   u64   1
    callp          mm_diags.strpclf 1 0
#2799:
    load     u64   .pc 
    iload    u64   
    store    u64   .pc 
#2801:
    load     u64   .pc 
    jumpt    u64   #2798 
#2800:
    load     u64   mm_lib.dest 
    setret   u64   
    jump           #2793 
;------------------------
#2793:
    return         
end

proc mm_diags.strpclstr
    rettype  u64   
    param    u64   .p 
;------------------------
    setcall        1
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_init 1 0
    loadimm  i64   0 
    store    i64   mc_decls.destlinestart 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_diags.strpclf 1 0
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_char 2 0
    load     u64   mm_lib.dest 
    iload    u64   
    setret   u64   
    jump           #2802 
;------------------------
#2802:
    return         
end

proc mm_diags.strpclfree
;------------------------
    setcall        1
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_free 1 0
;------------------------
#2803:
    return         
end

proc mm_diags.strpclf
    param    u64   .pcl 
;------------------------
    load     u64   .pcl 
    loadimm  i64   24 
    iloadx   u8    1 0
    loadimm  i64   148 
    jumpeq   i64   #2806 1
    loadimm  i64   149 
    jumpeq   i64   #2806 
    jump           #2807 
#2806:
    jump           #2805 
#2807:
    setcall        1
    load     u64   .pcl 
    setarg   u64   1
    callp          mm_diags.writepcl 1 0
    setcall        1
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_line 1 0
#2805:
;------------------------
#2804:
    return         
end

proc mm_diags.strpmode
    rettype  u64   
    param    i64   .m 
    param    i64   .size 
;------------------------
    load     i64   .m 
    loadimm  i64   12 
    jumpeq   i64   #2810 
    loadref  u64   mm_tables.stdnames 
    load     i64   .m 
    iloadx   u64   8 0
    setret   u64   
    jump           #2808 
#2810:
#2809:
    setcall        2
    loadimm  u64   "u8:"
    setarg   u64   2
    loadref  u64   mm_diags.strpmode.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .size 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadref  u64   mm_diags.strpmode.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    loadref  u64   mm_diags.strpmode.str 
    setret   u64   
    jump           #2808 
;------------------------
#2808:
    return         
end

proc mm_diags.writepcl
    param    u64   .pcl 
    local    u8:1024 .str 
    local    u64   .d 
    local    u64   .a 
    local    i64   .opcode 
    local    i64   .pmode 
    local    i64   .psize 
    local    i64   .scale 
    local    i64   .offset 
    local    i64   .n 
    local    u64   .q 
;------------------------
    load     u64   .pcl 
    loadimm  i64   24 
    iloadx   u8    1 0
    store    i64   .opcode 
    load     i64   .opcode 
    loadimm  i64   148 
    jumpne   i64   #2814 
    jump           #2812 
#2814:
#2813:
    load     u64   .pcl 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .a 
    loadimm  i64   0 
    store    i64   .scale 
    load     u64   .pcl 
    loadimm  i64   25 
    iloadx   u8    1 0
    store    i64   .pmode 
    load     u64   .pcl 
    loadimm  i64   16 
    iloadx   u32   1 0
    store    i64   .psize 
    load     i64   .opcode 
    loadimm  i64   150 
    jumpeq   i64   #2816 1
    loadimm  i64   1 
    jumpeq   i64   #2817 1
    loadimm  i64   10 
    jumpeq   i64   #2818 1
    loadimm  i64   145 
    jumpeq   i64   #2819 1
    loadimm  i64   6 
    jumpeq   i64   #2820 1
    loadimm  i64   13 
    jumpeq   i64   #2821 1
    loadimm  i64   143 
    jumpeq   i64   #2822 
    jump           #2823 
#2816:
    setcall        1
    loadimm  i64   59 
    setarg   i64   1
    callp          mm_libpcl.asmchar 1 0
    setcall        1
    load     u64   .a 
    iload    u64   
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    jump           #2812 
    jump           #2815 
#2817:
    load     u64   .a 
    iload    u64   
    store    u64   .d 
    setcall        1
    loadimm  u64   "proc "
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    setcall        1
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.getdispname 2 0
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    load     u64   .d 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpne   i64   #2826 
    setcall        1
    loadimm  u64   "*"
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
#2826:
#2825:
    jump           #2812 
    jump           #2815 
#2818:
    load     u64   .a 
    iload    u64   
    store    u64   .d 
    setcall        1
    loadimm  u64   "extproc "
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    setcall        1
    setcall        2
    loadref  u64   mm_decls.ttsize 
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u32   4 0
    setarg   i64   2
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_libpcl.getpclmode 1 0
    setarg   i64   1
    callf    u64   mm_diags.strpmode 2 0
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    setcall        1
    loadimm  u64   " "
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    setcall        1
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.getdispname 2 0
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    jump           #2812 
    jump           #2815 
#2819:
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "#"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   .a 
    iload    i64   
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   ":"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    jump           #2812 
    jump           #2815 
#2820:
    setcall        1
    loadimm  u64   "end\n"
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    jump           #2812 
    jump           #2815 
#2821:
    setcall        1
    loadimm  u64   "extend\n"
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    jump           #2812 
    jump           #2815 
#2822:
    setcall        1
    loadimm  u64   "    assem    --    "
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    setcall        1
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callf    u64   mm_libpcl.strvalue 2 0
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    jump           #2812 
    jump           #2815 
#2823:
    setcall        2
    loadref  u64   mm_pcl.pclnames 
    load     i64   .opcode 
    iloadx   u64   8 -8
    loadimm  i64   1 
    addptrx  u64   1 0
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
#2815:
    setcall        1
    loadimm  u64   "    "
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    setcall        3
    loadimm  u64   " "
    setarg   u64   3
    loadimm  i64   9 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          mlib.ipadstr 3 0
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    load     u64   .a 
    jumpf    u64   #2838 
    load     i64   .opcode 
    loadimm  i64   29 
    jumpeq   i64   #2839 1
    loadimm  i64   30 
    jumpeq   i64   #2839 1
    loadimm  i64   31 
    jumpeq   i64   #2839 1
    loadimm  i64   32 
    jumpeq   i64   #2839 1
    loadimm  i64   33 
    jumpeq   i64   #2839 1
    loadimm  i64   97 
    jumpeq   i64   #2839 1
    loadimm  i64   98 
    jumpne   i64   #2838 
#2839:
    load     u64   .a 
    iload    i64   
    store    i64   .scale 
    load     u64   .a 
    loadimm  i64   12 
    iloadx   i32   1 0
    store    i64   .offset 
    loadimm  u64   0 
    store    u64   .a 
#2838:
#2837:
    load     i64   .pmode 
    jumpf    i64   #2841 
    setcall        2
    setcall        2
    load     u64   .pcl 
    loadimm  i64   16 
    iloadx   u32   1 0
    setarg   i64   2
    load     i64   .pmode 
    setarg   i64   1
    callf    u64   mm_diags.strpmode 2 0
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    load     i64   .opcode 
    loadimm  i64   132 
    jumpeq   i64   #2844 1
    loadimm  i64   131 
    jumpeq   i64   #2844 1
    loadimm  i64   134 
    jumpeq   i64   #2844 1
    loadimm  i64   135 
    jumpeq   i64   #2844 1
    loadimm  i64   133 
    jumpeq   i64   #2844 1
    loadimm  i64   136 
    jumpne   i64   #2843 
#2844:
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    setcall        2
    loadref  u64   mm_decls.ttsize 
    load     u64   .pcl 
    loadimm  i64   20 
    iloadx   u8    1 0
    iloadx   u32   4 0
    setarg   i64   2
    load     u64   .pcl 
    loadimm  i64   20 
    iloadx   u8    1 0
    setarg   i64   1
    callf    u64   mm_diags.strpmode 2 0
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#2843:
#2842:
    setcall        3
    loadimm  u64   " "
    setarg   u64   3
    loadimm  i64   5 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          mlib.ipadstr 3 0
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    jump           #2840 
#2841:
    setcall        1
    loadimm  u64   "     "
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
#2840:
    setcall        0
    callp          mm_libpcl.asmsp 0 0
    load     u64   .a 
    jumpf    u64   #2847 
    load     u64   .pcl 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   8 
    iloadx   u8    1 0
    loadimm  i64   8 
    jumpne   i64   #2849 
    setcall        1
    load     u64   .pcl 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    iload    u64   
    setarg   u64   1
    callp          mm_diags.genpclstr 1 0
    jump           #2848 
#2849:
    setcall        1
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .pcl 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.strvalue 2 0
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
    setcall        0
    callp          mm_libpcl.asmsp 0 0
#2848:
#2847:
#2846:
    load     i64   .scale 
    jumpf    i64   #2851 
    setcall        1
    load     i64   .scale 
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
    load     i64   .opcode 
    loadimm  i64   33 
    jumpeq   i64   #2853 
    setcall        0
    callp          mm_libpcl.asmsp 0 0
    setcall        1
    load     i64   .offset 
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
#2853:
#2852:
#2851:
#2850:
    load     i64   .opcode 
    loadimm  i64   54 
    jumpeq   i64   #2855 1
    loadimm  i64   55 
    jumpeq   i64   #2855 1
    loadimm  i64   125 
    jumpeq   i64   #2855 1
    loadimm  i64   126 
    jumpeq   i64   #2855 1
    loadimm  i64   127 
    jumpeq   i64   #2855 1
    loadimm  i64   128 
    jumpeq   i64   #2855 1
    loadimm  i64   129 
    jumpeq   i64   #2855 1
    loadimm  i64   130 
    jumpeq   i64   #2855 1
    loadimm  i64   57 
    jumpeq   i64   #2856 1
    loadimm  i64   34 
    jumpeq   i64   #2857 1
    loadimm  i64   35 
    jumpeq   i64   #2857 1
    loadimm  i64   36 
    jumpeq   i64   #2857 1
    loadimm  i64   37 
    jumpeq   i64   #2857 1
    loadimm  i64   38 
    jumpeq   i64   #2858 1
    loadimm  i64   39 
    jumpeq   i64   #2858 1
    loadimm  i64   144 
    jumpeq   i64   #2859 1
    loadimm  i64   42 
    jumpeq   i64   #2859 
    jump           #2860 
#2855:
    setcall        1
    load     u64   .pcl 
    loadimm  i64   20 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
    jump           #2854 
#2856:
    setcall        1
    load     u64   .pcl 
    loadimm  i64   20 
    iloadx   i16   1 0
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
    setcall        0
    callp          mm_libpcl.asmsp 0 0
    setcall        1
    load     u64   .pcl 
    loadimm  i64   22 
    iloadx   i16   1 0
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
    jump           #2854 
#2857:
    setcall        1
    load     u64   .pcl 
    loadimm  i64   20 
    iloadx   i8    1 0
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
    setcall        0
    callp          mm_libpcl.asmsp 0 0
    setcall        1
    load     u64   .pcl 
    loadimm  i64   21 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
    jump           #2854 
#2858:
    setcall        1
    load     u64   .pcl 
    loadimm  i64   20 
    iloadx   i8    1 0
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
    jump           #2854 
#2859:
    setcall        1
    load     u64   .pcl 
    loadimm  i64   20 
    iloadx   u8    1 0
    setarg   i64   1
    callp          mm_libpcl.asmint 1 0
    jump           #2854 
#2860:
    load     i64   .opcode 
    loadimm  i64   46 
    jumplt   i64   #2862 1
    loadimm  i64   51 
    jumpgt   i64   #2862 
    load     u64   .pcl 
    loadimm  i64   20 
    iloadx   u8    1 0
    jumpf    i64   #2862 
    setcall        1
    loadimm  u64   "1"
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
#2862:
#2861:
#2854:
;------------------------
#2812:
    return         
end

proc mm_diags.genpclstr
    param    u64   .s 
;------------------------
    setcall        1
    setcall        2
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   mm_diags.strstringc 2 0
    setarg   u64   1
    callp          mm_libpcl.asmstr 1 0
;------------------------
#2864:
    return         
end

proc mm_diags.strstringc
    rettype  u64   
    param    u64   .s 
    param    i64   .length 
    local    i64   .i 
    local    i64   .state 
    local    i64   .c 
    local    i64   .a 
    local    i64   .col 
    local    u64   .dest 
    local    u64   .t 
;------------------------
    load     i64   .length 
    loadimm  i64   512 
    jumple   i64   #2867 
    setcall        1
    load     i64   .length 
    loadimm  i64   2 
    mul      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .dest 
    jump           #2866 
#2867:
    loadref  u64   mm_diags.strstringc.str 
    store    u64   .dest 
#2866:
    load     u64   .dest 
    store    u64   .t 
    setcall        2
    loadimm  u64   "\""
    setarg   u64   2
    loadref  u64   .t 
    loadincr u64   1
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #2870 
#2869:
    load     i64   .c 
    loadimm  i64   34 
    jumpeq   i64   #2873 1
    loadimm  i64   10 
    jumpeq   i64   #2874 1
    loadimm  i64   13 
    jumpeq   i64   #2875 1
    loadimm  i64   9 
    jumpeq   i64   #2876 1
    loadimm  i64   92 
    jumpeq   i64   #2877 
    jump           #2878 
#2873:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   34 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #2872 
#2874:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   110 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #2872 
#2875:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   114 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #2872 
#2876:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   116 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #2872 
#2877:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #2872 
#2878:
    load     i64   .c 
    loadimm  i64   32 
    jumpge   i64   #2880 
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    load     i64   .c 
    loadimm  i64   6 
    shr      i64   
    loadimm  i64   48 
    add      i64   
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    load     i64   .c 
    loadimm  i64   3 
    shr      i64   
    loadimm  i64   7 
    bitand   i64   
    loadimm  i64   48 
    add      i64   
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    load     i64   .c 
    loadimm  i64   7 
    bitand   i64   
    loadimm  i64   48 
    add      i64   
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #2879 
#2880:
    load     i64   .c 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
#2879:
#2872:
#2870:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    jumpt    i64   #2869 
#2871:
    loadimm  u64   34 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   0 
    load     u64   .t 
    istore   u8    
    load     u64   .dest 
    setret   u64   
    jump           #2865 
;------------------------
#2865:
    return         
end

proc mm_export.writeexports
    param    u64   .outfile 
    param    u64   .modulename 
    local    u64   .d 
    local    u64   .e 
    local    u64   .pp 
    local    u8:300 .filename 
    local    u64   .f 
    local    i64   .i 
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Writing exports file to"
    callp          msys.m$print_str_nf 1 0
    load     u64   .outfile 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    load     u64   mm_export.dest 
    setarg   u64   1
    callp          mlib.gs_init 1 0
    setcall        1
    loadimm  u64   "importlib "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .modulename 
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    loadimm  u64   " ="
    setarg   u64   1
    callp          mm_export.wxstrln 1 0
    loadimm  i64   30 
    store    i64   .i 
    load     i64   mm_decls.ntypes 
    loadimm  i64   30 
    jumplt   i64   #2887 
#2885:
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .i 
    iloadx   u64   8 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpne   i64   #2889 
    load     u64   .d 
    iload    u64   
    iload    u8    
    loadimm  u64   36 
    jumpeq   u64   #2889 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .i 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpeq   i64   #2891 
    jump           #2892 
#2891:
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_export.exportrecord 1 0
    jump           #2890 
#2892:
    setcall        1
    loadimm  u64   "    type "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .d 
    iload    u64   
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    loadimm  u64   " = "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        0
    callp          mm_export.wxline 0 0
#2890:
#2889:
#2888:
#2886:
    forup          #2885 1
    opnd           .i 
    opnd           mm_decls.ntypes 
#2887:
    load     u64   mm_decls.staticlist 
    store    u64   .pp 
    jump           #2898 
#2895:
    load     u64   .pp 
    iload    u64   
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpne   i64   #2900 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_export.exportstatic 1 0
#2900:
#2899:
#2896:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#2898:
    load     u64   .pp 
    jumpt    u64   #2895 
#2897:
    load     u64   mm_decls.staticlist 
    jumpf    u64   #2902 
    setcall        0
    callp          mm_export.wxline 0 0
#2902:
#2901:
    load     u64   mm_decls.constlist 
    store    u64   .pp 
    jump           #2906 
#2903:
    load     u64   .pp 
    iload    u64   
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpne   i64   #2908 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_export.exportconst 1 0
#2908:
#2907:
#2904:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#2906:
    load     u64   .pp 
    jumpt    u64   #2903 
#2905:
    load     u64   mm_decls.constlist 
    jumpf    u64   #2910 
    setcall        0
    callp          mm_export.wxline 0 0
#2910:
#2909:
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #2914 
#2911:
    load     u64   .pp 
    iload    u64   
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpne   i64   #2916 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_export.exportproc 1 0
#2916:
#2915:
#2912:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#2914:
    load     u64   .pp 
    jumpt    u64   #2911 
#2913:
    setcall        1
    loadimm  u64   "end importlib"
    setarg   u64   1
    callp          mm_export.wxstrln 1 0
    setcall        2
    loadimm  u64   "wb"
    setarg   u64   2
    load     u64   .outfile 
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    setcall        2
    load     u64   .f 
    setarg   u64   2
    load     u64   mm_export.dest 
    setarg   u64   1
    callp          mlib.gs_println 2 0
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
;------------------------
#2881:
    return         
end

proc mm_export.exportstatic
    param    u64   .d 
;------------------------
    setcall        1
    loadimm  u64   "    var "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_export.wxmode 1 0
    setcall        1
    loadimm  u64   " "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .d 
    iload    u64   
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        0
    callp          mm_export.wxline 0 0
;------------------------
#2919:
    return         
end

proc mm_export.exportconst
    param    u64   .d 
;------------------------
    setcall        1
    loadimm  u64   "    const "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_export.wxmode 1 0
    setcall        1
    loadimm  u64   " "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .d 
    iload    u64   
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    loadimm  u64   " = "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        2
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   mm_export.dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        0
    callp          mm_export.wxline 0 0
;------------------------
#2922:
    return         
end

proc mm_export.exportproc
    param    u64   .d 
    local    u64   .e 
    local    i64   .currmode 
    local    i64   .needcomma 
;------------------------
    setcall        1
    loadimm  u64   "    "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    startmx        
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #2929 
    loadimm  u64   "proc "
    resetmx        
    jump           #2928 
#2929:
    loadimm  u64   "func "
    endmx          
#2928:
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .d 
    iload    u64   
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    loadimm  u64   "("
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    load     u64   .d 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    loadimm  i64   0 
    store    i64   .needcomma 
    loadimm  i64   0 
    store    i64   .currmode 
    jump           #2934 
#2933:
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   13 
    jumpne   i64   #2937 
    load     i64   .needcomma 
    jumpf    i64   #2939 
    setcall        1
    loadimm  u64   ","
    setarg   u64   1
    callp          mm_export.wxstr 1 0
#2939:
#2938:
    load     u64   .e 
    loadimm  i64   152 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpeq   i64   #2942 
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     i64   .currmode 
    jumpeq   i64   #2944 
    setcall        1
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_export.wxmode 1 0
    setcall        1
    loadimm  u64   " "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    store    i64   .currmode 
#2944:
#2943:
    jump           #2941 
#2942:
    setcall        1
    loadref  u64   mm_decls.tttarget 
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   i32   4 0
    setarg   i64   1
    callp          mm_export.wxmode 1 0
    setcall        1
    loadimm  u64   " &"
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    loadimm  i64   0 
    store    i64   .currmode 
#2941:
    setcall        1
    load     u64   .e 
    iload    u64   
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    load     u64   .e 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #2948 
    setcall        1
    loadimm  u64   "="
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    loadref  u64   mm_decls.ttisref 
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #2951 
    load     u64   .e 
    loadimm  i64   56 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #2951 
    load     u64   .e 
    loadimm  i64   56 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    loadimm  i64   0 
    jumpne   i64   #2951 
    setcall        1
    loadimm  u64   "nil"
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    jump           #2950 
#2951:
    setcall        2
    load     u64   .e 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   mm_export.dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
#2950:
#2948:
#2947:
    loadimm  i64   1 
    store    i64   .needcomma 
#2937:
#2936:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#2934:
    load     u64   .e 
    jumpt    u64   #2933 
#2935:
    setcall        1
    loadimm  u64   ")"
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    jumpf    i64   #2955 
    setcall        1
    loadimm  u64   " => "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_export.wxmode 1 0
#2955:
#2954:
    setcall        0
    callp          mm_export.wxline 0 0
;------------------------
#2926:
    return         
end

proc mm_export.wxstr
    param    u64   .s 
;------------------------
    setcall        2
    load     u64   .s 
    setarg   u64   2
    load     u64   mm_export.dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
;------------------------
#2957:
    return         
end

proc mm_export.wxstrln
    param    u64   .s 
;------------------------
    setcall        2
    load     u64   .s 
    setarg   u64   2
    load     u64   mm_export.dest 
    setarg   u64   1
    callp          mlib.gs_strln 2 0
;------------------------
#2958:
    return         
end

proc mm_export.wxline
;------------------------
    setcall        1
    load     u64   mm_export.dest 
    setarg   u64   1
    callp          mlib.gs_line 1 0
;------------------------
#2959:
    return         
end

proc mm_export.exportrecord
    param    u64   .d 
    local    u64   .e 
    local    u64   .flags 
    local    i64   .flag 
    local    i64   .indent 
    local    i64   .$av_1 
    local    i64   .$av_2 
    local    i64   .$av_3 
    local    i64   .$av_4 
;------------------------
    load     u64   .d 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    setcall        1
    loadimm  u64   "    record "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .d 
    iload    u64   
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    loadimm  u64   " = "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        0
    callp          mm_export.wxline 0 0
    loadimm  i64   2 
    store    i64   .indent 
    jump           #2964 
#2963:
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   14 
    jumpne   i64   #2967 
    load     u64   .e 
    loadimm  i64   128 
    addptrx  u64   1 0
    store    u64   .flags 
#2968:
    load     u64   .flags 
    iload    u8    
    loadimm  u64   83 
    jumpeq   u64   #2970 1
    loadimm  u64   85 
    jumpeq   u64   #2971 
    jump           #2972 
#2970:
    load     i64   .indent 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #2975 
#2973:
    setcall        1
    loadimm  u64   "    "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
#2974:
    to             #2973 
    opnd           .$av_1 
#2975:
    setcall        1
    loadimm  u64   "struct"
    setarg   u64   1
    callp          mm_export.wxstrln 1 0
    loadref  u64   .indent 
    incrto   i64   1
    loadref  u64   .flags 
    incrto   u64   1
    jump           #2968 
#2971:
    load     i64   .indent 
    store    i64   .$av_2 
    load     i64   .$av_2 
    loadimm  i64   0 
    jumple   i64   #2980 
#2978:
    setcall        1
    loadimm  u64   "    "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
#2979:
    to             #2978 
    opnd           .$av_2 
#2980:
    setcall        1
    loadimm  u64   "union"
    setarg   u64   1
    callp          mm_export.wxstrln 1 0
    loadref  u64   .indent 
    incrto   i64   1
    loadref  u64   .flags 
    incrto   u64   1
    jump           #2968 
#2972:
    jump           #2969 
    jump           #2968 
#2969:
    load     i64   .indent 
    store    i64   .$av_3 
    load     i64   .$av_3 
    loadimm  i64   0 
    jumple   i64   #2985 
#2983:
    setcall        1
    loadimm  u64   "    "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
#2984:
    to             #2983 
    opnd           .$av_3 
#2985:
    setcall        1
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_export.wxmode 1 0
    setcall        1
    loadimm  u64   " "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    setcall        1
    load     u64   .e 
    iload    u64   
    setarg   u64   1
    callp          mm_export.wxstrln 1 0
#2988:
    loadref  u64   .flags 
    loadincr u64   1
    iload    u8    
    store    i64   .flag 
    load     i64   .flag 
    loadimm  i64   42 
    jumpeq   i64   #2991 1
    loadimm  i64   69 
    jumpeq   i64   #2992 
    jump           #2993 
#2991:
    jump           #2990 
#2992:
    loadref  u64   .indent 
    decrto   i64   1
    load     i64   .indent 
    store    i64   .$av_4 
    load     i64   .$av_4 
    loadimm  i64   0 
    jumple   i64   #2996 
#2994:
    setcall        1
    loadimm  u64   "    "
    setarg   u64   1
    callp          mm_export.wxstr 1 0
#2995:
    to             #2994 
    opnd           .$av_4 
#2996:
    setcall        1
    loadimm  u64   "end"
    setarg   u64   1
    callp          mm_export.wxstrln 1 0
    jump           #2990 
#2993:
    jump           #2989 
#2990:
    jump           #2988 
#2989:
#2967:
#2966:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#2964:
    load     u64   .e 
    jumpt    u64   #2963 
#2965:
    setcall        1
    loadimm  u64   "    end"
    setarg   u64   1
    callp          mm_export.wxstrln 1 0
    setcall        0
    callp          mm_export.wxline 0 0
;------------------------
#2960:
    return         
end

proc mm_export.wxmode
    param    i64   .mode 
    local    u64   .name 
;------------------------
    load     i64   .mode 
    loadimm  i64   30 
    jumplt   i64   #3002 
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .mode 
    iloadx   u64   8 0
    iload    u64   
    store    u64   .name 
    load     u64   .name 
    iload    u8    
    loadimm  u64   36 
    jumpeq   u64   #3004 
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callp          mm_export.wxstr 1 0
    jump           #3000 
#3004:
#3003:
#3002:
#3001:
    setcall        1
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     i64   .mode 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   1
    callp          mm_export.wxstr 1 0
;------------------------
#3000:
    return         
end

proc mm_genpcl.codegen_pcl
    rettype  i64   
    local    u64   .pp 
    local    u64   .d 
    local    u64   .e 
;------------------------
    setcall        0
    callp          mm_libpcl.pclinit 0 0
    load     u64   mm_decls.staticlist 
    store    u64   .pp 
    jump           #3007 
#3006:
    load     u64   .pp 
    iload    u64   
    store    u64   .d 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_genpcl.dostaticvar 1 0
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#3007:
    load     u64   .pp 
    jumpt    u64   #3006 
#3008:
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #3010 
#3009:
    load     u64   .pp 
    iload    u64   
    store    u64   .d 
    setcall        1
    load     u64   .d 
    double         
    store    u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_genpcl.genprocdef 1 0
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#3010:
    load     u64   .pp 
    jumpt    u64   #3009 
#3011:
    setcall        0
    callp          mm_genpcl.genpclfunctable 0 0
    setcall        1
    load     u64   mm_decls.stprogram 
    setarg   u64   1
    callp          mm_genpcl.scansymbol 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   148 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   1 
    setret   i64   
    jump           #3005 
;------------------------
#3005:
    return         
end

proc mm_genpcl.genprocdef
    param    u64   .p 
    local    u64   .ms 
    local    u64   .d 
    local    u64   .rx 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    setcall        2
    setcall        1
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_libpcl.genmemaddr 1 0
    setarg   u64   2
    loadimm  i64   1 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   28 
    jumpeq   i64   #3014 1
    loadimm  i64   0 
    jumpeq   i64   #3015 
    jump           #3016 
#3014:
    loadimm  i64   1 
    store    i64   .i 
    loadref  u64   mm_decls.ttlength 
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #3019 
#3017:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   4 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadref  u64   mm_decls.ttmult 
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u64   8 0
    load     i64   .i 
    iloadx   i32   4 -4
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#3018:
    forup          #3017 1
    opnd           .i 
    opnd           .$av_1 
#3019:
    jump           #3013 
#3015:
    jump           #3013 
#3016:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   4 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   25 
    iloadx   u8    1 0
    loadimm  i64   12 
    jumpne   i64   #3021 
    loadref  u64   mm_decls.ttisblock 
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpt    i64   #3021 
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#3021:
#3020:
#3013:
    loadimm  i64   0 
    store    i64   mc_decls.mstackdepth 
    loadimm  i64   0 
    store    i64   mm_libpcl.nblocktemps 
    loadref  u64   mm_decls.moduletable 
    load     u64   .p 
    loadimm  i64   86 
    iloadx   u8    1 0
    addptrx  u8:70 70 0
    store    u64   .ms 
    load     u64   .p 
    load     u64   .ms 
    loadimm  i64   40 
    iloadx   u64   1 0
    jumpne   u64   #3023 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_genpcl.genmaindef 1 0
    jump           #3012 
    jump           #3022 
#3023:
    load     u64   .p 
    load     u64   .ms 
    loadimm  i64   32 
    iloadx   u64   1 0
    jumpne   u64   #3024 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_genpcl.genstartdef 1 0
    jump           #3012 
#3024:
#3022:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_genpcl.genlocals 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   149 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   mc_decls.retindex 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "------------------------"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        1
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "------------------------"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        1
    load     i64   mc_decls.retindex 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        0
    callp          mm_genpcl.genreturn 0 0
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_genpcl.checkreturn 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   6 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#3012:
    return         
end

proc mm_genpcl.dostaticvar
    param    u64   .d 
    local    u64   .p 
;------------------------
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   7 
    loadbit        
    jumpf    u64   #3028 
    jump           #3026 
#3028:
#3027:
    load     u64   .d 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpne   i64   #3030 
    load     u64   .d 
    iload    u64   
    iload    u8    
    loadimm  u64   36 
    jumpne   u64   #3030 
    setcall        2
    loadimm  u64   "$cmdskip"
    setarg   u64   2
    load     u64   .d 
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #3032 
    loadimm  i64   3 
    load     u64   .d 
    loadimm  i64   191 
    istorex  u8    1 0
#3032:
#3031:
#3030:
#3029:
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   5 
    loadbit        
    loadimm  i64   1 
    jumpne   i64   #3035 
    jump           #3026 
#3035:
#3034:
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    startmx        
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #3037 
    loadimm  i64   7 
    resetmx        
    jump           #3036 
#3037:
    loadimm  i64   8 
    endmx          
#3036:
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_lib.getalignment 1 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   26 
    istorex  u8    1 0
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #3039 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_genpcl.genidata 3 0
#3039:
#3038:
;------------------------
#3026:
    return         
end

proc mm_genpcl.genidata
    param    u64   .p 
    param    i64   .doterm 
    param    i64   .offset 
    local    i64   .t 
    local    i64   .length 
    local    i64   .n 
    local    i64   .i 
    local    i64   .j 
    local    i64   .nwords 
    local    i64   .offset1 
    local    i64   .offset2 
    local    i64   .size 
    local    i64   .padding 
    local    i64   .isunion 
    local    i64   .tbase 
    local    i64   .u 
    local    u64   .q 
    local    u64   .a 
    local    u64   .b 
    local    u64   .d 
    local    r32   .sx 
;------------------------
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .t 
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    store    i64   .tbase 
    load     u64   .p 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #3042 1
    loadimm  i64   16 
    jumpeq   i64   #3043 1
    loadimm  i64   3 
    jumpeq   i64   #3044 1
    loadimm  i64   51 
    jumpeq   i64   #3045 1
    loadimm  i64   52 
    jumpeq   i64   #3046 1
    loadimm  i64   49 
    jumpeq   i64   #3047 1
    loadimm  i64   50 
    jumpeq   i64   #3047 
    jump           #3048 
#3042:
    loadimm  i64   2 
    store    i64   .u 
    loadref  u64   mm_decls.ttisref 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #3050 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   21 
    jumpne   i64   #3052 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    jumpf    u64   #3054 
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genstring 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #3053 
#3054:
    setcall        2
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#3053:
    jump           #3051 
#3052:
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#3051:
    jump           #3049 
#3050:
    loadref  u64   mm_decls.ttisreal 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #3055 
    load     i64   .tbase 
    store    i64   .u 
    loadref  u64   mm_decls.ttsize 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u32   4 0
    loadimm  i64   4 
    jumpeq   i64   #3057 1
    loadimm  i64   8 
    jumpeq   i64   #3058 
    jump           #3059 
#3057:
    setcall        2
    setcall        2
    loadimm  i64   4 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   r64   1 0
    setarg   r64   1
    callf    u64   mm_libpcl.genrealimm 2 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #3056 
#3058:
    setcall        2
    setcall        2
    loadimm  i64   5 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   r64   1 0
    setarg   r64   1
    callf    u64   mm_libpcl.genrealimm 2 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #3056 
#3059:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "IDATA/REAL:"
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#3056:
    jump           #3049 
#3055:
    loadref  u64   mm_decls.ttsize 
    startmx        
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #3063 
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    resetmx        
    jump           #3062 
#3063:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    endmx          
#3062:
    iloadx   u32   4 0
    loadimm  i64   1 
    jumpeq   i64   #3064 1
    loadimm  i64   2 
    jumpeq   i64   #3065 1
    loadimm  i64   4 
    jumpeq   i64   #3066 1
    loadimm  i64   8 
    jumpeq   i64   #3067 
    jump           #3068 
#3064:
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   18 
    store    i64   .u 
    jump           #3061 
#3065:
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   19 
    store    i64   .u 
    jump           #3061 
#3066:
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   20 
    store    i64   .u 
    jump           #3061 
#3067:
    setcall        2
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #3061 
#3068:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "IDATA/INT:"
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#3061:
#3049:
    setcall        1
    load     i64   .u 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #3041 
#3043:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #3071 
#3070:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_genpcl.genidata 3 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#3071:
    load     u64   .q 
    jumpt    u64   #3070 
#3072:
    jump           #3041 
#3044:
;doname::
#3073:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   11 
    jumpeq   i64   #3075 1
    loadimm  i64   6 
    jumpeq   i64   #3075 1
    loadimm  i64   7 
    jumpeq   i64   #3075 1
    loadimm  i64   17 
    jumpeq   i64   #3076 
    jump           #3077 
#3075:
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmemaddr 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .tbase 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #3074 
#3076:
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #3079 
    loadref  u64   mc_decls.mlabelno 
    incrload i64   1
    load     u64   .d 
    loadimm  i64   72 
    istorex  i32   1 0
#3079:
#3078:
    setcall        2
    setcall        1
    load     u64   .d 
    loadimm  i64   72 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #3074 
#3077:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Idata &frameXXX"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#3074:
    jump           #3040 
    jump           #3041 
#3045:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_genpcl.genidata 3 0
    jump           #3041 
#3046:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    loadref  u64   mm_decls.ttsize 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u32   4 0
    loadimm  i64   1 
    jumpeq   i64   #3082 1
    loadimm  i64   2 
    jumpeq   i64   #3083 1
    loadimm  i64   4 
    jumpeq   i64   #3084 
    jump           #3085 
#3082:
    setcall        2
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   18 
    store    i64   .u 
    jump           #3081 
#3083:
    setcall        2
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   19 
    store    i64   .u 
    jump           #3081 
#3084:
    setcall        2
    setcall        1
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   20 
    store    i64   .u 
    jump           #3081 
#3085:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "IDATA/SHORTEN:"
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#3081:
    setcall        1
    load     i64   .u 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #3041 
#3047:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #3088 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "idata/not &name"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#3088:
#3087:
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    jumpf    u64   #3091 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Idata/&name has offset"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#3091:
#3090:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .p 
    jump           #3073 
    jump           #3041 
#3048:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   mm_tables.jtagnames 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    setarg   u64   2
    loadimm  u64   "IDATA: "
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#3041:
;------------------------
#3040:
    return         
end

proc mm_genpcl.checkreturn
    param    u64   .p 
;------------------------
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpeq   i64   #3096 
    setcall        1
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.checkblockreturn 1 0
    jumpt    i64   #3098 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .p 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Function needs explicit return: "
    setarg   u64   1
    callp          mm_support.gerror_s 3 0
#3098:
#3097:
#3096:
#3095:
;------------------------
#3094:
    return         
end

proc mm_genpcl.genreturn
    local    u64   .ax 
    local    u64   .bx 
;------------------------
    loadref  u64   mm_decls.ttisblock 
    load     u64   mm_decls.currproc 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #3102 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "COPY BLOCK RETURN"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
#3102:
#3101:
    load     u64   mm_decls.currproc 
    loadimm  i64   117 
    iloadx   u8    1 0
    jumpf    i64   #3105 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   41 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #3100 
#3105:
#3104:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   41 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#3100:
    return         
end

proc mm_genpcl.genlocals
    param    u64   .p 
    local    u64   .d 
    local    u64   .e 
    local    u64   .b 
    local    i64   .m 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    store    i64   .m 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #3108 
    loadref  u64   mm_libpcl.nblocktemps 
    incrto   i64   1
    setcall        3
    loadimm  i64   13 
    setarg   i64   3
    setcall        1
    loadimm  u64   "$dummy"
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .e 
    load     i64   .m 
    load     u64   .e 
    loadimm  i64   64 
    istorex  i32   1 0
    setcall        2
    setcall        1
    load     u64   .e 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#3108:
#3107:
    jump           #3111 
#3110:
    load     u64   .d 
    loadimm  i64   80 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   12 
    jumpeq   i64   #3114 1
    loadimm  i64   13 
    jumpeq   i64   #3115 
    jump           #3116 
#3114:
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   5 
    loadbit        
    jumpt    u64   #3118 
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#3118:
#3117:
    jump           #3113 
#3115:
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    jump           #3113 
#3116:
#3113:
    load     u64   .d 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .d 
#3111:
    load     u64   .d 
    jumpt    u64   #3110 
#3112:
;------------------------
#3106:
    return         
end

proc mm_genpcl.docallproc
    param    u64   .d 
;------------------------
    load     u64   .d 
    jumpf    u64   #3121 
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmemaddr 1 0
    setarg   u64   2
    loadimm  i64   34 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#3121:
#3120:
;------------------------
#3119:
    return         
end

proc mm_genpcl.genmaindef
    param    u64   .p 
    local    u64   .ms 
    local    u64   .d 
    local    i64   .m 
    local    i64   .i 
;------------------------
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_genpcl.genlocals 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   149 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   mc_decls.retindex 
    loadimm  u64   1 
    jumpf    i64   #3124 
    loadimm  i64   2 
    store    i64   .i 
    load     i64   mm_decls.nsubprogs 
    loadimm  i64   2 
    jumplt   i64   #3127 
#3125:
    loadref  u64   mm_decls.moduletable 
    loadref  u64   mm_decls.subprogtable 
    load     i64   .i 
    addptrx  u8:42 42 0
    loadimm  i64   32 
    iloadx   i16   1 0
    addptrx  u8:70 70 0
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .d 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_genpcl.docallproc 1 0
#3126:
    forup          #3125 1
    opnd           .i 
    opnd           mm_decls.nsubprogs 
#3127:
    loadref  u64   mm_decls.moduletable 
    loadref  u64   mm_decls.subprogtable 
    loadimm  i64   1 
    addptrx  u8:42 42 0
    loadimm  i64   32 
    iloadx   i16   1 0
    addptrx  u8:70 70 0
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .d 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_genpcl.docallproc 1 0
#3124:
#3123:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "------------------------"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        1
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "------------------------"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        1
    load     i64   mc_decls.retindex 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        4
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   0 
    setarg   u64   1
    callp          mm_blockpcl.dx_stop 4 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   6 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   ""
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
;------------------------
#3122:
    return         
end

proc mm_genpcl.genstartdef
    param    u64   .p 
    local    u64   .ms 
    local    u64   .d 
    local    u64   .e 
    local    i64   .lead 
    local    i64   .m 
    local    i64   .s 
    local    i64   .i 
;------------------------
    loadimm  i64   0 
    store    i64   .lead 
    load     u64   .p 
    loadimm  i64   86 
    iloadx   u8    1 0
    store    i64   .m 
    load     u64   .p 
    loadimm  i64   87 
    iloadx   u8    1 0
    store    i64   .s 
    loadref  u64   mm_decls.subprogtable 
    load     i64   .s 
    addptrx  u8:42 42 0
    loadimm  i64   32 
    iloadx   i16   1 0
    load     i64   .m 
    jumpne   i64   #3132 
    loadimm  i64   1 
    store    i64   .lead 
#3132:
#3131:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_genpcl.genlocals 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   149 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        0
    callf    i64   mm_libpcl.createfwdlabel 0 0
    store    i64   mc_decls.retindex 
    load     i64   .lead 
    jumpf    i64   #3134 
    loadimm  u64   1 
    jumpf    i64   #3134 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   1 
    jumplt   i64   #3137 
#3135:
    loadref  u64   mm_decls.moduletosub 
    load     i64   .i 
    iloadx   u8    1 0
    load     i64   .s 
    jumpne   i64   #3139 
    load     i64   .i 
    load     i64   .m 
    jumpeq   i64   #3139 
    loadref  u64   mm_decls.moduletable 
    load     i64   .i 
    addptrx  u8:70 70 0
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .d 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_genpcl.docallproc 1 0
#3139:
#3138:
#3136:
    forup          #3135 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#3137:
#3134:
#3133:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "------------------------"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        1
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "------------------------"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        1
    load     i64   mc_decls.retindex 
    setarg   i64   1
    callp          mm_libpcl.definefwdlabel 1 0
    setcall        0
    callp          mm_genpcl.genreturn 0 0
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_genpcl.checkreturn 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   6 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   ""
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
;------------------------
#3130:
    return         
end

proc mm_genpcl.genpclfunctable
    local    u8:256 .str 
    local    u64   .s 
    local    u64   .t 
    local    u64   .pp 
    local    i64   .firststringlab 
    local    i64   .nextlab 
    local    i64   .nprocs 
;------------------------
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Function Table"
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    loadimm  i64   0 
    store    i64   .nprocs 
    jump           #3147 
#3144:
    load     u8    mm_decls.ffuntab 
    jumpt    i64   #3150 
    load     u64   .pp 
    iload    u64   
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   6 
    loadbit        
    jumpf    u64   #3149 
#3150:
    loadref  u64   .nprocs 
    incrto   i64   1
#3149:
#3148:
#3145:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#3147:
    load     u64   .pp 
    jumpt    u64   #3144 
#3146:
    setcall        2
    setcall        1
    load     u64   mm_libpcl.stnprocs 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   7 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    setcall        2
    setcall        1
    load     i64   .nprocs 
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   ""
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        2
    setcall        1
    load     u64   mm_libpcl.stprocname 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   7 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   12 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   25 
    istorex  u8    1 0
    load     i64   .nprocs 
    loadimm  i64   8 
    mul      i64   
    load     u64   mm_pcl.pccodex 
    loadimm  i64   16 
    istorex  u32   1 0
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #3155 
#3152:
    load     u8    mm_decls.ffuntab 
    jumpt    i64   #3158 
    load     u64   .pp 
    iload    u64   
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   6 
    loadbit        
    jumpf    u64   #3157 
#3158:
    setcall        2
    setcall        1
    load     u64   .pp 
    iload    u64   
    iload    u64   
    setarg   u64   1
    callf    u64   mm_libpcl.genstring 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#3157:
#3156:
#3153:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#3155:
    load     u64   .pp 
    jumpt    u64   #3152 
#3154:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   ""
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
    setcall        2
    setcall        1
    load     u64   mm_libpcl.stprocaddr 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   7 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    loadimm  i64   12 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   25 
    istorex  u8    1 0
    load     i64   .nprocs 
    loadimm  i64   8 
    mul      i64   
    load     u64   mm_pcl.pccodex 
    loadimm  i64   16 
    istorex  u32   1 0
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #3162 
#3159:
    load     u8    mm_decls.ffuntab 
    jumpt    i64   #3165 
    load     u64   .pp 
    iload    u64   
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   6 
    loadbit        
    jumpf    u64   #3164 
#3165:
    setcall        2
    setcall        1
    load     u64   .pp 
    iload    u64   
    setarg   u64   1
    callf    u64   mm_libpcl.genmemaddr 1 0
    setarg   u64   2
    loadimm  i64   9 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#3164:
#3163:
#3160:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#3162:
    load     u64   .pp 
    jumpt    u64   #3159 
#3161:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   ""
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
;------------------------
#3142:
    return         
end

proc mm_genpcl.scansymbol
    param    u64   .d 
    local    u64   .e 
;------------------------
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   7 
    jumpne   i64   #3168 
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   0 
    loadbit        
    jumpf    u64   #3168 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_genpcl.doimportedproc 1 0
#3168:
#3167:
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpeq   i64   #3170 1
    loadimm  i64   3 
    jumpeq   i64   #3170 
    jump           #3171 
#3170:
    jump           #3169 
#3171:
    jump           #3166 
#3169:
    load     u64   .d 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    jump           #3175 
#3172:
    setcall        1
    load     u64   .e 
    setarg   u64   1
    callp          mm_genpcl.scansymbol 1 0
#3173:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#3175:
    load     u64   .e 
    jumpt    u64   #3172 
#3174:
;------------------------
#3166:
    return         
end

proc mm_genpcl.doimportedproc
    param    u64   .d 
    local    u64   .e 
;------------------------
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   10 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    loadref  u64   mm_decls.ttisblock 
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #3178 
    setcall        3
    loadimm  i64   13 
    setarg   i64   3
    setcall        1
    loadimm  u64   "$dummy"
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .e 
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .e 
    loadimm  i64   64 
    istorex  i32   1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   11 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#3178:
#3177:
    load     u64   .d 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    jump           #3183 
#3180:
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   13 
    jumpne   i64   #3185 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   11 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
#3185:
#3184:
#3181:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#3183:
    load     u64   .e 
    jumpt    u64   #3180 
#3182:
    load     u64   .d 
    loadimm  i64   116 
    iloadx   u8    1 0
    jumpf    i64   #3187 
    setcall        2
    setcall        1
    load     u64   .d 
    loadimm  i64   116 
    iloadx   u8    1 0
    setarg   i64   1
    callf    u64   mm_libpcl.genint 1 0
    setarg   u64   2
    loadimm  i64   12 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#3187:
#3186:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   ""
    setarg   u64   1
    callp          mm_libpcl.genpclcomment 2 0
;------------------------
#3176:
    return         
end

proc mm_lex.lexreadtoken
    local    i64   .c 
    local    i64   .hsum 
    local    i64   .commentseen 
    local    i64   .hashindex 
    local    i64   .length 
    local    u64   .pstart 
    local    u64   .pnext 
    local    u64   .p 
    local    u64   .ss 
    local    u64   .lxsvalue 
;------------------------
    loadimm  i64   0 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
#3190:
    load     u64   mm_lex.lxsptr 
    store    u64   mm_lex.lxstart 
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    switch         #3192 0 239
    opnd           #3193 
#3192:
    swlabel        #3332 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3329 
    swlabel        #3331 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3330 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3329 
    swlabel        #3220 
    swlabel        #3327 
    swlabel        #3229 
    swlabel        #3194 
    swlabel        #3304 
    swlabel        #3322 
    swlabel        #3326 
    swlabel        #3279 
    swlabel        #3280 
    swlabel        #3300 
    swlabel        #3292 
    swlabel        #3268 
    swlabel        #3295 
    swlabel        #3259 
    swlabel        #3303 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3209 
    swlabel        #3270 
    swlabel        #3269 
    swlabel        #3309 
    swlabel        #3305 
    swlabel        #3316 
    swlabel        #3290 
    swlabel        #3287 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3208 
    swlabel        #3281 
    swlabel        #3237 
    swlabel        #3282 
    swlabel        #3286 
    swlabel        #3194 
    swlabel        #3328 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3194 
    swlabel        #3257 
    swlabel        #3283 
    swlabel        #3258 
    swlabel        #3291 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3193 
    swlabel        #3335 
    endsw          
#3194:
    load     u64   mm_lex.lxsptr 
    loadimm  i64   1 
    subptrx  u64   1 0
    store    u64   .lxsvalue 
;doname::
#3195:
    load     u64   .lxsvalue 
    iload    u8    
    store    i64   .hsum 
    load     u64   mm_lex.lxsptr 
    iload    u8    
    double         
    store    i64   .c 
    loadimm  i64   34 
    jumpne   i64   #3197 
    load     i64   .hsum 
    loadimm  i64   70 
    jumpeq   i64   #3199 1
    loadimm  i64   102 
    jumpeq   i64   #3199 1
    loadimm  i64   82 
    jumpeq   i64   #3199 1
    loadimm  i64   114 
    jumpeq   i64   #3199 1
    loadimm  i64   65 
    jumpeq   i64   #3200 1
    loadimm  i64   97 
    jumpeq   i64   #3200 1
    loadimm  i64   90 
    jumpeq   i64   #3200 1
    loadimm  i64   122 
    jumpeq   i64   #3200 
    jump           #3201 
#3199:
    setcall        0
    callp          mm_lex.readrawstring 0 0
    jump           #3189 
    jump           #3198 
#3200:
    setcall        1
    load     u64   .lxsvalue 
    iload    u8    
    setarg   i64   1
    callp          mm_lex.readarraystring 1 0
    jump           #3189 
    jump           #3198 
#3201:
#3198:
    jump           #3196 
#3197:
    loadref  u64   mm_lex.alphamap 
    load     i64   .c 
    iloadx   u8    1 0
    jumpf    i64   #3202 
#3203:
    loadref  u64   mm_lex.alphamap 
    load     u64   mm_lex.lxsptr 
    iload    u8    
    double         
    store    i64   .c 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpeq   i64   #3205 1
    loadimm  i64   2 
    jumpeq   i64   #3206 
    jump           #3207 
#3205:
    load     i64   .hsum 
    loadimm  i64   4 
    shl      i64   
    load     i64   .hsum 
    sub      i64   
    load     i64   .c 
    add      i64   
    store    i64   .hsum 
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    jump           #3203 
#3206:
    load     i64   .c 
    loadimm  i64   32 
    add      i64   
    load     u64   mm_lex.lxsptr 
    istore   u8    
    load     i64   .hsum 
    loadimm  i64   4 
    shl      i64   
    load     i64   .hsum 
    sub      i64   
    load     i64   .c 
    loadimm  i64   32 
    add      i64   
    add      i64   
    store    i64   .hsum 
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    jump           #3203 
#3207:
    jump           #3204 
    jump           #3203 
#3204:
#3202:
#3196:
    setcall        3
    load     i64   .hsum 
    loadimm  i64   5 
    shl      i64   
    load     i64   .hsum 
    sub      i64   
    setarg   i64   3
    load     u64   mm_lex.lxsptr 
    load     u64   .lxsvalue 
    subptr   u64   1
    setarg   i64   2
    load     u64   .lxsvalue 
    setarg   u64   1
    callp          mm_lex.lookup 3 0
    jump           #3189 
    jump           #3190 
#3208:
    load     u64   mm_lex.lxsptr 
    loadimm  i64   1 
    subptrx  u64   1 0
    store    u64   .lxsvalue 
    load     u64   .lxsvalue 
    loadimm  i64   32 
    addto    u8    
    jump           #3195 
    jump           #3190 
#3209:
    load     u64   mm_lex.lxsptr 
    loadimm  i64   1 
    subptrx  u64   1 0
    store    u64   mm_lex.lxstart 
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   41 
    jumpeq   u64   #3211 1
    loadimm  u64   13 
    jumpeq   u64   #3211 1
    loadimm  u64   44 
    jumpeq   u64   #3211 1
    loadimm  u64   32 
    jumpeq   u64   #3211 1
    loadimm  u64   120 
    jumpeq   u64   #3212 1
    loadimm  u64   88 
    jumpeq   u64   #3212 
    jump           #3213 
#3211:
    loadimm  i64   71 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   3 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    load     u64   mm_lex.lxstart 
    iload    u8    
    loadimm  u64   48 
    sub      u64   
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  i64   1 0
    jump           #3210 
#3212:
    load     u64   mm_lex.lxstart 
    iload    u8    
    loadimm  u64   48 
    jumpeq   u64   #3215 1
    loadimm  u64   50 
    jumpeq   u64   #3216 1
    loadimm  u64   56 
    jumpeq   u64   #3217 
    jump           #3218 
#3215:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    setcall        0
    callp          mm_lex.readhex 0 0
    jump           #3214 
#3216:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    setcall        0
    callp          mm_lex.readbin 0 0
    jump           #3214 
#3217:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    setcall        0
    callp          mm_lex.readoct 0 0
    jump           #3214 
#3218:
    setcall        1
    loadimm  u64   "Bad base"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3214:
    jump           #3210 
#3213:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    setcall        0
    callp          mm_lex.readdec 0 0
#3210:
    jump           #3189 
    jump           #3190 
#3220:
;docomment::
#3221:
#3222:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3224 0 13
    opnd           #3225 
#3224:
    swlabel        #3228 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3227 
    swlabel        #3225 
    swlabel        #3225 
    swlabel        #3226 
    endsw          
#3226:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    jump           #3223 
    jump           #3222 
#3227:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    jump           #3223 
    jump           #3222 
#3228:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3223 
    jump           #3222 
#3225:
    jump           #3222 
#3223:
    loadimm  i64   66 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3229:
    jump           #3221 
    unload   u64   
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    load     u64   mm_lex.lxsptr 
    store    u64   .lxsvalue 
#3230:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3232 0 13
    opnd           #3233 
#3232:
    swlabel        #3236 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3235 
    swlabel        #3233 
    swlabel        #3233 
    swlabel        #3234 
    endsw          
#3234:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    jump           #3231 
    jump           #3230 
#3235:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    jump           #3231 
    jump           #3230 
#3236:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3231 
    jump           #3230 
#3233:
    jump           #3230 
#3231:
    load     u64   mm_lex.lxsptr 
    load     u64   .lxsvalue 
    subptr   u64   1
    store    i64   .length 
    loadimm  i64   69 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        2
    load     i64   .length 
    setarg   i64   2
    load     u64   .lxsvalue 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstringn 2 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
    jump           #3189 
    jump           #3190 
#3237:
    loadimm  i64   0 
    store    i64   .commentseen 
#3238:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    switch         #3240 0 33
    opnd           #3241 
#3240:
    swlabel        #3244 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3245 
    swlabel        #3243 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3242 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3241 
    swlabel        #3245 
    swlabel        #3246 
    endsw          
#3242:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    jump           #3239 
    jump           #3238 
#3243:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    jump           #3239 
    jump           #3238 
#3244:
    loadimm  i64   67 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3189 
    jump           #3238 
#3245:
    jump           #3238 
#3246:
    loadimm  i64   1 
    store    i64   .commentseen 
    jump           #3238 
#3241:
    load     i64   .commentseen 
    jumpt    i64   #3248 
    setcall        1
    loadimm  u64   "\\ not followed by eol"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3248:
#3247:
    jump           #3238 
#3239:
#3250:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    switch         #3252 9 32
    opnd           #3253 
#3252:
    swlabel        #3256 
    swlabel        #3255 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3254 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3253 
    swlabel        #3256 
    endsw          
#3254:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    jump           #3250 
#3255:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    jump           #3250 
#3256:
    jump           #3250 
#3253:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3251 
    jump           #3250 
#3251:
    jump           #3190 
#3257:
    loadimm  i64   17 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3258:
    loadimm  i64   18 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3259:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    switch         #3261 46 57
    opnd           #3262 
#3261:
    swlabel        #3263 
    swlabel        #3262 
    swlabel        #3266 
    swlabel        #3266 
    swlabel        #3266 
    swlabel        #3266 
    swlabel        #3266 
    swlabel        #3266 
    swlabel        #3266 
    swlabel        #3266 
    swlabel        #3266 
    swlabel        #3266 
    endsw          
#3263:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   46 
    jumpne   u64   #3265 
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   29 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3264 
#3265:
    loadimm  i64   28 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   17 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
#3264:
    jump           #3189 
    jump           #3260 
#3266:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    setcall        1
    loadimm  u64   ".123 not done"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3189 
    jump           #3260 
#3262:
    loadimm  i64   2 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
#3260:
    jump           #3190 
#3268:
    loadimm  i64   5 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3269:
    loadimm  i64   6 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3270:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    switch         #3272 58 61
    opnd           #3273 
#3272:
    swlabel        #3275 
    swlabel        #3273 
    swlabel        #3273 
    swlabel        #3274 
    endsw          
#3274:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   9 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   24 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3271 
#3275:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   61 
    jumpeq   u64   #3277 
    jump           #3278 
#3277:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   10 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3276 
#3278:
    loadimm  i64   8 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
#3276:
    jump           #3271 
#3273:
    loadimm  i64   7 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
#3271:
    jump           #3189 
    jump           #3190 
#3279:
    loadref  u64   mm_decls.nlbrack 
    incrto   i64   1
    loadimm  i64   13 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3280:
    loadimm  i64   14 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3281:
    loadimm  i64   15 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3282:
    loadimm  i64   16 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3283:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   124 
    jumpne   u64   #3285 
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   21 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3284 
#3285:
    loadimm  i64   20 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
#3284:
    jump           #3189 
    jump           #3190 
#3286:
    loadimm  i64   19 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3287:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   64 
    jumpne   u64   #3289 
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   23 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3288 
#3289:
    loadimm  i64   22 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
#3288:
    jump           #3189 
    jump           #3190 
#3290:
    loadimm  i64   24 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3291:
    loadimm  i64   27 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3292:
    loadimm  i64   31 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   43 
    jumpne   u64   #3294 
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   70 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   125 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    loadref  u64   mm_decls.nincr 
    incrto   i64   1
    jump           #3189 
#3294:
#3293:
    jump           #3189 
    jump           #3190 
#3295:
    loadimm  i64   32 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   45 
    jumpeq   u64   #3297 1
    loadimm  u64   62 
    jumpeq   u64   #3298 
    jump           #3299 
#3297:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   70 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadref  u64   mm_decls.nincr 
    incrto   i64   1
    loadimm  i64   128 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3189 
    jump           #3296 
#3298:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   12 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3296 
#3299:
#3296:
    jump           #3189 
    jump           #3190 
#3300:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   42 
    jumpne   u64   #3302 
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   50 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3301 
#3302:
    loadimm  i64   33 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
#3301:
    jump           #3189 
    jump           #3190 
#3303:
    loadimm  i64   34 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3304:
    loadimm  i64   35 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3305:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   62 
    jumpeq   u64   #3307 
    jump           #3308 
#3307:
    loadimm  i64   11 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    jump           #3306 
#3308:
    loadimm  i64   48 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   77 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
#3306:
    jump           #3189 
    jump           #3190 
#3309:
    loadimm  i64   49 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   mm_lex.lxsptr 
    iload    u8    
    switch         #3311 60 62
    opnd           #3312 
#3311:
    swlabel        #3315 
    swlabel        #3313 
    swlabel        #3314 
    endsw          
#3313:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   80 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3310 
#3314:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   78 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3310 
#3315:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   41 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3310 
#3312:
    loadimm  i64   79 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
#3310:
    jump           #3189 
    jump           #3190 
#3316:
    loadimm  i64   49 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   mm_lex.lxsptr 
    iload    u8    
    switch         #3318 61 62
    opnd           #3319 
#3318:
    swlabel        #3320 
    swlabel        #3321 
    endsw          
#3320:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   49 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   81 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3317 
#3321:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   42 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3317 
#3319:
    loadimm  i64   49 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   82 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
#3317:
    jump           #3189 
    jump           #3190 
#3322:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   46 
    jumpeq   u64   #3324 
    jump           #3325 
#3324:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   4 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   0 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3323 
#3325:
    loadimm  i64   25 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   49 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
#3323:
    jump           #3189 
    jump           #3190 
#3326:
    setcall        1
    loadimm  i64   39 
    setarg   i64   1
    callp          mm_lex.lxreadstring 1 0
    jump           #3189 
    jump           #3190 
#3327:
    setcall        1
    loadimm  i64   34 
    setarg   i64   1
    callp          mm_lex.lxreadstring 1 0
    jump           #3189 
    jump           #3190 
#3328:
    setcall        0
    callp          mm_lex.readrawxname 0 0
    jump           #3189 
    jump           #3190 
#3329:
    jump           #3190 
#3330:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    loadimm  i64   66 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3331:
    loadref  u64   mm_lex.lxalllines 
    incrto   i64   1
    loadimm  i64   66 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3332:
    load     i64   mm_lex.sourcelevel 
    jumpf    i64   #3334 
    setcall        0
    callp          mm_lex.unstacksource 0 0
    jump           #3189 
    jump           #3333 
#3334:
    loadimm  i64   67 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3189 
#3333:
    jump           #3190 
#3335:
    loadref  u64   mm_lex.lxsptr 
    loadimm  i64   2 
    addpxto  u64   1 0
    jump           #3190 
#3193:
    loadimm  i64   1 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3189 
    jump           #3190 
#3191:
;------------------------
#3189:
    return         
end

proc mm_lex.lex
    local    i64   .lena 
    local    i64   .lenb 
    local    u64   .p 
;------------------------
    load     u8:16 mm_decls.nextlx 
    store    u8:16 mm_decls.lx 
    load     u64   mm_lex.lxstart 
    load     u64   mm_lex.lxsource 
    subptr   u64   1
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    addptrx  u64   1 0
    loadimm  i64   0 
    loadimm  i64   23 
    storebf  u32   
;reenter::
#3337:
    setcall        0
    callp          mm_lex.lexreadtoken 0 0
;reenter2::
#3338:
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    switch         #3340 48 161
    opnd           #3341 
#3340:
    swlabel        #3384 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3381 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3348 
    swlabel        #3341 
    swlabel        #3380 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3353 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3359 
    swlabel        #3356 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3342 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3341 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3341 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3342 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3342 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3341 
    swlabel        #3342 
    endsw          
#3342:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   104 
    jumpne   i64   #3344 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    jumpf    i64   #3346 
    setcall        1
    loadimm  u64   "end if if?"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3346:
#3345:
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3337 
    unload   u64   
#3344:
#3343:
    jump           #3339 
#3348:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #3351 1
    loadimm  i64   15 
    jumpeq   i64   #3351 1
    loadimm  i64   13 
    jumpne   i64   #3350 
#3351:
    jump           #3337 
    unload   u64   
    jump           #3349 
#3350:
    loadref  u64   mm_tables.symboloptypes 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    loadimm  i64   1 
    jumpne   i64   #3352 
    load     i64   mm_decls.assemmode 
    jumpt    i64   #3352 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   44 
    jumpeq   i64   #3352 1
    loadimm  i64   43 
    jumpeq   i64   #3352 
    jump           #3337 
    unload   u64   
#3352:
#3349:
    loadimm  i64   6 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3339 
#3353:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   76 
    jumpne   i64   #3355 
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .lena 
    setcall        1
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .lenb 
    setcall        1
    load     i64   .lena 
    load     i64   .lenb 
    add      i64   
    loadimm  i64   1 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .p 
    setcall        3
    load     i64   .lena 
    setarg   u64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          memcpy 3 0
    setcall        3
    load     i64   .lenb 
    setarg   u64   3
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    load     i64   .lena 
    addptrx  u64   1 0
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   .p 
    load     i64   .lena 
    addptrx  u64   1 0
    load     i64   .lenb 
    addptrx  u64   1 0
    istore   u8    
    load     u64   .p 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    istorex  u64   1 0
#3355:
#3354:
    jump           #3339 
#3356:
    setcall        1
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    iloadx   u8    1 0
    setarg   i64   1
    callf    i64   mm_lex.dolexdirective 1 0
    jumpt    i64   #3358 
    jump           #3337 
    unload   u64   
#3358:
#3357:
    jump           #3339 
#3359:
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   79 
    jumpeq   i64   #3361 1
    loadimm  i64   147 
    jumpeq   i64   #3362 
    jump           #3363 
#3361:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   71 
    jumpeq   i64   #3365 1
    loadimm  i64   73 
    jumpeq   i64   #3366 
    jump           #3367 
#3365:
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    loadimm  i64   2 
    jumpeq   i64   #3369 1
    loadimm  i64   3 
    jumpeq   i64   #3370 1
    loadimm  i64   1 
    jumpeq   i64   #3371 1
    loadimm  i64   4 
    jumpeq   i64   #3372 1
    loadimm  i64   5 
    jumpeq   i64   #3373 1
    loadimm  i64   6 
    jumpeq   i64   #3374 
    jump           #3375 
#3369:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    addptrx  u64   1 0
    loadimm  i64   1000000 
    multo    i64   
    jump           #3368 
#3370:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    addptrx  u64   1 0
    loadimm  i64   1000000000 
    multo    i64   
    jump           #3368 
#3371:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    addptrx  u64   1 0
    loadimm  i64   1000 
    multo    i64   
    jump           #3368 
#3372:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    addptrx  u64   1 0
    loadimm  i64   1024 
    multo    i64   
    jump           #3368 
#3373:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    addptrx  u64   1 0
    loadimm  i64   1048576 
    multo    i64   
    jump           #3368 
#3374:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    addptrx  u64   1 0
    loadimm  i64   1073741824 
    multo    i64   
    jump           #3368 
#3375:
    setcall        1
    loadimm  u64   "Can't do this unit index"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3368:
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lex.setinttype 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3337 
    unload   u64   
    jump           #3364 
#3366:
    setcall        1
    loadimm  u64   "Unit suffix after float not implem"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3364 
#3367:
    loadimm  i64   80 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
#3364:
    jump           #3360 
#3362:
    load     i64   mm_decls.headermode 
    jumpt    i64   #3379 
    loadimm  i64   80 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3378 
#3379:
    loadimm  i64   147 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    iloadx   i32   1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
#3378:
    jump           #3360 
#3363:
    loadimm  i64   80 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
#3360:
    jump           #3339 
#3380:
    loadimm  i64   80 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3339 
#3381:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #3383 
    loadimm  i64   52 
    loadref  u64   mm_decls.lx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   152 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3337 
    unload   u64   
#3383:
#3382:
    jump           #3339 
#3384:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #3386 
    loadimm  i64   49 
    loadref  u64   mm_decls.lx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   78 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3337 
    unload   u64   
#3386:
#3385:
    jump           #3339 
#3341:
#3339:
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   4 
    iloadx   u32   1 0
    load     i64   mm_lex.lxfileno 
    loadimm  i64   24 
    shl      i64   
    bitor    i64   
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   4 
    istorex  u32   1 0
;------------------------
#3336:
    return         
end

proc mm_lex.lexsetup
;------------------------
    setcall        0
    callp          mm_lex.inithashtable 0 0
;------------------------
#3387:
    return         
end

proc mm_lex.printstrn
    param    u64   .s 
    param    i64   .length 
;------------------------
    load     i64   .length 
    jumpf    i64   #3390 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "v"
    load     i64   .length 
    callp          msys.m$print_i64 2 0
    loadimm  u64   ".*"
    load     u64   .s 
    callp          msys.m$print_str 2 0
    callp          msys.m$print_end 0 0
#3390:
#3389:
;------------------------
#3388:
    return         
end

proc mm_lex.readrawstring
    local    u64   .dest 
    local    i64   .c 
;------------------------
    loadimm  i64   76 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadref  u64   mm_lex.lxsptr 
    incrload u64   1
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   mm_lex.lxsptr 
    store    u64   .dest 
#3394:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3396 0 34
    opnd           #3397 
#3396:
    swlabel        #3401 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3401 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3401 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3397 
    swlabel        #3398 
    endsw          
#3398:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   34 
    jumpne   u64   #3400 
    loadimm  u64   34 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    jump           #3399 
#3400:
    loadimm  u64   0 
    load     u64   mm_lex.lxsptr 
    loadimm  i64   1 
    subptrx  u64   1 0
    istore   u8    
    jump           #3395 
#3399:
    jump           #3394 
#3401:
    setcall        1
    loadimm  u64   "Raw string not terminated"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3395 
    jump           #3394 
#3397:
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    jump           #3394 
#3395:
;------------------------
#3393:
    return         
end

proc mm_lex.lookup
    param    u64   .name 
    param    i64   .length 
    param    i64   .hashindex0 
    local    i64   .wrapped 
    local    i64   .hashindex 
    local    i64   .index 
    local    i64   .n 
    local    u64   .d 
    local    i64   .j 
;------------------------
    load     i64   .hashindex0 
    loadimm  i64   65535 
    bitand   i64   
    store    i64   .j 
    loadref  u64   mm_lex.hashtable 
    load     i64   .j 
    iloadx   u64   8 0
    store    u64   .d 
    loadimm  i64   0 
    store    i64   .wrapped 
#3404:
    load     u64   .d 
    loadimm  u64   0 
    jumpne   u64   #3407 
    jump           #3405 
#3407:
#3406:
    load     u64   .d 
    loadimm  i64   68 
    iloadx   u8    1 0
    double         
    store    i64   .n 
    load     i64   .length 
    jumpne   i64   #3409 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .name 
    setarg   u64   2
    load     u64   .d 
    iload    u64   
    setarg   u64   1
    callf    i32   memcmp 3 0
    widen    i32   
    loadimm  i64   0 
    jumpne   i64   #3409 
    load     u64   .d 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .d 
    loadimm  i64   69 
    iloadx   u8    1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .d 
    loadimm  i64   71 
    iloadx   u8    1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #3403 
#3409:
#3408:
    loadref  u64   .j 
    incrload i64   1
    loadimm  i64   65536 
    jumplt   i64   #3411 
    load     i64   .wrapped 
    jumpf    i64   #3413 
    setcall        1
    loadimm  u64   "HASHTABLE FULL"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
#3413:
#3412:
    loadimm  i64   1 
    store    i64   .wrapped 
    loadimm  i64   0 
    store    i64   .j 
#3411:
#3410:
    loadref  u64   mm_lex.hashtable 
    load     i64   .j 
    iloadx   u64   8 0
    store    u64   .d 
    jump           #3404 
#3405:
    setcall        1
    loadimm  i64   193 
    setarg   i64   1
    callf    u64   mlib.pcm_allocz 1 0
    store    u64   .d 
    load     u64   .d 
    loadref  u64   mm_lex.hashtable 
    load     i64   .j 
    istorex  u64   8 0
    setcall        2
    load     i64   .length 
    setarg   i64   2
    load     u64   .name 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstringn 2 0
    load     u64   .d 
    loadimm  i64   0 
    istorex  u64   1 0
    load     i64   .length 
    load     u64   .d 
    loadimm  i64   68 
    istorex  u8    1 0
    loadimm  i64   80 
    load     u64   .d 
    loadimm  i64   69 
    istorex  u8    1 0
    load     u64   .d 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .d 
    loadimm  i64   69 
    iloadx   u8    1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
;------------------------
#3403:
    return         
end

proc mm_lex.lookupsys
    rettype  i64   
    param    u64   .name 
    local    i64   .j 
    local    i64   .wrapped 
    local    i64   .hashvalue 
;------------------------
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    i64   mm_lex.gethashvaluez 1 0
    loadimm  i64   65535 
    bitand   i64   
    store    i64   .j 
    loadref  u64   mm_lex.hashtable 
    load     i64   .j 
    iloadx   u64   8 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    istorex  u64   1 0
    loadimm  i64   0 
    store    i64   .wrapped 
#3416:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #3419 
    jump           #3417 
    jump           #3418 
#3419:
    setcall        2
    load     u64   .name 
    setarg   u64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #3420 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Lex dupl name:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .name 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           1
#3420:
#3418:
    loadref  u64   .j 
    incrload i64   1
    loadimm  i64   65536 
    jumplt   i64   #3423 
    load     i64   .wrapped 
    jumpf    i64   #3425 
    setcall        1
    loadimm  u64   "SYS:HASHTABLE FULL"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
#3425:
#3424:
    loadimm  i64   1 
    store    i64   .wrapped 
    loadimm  i64   0 
    store    i64   .j 
#3423:
#3422:
    loadref  u64   mm_lex.hashtable 
    load     i64   .j 
    iloadx   u64   8 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    istorex  u64   1 0
    jump           #3416 
#3417:
    setcall        1
    loadimm  i64   193 
    setarg   i64   1
    callf    u64   mlib.pcm_allocz 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    istorex  u64   1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadref  u64   mm_lex.hashtable 
    load     i64   .j 
    istorex  u64   8 0
    load     u64   .name 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   0 
    istorex  u64   1 0
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    i64   strlen 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   68 
    istorex  u8    1 0
    loadimm  i64   80 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   69 
    istorex  u8    1 0
    loadimm  i64   0 
    setret   i64   
    jump           #3415 
;------------------------
#3415:
    return         
end

proc mm_lex.gethashvaluez
    rettype  i64   
    param    u64   .s 
    local    i64   .c 
    local    i64   .hsum 
;------------------------
    load     u64   .s 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #3429 
    loadimm  i64   0 
    setret   i64   
    jump           #3427 
#3429:
#3428:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    store    i64   .hsum 
#3430:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    store    i64   .c 
    load     i64   .c 
    loadimm  i64   0 
    jumpne   i64   #3433 
    jump           #3431 
#3433:
#3432:
    load     i64   .hsum 
    loadimm  i64   4 
    shl      i64   
    load     i64   .hsum 
    sub      i64   
    load     i64   .c 
    add      i64   
    store    i64   .hsum 
    jump           #3430 
#3431:
    load     i64   .hsum 
    loadimm  i64   5 
    shl      i64   
    load     i64   .hsum 
    sub      i64   
    setret   i64   
    jump           #3427 
;------------------------
#3427:
    return         
end

proc mm_lex.inithashtable
    local    i64   .i 
    local    i64   .$av_1 
;------------------------
    setcall        3
    loadimm  u64   524288 
    setarg   u64   3
    loadimm  i64   0 
    setarg   i32   2
    loadref  u64   mm_lex.hashtable 
    setarg   u64   1
    callp          memset 3 0
    loadimm  i64   1 
    store    i64   .i 
#3435:
    setcall        1
    loadref  u64   mm_tables.stnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    i64   mm_lex.lookupsys 1 0
    unload   i64   
    loadref  u64   mm_tables.stsymbols 
    load     i64   .i 
    iloadx   i64   8 -8
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   69 
    istorex  u8    1 0
    loadref  u64   mm_tables.stsymbols 
    load     i64   .i 
    iloadx   i64   8 -8
    loadimm  i64   79 
    jumpeq   i64   #3439 1
    loadimm  i64   147 
    jumpeq   i64   #3439 
    jump           #3440 
#3439:
    loadref  u64   mm_tables.stsubcodes 
    load     i64   .i 
    iloadx   i64   8 -8
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    istorex  i32   1 0
    loadref  u64   mm_tables.stsymbols 
    load     i64   .i 
    iloadx   i64   8 -8
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   71 
    istorex  u8    1 0
    loadimm  i64   80 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   69 
    istorex  u8    1 0
    jump           #3438 
#3440:
    loadref  u64   mm_tables.stsubcodes 
    load     i64   .i 
    iloadx   i64   8 -8
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   71 
    istorex  u8    1 0
#3438:
#3436:
    forup          #3435 1
    opnd           .i 
    opnd           245 
#3437:
;------------------------
#3434:
    return         
end

proc mm_lex.printhashtable
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Hashtable:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;------------------------
#3441:
    return         
end

proc mm_lex.addreservedword
    param    u64   .name 
    param    i64   .symbol 
    param    i64   .subcode 
    param    i64   .regsize 
;------------------------
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    i64   mm_lex.lookupsys 1 0
    unload   i64   
    loadimm  i64   80 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   69 
    istorex  u8    1 0
    load     i64   .symbol 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   71 
    istorex  u8    1 0
    load     i64   .subcode 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   72 
    istorex  i32   1 0
    load     i64   .regsize 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   158 
    istorex  i16   1 0
;------------------------
#3443:
    return         
end

proc mm_lex.dolexdirective
    rettype  i64   
    param    i64   .index 
    local    u64   .symptr 
    local    u64   .p 
    local    u64   .file 
    local    i64   .i 
    local    i64   .lastsymbol 
    local    i64   .cond 
    local    i64   .fileno 
    local    i64   .length 
    local    u8:256 .str 
;------------------------
    load     i64   .index 
    loadimm  i64   2 
    jumpeq   i64   #3446 1
    loadimm  i64   1 
    jumpeq   i64   #3447 
    jump           #3448 
#3446:
    setcall        0
    callp          mm_lex.lexreadtoken 0 0
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   76 
    jumpeq   i64   #3450 
    setcall        1
    loadimm  u64   "strincl: string expected"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3449 
#3450:
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .file 
#3449:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  i64   0 
    setarg   i64   4
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    load     u64   .file 
    setarg   u64   1
    callf    i64   mm_support.getsupportfile 5 0
    store    i64   .fileno 
    loadref  u64   mm_decls.sourcefiletext 
    load     i64   .fileno 
    iloadx   u64   8 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
    loadref  u64   mm_decls.sourcefilesizes 
    load     i64   .fileno 
    iloadx   i64   8 0
    double         
    store    i64   .length 
    store    i64   mm_lex.astringlength 
    loadimm  i64   77 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   65 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    loadimm  u64   0 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    load     i64   .length 
    addptrx  u64   1 0
    istore   u8    
    loadimm  i64   1 
    setret   i64   
    jump           #3444 
    jump           #3445 
#3447:
    setcall        0
    callp          mm_lex.lexreadtoken 0 0
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   76 
    jumpeq   i64   #3454 
    setcall        1
    loadimm  u64   "include: string expected"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3454:
#3453:
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .file 
    setcall        1
    load     u64   .file 
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
    setcall        2
    loadimm  u64   "m"
    setarg   u64   2
    load     u64   .file 
    setarg   u64   1
    callf    u64   mlib.addext 2 0
    store    u64   .file 
    setcall        5
    loadimm  i64   1 
    setarg   i64   5
    loadimm  i64   0 
    setarg   i64   4
    loadref  u64   mm_decls.sourcefilepaths 
    load     i64   mm_lex.lxfileno 
    iloadx   u64   8 0
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    load     u64   .file 
    setarg   u64   1
    callf    i64   mm_support.getsupportfile 5 0
    store    i64   .fileno 
    setcall        0
    callp          mm_lex.lexreadtoken 0 0
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     i64   .fileno 
    setarg   i64   1
    callp          mm_lex.stacksource 2 0
    loadimm  i64   0 
    setret   i64   
    jump           #3444 
    jump           #3445 
#3448:
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_tables.sourcedirnames 
    load     i64   .index 
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "Directive not implemented"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3445:
    loadimm  i64   0 
    setret   i64   
    jump           #3444 
;------------------------
#3444:
    return         
end

proc mm_lex.startlex
    param    i64   .fileno 
;------------------------
    loadref  u64   mm_decls.sourcefiletext 
    load     i64   .fileno 
    iloadx   u64   8 0
    double         
    store    u64   mm_lex.lxsptr 
    store    u64   mm_lex.lxsource 
    loadimm  i64   0 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   4 
    istorex  u32   1 0
    load     i64   .fileno 
    store    i64   mm_lex.lxfileno 
    loadimm  i64   6 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   0 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
;------------------------
#3459:
    return         
end

proc mm_lex.start
    local    i64   .i 
;------------------------
    loadimm  i64   0 
    store    i64   .i 
#3461:
    load     i64   .i 
    switch         #3465 36 122
    opnd           #3466 
#3465:
    swlabel        #3467 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3468 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3466 
    swlabel        #3467 
    swlabel        #3466 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    swlabel        #3467 
    endsw          
#3467:
    loadimm  i64   1 
    loadref  u64   mm_lex.alphamap 
    load     i64   .i 
    istorex  u8    1 0
    jump           #3464 
#3468:
    loadimm  i64   2 
    loadref  u64   mm_lex.alphamap 
    load     i64   .i 
    istorex  u8    1 0
    jump           #3464 
#3466:
#3464:
#3462:
    forup          #3461 1
    opnd           .i 
    opnd           255 
#3463:
;------------------------
#3460:
    return         
end

;
proc mm_lex.addnamestr
    rettype  u64   
    param    u64   .name 
    local    u8:16 .oldlx 
    local    u64   .symptr 
;------------------------
    load     u8:16 mm_decls.nextlx 
    store    u8:16 .oldlx 
    setcall        3
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    i64   mm_lex.gethashvaluez 1 0
    setarg   i64   3
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    i64   strlen 1 0
    setarg   i64   2
    load     u64   .name 
    setarg   u64   1
    callp          mm_lex.lookup 3 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .symptr 
    load     u8:16 .oldlx 
    store    u8:16 mm_decls.nextlx 
    load     u64   .symptr 
    setret   u64   
    jump           #3469 
;------------------------
#3469:
    return         
end

proc mm_lex.ps
    param    u64   .caption 
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "PS:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .caption 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   ": "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   mm_decls.lx 
    setarg   u64   1
    callp          mm_diags.printsymbol 1 0
;------------------------
#3470:
    return         
end

proc mm_lex.psnext
    param    u64   .caption 
;------------------------
    callp          msys.m$print_startcon 0 0
    load     u64   .caption 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   ": "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   mm_decls.nextlx 
    setarg   u64   1
    callp          mm_diags.printsymbol 1 0
;------------------------
#3473:
    return         
end

proc mm_lex.psx
    param    u64   .caption 
;------------------------
    callp          msys.m$print_startcon 0 0
    load     u64   .caption 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   ": "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   mm_decls.lx 
    setarg   u64   1
    callp          mm_diags.printsymbol 1 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "\t"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   mm_decls.nextlx 
    setarg   u64   1
    callp          mm_diags.printsymbol 1 0
;------------------------
#3474:
    return         
end

proc mm_lex.stacksource
    param    i64   .fileno 
    param    i64   .isimport 
;------------------------
    load     i64   mm_lex.sourcelevel 
    loadimm  i64   20 
    jumplt   i64   #3478 
    setcall        1
    loadimm  u64   "Include file/macro overflow"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3478:
#3477:
    loadref  u64   mm_lex.sourcelevel 
    incrto   i64   1
    load     u64   mm_lex.lxstart 
    loadref  u64   mm_lex.lxstart_stack 
    load     i64   mm_lex.sourcelevel 
    istorex  u64   8 -8
    load     u64   mm_lex.lxsource 
    loadref  u64   mm_lex.lxsource_stack 
    load     i64   mm_lex.sourcelevel 
    istorex  u64   8 -8
    load     u64   mm_lex.lxsptr 
    loadref  u64   mm_lex.lxsptr_stack 
    load     i64   mm_lex.sourcelevel 
    istorex  u64   8 -8
    load     i64   mm_lex.lxfileno 
    loadref  u64   mm_lex.lxfileno_stack 
    load     i64   mm_lex.sourcelevel 
    istorex  i64   8 -8
    load     u8:16 mm_decls.nextlx 
    loadref  u64   mm_lex.lxnextlx_stack 
    load     i64   mm_lex.sourcelevel 
    istorex  u8:16 16 -16
    load     i64   mm_lex.lximport 
    loadref  u64   mm_lex.lximport_stack 
    load     i64   mm_lex.sourcelevel 
    istorex  u8    1 -1
    load     i64   .isimport 
    store    i64   mm_lex.lximport 
    loadref  u64   mm_decls.sourcefiletext 
    load     i64   .fileno 
    iloadx   u64   8 0
    double         
    store    u64   mm_lex.lxsptr 
    store    u64   mm_lex.lxsource 
    loadimm  i64   0 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   4 
    istorex  u32   1 0
    load     i64   .fileno 
    store    i64   mm_lex.lxfileno 
    loadimm  i64   6 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   0 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
;------------------------
#3476:
    return         
end

proc mm_lex.unstacksource
;------------------------
    load     i64   mm_lex.sourcelevel 
    loadimm  i64   0 
    jumple   i64   #3482 
    loadref  u64   mm_lex.lxstart_stack 
    load     i64   mm_lex.sourcelevel 
    iloadx   u64   8 -8
    store    u64   mm_lex.lxstart 
    loadref  u64   mm_lex.lxsource_stack 
    load     i64   mm_lex.sourcelevel 
    iloadx   u64   8 -8
    store    u64   mm_lex.lxsource 
    loadref  u64   mm_lex.lxsptr_stack 
    load     i64   mm_lex.sourcelevel 
    iloadx   u64   8 -8
    store    u64   mm_lex.lxsptr 
    loadref  u64   mm_lex.lxnextlx_stack 
    load     i64   mm_lex.sourcelevel 
    addptrx  u8:16 16 -16
    store    u8:16 mm_decls.nextlx 
    loadref  u64   mm_lex.lxfileno_stack 
    load     i64   mm_lex.sourcelevel 
    iloadx   i64   8 -8
    store    i64   mm_lex.lxfileno 
    loadref  u64   mm_lex.lximport_stack 
    load     i64   mm_lex.sourcelevel 
    iloadx   u8    1 -1
    store    i64   mm_lex.lximport 
    loadref  u64   mm_lex.sourcelevel 
    decrto   i64   1
#3482:
#3481:
;------------------------
#3480:
    return         
end

proc mm_lex.readarraystring
    param    i64   .prefix 
;------------------------
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    setcall        1
    loadimm  i64   34 
    setarg   i64   1
    callp          mm_lex.lxreadstring 1 0
    loadimm  i64   77 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        1
    load     i64   .prefix 
    setarg   i32   1
    callf    i32   toupper 1 0
    widen    i32   
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    setcall        1
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   mm_lex.astringlength 
;------------------------
#3483:
    return         
end

proc mm_lex.setinttype
    rettype  i64   
    param    u64   .a 
;------------------------
    startmx        
    load     u64   .a 
    loadimm  u64   9223372036854775807 
    jumpgt   u64   #3486 
    loadimm  i64   3 
    resetmx        
    jump           #3485 
#3486:
    loadimm  i64   2 
    endmx          
#3485:
    setret   i64   
    jump           #3484 
;------------------------
#3484:
    return         
end

proc mm_lex.readrawxname
    local    i64   .c 
    local    i64   .hsum 
    local    i64   .length 
;------------------------
    load     u64   mm_lex.lxsptr 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
    loadimm  i64   0 
    store    i64   .hsum 
#3488:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3490 36 122
    opnd           #3491 
#3490:
    swlabel        #3492 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3491 
    swlabel        #3492 
    swlabel        #3491 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    swlabel        #3492 
    endsw          
#3492:
    load     i64   .hsum 
    loadimm  i64   4 
    shl      i64   
    load     i64   .hsum 
    sub      i64   
    load     i64   .c 
    add      i64   
    store    i64   .hsum 
    jump           #3488 
#3491:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3489 
    jump           #3488 
#3489:
    load     u64   mm_lex.lxsptr 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    subptr   u64   1
    store    i64   .length 
    load     i64   .length 
    loadimm  i64   0 
    jumpne   i64   #3494 
    setcall        1
    loadimm  u64   "Bad ` name"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3494:
#3493:
    setcall        3
    load     i64   .hsum 
    loadimm  i64   5 
    shl      i64   
    load     i64   .hsum 
    sub      i64   
    setarg   i64   3
    load     i64   .length 
    setarg   i64   2
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_lex.lookup 3 0
    loadimm  i64   68 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3487 
;------------------------
#3487:
    return         
end

proc mm_lex.lxerror_s
    param    u64   .mess 
    param    u64   .s 
;------------------------
    setcall        1
    load     u64   .mess 
    setarg   u64   1
    callp          mm_support.lxerror 1 0
;------------------------
#3496:
    return         
end

proc mm_lex.lxreadstring
    param    i64   .termchar 
    local    u64   .s 
    local    u64   .t 
    local    i64   .c 
    local    i64   .d 
    local    i64   .length 
    local    i64   .hasescape 
    local    u64   .str 
    local    i64   .$av_1 
;------------------------
    load     i64   .termchar 
    loadimm  i64   34 
    jumpne   i64   #3499 
    loadimm  i64   76 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #3498 
#3499:
    loadimm  i64   74 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   3 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
#3498:
    load     u64   mm_lex.lxsptr 
    store    u64   .s 
    loadimm  i64   0 
    store    i64   .length 
    loadimm  i64   0 
    store    i64   .hasescape 
#3500:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3502 0 92
    opnd           #3503 
#3502:
    swlabel        #3519 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3519 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3519 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3514 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3514 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3503 
    swlabel        #3504 
    endsw          
#3504:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    store    i64   .c 
    load     i64   .c 
    loadimm  i64   65 
    jumplt   i64   #3506 1
    loadimm  i64   90 
    jumpgt   i64   #3506 
    loadref  u64   .c 
    loadimm  i64   32 
    addto    i64   
#3506:
#3505:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadimm  i64   1 
    store    i64   .hasescape 
    load     i64   .c 
    switch         #3508 34 122
    opnd           #3509 
#3508:
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3510 
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3510 
    swlabel        #3510 
    swlabel        #3510 
    swlabel        #3509 
    swlabel        #3510 
    swlabel        #3511 
    swlabel        #3512 
    swlabel        #3510 
    swlabel        #3510 
    endsw          
#3510:
    loadref  u64   .length 
    incrto   i64   1
    jump           #3507 
#3511:
    loadref  u64   .length 
    incrto   i64   1
    jump           #3507 
#3512:
    loadref  u64   mm_lex.lxsptr 
    loadimm  i64   2 
    addpxto  u64   1 0
    loadref  u64   .length 
    incrto   i64   1
    jump           #3507 
#3509:
    setcall        1
    loadimm  u64   "Bad str escape"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3507:
    jump           #3500 
#3514:
    load     i64   .c 
    load     i64   .termchar 
    jumpne   i64   #3516 
    load     u64   mm_lex.lxsptr 
    iload    u8    
    load     i64   .c 
    jumpne   i64   #3518 
    loadimm  i64   1 
    store    i64   .hasescape 
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
    loadref  u64   .length 
    incrto   i64   1
    jump           #3517 
#3518:
    jump           #3501 
#3517:
    jump           #3515 
#3516:
    loadref  u64   .length 
    incrto   i64   1
#3515:
    jump           #3500 
#3519:
    setcall        1
    loadimm  u64   "String not terminated"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3500 
#3503:
    loadref  u64   .length 
    incrto   i64   1
    jump           #3500 
#3501:
    load     i64   .length 
    loadimm  i64   0 
    jumpne   i64   #3522 
    loadimm  u64   ""
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
    jump           #3497 
    jump           #3521 
#3522:
    load     i64   .hasescape 
    jumpt    i64   #3524 
    setcall        2
    load     i64   .length 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstringn 2 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
    jump           #3497 
#3524:
#3521:
    setcall        1
    load     i64   .length 
    loadimm  i64   1 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    double         
    store    u64   .t 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  u64   1 0
#3525:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3528 0 92
    opnd           #3529 
#3528:
    swlabel        #3567 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3567 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3567 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3562 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3562 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3529 
    swlabel        #3530 
    endsw          
#3530:
    load     u64   .s 
    iload    u8    
    store    i64   .c 
    load     i64   .c 
    loadimm  i64   65 
    jumplt   i64   #3532 
    load     i64   .c 
    loadimm  i64   90 
    jumpgt   i64   #3532 
    loadref  u64   .c 
    loadimm  i64   32 
    addto    i64   
#3532:
#3531:
    loadref  u64   .s 
    incrto   u64   1
    load     i64   .c 
    switch         #3534 34 122
    opnd           #3535 
#3534:
    swlabel        #3558 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3560 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3557 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3558 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3559 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3536 
    swlabel        #3537 
    swlabel        #3538 
    swlabel        #3535 
    swlabel        #3539 
    swlabel        #3540 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3541 
    swlabel        #3535 
    swlabel        #3541 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3535 
    swlabel        #3538 
    swlabel        #3542 
    swlabel        #3543 
    swlabel        #3535 
    swlabel        #3544 
    swlabel        #3545 
    swlabel        #3546 
    swlabel        #3556 
    swlabel        #3557 
    endsw          
#3536:
    loadimm  i64   7 
    store    i64   .c 
    jump           #3533 
#3537:
    loadimm  i64   8 
    store    i64   .c 
    jump           #3533 
#3538:
    loadimm  i64   13 
    store    i64   .c 
    jump           #3533 
#3539:
    loadimm  i64   26 
    store    i64   .c 
    jump           #3533 
#3540:
    loadimm  i64   12 
    store    i64   .c 
    jump           #3533 
#3541:
    loadimm  i64   10 
    store    i64   .c 
    jump           #3533 
#3542:
    loadimm  i64   27 
    store    i64   .c 
    jump           #3533 
#3543:
    loadimm  i64   9 
    store    i64   .c 
    jump           #3533 
#3544:
    loadimm  i64   11 
    store    i64   .c 
    jump           #3533 
#3545:
    loadimm  u64   13 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  i64   10 
    store    i64   .c 
    jump           #3533 
#3546:
    loadimm  i64   0 
    store    i64   .c 
    loadimm  i64   2 
    store    i64   .$av_1 
#3547:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .d 
    loadimm  i64   65 
    jumpeq   i64   #3551 1
    loadimm  i64   66 
    jumpeq   i64   #3551 1
    loadimm  i64   67 
    jumpeq   i64   #3551 1
    loadimm  i64   68 
    jumpeq   i64   #3551 1
    loadimm  i64   69 
    jumpeq   i64   #3551 1
    loadimm  i64   70 
    jumpeq   i64   #3551 1
    loadimm  i64   97 
    jumpeq   i64   #3552 1
    loadimm  i64   98 
    jumpeq   i64   #3552 1
    loadimm  i64   99 
    jumpeq   i64   #3552 1
    loadimm  i64   100 
    jumpeq   i64   #3552 1
    loadimm  i64   101 
    jumpeq   i64   #3552 1
    loadimm  i64   102 
    jumpeq   i64   #3552 1
    loadimm  i64   48 
    jumpeq   i64   #3553 1
    loadimm  i64   49 
    jumpeq   i64   #3553 1
    loadimm  i64   50 
    jumpeq   i64   #3553 1
    loadimm  i64   51 
    jumpeq   i64   #3553 1
    loadimm  i64   52 
    jumpeq   i64   #3553 1
    loadimm  i64   53 
    jumpeq   i64   #3553 1
    loadimm  i64   54 
    jumpeq   i64   #3553 1
    loadimm  i64   55 
    jumpeq   i64   #3553 1
    loadimm  i64   56 
    jumpeq   i64   #3553 1
    loadimm  i64   57 
    jumpeq   i64   #3553 
    jump           #3554 
#3551:
    load     i64   .c 
    loadimm  i64   16 
    mul      i64   
    load     i64   .d 
    add      i64   
    loadimm  i64   65 
    sub      i64   
    loadimm  i64   10 
    add      i64   
    store    i64   .c 
    jump           #3550 
#3552:
    load     i64   .c 
    loadimm  i64   16 
    mul      i64   
    load     i64   .d 
    add      i64   
    loadimm  i64   97 
    sub      i64   
    loadimm  i64   10 
    add      i64   
    store    i64   .c 
    jump           #3550 
#3553:
    load     i64   .c 
    loadimm  i64   16 
    mul      i64   
    load     i64   .d 
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    i64   .c 
    jump           #3550 
#3554:
    setcall        1
    loadimm  u64   "Bad \\x code"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3550:
#3548:
    to             #3547 
    opnd           .$av_1 
#3549:
    jump           #3533 
#3556:
    loadimm  i64   16 
    store    i64   .c 
    jump           #3533 
#3557:
    loadimm  i64   0 
    store    i64   .c 
    jump           #3533 
#3558:
    loadimm  i64   34 
    store    i64   .c 
    jump           #3533 
#3559:
    loadimm  i64   92 
    store    i64   .c 
    jump           #3533 
#3560:
    loadimm  i64   39 
    store    i64   .c 
    jump           #3533 
#3535:
    load     i64   .c 
    loadref  u64   .str 
    loadimm  i64   1 
    istorex  u8    1 -1
    loadimm  u64   0 
    loadref  u64   .str 
    loadimm  i64   2 
    istorex  u8    1 -1
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    loadimm  u64   "Unknown string escape: \\%s"
    setarg   u64   1
    callp          mm_lex.lxerror_s 2 0
#3533:
    jump           #3527 
#3562:
    load     i64   .c 
    load     i64   .termchar 
    jumpne   i64   #3564 
    load     u64   .s 
    iload    u8    
    load     i64   .c 
    jumpne   i64   #3566 
    loadref  u64   .s 
    incrto   u64   1
    jump           #3565 
#3566:
    jump           #3526 
#3565:
#3564:
#3563:
    jump           #3527 
#3567:
    setcall        1
    loadimm  u64   "String not terminated"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3527 
#3529:
#3527:
    load     i64   .c 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #3525 
#3526:
    loadimm  u64   0 
    load     u64   .t 
    istore   u8    
;------------------------
#3497:
    return         
end

proc mm_lex.readdec
    local    i64   .c 
    local    u64   .dest 
    local    u64   .destend 
    local    u64   .pstart 
    local    i64   .islong 
    local    i64   .length 
    local    u8:1024 .str 
    local    u64   .a 
    local    i64   .$av_1 
;------------------------
    loadimm  i64   0 
    store    i64   .islong 
    load     u64   mm_lex.lxsptr 
    store    u64   .pstart 
    loadref  u64   .str 
    store    u64   .dest 
    load     u64   .dest 
    loadimm  i64   1024 
    addptrx  u64   1 0
    loadimm  i64   10 
    subptrx  u64   1 0
    store    u64   .destend 
    loadimm  u64   0 
    store    u64   .a 
#3570:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3573 39 108
    opnd           #3574 
#3573:
    swlabel        #3580 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3577 
    swlabel        #3574 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3575 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3583 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3576 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3581 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3580 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3583 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3576 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3574 
    swlabel        #3581 
    endsw          
#3575:
    load     u64   .a 
    loadimm  i64   10 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    u64   .a 
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    jump           #3572 
#3576:
    load     u64   .pstart 
    store    u64   mm_lex.lxsptr 
    setcall        0
    callp          mm_lex.readreal 0 0
    jump           #3569 
    jump           #3572 
#3577:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   46 
    jumpeq   u64   #3579 
    load     u64   .pstart 
    store    u64   mm_lex.lxsptr 
    setcall        0
    callp          mm_lex.readreal 0 0
    jump           #3569 
#3579:
#3578:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3571 
    jump           #3572 
#3580:
    jump           #3572 
#3581:
    loadimm  u64   0 
    load     u64   .dest 
    istore   u8    
    setcall        1
    loadimm  u64   "MAKEDECIMAL NOT READY"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3569 
    jump           #3572 
#3583:
    load     u64   .dest 
    loadref  u64   .str 
    subptr   u64   1
    store    i64   .length 
    load     i64   .length 
    loadimm  i64   64 
    jumple   i64   #3585 
    setcall        1
    loadimm  u64   "bin overflow"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3585:
#3584:
    loadref  u64   .str 
    store    u64   .dest 
    loadimm  u64   0 
    store    u64   .a 
    load     i64   .length 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #3589 
#3587:
    load     u64   .dest 
    iload    u8    
    loadimm  u64   50 
    jumplt   u64   #3591 
    setcall        1
    loadimm  u64   "bad bin digit"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3591:
#3590:
    load     u64   .a 
    loadimm  i64   2 
    mul      i64   
    loadref  u64   .dest 
    loadincr u64   1
    iload    u8    
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    u64   .a 
#3588:
    to             #3587 
    opnd           .$av_1 
#3589:
    jump           #3593 
    unload   u64   
    jump           #3572 
#3574:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3571 
#3572:
    load     u64   .dest 
    load     u64   .destend 
    jumplt   u64   #3595 
    setcall        1
    loadimm  u64   "Numlit too long"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3595:
#3594:
    jump           #3570 
#3571:
    load     u64   .dest 
    loadref  u64   .str 
    subptr   u64   1
    store    i64   .length 
    load     i64   .length 
    loadimm  i64   20 
    jumpgt   i64   #3599 
    load     i64   .length 
    loadimm  i64   20 
    jumpne   i64   #3598 
    setcall        3
    loadimm  u64   20 
    setarg   u64   3
    load     u64   mm_lex.u64maxstr 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    i32   strncmp 3 0
    widen    i32   
    jumpf    i64   #3598 
#3599:
    setcall        1
    loadimm  u64   "2:MAKEDECIMAL NOT READY"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3569 
#3598:
#3597:
;finish::
#3593:
    loadimm  i64   71 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_lex.setinttype 1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    load     u64   .a 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  i64   1 0
;------------------------
#3569:
    return         
end

proc mm_lex.readhex
    local    i64   .c 
    local    u64   .dest 
    local    u64   .destend 
    local    u64   .pstart 
    local    i64   .length 
    local    u8:1024 .str 
    local    u64   .a 
;------------------------
    load     u64   mm_lex.lxsptr 
    store    u64   .pstart 
    loadref  u64   .str 
    store    u64   .dest 
    load     u64   .dest 
    loadimm  i64   1024 
    addptrx  u64   1 0
    loadimm  i64   10 
    subptrx  u64   1 0
    store    u64   .destend 
    loadimm  u64   0 
    store    u64   .a 
#3602:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3605 39 108
    opnd           #3606 
#3605:
    swlabel        #3610 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3613 
    swlabel        #3606 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3607 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3608 
    swlabel        #3608 
    swlabel        #3608 
    swlabel        #3608 
    swlabel        #3608 
    swlabel        #3608 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3611 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3610 
    swlabel        #3606 
    swlabel        #3609 
    swlabel        #3609 
    swlabel        #3609 
    swlabel        #3609 
    swlabel        #3609 
    swlabel        #3609 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3606 
    swlabel        #3611 
    endsw          
#3607:
    load     u64   .a 
    loadimm  i64   16 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    u64   .a 
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    jump           #3604 
#3608:
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    load     u64   .a 
    loadimm  i64   16 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   65 
    sub      i64   
    loadimm  i64   10 
    add      i64   
    store    u64   .a 
    jump           #3604 
#3609:
    load     i64   .c 
    loadimm  i64   32 
    sub      i64   
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    load     u64   .a 
    loadimm  i64   16 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   97 
    sub      i64   
    loadimm  i64   10 
    add      i64   
    store    u64   .a 
    jump           #3604 
#3610:
    jump           #3604 
#3611:
    loadimm  u64   0 
    load     u64   .dest 
    istore   u8    
    setcall        1
    loadimm  u64   "3:MAKEDECIMAL NOT READY"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3601 
    jump           #3604 
#3613:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3603 
    jump           #3604 
#3606:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3603 
#3604:
    load     u64   .dest 
    load     u64   .destend 
    jumplt   u64   #3615 
    setcall        1
    loadimm  u64   "Numlit too long"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3615:
#3614:
    jump           #3602 
#3603:
    load     u64   .dest 
    loadref  u64   .str 
    subptr   u64   1
    store    i64   .length 
    load     i64   .length 
    loadimm  i64   16 
    jumple   i64   #3618 
    setcall        1
    loadimm  u64   "4:MAKEDECIMAL NOT READY"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3601 
#3618:
#3617:
    loadimm  i64   71 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_lex.setinttype 1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    load     u64   .a 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  i64   1 0
;------------------------
#3601:
    return         
end

proc mm_lex.readoct
    local    i64   .c 
    local    u64   .dest 
    local    u64   .destend 
    local    u64   .pstart 
    local    i64   .length 
    local    u8:1024 .str 
    local    u64   .a 
;------------------------
    load     u64   mm_lex.lxsptr 
    store    u64   .pstart 
    loadref  u64   .str 
    store    u64   .dest 
    load     u64   .dest 
    loadimm  i64   1024 
    addptrx  u64   1 0
    loadimm  i64   10 
    subptrx  u64   1 0
    store    u64   .destend 
    loadimm  u64   0 
    store    u64   .a 
#3621:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3624 39 95
    opnd           #3625 
#3624:
    swlabel        #3627 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3628 
    swlabel        #3625 
    swlabel        #3626 
    swlabel        #3626 
    swlabel        #3626 
    swlabel        #3626 
    swlabel        #3626 
    swlabel        #3626 
    swlabel        #3626 
    swlabel        #3626 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3625 
    swlabel        #3627 
    endsw          
#3626:
    load     u64   .a 
    loadimm  i64   8 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    u64   .a 
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    jump           #3623 
#3627:
    jump           #3623 
#3628:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3622 
    jump           #3623 
#3625:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3622 
#3623:
    load     u64   .dest 
    load     u64   .destend 
    jumplt   u64   #3630 
    setcall        1
    loadimm  u64   "Numlit too long"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3630:
#3629:
    jump           #3621 
#3622:
    load     u64   .dest 
    loadref  u64   .str 
    subptr   u64   1
    store    i64   .length 
    load     i64   .length 
    loadimm  i64   22 
    jumple   i64   #3633 
    setcall        1
    loadimm  u64   "oct overflow"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3633:
#3632:
    loadimm  i64   71 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_lex.setinttype 1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    load     u64   .a 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  i64   1 0
;------------------------
#3620:
    return         
end

proc mm_lex.readbin
    local    i64   .c 
    local    u64   .dest 
    local    u64   .destend 
    local    u64   .pstart 
    local    i64   .length 
    local    u8:1024 .str 
    local    u64   .a 
;------------------------
    load     u64   mm_lex.lxsptr 
    store    u64   .pstart 
    loadref  u64   .str 
    store    u64   .dest 
    load     u64   .dest 
    loadimm  i64   1024 
    addptrx  u64   1 0
    loadimm  i64   10 
    subptrx  u64   1 0
    store    u64   .destend 
    loadimm  u64   0 
    store    u64   .a 
#3636:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3639 39 108
    opnd           #3640 
#3639:
    swlabel        #3642 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3647 
    swlabel        #3640 
    swlabel        #3641 
    swlabel        #3641 
    swlabel        #3645 
    swlabel        #3645 
    swlabel        #3645 
    swlabel        #3645 
    swlabel        #3645 
    swlabel        #3645 
    swlabel        #3645 
    swlabel        #3645 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3643 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3642 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3640 
    swlabel        #3643 
    endsw          
#3641:
    load     u64   .a 
    loadimm  i64   2 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    u64   .a 
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    jump           #3638 
#3642:
    jump           #3638 
#3643:
    loadimm  u64   0 
    load     u64   .dest 
    istore   u8    
    setcall        1
    loadimm  u64   "5:MAKEDECIMAL NOT READY"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3635 
    jump           #3638 
#3645:
    setcall        1
    loadimm  u64   "bin bad digit"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3638 
#3647:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3637 
    jump           #3638 
#3640:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3637 
#3638:
    load     u64   .dest 
    load     u64   .destend 
    jumplt   u64   #3649 
    setcall        1
    loadimm  u64   "bin overflow"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3649:
#3648:
    jump           #3636 
#3637:
    load     u64   .dest 
    loadref  u64   .str 
    subptr   u64   1
    store    i64   .length 
    load     i64   .length 
    loadimm  i64   64 
    jumple   i64   #3652 
    setcall        1
    loadimm  u64   "6:MAKEDECIMAL NOT READY"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3635 
#3652:
#3651:
    loadimm  i64   71 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_lex.setinttype 1 0
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
    load     u64   .a 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  i64   1 0
;------------------------
#3635:
    return         
end

proc mm_lex.readreal
    local    i64   .c 
    local    i64   .n 
    local    i64   .negexpon 
    local    i64   .dotseen 
    local    i64   .length 
    local    i64   .fractlen 
    local    i64   .expon 
    local    i64   .expseen 
    local    r64   .x 
    local    u8:1024 .str 
    local    u64   .dest 
    local    u64   .destend 
    local    u64   .pexpon 
    local    i64   .$av_1 
    local    i64   .$av_2 
    local    i64   .$av_3 
    local    i64   .i 
;------------------------
    loadref  u64   .str 
    store    u64   .dest 
    load     u64   .dest 
    loadimm  i64   1024 
    addptrx  u64   1 0
    loadimm  i64   100 
    subptrx  u64   1 0
    store    u64   .destend 
    loadimm  i64   0 
    double         
    store    i64   .fractlen 
    double         
    store    i64   .expon 
    double         
    store    i64   .expseen 
    double         
    store    i64   .dotseen 
    double         
    store    i64   .negexpon 
    store    i64   .length 
#3655:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3658 39 108
    opnd           #3659 
#3658:
    swlabel        #3689 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3663 
    swlabel        #3659 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3660 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3666 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3690 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3689 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3666 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3659 
    swlabel        #3690 
    endsw          
#3660:
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    loadref  u64   .length 
    incrto   i64   1
    load     i64   .dotseen 
    jumpf    i64   #3662 
    loadref  u64   .fractlen 
    incrto   i64   1
#3662:
#3661:
    jump           #3657 
#3663:
    load     i64   .dotseen 
    jumpf    i64   #3665 
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3656 
#3665:
#3664:
    loadimm  i64   1 
    store    i64   .dotseen 
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    jump           #3657 
#3666:
    load     i64   .expseen 
    jumpf    i64   #3668 
    setcall        1
    loadimm  u64   "double expon"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3668:
#3667:
    loadimm  i64   1 
    store    i64   .expseen 
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    jump           #3671 
#3670:
    loadref  u64   mm_lex.lxsptr 
    incrto   u64   1
#3671:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   32 
    jumpeq   u64   #3670 
#3672:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   43 
    jumpeq   u64   #3675 1
    loadimm  u64   45 
    jumpne   u64   #3674 
#3675:
    load     u64   mm_lex.lxsptr 
    iload    u8    
    loadimm  u64   45 
    jumpne   u64   #3677 
    loadimm  i64   1 
    store    i64   .negexpon 
#3677:
#3676:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
#3674:
#3673:
    loadimm  i64   0 
    store    i64   .expon 
#3678:
    loadref  u64   mm_lex.lxsptr 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    switch         #3680 39 108
    opnd           #3681 
#3680:
    swlabel        #3686 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3682 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3687 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3686 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3681 
    swlabel        #3687 
    endsw          
#3682:
    load     i64   .expon 
    loadimm  i64   10 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    i64   .expon 
    load     i64   .c 
    loadref  u64   .dest 
    loadincr u64   1
    istore   u8    
    load     u64   .dest 
    load     u64   .destend 
    jumplt   u64   #3684 
    setcall        1
    loadimm  u64   "expon?"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3684:
#3683:
    jump           #3678 
#3686:
    jump           #3678 
#3687:
    loadimm  u64   0 
    load     u64   .dest 
    istore   u8    
    setcall        1
    loadimm  u64   "7:MAKEDECIMAL NOT READY"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3654 
    jump           #3678 
#3681:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3656 
    jump           #3678 
#3679:
    jump           #3657 
#3689:
    jump           #3657 
#3690:
    setcall        1
    loadimm  u64   "8:MAKEDECIMAL NOT READY"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
    jump           #3654 
    jump           #3657 
#3659:
    loadref  u64   mm_lex.lxsptr 
    decrto   u64   1
    jump           #3656 
#3657:
    load     u64   .dest 
    load     u64   .destend 
    jumplt   u64   #3693 
    setcall        1
    loadimm  u64   "r64lit too long"
    setarg   u64   1
    callp          mm_support.lxerror 1 0
#3693:
#3692:
    jump           #3655 
#3656:
    loadimm  u64   0 
    load     u64   .dest 
    istore   u8    
    load     i64   .negexpon 
    jumpf    i64   #3696 
    load     i64   .expon 
    neg      i64   
    store    i64   .expon 
#3696:
#3695:
    loadref  u64   .expon 
    load     i64   .fractlen 
    subto    i64   
    loadimm  r64   0.00000000000000000000 
    store    r64   .x 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .length 
    load     i64   .dotseen 
    add      i64   
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #3699 
#3697:
    loadref  u64   .str 
    load     i64   .i 
    iloadx   u8    1 -1
    store    i64   .c 
    load     i64   .c 
    loadimm  i64   46 
    jumpeq   i64   #3701 
    load     r64   .x 
    loadimm  r64   10.00000000000000000000 
    mul      r64   
    load     i64   .c 
    float    r64 i64 
    add      r64   
    loadimm  u64   48 
    float    r64 u64 
    sub      r64   
    store    r64   .x 
#3701:
#3700:
#3698:
    forup          #3697 1
    opnd           .i 
    opnd           .$av_1 
#3699:
    load     i64   .expon 
    loadimm  i64   0 
    jumplt   i64   #3703 
    load     i64   .expon 
    store    i64   .$av_2 
    load     i64   .$av_2 
    loadimm  i64   0 
    jumple   i64   #3706 
#3704:
    loadref  u64   .x 
    loadimm  r64   10.00000000000000000000 
    multo    r64   
#3705:
    to             #3704 
    opnd           .$av_2 
#3706:
    jump           #3702 
#3703:
    load     i64   .expon 
    neg      i64   
    store    i64   .$av_3 
    load     i64   .$av_3 
    loadimm  i64   0 
    jumple   i64   #3709 
#3707:
    loadref  u64   .x 
    loadimm  r64   10.00000000000000000000 
    divto    r64   
#3708:
    to             #3707 
    opnd           .$av_3 
#3709:
#3702:
    load     r64   .x 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   8 
    istorex  r64   1 0
    loadimm  i64   73 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   5 
    loadref  u64   mm_decls.nextlx 
    loadimm  i64   1 
    istorex  u8    1 0
;------------------------
#3654:
    return         
end

proc mm_lib.newstrec
    rettype  u64   
    local    u64   .p 
;------------------------
    setcall        1
    loadimm  i64   193 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .p 
    load     u64   .p 
    clear    u8:193 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    load     u64   .p 
    loadimm  i64   80 
    istorex  u32   1 0
    load     i64   mm_decls.currmoduleno 
    load     u64   .p 
    loadimm  i64   86 
    istorex  u8    1 0
    loadref  u64   mm_decls.moduletosub 
    load     i64   mm_decls.currmoduleno 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   87 
    istorex  u8    1 0
    load     u64   .p 
    setret   u64   
    jump           #3710 
;------------------------
#3710:
    return         
end

proc mm_lib.getduplnameptr
    rettype  u64   
    param    u64   .owner 
    param    u64   .symptr 
    param    i64   .id 
    local    u64   .p 
    local    u64   .q 
;------------------------
    setcall        0
    callf    u64   mm_lib.newstrec 0 0
    store    u64   .p 
    load     u64   .symptr 
    iload    u64   
    load     u64   .p 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u64   .symptr 
    loadimm  i64   68 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   68 
    istorex  u8    1 0
    loadimm  i64   80 
    load     u64   .p 
    loadimm  i64   69 
    istorex  u8    1 0
    load     u64   .owner 
    load     u64   .p 
    loadimm  i64   8 
    istorex  u64   1 0
    load     i64   .id 
    load     u64   .p 
    loadimm  i64   70 
    istorex  u8    1 0
    load     u64   .symptr 
    loadimm  i64   40 
    iloadx   u64   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  u64   1 0
    load     u64   .symptr 
    load     u64   .p 
    loadimm  i64   48 
    istorex  u64   1 0
    load     u64   .p 
    load     u64   .symptr 
    loadimm  i64   40 
    istorex  u64   1 0
    load     u64   .p 
    setret   u64   
    jump           #3711 
;------------------------
#3711:
    return         
end

proc mm_lib.adddef
    param    u64   .owner 
    param    u64   .p 
    local    u64   .q 
;------------------------
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u64   1 0
    double         
    store    u64   .q 
    jumpf    u64   #3714 
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    load     u64   .owner 
    jumpne   u64   #3716 
    callp          msys.m$print_startcon 0 0
    load     u64   .q 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "in"
    callp          msys.m$print_str_nf 1 0
    load     u64   .owner 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "Duplicate name"
    setarg   u64   1
    callp          mm_support.serror 1 0
#3716:
#3715:
#3714:
#3713:
    load     u64   .owner 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #3720 
    load     u64   .p 
    load     u64   .owner 
    loadimm  i64   16 
    istorex  u64   1 0
    jump           #3719 
#3720:
    load     u64   .p 
    load     u64   .owner 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   32 
    istorex  u64   1 0
#3719:
    load     u64   .p 
    load     u64   .owner 
    loadimm  i64   24 
    istorex  u64   1 0
;------------------------
#3712:
    return         
end

proc mm_lib.createname
    rettype  u64   
    param    u64   .p 
    local    u64   .u 
;------------------------
    setcall        0
    callf    u64   mm_lib.allocunitrec 0 0
    store    u64   .u 
    loadimm  i64   3 
    load     u64   .u 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .p 
    load     u64   .u 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .u 
    setret   u64   
    jump           #3721 
;------------------------
#3721:
    return         
end

proc mm_lib.createunit0
    rettype  u64   
    param    i64   .tag 
    local    u64   .u 
;------------------------
    setcall        0
    callf    u64   mm_lib.allocunitrec 0 0
    store    u64   .u 
    load     i64   .tag 
    load     u64   .u 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .u 
    setret   u64   
    jump           #3722 
;------------------------
#3722:
    return         
end

proc mm_lib.createunit1
    rettype  u64   
    param    i64   .tag 
    param    u64   .p 
    local    u64   .u 
;------------------------
    setcall        0
    callf    u64   mm_lib.allocunitrec 0 0
    store    u64   .u 
    load     i64   .tag 
    load     u64   .u 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .p 
    load     u64   .u 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .u 
    setret   u64   
    jump           #3723 
;------------------------
#3723:
    return         
end

proc mm_lib.createunit2
    rettype  u64   
    param    i64   .tag 
    param    u64   .p 
    param    u64   .q 
    local    u64   .u 
;------------------------
    setcall        0
    callf    u64   mm_lib.allocunitrec 0 0
    store    u64   .u 
    load     i64   .tag 
    load     u64   .u 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .p 
    load     u64   .u 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .q 
    load     u64   .u 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .u 
    setret   u64   
    jump           #3724 
;------------------------
#3724:
    return         
end

proc mm_lib.createunit3
    rettype  u64   
    param    i64   .tag 
    param    u64   .p 
    param    u64   .q 
    param    u64   .r 
    local    u64   .u 
;------------------------
    setcall        0
    callf    u64   mm_lib.allocunitrec 0 0
    store    u64   .u 
    load     i64   .tag 
    load     u64   .u 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .p 
    load     u64   .u 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .q 
    load     u64   .u 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .r 
    load     u64   .u 
    loadimm  i64   32 
    istorex  u64   1 0
    load     u64   .u 
    setret   u64   
    jump           #3725 
;------------------------
#3725:
    return         
end

proc mm_lib.insertunit
    param    u64   .p 
    param    i64   .tag 
    local    u64   .q 
    local    u64   .nextunit 
    local    i64   .mode 
;------------------------
    setcall        0
    callf    u64   mm_lib.allocunitrec 0 0
    store    u64   .q 
    load     u64   .p 
    iload    u8:64 
    load     u64   .q 
    istore   u8:64 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .mode 
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .nextunit 
    loadimm  u64   0 
    load     u64   .q 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .p 
    clear    u8:64 
    load     i64   .tag 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .q 
    loadimm  i64   4 
    iloadx   u32   1 0
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .q 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    load     i64   .mode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .nextunit 
    load     u64   .p 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .q 
    loadimm  i64   60 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   60 
    istorex  u8    1 0
;------------------------
#3726:
    return         
end

proc mm_lib.deleteunit
    param    u64   .p 
    param    u64   .q 
    local    u64   .r 
;------------------------
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
    load     u64   .q 
    iload    u8:64 
    load     u64   .p 
    istore   u8:64 
    load     u64   .r 
    load     u64   .p 
    loadimm  i64   8 
    istorex  u64   1 0
;------------------------
#3727:
    return         
end

proc mm_lib.createconstunit
    rettype  u64   
    param    u64   .a 
    param    i64   .t 
    local    u64   .u 
;------------------------
    setcall        0
    callf    u64   mm_lib.allocunitrec 0 0
    store    u64   .u 
    loadimm  i64   1 
    load     u64   .u 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .a 
    load     u64   .u 
    loadimm  i64   16 
    istorex  i64   1 0
    load     i64   .t 
    load     u64   .u 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   1 
    load     u64   .u 
    loadimm  i64   59 
    istorex  u8    1 0
    load     u64   .u 
    setret   u64   
    jump           #3728 
;------------------------
#3728:
    return         
end

proc mm_lib.createstringconstunit
    rettype  u64   
    param    u64   .s 
    param    i64   .length 
    local    u64   .u 
;------------------------
    setcall        0
    callf    u64   mm_lib.allocunitrec 0 0
    store    u64   .u 
    loadimm  i64   1 
    load     u64   .u 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .s 
    load     u64   .u 
    loadimm  i64   16 
    istorex  u64   1 0
    loadimm  i64   21 
    load     u64   .u 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   1 
    load     u64   .u 
    loadimm  i64   44 
    istorex  u8    1 0
    load     i64   .length 
    loadimm  i64   -1 
    jumpne   i64   #3731 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    load     u64   .u 
    loadimm  i64   40 
    istorex  u32   1 0
    jump           #3730 
#3731:
    load     i64   .length 
    load     u64   .u 
    loadimm  i64   40 
    istorex  u32   1 0
#3730:
    load     u64   .u 
    setret   u64   
    jump           #3729 
;------------------------
#3729:
    return         
end

proc mm_lib.newtypename
    rettype  i64   
    param    u64   .a 
    param    u64   .b 
;------------------------
    load     i64   mm_decls.ntypenames 
    loadimm  i64   8000 
    jumplt   i64   #3734 
    setcall        1
    loadimm  u64   "Too many type names"
    setarg   u64   1
    callp          mm_support.serror 1 0
#3734:
#3733:
    loadref  u64   mm_decls.ntypenames 
    incrto   i64   1
    load     u64   .a 
    loadref  u64   mm_decls.typenames 
    load     i64   mm_decls.ntypenames 
    addptrx  u8:32 32 0
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .b 
    loadref  u64   mm_decls.typenames 
    load     i64   mm_decls.ntypenames 
    addptrx  u8:32 32 0
    loadimm  i64   16 
    istorex  u64   1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    loadref  u64   mm_decls.typenamepos 
    load     i64   mm_decls.ntypenames 
    addptrx  u32   4 0
    loadimm  i64   0 
    istorex  u32   1 0
    load     i64   mm_decls.ntypenames 
    neg      i64   
    setret   i64   
    jump           #3732 
;------------------------
#3732:
    return         
end

proc mm_lib.createusertype
    rettype  i64   
    param    u64   .stname 
;------------------------
    load     i64   mm_decls.ntypes 
    loadimm  i64   6000 
    jumplt   i64   #3738 
    callp          msys.m$print_startcon 0 0
    load     i64   mm_decls.ntypes 
    callp          msys.m$print_i64_nf 1 0
    load     u64   .stname 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "Too many types"
    setarg   u64   1
    callp          mm_support.serror 1 0
#3738:
#3737:
    loadref  u64   mm_decls.ntypes 
    incrto   i64   1
    load     u64   .stname 
    iload    u64   
    loadref  u64   ttname 
    load     i64   mm_decls.ntypes 
    istorex  u64   8 0
    load     u64   .stname 
    loadref  u64   mm_decls.ttnamedef 
    load     i64   mm_decls.ntypes 
    istorex  u64   8 0
    loadimm  i64   0 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   mm_decls.ntypes 
    istorex  i32   4 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    loadref  u64   mm_decls.ttlineno 
    load     i64   mm_decls.ntypes 
    istorex  i32   4 0
    load     i64   mm_decls.ntypes 
    load     u64   .stname 
    loadimm  i64   64 
    istorex  i32   1 0
    load     i64   mm_decls.ntypes 
    setret   i64   
    jump           #3736 
;------------------------
#3736:
    return         
end

proc mm_lib.createusertypefromstr
    rettype  i64   
    param    u64   .name 
    local    u64   .stname 
;------------------------
    setcall        3
    loadimm  i64   5 
    setarg   i64   3
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   mm_decls.stmodule 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        1
    load     u64   .stname 
    setarg   u64   1
    callf    i64   mm_lib.createusertype 1 0
    setret   i64   
    jump           #3740 
;------------------------
#3740:
    return         
end

proc mm_lib.getrangelwbunit
    rettype  u64   
    param    u64   .p 
;------------------------
    startmx        
    load     u64   .p 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #3743 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    resetmx        
    jump           #3742 
#3743:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   33 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadimm  i64   153 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     u64   .p 
    endmx          
#3742:
    setret   u64   
    jump           #3741 
;------------------------
#3741:
    return         
end

proc mm_lib.getrangeupbunit
    rettype  u64   
    param    u64   .p 
;------------------------
    startmx        
    load     u64   .p 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #3746 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    resetmx        
    jump           #3745 
#3746:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   33 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadimm  i64   154 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     u64   .p 
    endmx          
#3745:
    setret   u64   
    jump           #3744 
;------------------------
#3744:
    return         
end

proc mm_lib.createarraymode
    rettype  i64   
    param    u64   .owner 
    param    i64   .target 
    param    u64   .dimexpr 
    param    i64   .typedefx 
    local    i64   .k 
    local    i64   .m 
;------------------------
    load     i64   .typedefx 
    loadimm  i64   0 
    jumpne   i64   #3749 
    loadimm  i64   30 
    store    i64   .k 
    load     i64   mm_decls.ntypes 
    loadimm  i64   30 
    jumplt   i64   #3752 
#3750:
    loadref  u64   mm_decls.ttusercat 
    load     i64   .k 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpne   i64   #3754 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .k 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpne   i64   #3754 
    loadref  u64   mm_decls.tttarget 
    load     i64   .k 
    iloadx   i32   4 0
    load     i64   .target 
    jumpne   i64   #3754 
    setcall        4
    loadref  u64   mm_decls.ttowner 
    load     i64   .k 
    iloadx   u64   8 0
    setarg   u64   4
    load     u64   .owner 
    setarg   u64   3
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .k 
    iloadx   u64   8 0
    setarg   u64   2
    load     u64   .dimexpr 
    setarg   u64   1
    callf    i64   mm_lib.sameunit 4 0
    jumpf    i64   #3754 
    load     i64   .k 
    setret   i64   
    jump           #3747 
#3754:
#3753:
#3751:
    forup          #3750 1
    opnd           .k 
    opnd           mm_decls.ntypes 
#3752:
    setcall        1
    setcall        0
    callf    u64   mm_lib.nextautotype 0 0
    setarg   u64   1
    callf    i64   mm_lib.createusertypefromstr 1 0
    store    i64   .m 
    jump           #3748 
#3749:
    load     i64   .typedefx 
    store    i64   .m 
#3748:
    loadimm  i64   10 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
    load     u64   .dimexpr 
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    istorex  u64   8 0
    setcall        3
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    addptrx  i32   4 0
    setarg   u64   3
    load     i64   .target 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     u64   .owner 
    loadref  u64   mm_decls.ttowner 
    load     i64   .m 
    istorex  u64   8 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    istorex  u8    1 0
    load     i64   .m 
    setret   i64   
    jump           #3747 
;------------------------
#3747:
    return         
end

proc mm_lib.sameunit
    rettype  i64   
    param    u64   .p 
    param    u64   .q 
    param    u64   .powner 
    param    u64   .qowner 
    local    u64   .d 
    local    u64   .e 
;------------------------
    load     u64   .p 
    load     u64   .q 
    jumpne   u64   #3757 
    loadimm  i64   1 
    setret   i64   
    jump           #3755 
#3757:
#3756:
    load     u64   .p 
    loadimm  u64   0 
    jumpeq   u64   #3760 
    load     u64   .q 
    loadimm  u64   0 
    jumpne   u64   #3759 
#3760:
    loadimm  i64   0 
    setret   i64   
    jump           #3755 
#3759:
#3758:
    load     u64   .p 
    iload    u8    
    load     u64   .q 
    iload    u8    
    jumpeq   i64   #3762 
    loadimm  i64   0 
    setret   i64   
    jump           #3755 
#3762:
#3761:
    load     u64   .p 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #3764 1
    loadimm  i64   17 
    jumpeq   i64   #3765 1
    loadimm  i64   23 
    jumpeq   i64   #3765 1
    loadimm  i64   3 
    jumpeq   i64   #3766 
    jump           #3767 
#3764:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    load     u64   .q 
    loadimm  i64   16 
    iloadx   i64   1 0
    eq       i64   
    setret   i64   
    jump           #3755 
    jump           #3763 
#3765:
    startmx        
    setcall        4
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .q 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.sameunit 4 0
    jumpf    i64   #3768 
    setcall        4
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .q 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.sameunit 4 0
    jumpf    i64   #3768 
    loadimm  i64   1 
    resetmx        
    jump           #3769 
#3768:
    loadimm  i64   0 
    endmx          
#3769:
    setret   i64   
    jump           #3755 
    jump           #3763 
#3766:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    load     u64   .q 
    loadimm  i64   16 
    iloadx   u64   1 0
    jumpne   u64   #3771 
    load     u64   .powner 
    load     u64   .qowner 
    jumpne   u64   #3771 
    loadimm  i64   1 
    setret   i64   
    jump           #3755 
#3771:
#3770:
    jump           #3763 
#3767:
#3763:
    loadimm  i64   0 
    setret   i64   
    jump           #3755 
;------------------------
#3755:
    return         
end

proc mm_lib.createarraymodek
    rettype  i64   
    param    u64   .owner 
    param    i64   .target 
    param    i64   .lower 
    param    i64   .length 
    param    i64   .typedefx 
    local    i64   .atype 
    local    i64   .k 
    local    i64   .m 
;------------------------
    loadimm  i64   10 
    store    i64   .atype 
    load     i64   .typedefx 
    loadimm  i64   0 
    jumpne   i64   #3774 
    setcall        1
    setcall        0
    callf    u64   mm_lib.nextautotype 0 0
    setarg   u64   1
    callf    i64   mm_lib.createusertypefromstr 1 0
    store    i64   .m 
    jump           #3773 
#3774:
    load     i64   .typedefx 
    store    i64   .m 
#3773:
    load     i64   .atype 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    load     i64   .lower 
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
    load     i64   .length 
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    istorex  i32   4 0
    load     i64   .target 
    loadimm  i64   0 
    jumpge   i64   #3776 
    setcall        1
    loadimm  u64   "CREATEARRAYMODEK/TARGET NOT RESOLVED"
    setarg   u64   1
    callp          mm_support.serror 1 0
#3776:
#3775:
    load     i64   .length 
    loadref  u64   mm_decls.ttsize 
    load     i64   .target 
    iloadx   u32   4 0
    mul      i64   
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    istorex  u32   4 0
    setcall        3
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    addptrx  i32   4 0
    setarg   u64   3
    load     i64   .target 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     u64   .owner 
    loadref  u64   mm_decls.ttowner 
    load     i64   .m 
    istorex  u64   8 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    istorex  u8    1 0
    load     i64   .m 
    setret   i64   
    jump           #3772 
;------------------------
#3772:
    return         
end

proc mm_lib.nextautotype
    rettype  u64   
;------------------------
    loadref  u64   mm_lib.nextautotype.str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "$T"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadref  u64   mm_lib.autotypeno 
    incrload i64   1
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    loadref  u64   mm_lib.nextautotype.str 
    setret   u64   
    jump           #3778 
;------------------------
#3778:
    return         
end

proc mm_lib.createslicemode
    rettype  i64   
    param    u64   .owner 
    param    i64   .slicetype 
    param    i64   .target 
    param    u64   .dimexpr 
    param    i64   .typedefx 
    local    i64   .k 
    local    i64   .m 
;------------------------
    load     i64   .typedefx 
    loadimm  i64   0 
    jumpne   i64   #3782 
    setcall        1
    setcall        0
    callf    u64   mm_lib.nextautotype 0 0
    setarg   u64   1
    callf    i64   mm_lib.createusertypefromstr 1 0
    store    i64   .m 
    jump           #3781 
#3782:
    load     i64   .typedefx 
    store    i64   .m 
#3781:
    load     i64   .slicetype 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    load     u64   .dimexpr 
    jumpf    u64   #3784 
    load     u64   .dimexpr 
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    istorex  u64   8 0
    jump           #3783 
#3784:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
#3783:
    setcall        3
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    addptrx  i32   4 0
    setarg   u64   3
    load     i64   .target 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     u64   .owner 
    loadref  u64   mm_decls.ttowner 
    load     i64   .m 
    istorex  u64   8 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    istorex  u8    1 0
    load     i64   .m 
    setret   i64   
    jump           #3780 
;------------------------
#3780:
    return         
end

proc mm_lib.createslicemodek
    rettype  i64   
    param    u64   .owner 
    param    i64   .target 
    param    i64   .lower 
    param    i64   .typedefx 
    local    i64   .k 
    local    i64   .m 
;------------------------
    load     i64   .typedefx 
    loadimm  i64   0 
    jumpne   i64   #3787 
    setcall        1
    setcall        0
    callf    u64   mm_lib.nextautotype 0 0
    setarg   u64   1
    callf    i64   mm_lib.createusertypefromstr 1 0
    store    i64   .m 
    jump           #3786 
#3787:
    load     i64   .typedefx 
    store    i64   .m 
#3786:
    loadimm  i64   11 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    load     i64   .lower 
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
    setcall        3
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    addptrx  i32   4 0
    setarg   u64   3
    load     i64   .target 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     u64   .owner 
    loadref  u64   mm_decls.ttowner 
    load     i64   .m 
    istorex  u64   8 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    istorex  u8    1 0
    load     i64   .m 
    setret   i64   
    jump           #3785 
;------------------------
#3785:
    return         
end

proc mm_lib.createrefmode
    rettype  i64   
    param    u64   .owner 
    param    i64   .target 
    param    i64   .typedefx 
    local    i64   .k 
    local    i64   .m 
;------------------------
    load     i64   .typedefx 
    loadimm  i64   0 
    jumpne   i64   #3790 
    loadimm  i64   30 
    store    i64   .k 
    load     i64   mm_decls.ntypes 
    loadimm  i64   30 
    jumplt   i64   #3793 
#3791:
    loadref  u64   mm_decls.ttisref 
    load     i64   .k 
    iloadx   u8    1 0
    jumpf    i64   #3795 
    loadref  u64   mm_decls.tttarget 
    load     i64   .k 
    iloadx   i32   4 0
    load     i64   .target 
    jumpne   i64   #3797 
    load     i64   .k 
    setret   i64   
    jump           #3788 
#3797:
#3796:
#3795:
#3794:
#3792:
    forup          #3791 1
    opnd           .k 
    opnd           mm_decls.ntypes 
#3793:
    setcall        1
    setcall        0
    callf    u64   mm_lib.nextautotype 0 0
    setarg   u64   1
    callf    i64   mm_lib.createusertypefromstr 1 0
    store    i64   .m 
    jump           #3789 
#3790:
    load     i64   .typedefx 
    store    i64   .m 
#3789:
    setcall        3
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    addptrx  i32   4 0
    setarg   u64   3
    load     i64   .target 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    loadimm  i64   7 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    loadref  u64   mm_decls.ttsize 
    loadimm  i64   7 
    iloadx   u32   4 0
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    istorex  u32   4 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisref 
    load     i64   .m 
    istorex  u8    1 0
    load     i64   .m 
    setret   i64   
    jump           #3788 
;------------------------
#3788:
    return         
end

proc mm_lib.createrefprocmode
    rettype  i64   
    param    u64   .owner 
    param    u64   .stproc 
    param    u64   .paramlist 
    param    i64   .kwd 
    param    i64   .prettype 
    param    i64   .typedefx 
    local    i64   .m 
    local    i64   .mproc 
;------------------------
    setcall        1
    load     u64   .stproc 
    setarg   u64   1
    callf    i64   mm_lib.createusertype 1 0
    store    i64   .mproc 
    load     u64   .paramlist 
    load     u64   .stproc 
    loadimm  i64   104 
    istorex  u64   1 0
    load     i64   .prettype 
    load     u64   .stproc 
    loadimm  i64   64 
    istorex  i32   1 0
    loadimm  i64   24 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .mproc 
    istorex  i32   4 0
    load     i64   .typedefx 
    loadimm  i64   0 
    jumpne   i64   #3800 
    setcall        1
    setcall        0
    callf    u64   mm_lib.nextautotype 0 0
    setarg   u64   1
    callf    i64   mm_lib.createusertypefromstr 1 0
    store    i64   .m 
    jump           #3799 
#3800:
    load     i64   .typedefx 
    store    i64   .m 
#3799:
    load     i64   .mproc 
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    istorex  i32   4 0
    loadimm  i64   7 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    loadref  u64   mm_decls.ttsize 
    loadimm  i64   7 
    iloadx   u32   4 0
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    istorex  u32   4 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisref 
    load     i64   .m 
    istorex  u8    1 0
    load     i64   .m 
    setret   i64   
    jump           #3798 
;------------------------
#3798:
    return         
end

proc mm_lib.copyttvalues
    param    i64   .dest 
    param    i64   .source 
;------------------------
    loadref  u64   mm_decls.ttsigned 
    load     i64   .source 
    iloadx   u8    1 0
    loadref  u64   mm_decls.ttsigned 
    load     i64   .dest 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttisreal 
    load     i64   .source 
    iloadx   u8    1 0
    loadref  u64   mm_decls.ttisreal 
    load     i64   .dest 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .source 
    iloadx   u8    1 0
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .dest 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttisshort 
    load     i64   .source 
    iloadx   u8    1 0
    loadref  u64   mm_decls.ttisshort 
    load     i64   .dest 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttisref 
    load     i64   .source 
    iloadx   u8    1 0
    loadref  u64   mm_decls.ttisref 
    load     i64   .dest 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttisblock 
    load     i64   .source 
    iloadx   u8    1 0
    loadref  u64   mm_decls.ttisblock 
    load     i64   .dest 
    istorex  u8    1 0
;------------------------
#3801:
    return         
end

proc mm_lib.getdottedname
    rettype  u64   
    param    u64   .p 
    local    u8:256 .str2 
    local    u64   .owner 
;------------------------
    setcall        2
    load     u64   .p 
    iload    u64   
    setarg   u64   2
    loadref  u64   mm_lib.getdottedname.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .owner 
    jump           #3804 
#3803:
    setcall        2
    loadref  u64   mm_lib.getdottedname.str 
    setarg   u64   2
    loadref  u64   .str2 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    load     u64   .owner 
    iload    u64   
    setarg   u64   2
    loadref  u64   mm_lib.getdottedname.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "."
    setarg   u64   2
    loadref  u64   mm_lib.getdottedname.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadref  u64   .str2 
    setarg   u64   2
    loadref  u64   mm_lib.getdottedname.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    load     u64   .owner 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .owner 
#3804:
    load     u64   .owner 
    jumpf    u64   #3807 
    load     u64   .owner 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpne   i64   #3803 
#3807:
#3805:
    loadref  u64   mm_lib.getdottedname.str 
    setret   u64   
    jump           #3802 
;------------------------
#3802:
    return         
end

proc mm_lib.getavname
    rettype  u64   
    param    u64   .owner 
    param    i64   .id 
    local    u64   .p 
    local    u8:32 .str 
    local    u64   .name 
;------------------------
    load     i64   .id 
    loadimm  i64   12 
    jumpne   i64   #3810 
    load     u64   .owner 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpeq   i64   #3810 
    setcall        1
    loadimm  u64   "Auto frame not in proc"
    setarg   u64   1
    callp          mm_support.serror 1 0
#3810:
#3809:
    load     i64   .id 
    loadimm  i64   12 
    jumpne   i64   #3813 
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "$av_"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadref  u64   mm_lib.nextavindex 
    incrload i64   1
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #3812 
#3813:
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "$sv_"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadref  u64   mm_lib.nextsvindex 
    incrload i64   1
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#3812:
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   .name 
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    unload   u64   
    setcall        3
    load     i64   .id 
    setarg   i64   3
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .p 
    loadimm  u64   1 
    load     u64   .p 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   0 
    storebit       
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   64 
    istorex  i32   1 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    load     u64   .p 
    setret   u64   
    jump           #3808 
;------------------------
#3808:
    return         
end

proc mm_lib.unionstr_clear
    param    u64   .u 
;------------------------
    loadimm  u64   0 
    load     u64   .u 
    istore   u64   
;------------------------
#3816:
    return         
end

proc mm_lib.unionstr_append
    param    u64   .u 
    param    i64   .c 
;------------------------
    load     u64   .u 
    loadimm  i64   7 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpne   i64   #3819 
    setcall        1
    loadimm  u64   "Uflags overflow/a"
    setarg   u64   1
    callp          mm_support.serror 1 0
#3819:
#3818:
    load     u64   .u 
    loadimm  i64   7 
    addptrx  u64   1 0
    incrto   u8    1
    load     i64   .c 
    load     u64   .u 
    load     u64   .u 
    loadimm  i64   7 
    iloadx   u8    1 0
    istorex  u8    1 -1
;------------------------
#3817:
    return         
end

proc mm_lib.unionstr_concat
    param    u64   .u 
    param    u64   .v 
    local    i64   .ulen 
    local    i64   .vlen 
    local    i64   .i 
;------------------------
    load     u64   .u 
    loadimm  i64   7 
    iloadx   u8    1 0
    store    i64   .ulen 
    load     u64   .v 
    loadimm  i64   7 
    iloadx   u8    1 0
    store    i64   .vlen 
    load     i64   .ulen 
    load     i64   .vlen 
    add      i64   
    loadimm  i64   7 
    jumple   i64   #3823 
    setcall        1
    loadimm  u64   "Uflags overflow/c"
    setarg   u64   1
    callp          mm_support.serror 1 0
#3823:
#3822:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .vlen 
    loadimm  i64   1 
    jumplt   i64   #3827 
#3825:
    load     u64   .v 
    load     i64   .i 
    iloadx   u8    1 -1
    load     u64   .u 
    load     i64   .i 
    load     i64   .ulen 
    add      i64   
    istorex  u8    1 -1
#3826:
    forup          #3825 1
    opnd           .i 
    opnd           .vlen 
#3827:
    load     i64   .ulen 
    load     i64   .vlen 
    add      i64   
    load     u64   .u 
    loadimm  i64   7 
    istorex  u8    1 0
;------------------------
#3821:
    return         
end

proc mm_lib.unionstr_last
    rettype  i64   
    param    u64   .u 
;------------------------
    load     u64   .u 
    loadimm  i64   7 
    iloadx   u8    1 0
    jumpf    i64   #3830 
    load     u64   .u 
    load     u64   .u 
    loadimm  i64   7 
    iloadx   u8    1 0
    iloadx   u8    1 -1
    setret   i64   
    jump           #3828 
#3830:
#3829:
    loadimm  i64   0 
    setret   i64   
    jump           #3828 
;------------------------
#3828:
    return         
end

proc mm_lib.unionstr_copy
    param    u64   .u 
    param    u64   .v 
;------------------------
    setcall        3
    loadimm  u64   8 
    setarg   u64   3
    load     u64   .v 
    setarg   u64   2
    load     u64   .u 
    setarg   u64   1
    callp          memcpy 3 0
;------------------------
#3831:
    return         
end

proc mm_lib.createrecordmode
    rettype  i64   
    param    u64   .owner 
    param    i64   .typedefx 
    local    i64   .m 
;------------------------
    load     i64   .typedefx 
    loadimm  i64   0 
    jumpne   i64   #3834 
    setcall        1
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.createusertype 1 0
    store    i64   .m 
    jump           #3833 
#3834:
    load     i64   .typedefx 
    store    i64   .m 
#3833:
    loadimm  i64   8 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttusercat 
    load     i64   .m 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    istorex  u8    1 0
    load     i64   .m 
    setret   i64   
    jump           #3832 
;------------------------
#3832:
    return         
end

proc mm_lib.createtuplemode
    rettype  i64   
    param    u64   .owner 
    param    u64   .elements 
    param    i64   .elementslen 
    param    i64   .typedefx 
    local    i64   .m 
    local    i64   .i 
;------------------------
    load     i64   .typedefx 
    loadimm  i64   0 
    jumpne   i64   #3837 
    setcall        1
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.createusertype 1 0
    store    i64   .m 
    jump           #3836 
#3837:
    load     i64   .typedefx 
    store    i64   .m 
#3836:
    loadimm  i64   28 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttusercat 
    load     i64   .m 
    istorex  u8    1 0
    load     i64   .elementslen 
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    istorex  i32   4 0
    setcall        1
    load     i64   .elementslen 
    loadimm  i64   4 
    mul      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    loadref  u64   mm_decls.ttmult 
    load     i64   .m 
    istorex  u64   8 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .elementslen 
    loadimm  i64   1 
    jumplt   i64   #3840 
#3838:
    setcall        3
    loadref  u64   mm_decls.ttmult 
    load     i64   .m 
    iloadx   u64   8 0
    load     i64   .i 
    addptrx  i32   4 -4
    setarg   u64   3
    load     u64   .elements 
    load     i64   .i 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
#3839:
    forup          #3838 1
    opnd           .i 
    opnd           .elementslen 
#3840:
    load     i64   .m 
    setret   i64   
    jump           #3835 
;------------------------
#3835:
    return         
end

proc mm_lib.getintintmode
    rettype  i64   
    local    i64   .m 
;------------------------
    load     i64   mm_tables.tintint 
    jumpf    i64   #3843 
    load     i64   mm_tables.tintint 
    setret   i64   
    jump           #3841 
#3843:
#3842:
    setcall        1
    loadimm  u64   "$intint"
    setarg   u64   1
    callf    i64   mm_lib.createusertypefromstr 1 0
    store    i64   .m 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   2 
    setarg   i64   3
    loadref  u64   mm_lib.getintintmode.elems 
    setarg   u64   2
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    setarg   u64   1
    callf    i64   mm_lib.createtuplemode 4 0
    setret   i64   
    jump           #3841 
;------------------------
#3841:
    return         
end

proc mm_lib.convertstring
    rettype  i64   
    param    u64   .s 
    param    u64   .t 
    local    i64   .c 
    local    u64   .t0 
;------------------------
    load     u64   .t 
    store    u64   .t0 
    jump           #3847 
#3846:
    load     i64   .c 
    switch         #3850 7 92
    opnd           #3851 
#3850:
    swlabel        #3857 
    swlabel        #3857 
    swlabel        #3855 
    swlabel        #3853 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3854 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3857 
    swlabel        #3857 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3852 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3851 
    swlabel        #3856 
    endsw          
#3852:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   34 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #3849 
#3853:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   110 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #3849 
#3854:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   99 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #3849 
#3855:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   116 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #3849 
#3856:
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   92 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #3849 
#3857:
    loadimm  u64   60 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    load     i64   .c 
    loadimm  i64   10 
    div      i64   
    loadimm  i64   48 
    add      i64   
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    load     i64   .c 
    loadimm  i64   10 
    rem      i64   
    loadimm  i64   48 
    add      i64   
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    loadimm  u64   62 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
    jump           #3849 
#3851:
    load     i64   .c 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
#3849:
#3847:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    jumpt    i64   #3846 
#3848:
    loadimm  u64   0 
    load     u64   .t 
    istore   u8    
    load     u64   .t 
    load     u64   .t0 
    subptr   u64   1
    setret   i64   
    jump           #3845 
;------------------------
#3845:
    return         
end

proc mm_lib.strexpr
    rettype  u64   
    param    u64   .p 
;------------------------
    setcall        1
    load     u64   mm_lib.exprstr 
    setarg   u64   1
    callp          mlib.gs_init 1 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   mm_lib.exprstr 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    load     u64   mm_lib.exprstr 
    setret   u64   
    jump           #3858 
;------------------------
#3858:
    return         
end

proc mm_lib.jevalx
    param    u64   .dest 
    param    u64   .p 
    local    u64   .q 
    local    u64   .a 
    local    u64   .b 
    local    u8:500 .str 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #3861 
    jump           #3859 
#3861:
#3860:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .b 
    load     u64   .p 
    iload    u8    
    switch         #3863 1 92
    opnd           #3864 
#3863:
    swlabel        #3865 
    swlabel        #3952 
    swlabel        #3880 
    swlabel        #3950 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3980 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3884 
    swlabel        #3884 
    swlabel        #3907 
    swlabel        #3916 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3939 
    swlabel        #3920 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3889 
    swlabel        #3881 
    swlabel        #3864 
    swlabel        #3881 
    swlabel        #3884 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3978 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3946 
    swlabel        #3898 
    swlabel        #3898 
    swlabel        #3905 
    swlabel        #3898 
    swlabel        #3898 
    swlabel        #3944 
    swlabel        #3954 
    swlabel        #3959 
    swlabel        #3927 
    swlabel        #3933 
    swlabel        #3936 
    swlabel        #3927 
    swlabel        #3926 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3970 
    swlabel        #3961 
    swlabel        #3966 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3964 
    swlabel        #3864 
    swlabel        #3964 
    swlabel        #3964 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3968 
    swlabel        #3864 
    swlabel        #3864 
    swlabel        #3889 
    swlabel        #3864 
    swlabel        #3973 
    swlabel        #3864 
    swlabel        #3922 
    endsw          
#3865:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   17 
    jumpeq   i64   #3867 1
    loadimm  i64   3 
    jumpeq   i64   #3867 1
    loadimm  i64   15 
    jumpeq   i64   #3867 1
    loadimm  i64   16 
    jumpeq   i64   #3867 1
    loadimm  i64   20 
    jumpeq   i64   #3868 1
    loadimm  i64   2 
    jumpeq   i64   #3868 1
    loadimm  i64   18 
    jumpeq   i64   #3868 1
    loadimm  i64   19 
    jumpeq   i64   #3868 1
    loadimm  i64   13 
    jumpeq   i64   #3869 1
    loadimm  i64   1 
    jumpeq   i64   #3869 1
    loadimm  i64   5 
    jumpeq   i64   #3870 1
    loadimm  i64   4 
    jumpeq   i64   #3870 1
    loadimm  i64   7 
    jumpeq   i64   #3871 
    jump           #3872 
#3867:
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callp          msys.getstrint 2 0
    jump           #3866 
#3868:
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   msys.strword 2 0
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #3866 
#3869:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadref  u64   .str 
    loadimm  i64   1 
    istorex  u8    1 -1
    loadimm  u64   0 
    loadref  u64   .str 
    loadimm  i64   0 
    istorex  u8    1 -1
    jump           #3866 
#3870:
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   r64   1 0
    callp          msys.m$print_r64 2 0
    callp          msys.m$print_end 0 0
    jump           #3866 
#3871:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   21 
    jumpne   i64   #3874 
    load     u64   .p 
    loadimm  i64   44 
    iloadx   u8    1 0
    jumpf    i64   #3874 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    loadimm  i64   250 
    jumple   i64   #3876 
    setcall        2
    loadimm  u64   "LS2:LONGSTR)"
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #3875 
#3876:
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.convertstring 2 0
    unload   i64   
#3875:
    setcall        2
    loadimm  u64   "\""
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    loadimm  u64   "\""
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3859 
    jump           #3873 
#3874:
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    callp          msys.m$print_ptr_nf 1 0
    callp          msys.m$print_end 0 0
#3873:
    jump           #3866 
#3872:
    setcall        2
    loadimm  u64   "<EVAL/CONST PROBABLY VOID>"
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
#3866:
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3880:
    setcall        2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3881:
    setcall        2
    loadref  u64   mm_pcl.pclnames 
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3884:
    setcall        2
    loadref  u64   mm_pcl.pclnames 
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #3887 
    setcall        2
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3886 
#3887:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
#3886:
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3889:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    load     u64   .b 
    store    u64   .q 
    jump           #3892 
#3891:
    setcall        2
    load     u64   .q 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
    load     u64   .q 
    jumpf    u64   #3895 
    setcall        2
    loadimm  u64   ","
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
#3895:
#3894:
#3892:
    load     u64   .q 
    jumpt    u64   #3891 
#3893:
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3898:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    load     u64   .p 
    iload    u8    
    loadimm  i64   46 
    jumpeq   i64   #3901 
    load     u64   .p 
    iload    u8    
    loadimm  i64   47 
    jumpne   i64   #3900 
#3901:
    setcall        2
    loadimm  u64   "."
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
#3900:
#3899:
    setcall        2
    loadimm  u64   "["
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   "]"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3905:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   "."
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    jump           #3862 
#3907:
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    load     u64   .a 
    store    u64   .q 
    jump           #3910 
#3909:
    setcall        2
    load     u64   .q 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
    load     u64   .q 
    jumpf    u64   #3913 
    setcall        2
    loadimm  u64   ","
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
#3913:
#3912:
#3910:
    load     u64   .q 
    jumpt    u64   #3909 
#3911:
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3916:
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ".."
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3920:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ":="
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    jump           #3862 
#3922:
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   "|"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   "|"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3926:
    setcall        2
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3927:
    setcall        2
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   52 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    load     u64   .p 
    iload    u8    
    loadimm  i64   54 
    jumpne   i64   #3929 
    setcall        2
    loadimm  u64   "@"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
#3929:
#3928:
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3933:
    setcall        2
    loadimm  u64   "shorten("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3936:
    setcall        2
    loadimm  u64   "cast("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3939:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ":"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    load     u64   .b 
    jumpf    u64   #3942 
    setcall        2
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    jump           #3941 
#3942:
    setcall        2
    loadimm  u64   "-"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
#3941:
    jump           #3862 
#3944:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   "^"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3946:
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ","
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ","
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3950:
    setcall        2
    loadimm  u64   "<JBLOCK>"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3952:
    setcall        2
    loadimm  u64   "<nullunit>"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    jump           #3862 
#3954:
    setcall        2
    loadimm  u64   "&"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    load     u64   .b 
    jumpf    u64   #3957 
    setcall        2
    loadimm  u64   "+"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .b 
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_strint 2 0
#3957:
#3956:
    jump           #3862 
#3959:
    setcall        2
    loadimm  u64   "&."
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    jump           #3862 
#3961:
    setcall        2
    loadimm  u64   "TYPESTR("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_support.gs_additem 2 0
    jump           #3862 
#3964:
    setcall        2
    loadimm  u64   "$"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadref  u64   mm_tables.jtagnames 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    loadimm  i64   2 
    addptrx  u64   1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    jump           #3862 
#3966:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   "."
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadref  u64   mm_tables.bitfieldnames 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    iloadx   u64   8 -8
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    jump           #3862 
#3968:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ":"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    jump           #3862 
#3970:
    setcall        2
    loadimm  u64   "typeof("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    jump           #3862 
#3973:
    setcall        2
    loadref  u64   mm_tables.sysfnnames 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    iloadx   u64   8 -8
    loadimm  i64   3 
    addptrx  u64   1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    load     u64   .a 
    jumpf    u64   #3976 
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
#3976:
#3975:
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    jump           #3862 
#3978:
    setcall        2
    loadimm  u64   "incrto "
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    jump           #3862 
#3980:
    setcall        2
    loadimm  u64   "newstrinclude "
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mm_lib.jevalx 2 0
    jump           #3862 
#3864:
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_tables.jtagnames 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  u64   "CAN'T DO JEVAL"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#3862:
;------------------------
#3859:
    return         
end

proc mm_lib.strmode
    rettype  u64   
    param    i64   .m 
    param    i64   .expand 
;------------------------
    setcall        3
    loadref  u64   mm_lib.strmode.str 
    setarg   u64   3
    load     i64   .expand 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
    loadref  u64   mm_lib.strmode.str 
    setret   u64   
    jump           #3983 
;------------------------
#3983:
    return         
end

proc mm_lib.strmode2
    rettype  u64   
    param    i64   .m 
    param    i64   .expand 
;------------------------
    setcall        3
    loadref  u64   mm_lib.strmode2.str 
    setarg   u64   3
    load     i64   .expand 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
    loadref  u64   mm_lib.strmode2.str 
    setret   u64   
    jump           #3984 
;------------------------
#3984:
    return         
end

proc mm_lib.istrmode
    param    i64   .m 
    param    i64   .expand 
    param    u64   .dest 
    local    u64   .d 
    local    u64   .q 
    local    u64   .e 
    local    i64   .value 
    local    i64   .needcomma 
    local    i64   .x 
    local    i64   .i 
    local    i64   .target 
    local    i64   .mbase 
    local    i64   .n 
    local    u8:16 .sxx 
    local    u64   .xx 
    local    u64   .sdim 
    local    u64   .slength 
    local    u8:100 .strdim 
    local    u64   .prefix 
    local    u8:32 .tn 
;------------------------
    loadref  u64   .sxx 
    store    u64   .xx 
    load     i64   .m 
    loadimm  i64   0 
    jumpge   i64   #3987 
    setcall        2
    loadimm  u64   "*"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadref  u64   mm_decls.typenames 
    load     i64   .m 
    neg      i64   
    addptrx  u8:32 32 0
    store    u8:32 .tn 
    loadref  u64   .tn 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #3990 
    setcall        2
    loadimm  u64   "typeof("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadref  u64   .tn 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #3989 
#3990:
    loadref  u64   .tn 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #3994 
    setcall        2
    loadref  u64   .tn 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "."
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#3994:
#3993:
    setcall        2
    loadref  u64   .tn 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#3989:
    jump           #3985 
#3987:
#3986:
    load     i64   .m 
    loadimm  i64   30 
    jumpge   i64   #3997 
    load     i64   .m 
    loadimm  i64   7 
    jumpeq   i64   #3997 
    setcall        2
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #3985 
#3997:
#3996:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    double         
    store    i64   .mbase 
    loadimm  i64   7 
    jumpeq   i64   #3999 1
    loadimm  i64   10 
    jumpeq   i64   #4000 1
    loadimm  i64   11 
    jumpeq   i64   #4001 1
    loadimm  i64   8 
    jumpeq   i64   #4002 1
    loadimm  i64   0 
    jumpeq   i64   #4003 1
    loadimm  i64   30 
    jumpeq   i64   #4004 1
    loadimm  i64   24 
    jumpeq   i64   #4005 1
    loadimm  i64   28 
    jumpeq   i64   #4006 1
    loadimm  i64   27 
    jumpeq   i64   #4007 
    jump           #4008 
#3999:
    setcall        2
    loadimm  u64   "ref "
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .target 
    load     i64   .target 
    loadimm  i64   0 
    jumplt   i64   #4011 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .target 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpne   i64   #4011 
    setcall        2
    setcall        1
    load     i64   .target 
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #4010 
#4011:
    setcall        3
    load     u64   .dest 
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
#4010:
    jump           #3998 
#4000:
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    iloadx   u64   8 0
    jumpf    u64   #4013 
    setcall        2
    loadref  u64   .strdim 
    setarg   u64   2
    setcall        1
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    iloadx   u64   8 0
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    setarg   u64   1
    callp          mm_support.gs_copytostr 2 0
    load     u64   .dest 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "@[#]"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   .strdim 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #4012 
#4013:
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    jumpf    i64   #4016 
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   1 
    jumpne   i64   #4018 
    load     u64   .dest 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "[#]"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    add      i64   
    loadimm  i64   1 
    sub      i64   
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #4017 
#4018:
    load     u64   .dest 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "[#..#]"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    add      i64   
    loadimm  i64   1 
    sub      i64   
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#4017:
    jump           #4015 
#4016:
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   1 
    jumpne   i64   #4022 
    load     u64   .dest 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "[]"
    callp          msys.m$print_setfmt 1 0
    callp          msys.m$print_end 0 0
    jump           #4021 
#4022:
    load     u64   .dest 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "[#:]"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#4021:
#4015:
#4012:
    setcall        3
    load     u64   .dest 
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
    jump           #3998 
#4001:
    loadref  u64   mm_tables.stdnames 
    load     i64   .mbase 
    iloadx   u64   8 0
    store    u64   .prefix 
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    iloadx   u64   8 0
    jumpf    u64   #4026 
    setcall        2
    loadref  u64   .strdim 
    setarg   u64   2
    setcall        1
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    iloadx   u64   8 0
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    setarg   u64   1
    callp          mm_support.gs_copytostr 2 0
    load     u64   .dest 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "@#[#:]"
    callp          msys.m$print_setfmt 1 0
    load     u64   .prefix 
    callp          msys.m$print_str_nf 1 0
    loadref  u64   .strdim 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #4025 
#4026:
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   1 
    jumpne   i64   #4029 
    setcall        2
    load     u64   .prefix 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "[]"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #4028 
#4029:
    load     u64   .dest 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "#[#:]"
    callp          msys.m$print_setfmt 1 0
    load     u64   .prefix 
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#4028:
#4025:
    setcall        3
    load     u64   .dest 
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
    jump           #3998 
#4002:
    load     i64   .expand 
    jumpt    i64   #4033 
    setcall        2
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #3985 
#4033:
#4032:
    setcall        2
    loadimm  u64   ""
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    load     i64   .expand 
    loadimm  i64   2 
    jumpeq   i64   #4036 
    setcall        2
    setcall        1
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4036:
#4035:
    setcall        2
    loadimm  u64   "("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    store    u64   .d 
    loadimm  i64   0 
    store    i64   .needcomma 
    load     u64   .d 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #4041 
#4038:
    load     i64   .needcomma 
    jumpf    i64   #4043 
    setcall        2
    loadimm  u64   ","
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4043:
#4042:
    loadimm  i64   1 
    store    i64   .needcomma 
    setcall        3
    load     u64   .dest 
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .q 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    load     u64   .q 
    iload    u64   
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4039:
    load     u64   .q 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .q 
#4041:
    load     u64   .q 
    jumpt    u64   #4038 
#4040:
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #3998 
#4003:
    setcall        2
    loadimm  u64   "void"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #3998 
#4004:
    setcall        2
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #3998 
#4005:
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    store    u64   .d 
    setcall        2
    loadimm  u64   "proc("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    load     u64   .d 
    loadimm  i64   104 
    iloadx   u64   1 0
    store    u64   .q 
    loadimm  i64   0 
    store    i64   .needcomma 
    jump           #4050 
#4049:
    load     i64   .needcomma 
    jumpf    i64   #4053 
    setcall        2
    loadimm  u64   ","
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4053:
#4052:
    loadimm  i64   1 
    store    i64   .needcomma 
    setcall        3
    load     u64   .dest 
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .q 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    load     u64   .q 
    iload    u64   
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    load     u64   .q 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .q 
#4050:
    load     u64   .q 
    loadimm  u64   0 
    jumpne   u64   #4049 
#4051:
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpeq   i64   #4058 
    setcall        3
    load     u64   .dest 
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
#4058:
#4057:
    jump           #3998 
#4006:
    setcall        2
    loadimm  u64   "Tuple("
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .n 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .n 
    loadimm  i64   1 
    jumplt   i64   #4062 
#4060:
    setcall        3
    load     u64   .dest 
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    loadref  u64   mm_decls.ttmult 
    load     i64   .m 
    iloadx   u64   8 0
    load     i64   .i 
    iloadx   i32   4 -4
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
    load     i64   .i 
    load     i64   .n 
    jumpge   i64   #4064 
    setcall        2
    loadimm  u64   ","
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4064:
#4063:
#4061:
    forup          #4060 1
    opnd           .i 
    opnd           .n 
#4062:
    setcall        2
    loadimm  u64   ")"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #3998 
#4007:
    setcall        2
    loadimm  u64   "bitfield"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #3998 
#4008:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   30 
    jumpge   i64   #4069 
    setcall        2
    loadimm  u64   "Alias for:"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        3
    load     u64   .dest 
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callp          mm_lib.istrmode 3 0
    jump           #4068 
#4069:
    callp          msys.m$print_startcon 0 0
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.typename 1 0
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "NEWSTRMODE"
    setarg   u64   1
    callp          mm_support.mcerror 1 0
#4068:
#3998:
;------------------------
#3985:
    return         
end

proc mm_lib.addtoproclist
    param    u64   .d 
    local    u64   .pp 
;------------------------
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .pp 
    load     u64   mm_decls.proclist 
    loadimm  u64   0 
    jumpne   u64   #4074 
    load     u64   .pp 
    double         
    store    u64   mm_decls.proclistx 
    store    u64   mm_decls.proclist 
    jump           #4073 
#4074:
    load     u64   .pp 
    load     u64   mm_decls.proclistx 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .pp 
    store    u64   mm_decls.proclistx 
#4073:
    load     u64   .d 
    load     u64   .pp 
    loadimm  i64   0 
    istorex  u64   1 0
;------------------------
#4072:
    return         
end

proc mm_lib.addstatic
    param    u64   .d 
    local    u64   .pp 
;------------------------
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .pp 
    load     u64   mm_decls.staticlist 
    loadimm  u64   0 
    jumpne   u64   #4077 
    load     u64   .pp 
    double         
    store    u64   mm_decls.staticlistx 
    store    u64   mm_decls.staticlist 
    jump           #4076 
#4077:
    load     u64   .pp 
    load     u64   mm_decls.staticlistx 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .pp 
    store    u64   mm_decls.staticlistx 
#4076:
    load     u64   .d 
    load     u64   .pp 
    loadimm  i64   0 
    istorex  u64   1 0
;------------------------
#4075:
    return         
end

proc mm_lib.addexpconst
    param    u64   .d 
    local    u64   .pp 
;------------------------
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .pp 
    load     u64   mm_decls.constlist 
    loadimm  u64   0 
    jumpne   u64   #4080 
    load     u64   .pp 
    double         
    store    u64   mm_decls.constlistx 
    store    u64   mm_decls.constlist 
    jump           #4079 
#4080:
    load     u64   .pp 
    load     u64   mm_decls.constlistx 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .pp 
    store    u64   mm_decls.constlistx 
#4079:
    load     u64   .d 
    load     u64   .pp 
    loadimm  i64   0 
    istorex  u64   1 0
;------------------------
#4078:
    return         
end

proc mm_lib.typename
    rettype  u64   
    param    i64   .m 
;------------------------
    load     i64   .m 
    loadimm  i64   0 
    jumplt   i64   #4083 
    loadref  u64   ttname 
    load     i64   .m 
    iloadx   u64   8 0
    setret   u64   
    jump           #4081 
#4083:
#4082:
    loadref  u64   mm_decls.typenames 
    load     i64   .m 
    neg      i64   
    addptrx  u8:32 32 0
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    setret   u64   
    jump           #4081 
;------------------------
#4081:
    return         
end

proc mm_lib.allocunitrec
    rettype  u64   
    local    u64   .p 
    local    u64   .q 
    local    i64   .nwords 
;------------------------
    loadref  u64   mm_decls.nunits 
    incrto   i64   1
    loadref  u64   mm_lib.remainingunits 
    loaddecr i64   1
    jumpf    i64   #4086 
    load     u64   mm_lib.unitheapptr 
    store    u64   .p 
    loadref  u64   mm_lib.unitheapptr 
    incrto   u64   64
    load     i64   mm_lib.parsedone 
    jumpf    i64   #4088 
    load     i64   mm_tables.mlineno 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #4087 
#4088:
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
#4087:
    load     i64   mm_decls.currmoduleno 
    load     u64   .p 
    loadimm  i64   56 
    istorex  u8    1 0
    loadref  u64   mm_decls.moduletosub 
    load     i64   mm_decls.currmoduleno 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   57 
    istorex  u8    1 0
    load     u64   .p 
    setret   u64   
    jump           #4084 
#4086:
#4085:
    setcall        1
    loadimm  i64   2097152 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    double         
    store    u64   mm_lib.unitheapptr 
    store    u64   .p 
    setcall        3
    loadimm  u64   2097152 
    setarg   u64   3
    loadimm  i64   0 
    setarg   i32   2
    load     u64   .p 
    setarg   u64   1
    callp          memset 3 0
    loadimm  i64   32767 
    store    i64   mm_lib.remainingunits 
    loadref  u64   mm_lib.unitheapptr 
    incrto   u64   64
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     i64   mm_decls.currmoduleno 
    load     u64   .p 
    loadimm  i64   56 
    istorex  u8    1 0
    loadref  u64   mm_decls.moduletosub 
    load     i64   mm_decls.currmoduleno 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   57 
    istorex  u8    1 0
    load     u64   .p 
    setret   u64   
    jump           #4084 
;------------------------
#4084:
    return         
end

proc mm_lib.createdupldef
    rettype  u64   
    param    u64   .owner 
    param    u64   .symptr 
    param    i64   .id 
    local    u64   .p 
    local    u64   .q 
;------------------------
    setcall        0
    callf    u64   mm_lib.newstrec 0 0
    store    u64   .p 
    load     u64   .symptr 
    iload    u64   
    load     u64   .p 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u64   .symptr 
    loadimm  i64   68 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   68 
    istorex  u8    1 0
    loadimm  i64   80 
    load     u64   .p 
    loadimm  i64   69 
    istorex  u8    1 0
    load     u64   .owner 
    load     u64   .p 
    loadimm  i64   8 
    istorex  u64   1 0
    load     i64   .id 
    load     u64   .p 
    loadimm  i64   70 
    istorex  u8    1 0
    load     u64   .symptr 
    loadimm  i64   40 
    iloadx   u64   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  u64   1 0
    load     u64   .p 
    load     u64   .symptr 
    loadimm  i64   40 
    istorex  u64   1 0
    load     u64   .owner 
    jumpf    u64   #4091 
    load     u64   .owner 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #4093 
    load     u64   .p 
    double         
    load     u64   .owner 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .owner 
    loadimm  i64   16 
    istorex  u64   1 0
    jump           #4092 
#4093:
    load     u64   .p 
    load     u64   .owner 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   32 
    istorex  u64   1 0
    load     u64   .p 
    load     u64   .owner 
    loadimm  i64   24 
    istorex  u64   1 0
#4092:
#4091:
#4090:
    load     u64   .p 
    setret   u64   
    jump           #4089 
;------------------------
#4089:
    return         
end

proc mm_lib.createnewmoduledef
    rettype  u64   
    param    u64   .owner 
    param    u64   .symptr 
    param    i64   .id 
;------------------------
    setcall        3
    load     i64   .id 
    setarg   i64   3
    load     u64   .symptr 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.createdupldef 3 0
    setret   u64   
    jump           #4094 
;------------------------
#4094:
    return         
end

proc mm_lib.duplunit
    rettype  u64   
    param    u64   .p 
    param    i64   .lineno 
    local    u64   .q 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #4097 
    loadimm  u64   0 
    setret   u64   
    jump           #4095 
#4097:
#4096:
    setcall        1
    load     u64   .p 
    iload    u8    
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .q 
    load     u64   .p 
    iload    u8:64 
    load     u64   .q 
    istore   u8:64 
    loadimm  u64   0 
    load     u64   .q 
    loadimm  i64   8 
    istorex  u64   1 0
    loadimm  i64   1 
    store    i64   .i 
    loadref  u64   mm_tables.jsubs 
    load     u64   .q 
    iload    u8    
    iloadx   u8    1 0
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #4100 
#4098:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .q 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    load     u64   .q 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .i 
    istorex  u64   8 -8
#4099:
    forup          #4098 1
    opnd           .i 
    opnd           .$av_1 
#4100:
    load     u64   .q 
    setret   u64   
    jump           #4095 
;------------------------
#4095:
    return         
end

proc mm_lib.checkblockreturn
    rettype  i64   
    param    u64   .p 
    local    u64   .e 
    local    u64   .wt 
    local    i64   .m 
    local    i64   .res 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #4103 
    loadimm  i64   0 
    setret   i64   
    jump           #4101 
#4103:
#4102:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
    load     u64   .p 
    iload    u8    
    loadimm  i64   89 
    jumpeq   i64   #4105 1
    loadimm  i64   122 
    jumpeq   i64   #4106 1
    loadimm  i64   92 
    jumpeq   i64   #4107 1
    loadimm  i64   4 
    jumpeq   i64   #4108 1
    loadimm  i64   105 
    jumpeq   i64   #4109 1
    loadimm  i64   107 
    jumpeq   i64   #4109 1
    loadimm  i64   106 
    jumpeq   i64   #4109 1
    loadimm  i64   108 
    jumpeq   i64   #4109 1
    loadimm  i64   5 
    jumpeq   i64   #4110 
    jump           #4111 
#4105:
    loadimm  i64   1 
    setret   i64   
    jump           #4101 
    jump           #4104 
#4106:
    loadimm  i64   1 
    setret   i64   
    jump           #4101 
    jump           #4104 
#4107:
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   2 
    istorex  u8    1 0
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .e 
    jump           #4115 
#4112:
    setcall        1
    load     u64   .e 
    setarg   u64   1
    callf    i64   mm_lib.checkblockreturn 1 0
    jumpt    i64   #4117 
    loadimm  i64   0 
    setret   i64   
    jump           #4101 
#4117:
#4116:
#4113:
    load     u64   .e 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .e 
#4115:
    load     u64   .e 
    jumpt    u64   #4112 
#4114:
    setcall        1
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.checkblockreturn 1 0
    setret   i64   
    jump           #4101 
    jump           #4104 
#4108:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    load     u64   .e 
    jumpf    u64   #4119 
    jump           #4121 
#4120:
    load     u64   .e 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .e 
#4121:
    load     u64   .e 
    jumpf    u64   #4123 
    load     u64   .e 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpt    u64   #4120 
#4123:
#4122:
    setcall        1
    load     u64   .e 
    setarg   u64   1
    callf    i64   mm_lib.checkblockreturn 1 0
    setret   i64   
    jump           #4101 
#4119:
#4118:
    jump           #4104 
#4109:
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   2 
    istorex  u8    1 0
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .wt 
    jump           #4125 
#4124:
    setcall        1
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.checkblockreturn 1 0
    jumpt    i64   #4128 
    loadimm  i64   0 
    setret   i64   
    jump           #4101 
#4128:
#4127:
    load     u64   .wt 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .wt 
#4125:
    load     u64   .wt 
    jumpt    u64   #4124 
#4126:
    setcall        1
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.checkblockreturn 1 0
    setret   i64   
    jump           #4101 
    jump           #4104 
#4110:
    loadimm  i64   1 
    setret   i64   
    jump           #4101 
    jump           #4104 
#4111:
#4104:
    startmx        
    loadref  u64   mm_tables.jisexpr 
    load     u64   .p 
    iload    u8    
    iloadx   u8    1 0
    jumpf    i64   #4130 
    load     i64   .m 
    loadimm  i64   0 
    jumpeq   i64   #4130 
    loadimm  i64   1 
    resetmx        
    jump           #4129 
#4130:
    loadimm  i64   0 
    endmx          
#4129:
    setret   i64   
    jump           #4101 
;------------------------
#4101:
    return         
end

proc mm_lib.isconstunit
    rettype  i64   
    param    u64   .a 
;------------------------
    load     u64   .a 
    loadimm  i64   59 
    iloadx   u8    1 0
    setret   i64   
    jump           #4131 
;------------------------
#4131:
    return         
end

proc mm_lib.getownername
    param    u64   .d 
    param    u64   .dest 
    local    u64   .owner 
;------------------------
    load     u64   .d 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .owner 
    load     u64   .owner 
    loadimm  u64   0 
    jumpeq   u64   #4135 
    load     u64   .owner 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpne   i64   #4134 
#4135:
    jump           #4132 
#4134:
#4133:
    setcall        2
    load     u64   .dest 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.getownername 2 0
    setcall        2
    load     u64   .owner 
    iload    u64   
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "."
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
;------------------------
#4132:
    return         
end

proc mm_lib.getalignment
    rettype  i64   
    param    i64   .m 
    local    i64   .a 
;------------------------
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpeq   i64   #4139 1
    loadimm  i64   8 
    jumpeq   i64   #4140 
    jump           #4141 
#4139:
    setcall        1
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callf    i64   mm_lib.getalignment 1 0
    setret   i64   
    jump           #4137 
    jump           #4138 
#4140:
    loadimm  i64   8 
    setret   i64   
    jump           #4137 
    jump           #4138 
#4141:
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #4143 
    loadimm  i64   8 
    setret   i64   
    jump           #4137 
#4143:
#4142:
#4138:
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    iloadx   u32   4 0
    store    i64   .a 
    load     i64   .a 
    loadimm  i64   1 
    jumpeq   i64   #4145 1
    loadimm  i64   2 
    jumpeq   i64   #4145 1
    loadimm  i64   4 
    jumpeq   i64   #4145 1
    loadimm  i64   8 
    jumpeq   i64   #4145 1
    loadimm  i64   0 
    jumpeq   i64   #4146 
    jump           #4147 
#4145:
    load     i64   .a 
    setret   i64   
    jump           #4137 
    jump           #4144 
#4146:
    loadimm  i64   8 
    setret   i64   
    jump           #4137 
    jump           #4144 
#4147:
#4144:
    callp          msys.m$print_startcon 0 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "GETALIGN SIZE NOT 1248"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
    loadimm  i64   0 
    setret   i64   
    jump           #4137 
;------------------------
#4137:
    return         
end

proc mm_lib.ispoweroftwo
    rettype  i64   
    param    i64   .x 
    local    i64   .a 
    local    i64   .n 
    local    i64   .$av_1 
;------------------------
    loadimm  i64   1 
    store    i64   .a 
    loadimm  i64   0 
    store    i64   .n 
    loadimm  i64   60 
    store    i64   .$av_1 
#4150:
    loadref  u64   .n 
    incrto   i64   1
    load     i64   .a 
    loadimm  i64   1 
    shl      i64   
    store    i64   .a 
    load     i64   .a 
    load     i64   .x 
    jumpne   i64   #4154 
    load     i64   .n 
    setret   i64   
    jump           #4149 
#4154:
#4153:
#4151:
    to             #4150 
    opnd           .$av_1 
#4152:
    loadimm  i64   0 
    setret   i64   
    jump           #4149 
;------------------------
#4149:
    return         
end

proc mm_lib.addlistunit
    param    u64   .ulist 
    param    u64   .ulistx 
    param    u64   .p 
;------------------------
    load     u64   .ulist 
    iload    u64   
    loadimm  u64   0 
    jumpne   u64   #4157 
    load     u64   .p 
    double         
    load     u64   .ulistx 
    istore   u64   
    load     u64   .ulist 
    istore   u64   
    jump           #4156 
#4157:
    load     u64   .p 
    load     u64   .ulistx 
    iload    u64   
    loadimm  i64   8 
    istorex  u64   1 0
#4156:
    load     u64   .p 
    load     u64   .ulistx 
    istore   u64   
;------------------------
#4155:
    return         
end

proc mm_lib.storemode
    rettype  i64   
    param    u64   .owner 
    param    i64   .m 
    param    u64   .pmode 
    local    u64   .r 
;------------------------
    load     i64   .m 
    loadimm  i64   0 
    jumplt   i64   #4160 
    load     i64   .m 
    load     u64   .pmode 
    istore   i32   
    load     i64   .m 
    setret   i64   
    jump           #4158 
#4160:
#4159:
    loadref  u64   mm_decls.typenames 
    load     i64   .m 
    neg      i64   
    addptrx  u8:32 32 0
    store    u64   .r 
    load     u64   .r 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #4162 
    load     u64   .owner 
    load     u64   .r 
    loadimm  i64   0 
    istorex  u64   1 0
    load     i64   .m 
    load     u64   .pmode 
    istore   i32   
    load     u64   .pmode 
    load     u64   .r 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .r 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #4164 
    setcall        1
    loadimm  u64   "PMODE=NIL"
    setarg   u64   1
    callp          mm_support.serror 1 0
#4164:
#4163:
    load     i64   .m 
    setret   i64   
    jump           #4158 
#4162:
#4161:
    setcall        2
    load     u64   .r 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .r 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.newtypename 2 0
    store    i64   .m 
    loadref  u64   mm_decls.typenames 
    load     i64   .m 
    neg      i64   
    addptrx  u8:32 32 0
    store    u64   .r 
    load     u64   .owner 
    load     u64   .r 
    loadimm  i64   0 
    istorex  u64   1 0
    load     i64   .m 
    load     u64   .pmode 
    istore   i32   
    load     u64   .pmode 
    load     u64   .r 
    loadimm  i64   24 
    istorex  u64   1 0
    load     i64   .m 
    setret   i64   
    jump           #4158 
;------------------------
#4158:
    return         
end

proc mm_lib.gettypebase
    rettype  i64   
    param    i64   .m 
;------------------------
    startmx        
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    switch         #4168 4 20
    opnd           #4169 
#4168:
    swlabel        #4172 
    swlabel        #4169 
    swlabel        #4169 
    swlabel        #4169 
    swlabel        #4169 
    swlabel        #4169 
    swlabel        #4169 
    swlabel        #4169 
    swlabel        #4169 
    swlabel        #4173 
    swlabel        #4169 
    swlabel        #4170 
    swlabel        #4170 
    swlabel        #4170 
    swlabel        #4171 
    swlabel        #4171 
    swlabel        #4171 
    endsw          
#4170:
    loadimm  i64   3 
    resetmx        
    jump           #4167 
#4171:
    loadimm  i64   3 
    resetmx        
    jump           #4167 
#4172:
    loadimm  i64   5 
    resetmx        
    jump           #4167 
#4173:
    loadimm  i64   1 
    resetmx        
    jump           #4167 
#4169:
    load     i64   .m 
    endmx          
#4167:
    setret   i64   
    jump           #4166 
;------------------------
#4166:
    return         
end

proc mm_lib.writegsfile
    param    u64   .filename 
    param    u64   .d 
    local    u64   .f 
;------------------------
    setcall        2
    loadimm  u64   "wb"
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    setcall        2
    load     u64   .f 
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callp          mlib.gs_println 2 0
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
;------------------------
#4174:
    return         
end

proc mm_lib.addtolog
    param    u64   .filename 
    param    u64   .logdest 
    local    u64   .f 
    local    i64   .c 
;------------------------
    setcall        2
    loadimm  u64   "rb"
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    load     u64   .f 
    loadimm  u64   0 
    jumpne   u64   #4179 
    jump           #4176 
#4179:
#4178:
#4180:
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fgetc 1 0
    widen    i32   
    store    i64   .c 
    load     i64   .c 
    loadimm  i64   -1 
    jumpne   i64   #4183 
    jump           #4181 
#4183:
#4182:
    setcall        2
    load     u64   .logdest 
    setarg   u64   2
    load     i64   .c 
    setarg   i32   1
    callf    i32   fputc 2 0
    unload   i32   
    jump           #4180 
#4181:
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
;------------------------
#4176:
    return         
end

proc mm_lib.getmemmode
    rettype  i64   
    param    u64   .p 
;------------------------
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    jumpf    i64   #4186 
    load     u64   .p 
    loadimm  i64   63 
    iloadx   u8    1 0
    setret   i64   
    jump           #4184 
#4186:
#4185:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setret   i64   
    jump           #4184 
;------------------------
#4184:
    return         
end

proc mm_lib.getfullname
    rettype  u64   
    param    u64   .d 
    local    u8:128 .chain 
    local    i64   .n 
    local    u64   .e 
    local    i64   .i 
;------------------------
    loadimm  i64   0 
    store    i64   .n 
    load     u64   .d 
    store    u64   .e 
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   7 
    loadbit        
    jumpf    u64   #4189 
    load     u64   .d 
    iload    u64   
    setret   u64   
    jump           #4187 
#4189:
#4188:
#4190:
    load     u64   .e 
    loadref  u64   .chain 
    loadref  u64   .n 
    incrload i64   1
    istorex  u64   8 -8
    load     u64   .e 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .e 
#4191:
    load     u64   .e 
    loadimm  u64   0 
    jumpeq   u64   #4193 
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpne   i64   #4190 
#4193:
#4192:
    setcall        2
    loadref  u64   .chain 
    load     i64   .n 
    iloadx   u64   8 -8
    iload    u64   
    setarg   u64   2
    loadref  u64   mm_lib.getfullname.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    load     i64   .n 
    loadimm  i64   1 
    sub      i64   
    store    i64   .i 
    load     i64   .i 
    loadimm  i64   1 
    jumplt   i64   #4196 
#4194:
    setcall        2
    loadimm  u64   "."
    setarg   u64   2
    loadref  u64   mm_lib.getfullname.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadref  u64   .chain 
    load     i64   .i 
    iloadx   u64   8 -8
    iload    u64   
    setarg   u64   2
    loadref  u64   mm_lib.getfullname.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4195:
    fordown        #4194 1
    opnd           .i 
    opnd           1 
#4196:
    loadref  u64   mm_lib.getfullname.str 
    setret   u64   
    jump           #4187 
;------------------------
#4187:
    return         
end

proc mm_lib.getbasename
    rettype  u64   
    param    u64   .s 
    local    u64   .t 
;------------------------
    load     u64   .s 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    store    u64   .t 
    jump           #4200 
#4199:
    loadref  u64   .t 
    decrto   u64   1
#4200:
    load     u64   .t 
    load     u64   .s 
    jumple   u64   #4202 
    load     u64   .t 
    loadimm  i64   1 
    subptrx  u64   1 0
    iload    u8    
    loadimm  u64   46 
    jumpne   u64   #4199 
#4202:
#4201:
    load     u64   .t 
    setret   u64   
    jump           #4198 
;------------------------
#4198:
    return         
end

proc mm_lib.addstr
    rettype  u64   
    param    u64   .s 
    param    u64   .t 
;------------------------
    setcall        2
    load     u64   .s 
    setarg   u64   2
    loadref  u64   mm_lib.addstr.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    load     u64   .t 
    setarg   u64   2
    loadref  u64   mm_lib.addstr.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    loadref  u64   mm_lib.addstr.str 
    setret   u64   
    jump           #4203 
;------------------------
#4203:
    return         
end

proc mm_libpcl.pclinit
;------------------------
    setcall        1
    loadimm  u64   "$nprocs"
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    store    u64   mm_libpcl.stnprocs 
    setcall        1
    loadimm  u64   "$procname"
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    store    u64   mm_libpcl.stprocname 
    setcall        1
    loadimm  u64   "$procaddr"
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    store    u64   mm_libpcl.stprocaddr 
    loadimm  u64   0 
    double         
    store    u64   mm_pcl.pccodex 
    store    u64   mm_pcl.pccode 
;------------------------
#4204:
    return         
end

proc mm_libpcl.genpc
    param    i64   .opcode 
    param    u64   .a 
    local    u64   .p 
    local    u64   .oldm 
    local    i64   .labno 
;------------------------
    setcall        1
    loadimm  i64   31 
    setarg   i64   1
    callf    u64   mlib.pcm_allocz 1 0
    store    u64   .p 
    load     i64   .opcode 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u8    1 0
    load     i64   mm_tables.mlineno 
    load     u64   .p 
    loadimm  i64   27 
    istorex  u32   1 0
    load     u64   .a 
    load     u64   .p 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   mm_pcl.pccode 
    jumpf    u64   #4210 
    load     u64   .p 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u64   .p 
    store    u64   mm_pcl.pccodex 
    jump           #4209 
#4210:
    load     u64   .p 
    double         
    store    u64   mm_pcl.pccodex 
    store    u64   mm_pcl.pccode 
#4209:
;------------------------
#4208:
    return         
end

proc mm_libpcl.genpc_cond
    param    i64   .opcode 
    param    i64   .cond 
    param    u64   .a 
;------------------------
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     i64   .opcode 
    load     i64   .cond 
    add      i64   
    loadimm  i64   77 
    sub      i64   
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#4211:
    return         
end

proc mm_libpcl.genpclcomment
    param    u64   .s 
    param    u64   .t 
    local    u8:300 .str 
;------------------------
    load     u64   .t 
    jumpf    u64   #4214 
    setcall        2
    load     u64   .s 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    load     u64   .t 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    setcall        2
    loadimm  i64   -1 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   mm_libpcl.gencommentstring 2 0
    setarg   u64   2
    loadimm  i64   150 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #4213 
#4214:
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #4217 
    loadimm  u64   ""
    store    u64   .s 
#4217:
#4216:
    setcall        2
    setcall        2
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   mm_libpcl.gencommentstring 2 0
    setarg   u64   2
    loadimm  i64   150 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#4213:
;------------------------
#4212:
    return         
end

proc mm_libpcl.roundsizetg
    rettype  i64   
    param    i64   .size 
;------------------------
    jump           #4221 
#4220:
    loadref  u64   .size 
    incrto   i64   1
#4221:
    load     i64   .size 
    load     i64   mm_decls.targetsize 
    loadimm  i64   1 
    sub      i64   
    bitand   i64   
    jumpt    i64   #4220 
#4222:
    load     i64   .size 
    setret   i64   
    jump           #4219 
;------------------------
#4219:
    return         
end

proc perror*
    param    u64   .mess 
    param    u64   .param 
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "PCL Error: # (#) on Line: # in #"
    callp          msys.m$print_setfmt 1 0
    load     u64   .mess 
    callp          msys.m$print_str_nf 1 0
    load     u64   .param 
    callp          msys.m$print_str_nf 1 0
    setcall        1
    load     i64   mm_tables.mlineno 
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.sourcefilenames 
    setcall        1
    load     i64   mm_tables.mlineno 
    setarg   u64   1
    callf    i64   mm_support.getfileno 1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    setcall        1
    load     i64   mm_tables.mlineno 
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    setarg   i64   2
    loadref  u64   mm_decls.sourcefilespecs 
    setcall        1
    load     i64   mm_tables.mlineno 
    setarg   u64   1
    callf    i64   mm_support.getfileno 1 0
    iloadx   u64   8 0
    setarg   u64   1
    callp          mm_support.stopcompiler 2 0
;------------------------
#4223:
    return         
end

proc mm_libpcl.createfwdlabel
    rettype  i64   
;------------------------
    loadref  u64   mc_decls.mlabelno 
    incrload i64   1
    setret   i64   
    jump           #4225 
;------------------------
#4225:
    return         
end

proc mm_libpcl.definefwdlabel
    param    i64   .lab 
;------------------------
    setcall        2
    setcall        1
    load     i64   .lab 
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   145 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
;------------------------
#4226:
    return         
end

proc mm_libpcl.definelabel
    rettype  i64   
;------------------------
    setcall        2
    setcall        1
    loadref  u64   mc_decls.mlabelno 
    incrload i64   1
    setarg   i64   1
    callf    u64   mm_libpcl.genlabel 1 0
    setarg   u64   2
    loadimm  i64   145 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    load     i64   mc_decls.mlabelno 
    setret   i64   
    jump           #4227 
;------------------------
#4227:
    return         
end

proc mm_libpcl.stacklooplabels
    param    i64   .a 
    param    i64   .b 
    param    i64   .c 
;------------------------
    loadref  u64   mm_libpcl.loopindex 
    incrto   i64   1
    load     i64   mm_libpcl.loopindex 
    loadimm  i64   50 
    jumple   i64   #4230 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Too many nested loops"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#4230:
#4229:
    load     i64   .a 
    loadref  u64   mm_libpcl.loopstack 
    load     i64   mm_libpcl.loopindex 
    addptrx  u8:32 32 -32
    loadimm  i64   1 
    istorex  i64   8 -8
    load     i64   .b 
    loadref  u64   mm_libpcl.loopstack 
    load     i64   mm_libpcl.loopindex 
    addptrx  u8:32 32 -32
    loadimm  i64   2 
    istorex  i64   8 -8
    load     i64   .c 
    loadref  u64   mm_libpcl.loopstack 
    load     i64   mm_libpcl.loopindex 
    addptrx  u8:32 32 -32
    loadimm  i64   3 
    istorex  i64   8 -8
;------------------------
#4228:
    return         
end

proc mm_libpcl.findlooplabel
    rettype  i64   
    param    i64   .k 
    param    i64   .n 
    local    i64   .i 
;------------------------
    load     i64   mm_libpcl.loopindex 
    load     i64   .n 
    loadimm  i64   1 
    sub      i64   
    sub      i64   
    store    i64   .i 
    load     i64   .i 
    loadimm  i64   1 
    jumplt   i64   #4235 
    load     i64   .i 
    load     i64   mm_libpcl.loopindex 
    jumple   i64   #4234 
#4235:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Bad loop index"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#4234:
#4233:
    loadref  u64   mm_libpcl.loopstack 
    load     i64   .i 
    addptrx  u8:32 32 -32
    load     i64   .k 
    iloadx   i64   8 -8
    setret   i64   
    jump           #4232 
;------------------------
#4232:
    return         
end

proc mm_libpcl.gensysfn
    param    i64   .fnindex 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
;------------------------
    setcall        5
    loadimm  i64   1 
    setarg   i64   5
    load     u64   .c 
    setarg   u64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     i64   .fnindex 
    setarg   i64   1
    callp          mm_libpcl.gensysproc 5 0
;------------------------
#4237:
    return         
end

proc mm_libpcl.gensysproc
    param    i64   .fnindex 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    param    i64   .asfunc 
    local    i64   .nargs 
    local    i64   .opc 
    local    u64   .d 
;------------------------
    loadimm  i64   0 
    store    i64   .nargs 
    load     u64   .c 
    jumpf    u64   #4240 
    setcall        1
    load     u64   .c 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    loadref  u64   .nargs 
    incrto   i64   1
#4240:
#4239:
    load     u64   .b 
    jumpf    u64   #4242 
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    loadref  u64   .nargs 
    incrto   i64   1
#4242:
#4241:
    load     u64   .a 
    jumpf    u64   #4244 
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_blockpcl.evalunit 1 0
    loadref  u64   .nargs 
    incrto   i64   1
#4244:
#4243:
    setcall        1
    load     i64   .fnindex 
    setarg   i64   1
    callf    u64   mm_libpcl.getsysfnhandler 1 0
    store    u64   .d 
    startmx        
    load     i64   .asfunc 
    jumpf    i64   #4246 
    loadimm  i64   35 
    resetmx        
    jump           #4245 
#4246:
    loadimm  i64   34 
    endmx          
#4245:
    store    i64   .opc 
    load     u64   .d 
    jumpf    u64   #4248 
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmemaddr 1 0
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    jump           #4247 
#4248:
    setcall        2
    setcall        1
    loadref  u64   mm_tables.sysfnnames 
    load     i64   .fnindex 
    iloadx   u64   8 -8
    loadimm  i64   3 
    addptrx  u64   1 0
    setarg   u64   1
    callf    u64   mm_libpcl.genname 1 0
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
#4247:
    load     i64   .nargs 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   20 
    istorex  i8    1 0
    loadimm  i64   0 
    load     u64   mm_pcl.pccodex 
    loadimm  i64   21 
    istorex  u8    1 0
;------------------------
#4238:
    return         
end

proc mm_libpcl.getsysfnhandler
    rettype  u64   
    param    i64   .fn 
    local    u64   .p 
    local    u8:300 .str 
    local    i64   .report 
    local    u64   .pp 
;------------------------
    loadref  u64   mm_tables.sysfnhandlers 
    load     i64   .fn 
    iloadx   u64   8 -8
    jumpf    u64   #4251 
    loadref  u64   mm_tables.sysfnhandlers 
    load     i64   .fn 
    iloadx   u64   8 -8
    setret   u64   
    jump           #4249 
#4251:
#4250:
    setcall        2
    loadimm  u64   "m$"
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadref  u64   mm_tables.sysfnnames 
    load     i64   .fn 
    iloadx   u64   8 -8
    loadimm  i64   3 
    addptrx  u64   1 0
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #4256 
#4253:
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .pp 
    iload    u64   
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4258 
    load     u64   .pp 
    iload    u64   
    loadref  u64   mm_tables.sysfnhandlers 
    load     i64   .fn 
    istorex  u64   8 -8
    load     u64   .pp 
    iload    u64   
    setret   u64   
    jump           #4249 
#4258:
#4257:
#4254:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#4256:
    load     u64   .pp 
    jumpt    u64   #4253 
#4255:
    load     i64   mm_decls.passlevel 
    loadimm  i64   9 
    gt       i64   
    store    i64   .report 
    load     i64   .report 
    jumpf    i64   #4260 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Sysfn not found:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   .str 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#4260:
#4259:
    load     i64   .fn 
    loadimm  i64   36 
    jumpeq   i64   #4263 
    setcall        1
    loadimm  i64   36 
    setarg   i64   1
    callf    u64   mm_libpcl.getsysfnhandler 1 0
    store    u64   .p 
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #4265 
    load     i64   .report 
    jumpf    i64   #4265 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "No m$unimpl"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#4265:
#4264:
    load     u64   .p 
    setret   u64   
    jump           #4249 
#4263:
#4262:
    loadimm  u64   0 
    setret   u64   
    jump           #4249 
;------------------------
#4249:
    return         
end

proc mm_libpcl.getpclmode
    rettype  i64   
    param    i64   .t 
    local    i64   .u 
;------------------------
    loadref  u64   mm_tables.stdpclmode 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    iloadx   u8    1 0
    store    i64   .u 
    load     i64   .u 
    loadimm  i64   12 
    jumpne   i64   #4269 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .t 
    iloadx   u8    1 0
    jumpt    i64   #4269 
    loadref  u64   mm_decls.ttsize 
    load     i64   .t 
    iloadx   u32   4 0
    loadimm  i64   1 
    jumpeq   i64   #4271 1
    loadimm  i64   2 
    jumpeq   i64   #4272 1
    loadimm  i64   4 
    jumpeq   i64   #4273 
    jump           #4274 
#4271:
    loadimm  i64   18 
    store    i64   .u 
    jump           #4270 
#4272:
    loadimm  i64   19 
    store    i64   .u 
    jump           #4270 
#4273:
    loadimm  i64   20 
    store    i64   .u 
    jump           #4270 
#4274:
    loadimm  i64   2 
    store    i64   .u 
#4270:
#4269:
#4268:
    load     i64   .u 
    setret   i64   
    jump           #4267 
;------------------------
#4267:
    return         
end

proc mm_libpcl.setmode_u
    param    u64   .p 
;------------------------
    setcall        1
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
;------------------------
#4275:
    return         
end

proc mm_libpcl.setmode
    param    i64   .mode 
;------------------------
    setcall        1
    load     i64   .mode 
    setarg   i64   1
    callf    i64   mm_libpcl.getpclmode 1 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   25 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttsize 
    load     i64   .mode 
    iloadx   u32   4 0
    load     u64   mm_pcl.pccodex 
    loadimm  i64   16 
    istorex  u32   1 0
;------------------------
#4276:
    return         
end

proc mm_libpcl.genint
    rettype  u64   
    param    i64   .x 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    load     i64   .x 
    load     u64   .a 
    loadimm  i64   0 
    istorex  i64   1 0
    loadimm  i64   1 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .a 
    setret   u64   
    jump           #4277 
;------------------------
#4277:
    return         
end

proc mm_libpcl.genscaleoffset
    rettype  u64   
    param    i64   .scale 
    param    i64   .offset 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    load     i64   .scale 
    load     u64   .a 
    loadimm  i64   0 
    istorex  i64   1 0
    loadimm  i64   1 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     i64   .offset 
    load     u64   .a 
    loadimm  i64   12 
    istorex  i32   1 0
    load     u64   .a 
    setret   u64   
    jump           #4278 
;------------------------
#4278:
    return         
end

proc mm_libpcl.genrealmem
    rettype  u64   
    param    r64   .x 
    param    i64   .mode 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    load     i64   .mode 
    loadimm  i64   5 
    jumpne   i64   #4281 
    setcall        1
    load     r64   .x 
    setarg   r64   1
    callf    u64   mm_libpcl.getrealindex 1 0
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    loadimm  i64   9 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    jump           #4280 
#4281:
    setcall        1
    load     r64   .x 
    setarg   r64   1
    callf    u64   mm_libpcl.getreal32index 1 0
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    loadimm  i64   10 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
#4280:
    load     u64   .a 
    setret   u64   
    jump           #4279 
;------------------------
#4279:
    return         
end

proc mm_libpcl.genrealimm
    rettype  u64   
    param    r64   .x 
    param    i64   .mode 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    load     r64   .x 
    load     u64   .a 
    loadimm  i64   0 
    istorex  r64   1 0
    loadimm  i64   2 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .a 
    setret   u64   
    jump           #4282 
;------------------------
#4282:
    return         
end

proc mm_libpcl.genlabel
    rettype  u64   
    param    i64   .x 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    load     i64   .x 
    loadimm  i64   0 
    jumpne   i64   #4285 
    loadref  u64   mc_decls.mlabelno 
    incrload i64   1
    store    i64   .x 
#4285:
#4284:
    load     i64   .x 
    load     u64   .a 
    loadimm  i64   0 
    istorex  i64   1 0
    loadimm  i64   5 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .a 
    setret   u64   
    jump           #4283 
;------------------------
#4283:
    return         
end

proc mm_libpcl.genmem
    rettype  u64   
    param    u64   .d 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   5 
    loadbit        
    jumpf    u64   #4288 
    load     u64   .d 
    loadimm  i64   88 
    iloadx   u64   1 0
    jumpf    u64   #4288 
    load     u64   .d 
    loadimm  i64   88 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
#4288:
#4287:
    load     u64   .d 
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u64   .d 
    loadimm  i64   156 
    addptrx  u64   1 0
    incrto   i16   1
    loadimm  i64   4 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .a 
    setret   u64   
    jump           #4286 
;------------------------
#4286:
    return         
end

proc mm_libpcl.genmemaddr
    rettype  u64   
    param    u64   .d 
    local    u64   .a 
;------------------------
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   5 
    loadbit        
    jumpf    u64   #4291 
    load     u64   .d 
    loadimm  i64   88 
    iloadx   u64   1 0
    jumpf    u64   #4291 
    load     u64   .d 
    loadimm  i64   88 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
#4291:
#4290:
    load     u64   .d 
    loadimm  i64   156 
    addptrx  u64   1 0
    incrto   i16   1
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    load     u64   .d 
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u64   .d 
    loadimm  i64   156 
    addptrx  u64   1 0
    incrto   i16   1
    loadimm  i64   4 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .a 
    setret   u64   
    jump           #4289 
;------------------------
#4289:
    return         
end

proc mm_libpcl.gentemp
    rettype  u64   
    param    i64   .n 
    local    u64   .a 
    local    u64   .d 
;------------------------
    loadref  u64   mc_decls.pcltempflags 
    load     i64   .n 
    iloadx   u8    1 -1
    jumpf    i64   #4294 
    loadref  u64   mc_decls.pcltemps 
    load     i64   .n 
    iloadx   u64   8 -8
    setret   u64   
    jump           #4292 
#4294:
#4293:
    setcall        1
    loadimm  i64   3 
    setarg   i64   1
    callf    u64   mm_libpcl.newblocktemp 1 0
    store    u64   .d 
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    loadimm  i64   4 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .d 
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u64   .a 
    loadref  u64   mc_decls.pcltemps 
    load     i64   .n 
    istorex  u64   8 -8
    loadimm  i64   1 
    loadref  u64   mc_decls.pcltempflags 
    load     i64   .n 
    istorex  u8    1 -1
    load     u64   .a 
    setret   u64   
    jump           #4292 
;------------------------
#4292:
    return         
end

proc mm_libpcl.genassem
    rettype  u64   
    param    u64   .p 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    loadimm  i64   7 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .p 
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u64   .a 
    setret   u64   
    jump           #4295 
;------------------------
#4295:
    return         
end

proc mm_libpcl.genstring
    rettype  u64   
    param    u64   .s 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mm_libpcl.getstringindex 1 0
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    loadimm  i64   8 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .a 
    setret   u64   
    jump           #4296 
;------------------------
#4296:
    return         
end

proc mm_libpcl.gencommentstring
    rettype  u64   
    param    u64   .s 
    param    i64   .length 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    load     i64   .length 
    loadimm  i64   0 
    jumpge   i64   #4299 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .length 
#4299:
#4298:
    setcall        1
    load     i64   .length 
    loadimm  i64   1 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    setcall        3
    load     i64   .length 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .a 
    iload    u64   
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   .a 
    iload    u64   
    load     i64   .length 
    addptrx  u64   1 0
    istore   u8    
    loadimm  i64   3 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .a 
    setret   u64   
    jump           #4297 
;------------------------
#4297:
    return         
end

proc mm_libpcl.genname
    rettype  u64   
    param    u64   .s 
    local    u8:64 .str 
    local    u64   .a 
;------------------------
    setcall        0
    callf    u64   mm_libpcl.newopnd 0 0
    store    u64   .a 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    load     u64   .a 
    loadimm  i64   0 
    istorex  u64   1 0
    loadimm  i64   6 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u8    1 0
    load     u64   .a 
    setret   u64   
    jump           #4300 
;------------------------
#4300:
    return         
end

proc mm_libpcl.asmstr
    param    u64   .s 
;------------------------
    setcall        2
    load     u64   .s 
    setarg   u64   2
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
;------------------------
#4301:
    return         
end

proc mm_libpcl.asmchar
    param    i64   .c 
;------------------------
    setcall        2
    load     i64   .c 
    setarg   i64   2
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_char 2 0
;------------------------
#4302:
    return         
end

proc mm_libpcl.asmsp
;------------------------
    setcall        2
    loadimm  i64   32 
    setarg   i64   2
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_char 2 0
;------------------------
#4303:
    return         
end

proc mm_libpcl.asmint
    param    i64   .a 
;------------------------
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .a 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    load     u64   mm_lib.dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
;------------------------
#4304:
    return         
end

proc mm_libpcl.getdispname
    rettype  u64   
    param    u64   .d 
    param    i64   .frompcl 
    local    u64   .name 
;------------------------
    load     i64   .frompcl 
    jumpf    i64   #4307 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   12 
    jumpeq   i64   #4308 1
    loadimm  i64   13 
    jumpne   i64   #4307 
#4308:
    loadref  u64   mm_libpcl.getdispname.str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   ".#"
    callp          msys.m$print_setfmt 1 0
    load     u64   .d 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    loadref  u64   mm_libpcl.getdispname.str 
    setret   u64   
    jump           #4305 
#4307:
#4306:
    load     u8    mm_topcl.fshortnames 
    jumpf    i64   #4311 
    load     u64   .d 
    iload    u64   
    setret   u64   
    jump           #4305 
#4311:
#4310:
    load     u64   .d 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpne   i64   #4313 
    load     u64   .d 
    iload    u64   
    setret   u64   
    jump           #4305 
#4313:
#4312:
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_lib.getfullname 1 0
    store    u64   .name 
    load     u64   .d 
    loadimm  i64   96 
    iloadx   u64   1 0
    jumpf    u64   #4315 
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   7 
    loadbit        
    jumpf    u64   #4315 
    setcall        2
    startmx        
    load     i64   .frompcl 
    jumpf    i64   #4317 
    loadimm  u64   ""
    resetmx        
    jump           #4316 
#4317:
    loadimm  u64   "`"
    endmx          
#4316:
    setarg   u64   2
    loadref  u64   mm_libpcl.getdispname.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    load     u64   .d 
    loadimm  i64   96 
    iloadx   u64   1 0
    setarg   u64   2
    loadref  u64   mm_libpcl.getdispname.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #4314 
#4315:
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   7 
    loadbit        
    jumpf    u64   #4320 
    setcall        2
    load     u64   .name 
    setarg   u64   2
    loadref  u64   mm_libpcl.getdispname.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #4314 
#4320:
    load     u64   .name 
    setret   u64   
    jump           #4305 
#4314:
    loadref  u64   mm_libpcl.getdispname.str 
    setret   u64   
    jump           #4305 
;------------------------
#4305:
    return         
end

proc mm_libpcl.strvalue
    rettype  u64   
    param    u64   .a 
    param    i64   .frompcl 
    local    u8:128 .str2 
    local    u64   .def 
    local    i64   .value 
    local    i64   .offset 
    local    i64   .length 
    local    u64   .ss 
;------------------------
    load     u64   .a 
    iload    u64   
    store    u64   .def 
    load     u64   .a 
    iload    i64   
    store    i64   .value 
    setcall        2
    loadimm  u64   ""
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u8    1 0
    loadimm  i64   4 
    jumpeq   i64   #4324 1
    loadimm  i64   1 
    jumpeq   i64   #4325 1
    loadimm  i64   2 
    jumpeq   i64   #4326 1
    loadimm  i64   9 
    jumpeq   i64   #4327 1
    loadimm  i64   10 
    jumpeq   i64   #4327 1
    loadimm  i64   8 
    jumpeq   i64   #4328 1
    loadimm  i64   3 
    jumpeq   i64   #4329 1
    loadimm  i64   6 
    jumpeq   i64   #4330 1
    loadimm  i64   5 
    jumpeq   i64   #4331 1
    loadimm  i64   7 
    jumpeq   i64   #4332 
    jump           #4333 
#4324:
    setcall        2
    setcall        2
    load     i64   .frompcl 
    setarg   i64   2
    load     u64   .def 
    setarg   u64   1
    callf    u64   mm_libpcl.getdispname 2 0
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
;addoffset::
#4334:
    load     u64   .a 
    loadimm  i64   12 
    iloadx   i32   1 0
    double         
    store    i64   .offset 
    jumpf    i64   #4336 
    loadref  u64   .str2 
    callp          msys.m$print_startstr 1 0
    startmx        
    load     i64   .offset 
    loadimm  i64   0 
    jumple   i64   #4338 
    loadimm  u64   "+"
    resetmx        
    jump           #4337 
#4338:
    loadimm  u64   ""
    endmx          
#4337:
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     i64   .offset 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadref  u64   .str2 
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4336:
#4335:
    jump           #4323 
#4325:
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .value 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #4323 
#4326:
    load     u64   .a 
    iload    r64   
    loadimm  r64   9218868437227405312 
    jumpne   r64   #4342 
    loadref  u64   mm_libpcl.strvalue.str 
    callp          msys.m$print_startstr 1 0
    loadimm  i64   0 
    load     u64   .a 
    iload    r64   
    typepun  u64 r64 
    callp          msys.m$print_u64 2 0
    callp          msys.m$print_end 0 0
    jump           #4341 
#4342:
    loadref  u64   mm_libpcl.strvalue.str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "20.20"
    load     u64   .a 
    iload    r64   
    callp          msys.m$print_r64 2 0
    callp          msys.m$print_end 0 0
#4341:
    jump           #4323 
#4327:
    jump           #4344 
    unload   u64   
    jump           #4323 
#4328:
    load     i64   .frompcl 
    jumpf    i64   #4346 
    load     u64   .a 
    iload    u64   
    iload    u64   
    store    u64   .ss 
    setcall        1
    load     u64   .ss 
    setarg   u64   1
    callf    i64   strlen 1 0
    loadimm  i64   8 
    jumple   i64   #4348 
    loadimm  u64   "\"<LS3:LONGSTR>\""
    setret   u64   
    jump           #4321 
    jump           #4347 
#4348:
    setcall        2
    loadref  u64   mm_libpcl.strvalue.str 
    loadimm  i64   2 
    addptrx  u8    1 -1
    setarg   u64   2
    load     u64   .a 
    iload    u64   
    iload    u64   
    setarg   u64   1
    callf    i64   mm_lib.convertstring 2 0
    unload   i64   
    loadimm  u64   34 
    loadref  u64   mm_libpcl.strvalue.str 
    loadimm  i64   1 
    istorex  u8    1 -1
    setcall        2
    loadimm  u64   "\""
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4347:
    jump           #4345 
#4346:
;dopclmem::
#4344:
    setcall        2
    loadimm  u64   "L"
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .a 
    iload    u64   
    loadimm  i64   16 
    iloadx   i64   1 0
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4345:
    jump           #4323 
#4329:
    setcall        2
    loadimm  u64   "\""
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    load     u64   .a 
    iload    u64   
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "\""
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #4323 
#4330:
    load     u64   .a 
    iload    u64   
    iload    u8    
    loadimm  u64   42 
    jumpne   u64   #4354 
    setcall        2
    load     u64   .a 
    iload    u64   
    loadimm  i64   1 
    addptrx  u64   1 0
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "*"
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #4353 
#4354:
    setcall        2
    load     u64   .a 
    iload    u64   
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#4353:
    jump           #4323 
#4331:
    load     i64   .frompcl 
    jumpf    i64   #4357 
    setcall        2
    loadimm  u64   "#"
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .a 
    iload    i64   
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #4356 
#4357:
    setcall        2
    loadimm  u64   "L"
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .a 
    iload    i64   
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadref  u64   mm_libpcl.strvalue.str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #4334 
#4356:
    jump           #4323 
#4332:
    loadref  u64   mm_libpcl.strvalue.str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "\""
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadref  u64   mclnames 
    load     u64   .a 
    iload    u64   
    loadimm  i64   40 
    iloadx   i16   1 0
    iloadx   u64   8 -8
    loadimm  i64   2 
    addptrx  u64   1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   "\""
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #4323 
#4333:
    loadimm  u64   "<BADVALUE>"
    setret   u64   
    jump           #4321 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "strvalue"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#4323:
    loadref  u64   mm_libpcl.strvalue.str 
    setret   u64   
    jump           #4321 
;------------------------
#4321:
    return         
end

proc mm_libpcl.newopnd
    rettype  u64   
    local    u64   .a 
;------------------------
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mlib.pcm_allocz 1 0
    store    u64   .a 
    load     u64   .a 
    setret   u64   
    jump           #4363 
;------------------------
#4363:
    return         
end

proc mm_libpcl.getstringindex
    rettype  u64   
    param    u64   .s 
;------------------------
    load     u64   mm_pcl.cstringlist 
    jumpf    u64   #4366 
    setcall        2
    load     u64   .s 
    setarg   u64   2
    load     u64   mm_pcl.cstringlist 
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4366 
    load     u64   mm_pcl.cstringlist 
    setret   u64   
    jump           #4364 
#4366:
#4365:
    setcall        2
    load     u64   .s 
    setarg   i64   2
    loadref  u64   mm_pcl.cstringlist 
    setarg   u64   1
    callf    u64   mm_libpcl.addconst 2 0
    setret   u64   
    jump           #4364 
;------------------------
#4364:
    return         
end

proc mm_libpcl.getrealindex
    rettype  u64   
    param    r64   .x 
;------------------------
    setcall        2
    load     r64   .x 
    typepun  i64 r64 
    setarg   i64   2
    loadref  u64   mm_pcl.creallist 
    setarg   u64   1
    callf    u64   mm_libpcl.addconst 2 0
    setret   u64   
    jump           #4367 
;------------------------
#4367:
    return         
end

proc mm_libpcl.getreal32index
    rettype  u64   
    param    r64   .x 
;------------------------
    setcall        2
    load     r64   .x 
    typepun  i64 r64 
    setarg   i64   2
    loadref  u64   mm_pcl.creal32list 
    setarg   u64   1
    callf    u64   mm_libpcl.addconst 2 0
    setret   u64   
    jump           #4368 
;------------------------
#4368:
    return         
end

proc mm_libpcl.newblocktemp
    rettype  u64   
    param    i64   .m 
    local    u8:16 .str 
    local    u64   .d 
;------------------------
    loadref  u64   mm_libpcl.nblocktemps 
    incrto   i64   1
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "$T#"
    callp          msys.m$print_setfmt 1 0
    load     i64   mm_libpcl.nblocktemps 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        3
    loadimm  i64   12 
    setarg   i64   3
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .d 
    load     i64   .m 
    load     u64   .d 
    loadimm  i64   64 
    istorex  i32   1 0
    setcall        2
    load     u64   .d 
    setarg   u64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        2
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_libpcl.genmem 1 0
    setarg   u64   2
    loadimm  i64   3 
    setarg   i64   1
    callp          mm_libpcl.genpc 2 0
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callp          mm_libpcl.setmode 1 0
    load     u64   .d 
    setret   u64   
    jump           #4369 
;------------------------
#4369:
    return         
end

proc mm_libpcl.addconst
    rettype  u64   
    param    u64   .clist 
    param    i64   .value 
    local    u64   .p 
;------------------------
    setcall        1
    loadimm  i64   24 
    setarg   i64   1
    callf    u64   mlib.pcm_allocz 1 0
    store    u64   .p 
    load     i64   .value 
    load     u64   .p 
    loadimm  i64   0 
    istorex  i64   1 0
    loadref  u64   mc_decls.mlabelno 
    incrload i64   1
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    load     u64   .clist 
    iload    u64   
    load     u64   .p 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .p 
    load     u64   .clist 
    istore   u64   
    load     u64   .p 
    setret   u64   
    jump           #4371 
;------------------------
#4371:
    return         
end

proc mm_libsources.findsyslib
    rettype  i64   
    param    u64   .filename 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    loadimm  u64   0 
    jumpf    i64   #4374 
    loadimm  i64   0 
    setret   i64   
    jump           #4372 
#4374:
#4373:
    setcall        1
    load     u64   .filename 
    setarg   u64   1
    callf    u64   mlib.extractfile 1 0
    store    u64   .filename 
    loadimm  i64   1 
    store    i64   .i 
#4375:
    setcall        2
    load     u64   .filename 
    setarg   u64   2
    loadref  u64   mm_libsources.syslibnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4379 
    loadref  u64   mm_libsources.syslibfileno 
    load     i64   .i 
    iloadx   u8    1 -1
    jumpf    i64   #4381 
    loadref  u64   mm_libsources.syslibfileno 
    load     i64   .i 
    iloadx   u8    1 -1
    setret   i64   
    jump           #4372 
#4381:
#4380:
    load     i64   mm_decls.nsourcefiles 
    loadimm  i64   1000 
    jumplt   i64   #4383 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "fsl: too many files"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4383:
#4382:
    loadref  u64   mm_decls.nsourcefiles 
    incrto   i64   1
    setcall        1
    load     u64   .filename 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    setcall        1
    loadref  u64   mm_libsources.libtext 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    loadref  u64   mm_decls.sourcefiletext 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    load     u8    mm_decls.fwritema 
    jumpf    i64   #4387 
    setcall        1
    loadref  u64   mm_libsources.libtext 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    loadref  u64   mm_decls.sourcefiledupl 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
#4387:
#4386:
    setcall        1
    loadref  u64   mm_libsources.libtext 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    i64   strlen 1 0
    loadref  u64   mm_decls.sourcefilesizes 
    load     i64   mm_decls.nsourcefiles 
    istorex  i64   8 0
    loadimm  u64   ""
    loadref  u64   mm_decls.sourcefilepaths 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    loadimm  u64   ""
    loadref  u64   mm_decls.sourcefilespecs 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    loadimm  i64   1 
    loadref  u64   mm_decls.sourcefilesys 
    load     i64   mm_decls.nsourcefiles 
    istorex  u8    1 0
    loadimm  i64   0 
    loadref  u64   mm_decls.sourcefilesupport 
    load     i64   mm_decls.nsourcefiles 
    istorex  u8    1 0
    load     i64   mm_decls.nsourcefiles 
    loadref  u64   mm_libsources.syslibfileno 
    load     i64   .i 
    istorex  u8    1 -1
    load     i64   mm_decls.nsourcefiles 
    setret   i64   
    jump           #4372 
#4379:
#4378:
#4376:
    forup          #4375 1
    opnd           .i 
    opnd           5 
#4377:
    loadimm  i64   0 
    setret   i64   
    jump           #4372 
;------------------------
#4372:
    return         
end

proc mm_modules.readprojectfile
    param    u64   .filename 
    local    i64   .fileno 
    local    i64   .headerdir 
    local    i64   .dir 
    local    i64   .oldsyslib 
    local    i64   .found 
    local    u64   .basefile 
    local    u64   .extension 
;------------------------
    setcall        1
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   mlib.extractext 2 0
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    store    u64   .extension 
    setcall        1
    load     u64   .filename 
    setarg   u64   1
    callf    i64   mlib.checkfile 1 0
    store    i64   .found 
    load     i64   .found 
    jumpt    i64   #4391 
    setcall        2
    loadimm  u64   "ma"
    setarg   u64   2
    load     u64   .extension 
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpt    i64   #4391 
    setcall        1
    setcall        2
    loadimm  u64   "ma"
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   mlib.changeext 2 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   .filename 
    setcall        1
    load     u64   .filename 
    setarg   u64   1
    callf    i64   mlib.checkfile 1 0
    store    i64   .found 
    load     i64   .found 
    jumpf    i64   #4394 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "(Building #)"
    callp          msys.m$print_setfmt 1 0
    load     u64   .filename 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  u64   "ma"
    store    u64   .extension 
#4394:
#4393:
#4391:
#4390:
    load     i64   .found 
    jumpt    i64   #4398 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    load     u64   .filename 
    setarg   u64   2
    loadimm  u64   "Can't find main module or project: ##"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4398:
#4397:
    setcall        2
    loadimm  u64   "ma"
    setarg   u64   2
    load     u64   .extension 
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4402 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   mm_modules.loadmafile 2 0
    store    u64   .filename 
#4402:
#4401:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  i64   0 
    setarg   i64   4
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    i64   mm_support.getsupportfile 5 0
    store    i64   .fileno 
    setcall        1
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   .fileno 
    iloadx   u64   8 0
    setarg   u64   1
    callf    u64   mlib.extractbasefile 1 0
    store    u64   .basefile 
    loadref  u64   mm_decls.sourcefilespecs 
    load     i64   .fileno 
    iloadx   u64   8 0
    store    u64   mm_cli.projectmodule 
    setcall        0
    callp          mm_modules.initheadervars 0 0
    loadimm  i64   1 
    store    i64   mm_decls.headermode 
    loadimm  i64   0 
    store    i64   .headerdir 
    loadimm  u64   "PROGRAM"
    loadref  u64   mm_decls.moduletable 
    loadimm  i64   0 
    addptrx  u8:70 70 0
    loadimm  i64   0 
    istorex  u64   1 0
    loadimm  i64   0 
    loadref  u64   mm_decls.moduletable 
    loadimm  i64   0 
    addptrx  u8:70 70 0
    loadimm  i64   64 
    istorex  i16   1 0
    setcall        3
    loadimm  i64   1 
    setarg   i64   3
    setcall        1
    loadimm  u64   "$prog"
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_lib.createdupldef 3 0
    store    u64   mm_decls.stprogram 
    load     u64   mm_decls.stprogram 
    loadref  u64   mm_decls.moduletable 
    loadimm  i64   0 
    addptrx  u8:70 70 0
    loadimm  i64   8 
    istorex  u64   1 0
    setcall        2
    load     i64   .fileno 
    setarg   i64   2
    load     u64   .basefile 
    setarg   u64   1
    callp          mm_modules.addfirstsubprogram 2 0
    setcall        1
    load     i64   .fileno 
    setarg   i64   1
    callp          mm_lex.startlex 1 0
#4407:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   147 
    jumpeq   i64   #4410 1
    loadimm  i64   6 
    jumpeq   i64   #4411 1
    loadimm  i64   67 
    jumpeq   i64   #4412 
    jump           #4413 
#4410:
    loadimm  i64   1 
    store    i64   .headerdir 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .dir 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   mm_modules.dirpos 
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .dir 
    loadimm  i64   1 
    jumpeq   i64   #4415 1
    loadimm  i64   4 
    jumpeq   i64   #4416 1
    loadimm  i64   3 
    jumpeq   i64   #4417 1
    loadimm  i64   6 
    jumpeq   i64   #4418 1
    loadimm  i64   2 
    jumpeq   i64   #4419 1
    loadimm  i64   7 
    jumpeq   i64   #4420 1
    loadimm  i64   5 
    jumpeq   i64   #4421 1
    loadimm  i64   8 
    jumpeq   i64   #4422 1
    loadimm  i64   9 
    jumpeq   i64   #4423 1
    loadimm  i64   15 
    jumpeq   i64   #4424 1
    loadimm  i64   16 
    jumpeq   i64   #4425 1
    loadimm  i64   10 
    jumpeq   i64   #4426 1
    loadimm  i64   11 
    jumpeq   i64   #4427 
    jump           #4428 
#4415:
    setcall        0
    callp          mm_modules.readmoduledir 0 0
    loadimm  u64   ""
    loadref  u64   mm_modules.headervars 
    loadimm  i64   7 
    istorex  u64   8 -8
    jump           #4414 
#4416:
    load     i64   mm_modules.issyslib 
    store    i64   .oldsyslib 
    loadimm  i64   1 
    store    i64   mm_modules.issyslib 
    setcall        0
    callp          mm_modules.readmoduledir 0 0
    load     i64   .oldsyslib 
    store    i64   mm_modules.issyslib 
    loadimm  u64   ""
    loadref  u64   mm_modules.headervars 
    loadimm  i64   7 
    istorex  u64   8 -8
    jump           #4414 
#4417:
    loadimm  u64   ""
    store    u64   mm_modules.altpathx 
    loadimm  i64   0 
    store    i64   mm_modules.issyslib 
    setcall        0
    callp          mm_modules.readsubprogram 0 0
    jump           #4414 
#4418:
    load     u64   mm_modules.importpathx 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #4431 
    loadref  u64   mm_modules.headervars 
    loadimm  i64   1 
    iloadx   u64   8 -8
    store    u64   mm_modules.importpathx 
#4431:
#4430:
    loadimm  i64   1 
    store    i64   mm_modules.issyslib 
    setcall        0
    callp          mm_modules.readsubprogram 0 0
    jump           #4414 
#4419:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #4433 
    setcall        2
    loadimm  u64   "mlib"
    setarg   u64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4433 
    jump           #4435 
    unload   u64   
#4433:
#4432:
    loadimm  i64   0 
    store    i64   mm_modules.issyslib 
    loadimm  u64   ""
    store    u64   mm_modules.altpathx 
    setcall        0
    callp          mm_modules.readimport 0 0
    jump           #4414 
#4420:
    setcall        0
    callp          mm_modules.readinclude 0 0
    jump           #4414 
#4421:
;$hdr_sysimport::
#4435:
    load     u64   mm_modules.importpathx 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #4438 
    loadref  u64   mm_modules.headervars 
    loadimm  i64   1 
    iloadx   u64   8 -8
    store    u64   mm_modules.importpathx 
#4438:
#4437:
    loadimm  i64   1 
    store    i64   mm_modules.issyslib 
    loadimm  u64   ""
    store    u64   mm_modules.altpathx 
    setcall        0
    callp          mm_modules.readimport 0 0
    jump           #4414 
#4422:
    setcall        1
    setcall        0
    callf    u64   mm_modules.readvar 0 0
    setarg   u64   1
    callf    u64   mm_modules.fixpath 1 0
    store    u64   mm_modules.altpathx 
    jump           #4414 
#4423:
    setcall        1
    setcall        0
    callf    u64   mm_modules.readvar 0 0
    setarg   u64   1
    callf    u64   mm_modules.fixpath 1 0
    store    u64   mm_modules.importpathx 
    startmx        
    load     u64   mm_modules.importpathx 
    iload    u8    
    jumpf    u64   #4440 
    load     u64   mm_modules.importpathx 
    resetmx        
    jump           #4439 
#4440:
    load     u64   mm_modules.headerpathx 
    endmx          
#4439:
    store    u64   mm_modules.subprogpath 
    jump           #4414 
#4424:
    setcall        0
    callp          mm_modules.dosetvar 0 0
    jump           #4414 
#4425:
    setcall        0
    callp          mm_modules.doshowvar 0 0
    jump           #4414 
#4426:
    setcall        2
    loadimm  i64   68 
    setarg   i64   2
    setcall        0
    callf    u64   mm_modules.readvar 0 0
    setarg   u64   1
    callp          mm_modules.addlib 2 0
    jump           #4414 
#4427:
    setcall        2
    loadimm  i64   76 
    setarg   i64   2
    setcall        0
    callf    u64   mm_modules.readvar 0 0
    setarg   u64   1
    callp          mm_modules.addlib 2 0
    jump           #4414 
#4428:
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadref  u64   mm_tables.headerdirnames 
    load     i64   .dir 
    iloadx   u64   8 -8
    setarg   u64   2
    loadimm  u64   "Hdr directive not ready:##"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4414:
    setcall        1
    loadimm  i64   6 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    jump           #4409 
#4411:
    jump           #4409 
#4412:
    jump           #4408 
    jump           #4409 
#4413:
    load     i64   mm_lex.sourcelevel 
    jumpf    i64   #4443 
    load     i64   mm_lex.lximport 
    jumpf    i64   #4443 
    setcall        0
    callp          mm_modules.setmixedimport 0 0
    setcall        0
    callp          mm_lex.unstacksource 0 0
    jump           #4442 
#4443:
    loadimm  u64   0 
    store    u64   mm_cli.projectmodule 
    setcall        1
    load     u64   .basefile 
    setarg   u64   1
    callp          mm_modules.setmixedprogram 1 0
    jump           #4408 
#4442:
#4409:
    jump           #4407 
#4408:
    load     i64   mm_decls.nmodules 
    loadimm  i64   0 
    jumpne   i64   #4445 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "No modules specified"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4445:
#4444:
    setcall        0
    callp          mm_modules.addsyslib 0 0
    setcall        2
    loadimm  i64   68 
    setarg   i64   2
    loadimm  u64   "msvcrt"
    setarg   u64   1
    callp          mm_modules.addlib 2 0
    setcall        2
    loadimm  i64   68 
    setarg   i64   2
    loadimm  u64   "user32"
    setarg   u64   1
    callp          mm_modules.addlib 2 0
    setcall        2
    loadimm  i64   68 
    setarg   i64   2
    loadimm  u64   "gdi32"
    setarg   u64   1
    callp          mm_modules.addlib 2 0
    setcall        2
    loadimm  i64   68 
    setarg   i64   2
    loadimm  u64   "kernel32"
    setarg   u64   1
    callp          mm_modules.addlib 2 0
;------------------------
#4389:
    return         
end

proc mm_modules.initheadervars
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
#4453:
    loadimm  u64   ""
    loadref  u64   mm_modules.headervars 
    load     i64   .i 
    istorex  u64   8 -8
#4454:
    forup          #4453 1
    opnd           .i 
    opnd           10 
#4455:
    loadimm  u64   "C:/mxp/"
    loadref  u64   mm_modules.headervars 
    loadimm  i64   1 
    istorex  u64   8 -8
    setcall        1
    setcall        1
    loadref  u64   msys.sysparams 
    loadimm  i64   1 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    u64   mlib.extractpath 1 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    loadref  u64   mm_modules.headervars 
    loadimm  i64   2 
    istorex  u64   8 -8
    setcall        1
    loadref  u64   mm_decls.sourcefilepaths 
    loadimm  i64   1 
    iloadx   u64   8 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    double         
    loadref  u64   mm_modules.headervars 
    loadimm  i64   3 
    istorex  u64   8 -8
    double         
    store    u64   mm_modules.headerpathx 
    store    u64   mm_modules.subprogpath 
    load     u8    mm_decls.fwindows 
    jumpf    i64   #4459 
    loadimm  u64   "1"
    loadref  u64   mm_modules.headervars 
    loadimm  i64   4 
    istorex  u64   8 -8
#4459:
#4458:
    loadimm  u64   "1"
    loadref  u64   mm_modules.headervars 
    loadimm  i64   7 
    istorex  u64   8 -8
;------------------------
#4452:
    return         
end

proc mm_modules.readmoduledir
    local    u64   .modulename 
    local    u64   .modulefilespec 
    local    u64   .stalias 
;------------------------
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    double         
    store    u64   .modulefilespec 
    store    u64   .modulename 
    setcall        1
    load     u64   .modulename 
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
    loadimm  u64   0 
    store    u64   .stalias 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #4463 
    setcall        2
    loadimm  u64   "as"
    setarg   u64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4463 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #4466 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .stalias 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #4465 
#4466:
    setcall        1
    setcall        0
    callf    u64   mm_modules.readvar 0 0
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    store    u64   .stalias 
#4465:
#4463:
#4462:
    setcall        0
    callf    i64   mm_modules.checkwhen 0 0
    jumpf    i64   #4468 
    setcall        2
    load     u64   .stalias 
    setarg   u64   2
    load     u64   .modulename 
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
#4468:
#4467:
;------------------------
#4461:
    return         
end

proc mm_modules.checkwhen
    rettype  i64   
    local    i64   .index 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   109 
    jumpeq   i64   #4471 
    loadimm  i64   1 
    setret   i64   
    jump           #4469 
#4471:
#4470:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   148 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .index 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  u64   "1"
    setarg   u64   2
    loadref  u64   mm_modules.headervars 
    load     i64   .index 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    setret   i64   
    jump           #4469 
;------------------------
#4469:
    return         
end

proc mm_modules.addmodule
    param    u64   .modulename 
    param    u64   .stalias 
    local    u64   .pm 
    local    u64   .ps 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   1 
    jumplt   i64   #4476 
#4474:
    setcall        2
    load     u64   .modulename 
    setarg   u64   2
    loadref  u64   mm_decls.moduletable 
    load     i64   .i 
    addptrx  u8:70 70 0
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4478 
    setcall        3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    setcall        1
    load     i64   mm_modules.dirpos 
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   3
    load     u64   .modulename 
    setarg   u64   2
    loadimm  u64   "Duplicate module name: # (Line:#)"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4478:
#4477:
#4475:
    forup          #4474 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#4476:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nsubprogs 
    loadimm  i64   1 
    jumplt   i64   #4482 
#4480:
    setcall        2
    load     u64   .modulename 
    setarg   u64   2
    loadref  u64   mm_decls.subprogtable 
    load     i64   .i 
    addptrx  u8:42 42 0
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4484 
    setcall        3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    setcall        1
    load     i64   mm_modules.dirpos 
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   3
    load     u64   .modulename 
    setarg   u64   2
    loadimm  u64   "Clashing subprog/module name: # (Line:#)"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4484:
#4483:
#4481:
    forup          #4480 1
    opnd           .i 
    opnd           mm_decls.nsubprogs 
#4482:
    load     i64   mm_decls.nmodules 
    loadimm  i64   200 
    jumplt   i64   #4487 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    load     u64   .modulename 
    setarg   u64   2
    loadimm  u64   "Too many modules"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4487:
#4486:
    loadref  u64   mm_decls.moduletable 
    loadref  u64   mm_decls.nmodules 
    incrload i64   1
    addptrx  u8:70 70 0
    store    u64   .pm 
    setcall        1
    load     u64   .modulename 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    load     u64   .pm 
    loadimm  i64   0 
    istorex  u64   1 0
    load     i64   mm_decls.nsubprogs 
    load     u64   .pm 
    loadimm  i64   68 
    istorex  i16   1 0
    setcall        3
    loadimm  i64   3 
    setarg   i64   3
    setcall        1
    load     u64   .modulename 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   mm_decls.stprogram 
    setarg   u64   1
    callf    u64   mm_lib.createnewmoduledef 3 0
    double         
    store    u64   mm_decls.stmodule 
    load     u64   .pm 
    loadimm  i64   8 
    istorex  u64   1 0
    startmx        
    load     u64   mm_modules.altpathx 
    iload    u8    
    jumpf    u64   #4491 
    load     u64   mm_modules.altpathx 
    resetmx        
    jump           #4490 
#4491:
    load     u64   mm_modules.subprogpath 
    endmx          
#4490:
    load     u64   .pm 
    loadimm  i64   24 
    istorex  u64   1 0
    load     i64   mm_modules.issyslib 
    load     u64   .pm 
    loadimm  i64   66 
    istorex  i16   1 0
    load     i64   mm_decls.nmodules 
    load     u64   mm_decls.stmodule 
    loadimm  i64   86 
    istorex  u8    1 0
    load     i64   mm_decls.nsubprogs 
    load     u64   mm_decls.stmodule 
    loadimm  i64   87 
    istorex  u8    1 0
    load     i64   mm_decls.nsubprogs 
    loadref  u64   mm_decls.moduletosub 
    load     i64   mm_decls.nmodules 
    istorex  u8    1 0
    loadref  u64   mm_decls.subprogtable 
    load     i64   mm_decls.nsubprogs 
    addptrx  u8:42 42 0
    store    u64   .ps 
    load     u64   .ps 
    loadimm  i64   32 
    iloadx   i16   1 0
    loadimm  i64   0 
    jumpne   i64   #4493 
    load     i64   mm_decls.nmodules 
    load     u64   .ps 
    loadimm  i64   32 
    istorex  i16   1 0
#4493:
#4492:
    load     u64   .stalias 
    jumpf    u64   #4495 
    setcall        3
    loadimm  i64   18 
    setarg   i64   3
    load     u64   .stalias 
    setarg   u64   2
    load     u64   mm_decls.stprogram 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    load     u64   .pm 
    loadimm  i64   48 
    istorex  u64   1 0
    setcall        2
    load     u64   .pm 
    loadimm  i64   48 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   mm_decls.stprogram 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    loadimm  u64   0 
    load     u64   .pm 
    loadimm  i64   48 
    iloadx   u64   1 0
    loadimm  i64   104 
    istorex  u64   1 0
    setcall        1
    load     u64   mm_decls.stmodule 
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    load     u64   .pm 
    loadimm  i64   48 
    iloadx   u64   1 0
    loadimm  i64   56 
    istorex  u64   1 0
#4495:
#4494:
;------------------------
#4473:
    return         
end

proc mm_modules.addsubprogram
    param    u64   .subprogname 
    param    i64   .fileno 
    local    u64   .ps 
    local    i64   .i 
;------------------------
    load     i64   mm_decls.nsubprogs 
    loadimm  i64   30 
    jumplt   i64   #4498 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    load     u64   .subprogname 
    setarg   u64   2
    loadimm  u64   "Too many subprograms"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4498:
#4497:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nsubprogs 
    loadimm  i64   1 
    jumplt   i64   #4503 
#4501:
    setcall        2
    load     u64   .subprogname 
    setarg   u64   2
    loadref  u64   mm_decls.subprogtable 
    load     i64   .i 
    addptrx  u8:42 42 0
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4505 
    setcall        3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    setcall        1
    load     i64   mm_modules.dirpos 
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   3
    load     u64   .subprogname 
    setarg   u64   2
    loadimm  u64   "Duplicate subprog name: # (Line:#)"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4505:
#4504:
#4502:
    forup          #4501 1
    opnd           .i 
    opnd           mm_decls.nsubprogs 
#4503:
    loadref  u64   mm_decls.subprogtable 
    loadref  u64   mm_decls.nsubprogs 
    incrload i64   1
    addptrx  u8:42 42 0
    store    u64   .ps 
    setcall        1
    load     u64   .subprogname 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    load     u64   .ps 
    loadimm  i64   0 
    istorex  u64   1 0
    startmx        
    load     u64   mm_modules.importpathx 
    iload    u8    
    jumpf    u64   #4508 
    load     u64   mm_modules.importpathx 
    resetmx        
    jump           #4507 
#4508:
    load     u64   mm_modules.subprogpath 
    endmx          
#4507:
    double         
    load     u64   .ps 
    loadimm  i64   24 
    istorex  u64   1 0
    store    u64   mm_modules.subprogpath 
    setcall        3
    loadimm  i64   2 
    setarg   i64   3
    setcall        1
    load     u64   .subprogname 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   mm_decls.stprogram 
    setarg   u64   1
    callf    u64   mm_lib.createnewmoduledef 3 0
    store    u64   mm_decls.stsubprog 
    load     i64   mm_decls.nsubprogs 
    load     u64   mm_decls.stsubprog 
    loadimm  i64   87 
    istorex  u8    1 0
    load     u64   mm_decls.stsubprog 
    load     u64   .ps 
    loadimm  i64   8 
    istorex  u64   1 0
    load     i64   .fileno 
    load     u64   .ps 
    loadimm  i64   34 
    istorex  i64   1 0
    load     i64   mm_modules.issyslib 
    load     u64   .ps 
    loadimm  i64   16 
    istorex  i64   1 0
;------------------------
#4496:
    return         
end

proc mm_modules.addfirstsubprogram
    param    u64   .progname 
    param    i64   .fileno 
    local    u64   .ps 
;------------------------
    loadimm  i64   1 
    store    i64   mm_decls.nsubprogs 
    loadref  u64   mm_decls.subprogtable 
    loadimm  i64   1 
    addptrx  u8:42 42 0
    store    u64   .ps 
    setcall        1
    load     u64   .progname 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    load     u64   .ps 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u64   mm_modules.headerpathx 
    load     u64   .ps 
    loadimm  i64   24 
    istorex  u64   1 0
    setcall        3
    loadimm  i64   2 
    setarg   i64   3
    setcall        1
    load     u64   .progname 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   mm_decls.stprogram 
    setarg   u64   1
    callf    u64   mm_lib.createnewmoduledef 3 0
    store    u64   mm_decls.stsubprog 
    loadimm  i64   1 
    load     u64   mm_decls.stsubprog 
    loadimm  i64   87 
    istorex  u8    1 0
    load     u64   mm_decls.stsubprog 
    load     u64   .ps 
    loadimm  i64   8 
    istorex  u64   1 0
    load     i64   .fileno 
    load     u64   .ps 
    loadimm  i64   34 
    istorex  i64   1 0
    loadimm  i64   1 
    store    i64   mm_decls.mainmoduleno 
;------------------------
#4509:
    return         
end

proc mm_modules.readsubprogram
    local    u64   .subprogname 
    local    u64   .subprogfilespec 
;------------------------
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    double         
    store    u64   .subprogfilespec 
    store    u64   .subprogname 
    setcall        1
    load     u64   .subprogname 
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   109 
    jumpne   i64   #4512 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_lex.lex 0 0
#4512:
#4511:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .subprogname 
    setarg   u64   1
    callp          mm_modules.addsubprogram 2 0
;------------------------
#4510:
    return         
end

proc mm_modules.readimport
    local    u64   .subprogname 
    local    u64   .path 
    local    i64   .fileno 
;------------------------
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   .subprogname 
    setcall        1
    load     u64   .subprogname 
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
    setcall        0
    callp          mm_lex.lex 0 0
    startmx        
    load     u64   mm_modules.importpathx 
    iload    u8    
    jumpf    u64   #4515 
    load     u64   mm_modules.importpathx 
    resetmx        
    jump           #4514 
#4515:
    load     u64   mm_modules.subprogpath 
    endmx          
#4514:
    store    u64   .path 
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  i64   0 
    setarg   i64   4
    load     u64   .path 
    setarg   u64   3
    loadimm  u64   "m"
    setarg   u64   2
    load     u64   .subprogname 
    setarg   u64   1
    callf    i64   mm_support.getsupportfile 5 0
    store    i64   .fileno 
    setcall        2
    load     i64   .fileno 
    setarg   i64   2
    load     u64   .subprogname 
    setarg   u64   1
    callp          mm_modules.addsubprogram 2 0
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     i64   .fileno 
    setarg   i64   1
    callp          mm_lex.stacksource 2 0
;------------------------
#4513:
    return         
end

proc mm_modules.readinclude
    local    u64   .name 
    local    u64   .path 
    local    i64   .fileno 
;------------------------
    setcall        1
    loadimm  i64   76 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   .name 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  i64   0 
    setarg   i64   4
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   "m"
    setarg   u64   2
    load     u64   .name 
    setarg   u64   1
    callf    i64   mm_support.getsupportfile 5 0
    store    i64   .fileno 
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     i64   .fileno 
    setarg   i64   1
    callp          mm_lex.stacksource 2 0
;------------------------
#4517:
    return         
end

proc mm_modules.readvar
    rettype  u64   
    local    u64   .s 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   76 
    jumpeq   i64   #4522 1
    loadimm  i64   148 
    jumpeq   i64   #4523 1
    loadimm  i64   80 
    jumpeq   i64   #4524 
    jump           #4525 
#4522:
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   .s 
    jump           #4521 
#4523:
    loadref  u64   mm_modules.headervars 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    store    u64   .s 
    jump           #4521 
#4524:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    store    u64   .s 
    jump           #4521 
#4525:
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "readvar/bad expr"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
    loadimm  u64   "?"
    store    u64   .s 
#4521:
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .s 
    setret   u64   
    jump           #4520 
;------------------------
#4520:
    return         
end

proc mm_modules.fixpath
    rettype  u64   
    param    u64   .path 
    local    u8:300 .newpath 
    local    i64   .n 
;------------------------
    setcall        1
    load     u64   .path 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .n 
    load     i64   .n 
    loadimm  i64   0 
    jumpne   i64   #4531 
    load     u64   .path 
    setret   u64   
    jump           #4529 
#4531:
#4530:
    load     u64   .path 
    load     i64   .n 
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    iload    u8    
    loadimm  u64   92 
    jumpeq   u64   #4534 1
    loadimm  u64   47 
    jumpne   u64   #4533 
#4534:
    load     u64   .path 
    setret   u64   
    jump           #4529 
#4533:
#4532:
    setcall        2
    load     u64   .path 
    setarg   u64   2
    loadref  u64   .newpath 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "\\"
    setarg   u64   2
    loadref  u64   .newpath 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        1
    loadref  u64   .newpath 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    setret   u64   
    jump           #4529 
;------------------------
#4529:
    return         
end

proc mm_modules.dosetvar
    local    i64   .index 
;------------------------
    setcall        1
    loadimm  i64   148 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .index 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   48 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_modules.readvar 0 0
    loadref  u64   mm_modules.headervars 
    load     i64   .index 
    istorex  u64   8 -8
;------------------------
#4536:
    return         
end

proc mm_modules.doshowvar
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   76 
    jumpne   i64   #4539 
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #4538 
#4539:
    setcall        1
    loadimm  i64   148 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_tables.headervarnames 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    loadimm  i64   3 
    addptrx  u64   1 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "="
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_modules.headervars 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#4538:
    setcall        0
    callp          mm_lex.lex 0 0
;------------------------
#4537:
    return         
end

proc mm_modules.setmixedprogram
    param    u64   .basefile 
    local    u8:100 .name 
    local    i64   .oldns 
;------------------------
    loadref  u64   .name 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "$"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   .basefile 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     i64   mm_decls.nsubprogs 
    store    i64   .oldns 
    loadimm  i64   1 
    store    i64   mm_decls.nsubprogs 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadref  u64   .name 
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
    load     i64   .oldns 
    store    i64   mm_decls.nsubprogs 
    loadimm  i64   1 
    loadref  u64   mm_decls.moduletable 
    load     i64   mm_decls.nmodules 
    addptrx  u8:70 70 0
    loadimm  i64   64 
    istorex  i16   1 0
    load     i64   mm_decls.nmodules 
    double         
    loadref  u64   mm_decls.subprogtable 
    loadimm  i64   1 
    addptrx  u8:42 42 0
    loadimm  i64   32 
    istorex  i16   1 0
    store    i64   mm_decls.mainmoduleno 
;------------------------
#4541:
    return         
end

proc mm_modules.setmixedimport
    local    u8:100 .name 
;------------------------
    loadref  u64   .name 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "$"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadref  u64   mm_decls.subprogtable 
    load     i64   mm_decls.nsubprogs 
    addptrx  u8:42 42 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadref  u64   .name 
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
    loadref  u64   mm_decls.subprogtable 
    load     i64   mm_decls.nsubprogs 
    addptrx  u8:42 42 0
    loadimm  i64   34 
    iloadx   i64   1 0
    loadref  u64   mm_decls.moduletable 
    load     i64   mm_decls.nmodules 
    addptrx  u8:70 70 0
    loadimm  i64   64 
    istorex  i16   1 0
    load     i64   mm_decls.nmodules 
    loadref  u64   mm_decls.subprogtable 
    load     i64   mm_decls.nsubprogs 
    addptrx  u8:42 42 0
    loadimm  i64   32 
    istorex  i16   1 0
;------------------------
#4543:
    return         
end

proc mm_modules.loadmodules
    local    u64   .pm 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   1 
    jumplt   i64   #4547 
#4545:
    loadref  u64   mm_decls.moduletable 
    load     i64   .i 
    addptrx  u8:70 70 0
    store    u64   .pm 
    setcall        1
    load     u64   .pm 
    setarg   u64   1
    callp          mm_modules.loadmodule 1 0
#4546:
    forup          #4545 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#4547:
;------------------------
#4544:
    return         
end

proc mm_modules.loadmodule
    param    u64   .pm 
    local    u8:300 .filespec 
    local    u64   .path 
;------------------------
    load     u64   .pm 
    loadimm  i64   64 
    iloadx   i16   1 0
    jumpf    i64   #4550 
    jump           #4548 
#4550:
#4549:
    load     u64   .pm 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .path 
    load     u64   .path 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #4552 
    load     u64   .pm 
    loadimm  i64   66 
    iloadx   i16   1 0
    jumpf    i64   #4552 
    loadimm  u64   "c:\\mx\\"
    store    u64   .path 
#4552:
#4551:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    load     u64   .pm 
    loadimm  i64   66 
    iloadx   i16   1 0
    setarg   i64   4
    load     u64   .path 
    setarg   u64   3
    loadimm  u64   "m"
    setarg   u64   2
    load     u64   .pm 
    iload    u64   
    setarg   u64   1
    callf    i64   mm_support.getsupportfile 5 0
    load     u64   .pm 
    loadimm  i64   64 
    istorex  i16   1 0
;------------------------
#4548:
    return         
end

proc mm_modules.addsyslib
    local    i64   .i 
;------------------------
    load     u8    mm_decls.msyslevel 
    loadimm  i64   0 
    jumpne   i64   #4557 
    jump           #4555 
#4557:
#4556:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nsubprogs 
    loadimm  i64   1 
    jumplt   i64   #4560 
#4558:
    setcall        2
    loadimm  u64   "mlibx"
    setarg   u64   2
    loadref  u64   mm_decls.subprogtable 
    load     i64   .i 
    addptrx  u8:42 42 0
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4562 
    jump           #4555 
#4562:
#4561:
#4559:
    forup          #4558 1
    opnd           .i 
    opnd           mm_decls.nsubprogs 
#4560:
    loadimm  i64   1 
    store    i64   mm_modules.issyslib 
    loadref  u64   mm_modules.headervars 
    loadimm  i64   1 
    iloadx   u64   8 -8
    store    u64   mm_modules.importpathx 
    loadimm  u64   ""
    store    u64   mm_modules.altpathx 
    load     u8    mm_decls.msyslevel 
    loadimm  i64   1 
    jumpne   i64   #4566 
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    loadimm  u64   "mlibmin"
    setarg   u64   1
    callp          mm_modules.addsubprogram 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "mmin"
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
    jump           #4555 
#4566:
#4565:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    loadimm  u64   "mlibx"
    setarg   u64   1
    callp          mm_modules.addsubprogram 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "msys"
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "mlib"
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "mclib"
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "mwindows"
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    startmx        
    load     u8    mm_decls.fnowindll 
    jumpt    i64   #4576 
    load     i64   mm_decls.passlevel 
    loadimm  i64   7 
    jumpne   i64   #4575 
#4576:
    loadimm  u64   "mwindllc"
    resetmx        
    jump           #4574 
#4575:
    loadimm  u64   "mwindll"
    endmx          
#4574:
    setarg   u64   1
    callp          mm_modules.addmodule 2 0
;------------------------
#4555:
    return         
end

proc mm_modules.addlib
    param    u64   .libname 
    param    i64   .libtype 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nlibfiles 
    loadimm  i64   1 
    jumplt   i64   #4582 
#4580:
    setcall        2
    load     u64   .libname 
    setarg   u64   2
    loadref  u64   mm_decls.libfiles 
    load     i64   .i 
    iloadx   u64   8 0
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4584 
    jump           #4579 
#4584:
#4583:
#4581:
    forup          #4580 1
    opnd           .i 
    opnd           mm_decls.nlibfiles 
#4582:
    load     i64   mm_decls.nlibfiles 
    loadimm  i64   50 
    jumplt   i64   #4586 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Too many libs"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4586:
#4585:
    load     u64   .libname 
    loadref  u64   mm_decls.libfiles 
    loadref  u64   mm_decls.nlibfiles 
    incrload i64   1
    istorex  u64   8 0
    load     i64   .libtype 
    loadref  u64   mm_decls.libtypes 
    load     i64   mm_decls.nlibfiles 
    istorex  u8    1 0
;------------------------
#4579:
    return         
end

proc mm_modules.readfileline
    rettype  u64   
    param    u64   .s 
    local    u8:2048 .str 
    local    u64   .t 
    local    i64   .n 
    local    i64   .c 
;------------------------
    loadref  u64   .str 
    store    u64   .t 
    loadimm  i64   0 
    store    i64   .n 
#4590:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    loadimm  i64   0 
    jumpeq   i64   #4592 1
    loadimm  i64   10 
    jumpeq   i64   #4593 
    jump           #4594 
#4592:
    loadref  u64   .s 
    decrto   u64   1
    jump           #4591 
    jump           #4590 
#4593:
    jump           #4591 
    jump           #4590 
#4594:
    load     i64   .n 
    loadimm  i64   2048 
    jumpge   i64   #4596 
    load     i64   .c 
    loadref  u64   .t 
    loadincr u64   1
    istore   u8    
#4596:
#4595:
    jump           #4590 
#4591:
    loadimm  u64   0 
    load     u64   .t 
    istore   u8    
    loadref  u64   .str 
    callp          msys.m$read_strline 1 0
    load     u64   .s 
    setret   u64   
    jump           #4589 
;------------------------
#4589:
    return         
end

proc mm_modules.findnextlineheader
    rettype  u64   
    param    u64   .s 
    local    i64   .c 
;------------------------
#4598:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    double         
    store    i64   .c 
    loadimm  i64   0 
    jumpeq   i64   #4600 1
    loadimm  i64   10 
    jumpeq   i64   #4601 
    jump           #4602 
#4600:
    loadimm  u64   0 
    setret   u64   
    jump           #4597 
    jump           #4598 
#4601:
    load     u64   .s 
    iload    u8    
    loadimm  u64   61 
    jumpne   u64   #4604 
    load     u64   .s 
    loadimm  i64   1 
    addptrx  u64   1 0
    iload    u8    
    loadimm  u64   61 
    jumpne   u64   #4604 
    load     u64   .s 
    loadimm  i64   2 
    addptrx  u64   1 0
    iload    u8    
    loadimm  u64   61 
    jumpne   u64   #4604 
    load     u64   .s 
    loadimm  i64   3 
    addptrx  u64   1 0
    setret   u64   
    jump           #4597 
#4604:
#4603:
    jump           #4598 
#4602:
    jump           #4598 
#4599:
    loadimm  u64   0 
    setret   u64   
    jump           #4597 
;------------------------
#4597:
    return         
end

proc mm_modules.loadmafile
    rettype  u64   
    param    u64   .filespec 
    param    u64   .builtinstr 
    local    u64   .s 
    local    u64   .t 
    local    u8:100 .name 
    local    u8:300 .newfilespec 
    local    i64   .sys 
    local    i64   .support 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    u8    mm_decls.freadma 
    load     u64   .filespec 
    jumpf    u64   #4607 
    setcall        1
    load     u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.readfile 1 0
    store    u64   .s 
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #4609 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    load     u64   .filespec 
    setarg   u64   2
    loadimm  u64   "Can't find MA file ##"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4609:
#4608:
    setcall        2
    setcall        1
    load     u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.extractpath 1 0
    setarg   u64   2
    loadref  u64   .newfilespec 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #4606 
#4607:
    load     u64   .builtinstr 
    store    u64   .s 
    loadimm  u64   0 
    loadref  u64   .newfilespec 
    loadimm  i64   1 
    istorex  u8    1 -1
#4606:
    setcall        1
    load     u64   .s 
    loadimm  i64   3 
    addptrx  u64   1 0
    setarg   u64   1
    callf    u64   mm_modules.readfileline 1 0
    store    u64   .s 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   110 
    setarg   i64   2
    loadref  u64   .name 
    setarg   u64   1
    callp          msys.readstr 3 0
    setcall        2
    loadimm  u64   "ma"
    setarg   u64   2
    loadref  u64   .name 
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpt    i64   #4613 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "MA: bad header"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4613:
#4612:
    loadref  u64   .s 
    decrto   u64   1
    load     i64   mm_decls.nsourcefiles 
    jumpf    i64   #4618 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "MA/table not empty"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4618:
#4617:
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mm_modules.findnextlineheader 1 0
    store    u64   .s 
#4621:
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #4624 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Unexpected EOF in MA file"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
    jump           #4622 
#4624:
#4623:
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mm_modules.readfileline 1 0
    store    u64   .s 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   110 
    setarg   i64   2
    loadref  u64   .name 
    setarg   u64   1
    callp          msys.readstr 3 0
    loadimm  i64   0 
    callf    i64   msys.m$read_i64 1 0
    store    i64   .sys 
    loadimm  i64   0 
    callf    i64   msys.m$read_i64 1 0
    store    i64   .support 
    setcall        2
    loadimm  u64   "end"
    setarg   u64   2
    loadref  u64   .name 
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4628 
    jump           #4622 
#4628:
#4627:
    load     i64   mm_decls.nsourcefiles 
    loadimm  i64   1000 
    jumplt   i64   #4631 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Too many files in MA"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4631:
#4630:
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mm_modules.findnextlineheader 1 0
    store    u64   .t 
    load     u64   .t 
    loadimm  u64   0 
    jumpne   u64   #4635 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "MA error"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#4635:
#4634:
    loadref  u64   mm_decls.nsourcefiles 
    incrto   i64   1
    setcall        1
    loadref  u64   .name 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    double         
    loadref  u64   mm_decls.sourcefilespecs 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    load     u64   .t 
    load     u64   .s 
    subptr   u64   1
    loadimm  i64   3 
    sub      i64   
    loadref  u64   mm_decls.sourcefilesizes 
    load     i64   mm_decls.nsourcefiles 
    istorex  i64   8 0
    load     u64   .s 
    loadref  u64   mm_decls.sourcefiletext 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    loadimm  u64   ""
    loadref  u64   mm_decls.sourcefilepaths 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    loadimm  u64   ""
    loadref  u64   mm_decls.sourcefilespecs 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    load     i64   .sys 
    loadref  u64   mm_decls.sourcefilesys 
    load     i64   mm_decls.nsourcefiles 
    istorex  u8    1 0
    load     i64   .support 
    loadref  u64   mm_decls.sourcefilesupport 
    load     i64   mm_decls.nsourcefiles 
    istorex  u8    1 0
    load     u64   .t 
    store    u64   .s 
    jump           #4621 
#4622:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nsourcefiles 
    loadimm  i64   1 
    jumplt   i64   #4641 
#4639:
    loadimm  u64   0 
    loadref  u64   mm_decls.sourcefiletext 
    load     i64   .i 
    iloadx   u64   8 0
    loadref  u64   mm_decls.sourcefilesizes 
    load     i64   .i 
    iloadx   i64   8 0
    addptrx  u64   1 0
    istore   u8    
#4640:
    forup          #4639 1
    opnd           .i 
    opnd           mm_decls.nsourcefiles 
#4641:
    setcall        2
    loadref  u64   mm_decls.sourcefilenames 
    loadimm  i64   1 
    iloadx   u64   8 0
    setarg   u64   2
    loadref  u64   .newfilespec 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        1
    loadref  u64   .newfilespec 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    setret   u64   
    jump           #4605 
;------------------------
#4605:
    return         
end

proc mm_name.rx_typetable
    local    u64   .d 
    local    i64   .i 
;------------------------
    loadimm  i64   30 
    store    i64   .i 
    load     i64   mm_decls.ntypes 
    loadimm  i64   30 
    jumplt   i64   #4645 
#4643:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .i 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpne   i64   #4647 
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .i 
    iloadx   u64   8 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   136 
    iloadx   i32   1 0
    jumpf    i64   #4649 
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_name.do_baseclass 1 0
#4649:
#4648:
#4647:
#4646:
#4644:
    forup          #4643 1
    opnd           .i 
    opnd           mm_decls.ntypes 
#4645:
;------------------------
#4642:
    return         
end

proc mm_name.rx_unit
    param    u64   .owner 
    param    u64   .p 
    local    u64   .d 
    local    u64   .a 
    local    u64   .b 
    local    i64   .n 
    local    i64   .oldnoexpand 
    local    i64   .oldnoassem 
    local    i64   .oldtag 
    local    i64   .useparams 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .b 
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    load     u64   .p 
    iload    u8    
    switch         #4652 3 88
    opnd           #4653 
#4652:
    swlabel        #4654 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4694 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4679 
    swlabel        #4679 
    swlabel        #4689 
    swlabel        #4684 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4657 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4659 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4658 
    swlabel        #4697 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4653 
    swlabel        #4659 
    endsw          
#4654:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.resolvename 2 0
    load     u64   .p 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #4656 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   18 
    jumpne   i64   #4656 
    load     i64   mm_name.noexpand 
    jumpt    i64   #4656 
    loadref  u64   mm_name.macrolevels 
    incrto   i64   1
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.expandmacro 3 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    loadref  u64   mm_name.macrolevels 
    decrto   i64   1
#4656:
#4655:
    jump           #4651 
#4657:
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    jump           #4651 
#4658:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.resolvedot 2 0
    jump           #4651 
#4659:
    load     u64   .p 
    iload    u8    
    store    i64   .oldtag 
    load     u64   .a 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #4661 
    load     i64   mm_name.noexpand 
    store    i64   .oldnoexpand 
    loadimm  i64   1 
    store    i64   mm_name.noexpand 
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    load     i64   .oldnoexpand 
    store    i64   mm_name.noexpand 
    jump           #4660 
#4661:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
#4660:
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unitlist 2 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #4663 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   5 
    jumpeq   i64   #4665 1
    loadimm  i64   18 
    jumpeq   i64   #4666 
    jump           #4667 
#4665:
    loadimm  i64   51 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        3
    load     u64   .p 
    loadimm  i64   52 
    addptrx  u64   1 0
    setarg   u64   3
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     u64   .b 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .b 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #4669 
    setcall        2
    load     u64   .b 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    loadimm  i64   0 
    store    i64   .n 
    jump           #4671 
#4670:
    loadref  u64   .n 
    incrto   i64   1
    load     u64   .b 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .b 
#4671:
    load     u64   .b 
    jumpt    u64   #4670 
#4672:
    load     i64   .n 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   40 
    istorex  u32   1 0
#4669:
#4668:
    jump           #4664 
#4666:
    loadref  u64   mm_name.macrolevels 
    incrto   i64   1
    load     u64   .d 
    loadimm  i64   16 
    iloadx   u64   1 0
    jumpf    u64   #4674 
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.expandmacro 3 0
    loadimm  u64   0 
    store    u64   .b 
    loadimm  i64   0 
    store    i64   .useparams 
    jump           #4673 
#4674:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.expandmacro 3 0
    loadimm  i64   1 
    store    i64   .useparams 
#4673:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    loadref  u64   mm_name.macrolevels 
    decrto   i64   1
    load     i64   .useparams 
    jumpf    i64   #4676 
    load     u64   .p 
    iload    u8    
    loadimm  i64   88 
    jumpeq   i64   #4676 1
    loadimm  i64   29 
    jumpeq   i64   #4676 
    setcall        2
    load     i64   .oldtag 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     u64   .b 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
#4676:
#4675:
    jump           #4664 
#4667:
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #4678 
    loadimm  i64   88 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
#4678:
#4677:
#4664:
#4663:
#4662:
    jump           #4651 
#4679:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    loadref  u64   mm_tables.isbooltag 
    load     u64   .a 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #4681 
    setcall        2
    loadimm  i64   15 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadimm  i64   103 
    load     u64   .a 
    loadimm  i64   61 
    istorex  u8    1 0
#4681:
#4680:
    loadref  u64   mm_tables.isbooltag 
    load     u64   .b 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #4683 
    setcall        2
    loadimm  i64   15 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadimm  i64   103 
    load     u64   .b 
    loadimm  i64   61 
    istorex  u8    1 0
#4683:
#4682:
    jump           #4651 
#4684:
;doistruel::
#4685:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    loadref  u64   mm_tables.isbooltag 
    load     u64   .a 
    iload    u8    
    iloadx   u8    1 0
    jumpf    i64   #4687 
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
#4687:
#4686:
    jump           #4688 
    jump           #4651 
#4689:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #4691 
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    loadimm  i64   15 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   103 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    jump           #4685 
#4691:
#4690:
    loadref  u64   mm_tables.isbooltag 
    load     u64   .a 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #4693 
    setcall        2
    loadimm  i64   15 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadimm  i64   103 
    load     u64   .a 
    loadimm  i64   61 
    istorex  u8    1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
#4693:
#4692:
    jump           #4688 
    jump           #4651 
#4694:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.resolvename 2 0
    load     i64   mm_name.noexpand 
    jumpt    i64   #4696 
    loadref  u64   mm_name.macrolevels 
    incrto   i64   1
    load     i64   mm_name.noassem 
    store    i64   .oldnoassem 
    loadimm  i64   1 
    store    i64   mm_name.noassem 
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.expandmacro 3 0
    load     i64   .oldnoassem 
    store    i64   mm_name.noassem 
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    loadref  u64   mm_name.macrolevels 
    decrto   i64   1
#4696:
#4695:
    jump           #4651 
#4697:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    load     u64   .b 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #4699 
    loadimm  i64   47 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
#4699:
#4698:
    jump           #4651 
#4653:
;doabc::
#4688:
    loadimm  i64   1 
    store    i64   .i 
    loadref  u64   mm_tables.jsubs 
    load     u64   .p 
    iload    u8    
    iloadx   u8    1 0
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #4702 
#4700:
    setcall        2
    load     u64   .p 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unitlist 2 0
#4701:
    forup          #4700 1
    opnd           .i 
    opnd           .$av_1 
#4702:
#4651:
;------------------------
#4650:
    return         
end

proc mm_name.rx_module
    rettype  i64   
    param    i64   .n 
    local    u8:70 .m 
    local    u64   .stmodule 
    local    u64   .d 
    local    i64   .globalflag 
    local    i64   .status 
;------------------------
    load     i64   .n 
    store    i64   mm_decls.currmoduleno 
    setcall        2
    loadref  u64   mm_decls.moduletable 
    load     i64   .n 
    addptrx  u8:70 70 0
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   mm_decls.stprogram 
    setarg   u64   1
    callp          mm_name.rx_passdef 2 0
    loadimm  i64   1 
    setret   i64   
    jump           #4703 
;------------------------
#4703:
    return         
end

proc mm_name.rx_deflist
    param    u64   .owner 
    param    u64   .p 
    local    u64   .pstart 
;------------------------
    load     u64   .p 
    store    u64   .pstart 
    jump           #4706 
#4705:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_passdef 2 0
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .p 
#4706:
    load     u64   .p 
    jumpt    u64   #4705 
#4707:
;------------------------
#4704:
    return         
end

proc mm_name.rx_passdef
    param    u64   .owner 
    param    u64   .p 
    local    u64   .d 
;------------------------
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpeq   i64   #4710 1
    loadimm  i64   4 
    jumpeq   i64   #4710 1
    loadimm  i64   6 
    jumpeq   i64   #4711 1
    loadimm  i64   7 
    jumpeq   i64   #4712 1
    loadimm  i64   10 
    jumpeq   i64   #4713 1
    loadimm  i64   11 
    jumpeq   i64   #4713 1
    loadimm  i64   12 
    jumpeq   i64   #4713 1
    loadimm  i64   13 
    jumpeq   i64   #4713 1
    loadimm  i64   5 
    jumpeq   i64   #4714 
    jump           #4715 
#4710:
    setcall        2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.rx_deflist 2 0
    jump           #4709 
#4711:
    setcall        2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.rx_deflist 2 0
    load     u64   .p 
    store    u64   mm_name.currstproc 
    setcall        2
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    loadimm  u64   0 
    store    u64   mm_name.currstproc 
    jump           #4709 
#4712:
    setcall        2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.rx_deflist 2 0
    jump           #4709 
#4713:
    load     u64   .p 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   5 
    loadbit        
    jumpf    u64   #4717 
    setcall        2
    load     u64   .p 
    loadimm  i64   88 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
#4717:
#4716:
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #4719 
    setcall        2
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
#4719:
#4718:
    jump           #4709 
#4714:
    setcall        2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.rx_deflist 2 0
    jump           #4709 
#4715:
#4709:
;------------------------
#4708:
    return         
end

proc mm_name.rx_unitlist
    param    u64   .owner 
    param    u64   .p 
;------------------------
    jump           #4722 
#4721:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .p 
#4722:
    load     u64   .p 
    jumpt    u64   #4721 
#4723:
;------------------------
#4720:
    return         
end

proc mm_name.resolvetopname
    rettype  u64   
    param    u64   .owner 
    param    u64   .stnewname 
    param    i64   .moduleno 
    param    i64   .allowmod 
    local    i64   .extcount 
    local    i64   .subprogno 
    local    u64   .p 
    local    u64   .q 
    local    u64   .powner 
    local    u64   .extdef 
    local    u64   .moddef 
    local    u8:80 .ambiglist 
    local    i64   .i 
;------------------------
    load     u64   .owner 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpne   i64   #4726 
    load     u64   .owner 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #4730 
#4727:
    load     u64   .q 
    loadimm  i64   48 
    iloadx   u64   1 0
    load     u64   .stnewname 
    jumpne   u64   #4732 
    load     u64   .q 
    setret   u64   
    jump           #4724 
#4732:
#4731:
#4728:
    load     u64   .q 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .q 
#4730:
    load     u64   .q 
    jumpt    u64   #4727 
#4729:
#4726:
#4725:
    load     u64   .stnewname 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .p 
    loadref  u64   mm_decls.moduletosub 
    load     i64   .moduleno 
    iloadx   u8    1 0
    store    i64   .subprogno 
    loadimm  i64   0 
    store    i64   .extcount 
    loadimm  u64   0 
    double         
    store    u64   .moddef 
    store    u64   .extdef 
    jump           #4736 
#4733:
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .powner 
    load     u64   .powner 
    loadimm  i64   70 
    iloadx   u8    1 0
    switch         #4738 1 5
    opnd           #4739 
#4738:
    swlabel        #4753 
    swlabel        #4739 
    swlabel        #4740 
    swlabel        #4739 
    swlabel        #4749 
    endsw          
#4740:
    load     u64   .powner 
    loadimm  i64   86 
    iloadx   u8    1 0
    load     i64   .moduleno 
    jumpne   i64   #4742 
    load     u64   .p 
    setret   u64   
    jump           #4724 
    jump           #4741 
#4742:
    load     u64   .p 
    loadimm  i64   191 
    iloadx   u8    1 0
    jumpf    i64   #4743 
    load     u64   .powner 
    loadimm  i64   87 
    iloadx   u8    1 0
    load     i64   .subprogno 
    jumpeq   i64   #4746 
    load     u64   .p 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpeq   i64   #4746 
    load     u64   .p 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   7 
    loadbit        
    jumpf    u64   #4745 
#4746:
    loadref  u64   .extcount 
    incrto   i64   1
    load     u64   .p 
    store    u64   .extdef 
    load     i64   .extcount 
    loadimm  i64   10 
    jumpge   i64   #4748 
    load     u64   .extdef 
    loadref  u64   .ambiglist 
    load     i64   .extcount 
    istorex  u64   8 -8
#4748:
#4747:
#4745:
#4744:
#4743:
#4741:
    jump           #4737 
#4749:
    load     u64   .powner 
    load     u64   .owner 
    jumpeq   u64   #4752 
    load     u64   .powner 
    load     u64   .owner 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpne   u64   #4751 
#4752:
    load     u64   .p 
    setret   u64   
    jump           #4724 
#4751:
#4750:
    jump           #4737 
#4753:
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpeq   i64   #4755 1
    loadimm  i64   2 
    jumpeq   i64   #4755 1
    loadimm  i64   18 
    jumpeq   i64   #4756 
    jump           #4757 
#4755:
    load     u64   .p 
    store    u64   .moddef 
    jump           #4754 
#4756:
    load     u64   .p 
    setret   u64   
    jump           #4724 
    jump           #4754 
#4757:
#4754:
    jump           #4737 
#4739:
#4737:
#4734:
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .p 
#4736:
    load     u64   .p 
    jumpt    u64   #4733 
#4735:
    load     i64   .allowmod 
    jumpf    i64   #4759 
    load     u64   .moddef 
    jumpf    u64   #4759 
    load     u64   .moddef 
    setret   u64   
    jump           #4724 
#4759:
#4758:
    load     u64   .extdef 
    jumpf    u64   #4761 
    load     i64   .extcount 
    loadimm  i64   1 
    jumple   i64   #4763 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .extcount 
    loadimm  i64   1 
    jumplt   i64   #4766 
#4764:
    loadref  u64   .ambiglist 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .extdef 
    callp          msys.m$print_startcon 0 0
    load     i64   .i 
    callp          msys.m$print_i64_nf 1 0
    load     u64   .extdef 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.namenames 
    load     u64   .extdef 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   70 
    iloadx   u8    1 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#4765:
    forup          #4764 1
    opnd           .i 
    opnd           .extcount 
#4766:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .extdef 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Ambiguous ext name: #"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4763:
#4762:
    load     u64   .extdef 
    setret   u64   
    jump           #4724 
#4761:
#4760:
    loadimm  u64   0 
    setret   u64   
    jump           #4724 
;------------------------
#4724:
    return         
end

proc mm_name.resolvename
    param    u64   .owner 
    param    u64   .p 
    local    u64   .d 
    local    u64   .e 
    local    u64   .q 
    local    i64   .moduleno 
    local    i64   .mode 
    local    i64   .islet 
    local    u8:300 .str 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u8    1 0
    store    i64   .moduleno 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpeq   i64   #4770 
    jump           #4768 
#4770:
#4769:
    setcall        4
    load     i64   mm_name.allowmodname 
    setarg   i64   4
    load     i64   .moduleno 
    setarg   i64   3
    load     u64   .d 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_name.resolvetopname 4 0
    store    u64   .e 
    load     u64   .e 
    jumpt    u64   #4772 
    loadimm  i64   0 
    store    i64   .islet 
    loadimm  i64   0 
    store    i64   .mode 
    load     u64   .p 
    loadimm  i64   41 
    iloadx   u8    1 0
    loadimm  i64   73 
    jumpeq   i64   #4774 1
    loadimm  i64   84 
    jumpeq   i64   #4774 1
    loadimm  i64   83 
    jumpeq   i64   #4774 1
    loadimm  i64   76 
    jumpeq   i64   #4775 1
    loadimm  i64   65 
    jumpeq   i64   #4775 
    jump           #4776 
#4774:
    loadimm  i64   3 
    store    i64   .mode 
    loadimm  i64   1 
    store    i64   .islet 
    jump           #4773 
#4775:
    loadimm  i64   23 
    store    i64   .mode 
    jump           #4773 
#4776:
#4773:
    load     i64   .mode 
    loadimm  i64   0 
    jumpne   i64   #4778 
    setcall        2
    load     u64   .d 
    iload    u64   
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   mlib.convucstring 1 0
    unload   u64   
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    loadimm  u64   "pcl:Undefined: #"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
    jump           #4777 
#4778:
    setcall        4
    load     i64   .mode 
    setarg   i64   4
    load     i64   .moduleno 
    setarg   i64   3
    load     u64   .d 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_name.addframevar 4 0
    store    u64   .e 
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    load     u64   .e 
    loadimm  i64   80 
    istorex  u32   1 0
    load     i64   .islet 
    load     u64   .e 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   3 
    storebit       
#4777:
#4772:
#4771:
    loadimm  u64   1 
    load     u64   .e 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   0 
    storebit       
    load     u64   .e 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
;------------------------
#4768:
    return         
end

proc mm_name.finddupl
    rettype  u64   
    param    u64   .d 
    param    u64   .pdupl 
;------------------------
    load     u64   .pdupl 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpeq   i64   #4782 
    load     u64   .pdupl 
    setret   u64   
    jump           #4780 
#4782:
#4781:
    load     u64   .pdupl 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .pdupl 
    jump           #4784 
#4783:
    load     u64   .pdupl 
    loadimm  i64   8 
    iloadx   u64   1 0
    load     u64   .d 
    jumpne   u64   #4787 
    load     u64   .pdupl 
    setret   u64   
    jump           #4780 
#4787:
#4786:
    load     u64   .pdupl 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .pdupl 
#4784:
    load     u64   .pdupl 
    jumpt    u64   #4783 
#4785:
    loadimm  u64   0 
    setret   u64   
    jump           #4780 
;------------------------
#4780:
    return         
end

proc mm_name.finddupl_sub
    rettype  u64   
    param    u64   .d 
    param    u64   .pdupl 
    local    i64   .subprogno 
;------------------------
    load     u64   .pdupl 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpeq   i64   #4790 
    load     u64   .pdupl 
    setret   u64   
    jump           #4788 
#4790:
#4789:
    load     u64   .pdupl 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .pdupl 
    load     u64   .d 
    loadimm  i64   87 
    iloadx   u8    1 0
    store    i64   .subprogno 
    jump           #4792 
#4791:
    load     u64   .pdupl 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadimm  i64   87 
    iloadx   u8    1 0
    load     i64   .subprogno 
    jumpne   i64   #4795 
    load     u64   .pdupl 
    setret   u64   
    jump           #4788 
#4795:
#4794:
    load     u64   .pdupl 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .pdupl 
#4792:
    load     u64   .pdupl 
    jumpt    u64   #4791 
#4793:
    loadimm  u64   0 
    setret   u64   
    jump           #4788 
;------------------------
#4788:
    return         
end

proc mm_name.resolvedot
    param    u64   .owner 
    param    u64   .p 
    local    u64   .lhs 
    local    u64   .rhs 
    local    u64   .d 
    local    u64   .e 
    local    u64   .t 
    local    u64   .f 
    local    u64   .g 
    local    i64   .m 
    local    i64   .moduleno 
    local    i64   .subprogno 
    local    i64   .oldallowmod 
;------------------------
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u8    1 0
    store    i64   .moduleno 
    load     u64   .p 
    loadimm  i64   57 
    iloadx   u8    1 0
    store    i64   .subprogno 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .lhs 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .rhs 
    load     u64   .rhs 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    load     i64   mm_name.allowmodname 
    store    i64   .oldallowmod 
    load     u64   .lhs 
    iload    u8    
    loadimm  i64   3 
    eq       i64   
    store    i64   mm_name.allowmodname 
    setcall        2
    load     u64   .lhs 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    load     i64   .oldallowmod 
    store    i64   mm_name.allowmodname 
    load     u64   .lhs 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #4798 
    jump           #4799 
#4798:
    load     u64   .lhs 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpeq   i64   #4801 1
    loadimm  i64   5 
    jumpeq   i64   #4801 1
    loadimm  i64   6 
    jumpeq   i64   #4801 1
    loadimm  i64   5 
    jumpeq   i64   #4801 1
    loadimm  i64   12 
    jumpeq   i64   #4802 1
    loadimm  i64   11 
    jumpeq   i64   #4802 1
    loadimm  i64   13 
    jumpeq   i64   #4802 1
    loadimm  i64   2 
    jumpeq   i64   #4803 
    jump           #4804 
#4801:
    setcall        2
    load     u64   .e 
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_name.finddupl 2 0
    store    u64   .e 
    load     u64   .e 
    jumpf    u64   #4806 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpne   i64   #4808 
    load     u64   .e 
    loadimm  i64   87 
    iloadx   u8    1 0
    load     i64   .subprogno 
    jumpeq   i64   #4810 
    load     u64   .e 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpge   i64   #4812 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .e 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Need export to import '#'"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4812:
#4811:
    jump           #4809 
#4810:
    load     u64   .e 
    loadimm  i64   86 
    iloadx   u8    1 0
    load     i64   .moduleno 
    jumpeq   i64   #4814 
    load     u64   .e 
    loadimm  i64   191 
    iloadx   u8    1 0
    jumpt    i64   #4816 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .e 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Need global to import '#'"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4816:
#4815:
#4814:
#4809:
#4808:
#4807:
;domodule::
#4818:
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  u64   0 
    double         
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .e 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   16 
    jumpeq   i64   #4820 1
    loadimm  i64   10 
    jumpeq   i64   #4821 
    jump           #4822 
#4820:
    jump           #4819 
#4821:
    jump           #4819 
#4822:
#4819:
    jump           #4805 
#4806:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Can't resolve .#"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4805:
    jump           #4800 
#4802:
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    store    i64   .m 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpeq   i64   #4825 1
    loadimm  i64   7 
    jumpeq   i64   #4826 
    jump           #4827 
#4825:
    jump           #4824 
#4826:
#4828:
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .m 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpeq   i64   #4831 1
    loadimm  i64   7 
    jumpeq   i64   #4832 
    jump           #4833 
#4831:
    jump           #4829 
    jump           #4830 
#4832:
    jump           #4830 
#4833:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "2:Record expected"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
#4830:
    jump           #4828 
#4829:
    jump           #4824 
#4827:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Record expected"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
#4824:
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    store    u64   .t 
    setcall        2
    load     u64   .e 
    setarg   u64   2
    load     u64   .t 
    setarg   u64   1
    callf    u64   mm_name.finddupl 2 0
    store    u64   .e 
    load     u64   .e 
    jumpf    u64   #4837 
    load     u64   .e 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    istorex  u64   1 0
    jump           #4836 
#4837:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .rhs 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Not a field: #"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4836:
    jump           #4800 
#4803:
    setcall        2
    load     u64   .e 
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_name.finddupl_sub 2 0
    store    u64   .e 
    load     u64   .e 
    jumpf    u64   #4840 
    load     u64   .e 
    loadimm  i64   87 
    iloadx   u8    1 0
    load     i64   .subprogno 
    jumpeq   i64   #4842 
    load     u64   .e 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpge   i64   #4844 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .e 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Need export to import '#'"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4844:
#4843:
#4842:
#4841:
    jump           #4818 
    jump           #4839 
#4840:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Can't resolve sub.#"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4839:
    jump           #4800 
#4804:
#4800:
    jump           #4797 
#4799:
    load     u64   .e 
    loadimm  i64   40 
    iloadx   u64   1 0
    jumpt    u64   #4848 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .e 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Not a field: #"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4848:
#4847:
#4797:
;------------------------
#4796:
    return         
end

proc mm_name.fixmode
    param    u64   .p 
    local    u64   .pmode 
    local    u64   .a 
    local    u64   .d 
    local    u64   .e 
    local    u64   .f 
    local    u64   .owner 
    local    i64   .m 
    local    i64   .moduleno 
;------------------------
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .pmode 
    load     u64   .pmode 
    iload    i32   
    neg      i64   
    store    i64   .m 
    load     u64   .p 
    iload    u64   
    double         
    store    u64   .owner 
    store    u64   .d 
    jump           #4852 
#4851:
    load     u64   .d 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .d 
#4852:
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpne   i64   #4851 
#4853:
    load     u64   .d 
    loadimm  i64   86 
    iloadx   u8    1 0
    store    i64   .moduleno 
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .a 
    loadimm  u64   0 
    jumpne   u64   #4855 
    load     u64   .d 
    jumpf    u64   #4855 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     i64   .moduleno 
    setarg   i64   3
    load     u64   .d 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_name.resolvetopname 4 0
    store    u64   .e 
    jump           #4854 
#4855:
    load     u64   .d 
    loadimm  u64   0 
    jumpne   u64   #4856 
    load     u64   .a 
    jumpf    u64   #4856 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Fixmode can't do typeof yet"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
    jump           #4854 
#4856:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     i64   .moduleno 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_name.resolvetopname 4 0
    store    u64   .e 
    load     u64   .e 
    jumpf    u64   #4859 
    load     u64   .e 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .f 
    loadimm  u64   0 
    store    u64   .e 
    jump           #4861 
#4860:
    load     u64   .f 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   5 
    jumpne   i64   #4864 
    load     u64   .f 
    loadimm  i64   48 
    iloadx   u64   1 0
    load     u64   .d 
    jumpne   u64   #4864 
    load     u64   .f 
    store    u64   .e 
    jump           #4862 
#4864:
#4863:
    load     u64   .f 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .f 
#4861:
    load     u64   .f 
    jumpt    u64   #4860 
#4862:
#4859:
#4858:
#4854:
    load     u64   .e 
    jumpf    u64   #4866 
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   5 
    jumpne   i64   #4866 
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .pmode 
    istore   i32   
    jump           #4865 
#4866:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .d 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "2:Can't resolve tentative type: #"
    setarg   u64   1
    callp          mm_support.rxerror_s 3 0
#4865:
;------------------------
#4850:
    return         
end

proc mm_name.fixusertypes
    local    u64   .p 
    local    i64   .npasses 
    local    i64   .notresolved 
    local    i64   .m 
    local    i64   .zerosizes 
    local    u64   .d 
    local    i64   .i 
;------------------------
    loadimm  i64   0 
    store    i64   .npasses 
#4869:
    loadref  u64   .npasses 
    incrto   i64   1
    loadimm  i64   0 
    store    i64   .notresolved 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.ntypenames 
    loadimm  i64   1 
    jumplt   i64   #4874 
#4872:
    loadref  u64   mm_decls.typenames 
    load     i64   .i 
    addptrx  u8:32 32 0
    store    u64   .p 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    iload    i32   
    loadimm  i64   0 
    jumpge   i64   #4876 
    loadref  u64   mm_decls.typenamepos 
    load     i64   .i 
    addptrx  u32   4 0
    iload    u32   
    store    i64   mm_tables.mlineno 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.fixmode 1 0
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    iload    i32   
    loadimm  i64   0 
    jumpge   i64   #4878 
    loadref  u64   .notresolved 
    incrto   i64   1
#4878:
#4877:
#4876:
#4875:
#4873:
    forup          #4872 1
    opnd           .i 
    opnd           mm_decls.ntypenames 
#4874:
    load     i64   .npasses 
    loadimm  i64   5 
    jumple   i64   #4880 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Type phase errors - check these user types:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.ntypenames 
    loadimm  i64   1 
    jumplt   i64   #4884 
#4882:
    loadref  u64   mm_decls.typenames 
    load     i64   .i 
    addptrx  u8:32 32 0
    store    u64   .p 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    iload    i32   
    loadimm  i64   0 
    jumpge   i64   #4886 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  u64   0 
    jumpne   u64   #4888 
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .d 
#4888:
#4887:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "\t"
    callp          msys.m$print_str_nf 1 0
    load     u64   .d 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#4886:
#4885:
#4883:
    forup          #4882 1
    opnd           .i 
    opnd           mm_decls.ntypenames 
#4884:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Fixtypes: too many passes (cyclic ref?)"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
#4880:
#4879:
#4870:
    load     i64   .notresolved 
    loadimm  i64   0 
    jumpne   i64   #4869 
#4871:
;------------------------
#4868:
    return         
end

proc mm_name.addframevar
    rettype  u64   
    param    u64   .owner 
    param    u64   .d 
    param    i64   .moduleno 
    param    i64   .mode 
    local    u64   .e 
;------------------------
    setcall        3
    loadimm  i64   12 
    setarg   i64   3
    load     u64   .d 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .e 
    setcall        3
    load     u64   .e 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .mode 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    setcall        2
    load     u64   .e 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    load     u64   .e 
    setret   u64   
    jump           #4891 
;------------------------
#4891:
    return         
end

proc mm_name.copylistunit
    rettype  u64   
    param    u64   .p 
    local    u64   .q 
    local    u64   .plist 
    local    u64   .plistx 
;------------------------
    loadimm  u64   0 
    double         
    store    u64   .plistx 
    store    u64   .plist 
    jump           #4894 
#4893:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_name.copyunit 1 0
    store    u64   .q 
    setcall        3
    load     u64   .q 
    setarg   u64   3
    loadref  u64   .plistx 
    setarg   u64   2
    loadref  u64   .plist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .p 
#4894:
    load     u64   .p 
    jumpt    u64   #4893 
#4895:
    load     u64   .plist 
    setret   u64   
    jump           #4892 
;------------------------
#4892:
    return         
end

proc mm_name.copyunit
    rettype  u64   
    param    u64   .p 
    local    u64   .q 
    local    u64   .d 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #4898 
    loadimm  u64   0 
    setret   u64   
    jump           #4896 
#4898:
#4897:
    load     u64   .p 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #4900 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_name.nmacroparams 
    loadimm  i64   1 
    jumplt   i64   #4903 
#4901:
    loadref  u64   mm_name.macroparamsgen 
    load     i64   .i 
    iloadx   u64   8 -8
    load     u64   .d 
    jumpne   u64   #4905 
    setcall        1
    loadref  u64   mm_name.macroargs 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    u64   mm_name.copyunit 1 0
    setret   u64   
    jump           #4896 
    jump           #4903 
#4905:
#4904:
#4902:
    forup          #4901 1
    opnd           .i 
    opnd           mm_name.nmacroparams 
#4903:
#4900:
#4899:
    setcall        1
    load     u64   .p 
    iload    u8    
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .q 
    load     u64   .p 
    iload    u8:64 
    load     u64   .q 
    istore   u8:64 
    loadimm  u64   0 
    load     u64   .q 
    loadimm  i64   8 
    istorex  u64   1 0
    loadimm  i64   1 
    store    i64   .i 
    loadref  u64   mm_tables.jsubs 
    load     u64   .q 
    iload    u8    
    iloadx   u8    1 0
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #4908 
#4906:
    setcall        1
    load     u64   .q 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    u64   mm_name.copylistunit 1 0
    load     u64   .q 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .i 
    istorex  u64   8 -8
#4907:
    forup          #4906 1
    opnd           .i 
    opnd           .$av_1 
#4908:
    load     u64   .q 
    setret   u64   
    jump           #4896 
;------------------------
#4896:
    return         
end

proc mm_name.replaceunit
    param    u64   .p 
    param    u64   .q 
    local    u64   .pnext 
;------------------------
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pnext 
    load     u64   .q 
    iload    u8:64 
    load     u64   .p 
    istore   u8:64 
    load     u64   .pnext 
    load     u64   .p 
    loadimm  i64   8 
    istorex  u64   1 0
;------------------------
#4909:
    return         
end

proc mm_name.expandmacro
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    u64   .d 
    local    u64   .pm 
    local    u64   .pnew 
    local    i64   .ignoreargs 
;------------------------
    load     i64   mm_name.macrolevels 
    loadimm  i64   10 
    jumple   i64   #4912 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Too many macro levels (recursive macro?)"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
#4912:
#4911:
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   104 
    iloadx   u64   1 0
    store    u64   .pm 
    loadimm  i64   0 
    store    i64   mm_name.nmacroparams 
    jump           #4915 
#4914:
    load     i64   mm_name.nmacroparams 
    loadimm  i64   50 
    jumplt   i64   #4918 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "macro param overflow"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
#4918:
#4917:
    load     u64   .pm 
    loadref  u64   mm_name.macroparams 
    loadref  u64   mm_name.nmacroparams 
    incrload i64   1
    istorex  u64   8 -8
    load     u64   .pm 
    loadimm  i64   48 
    iloadx   u64   1 0
    loadref  u64   mm_name.macroparamsgen 
    load     i64   mm_name.nmacroparams 
    istorex  u64   8 -8
    load     u64   .pm 
    loadimm  i64   144 
    iloadx   u64   1 0
    store    u64   .pm 
#4915:
    load     u64   .pm 
    jumpt    u64   #4914 
#4916:
    loadimm  i64   0 
    store    i64   mm_name.nmacroargs 
    jump           #4921 
#4920:
    load     i64   mm_name.nmacroargs 
    loadimm  i64   50 
    jumplt   i64   #4924 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "macro arg overflow"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
#4924:
#4923:
    load     u64   .b 
    loadref  u64   mm_name.macroargs 
    loadref  u64   mm_name.nmacroargs 
    incrload i64   1
    istorex  u64   8 -8
    load     u64   .b 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .b 
#4921:
    load     u64   .b 
    jumpt    u64   #4920 
#4922:
    load     i64   mm_name.nmacroargs 
    load     i64   mm_name.nmacroparams 
    jumpge   i64   #4927 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "NMACROARGS="
    callp          msys.m$print_str_nf 1 0
    load     i64   mm_name.nmacroargs 
    callp          msys.m$print_i64_nf 1 0
    load     i64   mm_name.nmacroparams 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Too few macro args"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
#4927:
#4926:
    loadimm  i64   0 
    store    i64   .ignoreargs 
    load     i64   mm_name.nmacroargs 
    loadimm  i64   0 
    jumple   i64   #4931 
    load     i64   mm_name.nmacroparams 
    loadimm  i64   0 
    jumpne   i64   #4931 
    loadimm  i64   1 
    store    i64   .ignoreargs 
    loadimm  i64   0 
    double         
    store    i64   mm_name.nmacroparams 
    store    i64   mm_name.nmacroargs 
    jump           #4930 
#4931:
    load     i64   mm_name.nmacroargs 
    load     i64   mm_name.nmacroparams 
    jumple   i64   #4932 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Too many macro args"
    setarg   u64   1
    callp          mm_support.rxerror 2 0
#4932:
#4930:
    setcall        1
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_name.copyunit 1 0
    store    u64   .pnew 
    load     i64   .ignoreargs 
    jumpt    i64   #4935 
    setcall        2
    load     u64   .pnew 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_name.replaceunit 2 0
    jump           #4934 
#4935:
    load     u64   .pnew 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
#4934:
;------------------------
#4910:
    return         
end

proc mm_name.duplfield
    param    u64   .owner 
    param    u64   .p 
    param    u64   .q 
;------------------------
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #4938 
    setcall        1
    loadimm  u64   "DUPLFIELD"
    setarg   u64   1
    callp          mm_support.serror 1 0
#4938:
#4937:
    load     u64   .p 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   4 
    loadbit        
    load     u64   .q 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   4 
    storebit       
    load     u64   .p 
    loadimm  i64   84 
    iloadx   u16   1 0
    load     u64   .q 
    loadimm  i64   84 
    istorex  u16   1 0
    load     u64   .p 
    loadimm  i64   128 
    iloadx   u64   1 0
    load     u64   .q 
    loadimm  i64   128 
    istorex  u64   1 0
    setcall        3
    load     u64   .q 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     u64   .p 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
;------------------------
#4936:
    return         
end

proc mm_name.do_baseclass
    param    u64   .p 
    local    u64   .d 
    local    u64   .e 
    local    u64   .newd 
    local    u64   .dbase 
    local    i64   .normalexit 
;------------------------
    loadref  u64   mm_decls.ttnamedef 
    load     u64   .p 
    loadimm  i64   136 
    iloadx   i32   1 0
    iloadx   u64   8 0
    store    u64   .dbase 
    load     u64   .dbase 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    jump           #4942 
#4941:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    loadimm  i64   1 
    store    i64   .normalexit 
    jump           #4945 
#4944:
    setcall        2
    load     u64   .e 
    iload    u64   
    setarg   u64   2
    load     u64   .d 
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #4948 
    loadimm  i64   0 
    store    i64   .normalexit 
    jump           #4946 
#4948:
#4947:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#4945:
    load     u64   .e 
    jumpt    u64   #4944 
#4946:
    load     i64   .normalexit 
    jumpf    i64   #4950 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpeq   i64   #4952 1
    loadimm  i64   20 
    jumpeq   i64   #4952 
    jump           #4953 
#4952:
    setcall        3
    loadimm  i64   20 
    setarg   i64   3
    load     u64   .d 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .newd 
    load     u64   .d 
    load     u64   .newd 
    loadimm  i64   120 
    istorex  u64   1 0
    jump           #4951 
#4953:
    setcall        3
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    setarg   i64   3
    load     u64   .d 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .newd 
    setcall        3
    load     u64   .newd 
    setarg   u64   3
    load     u64   .d 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_name.duplfield 3 0
#4951:
    setcall        2
    load     u64   .newd 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
#4950:
#4949:
    load     u64   .d 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .d 
#4942:
    load     u64   .d 
    jumpt    u64   #4941 
#4943:
;------------------------
#4940:
    return         
end

proc mm_parse.parsemodule
    rettype  i64   
    param    i64   .n 
    local    u64   .pm 
    local    u64   .owner 
    local    u64   .p 
;------------------------
    setcall        0
    callp          mm_parse.initparser 0 0
    loadref  u64   mm_decls.moduletable 
    load     i64   .n 
    addptrx  u8:70 70 0
    store    u64   .pm 
    load     i64   .n 
    store    i64   mm_decls.currmoduleno 
    load     u64   .pm 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   mm_decls.stmodule 
    load     u64   mm_decls.stmodule 
    store    u64   mm_decls.currproc 
    loadref  u64   mm_decls.subprogtable 
    load     u64   mm_decls.stmodule 
    loadimm  i64   86 
    iloadx   u8    1 0
    addptrx  u8:42 42 0
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   mm_decls.stsubprog 
    load     u64   mm_decls.stsubprog 
    store    u64   mm_decls.currsubprog 
    setcall        1
    load     u64   .pm 
    loadimm  i64   64 
    iloadx   i16   1 0
    setarg   i64   1
    callp          mm_lex.startlex 1 0
    load     u64   mm_decls.stmodule 
    store    u64   .owner 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readmoduledefs 1 0
    load     u64   .pm 
    loadimm  i64   56 
    istorex  u64   1 0
    loadimm  i64   1 
    setret   i64   
    jump           #4954 
;------------------------
#4954:
    return         
end

proc mm_parse.readmoduledefs
    rettype  u64   
    param    u64   .owner 
    local    u64   .dimport 
    local    u64   .stimport 
    local    i64   .globalflag 
    local    i64   .i 
    local    i64   .callbackflag 
    local    u64   .ulist 
    local    u64   .ulistx 
    local    u64   .p 
    local    u64   .name 
;------------------------
    loadimm  i64   0 
    store    i64   .globalflag 
    loadimm  i64   0 
    store    i64   .callbackflag 
    loadimm  u64   0 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
#4956:
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #4959 2 156
    opnd           #4960 
#4959:
    swlabel        #4990 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4979 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4968 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4980 
    swlabel        #4960 
    swlabel        #4978 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4992 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4968 
    swlabel        #4968 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4968 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4967 
    swlabel        #4967 
    swlabel        #4960 
    swlabel        #4976 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4973 
    swlabel        #4974 
    swlabel        #4968 
    swlabel        #4970 
    swlabel        #4971 
    swlabel        #4968 
    swlabel        #4972 
    swlabel        #4968 
    swlabel        #4985 
    swlabel        #4975 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4986 
    swlabel        #4960 
    swlabel        #4981 
    swlabel        #4961 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4960 
    swlabel        #4977 
    endsw          
#4961:
    load     i64   .globalflag 
    jumpf    i64   #4963 
    setcall        1
    loadimm  u64   "global global?"
    setarg   u64   1
    callp          mm_support.serror 1 0
#4963:
#4962:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .globalflag 
    load     i64   .globalflag 
    loadimm  i64   3 
    jumpne   i64   #4966 
    load     u64   mm_decls.stmodule 
    loadimm  i64   87 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpeq   i64   #4966 
    loadimm  i64   2 
    store    i64   .globalflag 
#4966:
#4965:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #4958 
#4967:
    setcall        3
    load     i64   .callbackflag 
    setarg   i64   3
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readprocdef 3 0
    loadimm  i64   0 
    store    i64   .callbackflag 
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4968:
;dovar::
#4969:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   11 
    setarg   i64   3
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readvardef 4 0
    unload   u64   
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4970:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        4
    loadimm  i64   138 
    setarg   i64   4
    loadimm  i64   11 
    setarg   i64   3
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readvardef 4 0
    unload   u64   
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4971:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        4
    loadimm  i64   139 
    setarg   i64   4
    loadimm  i64   11 
    setarg   i64   3
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readvardef 4 0
    unload   u64   
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4972:
    setcall        1
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    jump           #4969 
    jump           #4958 
#4973:
    setcall        1
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readimportmodule 1 0
    jump           #4958 
#4974:
    setcall        2
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readtypedef 2 0
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4975:
    setcall        2
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readconstdef 2 0
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4976:
    setcall        2
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readclassdef 2 0
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4977:
    setcall        2
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readtabledef 2 0
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4978:
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_parse.adddocstring 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #4958 
#4979:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #4958 
#4980:
    jump           #4957 
    jump           #4958 
#4981:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   4 
    jumpne   i64   #4983 
    loadimm  i64   4 
    store    i64   .callbackflag 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #4982 
#4983:
    setcall        1
    loadimm  u64   "fflang?"
    setarg   u64   1
    callp          mm_support.serror 1 0
#4982:
    jump           #4958 
#4985:
    setcall        2
    load     i64   .globalflag 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readmacrodef 2 0
    loadimm  i64   0 
    store    i64   .globalflag 
    jump           #4958 
#4986:
#4987:
    setcall        0
    callp          mm_lex.lex 0 0
#4988:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpne   i64   #4987 
#4989:
    jump           #4958 
#4990:
    setcall        1
    loadimm  u64   "MODULE/DOT"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #4958 
#4992:
    setcall        0
    callf    i64   mm_parse.istypestarter 0 0
    jumpf    i64   #4994 
    jump           #4969 
#4994:
#4993:
    jump           #4995 
    jump           #4958 
#4960:
;doexec::
#4995:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#4958:
    jump           #4956 
#4957:
    load     u64   .ulist 
    setret   u64   
    jump           #4955 
;------------------------
#4955:
    return         
end

proc mm_parse.initparser
    local    u64   .tabledataname 
;------------------------
    load     u64   mm_decls.nullunit 
    jumpt    u64   #4998 
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   mm_decls.nullunit 
#4998:
#4997:
    loadimm  i64   0 
    store    i64   mm_parse.try_level 
    loadimm  u64   0 
    store    u64   mm_decls.currproc 
    loadimm  i64   0 
    store    i64   mm_parse.varattribs 
    loadimm  i64   0 
    store    i64   mm_parse.intabledata 
    loadimm  i64   0 
    store    i64   mm_parse.inreadprint 
    loadimm  i64   0 
    store    i64   mm_parse.inparamlist 
    loadimm  i64   0 
    store    i64   mm_parse.inrecordbody 
    loadimm  i64   0 
    store    i64   mm_parse.inimportmodule 
    loadimm  u64   ""
    store    u64   .tabledataname 
    loadimm  i64   0 
    store    i64   mm_parse.labelseen 
    loadimm  i64   0 
    store    i64   mm_parse.ndollar 
;------------------------
#4996:
    return         
end

proc mm_parse.skipsemi
;------------------------
    jump           #5002 
#5001:
    setcall        0
    callp          mm_lex.lex 0 0
#5002:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpeq   i64   #5001 
#5003:
;------------------------
#5000:
    return         
end

proc mm_parse.makeblock
    rettype  u64   
    param    u64   .p 
;------------------------
    load     u64   .p 
    jumpf    u64   #5006 
    load     u64   .p 
    iload    u8    
    loadimm  i64   4 
    jumpne   i64   #5006 
    load     u64   .p 
    setret   u64   
    jump           #5004 
#5006:
#5005:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   4 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setret   u64   
    jump           #5004 
;------------------------
#5004:
    return         
end

proc mm_parse.checkequals
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   48 
    jumpeq   i64   #5009 
    setcall        1
    loadimm  u64   "\"=\" expected"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5009:
#5008:
;------------------------
#5007:
    return         
end

proc mm_parse.getcurrline
    rettype  i64   
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    setret   i64   
    jump           #5011 
;------------------------
#5011:
    return         
end

proc mm_parse.checkbegin
    rettype  i64   
    param    i64   .fbrack 
    local    i64   .closesym 
;------------------------
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #5014 
    load     i64   .fbrack 
    jumpf    i64   #5014 
    loadimm  i64   14 
    store    i64   .closesym 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5013 
#5014:
    loadimm  i64   104 
    store    i64   .closesym 
#5013:
    load     i64   .closesym 
    setret   i64   
    jump           #5012 
;------------------------
#5012:
    return         
end

proc mm_parse.checkbeginend
    param    i64   .closesym 
    param    i64   .kwd 
    param    i64   .startline 
;------------------------
    setcall        0
    callp          mm_parse.skipsemi 0 0
    load     i64   .closesym 
    loadimm  i64   14 
    jumpne   i64   #5017 
    setcall        1
    load     i64   .closesym 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    jump           #5016 
#5017:
    setcall        4
    load     i64   .startline 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .kwd 
    setarg   i64   2
    load     i64   .closesym 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
#5016:
    setcall        0
    callp          mm_lex.lex 0 0
;------------------------
#5015:
    return         
end

proc mm_parse.checkend
    param    i64   .endsym 
    param    i64   .endkwd1 
    param    i64   .endkwd2 
    param    i64   .startline 
    local    u8:100 .str 
;------------------------
    load     i64   .endsym 
    loadref  u64   mm_decls.lx 
    iload    u8    
    swapopnds      
    jumpne   i64   #5020 1
    loadimm  i64   14 
    jumpne   i64   #5020 
    jump           #5018 
#5020:
#5019:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   104 
    jumpeq   i64   #5022 
    setcall        2
    loadimm  u64   "Bad 'end' "
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
;error::
#5024:
    load     i64   .startline 
    jumpf    i64   #5026 
    loadref  u64   .str 
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    callp          msys.m$print_startstr 1 0
    loadimm  u64   " (from line #)"
    callp          msys.m$print_setfmt 1 0
    load     i64   .startline 
    loadimm  i64   16777215 
    bitand   i64   
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_end 0 0
#5026:
#5025:
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callp          mm_support.serror 1 0
#5022:
#5021:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpne   i64   #5029 
    jump           #5018 
#5029:
#5028:
    load     i64   .endkwd1 
    jumpf    i64   #5032 
    load     i64   .endkwd1 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    jumpeq   i64   #5031 
#5032:
    load     i64   .endkwd2 
    jumpf    i64   #5033 
    load     i64   .endkwd2 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    jumpeq   i64   #5031 
#5033:
    setcall        2
    loadimm  u64   "Mismatched 'end'"
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #5024 
#5031:
#5030:
;------------------------
#5018:
    return         
end

proc mm_parse.readvardef
    rettype  u64   
    param    u64   .owner 
    param    i64   .scope 
    param    i64   .varid 
    param    i64   .k 
    local    u64   .ulist 
    local    u64   .ulistx 
    local    u64   .p 
    local    i64   .nvars 
    local    i64   .m 
    local    i64   .initcode 
    local    u64   .stname 
;------------------------
    loadimm  u64   0 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
    setcall        0
    callf    i64   mm_parse.istypestarter 0 0
    jumpf    i64   #5037 
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .m 
    jump           #5036 
#5037:
    load     i64   .k 
    jumpf    i64   #5038 
    loadimm  i64   22 
    store    i64   .m 
    jump           #5036 
#5038:
    setcall        1
    loadimm  u64   "Readvar?"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5036:
    loadimm  i64   0 
    store    i64   .nvars 
    jump           #5041 
#5040:
    loadref  u64   .nvars 
    incrto   i64   1
    setcall        3
    load     i64   .varid 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    load     i64   .scope 
    load     u64   .stname 
    loadimm  i64   191 
    istorex  u8    1 0
    load     i64   .k 
    loadimm  i64   139 
    eq       i64   
    load     u64   .stname 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   3 
    storebit       
    load     i64   .varid 
    loadimm  i64   8 
    jumpne   i64   #5044 
    loadimm  u64   1 
    load     u64   .stname 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   7 
    storebit       
#5044:
#5043:
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    load     i64   .varid 
    loadimm  i64   11 
    jumpne   i64   #5046 
    setcall        1
    load     u64   .stname 
    setarg   u64   1
    callp          mm_lib.addstatic 1 0
#5046:
#5045:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpne   i64   #5048 
    load     i64   .m 
    loadimm  i64   22 
    jumpeq   i64   #5050 
    setcall        1
    loadimm  u64   "Mixed var T x:T"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5050:
#5049:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .m 
#5048:
#5047:
    setcall        3
    load     u64   .stname 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpeq   i64   #5054 1
    loadimm  i64   48 
    jumpeq   i64   #5054 1
    loadimm  i64   10 
    jumpne   i64   #5053 
#5054:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   48 
    jumpeq   i64   #5056 1
    loadimm  i64   9 
    jumpeq   i64   #5057 
    jump           #5058 
#5056:
    loadimm  i64   1 
    store    i64   .initcode 
    jump           #5055 
#5057:
    loadimm  i64   2 
    store    i64   .initcode 
    jump           #5055 
#5058:
    loadimm  i64   3 
    store    i64   .initcode 
#5055:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   48 
    jumpeq   i64   #5060 
    load     i64   .varid 
    loadimm  i64   11 
    jumpne   i64   #5062 
    setcall        1
    loadimm  u64   "Non-variants can't use :="
    setarg   u64   1
    callp          mm_support.serror 1 0
    load     u64   .owner 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpne   i64   #5065 
    setcall        1
    loadimm  u64   "Can't use := for statics inside procs"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5065:
#5064:
#5062:
#5061:
    jump           #5059 
#5060:
    load     i64   .varid 
    loadimm  i64   12 
    jumpne   i64   #5068 
    setcall        1
    loadimm  u64   "Need 'static' for '='"
    setarg   u64   1
    callp          mm_support.serror 1 0
    setcall        1
    load     u64   .stname 
    setarg   u64   1
    callp          mm_lib.addstatic 1 0
#5068:
#5067:
#5059:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   164 
    jumpne   i64   #5071 
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .varid 
    loadimm  i64   12 
    jumpeq   i64   #5073 
    setcall        1
    loadimm  u64   "empty: not frame"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5073:
#5072:
    setcall        2
    setcall        1
    load     u64   .stname 
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    setarg   u64   2
    loadimm  i64   124 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    jump           #5070 
#5071:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    load     u64   .stname 
    loadimm  i64   56 
    istorex  u64   1 0
    load     i64   .initcode 
    load     u64   .stname 
    loadimm  i64   192 
    istorex  u8    1 0
    load     i64   .varid 
    loadimm  i64   12 
    jumpne   i64   #5076 
    setcall        3
    load     u64   .stname 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   3
    setcall        1
    load     u64   .stname 
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   58 
    istorex  u8    1 0
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5076:
#5075:
#5070:
    jump           #5052 
#5053:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5077 
    load     i64   .k 
    loadimm  i64   139 
    jumpne   i64   #5079 
    setcall        1
    loadimm  u64   "let@"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5079:
#5078:
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   1 
    load     u64   .stname 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   5 
    storebit       
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    load     u64   .stname 
    loadimm  i64   88 
    istorex  u64   1 0
    jump           #5052 
#5077:
    load     i64   .k 
    loadimm  i64   139 
    jumpne   i64   #5081 
    setcall        1
    loadimm  u64   "let needs :=/="
    setarg   u64   1
    callp          mm_support.serror 1 0
#5081:
#5052:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5084 
    jump           #5042 
#5084:
#5083:
    setcall        0
    callp          mm_lex.lex 0 0
#5041:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpeq   i64   #5040 
#5042:
    load     i64   .nvars 
    loadimm  i64   0 
    jumpne   i64   #5086 
    setcall        1
    loadimm  u64   "No vars declared"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5086:
#5085:
    load     u64   .ulist 
    setret   u64   
    jump           #5035 
;------------------------
#5035:
    return         
end

proc mm_parse.readconstdef
    param    u64   .owner 
    param    i64   .scope 
    local    i64   .nconsts 
    local    i64   .deft 
    local    i64   .m 
    local    u64   .stname 
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   0 
    store    i64   .nconsts 
    setcall        0
    callf    i64   mm_parse.istypestarter 0 0
    jumpf    i64   #5090 
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .deft 
    jump           #5089 
#5090:
    loadimm  i64   22 
    store    i64   .deft 
#5089:
    jump           #5092 
#5091:
    setcall        3
    loadimm  i64   10 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_parse.checkequals 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_parse.readconstexpr 1 0
    load     u64   .stname 
    loadimm  i64   56 
    istorex  u64   1 0
    load     i64   .deft 
    store    i64   .m 
    setcall        3
    load     u64   .stname 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    loadref  u64   .nconsts 
    incrto   i64   1
    load     i64   .scope 
    load     u64   .stname 
    loadimm  i64   191 
    istorex  u8    1 0
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    load     i64   .scope 
    loadimm  i64   3 
    jumpne   i64   #5095 
    load     u64   .stname 
    iload    u64   
    iload    u8    
    loadimm  u64   36 
    jumpeq   u64   #5095 
    setcall        1
    load     u64   .stname 
    setarg   u64   1
    callp          mm_lib.addexpconst 1 0
#5095:
#5094:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5097 
    jump           #5093 
#5097:
#5096:
    setcall        0
    callp          mm_lex.lex 0 0
#5092:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpeq   i64   #5091 
#5093:
    load     i64   .nconsts 
    loadimm  i64   0 
    jumpne   i64   #5099 
    setcall        1
    loadimm  u64   "No consts declared"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5099:
#5098:
;------------------------
#5088:
    return         
end

proc mm_parse.readlbrack
    rettype  u64   
    local    u64   .ulist 
    local    u64   .ulistx 
    local    u64   .p 
    local    u64   .q 
    local    u64   .r 
    local    u64   .plower 
    local    i64   .oldirp 
    local    i64   .length 
    local    i64   .usecomma 
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
    loadimm  u64   0 
    store    u64   .plower 
    loadimm  i64   0 
    store    i64   .length 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5103 
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   mm_parse.inreadprint 
    store    i64   .oldirp 
    loadimm  i64   1 
    store    i64   mm_parse.inreadprint 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .plower 
    load     i64   .oldirp 
    store    i64   mm_parse.inreadprint 
    setcall        1
    loadimm  i64   7 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5102 
#5103:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   71 
    jumpne   i64   #5104 
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   7 
    jumpne   i64   #5104 
    setcall        2
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    setarg   i64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .plower 
    loadimm  i64   1 
    load     u64   .plower 
    loadimm  i64   62 
    istorex  u8    1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5102 
#5104:
    loadref  u64   mm_tables.symboloptypes 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    loadimm  i64   1 
    jumpne   i64   #5105 
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5105 
    setcall        1
    loadimm  i64   56 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    loadref  u64   mm_tables.symbolgentoops 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5101 
    jump           #5102 
#5105:
    loadref  u64   mm_tables.symboloptypes 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    loadimm  i64   1 
    jumpne   i64   #5106 
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #5106 
    setcall        1
    loadimm  i64   56 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    loadref  u64   mm_tables.symbolgentoops 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5101 
#5106:
#5102:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #5108 
    jump           #5109 
#5108:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    load     u64   .plower 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5101 
    jump           #5107 
#5109:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
#5107:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #5111 1
    loadimm  i64   5 
    jumpeq   i64   #5112 1
    loadimm  i64   20 
    jumpeq   i64   #5113 1
    loadimm  i64   6 
    jumpeq   i64   #5114 
    jump           #5115 
#5111:
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5101 
    jump           #5110 
#5112:
    loadimm  i64   1 
    store    i64   .usecomma 
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5117 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    load     u64   .plower 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .p 
    setret   u64   
    jump           #5101 
#5117:
#5116:
;docomma::
#5118:
    loadimm  i64   1 
    store    i64   .length 
    load     u64   .p 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
    load     i64   .usecomma 
    jumpf    i64   #5120 
#5121:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5125 
    jump           #5123 
#5125:
#5124:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5127 
    setcall        1
    loadimm  u64   ",, null expr not allowed"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5127:
#5126:
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   .length 
    incrto   i64   1
    setcall        0
    callp          mm_parse.skipsemi 0 0
#5122:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5121 
#5123:
    jump           #5119 
#5120:
#5129:
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5133 
    jump           #5131 
#5133:
#5132:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5135 
    setcall        1
    loadimm  u64   ",, null expr not allowed"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5135:
#5134:
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   .length 
    incrto   i64   1
#5130:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpeq   i64   #5129 
#5131:
#5119:
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    load     u64   .ulist 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     i64   .length 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    load     u64   .plower 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .p 
    setret   u64   
    jump           #5101 
    jump           #5110 
#5113:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .q 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   20 
    jumpeq   i64   #5137 1
    loadimm  i64   14 
    jumpeq   i64   #5138 
    jump           #5139 
#5137:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .r 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        4
    load     u64   .r 
    setarg   u64   4
    load     u64   .q 
    setarg   u64   3
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    setarg   u64   2
    loadimm  i64   92 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    setret   u64   
    jump           #5101 
    jump           #5136 
#5138:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        4
    loadimm  u64   0 
    setarg   u64   4
    load     u64   .q 
    setarg   u64   3
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    setarg   u64   2
    loadimm  i64   92 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    setret   u64   
    jump           #5101 
    jump           #5136 
#5139:
#5136:
    setcall        3
    load     u64   .q 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   20 
    jumpeq   i64   #5141 
#5142:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5143:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5142 
#5144:
    setcall        1
    loadimm  i64   20 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    jump           #5140 
#5141:
    setcall        0
    callp          mm_lex.lex 0 0
#5140:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .r 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        4
    load     u64   .r 
    setarg   u64   4
    load     u64   .ulist 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   110 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    setret   u64   
    jump           #5101 
    jump           #5110 
#5114:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpne   i64   #5146 
    loadimm  i64   0 
    store    i64   .usecomma 
    jump           #5118 
#5146:
#5145:
    load     u64   .p 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
#5147:
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5151 
    jump           #5149 
#5151:
#5150:
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5148:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpeq   i64   #5147 
#5149:
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    load     u64   .ulist 
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    setret   u64   
    jump           #5101 
    jump           #5110 
#5115:
    setcall        1
    loadimm  u64   "(x ..."
    setarg   u64   1
    callp          mm_support.serror 1 0
#5110:
    loadimm  u64   0 
    setret   u64   
    jump           #5101 
;------------------------
#5101:
    return         
end

proc mm_parse.addlistparam
    param    u64   .ulist 
    param    u64   .ulistx 
    param    u64   .p 
;------------------------
    load     u64   .ulist 
    iload    u64   
    loadimm  u64   0 
    jumpne   u64   #5155 
    load     u64   .p 
    double         
    load     u64   .ulistx 
    istore   u64   
    load     u64   .ulist 
    istore   u64   
    jump           #5154 
#5155:
    load     u64   .p 
    load     u64   .ulistx 
    iload    u64   
    loadimm  i64   144 
    istorex  u64   1 0
#5154:
    load     u64   .p 
    load     u64   .ulistx 
    istore   u64   
;------------------------
#5153:
    return         
end

proc mm_parse.readcast
    rettype  u64   
    local    u64   .p 
    local    i64   .opc 
    local    i64   .t 
;------------------------
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .t 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #5158 1
    loadimm  i64   22 
    jumpeq   i64   #5159 1
    loadimm  i64   2 
    jumpeq   i64   #5160 
    jump           #5161 
#5158:
    setcall        1
    loadimm  i64   55 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    loadimm  i64   26 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    load     u64   .p 
    setret   u64   
    jump           #5156 
    jump           #5157 
#5159:
    loadimm  i64   54 
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5157 
#5160:
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   136 
    jumpne   i64   #5163 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   55 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    loadimm  i64   26 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5162 
#5163:
    setcall        1
    loadimm  i64   55 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
#5162:
    load     u64   .p 
    setret   u64   
    jump           #5156 
    jump           #5157 
#5161:
    loadimm  i64   51 
    store    i64   .opc 
#5157:
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    setcall        3
    load     u64   .p 
    loadimm  i64   52 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     u64   .p 
    setret   u64   
    jump           #5156 
;------------------------
#5156:
    return         
end

proc mm_parse.readopc
    rettype  u64   
    local    u64   .p 
    local    u64   .q 
    local    u64   .r 
    local    i64   .tag 
    local    i64   .opc 
    local    i64   .firstsym 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .firstsym 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   63 
    jumpeq   i64   #5166 1
    loadimm  i64   64 
    jumpeq   i64   #5167 
    jump           #5168 
#5166:
    loadimm  i64   37 
    store    i64   .tag 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    jump           #5165 
#5167:
    loadimm  i64   38 
    store    i64   .tag 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    jump           #5165 
#5168:
    loadimm  i64   33 
    store    i64   .tag 
    loadref  u64   mm_tables.symbolgenops 
    load     i64   .firstsym 
    iloadx   u8    1 -1
    store    i64   .opc 
#5165:
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .firstsym 
    loadimm  i64   31 
    jumpeq   i64   #5170 1
    loadimm  i64   32 
    jumpeq   i64   #5171 1
    loadimm  i64   43 
    jumpeq   i64   #5172 1
    loadimm  i64   44 
    jumpeq   i64   #5172 1
    loadimm  i64   64 
    jumpeq   i64   #5172 
    jump           #5173 
#5170:
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setret   u64   
    jump           #5164 
    jump           #5169 
#5171:
    loadimm  i64   99 
    store    i64   .opc 
    jump           #5169 
#5172:
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    store    u64   .p 
    load     u64   .p 
    iload    u8    
    loadimm  i64   16 
    jumpne   i64   #5175 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    loadimm  i64   2 
    jumpeq   i64   #5177 
    setcall        1
    loadimm  u64   "Needs (x,y)"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5177:
#5176:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
    loadimm  u64   0 
    load     u64   .q 
    loadimm  i64   8 
    istorex  u64   1 0
    setcall        3
    load     u64   .r 
    setarg   u64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   32 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    load     i64   .opc 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     u64   .p 
    setret   u64   
    jump           #5164 
    jump           #5174 
#5175:
    setcall        1
    loadimm  u64   "READOPC/SINGLE OPND?"
    setarg   u64   1
    callp          mm_support.serror 1 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setret   u64   
    jump           #5164 
#5174:
    jump           #5169 
#5173:
    loadref  u64   mm_tables.symboloptypes 
    load     i64   .firstsym 
    iloadx   u8    1 -1
    loadimm  i64   1 
    jumpne   i64   #5181 
    setcall        1
    loadimm  u64   "Can't be used as unary op"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5181:
#5180:
#5169:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #5184 
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   35 
    store    i64   .tag 
    load     i64   .firstsym 
    loadimm  i64   32 
    jumpeq   i64   #5186 
    jump           #5187 
#5186:
    loadimm  i64   120 
    store    i64   .opc 
    jump           #5185 
#5187:
    loadref  u64   mm_tables.symbolgentoops 
    load     i64   .firstsym 
    iloadx   u8    1 -1
    store    i64   .opc 
    load     i64   .opc 
    loadimm  i64   0 
    jumpne   i64   #5189 
    setcall        1
    loadimm  u64   "op:= not available"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5189:
#5188:
#5185:
#5184:
#5183:
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    double         
    store    u64   .q 
    setarg   u64   2
    load     i64   .tag 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     i64   .opc 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     u64   .q 
    iload    u8    
    loadimm  i64   16 
    jumpne   i64   #5192 
    setcall        1
    loadimm  u64   "Too many opnds"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5192:
#5191:
    load     u64   .p 
    setret   u64   
    jump           #5164 
;------------------------
#5164:
    return         
end

proc mm_parse.readsprint
    rettype  u64   
    local    i64   .oldinreadprint 
    local    i64   .opc 
    local    i64   .isfprint 
    local    u64   .pformat 
    local    u64   .pdev 
    local    u64   .printlist 
    local    u64   .printlistx 
    local    u64   .p 
;------------------------
    load     i64   mm_parse.inreadprint 
    store    i64   .oldinreadprint 
    loadimm  i64   1 
    store    i64   mm_parse.inreadprint 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .opc 
    loadimm  i64   117 
    jumpeq   i64   #5196 
    jump           #5197 
#5196:
    loadimm  i64   1 
    store    i64   .isfprint 
    jump           #5195 
#5197:
    loadimm  i64   0 
    store    i64   .isfprint 
#5195:
    loadimm  u64   0 
    double         
    store    u64   .printlistx 
    store    u64   .printlist 
    loadimm  u64   0 
    double         
    store    u64   .pdev 
    store    u64   .pformat 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5199 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pdev 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5201 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5200 
#5201:
    jump           #5202 
#5200:
#5199:
#5198:
    load     i64   .isfprint 
    jumpf    i64   #5204 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pformat 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5206 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5205 
#5206:
    jump           #5202 
#5205:
#5204:
#5203:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5208 
    jump           #5202 
#5208:
#5207:
#5209:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5212 
    setcall        3
    setcall        1
    loadimm  i64   86 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    setarg   u64   3
    loadref  u64   .printlistx 
    setarg   u64   2
    loadref  u64   .printlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    jump           #5211 
#5212:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpne   i64   #5214 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   85 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
#5214:
#5213:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .printlistx 
    setarg   u64   2
    loadref  u64   .printlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5211:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5216 
    jump           #5210 
#5216:
#5215:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5209 
#5210:
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
;finish::
#5202:
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .oldinreadprint 
    store    i64   mm_parse.inreadprint 
    load     i64   .opc 
    loadimm  i64   112 
    jumpeq   i64   #5219 
    load     i64   .opc 
    loadimm  i64   114 
    jumpne   i64   #5218 
#5219:
    load     u64   .printlist 
    loadimm  u64   0 
    jumpne   u64   #5218 
    setcall        1
    loadimm  u64   "No print items"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5218:
#5217:
    startmx        
    load     i64   .isfprint 
    jumpf    i64   #5222 
    load     u64   .pformat 
    iload    u8    
    loadimm  i64   2 
    jumpne   i64   #5224 
    setcall        1
    loadimm  u64   "No fmt str"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5224:
#5223:
    setcall        4
    load     u64   .printlist 
    setarg   u64   4
    load     u64   .pformat 
    setarg   u64   3
    load     u64   .pdev 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    resetmx        
    jump           #5221 
#5222:
    setcall        3
    load     u64   .printlist 
    setarg   u64   3
    load     u64   .pdev 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    endmx          
#5221:
    setret   u64   
    jump           #5194 
;------------------------
#5194:
    return         
end

proc mm_parse.readsread
    rettype  u64   
    local    i64   .oldinreadprint 
    local    i64   .opc 
    local    u64   .pformat 
    local    u64   .pdev 
    local    u64   .p 
    local    u64   .readlist 
    local    u64   .readlistx 
;------------------------
    load     i64   mm_parse.inreadprint 
    store    i64   .oldinreadprint 
    loadimm  i64   1 
    store    i64   mm_parse.inreadprint 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    double         
    store    u64   .readlistx 
    store    u64   .readlist 
    loadimm  u64   0 
    double         
    store    u64   .pdev 
    store    u64   .pformat 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5228 
    load     i64   .opc 
    loadimm  i64   118 
    jumpne   i64   #5230 
    setcall        1
    loadimm  u64   "@ on read"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5230:
#5229:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pdev 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5233 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5232 
#5233:
    jump           #5234 
#5232:
#5228:
#5227:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5236 
    jump           #5234 
#5236:
#5235:
#5237:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpne   i64   #5240 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   85 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
#5240:
#5239:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .readlistx 
    setarg   u64   2
    loadref  u64   .readlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5242 
    jump           #5238 
#5242:
#5241:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5237 
#5238:
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
;finish::
#5234:
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .oldinreadprint 
    store    i64   mm_parse.inreadprint 
    load     i64   .opc 
    loadimm  i64   118 
    jumpne   i64   #5244 
    load     u64   .readlist 
    loadimm  u64   0 
    jumpne   u64   #5244 
    setcall        1
    loadimm  u64   "No read items"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5244:
#5243:
    setcall        3
    load     u64   .readlist 
    setarg   u64   3
    load     u64   .pdev 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    setret   u64   
    jump           #5226 
;------------------------
#5226:
    return         
end

proc mm_parse.readcompilervar
    rettype  u64   
    local    u8:100 .str 
    local    u8:16 .tm 
    local    u64   .p 
    local    u64   .currmodule 
    local    i64   .code 
;------------------------
    loadref  u64   mm_decls.moduletable 
    load     i64   mm_decls.currmoduleno 
    addptrx  u8:70 70 0
    store    u64   .currmodule 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    switch         #5248 65 83
    opnd           #5249 
#5248:
    swlabel        #5253 
    swlabel        #5254 
    swlabel        #5255 
    swlabel        #5256 
    swlabel        #5257 
    swlabel        #5258 
    swlabel        #5261 
    swlabel        #5270 
    swlabel        #5264 
    swlabel        #5265 
    swlabel        #5266 
    swlabel        #5268 
    swlabel        #5269 
    swlabel        #5250 
    swlabel        #5251 
    swlabel        #5252 
    swlabel        #5272 
    swlabel        #5272 
    swlabel        #5273 
    endsw          
#5250:
    setcall        2
    loadimm  i64   7 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5246 
    jump           #5247 
#5251:
    setcall        2
    loadimm  i64   5 
    setarg   i64   2
    loadimm  r64   3.14159265358979310000 
    typepun  u64 r64 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5246 
    jump           #5247 
#5252:
    setcall        2
    loadimm  i64   5 
    setarg   i64   2
    loadimm  r64   9218868437227405312 
    typepun  u64 r64 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5246 
    jump           #5247 
#5253:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    setarg   u64   1
    callf    u64   mm_support.getlineno 1 0
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5246 
    jump           #5247 
#5254:
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    setarg   i64   1
    callp          msys.getstrint 2 0
    jump           #5247 
#5255:
    setcall        2
    load     u64   mm_decls.stmodule 
    iload    u64   
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #5247 
#5256:
    setcall        2
    loadref  u64   mm_decls.sourcefilepaths 
    load     u64   .currmodule 
    loadimm  i64   64 
    iloadx   i16   1 0
    iloadx   u64   8 0
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #5247 
#5257:
    setcall        2
    load     u64   mm_decls.currproc 
    iload    u64   
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #5247 
#5258:
    setcall        1
    loadref  u64   .tm 
    setarg   u64   1
    callp          mwindows.os_getsystime 1 0
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "#-#-#"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   .tm 
    loadimm  i64   6 
    iloadx   u16   1 0
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_parse.readcompilervar.monthnames 
    loadref  u64   .tm 
    loadimm  i64   2 
    iloadx   u16   1 0
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "4"
    loadref  u64   .tm 
    iload    u16   
    callp          msys.m$print_i64 2 0
    callp          msys.m$print_end 0 0
    jump           #5247 
#5261:
    setcall        1
    loadref  u64   .tm 
    setarg   u64   1
    callp          mwindows.os_getsystime 1 0
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "#:#:#"
    callp          msys.m$print_setfmt 1 0
    loadimm  u64   "z2"
    loadref  u64   .tm 
    loadimm  i64   8 
    iloadx   u16   1 0
    callp          msys.m$print_i64 2 0
    loadimm  u64   "z2"
    loadref  u64   .tm 
    loadimm  i64   10 
    iloadx   u16   1 0
    callp          msys.m$print_i64 2 0
    loadimm  u64   "z2"
    loadref  u64   .tm 
    loadimm  i64   12 
    iloadx   u16   1 0
    callp          msys.m$print_i64 2 0
    callp          msys.m$print_end 0 0
    jump           #5247 
#5264:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   mm_decls.targetbits 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setret   u64   
    jump           #5246 
    jump           #5247 
#5265:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   mm_decls.targetsize 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setret   u64   
    jump           #5246 
    jump           #5247 
#5266:
    setcall        2
    loadimm  u64   "wx64"
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #5247 
#5268:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     u8    mm_decls.fwindows 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5246 
    jump           #5247 
#5269:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     u8    mm_decls.flinux 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5246 
    jump           #5247 
#5270:
    setcall        2
    loadimm  u64   "Compiler:BX Experimental"
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #5247 
#5272:
    setcall        2
    loadimm  i64   6 
    setarg   i64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   81 
    eq       i64   
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5246 
    jump           #5247 
#5273:
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   1 
    store    i64   .code 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   71 
    jumpne   i64   #5275 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   i64   1 0
    store    i64   .code 
    setcall        0
    callp          mm_lex.lex 0 0
#5275:
#5274:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "CODE="
    callp          msys.m$print_str_nf 1 0
    load     i64   .code 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .code 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setarg   u64   2
    loadimm  i64   11 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setret   u64   
    jump           #5246 
    jump           #5247 
#5249:
    setcall        2
    loadref  u64   mm_tables.jtagnames 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    iloadx   u64   8 0
    setarg   u64   2
    loadimm  u64   "compiler var not impl: #"
    setarg   u64   1
    callp          mm_support.serror_s 2 0
#5247:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  i64   -1 
    setarg   i64   2
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    setarg   u64   1
    callf    u64   mm_lib.createstringconstunit 2 0
    setret   u64   
    jump           #5246 
;------------------------
#5246:
    return         
end

proc mm_parse.readcastx
    rettype  u64   
    local    i64   .opc 
    local    i64   .m 
    local    u64   .p 
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   51 
    store    i64   .opc 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5280 
    loadimm  i64   54 
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
#5280:
#5279:
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   0 
    store    i64   .m 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5282 
    load     i64   .opc 
    loadimm  i64   54 
    jumpne   i64   #5284 
    setcall        1
    loadimm  u64   "@ type missing"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5284:
#5283:
    loadimm  i64   53 
    store    i64   .opc 
    jump           #5281 
#5282:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .m 
#5281:
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    setcall        3
    load     u64   .p 
    loadimm  i64   52 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     u64   .p 
    setret   u64   
    jump           #5278 
;------------------------
#5278:
    return         
end

proc mm_parse.checksymbol
    param    i64   .symbol 
    local    u8:100 .str 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    load     i64   .symbol 
    jumpeq   i64   #5288 
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "# expected, not #"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_tables.symbolnames 
    load     i64   .symbol 
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.symbolnames 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callp          mm_support.serror 1 0
#5288:
#5287:
;------------------------
#5286:
    return         
end

proc mm_parse.lexchecksymbol
    param    i64   .symbol 
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    load     i64   .symbol 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
;------------------------
#5290:
    return         
end

proc mm_parse.readtypespec
    rettype  i64   
    param    u64   .owner 
    param    i64   .typedefx 
    local    u64   .d 
    local    u64   .e 
    local    i64   .t 
    local    i64   .kwd 
    local    i64   .fflang 
    local    i64   .sltype 
    local    i64   .w 
    local    u64   .x 
    local    u64   .pupper 
    local    u64   .plx 
    local    u64   .dim 
    local    u64   .length 
    local    u8:240 .dims 
    local    i64   .ndims 
    local    i64   .i 
    local    i64   .n 
    local    i64   .k 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   15 
    jumpeq   i64   #5293 1
    loadimm  i64   92 
    jumpeq   i64   #5294 1
    loadimm  i64   80 
    jumpeq   i64   #5295 1
    loadimm  i64   132 
    jumpeq   i64   #5296 1
    loadimm  i64   133 
    jumpeq   i64   #5296 1
    loadimm  i64   134 
    jumpeq   i64   #5297 1
    loadimm  i64   137 
    jumpeq   i64   #5298 1
    loadimm  i64   96 
    jumpeq   i64   #5299 1
    loadimm  i64   93 
    jumpeq   i64   #5300 1
    loadimm  i64   140 
    jumpeq   i64   #5301 1
    loadimm  i64   141 
    jumpeq   i64   #5302 
    jump           #5303 
#5293:
;arraybounds::
#5304:
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   0 
    store    i64   .ndims 
    loadimm  i64   1 
    store    i64   mm_parse.inreadprint 
#5305:
    loadimm  u64   0 
    store    u64   .length 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #5309 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5308 
#5309:
    loadimm  u64   0 
    store    u64   .dim 
    jump           #5307 
#5308:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .dim 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #5311 1
    loadimm  i64   5 
    jumpeq   i64   #5311 1
    loadimm  i64   7 
    jumpeq   i64   #5312 
    jump           #5313 
#5311:
    jump           #5310 
#5312:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5315 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #5315 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .length 
    setcall        3
    load     u64   .length 
    setarg   u64   3
    load     u64   .dim 
    setarg   u64   2
    loadimm  i64   23 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .dim 
    jump           #5314 
#5315:
    setcall        2
    load     u64   .dim 
    setarg   u64   2
    loadimm  i64   23 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .dim 
#5314:
    jump           #5310 
#5313:
#5310:
#5307:
    load     i64   .ndims 
    loadimm  i64   30 
    jumplt   i64   #5317 
    setcall        1
    loadimm  u64   "Too many array dims"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5317:
#5316:
    load     u64   .dim 
    loadref  u64   .dims 
    loadref  u64   .ndims 
    incrload i64   1
    istorex  u64   8 -8
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5320 
    jump           #5306 
#5320:
#5319:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5305 
#5306:
    loadimm  i64   0 
    store    i64   mm_parse.inreadprint 
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .t 
    load     i64   .ndims 
    store    i64   .i 
    load     i64   .i 
    loadimm  i64   1 
    jumplt   i64   #5323 
#5321:
    setcall        4
    startmx        
    load     i64   .i 
    loadimm  i64   1 
    jumpne   i64   #5325 
    load     i64   .typedefx 
    resetmx        
    jump           #5324 
#5325:
    loadimm  i64   0 
    endmx          
#5324:
    setarg   i64   4
    loadref  u64   .dims 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.createarraymode 4 0
    store    i64   .t 
#5322:
    fordown        #5321 1
    opnd           .i 
    opnd           1 
#5323:
    load     i64   .t 
    setret   i64   
    jump           #5291 
    jump           #5292 
#5294:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .t 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5292 
#5295:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .d 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   2 
    jumpne   i64   #5327 
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .d 
    setarg   u64   1
    callf    i64   mm_lib.newtypename 2 0
    store    i64   .t 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5326 
#5327:
    setcall        2
    load     u64   .d 
    setarg   u64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.newtypename 2 0
    store    i64   .t 
#5326:
    jump           #5292 
#5296:
    setcall        1
    loadimm  u64   "Use 'record name =' syntax"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #5292 
#5297:
    setcall        1
    loadimm  u64   "Top-level union not allowed"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #5292 
#5298:
    loadimm  i64   0 
    store    i64   .fflang 
;retry::
#5330:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   111 
    jumpne   i64   #5332 
    setcall        0
    callp          mm_lex.lex 0 0
#5332:
#5331:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   129 
    jumpeq   i64   #5334 1
    loadimm  i64   130 
    jumpeq   i64   #5334 1
    loadimm  i64   149 
    jumpeq   i64   #5335 
    jump           #5336 
#5334:
    setcall        3
    load     i64   .fflang 
    setarg   i64   3
    load     i64   .typedefx 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readrefproc 3 0
    store    i64   .t 
    jump           #5333 
#5335:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .fflang 
    jump           #5330 
    jump           #5333 
#5336:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   92 
    jumpne   i64   #5338 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   13 
    jumpeq   i64   #5340 
    jump           #5341 
#5340:
    loadimm  i64   21 
    store    i64   .t 
    load     i64   .typedefx 
    jumpf    i64   #5343 
    loadimm  i64   13 
    loadref  u64   mm_decls.tttarget 
    load     i64   .typedefx 
    istorex  i32   4 0
#5343:
#5342:
    jump           #5339 
#5341:
    jump           #5344 
#5339:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5337 
#5338:
;readtarget::
#5344:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .t 
    setcall        3
    load     i64   .typedefx 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    store    i64   .t 
#5337:
#5333:
    jump           #5292 
#5299:
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   21 
    store    i64   .t 
    load     i64   .typedefx 
    jumpf    i64   #5346 
    loadimm  i64   13 
    loadref  u64   mm_decls.tttarget 
    load     i64   .typedefx 
    istorex  i32   4 0
#5346:
#5345:
    jump           #5292 
#5300:
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.newtypename 2 0
    store    i64   .t 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5292 
#5301:
    setcall        3
    load     i64   .typedefx 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readslicetype 3 0
    store    i64   .t 
    jump           #5292 
#5302:
    setcall        1
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    jump           #5304 
    jump           #5292 
#5303:
    setcall        1
    loadimm  u64   "Bad type starter"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5292:
    load     i64   .typedefx 
    jumpf    i64   #5349 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .typedefx 
    istorex  i32   4 0
#5349:
#5348:
    load     i64   .t 
    setret   i64   
    jump           #5291 
;------------------------
#5291:
    return         
end

proc mm_parse.readslicetype
    rettype  i64   
    param    u64   .owner 
    param    i64   .slicetype 
    param    i64   .typedefx 
    local    u64   .plower 
    local    i64   .t 
;------------------------
    setcall        1
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #5352 
    loadimm  i64   1 
    store    i64   mm_parse.inreadprint 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .plower 
    loadimm  i64   0 
    store    i64   mm_parse.inreadprint 
    setcall        1
    loadimm  i64   7 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    jump           #5351 
#5352:
    loadimm  u64   0 
    store    u64   .plower 
#5351:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    load     i64   .typedefx 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .t 
    setcall        5
    load     i64   .typedefx 
    setarg   i64   5
    load     u64   .plower 
    setarg   u64   4
    load     i64   .t 
    setarg   i64   3
    load     i64   .slicetype 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.createslicemode 5 0
    setret   i64   
    jump           #5350 
;------------------------
#5350:
    return         
end

proc mm_parse.readslist
    rettype  u64   
    param    i64   .iscall 
    param    i64   .donulls 
    local    u64   .ulist 
    local    u64   .ulistx 
    local    i64   .oldinparamlist 
;------------------------
    loadimm  u64   0 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5355 
    load     u64   .ulist 
    setret   u64   
    jump           #5353 
#5355:
#5354:
    load     i64   mm_parse.inparamlist 
    store    i64   .oldinparamlist 
    load     i64   .iscall 
    store    i64   mm_parse.inparamlist 
#5356:
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5359 1
    loadimm  i64   14 
    jumpeq   i64   #5360 
    jump           #5361 
#5359:
    load     i64   .donulls 
    jumpf    i64   #5363 
    setcall        3
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    jump           #5362 
#5363:
    setcall        1
    loadimm  u64   "null comma expr not allowed"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5362:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5358 
#5360:
    load     i64   .donulls 
    jumpf    i64   #5366 
    setcall        3
    load     u64   mm_decls.nullunit 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5366:
#5365:
    jump           #5357 
    jump           #5358 
#5361:
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5369 1
    loadimm  i64   6 
    jumpne   i64   #5368 
#5369:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5371 
    jump           #5357 
#5371:
#5370:
    jump           #5367 
#5368:
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #5373 
    jump           #5357 
#5373:
#5372:
    setcall        1
    loadimm  u64   "SLIST?"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5367:
#5358:
    jump           #5356 
#5357:
    load     i64   .oldinparamlist 
    store    i64   mm_parse.inparamlist 
    load     u64   .ulist 
    setret   u64   
    jump           #5353 
;------------------------
#5353:
    return         
end

proc mm_parse.readindex
    rettype  u64   
    param    u64   .p 
    param    i64   .dot 
    local    u64   .q 
    local    u64   .plower 
    local    u64   .pupper 
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .dot 
    jumpt    i64   #5377 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #5379 1
    loadimm  i64   28 
    jumpeq   i64   #5380 1
    loadimm  i64   7 
    jumpeq   i64   #5380 
    jump           #5381 
#5379:
;fullslice::
#5382:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    setarg   u64   2
    loadimm  i64   33 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .plower 
    loadimm  i64   153 
    load     u64   .plower 
    loadimm  i64   61 
    istorex  u8    1 0
    setcall        2
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    setarg   u64   2
    loadimm  i64   33 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .pupper 
    loadimm  i64   154 
    load     u64   .pupper 
    loadimm  i64   61 
    istorex  u8    1 0
    setcall        3
    setcall        3
    load     u64   .pupper 
    setarg   u64   3
    load     u64   .plower 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   44 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    load     u64   .p 
    setret   u64   
    jump           #5375 
    jump           #5378 
#5380:
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    jump           #5382 
    jump           #5378 
#5381:
#5378:
#5377:
#5376:
#5383:
    load     i64   mm_parse.ndollar 
    loadimm  i64   10 
    jumplt   i64   #5386 
    setcall        1
    loadimm  u64   "Too many nested a[$]"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5386:
#5385:
    load     u64   .p 
    loadref  u64   mm_parse.dollarstack 
    loadref  u64   mm_parse.ndollar 
    incrload i64   1
    istorex  u64   8 -8
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .q 
    loadref  u64   mm_parse.ndollar 
    decrto   i64   1
    load     u64   .q 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #5389 
    setcall        3
    load     u64   .q 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    startmx        
    load     i64   .dot 
    jumpf    i64   #5391 
    loadimm  i64   47 
    resetmx        
    jump           #5390 
#5391:
    loadimm  i64   44 
    endmx          
#5390:
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    jump           #5388 
#5389:
    setcall        3
    load     u64   .q 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    startmx        
    load     i64   .dot 
    jumpf    i64   #5393 
    loadimm  i64   46 
    resetmx        
    jump           #5392 
#5393:
    loadimm  i64   43 
    endmx          
#5392:
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
#5388:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5395 
    jump           #5384 
#5395:
#5394:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5383 
#5384:
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    setret   u64   
    jump           #5375 
;------------------------
#5375:
    return         
end

proc mm_parse.readdotsuffix
    rettype  u64   
    param    u64   .p 
    local    u64   .q 
    local    i64   .t 
;------------------------
    jump           #5398 
#5397:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #5401 15 136
    opnd           #5402 
#5401:
    swlabel        #5403 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5413 
    swlabel        #5412 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5405 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5407 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5404 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5414 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5402 
    swlabel        #5408 
    endsw          
#5403:
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.readindex 2 0
    store    u64   .p 
    jump           #5400 
#5404:
    setcall        3
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   45 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5400 
#5405:
;doprop::
#5406:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   33 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5400 
#5407:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   62 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  i16   1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5400 
#5408:
    load     u64   .p 
    iload    u8    
    loadimm  i64   55 
    jumpeq   i64   #5410 
    jump           #5411 
#5410:
    jump           #5409 
#5411:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   60 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
#5409:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5400 
#5412:
    loadimm  i64   157 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #5406 
    jump           #5400 
#5413:
    loadimm  i64   156 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    istorex  u8    1 0
    jump           #5406 
    jump           #5400 
#5414:
    load     u64   .p 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #5416 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   9 
    jumpne   i64   #5416 
    setcall        3
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   33 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setarg   u64   3
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   33 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .q 
    loadimm  i64   156 
    load     u64   .q 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   61 
    istorex  u8    1 0
    loadimm  i64   157 
    load     u64   .q 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #5415 
#5416:
    jump           #5417 
    unload   u64   
#5415:
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .q 
    store    u64   .p 
    jump           #5400 
#5402:
;error::
#5417:
    setcall        1
    loadimm  u64   "Unknown dot suffix"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5400:
#5398:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   2 
    jumpeq   i64   #5397 
#5399:
    load     u64   .p 
    setret   u64   
    jump           #5396 
;------------------------
#5396:
    return         
end

proc mm_parse.readconstexpr
    rettype  u64   
    param    i64   .needconst 
;------------------------
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setret   u64   
    jump           #5419 
;------------------------
#5419:
    return         
end

proc mm_parse.readconstint
    rettype  i64   
    local    i64   .x 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   71 
    jumpne   i64   #5422 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   i64   1 0
    store    i64   .x 
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .x 
    setret   i64   
    jump           #5420 
    jump           #5421 
#5422:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   32 
    jumpne   i64   #5423 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   71 
    jumpne   i64   #5425 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   i64   1 0
    store    i64   .x 
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .x 
    neg      i64   
    setret   i64   
    jump           #5420 
#5425:
#5424:
#5423:
#5421:
    setcall        1
    loadimm  u64   "Can't do complex expr"
    setarg   u64   1
    callp          mm_support.serror 1 0
    loadimm  i64   0 
    setret   i64   
    jump           #5420 
;------------------------
#5420:
    return         
end

proc mm_parse.readprocdef
    param    u64   .procowner 
    param    i64   .scope 
    param    i64   .fflang 
    local    i64   .kwd 
    local    i64   .startline 
    local    i64   .closesym 
    local    i64   .shortfun 
    local    u64   .stproc 
    local    u64   .q 
    local    u64   .stname 
    local    i64   .i 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .kwd 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   1 
    eq       i64   
    store    i64   .shortfun 
    loadimm  i64   0 
    store    i64   mm_parse.nforloops 
    loadimm  i64   1 
    store    i64   mm_decls.assemmode 
    setcall        3
    load     i64   .fflang 
    setarg   i64   3
    load     i64   .scope 
    setarg   i64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    u64   mm_parse.readprocdecl 3 0
    store    u64   .stproc 
    loadimm  i64   0 
    store    i64   mm_decls.assemmode 
    setcall        0
    callp          mm_parse.checkequals 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    i64   mm_parse.getcurrline 0 0
    store    i64   .startline 
    load     i64   .shortfun 
    jumpt    i64   #5429 
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    i64   mm_parse.checkbegin 1 0
    store    i64   .closesym 
#5429:
#5428:
    setcall        1
    load     u64   .stproc 
    setarg   u64   1
    callp          mm_parse.pushproc 1 0
    loadimm  i64   0 
    store    i64   mm_lib.nextavindex 
    load     u64   mm_parse.dretvar 
    jumpf    u64   #5431 
    setcall        3
    loadimm  i64   12 
    setarg   i64   3
    load     u64   mm_parse.dretvar 
    setarg   u64   2
    load     u64   .stproc 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        3
    load     u64   .stname 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     u64   .stproc 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   .stproc 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
#5431:
#5430:
    setcall        1
    load     u64   .stproc 
    setarg   u64   1
    callp          mm_lib.addtoproclist 1 0
    load     i64   .shortfun 
    jumpf    i64   #5433 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    load     u64   .stproc 
    loadimm  i64   56 
    istorex  u64   1 0
    setcall        1
    loadimm  i64   6 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5432 
#5433:
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    load     u64   .stproc 
    loadimm  i64   56 
    istorex  u64   1 0
    setcall        3
    load     i64   .startline 
    setarg   i64   3
    load     i64   .kwd 
    setarg   i64   2
    load     i64   .closesym 
    setarg   i64   1
    callp          mm_parse.checkbeginend 3 0
#5432:
    setcall        1
    load     u64   .stproc 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    load     u64   .stproc 
    loadimm  i64   56 
    istorex  u64   1 0
    load     i64   mm_decls.ndocstrings 
    jumpf    i64   #5435 
    load     u64   mm_parse.docfile 
    jumpf    u64   #5435 
    load     u64   .stproc 
    loadimm  i64   191 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumplt   i64   #5435 
    load     u64   mm_parse.docfile 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "proc"
    callp          msys.m$print_str_nf 1 0
    load     u64   .stproc 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.ndocstrings 
    loadimm  i64   1 
    jumplt   i64   #5439 
#5437:
    load     u64   mm_parse.docfile 
    callp          msys.m$print_startfile 1 0
    loadref  u64   mm_decls.docstrings 
    load     i64   .i 
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    setcall        1
    loadref  u64   mm_decls.docstrings 
    load     i64   .i 
    iloadx   u64   8 -8
    loadimm  i64   1 
    addptrx  u64   1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    setarg   i64   2
    loadref  u64   mm_decls.docstrings 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mlib.pcm_free 2 0
#5438:
    forup          #5437 1
    opnd           .i 
    opnd           mm_decls.ndocstrings 
#5439:
    load     u64   mm_parse.docfile 
    callp          msys.m$print_startfile 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   0 
    store    i64   mm_decls.ndocstrings 
#5435:
#5434:
    setcall        0
    callp          mm_parse.popproc 0 0
;------------------------
#5427:
    return         
end

proc mm_parse.readprocdecl
    rettype  u64   
    param    u64   .procowner 
    param    i64   .scope 
    param    i64   .fflang 
    local    i64   .kwd 
    local    i64   .varparams 
    local    i64   .try_level 
    local    i64   .nparams 
    local    i64   .nretvalues 
    local    i64   .isthreaded 
    local    u8:32 .retmodes 
    local    u64   .metadata 
    local    u64   .truename 
    local    u64   .pequiv 
    local    u64   .stproc 
    local    u64   .owner 
    local    u64   .paramlist 
    local    u64   .nameptr 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .kwd 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   2 
    eq       i64   
    store    i64   .isthreaded 
    loadimm  u64   0 
    store    u64   .pequiv 
    loadimm  u64   ""
    store    u64   .metadata 
    loadimm  u64   0 
    store    u64   .truename 
    loadimm  i64   0 
    store    i64   .varparams 
    loadimm  i64   0 
    store    i64   .try_level 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   76 
    jumpne   i64   #5443 
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   .truename 
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    istorex  u64   1 0
    jump           #5442 
#5443:
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
#5442:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .nameptr 
    setcall        3
    startmx        
    load     i64   mm_parse.insidedllimport 
    jumpf    i64   #5445 
    loadimm  i64   7 
    resetmx        
    jump           #5444 
#5445:
    loadimm  i64   6 
    endmx          
#5444:
    setarg   i64   3
    load     u64   .nameptr 
    setarg   u64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stproc 
    load     i64   mm_parse.insidedllimport 
    jumpf    i64   #5447 
    loadimm  i64   1 
    store    i64   .scope 
    load     i64   mm_parse.insidedllimport 
    load     u64   .stproc 
    loadimm  i64   113 
    istorex  u8    1 0
#5447:
#5446:
    load     i64   .isthreaded 
    load     u64   .stproc 
    loadimm  i64   117 
    istorex  u8    1 0
    load     u64   .truename 
    jumpf    u64   #5449 
    load     u64   .truename 
    load     u64   .stproc 
    loadimm  i64   96 
    istorex  u64   1 0
#5449:
#5448:
    setcall        2
    load     u64   .stproc 
    setarg   u64   2
    load     u64   .procowner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    load     u64   .stproc 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   7 
    jumpne   i64   #5451 
    loadimm  u64   1 
    load     u64   .stproc 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   7 
    storebit       
#5451:
#5450:
    load     u64   .stproc 
    store    u64   .owner 
    setcall        1
    load     u64   .stproc 
    setarg   u64   1
    callp          mm_parse.pushproc 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   33 
    jumpne   i64   #5453 
    loadimm  u64   1 
    load     u64   .stproc 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   6 
    storebit       
    setcall        0
    callp          mm_lex.lex 0 0
#5453:
#5452:
    loadimm  u64   0 
    store    u64   .paramlist 
    loadimm  i64   0 
    loadref  u64   .retmodes 
    loadimm  i64   1 
    istorex  i64   8 -8
    loadimm  i64   0 
    store    i64   .nparams 
    loadimm  i64   0 
    store    i64   .nretvalues 
    loadimm  i64   0 
    store    i64   .nretvalues 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #5455 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #5457 
    setcall        5
    loadref  u64   .nparams 
    setarg   u64   5
    loadref  u64   .varparams 
    setarg   u64   4
    load     i64   .fflang 
    setarg   i64   3
    load     u64   .stproc 
    setarg   u64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    u64   mm_parse.readparams 5 0
    store    u64   .paramlist 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
#5457:
#5456:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpeq   i64   #5460 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   11 
    jumpne   i64   #5459 
#5460:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadref  u64   .retmodes 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readreturntype 2 0
    store    i64   .nretvalues 
    jump           #5458 
#5459:
    loadref  u64   mm_decls.typestarterset 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #5462 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #5461 
#5462:
    setcall        2
    loadref  u64   .retmodes 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readreturntype 2 0
    store    i64   .nretvalues 
#5461:
#5458:
    jump           #5454 
#5455:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpeq   i64   #5464 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   11 
    jumpne   i64   #5463 
#5464:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadref  u64   .retmodes 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readreturntype 2 0
    store    i64   .nretvalues 
#5463:
#5454:
    loadimm  u64   0 
    store    u64   mm_parse.dretvar 
    load     i64   .nretvalues 
    loadimm  i64   1 
    jumpne   i64   #5466 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #5468 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   mm_parse.dretvar 
    setcall        0
    callp          mm_lex.lex 0 0
#5468:
#5467:
#5466:
#5465:
    load     i64   .nretvalues 
    jumpt    i64   #5470 
    load     i64   .kwd 
    loadimm  i64   130 
    jumpne   i64   #5470 
    setcall        1
    loadimm  u64   "Function needs ret type"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5470:
#5469:
    load     i64   .nretvalues 
    jumpf    i64   #5473 
    load     i64   .kwd 
    loadimm  i64   130 
    jumpeq   i64   #5473 
    setcall        1
    loadimm  u64   "Proc can't return value"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5473:
#5472:
    load     u64   .paramlist 
    load     u64   .stproc 
    loadimm  i64   104 
    istorex  u64   1 0
    load     i64   .nretvalues 
    load     u64   .stproc 
    loadimm  i64   115 
    istorex  u8    1 0
    load     i64   .nretvalues 
    loadimm  i64   0 
    jumpeq   i64   #5476 1
    loadimm  i64   1 
    jumpeq   i64   #5477 
    jump           #5478 
#5476:
    loadimm  i64   0 
    load     u64   .stproc 
    loadimm  i64   64 
    istorex  i32   1 0
    jump           #5475 
#5477:
    setcall        3
    load     u64   .stproc 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    loadref  u64   .retmodes 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    jump           #5475 
#5478:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     i64   .nretvalues 
    setarg   i64   3
    loadref  u64   .retmodes 
    setarg   u64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    i64   mm_lib.createtuplemode 4 0
    load     u64   .stproc 
    loadimm  i64   64 
    istorex  i32   1 0
#5475:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5480 
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        1
    loadimm  u64   "READPROCDEF @"
    setarg   u64   1
    callp          mm_support.serror 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   1 
    load     u64   .stproc 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   5 
    storebit       
#5480:
#5479:
    loadimm  u64   0 
    load     u64   .stproc 
    loadimm  i64   56 
    istorex  u64   1 0
    load     i64   .fflang 
    loadimm  i64   2 
    jumpeq   i64   #5483 1
    loadimm  i64   1 
    jumpeq   i64   #5483 
    jump           #5484 
#5483:
    jump           #5482 
#5484:
    load     u64   .procowner 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   3 
    jumpeq   i64   #5486 1
    loadimm  i64   4 
    jumpeq   i64   #5487 
    jump           #5488 
#5486:
    jump           #5485 
#5487:
    setcall        1
    loadimm  u64   "Need FF specifier"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #5485 
#5488:
#5485:
#5482:
    load     i64   .scope 
    load     u64   .stproc 
    loadimm  i64   191 
    istorex  u8    1 0
    load     i64   .varparams 
    load     u64   .stproc 
    loadimm  i64   116 
    istorex  u8    1 0
    load     i64   .fflang 
    load     u64   .stproc 
    loadimm  i64   114 
    istorex  u8    1 0
    load     u64   .procowner 
    load     u64   mm_decls.stmodule 
    jumpne   u64   #5491 
    load     u64   .stproc 
    loadimm  i64   68 
    iloadx   u8    1 0
    loadimm  i64   5 
    jumpne   i64   #5493 
    setcall        2
    loadimm  u64   "start"
    setarg   u64   2
    load     u64   .stproc 
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #5493 
    load     u64   .stproc 
    loadref  u64   mm_decls.moduletable 
    load     u64   mm_decls.stmodule 
    loadimm  i64   86 
    iloadx   u8    1 0
    addptrx  u8:70 70 0
    loadimm  i64   32 
    istorex  u64   1 0
    loadimm  i64   1 
    load     u64   .stproc 
    loadimm  i64   191 
    istorex  u8    1 0
    jump           #5492 
#5493:
    load     u64   .stproc 
    loadimm  i64   68 
    iloadx   u8    1 0
    loadimm  i64   4 
    jumpne   i64   #5495 
    setcall        2
    loadimm  u64   "main"
    setarg   u64   2
    load     u64   .stproc 
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #5495 
    load     u64   mm_decls.stmodule 
    loadimm  i64   86 
    iloadx   u8    1 0
    load     i64   mm_decls.mainmoduleno 
    jumpne   i64   #5495 
    load     u64   .stproc 
    loadref  u64   mm_decls.moduletable 
    load     u64   mm_decls.stmodule 
    loadimm  i64   86 
    iloadx   u8    1 0
    addptrx  u8:70 70 0
    loadimm  i64   40 
    istorex  u64   1 0
    loadimm  i64   3 
    load     u64   .stproc 
    loadimm  i64   191 
    istorex  u8    1 0
#5495:
#5492:
#5491:
#5490:
    setcall        0
    callp          mm_parse.popproc 0 0
    load     u64   .stproc 
    setret   u64   
    jump           #5440 
;------------------------
#5440:
    return         
end

proc mm_parse.readparams
    rettype  u64   
    param    u64   .procowner 
    param    u64   .owner 
    param    i64   .fflang 
    param    u64   .varparams 
    param    u64   .nparams 
    local    u64   .stlist 
    local    u64   .stlistx 
    local    u64   .stname 
    local    i64   .parammode 
    local    i64   .pmode 
    local    i64   .m 
    local    i64   .isoptional 
    local    i64   .types 
    local    u8:32 .str 
;------------------------
    loadimm  u64   0 
    double         
    store    u64   .stlistx 
    store    u64   .stlist 
    loadimm  i64   0 
    store    i64   .pmode 
    loadimm  i64   0 
    load     u64   .nparams 
    istore   i64   
    loadimm  i64   0 
    store    i64   .parammode 
    loadimm  i64   0 
    store    i64   .types 
    load     i64   .fflang 
    loadimm  i64   0 
    jumpne   i64   #5499 
    loadimm  i64   3 
    store    i64   .fflang 
#5499:
#5498:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #5501 
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5502 1
    loadimm  i64   14 
    jumpne   i64   #5501 
#5502:
    loadimm  i64   1 
    store    i64   .types 
#5501:
#5500:
#5503:
    loadimm  i64   0 
    store    i64   .parammode 
    loadimm  i64   0 
    store    i64   .isoptional 
    load     i64   .types 
    jumpt    i64   #5507 
    setcall        0
    callf    i64   mm_parse.istypestarter 0 0
    jumpf    i64   #5506 
#5507:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .pmode 
;gotmode::
#5508:
    load     u64   .nparams 
    iload    i64   
    loadimm  i64   0 
    jumpne   i64   #5510 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5511 1
    loadimm  i64   14 
    jumpne   i64   #5510 
#5511:
#5512:
    load     u64   .nparams 
    incrto   i64   1
    loadimm  u64   36 
    loadref  u64   .str 
    loadimm  i64   1 
    istorex  u8    1 -1
    loadimm  u64   0 
    loadref  u64   .str 
    loadimm  i64   2 
    istorex  u8    1 -1
    setcall        2
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .nparams 
    iload    i64   
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        3
    loadimm  i64   13 
    setarg   i64   3
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        3
    load     u64   .stname 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .pmode 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     i64   .parammode 
    load     u64   .stname 
    loadimm  i64   152 
    istorex  u8    1 0
    setcall        3
    load     u64   .stname 
    setarg   u64   3
    loadref  u64   .stlistx 
    setarg   u64   2
    loadref  u64   .stlist 
    setarg   u64   1
    callp          mm_parse.addlistparam 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #5515 
    jump           #5516 
#5515:
    jump           #5513 
    jump           #5514 
#5516:
#5514:
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   29 
    jumpne   i64   #5518 
    load     u64   .nparams 
    iload    i64   
    loadimm  i64   1 
    add      i64   
    load     u64   .varparams 
    istore   i64   
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5513 
#5518:
#5517:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .pmode 
    jump           #5512 
#5513:
    load     u64   .stlist 
    setret   u64   
    jump           #5497 
#5510:
#5509:
    jump           #5505 
#5506:
    load     i64   .pmode 
    loadimm  i64   0 
    jumpne   i64   #5519 
    setcall        1
    loadimm  u64   "Type expected"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5519:
#5505:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   51 
    jumpeq   i64   #5522 1
    loadimm  i64   95 
    jumpeq   i64   #5523 1
    loadimm  i64   25 
    jumpeq   i64   #5523 1
    loadimm  i64   24 
    jumpeq   i64   #5524 1
    loadimm  i64   29 
    jumpeq   i64   #5525 
    jump           #5526 
#5522:
    loadimm  i64   1 
    store    i64   .parammode 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpne   i64   #5528 
    setcall        0
    callp          mm_lex.lex 0 0
#5528:
#5527:
    jump           #5521 
#5523:
    loadimm  i64   2 
    store    i64   .parammode 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpne   i64   #5530 
    setcall        0
    callp          mm_lex.lex 0 0
#5530:
#5529:
    jump           #5521 
#5524:
    loadimm  i64   1 
    store    i64   .isoptional 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5521 
#5525:
    loadimm  i64   1 
    load     u64   .varparams 
    istore   i64   
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .stlist 
    setret   u64   
    jump           #5497 
    jump           #5521 
#5526:
#5521:
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    load     u64   .nparams 
    incrto   i64   1
    setcall        3
    loadimm  i64   13 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .parammode 
    loadimm  i64   2 
    jumpne   i64   #5532 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .pmode 
    setarg   i64   2
    load     u64   .procowner 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    store    i64   .m 
    jump           #5531 
#5532:
    load     i64   .pmode 
    store    i64   .m 
#5531:
    setcall        3
    load     u64   .stname 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     i64   .parammode 
    load     u64   .stname 
    loadimm  i64   152 
    istorex  u8    1 0
    load     i64   .isoptional 
    load     u64   .stname 
    loadimm  i64   153 
    istorex  u8    1 0
    setcall        3
    load     u64   .stname 
    setarg   u64   3
    loadref  u64   .stlistx 
    setarg   u64   2
    loadref  u64   .stlist 
    setarg   u64   1
    callp          mm_parse.addlistparam 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpeq   i64   #5534 1
    loadimm  i64   48 
    jumpeq   i64   #5534 
    jump           #5535 
#5534:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    load     u64   .stname 
    loadimm  i64   56 
    istorex  u64   1 0
    loadimm  i64   1 
    load     u64   .stname 
    loadimm  i64   192 
    istorex  u8    1 0
    loadimm  i64   1 
    load     u64   .stname 
    loadimm  i64   153 
    istorex  u8    1 0
    jump           #5533 
#5535:
#5533:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5537 1
    loadimm  i64   14 
    jumpeq   i64   #5538 
    jump           #5539 
#5537:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5536 
#5538:
    jump           #5504 
    jump           #5536 
#5539:
    setcall        1
    loadimm  u64   "nameparams1"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5536:
    jump           #5503 
#5504:
    load     u64   .stlist 
    setret   u64   
    jump           #5497 
;------------------------
#5497:
    return         
end

proc mm_parse.readcondsuffix
    rettype  u64   
    param    u64   .p 
    local    u64   .q 
;------------------------
    startmx        
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #5543 105 109
    opnd           #5544 
#5543:
    swlabel        #5546 
    swlabel        #5544 
    swlabel        #5544 
    swlabel        #5544 
    swlabel        #5545 
    endsw          
#5545:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   4 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setarg   u64   3
    setcall        1
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    setarg   u64   2
    loadimm  i64   92 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    resetmx        
    jump           #5542 
#5546:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        1
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    setarg   u64   2
    loadimm  i64   14 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .q 
    loadimm  i64   102 
    load     u64   .q 
    loadimm  i64   61 
    istorex  u8    1 0
    setcall        3
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   4 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setarg   u64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   92 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    resetmx        
    jump           #5542 
#5544:
    load     u64   .p 
    endmx          
#5542:
    setret   u64   
    jump           #5541 
;------------------------
#5541:
    return         
end

proc mm_parse.readif
    rettype  u64   
    local    i64   .pos1 
    local    i64   .kwd 
    local    i64   .pos2 
    local    u64   .clist 
    local    u64   .clistx 
    local    u64   .plist 
    local    u64   .plistx 
    local    u64   .pelse 
    local    u64   .p 
    local    u64   .pelsif 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos1 
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .kwd 
    loadimm  u64   0 
    double         
    store    u64   .pelse 
    double         
    store    u64   .plistx 
    double         
    store    u64   .plist 
    double         
    store    u64   .clistx 
    store    u64   .clist 
#5548:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    setarg   u64   3
    loadref  u64   .clistx 
    setarg   u64   2
    loadref  u64   .clist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    setcall        0
    callp          mm_parse.skipsemi 0 0
    setcall        1
    loadimm  i64   98 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    setarg   u64   3
    loadref  u64   .plistx 
    setarg   u64   2
    loadref  u64   .plist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    setcall        0
    callp          mm_parse.skipsemi 0 0
#5549:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   99 
    jumpeq   i64   #5548 
#5550:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   100 
    jumpeq   i64   #5552 1
    loadimm  i64   101 
    jumpeq   i64   #5553 1
    loadimm  i64   102 
    jumpeq   i64   #5553 
    jump           #5554 
#5552:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pelse 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .kwd 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5551 
#5553:
    load     i64   .kwd 
    loadref  u64   mm_decls.lx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        1
    setcall        0
    callf    u64   mm_parse.readswitchcase 0 0
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    store    u64   .pelse 
    jump           #5551 
#5554:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .kwd 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
#5551:
    setcall        4
    load     u64   .pelse 
    setarg   u64   4
    load     u64   .plist 
    setarg   u64   3
    load     u64   .clist 
    setarg   u64   2
    loadimm  i64   92 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    store    u64   .p 
    load     i64   .pos1 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5547 
;------------------------
#5547:
    return         
end

proc mm_parse.readgoto
    rettype  u64   
    param    i64   .gototag 
    local    u64   .d 
    local    u64   .p 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpne   i64   #5557 
    setcall        1
    loadimm  i64   111 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
#5557:
#5556:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    setcall        2
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   2
    load     i64   .gototag 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setarg   u64   1
    callf    u64   mm_parse.readcondsuffix 1 0
    setret   u64   
    jump           #5555 
;------------------------
#5555:
    return         
end

proc mm_parse.readunless
    rettype  u64   
    local    i64   .pos 
    local    u64   .pcond 
    local    u64   .pthen 
    local    u64   .pelse 
    local    u64   .p 
    local    u64   .q 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    store    u64   .pcond 
    setcall        1
    loadimm  i64   98 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pthen 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   100 
    jumpne   i64   #5560 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pelse 
    jump           #5559 
#5560:
    loadimm  u64   0 
    store    u64   .pelse 
#5559:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   105 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        4
    load     u64   .pelse 
    setarg   u64   4
    load     u64   .pthen 
    setarg   u64   3
    setcall        2
    load     u64   .pcond 
    setarg   u64   2
    loadimm  i64   14 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    double         
    store    u64   .q 
    setarg   u64   2
    loadimm  i64   92 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    store    u64   .p 
    loadimm  i64   102 
    load     u64   .q 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5558 
;------------------------
#5558:
    return         
end

proc mm_parse.readswitchcase
    rettype  u64   
    local    i64   .pos1 
    local    i64   .kwd 
    local    i64   .opc 
    local    i64   .pos2 
    local    i64   .rangeused 
    local    i64   .nwhen 
    local    u64   .pexpr 
    local    u64   .pwhenlist 
    local    u64   .pwhenlistx 
    local    u64   .pwhen 
    local    u64   .pwhenx 
    local    u64   .pelse 
    local    u64   .p 
    local    u64   .pthen 
    local    u64   .pwhenthen 
    local    u64   .q 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos1 
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .kwd 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   109 
    jumpne   i64   #5563 
    load     i64   .kwd 
    loadimm  i64   122 
    jumpne   i64   #5565 
    setcall        1
    loadimm  u64   "switch expr missing"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5565:
#5564:
    loadimm  u64   0 
    store    u64   .pexpr 
    jump           #5562 
#5563:
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pexpr 
#5562:
    loadimm  u64   0 
    double         
    store    u64   .pwhenlistx 
    store    u64   .pwhenlist 
    loadimm  i64   0 
    store    i64   .rangeused 
    loadimm  i64   0 
    store    i64   .nwhen 
    setcall        0
    callp          mm_parse.skipsemi 0 0
    jump           #5568 
#5567:
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos2 
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    double         
    store    u64   .pwhenx 
    store    u64   .pwhen 
#5570:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    loadref  u64   .nwhen 
    incrto   i64   1
    load     i64   .pos2 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #5573 
    loadimm  i64   1 
    store    i64   .rangeused 
#5573:
#5572:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .pwhenx 
    setarg   u64   2
    loadref  u64   .pwhen 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5575 
    jump           #5571 
#5575:
#5574:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5570 
#5571:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   11 
    jumpeq   i64   #5577 
    setcall        1
    loadimm  i64   98 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
#5577:
#5576:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pthen 
    setcall        3
    load     u64   .pthen 
    setarg   u64   3
    load     u64   .pwhen 
    setarg   u64   2
    loadimm  i64   84 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .pwhenthen 
    load     i64   .pos2 
    load     u64   .pwhenthen 
    loadimm  i64   4 
    istorex  u32   1 0
    setcall        3
    load     u64   .pwhenthen 
    setarg   u64   3
    loadref  u64   .pwhenlistx 
    setarg   u64   2
    loadref  u64   .pwhenlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5568:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   109 
    jumpeq   i64   #5567 
#5569:
    load     i64   .opc 
    loadimm  i64   107 
    jumpne   i64   #5579 
    load     i64   .rangeused 
    jumpt    i64   #5579 
    load     i64   .nwhen 
    loadimm  i64   8 
    jumpgt   i64   #5581 
#5581:
#5580:
#5579:
#5578:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   100 
    jumpeq   i64   #5583 1
    loadimm  i64   99 
    jumpeq   i64   #5584 1
    loadimm  i64   101 
    jumpeq   i64   #5585 1
    loadimm  i64   102 
    jumpeq   i64   #5585 
    jump           #5586 
#5583:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pelse 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .kwd 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5582 
#5584:
    load     i64   .kwd 
    loadref  u64   mm_decls.lx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        1
    setcall        0
    callf    u64   mm_parse.readif 0 0
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    store    u64   .pelse 
    jump           #5582 
#5585:
    load     i64   .kwd 
    loadref  u64   mm_decls.lx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        1
    setcall        0
    callf    u64   mm_parse.readswitchcase 0 0
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    store    u64   .pelse 
    jump           #5582 
#5586:
    loadimm  u64   0 
    store    u64   .pelse 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .kwd 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
#5582:
    setcall        4
    load     u64   .pelse 
    setarg   u64   4
    load     u64   .pwhenlist 
    setarg   u64   3
    load     u64   .pexpr 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    store    u64   .p 
    load     i64   .pos1 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5561 
;------------------------
#5561:
    return         
end

proc mm_parse.readstop
    rettype  u64   
    local    u64   .p 
    local    i64   .i 
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_tables.exprstarter 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    jumpf    i64   #5589 
    setcall        2
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   2
    loadimm  i64   122 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    jump           #5588 
#5589:
    setcall        1
    loadimm  i64   122 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
#5588:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.readcondsuffix 1 0
    setret   u64   
    jump           #5587 
;------------------------
#5587:
    return         
end

proc mm_parse.readreturn
    rettype  u64   
    local    u64   .p 
    local    u64   .q 
    local    u64   .r 
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_tables.exprstarter 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    jumpf    i64   #5592 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .q 
    setcall        2
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   89 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    jump           #5591 
#5592:
    setcall        1
    loadimm  i64   89 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
#5591:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.readcondsuffix 1 0
    setret   u64   
    jump           #5590 
;------------------------
#5590:
    return         
end

proc mm_parse.readdo
    rettype  u64   
    local    u64   .p 
    local    i64   .pos 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .p 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   113 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   104 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5593 
;------------------------
#5593:
    return         
end

proc mm_parse.readto
    rettype  u64   
    local    i64   .pos 
    local    i64   .id 
    local    u64   .p 
    local    u64   .pcount 
    local    u64   .pbody 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pcount 
    setcall        1
    loadimm  i64   113 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pbody 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   113 
    setarg   i64   3
    loadimm  i64   111 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   12 
    store    i64   .id 
    load     u64   mm_decls.currproc 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpeq   i64   #5596 
    loadimm  i64   11 
    store    i64   .id 
#5596:
#5595:
    setcall        4
    setcall        1
    setcall        2
    load     i64   .id 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_lib.getavname 2 0
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    setarg   u64   4
    load     u64   .pbody 
    setarg   u64   3
    load     u64   .pcount 
    setarg   u64   2
    loadimm  i64   91 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    store    u64   .p 
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5594 
;------------------------
#5594:
    return         
end

proc mm_parse.readwhile
    rettype  u64   
    local    i64   .pos 
    local    u64   .pcond 
    local    u64   .pbody 
    local    u64   .pincr 
    local    u64   .p 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    store    u64   .pcond 
    loadimm  u64   0 
    store    u64   .pincr 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5599 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pincr 
#5599:
#5598:
    setcall        1
    loadimm  i64   113 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pbody 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   120 
    jumpne   i64   #5601 
    load     u64   .pincr 
    jumpf    u64   #5603 
    setcall        1
    loadimm  u64   "Double incr"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5603:
#5602:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pincr 
#5601:
#5600:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   113 
    setarg   i64   3
    loadimm  i64   114 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        4
    load     u64   .pincr 
    setarg   u64   4
    load     u64   .pbody 
    setarg   u64   3
    load     u64   .pcond 
    setarg   u64   2
    loadimm  i64   97 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    store    u64   .p 
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5597 
;------------------------
#5597:
    return         
end

proc mm_parse.readrepeat
    rettype  u64   
    local    i64   .pos 
    local    u64   .pbody 
    local    u64   .pcond 
    local    u64   .p 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pbody 
    setcall        1
    loadimm  i64   116 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    store    u64   .pcond 
    setcall        3
    load     u64   .pcond 
    setarg   u64   3
    load     u64   .pbody 
    setarg   u64   2
    loadimm  i64   98 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5605 
;------------------------
#5605:
    return         
end

proc mm_parse.readloopcontrol
    rettype  u64   
    local    i64   .opc 
    local    u64   .p 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #5608 
    setcall        2
    loadimm  u64   "all"
    setarg   u64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #5608 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    jump           #5607 
#5608:
    loadref  u64   mm_tables.exprstarter 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    jumpf    i64   #5610 
    setcall        2
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_parse.readconstexpr 1 0
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    jump           #5607 
#5610:
    setcall        2
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadimm  u64   1 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
#5607:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.readcondsuffix 1 0
    setret   u64   
    jump           #5606 
;------------------------
#5606:
    return         
end

proc mm_parse.readprint
    rettype  u64   
    local    i64   .oldinreadprint 
    local    i64   .opc 
    local    i64   .isfprint 
    local    i64   .fshowname 
    local    i64   .length 
    local    u64   .pformat 
    local    u64   .pdev 
    local    u64   .printlist 
    local    u64   .printlistx 
    local    u64   .p 
    local    u64   .q 
    local    u64   .expr 
    local    u64   .s 
;------------------------
    load     i64   mm_parse.inreadprint 
    store    i64   .oldinreadprint 
    loadimm  i64   1 
    store    i64   mm_parse.inreadprint 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    load     i64   .opc 
    loadimm  i64   114 
    jumpeq   i64   #5613 1
    loadimm  i64   115 
    jumpeq   i64   #5613 
    jump           #5614 
#5613:
    loadimm  i64   1 
    store    i64   .isfprint 
    jump           #5612 
#5614:
    loadimm  i64   0 
    store    i64   .isfprint 
#5612:
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    double         
    store    u64   .printlistx 
    store    u64   .printlist 
    loadimm  u64   0 
    double         
    store    u64   .pdev 
    store    u64   .pformat 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5616 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pdev 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5618 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5617 
#5618:
    jump           #5619 
#5617:
#5616:
#5615:
    load     i64   .isfprint 
    jumpf    i64   #5621 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pformat 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5623 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5622 
#5623:
    jump           #5619 
#5622:
#5621:
#5620:
    loadref  u64   mm_tables.exprstarter 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    jumpt    i64   #5625 
    jump           #5619 
#5625:
#5624:
#5626:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5629 1
    loadimm  i64   154 
    jumpeq   i64   #5630 
    jump           #5631 
#5629:
    setcall        3
    setcall        1
    loadimm  i64   86 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    setarg   u64   3
    loadref  u64   .printlistx 
    setarg   u64   2
    loadref  u64   .printlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    jump           #5628 
#5630:
    setcall        3
    setcall        1
    loadimm  i64   87 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    setarg   u64   3
    loadref  u64   .printlistx 
    setarg   u64   2
    loadref  u64   .printlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5628 
#5631:
    loadimm  i64   0 
    store    i64   .fshowname 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   48 
    jumpne   i64   #5633 
    loadimm  i64   1 
    store    i64   .fshowname 
    setcall        0
    callp          mm_lex.lex 0 0
#5633:
#5632:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpne   i64   #5635 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   85 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
#5635:
#5634:
    load     i64   .fshowname 
    jumpf    i64   #5637 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_lib.strexpr 1 0
    store    u64   .expr 
    setcall        3
    loadimm  i64   -1 
    setarg   i64   3
    loadimm  u64   "="
    setarg   u64   2
    load     u64   .expr 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
    load     u64   .expr 
    iload    u64   
    store    u64   .s 
    setcall        2
    load     u64   .expr 
    loadimm  i64   8 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .expr 
    iload    u64   
    setarg   u64   1
    callp          mlib.iconvucn 2 0
    setcall        3
    setcall        2
    load     u64   .expr 
    loadimm  i64   8 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   mm_lib.createstringconstunit 2 0
    double         
    store    u64   .q 
    setarg   u64   3
    loadref  u64   .printlistx 
    setarg   u64   2
    loadref  u64   .printlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5637:
#5636:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .printlistx 
    setarg   u64   2
    loadref  u64   .printlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5628:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5640 
    jump           #5627 
#5640:
#5639:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5626 
#5627:
;finish::
#5619:
    load     i64   .oldinreadprint 
    store    i64   mm_parse.inreadprint 
    load     i64   .opc 
    loadimm  i64   112 
    jumpne   i64   #5642 
    load     u64   .printlist 
    loadimm  u64   0 
    jumpne   u64   #5642 
    setcall        1
    loadimm  u64   "No print items"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5642:
#5641:
    load     i64   .opc 
    loadimm  i64   114 
    jumpne   i64   #5645 
    load     u64   .printlist 
    loadimm  u64   0 
    jumpne   u64   #5645 
    load     u64   .pformat 
    loadimm  u64   0 
    jumpne   u64   #5645 
    setcall        1
    loadimm  u64   "No print items"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5645:
#5644:
    startmx        
    load     i64   .isfprint 
    jumpf    i64   #5647 
    load     u64   .pformat 
    loadimm  u64   0 
    jumpne   u64   #5649 
    setcall        1
    loadimm  u64   "No fmt str"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5649:
#5648:
    setcall        4
    load     u64   .printlist 
    setarg   u64   4
    load     u64   .pformat 
    setarg   u64   3
    load     u64   .pdev 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    resetmx        
    jump           #5646 
#5647:
    setcall        3
    load     u64   .printlist 
    setarg   u64   3
    load     u64   .pdev 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    endmx          
#5646:
    setret   u64   
    jump           #5611 
;------------------------
#5611:
    return         
end

proc mm_parse.readread
    rettype  u64   
    local    i64   .oldinreadprint 
    local    i64   .opc 
    local    u64   .pformat 
    local    u64   .pdev 
    local    u64   .readlist 
    local    u64   .readlistx 
    local    u64   .p 
    local    u64   .pread 
;------------------------
    load     i64   mm_parse.inreadprint 
    store    i64   .oldinreadprint 
    loadimm  i64   1 
    store    i64   mm_parse.inreadprint 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    double         
    store    u64   .readlistx 
    store    u64   .readlist 
    loadimm  u64   0 
    double         
    store    u64   .pdev 
    store    u64   .pformat 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5653 
    load     i64   .opc 
    loadimm  i64   118 
    jumpne   i64   #5655 
    setcall        1
    loadimm  u64   "@ on read"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5655:
#5654:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pdev 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5658 
    setcall        0
    callp          mm_lex.lex 0 0
#5658:
#5657:
#5653:
#5652:
    load     i64   .opc 
    loadimm  i64   119 
    jumpne   i64   #5660 
    setcall        3
    setcall        2
    load     u64   .pdev 
    setarg   u64   2
    loadimm  i64   119 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setarg   u64   3
    loadref  u64   .readlistx 
    setarg   u64   2
    loadref  u64   .readlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
#5660:
#5659:
    loadref  u64   mm_tables.exprstarter 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 -1
    jumpt    i64   #5662 
    jump           #5663 
#5662:
#5661:
#5664:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpne   i64   #5667 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pformat 
    jump           #5666 
#5667:
    loadimm  u64   0 
    store    u64   .pformat 
#5666:
    setcall        2
    load     u64   .pformat 
    setarg   u64   2
    loadimm  i64   118 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .pread 
    setcall        3
    load     u64   .pread 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .readlistx 
    setarg   u64   2
    loadref  u64   .readlist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5669 
    jump           #5665 
#5669:
#5668:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5664 
#5665:
;finish::
#5663:
    load     i64   .oldinreadprint 
    store    i64   mm_parse.inreadprint 
    load     i64   .opc 
    loadimm  i64   118 
    jumpne   i64   #5671 
    load     u64   .readlist 
    loadimm  u64   0 
    jumpne   u64   #5671 
    setcall        1
    loadimm  u64   "No read items"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5671:
#5670:
    startmx        
    load     u64   .readlist 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #5674 
    setcall        2
    load     u64   .readlist 
    setarg   u64   2
    loadimm  i64   4 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    resetmx        
    jump           #5673 
#5674:
    load     u64   .readlist 
    endmx          
#5673:
    setret   u64   
    jump           #5651 
;------------------------
#5651:
    return         
end

proc mm_parse.readfor
    rettype  u64   
    local    i64   .pos 
    local    i64   .opc 
    local    i64   .kwd 
    local    u64   .pindex 
    local    u64   .plocal 
    local    u64   .pfrom 
    local    u64   .pto 
    local    u64   .pstep 
    local    u64   .ptoinit 
    local    u64   .plist 
    local    u64   .passign 
    local    u64   .pcond 
    local    u64   .pbody 
    local    u64   .pelse 
    local    u64   .p 
    local    i64   .i 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    store    u64   .plocal 
    loadimm  u64   0 
    store    u64   .ptoinit 
    setcall        0
    callf    u64   mm_parse.readname 0 0
    store    u64   .pindex 
    load     i64   mm_parse.nforloops 
    loadimm  i64   10 
    jumplt   i64   #5677 
    setcall        1
    loadimm  u64   "Too many for-loops"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5677:
#5676:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_parse.nforloops 
    loadimm  i64   1 
    jumplt   i64   #5681 
#5679:
    loadref  u64   mm_parse.forindexvars 
    load     i64   .i 
    iloadx   u64   8 -8
    load     u64   .pindex 
    loadimm  i64   16 
    iloadx   u64   1 0
    jumpne   u64   #5683 
    setcall        1
    loadimm  u64   "Re-using nested loop index"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5683:
#5682:
#5680:
    forup          #5679 1
    opnd           .i 
    opnd           mm_parse.nforloops 
#5681:
    load     u64   .pindex 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadref  u64   mm_parse.forindexvars 
    loadref  u64   mm_parse.nforloops 
    incrload i64   1
    istorex  u64   8 -8
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5686 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readname 0 0
    store    u64   .plocal 
#5686:
#5685:
    loadimm  i64   93 
    store    i64   .opc 
    loadimm  u64   0 
    store    u64   .pstep 
    loadimm  u64   0 
    store    u64   .pcond 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   51 
    jumpeq   i64   #5689 1
    loadimm  i64   53 
    jumpne   i64   #5688 
#5689:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   39 
    jumpne   i64   #5691 
    loadimm  i64   94 
    store    i64   .opc 
#5691:
#5690:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .plist 
    load     u64   .plist 
    iload    u8    
    loadimm  i64   33 
    jumpne   i64   #5693 
    load     u64   .plist 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   158 
    jumpne   i64   #5693 
    setcall        1
    load     u64   .plist 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.getrangelwbunit 1 0
    store    u64   .pfrom 
    setcall        1
    load     u64   .plist 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.getrangeupbunit 1 0
    store    u64   .pto 
    jump           #5692 
#5693:
    load     u64   .plist 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #5694 
    load     u64   .plist 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .pfrom 
    load     u64   .plist 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .pto 
    jump           #5692 
#5694:
    startmx        
    load     i64   .opc 
    loadimm  i64   93 
    jumpne   i64   #5696 
    loadimm  i64   95 
    resetmx        
    jump           #5695 
#5696:
    loadimm  i64   96 
    endmx          
#5695:
    store    i64   .opc 
    setcall        1
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .plist 
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    setarg   u64   1
    callf    u64   mm_lib.getrangelwbunit 1 0
    store    u64   .pfrom 
    setcall        1
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .plist 
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    setarg   u64   1
    callf    u64   mm_lib.getrangeupbunit 1 0
    store    u64   .pto 
#5692:
    jump           #5687 
#5688:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #5698 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pfrom 
    jump           #5697 
#5698:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadimm  u64   1 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .pfrom 
#5697:
    setcall        1
    loadimm  i64   111 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    startmx        
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpne   i64   #5700 
    loadimm  i64   94 
    resetmx        
    jump           #5699 
#5700:
    loadimm  i64   93 
    endmx          
#5699:
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .pto 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   112 
    jumpne   i64   #5702 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readconstexpr 1 0
    store    u64   .pstep 
    load     u64   .pstep 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #5704 
    load     u64   .pstep 
    loadimm  i64   16 
    iloadx   i64   1 0
    loadimm  i64   1 
    jumpne   i64   #5706 
    loadimm  u64   0 
    store    u64   .pstep 
#5706:
#5705:
#5704:
#5703:
#5702:
#5701:
#5687:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   109 
    jumpne   i64   #5708 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   1
    callf    u64   mm_parse.fixcond 1 0
    store    u64   .pcond 
#5708:
#5707:
    setcall        1
    loadimm  i64   113 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pbody 
    loadimm  u64   0 
    store    u64   .pelse 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   100 
    jumpne   i64   #5710 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_parse.readsunit 1 0
    store    u64   .pelse 
#5710:
#5709:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   113 
    setarg   i64   3
    loadimm  i64   110 
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .pcond 
    loadimm  u64   0 
    jumpeq   u64   #5712 
    setcall        1
    setcall        3
    load     u64   .pbody 
    setarg   u64   3
    load     u64   .pcond 
    setarg   u64   2
    loadimm  i64   92 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    store    u64   .pbody 
#5712:
#5711:
    load     u64   .pelse 
    load     u64   .pbody 
    loadimm  i64   8 
    istorex  u64   1 0
    load     i64   .opc 
    loadimm  i64   93 
    jumpeq   i64   #5714 1
    loadimm  i64   94 
    jumpeq   i64   #5714 
    jump           #5715 
#5714:
    load     u64   .plocal 
    jumpf    u64   #5717 
    setcall        1
    loadimm  u64   "for i,x?"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5717:
#5716:
    loadimm  i64   73 
    load     u64   .pindex 
    loadimm  i64   41 
    istorex  u8    1 0
    load     u64   .pto 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #5720 1
    loadimm  i64   3 
    jumpeq   i64   #5720 
    setcall        1
    setcall        2
    loadimm  i64   12 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_lib.getavname 2 0
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    store    u64   .plocal 
    loadimm  i64   73 
    load     u64   .plocal 
    loadimm  i64   41 
    istorex  u8    1 0
    setcall        3
    load     u64   .pto 
    setarg   u64   3
    load     u64   .plocal 
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .ptoinit 
    load     u64   .ptoinit 
    load     u64   .pindex 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .plocal 
    store    u64   .pto 
#5720:
#5719:
    load     u64   .pto 
    load     u64   .pfrom 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .pstep 
    load     u64   .pto 
    loadimm  i64   8 
    istorex  u64   1 0
    setcall        4
    load     u64   .pbody 
    setarg   u64   4
    load     u64   .pfrom 
    setarg   u64   3
    load     u64   .pindex 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    store    u64   .p 
    jump           #5713 
#5715:
    load     u64   .plocal 
    loadimm  u64   0 
    jumpne   u64   #5722 
    load     u64   .pindex 
    store    u64   .plocal 
    setcall        1
    setcall        2
    loadimm  i64   12 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_lib.getavname 2 0
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    store    u64   .pindex 
#5722:
#5721:
    loadimm  i64   73 
    load     u64   .pindex 
    loadimm  i64   41 
    istorex  u8    1 0
    loadimm  i64   76 
    load     u64   .plocal 
    loadimm  i64   41 
    istorex  u8    1 0
    load     u64   .plocal 
    load     u64   .pindex 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .pfrom 
    load     u64   .plocal 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .pto 
    load     u64   .pfrom 
    loadimm  i64   8 
    istorex  u64   1 0
    setcall        3
    setcall        3
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .pindex 
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .plist 
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    setarg   u64   2
    loadimm  i64   43 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    setarg   u64   3
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .plocal 
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .passign 
    load     u64   .passign 
    load     u64   .plist 
    loadimm  i64   8 
    istorex  u64   1 0
    setcall        4
    load     u64   .pbody 
    setarg   u64   4
    load     u64   .plist 
    setarg   u64   3
    load     u64   .pindex 
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit3 4 0
    store    u64   .p 
#5713:
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    loadref  u64   mm_parse.nforloops 
    decrto   i64   1
    load     u64   .p 
    setret   u64   
    jump           #5675 
;------------------------
#5675:
    return         
end

proc mm_parse.readname
    rettype  u64   
    local    u64   .p 
;------------------------
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    store    u64   .p 
    load     u64   .p 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #5725 
    setcall        1
    loadimm  u64   "Name expected"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5725:
#5724:
    load     u64   .p 
    setret   u64   
    jump           #5723 
;------------------------
#5723:
    return         
end

proc mm_parse.readtypedef
    param    u64   .owner 
    param    i64   .scope 
    local    u64   .sttype 
    local    u64   .stname 
    local    i64   .t 
    local    i64   .m 
;------------------------
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .stname 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_parse.checkequals 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    loadimm  i64   5 
    setarg   i64   3
    load     u64   .stname 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .sttype 
    setcall        2
    load     u64   .sttype 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        1
    load     u64   .sttype 
    setarg   u64   1
    callf    i64   mm_lib.createusertype 1 0
    store    i64   .m 
    loadimm  i64   1 
    loadref  u64   mm_decls.ttusercat 
    load     i64   .m 
    istorex  u8    1 0
    setcall        2
    load     i64   .m 
    setarg   i64   2
    load     u64   .sttype 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .t 
    load     i64   .scope 
    load     u64   .sttype 
    loadimm  i64   191 
    istorex  u8    1 0
    setcall        3
    load     u64   .sttype 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     i64   .t 
    loadimm  i64   0 
    jumplt   i64   #5729 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .t 
    iloadx   u8    1 0
    loadref  u64   mm_decls.ttisreal 
    load     i64   .t 
    iloadx   u8    1 0
    add      i64   
    jumpf    i64   #5731 
    load     i64   .t 
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    istorex  i32   4 0
    jump           #5730 
#5731:
    loadref  u64   mm_decls.ttisref 
    load     i64   .t 
    iloadx   u8    1 0
    jumpf    i64   #5732 
    jump           #5730 
#5732:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpeq   i64   #5734 1
    loadimm  i64   11 
    jumpeq   i64   #5735 1
    loadimm  i64   8 
    jumpeq   i64   #5736 
    jump           #5737 
#5734:
    jump           #5733 
#5735:
    jump           #5733 
#5736:
    jump           #5733 
#5737:
    load     i64   .t 
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    istorex  i32   4 0
#5733:
#5730:
    jump           #5728 
#5729:
    setcall        3
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    addptrx  i32   4 0
    setarg   u64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
#5728:
    load     i64   .t 
    loadimm  i64   0 
    jumplt   i64   #5739 
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callp          mm_lib.copyttvalues 2 0
    jump           #5738 
#5739:
    loadimm  i64   29 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
#5738:
;------------------------
#5727:
    return         
end

proc mm_parse.readrecordfields
    param    u64   .owner 
    param    i64   .m 
    local    i64   .nvars 
    local    i64   .offset 
    local    u64   .stname 
    local    u64   .stbitfield 
;------------------------
    loadimm  i64   0 
    store    i64   .nvars 
    jump           #5742 
#5741:
    setcall        3
    loadimm  i64   14 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        3
    load     u64   .stname 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    loadref  u64   .nvars 
    incrto   i64   1
    loadref  u64   mm_parse.unionpend 
    loadimm  i64   7 
    iloadx   u8    1 0
    jumpf    i64   #5745 
    setcall        2
    loadref  u64   mm_parse.unionpend 
    setarg   u64   2
    load     u64   .stname 
    loadimm  i64   128 
    addptrx  u64   1 0
    setarg   u64   1
    callp          mm_lib.unionstr_copy 2 0
    setcall        2
    loadref  u64   mm_parse.unionpend 
    setarg   u64   2
    loadref  u64   mm_parse.unionstring 
    setarg   u64   1
    callp          mm_lib.unionstr_concat 2 0
    setcall        1
    loadref  u64   mm_parse.unionpend 
    setarg   u64   1
    callp          mm_lib.unionstr_clear 1 0
    jump           #5744 
#5745:
    setcall        1
    load     u64   .stname 
    loadimm  i64   128 
    addptrx  u64   1 0
    setarg   u64   1
    callp          mm_lib.unionstr_clear 1 0
#5744:
    load     u64   .stname 
    store    u64   mm_parse.unionlastvar 
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpeq   i64   #5747 1
    loadimm  i64   23 
    jumpeq   i64   #5748 1
    loadimm  i64   7 
    jumpeq   i64   #5749 
    jump           #5750 
#5747:
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   1 
    load     u64   .stname 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   4 
    storebit       
    setcall        1
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readequivfield 1 0
    load     u64   .stname 
    loadimm  i64   120 
    istorex  u64   1 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   31 
    jumpne   i64   #5752 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    i64   mm_parse.readconstint 0 0
    store    i64   .offset 
    load     i64   .offset 
    loadimm  i64   255 
    jumple   i64   #5754 
    setcall        1
    loadimm  u64   "Offset>255"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5754:
#5753:
    load     i64   .offset 
    load     u64   .stname 
    loadimm  i64   143 
    istorex  u8    1 0
#5752:
#5751:
    jump           #5746 
#5748:
    setcall        1
    loadimm  i64   71 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   i64   1 0
    loadimm  i64   1 
    jumpeq   i64   #5757 1
    loadimm  i64   2 
    jumpeq   i64   #5757 1
    loadimm  i64   4 
    jumpeq   i64   #5757 1
    loadimm  i64   8 
    jumpeq   i64   #5757 1
    loadimm  i64   0 
    jumpeq   i64   #5758 
    jump           #5759 
#5757:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   i64   1 0
    load     u64   .stname 
    loadimm  i64   141 
    istorex  u8    1 0
    jump           #5756 
#5758:
    loadimm  i64   255 
    load     u64   .stname 
    loadimm  i64   141 
    istorex  u8    1 0
    jump           #5756 
#5759:
    setcall        1
    loadimm  u64   "@@ bad align"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5756:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5746 
#5749:
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
#5761:
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        3
    loadimm  i64   14 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stbitfield 
    loadimm  i64   27 
    load     u64   .stbitfield 
    loadimm  i64   64 
    istorex  i32   1 0
    setcall        2
    load     u64   .stbitfield 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    loadimm  u64   1 
    load     u64   .stbitfield 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   4 
    storebit       
    load     u64   .stname 
    load     u64   .stbitfield 
    loadimm  i64   120 
    istorex  u64   1 0
    setcall        1
    loadimm  i64   7 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        1
    loadimm  i64   71 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   i64   1 0
    load     u64   .stbitfield 
    loadimm  i64   140 
    istorex  u8    1 0
    setcall        0
    callp          mm_lex.lex 0 0
#5762:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5761 
#5763:
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5746 
#5750:
#5746:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5765 
    jump           #5743 
#5765:
#5764:
    setcall        0
    callp          mm_lex.lex 0 0
#5742:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpeq   i64   #5741 
#5743:
    load     i64   .nvars 
    loadimm  i64   0 
    jumpne   i64   #5767 
    setcall        1
    loadimm  u64   "No fields declared"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5767:
#5766:
;------------------------
#5740:
    return         
end

proc mm_parse.readtabledef
    param    u64   .owner 
    param    i64   .scope 
    local    i64   .i 
    local    i64   .ncols 
    local    i64   .nrows 
    local    i64   .enums 
    local    i64   .nextenumvalue 
    local    i64   .firstval 
    local    i64   .lastval 
    local    i64   .startline 
    local    i64   .closesym 
    local    i64   .ltype 
    local    u64   .plower 
    local    u64   .stvar 
    local    u64   .stenum 
    local    u64   .stgen 
    local    u8:160 .varnameptrs 
    local    u8:160 .varlisttypes 
    local    u8:160 .plist 
    local    u8:160 .plistx 
    local    u8:4000 .enumvalues 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .enums 
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    store    u64   mm_parse.tabledataname 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #5771 
    load     i64   .enums 
    jumpt    i64   #5773 
    setcall        1
    loadimm  u64   "use 'enumdata'"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5773:
#5772:
    loadimm  i64   1 
    store    i64   .enums 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
#5771:
#5770:
    loadimm  i64   1 
    store    i64   .nextenumvalue 
    loadimm  i64   0 
    store    i64   .nrows 
    loadimm  i64   0 
    store    i64   .ncols 
    jump           #5776 
#5775:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .ltype 
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    loadref  u64   .ncols 
    incrload i64   1
    loadimm  i64   20 
    jumple   i64   #5779 
    setcall        1
    loadimm  u64   "tabledata/too many columns"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5779:
#5778:
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    loadref  u64   .varnameptrs 
    load     i64   .ncols 
    istorex  u64   8 -8
    load     i64   .ltype 
    loadref  u64   .varlisttypes 
    load     i64   .ncols 
    istorex  i64   8 -8
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpne   i64   #5782 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5781 
#5782:
    jump           #5777 
#5781:
#5776:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   48 
    jumpne   i64   #5775 
#5777:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callp          mm_parse.skipsemi 0 0
    setcall        0
    callf    i64   mm_parse.getcurrline 0 0
    store    i64   .startline 
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    i64   mm_parse.checkbegin 1 0
    store    i64   .closesym 
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadimm  i64   0 
    double         
    store    i64   .lastval 
    store    i64   .firstval 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .ncols 
    loadimm  i64   1 
    jumplt   i64   #5785 
#5783:
    loadimm  u64   0 
    double         
    loadref  u64   .plistx 
    load     i64   .i 
    istorex  u64   8 -8
    loadref  u64   .plist 
    load     i64   .i 
    istorex  u64   8 -8
#5784:
    forup          #5783 1
    opnd           .i 
    opnd           .ncols 
#5785:
    loadimm  i64   1 
    store    i64   mm_parse.intabledata 
#5786:
    setcall        0
    callp          mm_parse.skipsemi 0 0
    load     i64   .ncols 
    loadimm  i64   0 
    jumple   i64   #5789 
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
#5789:
#5788:
    loadref  u64   .nrows 
    incrload i64   1
    loadimm  i64   500 
    jumple   i64   #5791 
    setcall        1
    loadimm  u64   "tabledata:too many rows"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5791:
#5790:
    load     i64   .enums 
    jumpf    i64   #5794 
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .stgen 
    load     u64   .stgen 
    iload    u64   
    store    u64   mm_parse.tabledataname 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   48 
    jumpne   i64   #5796 
    load     i64   .nrows 
    loadimm  i64   1 
    jumple   i64   #5798 
    setcall        1
    loadimm  u64   "tabledata '=' not 1st"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5798:
#5797:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    i64   mm_parse.readconstint 0 0
    store    i64   .nextenumvalue 
#5796:
#5795:
    load     i64   .nextenumvalue 
    loadref  u64   .enumvalues 
    load     i64   .nrows 
    istorex  i64   8 -8
    setcall        3
    loadimm  i64   10 
    setarg   i64   3
    load     u64   .stgen 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stenum 
    loadimm  i64   3 
    load     u64   .stenum 
    loadimm  i64   64 
    istorex  i32   1 0
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .nextenumvalue 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    load     u64   .stenum 
    loadimm  i64   56 
    istorex  u64   1 0
    load     i64   .scope 
    load     u64   .stenum 
    loadimm  i64   191 
    istorex  u8    1 0
    setcall        2
    load     u64   .stenum 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    load     i64   .scope 
    loadimm  i64   3 
    jumpne   i64   #5801 
    setcall        1
    load     u64   .stenum 
    setarg   u64   1
    callp          mm_lib.addexpconst 1 0
#5801:
#5800:
    load     i64   .nrows 
    loadimm  i64   1 
    jumpne   i64   #5803 
    load     i64   .nextenumvalue 
    store    i64   .firstval 
#5803:
#5802:
    load     i64   .nextenumvalue 
    store    i64   .lastval 
    loadref  u64   .nextenumvalue 
    incrto   i64   1
    load     i64   .ncols 
    jumpf    i64   #5805 
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
#5805:
#5804:
#5794:
#5793:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .ncols 
    loadimm  i64   1 
    jumplt   i64   #5808 
#5806:
    setcall        3
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   3
    loadref  u64   .plistx 
    load     i64   .i 
    addptrx  u64   8 -8
    setarg   u64   2
    loadref  u64   .plist 
    load     i64   .i 
    addptrx  u64   8 -8
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    load     i64   .i 
    load     i64   .ncols 
    jumpne   i64   #5810 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    jump           #5809 
#5810:
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
#5809:
    setcall        0
    callp          mm_lex.lex 0 0
#5807:
    forup          #5806 1
    opnd           .i 
    opnd           .ncols 
#5808:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5812 
    jump           #5787 
#5812:
#5811:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    load     i64   .closesym 
    jumpne   i64   #5814 
    jump           #5787 
#5814:
#5813:
    jump           #5786 
#5787:
    loadimm  i64   0 
    store    i64   mm_parse.intabledata 
    setcall        0
    callp          mm_parse.skipsemi 0 0
    setcall        3
    load     i64   .startline 
    setarg   i64   3
    loadimm  i64   156 
    setarg   i64   2
    load     i64   .closesym 
    setarg   i64   1
    callp          mm_parse.checkbeginend 3 0
    load     i64   .nrows 
    loadimm  i64   0 
    jumpne   i64   #5816 
    setcall        1
    loadimm  u64   "No table data"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5816:
#5815:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .ncols 
    loadimm  i64   1 
    jumplt   i64   #5820 
#5818:
    setcall        3
    loadimm  i64   11 
    setarg   i64   3
    loadref  u64   .varnameptrs 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stvar 
    setcall        2
    loadref  u64   .plist 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    load     u64   .stvar 
    loadimm  i64   56 
    istorex  u64   1 0
    load     i64   .nrows 
    load     u64   .stvar 
    loadimm  i64   56 
    iloadx   u64   1 0
    loadimm  i64   40 
    istorex  u32   1 0
    setcall        3
    load     u64   .stvar 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    loadref  u64   .varlisttypes 
    load     i64   .i 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     i64   .scope 
    load     u64   .stvar 
    loadimm  i64   191 
    istorex  u8    1 0
    setcall        2
    load     u64   .stvar 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        1
    load     u64   .stvar 
    setarg   u64   1
    callp          mm_lib.addstatic 1 0
#5819:
    forup          #5818 1
    opnd           .i 
    opnd           .ncols 
#5820:
;------------------------
#5769:
    return         
end

proc mm_parse.readclassdef
    param    u64   .owner 
    param    i64   .scope 
    local    i64   .kwd 
    local    i64   .baseclass 
    local    i64   .m 
    local    i64   .startline 
    local    i64   .closesym 
    local    i64   .mrec 
    local    i64   .normalexit 
    local    i64   .isrecord 
    local    i64   .align 
    local    u64   .nameptr 
    local    u64   .sttype 
    local    u64   .newd 
    local    u64   .d 
    local    u64   .e 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .kwd 
    load     i64   .kwd 
    loadimm  i64   132 
    eq       i64   
    store    i64   .isrecord 
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .nameptr 
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   0 
    store    i64   .baseclass 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #5823 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .baseclass 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
#5823:
#5822:
    setcall        0
    callp          mm_parse.checkequals 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   0 
    store    i64   .align 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #5825 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpne   i64   #5827 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    i64   mm_parse.readconstint 0 0
    store    i64   .align 
    jump           #5826 
#5827:
    setcall        0
    callp          mm_lex.lex 0 0
#5826:
    loadimm  i64   1 
    store    i64   .align 
#5825:
#5824:
    setcall        3
    loadimm  i64   5 
    setarg   i64   3
    load     u64   .nameptr 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .sttype 
    setcall        2
    load     u64   .sttype 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        1
    load     u64   .sttype 
    setarg   u64   1
    callf    i64   mm_lib.createusertype 1 0
    store    i64   .m 
    setcall        2
    load     i64   .m 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.createrecordmode 2 0
    store    i64   .mrec 
    setcall        3
    load     u64   .sttype 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .mrec 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    setcall        3
    load     u64   .sttype 
    loadimm  i64   136 
    addptrx  u64   1 0
    setarg   u64   3
    load     i64   .baseclass 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     i64   .align 
    load     u64   .sttype 
    loadimm  i64   141 
    istorex  u8    1 0
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callf    i64   mm_parse.checkbegin 1 0
    store    i64   .closesym 
    setcall        0
    callf    i64   mm_parse.getcurrline 0 0
    store    i64   .startline 
    setcall        2
    load     i64   .kwd 
    setarg   i64   2
    load     u64   .sttype 
    setarg   u64   1
    callp          mm_parse.readclassbody 2 0
    setcall        3
    load     i64   .startline 
    setarg   i64   3
    load     i64   .kwd 
    setarg   i64   2
    load     i64   .closesym 
    setarg   i64   1
    callp          mm_parse.checkbeginend 3 0
    load     i64   .scope 
    load     u64   .sttype 
    loadimm  i64   191 
    istorex  u8    1 0
;------------------------
#5821:
    return         
end

proc mm_parse.readclassbody
    param    u64   .owner 
    param    i64   .classkwd 
    local    i64   .kwd 
    local    i64   .t 
    local    u64   .d 
;------------------------
    setcall        1
    loadref  u64   mm_parse.unionstring 
    setarg   u64   1
    callp          mm_lib.unionstr_clear 1 0
    setcall        1
    loadref  u64   mm_parse.unionpend 
    setarg   u64   1
    callp          mm_lib.unionstr_clear 1 0
#5829:
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #5831 6 156
    opnd           #5832 
#5831:
    swlabel        #5841 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5847 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5839 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5847 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5834 
    swlabel        #5834 
    swlabel        #5832 
    swlabel        #5837 
    swlabel        #5844 
    swlabel        #5844 
    swlabel        #5832 
    swlabel        #5838 
    swlabel        #5832 
    swlabel        #5859 
    swlabel        #5863 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5843 
    swlabel        #5833 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5832 
    swlabel        #5842 
    endsw          
#5833:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readconstdef 2 0
    jump           #5829 
#5834:
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .kwd 
    load     u64   .owner 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   7 
    loadbit        
    jumpf    u64   #5836 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readprocdecl 3 0
    unload   u64   
    jump           #5835 
#5836:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readprocdef 3 0
#5835:
    jump           #5829 
#5837:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readclassdef 2 0
    jump           #5829 
#5838:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readtypedef 2 0
    jump           #5829 
#5839:
    setcall        1
    loadimm  u64   "Class eof?"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #5830 
    jump           #5829 
#5841:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5829 
#5842:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readtabledef 2 0
    jump           #5829 
#5843:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readmacrodef 2 0
    jump           #5829 
#5844:
    setcall        2
    startmx        
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   133 
    jumpne   i64   #5846 
    loadimm  i64   83 
    resetmx        
    jump           #5845 
#5846:
    loadimm  i64   85 
    endmx          
#5845:
    setarg   i64   2
    loadref  u64   mm_parse.unionpend 
    setarg   u64   1
    callp          mm_lib.unionstr_append 2 0
    loadimm  u64   0 
    store    u64   mm_parse.unionlastvar 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #5829 
#5847:
    loadref  u64   mm_parse.unionstring 
    loadimm  i64   7 
    iloadx   u8    1 0
    jumpf    i64   #5849 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    startmx        
    setcall        1
    loadref  u64   mm_parse.unionstring 
    setarg   u64   1
    callf    i64   mm_lib.unionstr_last 1 0
    loadimm  i64   83 
    jumpne   i64   #5851 
    loadimm  i64   133 
    resetmx        
    jump           #5850 
#5851:
    loadimm  i64   134 
    endmx          
#5850:
    setarg   i64   2
    loadimm  i64   104 
    setarg   i64   1
    callp          mm_parse.checkend 4 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   mm_parse.unionlastvar 
    loadimm  u64   0 
    jumpeq   u64   #5854 
    loadref  u64   mm_parse.unionpend 
    loadimm  i64   7 
    iloadx   u8    1 0
    jumpf    i64   #5853 
#5854:
    setcall        1
    loadimm  u64   "Empty union group"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5853:
#5852:
    setcall        1
    load     u64   mm_parse.unionlastvar 
    loadimm  i64   128 
    addptrx  u64   1 0
    setarg   u64   1
    callf    i64   mm_lib.unionstr_last 1 0
    loadimm  i64   69 
    jumpeq   i64   #5857 1
    loadimm  i64   42 
    jumpeq   i64   #5857 
    jump           #5858 
#5857:
    jump           #5856 
#5858:
    setcall        2
    loadimm  i64   42 
    setarg   i64   2
    load     u64   mm_parse.unionlastvar 
    loadimm  i64   128 
    addptrx  u64   1 0
    setarg   u64   1
    callp          mm_lib.unionstr_append 2 0
#5856:
    setcall        2
    loadimm  i64   69 
    setarg   i64   2
    load     u64   mm_parse.unionlastvar 
    loadimm  i64   128 
    addptrx  u64   1 0
    setarg   u64   1
    callp          mm_lib.unionstr_append 2 0
    loadref  u64   mm_parse.unionstring 
    loadimm  i64   7 
    addptrx  u64   1 0
    decrto   u8    1
    jump           #5848 
#5849:
    jump           #5830 
#5848:
    jump           #5829 
#5859:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    i64   mm_parse.istypestarter 0 0
    jumpf    i64   #5861 
;readmut::
#5862:
    loadref  u64   mm_parse.insiderecord 
    incrto   i64   1
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    store    i64   .t 
    loadref  u64   mm_parse.insiderecord 
    decrto   i64   1
    jump           #5860 
#5861:
    loadimm  i64   22 
    store    i64   .t 
#5860:
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readrecordfields 2 0
    jump           #5829 
#5863:
    setcall        1
    loadimm  u64   "Let not allowed"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #5829 
#5832:
    setcall        0
    callf    i64   mm_parse.istypestarter 0 0
    jumpf    i64   #5866 
    jump           #5862 
    jump           #5865 
#5866:
    jump           #5830 
#5865:
    jump           #5829 
#5830:
;------------------------
#5828:
    return         
end

proc mm_parse.readimportmodule
    param    u64   .owner 
    local    i64   .isnew 
    local    i64   .startline 
    local    i64   .closesym 
    local    i64   .libtype 
    local    u64   .d 
    local    u64   .stname 
    local    u64   .stname0 
;------------------------
    load     i64   mm_parse.insidedllimport 
    jumpf    i64   #5869 
    setcall        1
    loadimm  u64   "nested importdll"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5869:
#5868:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .libtype 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   76 
    jumpne   i64   #5872 
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    store    u64   .stname 
    jump           #5871 
#5872:
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .stname 
#5871:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #5874 
#5875:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        2
    load     i64   .libtype 
    setarg   i64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    iload    u64   
    setarg   u64   1
    callp          mm_modules.addlib 2 0
    setcall        0
    callp          mm_lex.lex 0 0
#5876:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5875 
#5877:
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
#5874:
#5873:
    setcall        0
    callp          mm_parse.checkequals 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   1 
    store    i64   .isnew 
    load     u64   .stname 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .d 
    jump           #5879 
#5878:
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   4 
    jumpne   i64   #5882 
    load     u64   .d 
    store    u64   .stname 
    loadimm  i64   0 
    store    i64   .isnew 
    jump           #5880 
#5882:
#5881:
    load     u64   .d 
    loadimm  i64   40 
    iloadx   u64   1 0
    store    u64   .d 
#5879:
    load     u64   .d 
    jumpt    u64   #5878 
#5880:
    load     i64   .isnew 
    jumpf    i64   #5884 
    setcall        3
    loadimm  i64   4 
    setarg   i64   3
    load     u64   .stname 
    setarg   u64   2
    load     u64   mm_decls.stmodule 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   mm_decls.stmodule 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        2
    load     i64   .libtype 
    setarg   i64   2
    load     u64   .stname 
    iload    u64   
    setarg   u64   1
    callp          mm_modules.addlib 2 0
    load     i64   mm_decls.nlibfiles 
    load     u64   .stname 
    loadimm  i64   113 
    istorex  u8    1 0
#5884:
#5883:
    setcall        0
    callf    i64   mm_parse.getcurrline 0 0
    store    i64   .startline 
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    i64   mm_parse.checkbegin 1 0
    store    i64   .closesym 
    load     u64   .stname 
    loadimm  i64   113 
    iloadx   u8    1 0
    store    i64   mm_parse.insidedllimport 
    setcall        1
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readimportbody 1 0
    loadimm  i64   0 
    store    i64   mm_parse.insidedllimport 
    setcall        3
    load     i64   .startline 
    setarg   i64   3
    loadimm  i64   135 
    setarg   i64   2
    load     i64   .closesym 
    setarg   i64   1
    callp          mm_parse.checkbeginend 3 0
;------------------------
#5867:
    return         
end

proc mm_parse.readimportbody
    param    u64   .owner 
    local    i64   .pos 
    local    i64   .fflang 
    local    u64   .d 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
#5886:
    setcall        0
    callp          mm_parse.skipsemi 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #5889 15 149
    opnd           #5890 
#5889:
    swlabel        #5904 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5905 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5904 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5904 
    swlabel        #5904 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5904 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5906 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5896 
    swlabel        #5896 
    swlabel        #5890 
    swlabel        #5902 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5900 
    swlabel        #5904 
    swlabel        #5903 
    swlabel        #5890 
    swlabel        #5904 
    swlabel        #5890 
    swlabel        #5904 
    swlabel        #5890 
    swlabel        #5901 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5890 
    swlabel        #5891 
    endsw          
#5891:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .fflang 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   129 
    jumpeq   i64   #5893 1
    loadimm  i64   130 
    jumpeq   i64   #5893 
    jump           #5894 
#5893:
    jump           #5895 
    jump           #5892 
#5894:
#5892:
    jump           #5888 
#5896:
    loadimm  i64   0 
    store    i64   .fflang 
;doproc::
#5895:
    setcall        3
    load     i64   .fflang 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readprocdecl 3 0
    store    u64   .d 
    load     i64   mm_decls.ndllproctable 
    loadimm  i64   1000 
    jumplt   i64   #5898 
    setcall        1
    loadimm  u64   "Too many dll procs"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5898:
#5897:
    load     u64   .d 
    loadref  u64   mm_decls.dllproctable 
    loadref  u64   mm_decls.ndllproctable 
    incrload i64   1
    istorex  u64   8 -8
    jump           #5888 
#5900:
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readtypedef 2 0
    jump           #5888 
#5901:
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readconstdef 2 0
    jump           #5888 
#5902:
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_parse.readclassdef 2 0
    jump           #5888 
#5903:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        4
    loadimm  i64   138 
    setarg   i64   4
    loadimm  i64   8 
    setarg   i64   3
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readvardef 4 0
    unload   u64   
    jump           #5888 
#5904:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   8 
    setarg   i64   3
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readvardef 4 0
    unload   u64   
    jump           #5888 
#5905:
    jump           #5887 
    jump           #5888 
#5906:
    jump           #5887 
    jump           #5888 
#5890:
    setcall        1
    loadimm  u64   "symbol"
    setarg   u64   1
    callp          mm_lex.ps 1 0
    setcall        1
    loadimm  u64   "Not allowed in importmodule"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5888:
    jump           #5886 
#5887:
;------------------------
#5885:
    return         
end

proc mm_parse.readequivfield
    rettype  u64   
    param    u64   .owner 
    local    u64   .p 
    local    u64   .d 
;------------------------
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .d 
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .owner 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .p 
    jump           #5911 
#5910:
    setcall        2
    load     u64   .d 
    iload    u64   
    setarg   u64   2
    load     u64   .p 
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #5914 
    load     u64   .p 
    setret   u64   
    jump           #5909 
#5914:
#5913:
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .p 
#5911:
    load     u64   .p 
    jumpt    u64   #5910 
#5912:
    callp          msys.m$print_startcon 0 0
    load     u64   .d 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "Can't find @ field"
    setarg   u64   1
    callp          mm_support.serror 1 0
    loadimm  u64   0 
    setret   u64   
    jump           #5909 
;------------------------
#5909:
    return         
end

proc mm_parse.readrefproc
    rettype  i64   
    param    u64   .owner 
    param    i64   .typedefx 
    param    i64   .fflang 
    local    i64   .kwd 
    local    i64   .prettype 
    local    i64   .m 
    local    i64   .varparams 
    local    i64   .nparams 
    local    u8:32 .retmodes 
    local    u64   .paramlist 
    local    u64   .stproc 
    local    i64   .rettype2 
    local    i64   .rettype3 
    local    i64   .nretvalues 
    local    u64   .name 
;------------------------
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .kwd 
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    store    u64   .paramlist 
    loadimm  i64   0 
    store    i64   .prettype 
    loadimm  i64   0 
    store    i64   .nretvalues 
    setcall        0
    callf    u64   mm_lib.nextautotype 0 0
    store    u64   .name 
    setcall        3
    loadimm  i64   5 
    setarg   i64   3
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   mm_decls.stmodule 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stproc 
    setcall        2
    load     u64   .stproc 
    setarg   u64   2
    load     u64   mm_decls.stmodule 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    loadimm  i64   0 
    loadref  u64   .retmodes 
    loadimm  i64   1 
    istorex  i64   8 -8
    load     i64   .kwd 
    loadimm  i64   130 
    jumpne   i64   #5918 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #5920 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #5922 
    setcall        5
    loadref  u64   .nparams 
    setarg   u64   5
    loadref  u64   .varparams 
    setarg   u64   4
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .stproc 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readparams 5 0
    store    u64   .paramlist 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
#5922:
#5921:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpeq   i64   #5925 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   11 
    jumpne   i64   #5924 
#5925:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadref  u64   .retmodes 
    setarg   u64   2
    load     u64   .stproc 
    setarg   u64   1
    callf    i64   mm_parse.readreturntype 2 0
    store    i64   .nretvalues 
    jump           #5923 
#5924:
    loadref  u64   mm_decls.typestarterset 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #5927 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #5926 
#5927:
    setcall        2
    loadref  u64   .retmodes 
    setarg   u64   2
    load     u64   .stproc 
    setarg   u64   1
    callf    i64   mm_parse.readreturntype 2 0
    store    i64   .nretvalues 
#5926:
#5923:
    jump           #5919 
#5920:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpeq   i64   #5929 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   11 
    jumpne   i64   #5928 
#5929:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadref  u64   .retmodes 
    setarg   u64   2
    load     u64   .stproc 
    setarg   u64   1
    callf    i64   mm_parse.readreturntype 2 0
    store    i64   .nretvalues 
#5928:
#5919:
    load     i64   .nretvalues 
    loadimm  i64   0 
    jumpne   i64   #5931 
    setcall        1
    loadimm  u64   "Function needs return type"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5931:
#5930:
    load     i64   .nretvalues 
    jumpf    i64   #5934 
    load     i64   .kwd 
    loadimm  i64   129 
    jumpne   i64   #5934 
    setcall        1
    loadimm  u64   "Proc can't return value"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5934:
#5933:
    jump           #5917 
#5918:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #5937 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #5939 
    setcall        5
    loadref  u64   .nparams 
    setarg   u64   5
    loadref  u64   .varparams 
    setarg   u64   4
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .stproc 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_parse.readparams 5 0
    store    u64   .paramlist 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
#5939:
#5938:
    setcall        0
    callp          mm_lex.lex 0 0
#5937:
#5936:
    loadref  u64   mm_decls.typestarterset 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #5942 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   7 
    jumpeq   i64   #5942 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   11 
    jumpne   i64   #5941 
#5942:
    setcall        1
    loadimm  u64   "proc can't have ret value"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5941:
#5940:
#5917:
    setcall        6
    load     i64   .typedefx 
    setarg   i64   6
    load     i64   .prettype 
    setarg   i64   5
    load     i64   .kwd 
    setarg   i64   4
    load     u64   .paramlist 
    setarg   u64   3
    load     u64   .stproc 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.createrefprocmode 6 0
    store    i64   .m 
    setcall        3
    load     u64   .stproc 
    loadimm  i64   64 
    addptrx  u64   1 0
    setarg   u64   3
    loadref  u64   .retmodes 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_lib.storemode 3 0
    unload   i64   
    load     i64   .nretvalues 
    load     u64   .stproc 
    loadimm  i64   115 
    istorex  u8    1 0
    load     u64   .stproc 
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    istorex  u64   8 0
    load     i64   .fflang 
    load     u64   .stproc 
    loadimm  i64   114 
    istorex  u8    1 0
    load     i64   .varparams 
    load     u64   .stproc 
    loadimm  i64   116 
    istorex  u8    1 0
    load     i64   .m 
    setret   i64   
    jump           #5916 
;------------------------
#5916:
    return         
end

proc mm_parse.pushproc
    param    u64   .p 
;------------------------
    load     i64   mm_parse.nprocstack 
    loadimm  i64   10 
    jumplt   i64   #5946 
    setcall        1
    loadimm  u64   "Too many nested proc"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5946:
#5945:
    load     u64   mm_decls.currproc 
    loadref  u64   mm_parse.procstack 
    loadref  u64   mm_parse.nprocstack 
    incrload i64   1
    istorex  u64   8 -8
    load     u64   .p 
    store    u64   mm_decls.currproc 
;------------------------
#5944:
    return         
end

proc mm_parse.popproc
;------------------------
    load     i64   mm_parse.nprocstack 
    jumpf    i64   #5950 
    loadref  u64   mm_parse.procstack 
    loadref  u64   mm_parse.nprocstack 
    loaddecr i64   1
    iloadx   u64   8 -8
    store    u64   mm_decls.currproc 
    jump           #5949 
#5950:
    load     u64   mm_decls.stmodule 
    store    u64   mm_decls.currproc 
#5949:
;------------------------
#5948:
    return         
end

proc mm_parse.makeastring
    rettype  u64   
    local    u64   .ulist 
    local    u64   .ulistx 
    local    u64   .p 
    local    u64   .pconst 
    local    u64   .s 
    local    i64   .length 
    local    i64   .$av_1 
;------------------------
    loadimm  u64   0 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .s 
    load     i64   mm_lex.astringlength 
    store    i64   .length 
    load     i64   mm_lex.astringlength 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #5954 
#5952:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .s 
    iload    u8    
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .pconst 
    setcall        3
    load     u64   .pconst 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   .s 
    incrto   u64   1
#5953:
    to             #5952 
    opnd           .$av_1 
#5954:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   90 
    jumpne   i64   #5956 
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .pconst 
    setcall        3
    load     u64   .pconst 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   .length 
    incrto   i64   1
#5956:
#5955:
    setcall        2
    load     u64   .ulist 
    setarg   u64   2
    loadimm  i64   16 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     i64   .length 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5951 
;------------------------
#5951:
    return         
end

proc mm_parse.readreturntype
    rettype  i64   
    param    u64   .owner 
    param    u64   .retmodes 
    local    i64   .nretvalues 
;------------------------
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    load     u64   .retmodes 
    loadimm  i64   1 
    istorex  i64   8 -8
    loadimm  i64   1 
    store    i64   .nretvalues 
    jump           #5959 
#5958:
    load     i64   .nretvalues 
    loadimm  i64   4 
    jumplt   i64   #5962 
    setcall        1
    loadimm  u64   "Too many return values"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5962:
#5961:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .owner 
    setarg   u64   1
    callf    i64   mm_parse.readtypespec 2 0
    load     u64   .retmodes 
    loadref  u64   .nretvalues 
    incrload i64   1
    istorex  i64   8 -8
#5959:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5958 
#5960:
    load     i64   .nretvalues 
    setret   i64   
    jump           #5957 
;------------------------
#5957:
    return         
end

proc mm_parse.readset
    rettype  u64   
    local    i64   .length 
    local    i64   .nkeyvalues 
    local    i64   .oldirp 
    local    u64   .p 
    local    u64   .ulist 
    local    u64   .ulistx 
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #5966 1
    loadimm  i64   7 
    jumpeq   i64   #5967 
    jump           #5968 
#5966:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   18 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setret   u64   
    jump           #5964 
    jump           #5965 
#5967:
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  i64   19 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    setret   u64   
    jump           #5964 
    jump           #5965 
#5968:
#5965:
    loadimm  i64   0 
    store    i64   .length 
    loadimm  i64   0 
    store    i64   .nkeyvalues 
    loadimm  u64   0 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
#5969:
    load     i64   mm_parse.inreadprint 
    store    i64   .oldirp 
    loadimm  i64   0 
    store    i64   mm_parse.inreadprint 
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    load     i64   .oldirp 
    store    i64   mm_parse.inreadprint 
    load     u64   .p 
    iload    u8    
    loadimm  i64   23 
    jumpne   i64   #5972 
    loadref  u64   .nkeyvalues 
    incrto   i64   1
#5972:
#5971:
    loadref  u64   .length 
    incrto   i64   1
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   5 
    jumpeq   i64   #5974 1
    loadimm  i64   6 
    jumpeq   i64   #5975 1
    loadimm  i64   16 
    jumpeq   i64   #5976 
    jump           #5977 
#5974:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   16 
    jumpne   i64   #5979 
    jump           #5970 
#5979:
#5978:
    jump           #5973 
#5975:
    setcall        1
    loadimm  i64   16 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    jump           #5970 
    jump           #5973 
#5976:
    jump           #5970 
    jump           #5973 
#5977:
    setcall        1
    loadimm  u64   "readset?"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5973:
    setcall        0
    callp          mm_parse.skipsemi 0 0
    jump           #5969 
#5970:
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   .nkeyvalues 
    jumpf    i64   #5982 
    load     i64   .length 
    load     i64   .nkeyvalues 
    jumple   i64   #5984 
    setcall        1
    loadimm  u64   "dict: mixed elements"
    setarg   u64   1
    callp          mm_support.serror 1 0
#5984:
#5983:
    setcall        2
    load     u64   .ulist 
    setarg   u64   2
    loadimm  i64   19 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    jump           #5981 
#5982:
    setcall        2
    load     u64   .ulist 
    setarg   u64   2
    loadimm  i64   18 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
#5981:
    load     i64   .length 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #5964 
;------------------------
#5964:
    return         
end

proc mm_parse.istypestarter
    rettype  i64   
;------------------------
    loadref  u64   mm_decls.typestarterset 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u8    1 0
    jumpf    i64   #5988 
    loadimm  i64   1 
    setret   i64   
    jump           #5986 
#5988:
#5987:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #5990 
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   80 
    jumpeq   i64   #5992 1
    loadimm  i64   25 
    jumpeq   i64   #5993 
    jump           #5994 
#5992:
    loadimm  i64   1 
    setret   i64   
    jump           #5986 
    jump           #5991 
#5993:
    loadimm  i64   1 
    setret   i64   
    jump           #5986 
    jump           #5991 
#5994:
#5991:
#5990:
#5989:
    loadimm  i64   0 
    setret   i64   
    jump           #5986 
;------------------------
#5986:
    return         
end

proc mm_parse.readunit
    rettype  u64   
    local    u64   .p 
    local    u64   .pt 
    local    i64   .pos 
;------------------------
    loadimm  u64   0 
    store    u64   .pt 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    store    u64   .pt 
    loadref  u64   mm_tables.jisexpr 
    load     u64   .pt 
    iload    u8    
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpne   i64   #5997 
    load     u64   .pt 
    setret   u64   
    jump           #5995 
#5997:
#5996:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #5999 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    store    u64   .p 
    setcall        3
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.readassignment 1 0
    setarg   u64   3
    load     u64   .pt 
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    jump           #5998 
#5999:
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readassignment 1 0
    store    u64   .p 
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
#5998:
    jump           #6001 
#6000:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    load     u64   .p 
    setarg   u64   3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readassignment 1 0
    setarg   u64   2
    loadimm  i64   29 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
#6001:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   12 
    jumpeq   i64   #6000 
#6002:
    load     u64   .p 
    setret   u64   
    jump           #5995 
;------------------------
#5995:
    return         
end

proc mm_parse.readassignment
    rettype  u64   
    param    u64   .pt 
    local    u64   .p 
    local    i64   .pos 
    local    i64   .opc 
    local    u64   .q 
;------------------------
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readorterms 1 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    iload    u8    
    double         
    store    i64   .opc 
    loadimm  i64   9 
    jumpeq   i64   #6006 1
    loadimm  i64   10 
    jumpne   i64   #6005 
#6006:
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   164 
    jumpne   i64   #6008 
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   124 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6007 
#6008:
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readassignment 1 0
    store    u64   .q 
    load     i64   .opc 
    loadimm  i64   10 
    jumpne   i64   #6010 
    setcall        2
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   28 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .q 
#6010:
#6009:
    setcall        3
    load     u64   .q 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   24 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
#6007:
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
#6005:
#6004:
    load     u64   .p 
    setret   u64   
    jump           #6003 
;------------------------
#6003:
    return         
end

proc mm_parse.readorterms
    rettype  u64   
    param    u64   .pt 
    local    u64   .p 
    local    i64   .pos 
;------------------------
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readandterms 1 0
    store    u64   .p 
    jump           #6013 
#6012:
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #6016 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readassignment 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   34 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadimm  i64   160 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #6014 
#6016:
#6015:
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readandterms 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   13 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadimm  i64   162 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
#6013:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   46 
    jumpeq   i64   #6012 
#6014:
    load     u64   .p 
    setret   u64   
    jump           #6011 
;------------------------
#6011:
    return         
end

proc mm_parse.readandterms
    rettype  u64   
    param    u64   .pt 
    local    u64   .p 
    local    i64   .pos 
;------------------------
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readcmpterms 1 0
    store    u64   .p 
    jump           #6019 
#6018:
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #6022 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readassignment 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   34 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadimm  i64   159 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #6020 
#6022:
#6021:
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readcmpterms 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   12 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadimm  i64   161 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
#6019:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   45 
    jumpeq   i64   #6018 
#6020:
    load     u64   .p 
    setret   u64   
    jump           #6017 
;------------------------
#6017:
    return         
end

proc mm_parse.readcmpterms
    rettype  u64   
    param    u64   .pt 
    local    u64   .p 
    local    i64   .pos 
    local    i64   .opc 
    local    i64   .n 
    local    u64   .ulist 
    local    u64   .ulistx 
    local    u64   .q 
    local    u32   .genops 
;------------------------
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readinterms 1 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   48 
    jumpeq   i64   #6025 1
    loadimm  i64   49 
    jumpeq   i64   #6025 
    load     u64   .p 
    setret   u64   
    jump           #6023 
#6025:
#6024:
    load     u64   .p 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   31 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadimm  i64   0 
    store    i64   .n 
    loadref  u64   .genops 
    clear    u32   
#6026:
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #6028 48 49
    opnd           #6029 
#6028:
    swlabel        #6030 
    swlabel        #6030 
    endsw          
#6030:
    loadref  u64   .n 
    incrto   i64   1
    load     i64   .n 
    loadimm  i64   4 
    jumple   i64   #6032 
    setcall        1
    loadimm  u64   "cmpchain: Too many items"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6032:
#6031:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadref  u64   .genops 
    load     i64   .n 
    istorex  u8    1 -1
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readinterms 1 0
    store    u64   .q 
    setcall        3
    load     u64   .q 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    load     i64   .pos 
    load     u64   .q 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #6026 
#6029:
    jump           #6027 
    jump           #6026 
#6027:
    load     i64   .n 
    loadimm  i64   1 
    jumpne   i64   #6035 
    loadimm  i64   30 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    loadref  u64   .genops 
    loadimm  i64   1 
    iloadx   u8    1 -1
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    loadimm  u64   0 
    load     u64   .q 
    loadimm  i64   8 
    istorex  u64   1 0
    jump           #6034 
#6035:
    load     u32   .genops 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
#6034:
    load     u64   .p 
    setret   u64   
    jump           #6023 
;------------------------
#6023:
    return         
end

proc mm_parse.readinterms
    rettype  u64   
    param    u64   .pt 
    local    u64   .p 
    local    i64   .pos 
    local    i64   .opc 
;------------------------
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readrangeterm 1 0
    store    u64   .p 
#6037:
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #6039 51 52
    opnd           #6040 
#6039:
    swlabel        #6041 
    swlabel        #6041 
    endsw          
#6041:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readrangeterm 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   32 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    load     i64   .opc 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #6037 
#6040:
    jump           #6038 
    jump           #6037 
#6038:
    load     u64   .p 
    setret   u64   
    jump           #6036 
;------------------------
#6036:
    return         
end

proc mm_parse.readrangeterm
    rettype  u64   
    param    u64   .pt 
    local    u64   .p 
    local    i64   .pos 
    local    i64   .opc 
;------------------------
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readaddterms 1 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   28 
    jumpne   i64   #6044 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readaddterms 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
#6044:
#6043:
    load     u64   .p 
    setret   u64   
    jump           #6042 
;------------------------
#6042:
    return         
end

proc mm_parse.readaddterms
    rettype  u64   
    param    u64   .pt 
    local    u64   .p 
    local    i64   .pos 
    local    i64   .sym 
    local    i64   .tag 
    local    i64   .genop 
;------------------------
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readmulterms 1 0
    store    u64   .p 
#6046:
    loadref  u64   mm_decls.lx 
    iload    u8    
    double         
    store    i64   .sym 
    switch         #6048 31 44
    opnd           #6049 
#6048:
    swlabel        #6050 
    swlabel        #6050 
    swlabel        #6049 
    swlabel        #6049 
    swlabel        #6049 
    swlabel        #6049 
    swlabel        #6049 
    swlabel        #6050 
    swlabel        #6050 
    swlabel        #6050 
    swlabel        #6049 
    swlabel        #6049 
    swlabel        #6050 
    swlabel        #6050 
    endsw          
#6050:
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .genop 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #6052 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readassignment 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   34 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadref  u64   mm_tables.symbolgentoops 
    load     i64   .sym 
    iloadx   u8    1 -1
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #6047 
#6052:
#6051:
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readmulterms 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   32 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadref  u64   mm_tables.symbolgenops 
    load     i64   .sym 
    iloadx   u8    1 -1
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #6046 
#6049:
    jump           #6047 
    jump           #6046 
#6047:
    load     u64   .p 
    setret   u64   
    jump           #6045 
;------------------------
#6045:
    return         
end

proc mm_parse.readmulterms
    rettype  u64   
    param    u64   .pt 
    local    u64   .p 
    local    i64   .pos 
    local    i64   .sym 
;------------------------
    setcall        1
    load     u64   .pt 
    setarg   u64   1
    callf    u64   mm_parse.readpowerterms 1 0
    store    u64   .p 
#6054:
    loadref  u64   mm_decls.lx 
    iload    u8    
    double         
    store    i64   .sym 
    switch         #6056 33 42
    opnd           #6057 
#6056:
    swlabel        #6058 
    swlabel        #6058 
    swlabel        #6058 
    swlabel        #6058 
    swlabel        #6058 
    swlabel        #6057 
    swlabel        #6057 
    swlabel        #6057 
    swlabel        #6058 
    swlabel        #6058 
    endsw          
#6058:
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #6060 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readassignment 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   34 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadref  u64   mm_tables.symbolgentoops 
    load     i64   .sym 
    iloadx   u8    1 -1
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #6055 
#6060:
#6059:
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readpowerterms 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   32 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadref  u64   mm_tables.symbolgenops 
    load     i64   .sym 
    iloadx   u8    1 -1
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    jump           #6054 
#6057:
    jump           #6055 
    jump           #6054 
#6055:
    load     u64   .p 
    setret   u64   
    jump           #6053 
;------------------------
#6053:
    return         
end

proc mm_parse.readpowerterms
    rettype  u64   
    param    u64   .p 
    local    i64   .pos 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #6063 
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    store    u64   .p 
#6063:
#6062:
    jump           #6065 
#6064:
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.readpowerterms 1 0
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   32 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadimm  i64   83 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
#6065:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   50 
    jumpeq   i64   #6064 
#6066:
    load     u64   .p 
    setret   u64   
    jump           #6061 
;------------------------
#6061:
    return         
end

proc mm_parse.readterm2
    rettype  u64   
    local    u64   .p 
    local    u64   .q 
    local    u64   .r 
    local    u64   .pbyte 
    local    u64   .a 
    local    i64   .oldipl 
    local    i64   .opc 
    local    i64   .oldinrp 
    local    i64   .pos 
    local    i64   .shift 
    local    i64   .t 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    setcall        0
    callf    u64   mm_parse.readterm 0 0
    store    u64   .p 
#6068:
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #6070 2 70
    opnd           #6071 
#6070:
    swlabel        #6077 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6078 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6072 
    swlabel        #6071 
    swlabel        #6076 
    swlabel        #6071 
    swlabel        #6088 
    swlabel        #6071 
    swlabel        #6075 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6071 
    swlabel        #6083 
    endsw          
#6072:
    setcall        0
    callp          mm_lex.lex 0 0
    load     i64   mm_parse.inreadprint 
    store    i64   .oldinrp 
    loadimm  i64   0 
    store    i64   mm_parse.inreadprint 
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    loadimm  i64   1 
    setarg   i64   1
    callf    u64   mm_parse.readslist 2 0
    store    u64   .q 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    load     u64   .p 
    iload    u8    
    loadimm  i64   90 
    jumpne   i64   #6074 
    load     u64   .q 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    jump           #6073 
#6074:
    setcall        3
    load     u64   .q 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   29 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
#6073:
    load     i64   .oldinrp 
    store    i64   mm_parse.inreadprint 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.readcondsuffix 1 0
    store    u64   .p 
    jump           #6068 
#6075:
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   48 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6068 
#6076:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.readindex 2 0
    store    u64   .p 
    jump           #6068 
#6077:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callf    u64   mm_parse.readdotsuffix 1 0
    store    u64   .p 
    jump           #6068 
#6078:
    load     i64   mm_parse.inreadprint 
    jumpf    i64   #6080 
    jump           #6069 
#6080:
#6079:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .q 
    setcall        3
    load     u64   .q 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    startmx        
    load     i64   mm_parse.inparamlist 
    jumpf    i64   #6082 
    loadimm  i64   22 
    resetmx        
    jump           #6081 
#6082:
    loadimm  i64   23 
    endmx          
#6081:
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    jump           #6068 
#6083:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   125 
    jumpeq   i64   #6085 1
    loadimm  i64   128 
    jumpeq   i64   #6086 
    jump           #6087 
#6085:
    loadimm  i64   127 
    store    i64   .opc 
    jump           #6084 
#6086:
    loadimm  i64   130 
    store    i64   .opc 
    jump           #6084 
#6087:
#6084:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   36 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     i64   .opc 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #6068 
#6088:
    setcall        1
    loadimm  u64   "X{...} not ready"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #6068 
#6071:
    jump           #6069 
    jump           #6068 
#6069:
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #6067 
;------------------------
#6067:
    return         
end

proc mm_parse.readterm
    rettype  u64   
    local    u64   .p 
    local    u64   .q 
    local    u64   .r 
    local    u64   .pbyte 
    local    u64   .a 
    local    i64   .oldipl 
    local    i64   .opc 
    local    i64   .oldinrp 
    local    i64   .pos 
    local    i64   .shift 
    local    i64   .t 
    local    i64   .length 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #6092 4 165
    opnd           #6093 
#6092:
    swlabel        #6127 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6108 
    swlabel        #6093 
    swlabel        #6117 
    swlabel        #6093 
    swlabel        #6167 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6121 
    swlabel        #6121 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6110 
    swlabel        #6110 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6110 
    swlabel        #6110 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6111 
    swlabel        #6114 
    swlabel        #6110 
    swlabel        #6110 
    swlabel        #6110 
    swlabel        #6110 
    swlabel        #6110 
    swlabel        #6093 
    swlabel        #6110 
    swlabel        #6110 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6118 
    swlabel        #6097 
    swlabel        #6100 
    swlabel        #6097 
    swlabel        #6102 
    swlabel        #6093 
    swlabel        #6098 
    swlabel        #6099 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6094 
    swlabel        #6093 
    swlabel        #6164 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6109 
    swlabel        #6109 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6109 
    swlabel        #6144 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6145 
    swlabel        #6146 
    swlabel        #6146 
    swlabel        #6147 
    swlabel        #6093 
    swlabel        #6148 
    swlabel        #6149 
    swlabel        #6093 
    swlabel        #6150 
    swlabel        #6151 
    swlabel        #6152 
    swlabel        #6093 
    swlabel        #6154 
    swlabel        #6155 
    swlabel        #6153 
    swlabel        #6093 
    swlabel        #6143 
    swlabel        #6146 
    swlabel        #6146 
    swlabel        #6156 
    swlabel        #6119 
    swlabel        #6157 
    swlabel        #6120 
    swlabel        #6120 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6109 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6139 
    swlabel        #6128 
    swlabel        #6130 
    swlabel        #6159 
    swlabel        #6093 
    swlabel        #6093 
    swlabel        #6140 
    swlabel        #6158 
    swlabel        #6129 
    swlabel        #6160 
    swlabel        #6163 
    swlabel        #6093 
    swlabel        #6165 
    swlabel        #6166 
    endsw          
#6094:
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   22 
    jumpne   i64   #6096 
    setcall        0
    callf    u64   mm_parse.readcast 0 0
    store    u64   .p 
    jump           #6095 
#6096:
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    setcall        0
    callp          mm_lex.lex 0 0
#6095:
    jump           #6091 
#6097:
    setcall        2
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    setarg   i64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   62 
    istorex  u8    1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6091 
#6098:
    setcall        2
    loadimm  i64   -1 
    setarg   i64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.createstringconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6091 
#6099:
    setcall        0
    callf    u64   mm_parse.makeastring 0 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6091 
#6100:
    setcall        1
    loadimm  u64   "DEC CONST"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #6091 
#6102:
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .length 
    load     i64   .length 
    loadimm  i64   8 
    jumple   i64   #6104 
    setcall        1
    loadimm  u64   "Char const too long"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6104:
#6103:
    loadimm  u64   0 
    store    u64   .a 
    load     i64   .length 
    jumpf    i64   #6107 
    setcall        3
    load     i64   .length 
    setarg   u64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    loadref  u64   .a 
    setarg   u64   1
    callp          memcpy 3 0
#6107:
#6106:
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   62 
    istorex  u8    1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6091 
#6108:
    setcall        0
    callf    u64   mm_parse.readlbrack 0 0
    store    u64   .p 
    jump           #6091 
#6109:
    setcall        0
    callf    u64   mm_parse.readcast 0 0
    store    u64   .p 
    jump           #6091 
#6110:
    setcall        0
    callf    u64   mm_parse.readopc 0 0
    store    u64   .p 
    jump           #6091 
#6111:
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #6113 
    setcall        0
    callf    u64   mm_parse.readopc 0 0
    store    u64   .p 
    jump           #6112 
#6113:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setarg   u64   2
    loadimm  i64   14 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadimm  i64   102 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
#6112:
    jump           #6091 
#6114:
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #6116 
    setcall        0
    callf    u64   mm_parse.readopc 0 0
    store    u64   .p 
    jump           #6115 
#6116:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setarg   u64   2
    loadimm  i64   15 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadimm  i64   103 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
#6115:
    jump           #6091 
#6117:
    setcall        0
    callf    u64   mm_parse.readset 0 0
    store    u64   .p 
    jump           #6091 
#6118:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setarg   u64   2
    loadimm  i64   36 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     i64   .opc 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #6091 
#6119:
    setcall        0
    callf    u64   mm_parse.readsprint 0 0
    store    u64   .p 
    jump           #6091 
#6120:
    setcall        0
    callf    u64   mm_parse.readsread 0 0
    store    u64   .p 
    jump           #6091 
#6121:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setarg   u64   2
    load     i64   .opc 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   29 
    jumpne   i64   #6123 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   24 
    iloadx   u64   1 0
    jumpf    u64   #6125 
    setcall        1
    loadimm  u64   "Params not allowed"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6125:
#6124:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
#6123:
#6122:
    jump           #6091 
#6127:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setarg   u64   2
    loadimm  i64   50 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    jump           #6091 
#6128:
    setcall        0
    callf    u64   mm_parse.readcompilervar 0 0
    store    u64   .p 
    jump           #6091 
#6129:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .p 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6091 
#6130:
    load     i64   mm_parse.intabledata 
    jumpf    i64   #6132 
    load     u64   mm_parse.tabledataname 
    jumpt    u64   #6134 
    setcall        1
    loadimm  u64   "$: no enum"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6134:
#6133:
    setcall        2
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   mm_parse.tabledataname 
    setarg   u64   1
    callf    u64   mm_lib.createstringconstunit 2 0
    store    u64   .p 
    jump           #6131 
#6132:
    load     i64   mm_parse.ndollar 
    loadimm  i64   0 
    jumpgt   i64   #6137 
    setcall        1
    loadimm  u64   "[$] No array"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6137:
#6136:
    setcall        2
    loadref  u64   mm_parse.dollarstack 
    load     i64   mm_parse.ndollar 
    iloadx   u64   8 -8
    setarg   u64   2
    loadimm  i64   33 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    loadimm  i64   154 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
#6131:
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6091 
#6139:
    setcall        0
    callf    u64   mm_parse.readcastx 0 0
    store    u64   .p 
    jump           #6091 
#6140:
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .q 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #6142 
    load     u64   .q 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #6142 
    load     u64   .q 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .r 
    load     u64   .q 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #6141 
#6142:
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .r 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
#6141:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    load     u64   .q 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   32 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .q 
    loadimm  i64   76 
    load     u64   .q 
    loadimm  i64   61 
    istorex  u8    1 0
    setcall        3
    load     u64   .r 
    setarg   u64   3
    load     u64   .q 
    setarg   u64   2
    loadimm  i64   32 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    loadimm  i64   75 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #6091 
#6143:
    setcall        1
    loadimm  i64   99 
    setarg   i64   1
    callf    u64   mm_parse.readgoto 1 0
    store    u64   .p 
    jump           #6091 
#6144:
    setcall        0
    callf    u64   mm_parse.readif 0 0
    store    u64   .p 
    jump           #6091 
#6145:
    setcall        0
    callf    u64   mm_parse.readunless 0 0
    store    u64   .p 
    jump           #6091 
#6146:
    setcall        0
    callf    u64   mm_parse.readswitchcase 0 0
    store    u64   .p 
    jump           #6091 
#6147:
    setcall        0
    callf    u64   mm_parse.readrecase 0 0
    store    u64   .p 
    jump           #6091 
#6148:
    setcall        0
    callf    u64   mm_parse.readfor 0 0
    store    u64   .p 
    jump           #6091 
#6149:
    setcall        0
    callf    u64   mm_parse.readto 0 0
    store    u64   .p 
    jump           #6091 
#6150:
    setcall        0
    callf    u64   mm_parse.readdo 0 0
    store    u64   .p 
    jump           #6091 
#6151:
    setcall        0
    callf    u64   mm_parse.readwhile 0 0
    store    u64   .p 
    jump           #6091 
#6152:
    setcall        0
    callf    u64   mm_parse.readrepeat 0 0
    store    u64   .p 
    jump           #6091 
#6153:
    setcall        0
    callf    u64   mm_parse.readloopcontrol 0 0
    store    u64   .p 
    jump           #6091 
#6154:
    setcall        0
    callf    u64   mm_parse.readreturn 0 0
    store    u64   .p 
    jump           #6091 
#6155:
    setcall        0
    callf    u64   mm_parse.readstop 0 0
    store    u64   .p 
    jump           #6091 
#6156:
    setcall        0
    callf    u64   mm_parse.readprint 0 0
    store    u64   .p 
    jump           #6091 
#6157:
    setcall        0
    callf    u64   mm_parse.readread 0 0
    store    u64   .p 
    jump           #6091 
#6158:
    setcall        1
    loadimm  i64   13 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .q 
    setcall        1
    loadimm  i64   14 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        3
    load     u64   .q 
    setarg   u64   3
    load     u64   .p 
    setarg   u64   2
    loadimm  i64   109 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .p 
    jump           #6091 
#6159:
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   2
    loadimm  i64   123 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    load     i64   .opc 
    load     u64   .p 
    loadimm  i64   40 
    istorex  i32   1 0
    jump           #6091 
#6160:
    loadimm  i64   1 
    load     u64   mm_decls.currproc 
    loadimm  i64   112 
    istorex  u8    1 0
    loadimm  i64   1 
    store    i64   mm_decls.assemmode 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpne   i64   #6162 
    setcall        0
    callf    u64   mm_assem.readassemline 0 0
    store    u64   .p 
    jump           #6161 
#6162:
    setcall        0
    callf    u64   mm_assem.readassemblock 0 0
    store    u64   .p 
#6161:
    loadimm  i64   0 
    store    i64   mm_decls.assemmode 
    jump           #6091 
#6163:
    setcall        1
    loadimm  i64   90 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    loadref  u64   mm_decls.lx 
    loadimm  i64   1 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  i16   1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6091 
#6164:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setarg   u64   2
    loadimm  i64   10 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    jump           #6091 
#6165:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setarg   u64   2
    loadimm  i64   124 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    jump           #6091 
#6166:
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        2
    setcall        0
    callf    u64   mm_parse.readterm2 0 0
    setarg   u64   2
    loadimm  i64   28 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    store    u64   .p 
    jump           #6091 
#6167:
    setcall        1
    loadimm  u64   "{...} not ready"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #6091 
#6093:
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_tables.symbolnames 
    loadref  u64   mm_decls.lx 
    iload    u8    
    iloadx   u64   8 -8
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "LX.SYMBOL="
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    callp          msys.m$print_i64_nf 1 0
    setcall        0
    callf    i64   mm_parse.istypestarter 0 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "readterm?"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6091:
    load     i64   .pos 
    load     u64   .p 
    loadimm  i64   4 
    istorex  u32   1 0
    load     u64   .p 
    setret   u64   
    jump           #6090 
;------------------------
#6090:
    return         
end

proc mm_parse.readmacrodef
    param    u64   .owner 
    param    i64   .scope 
    local    u64   .nameptr 
    local    u64   .stmacro 
    local    u64   .paramlist 
    local    u64   .paramlistx 
    local    u64   .stname 
;------------------------
    setcall        1
    loadimm  i64   80 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .nameptr 
    setcall        3
    loadimm  i64   18 
    setarg   i64   3
    load     u64   .nameptr 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stmacro 
    setcall        2
    load     u64   .stmacro 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    load     u64   .stmacro 
    store    u64   .owner 
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  u64   0 
    double         
    store    u64   .paramlistx 
    store    u64   .paramlist 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #6173 
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #6175 
#6176:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpeq   i64   #6179 
    jump           #6180 
#6179:
    setcall        3
    loadimm  i64   19 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        3
    load     u64   .stname 
    setarg   u64   3
    loadref  u64   .paramlistx 
    setarg   u64   2
    loadref  u64   .paramlist 
    setarg   u64   1
    callp          mm_parse.addlistparam 3 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpne   i64   #6182 
    jump           #6177 
#6182:
#6181:
    setcall        1
    loadimm  i64   5 
    setarg   i64   1
    callp          mm_parse.checksymbol 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6178 
#6180:
    setcall        1
    loadimm  u64   "macro def params"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6178:
    jump           #6176 
#6177:
#6175:
#6174:
    setcall        0
    callp          mm_lex.lex 0 0
#6173:
#6172:
    load     u64   .paramlist 
    load     u64   .stmacro 
    loadimm  i64   104 
    istorex  u64   1 0
    load     i64   .scope 
    load     u64   .stmacro 
    loadimm  i64   191 
    istorex  u8    1 0
    setcall        0
    callp          mm_parse.checkequals 0 0
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    load     u64   .stmacro 
    loadimm  i64   56 
    istorex  u64   1 0
;------------------------
#6171:
    return         
end

proc mm_parse.readrecase
    rettype  u64   
;------------------------
    setcall        0
    callp          mm_lex.lex 0 0
    startmx        
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   100 
    jumpne   i64   #6186 
    setcall        0
    callp          mm_lex.lex 0 0
    setcall        1
    loadimm  i64   111 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    resetmx        
    jump           #6185 
#6186:
    setcall        2
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    setarg   u64   2
    loadimm  i64   111 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    endmx          
#6185:
    setret   u64   
    jump           #6184 
;------------------------
#6184:
    return         
end

proc mm_parse.adddocstring
    param    u64   .s 
;------------------------
    load     i64   mm_decls.ndocstrings 
    loadimm  i64   20 
    jumple   i64   #6189 
    setcall        1
    loadimm  u64   "Too many docstrings"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6189:
#6188:
    setcall        2
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstringn 2 0
    loadref  u64   mm_decls.docstrings 
    loadref  u64   mm_decls.ndocstrings 
    incrload i64   1
    istorex  u64   8 -8
;------------------------
#6187:
    return         
end

proc mm_parse.fixcond
    rettype  u64   
    param    u64   .p 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   4 
    jumpne   i64   #6193 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #6193 
    setcall        1
    loadimm  u64   "Empty cond"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6193:
#6192:
    loadref  u64   mm_tables.isbooltag 
    load     u64   .p 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #6196 
    setcall        2
    loadimm  i64   15 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadimm  i64   103 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
#6196:
#6195:
    load     u64   .p 
    setret   u64   
    jump           #6191 
;------------------------
#6191:
    return         
end

proc mm_parse.readsunit
    rettype  u64   
    param    i64   .inwhile 
    local    i64   .pos 
    local    i64   .m 
    local    i64   .sym 
    local    i64   .opc 
    local    u64   .ulist 
    local    u64   .ulistx 
    local    u64   .p 
    local    u64   .q 
    local    u64   .r 
    local    u64   .stname 
;------------------------
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    loadimm  u64   0 
    double         
    store    u64   .ulistx 
    store    u64   .ulist 
#6198:
    jump           #6202 
#6201:
    setcall        0
    callp          mm_lex.lex 0 0
#6202:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpeq   i64   #6201 
#6203:
    loadref  u64   mm_decls.lx 
    iload    u8    
    switch         #6205 6 156
    opnd           #6206 
#6205:
    swlabel        #6240 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6231 
    swlabel        #6212 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6229 
    swlabel        #6206 
    swlabel        #6226 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6232 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6212 
    swlabel        #6212 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6212 
    swlabel        #6206 
    swlabel        #6231 
    swlabel        #6231 
    swlabel        #6231 
    swlabel        #6231 
    swlabel        #6231 
    swlabel        #6206 
    swlabel        #6231 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6231 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6237 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6231 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6241 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6211 
    swlabel        #6211 
    swlabel        #6206 
    swlabel        #6225 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6223 
    swlabel        #6212 
    swlabel        #6219 
    swlabel        #6219 
    swlabel        #6212 
    swlabel        #6218 
    swlabel        #6212 
    swlabel        #6227 
    swlabel        #6224 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6207 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6206 
    swlabel        #6228 
    endsw          
#6207:
    setcall        0
    callp          mm_lex.lex 0 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   139 
    jumpeq   i64   #6210 1
    loadimm  i64   138 
    jumpne   i64   #6209 
#6210:
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .opc 
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6208 
#6209:
    loadimm  i64   0 
    store    i64   .opc 
#6208:
    setcall        4
    load     i64   .opc 
    setarg   i64   4
    loadimm  i64   11 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_parse.readvardef 4 0
    unload   u64   
    jump           #6204 
#6211:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_parse.readprocdef 3 0
    jump           #6204 
#6212:
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   13 
    jumpeq   i64   #6215 1
    loadimm  i64   22 
    jumpeq   i64   #6215 1
    loadimm  i64   2 
    jumpne   i64   #6214 
#6215:
    jump           #6216 
    jump           #6213 
#6214:
    loadimm  i64   0 
    store    i64   .sym 
    jump           #6217 
#6213:
    jump           #6204 
#6218:
    setcall        1
    loadimm  i64   15 
    setarg   i64   1
    callp          mm_parse.lexchecksymbol 1 0
    loadimm  i64   0 
    store    i64   .sym 
    jump           #6217 
    jump           #6204 
#6219:
    loadref  u64   mm_decls.lx 
    iload    u8    
    store    i64   .sym 
    setcall        0
    callp          mm_lex.lex 0 0
;dovar::
#6217:
    setcall        4
    load     i64   .sym 
    setarg   i64   4
    loadimm  i64   12 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_parse.readvardef 4 0
    store    u64   .q 
    jump           #6221 
#6220:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
    loadimm  u64   0 
    load     u64   .q 
    loadimm  i64   8 
    istorex  u64   1 0
    setcall        3
    load     u64   .q 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    load     u64   .r 
    store    u64   .q 
#6221:
    load     u64   .q 
    jumpt    u64   #6220 
#6222:
    jump           #6204 
#6223:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_parse.readtypedef 2 0
    jump           #6204 
#6224:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_parse.readconstdef 2 0
    jump           #6204 
#6225:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_parse.readclassdef 2 0
    jump           #6204 
#6226:
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_parse.adddocstring 1 0
    setcall        0
    callp          mm_lex.lex 0 0
    jump           #6204 
#6227:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_parse.readmacrodef 2 0
    jump           #6204 
#6228:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_parse.readtabledef 2 0
    jump           #6204 
#6229:
    callp          msys.m$print_startcon 0 0
    load     u64   mm_decls.currproc 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "Unexpected EOF in proc"
    setarg   u64   1
    callp          mm_support.serror 1 0
    jump           #6204 
#6231:
    jump           #6200 
    jump           #6204 
#6232:
    loadref  u64   mm_decls.nextlx 
    iload    u8    
    loadimm  i64   8 
    jumpeq   i64   #6234 1
    loadimm  i64   80 
    jumpeq   i64   #6235 
    jump           #6236 
#6234:
    setcall        1
    loadimm  i64   100 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .p 
    setcall        3
    loadimm  i64   17 
    setarg   i64   3
    loadref  u64   mm_decls.lx 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stname 
    setcall        2
    load     u64   .stname 
    setarg   u64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    load     u64   .stname 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    setcall        0
    callp          mm_lex.lex 0 0
    loadimm  i64   6 
    loadref  u64   mm_decls.lx 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    jump           #6233 
#6235:
    loadimm  i64   138 
    store    i64   .sym 
    jump           #6217 
    jump           #6216 
    jump           #6233 
#6236:
    jump           #6216 
#6233:
    jump           #6204 
#6237:
    load     i64   .inwhile 
    jumpf    i64   #6239 
    jump           #6200 
#6239:
#6238:
    jump           #6216 
    jump           #6204 
#6240:
    jump           #6204 
#6241:
    jump           #6200 
    jump           #6204 
#6206:
;doexec::
#6216:
    setcall        0
    callf    u64   mm_parse.readunit 0 0
    store    u64   .p 
;doexec2::
#6242:
    load     u64   .p 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #6244 
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   80 
    jumpne   i64   #6244 
    setcall        1
    loadimm  u64   "Possibly var/let needed"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6244:
#6243:
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   113 
    jumpne   i64   #6247 
    jump           #6200 
#6247:
#6246:
#6204:
#6199:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   6 
    jumpeq   i64   #6198 
#6200:
    loadref  u64   mm_decls.lx 
    iload    u8    
    loadimm  i64   14 
    jumpeq   i64   #6249 1
    loadimm  i64   98 
    jumpeq   i64   #6249 1
    loadimm  i64   99 
    jumpeq   i64   #6249 1
    loadimm  i64   100 
    jumpeq   i64   #6249 1
    loadimm  i64   116 
    jumpeq   i64   #6249 1
    loadimm  i64   109 
    jumpeq   i64   #6249 1
    loadimm  i64   113 
    jumpeq   i64   #6249 1
    loadimm  i64   101 
    jumpeq   i64   #6249 1
    loadimm  i64   102 
    jumpeq   i64   #6249 1
    loadimm  i64   104 
    jumpeq   i64   #6249 1
    loadimm  i64   5 
    jumpeq   i64   #6249 1
    loadimm  i64   20 
    jumpeq   i64   #6249 1
    loadimm  i64   120 
    jumpeq   i64   #6249 
    jump           #6250 
#6249:
    jump           #6248 
#6250:
    setcall        1
    loadimm  u64   "Readsunit: \";\" expected, or bad unit starter"
    setarg   u64   1
    callp          mm_support.serror 1 0
#6248:
    startmx        
    load     u64   .ulist 
    loadimm  u64   0 
    jumpeq   u64   #6254 
    load     u64   .ulist 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #6253 
#6254:
    setcall        2
    load     u64   .ulist 
    setarg   u64   2
    loadimm  i64   4 
    setarg   i64   1
    callf    u64   mm_lib.createunit1 2 0
    resetmx        
    jump           #6252 
#6253:
    load     u64   .ulist 
    endmx          
#6252:
    setret   u64   
    jump           #6197 
;------------------------
#6197:
    return         
end

proc mm_support.loadsourcefile
    rettype  i64   
    param    u64   .filespec 
    local    u64   .s 
    local    u64   .basefilename 
;------------------------
    load     i64   mm_decls.nsourcefiles 
    loadimm  i64   1000 
    jumple   i64   #6257 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Too many source files"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#6257:
#6256:
    setcall        1
    load     u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.extractfile 1 0
    store    u64   .basefilename 
    loadref  u64   mm_decls.nsourcefiles 
    incrto   i64   1
    setcall        1
    load     u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    loadref  u64   mm_decls.sourcefilespecs 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    setcall        1
    setcall        1
    load     u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.extractpath 1 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    loadref  u64   mm_decls.sourcefilepaths 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    setcall        1
    load     u64   .basefilename 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    setcall        1
    load     u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.readfile 1 0
    store    u64   .s 
    load     u64   .s 
    jumpt    u64   #6261 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    load     u64   .filespec 
    setarg   u64   2
    loadimm  u64   "LSF can't load "
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#6261:
#6260:
    load     u64   .s 
    loadref  u64   mm_decls.sourcefiletext 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
    load     u8    mm_decls.fwritema 
    jumpf    i64   #6265 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    loadref  u64   mm_decls.sourcefiledupl 
    load     i64   mm_decls.nsourcefiles 
    istorex  u64   8 0
#6265:
#6264:
    load     i64   mlib.rfsize 
    loadref  u64   mm_decls.sourcefilesizes 
    load     i64   mm_decls.nsourcefiles 
    istorex  i64   8 0
    loadimm  u64   0 
    load     u64   .s 
    load     i64   mlib.rfsize 
    addptrx  u64   1 0
    istore   u8    
    load     i64   mm_decls.nsourcefiles 
    setret   i64   
    jump           #6255 
;------------------------
#6255:
    return         
end

proc mm_support.loadbundledfile
    rettype  i64   
    param    u64   .filespec 
    param    i64   .issyslib 
    param    i64   .support 
    local    i64   .fileno 
    local    u64   .file 
    local    i64   .i 
;------------------------
    setcall        1
    load     u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.extractfile 1 0
    store    u64   .file 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nsourcefiles 
    loadimm  i64   1 
    jumplt   i64   #6269 
#6267:
    setcall        2
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   .i 
    iloadx   u64   8 0
    setarg   u64   2
    load     u64   .file 
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #6271 
    load     i64   .support 
    loadref  u64   mm_decls.sourcefilesupport 
    load     i64   .i 
    iloadx   u8    1 0
    jumpne   i64   #6271 
    load     i64   .i 
    setret   i64   
    jump           #6266 
#6271:
#6270:
#6268:
    forup          #6267 1
    opnd           .i 
    opnd           mm_decls.nsourcefiles 
#6269:
    setcall        1
    load     u64   .file 
    setarg   u64   1
    callf    i64   mm_libsources.findsyslib 1 0
    store    i64   .fileno 
    load     i64   .fileno 
    jumpf    i64   #6273 
    load     i64   .fileno 
    setret   i64   
    jump           #6266 
#6273:
#6272:
    load     i64   .issyslib 
    jumpt    i64   #6275 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    load     u64   .filespec 
    setarg   u64   2
    loadimm  u64   "Can't find bundled file: ##"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#6275:
#6274:
    loadimm  i64   0 
    setret   i64   
    jump           #6266 
;------------------------
#6266:
    return         
end

proc mm_support.mcerror
    param    u64   .mess 
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "MC Error:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .mess 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           1
;------------------------
#6278:
    return         
end

proc mm_support.serror_gen
    param    u64   .mess 
;------------------------
    setcall        1
    loadimm  u64   42 
    setarg   u64   1
    callp          mm_support.showdivider 1 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Syntax Error:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    load     u64   mm_decls.currproc 
    setarg   u64   2
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    setarg   i64   1
    callp          mm_support.showerrorsource 2 0
    callp          msys.m$print_startcon 0 0
    load     u64   .mess 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    setarg   i64   2
    loadref  u64   mm_decls.sourcefilespecs 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    loadimm  i64   24 
    loadimm  i64   31 
    loadbf         
    iloadx   u64   8 0
    setarg   u64   1
    callp          mm_support.stopcompiler 2 0
;------------------------
#6280:
    return         
end

proc mm_support.showdivider
    param    u64   .ch 
    local    i64   .$av_1 
;------------------------
    loadimm  i64   87 
    store    i64   .$av_1 
#6283:
    callp          msys.m$print_startcon 0 0
    loadimm  i64   0 
    load     u64   .ch 
    callp          msys.m$print_c8 2 0
    callp          msys.m$print_end 0 0
#6284:
    to             #6283 
    opnd           .$av_1 
#6285:
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;------------------------
#6282:
    return         
end

proc mm_support.showerrorsource
    param    i64   .pos 
    param    u64   .stproc 
    local    i64   .fileno 
    local    i64   .lineoffset 
    local    u64   .errorline 
    local    u64   .s 
    local    i64   .$av_1 
    local    i64   .$av_2 
    local    i64   .$av_3 
;------------------------
    setcall        1
    load     i64   .pos 
    setarg   u64   1
    callf    i64   mm_support.getfileno 1 0
    store    i64   .fileno 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "    Line:     #"
    callp          msys.m$print_setfmt 1 0
    setcall        1
    load     i64   .pos 
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .stproc 
    jumpf    u64   #6289 
    load     u64   .stproc 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpne   i64   #6289 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "    Function: #()"
    callp          msys.m$print_setfmt 1 0
    load     u64   .stproc 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#6289:
#6288:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "    Module:   # (#)"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   .fileno 
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.sourcefilespecs 
    load     i64   .fileno 
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   45 
    setarg   u64   1
    callp          mm_support.showdivider 1 0
    setcall        1
    load     i64   .pos 
    setarg   u64   1
    callf    u64   mm_support.getsourceline 1 0
    double         
    store    u64   .errorline 
    store    u64   .s 
    setcall        1
    load     i64   .pos 
    setarg   u64   1
    callf    u64   mm_support.getsourcepos 1 0
    load     u64   .errorline 
    subptr   u64   1
    store    i64   .lineoffset 
    loadimm  i64   6 
    store    i64   .$av_1 
#6292:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   " "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#6293:
    to             #6292 
    opnd           .$av_1 
#6294:
    jump           #6297 
#6296:
    callp          msys.m$print_startcon 0 0
    loadimm  i64   0 
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    callp          msys.m$print_c8 2 0
    callp          msys.m$print_end 0 0
#6297:
    load     u64   .s 
    iload    u8    
    loadimm  i64   10 
    jumpeq   u64   #6299 1
    loadimm  i64   0 
    jumpne   u64   #6296 
#6299:
#6298:
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .errorline 
    store    u64   .s 
    loadimm  i64   6 
    store    i64   .$av_2 
#6300:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   " "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#6301:
    to             #6300 
    opnd           .$av_2 
#6302:
    load     i64   .lineoffset 
    store    i64   .$av_3 
    load     i64   .$av_3 
    loadimm  i64   0 
    jumple   i64   #6305 
#6303:
    load     u64   .s 
    iload    u8    
    loadimm  i64   9 
    jumpne   i64   #6307 
    callp          msys.m$print_startcon 0 0
    loadimm  i64   0 
    loadimm  u64   9 
    callp          msys.m$print_c8 2 0
    callp          msys.m$print_end 0 0
    jump           #6306 
#6307:
    callp          msys.m$print_startcon 0 0
    loadimm  i64   0 
    loadimm  u64   32 
    callp          msys.m$print_c8 2 0
    callp          msys.m$print_end 0 0
#6306:
    loadref  u64   .s 
    incrto   u64   1
#6304:
    to             #6303 
    opnd           .$av_3 
#6305:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "^"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   45 
    setarg   u64   1
    callp          mm_support.showdivider 1 0
;------------------------
#6286:
    return         
end

proc mm_support.stopcompiler
    param    u64   .filename 
    param    i64   .lineno 
    local    u64   .f 
;------------------------
    setcall        2
    loadimm  u64   "w"
    setarg   u64   2
    loadimm  u64   "$error.tmp"
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   .filename 
    callp          msys.m$print_str_nf 1 0
    load     i64   .lineno 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           1
;------------------------
#6309:
    return         
end

proc mm_support.serror
    param    u64   .mess 
;------------------------
    setcall        1
    load     u64   .mess 
    setarg   u64   1
    callp          mm_support.serror_gen 1 0
;------------------------
#6312:
    return         
end

proc mm_support.serror_s
    param    u64   .mess 
    param    u64   .a 
    local    u8:256 .str 
;------------------------
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .mess 
    callp          msys.m$print_setfmt 1 0
    load     u64   .a 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callp          mm_support.serror_gen 1 0
;------------------------
#6313:
    return         
end

proc mm_support.error_gen
    param    i64   .pass 
    param    u64   .mess 
    param    u64   .p 
    local    i64   .pos 
;------------------------
    load     u64   .p 
    jumpf    u64   #6316 
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   .pos 
    jump           #6315 
#6316:
    load     i64   mm_tables.mlineno 
    store    i64   .pos 
#6315:
    setcall        1
    loadimm  u64   42 
    setarg   u64   1
    callp          mm_support.showdivider 1 0
    load     i64   .pass 
    loadimm  i64   78 
    jumpeq   i64   #6318 1
    loadimm  i64   84 
    jumpeq   i64   #6319 1
    loadimm  i64   71 
    jumpeq   i64   #6320 1
    loadimm  i64   65 
    jumpeq   i64   #6321 
    jump           #6322 
#6318:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "RX Name Error: "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #6317 
#6319:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "TX Type Error: "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #6317 
#6320:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "GX Code Gen Error: "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #6317 
#6321:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "AX Code Gen Error: "
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #6317 
#6322:
#6317:
    setcall        2
    load     u64   mm_decls.currproc 
    setarg   u64   2
    load     i64   .pos 
    setarg   i64   1
    callp          mm_support.showerrorsource 2 0
    callp          msys.m$print_startcon 0 0
    load     u64   .mess 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    setcall        1
    load     i64   .pos 
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    setarg   i64   2
    loadref  u64   mm_decls.sourcefilespecs 
    setcall        1
    load     i64   .pos 
    setarg   u64   1
    callf    i64   mm_support.getfileno 1 0
    iloadx   u64   8 0
    setarg   u64   1
    callp          mm_support.stopcompiler 2 0
;------------------------
#6314:
    return         
end

proc mm_support.rxerror
    param    u64   .mess 
    param    u64   .p 
;------------------------
    setcall        3
    load     u64   .p 
    setarg   u64   3
    load     u64   .mess 
    setarg   u64   2
    loadimm  i64   78 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
;------------------------
#6327:
    return         
end

proc mm_support.gerror
    rettype  i64   
    param    u64   .mess 
    param    u64   .p 
;------------------------
    setcall        3
    load     u64   .p 
    setarg   u64   3
    load     u64   .mess 
    setarg   u64   2
    loadimm  i64   71 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
    loadimm  i64   0 
    setret   i64   
    jump           #6328 
;------------------------
#6328:
    return         
end

proc mm_support.axerror
    param    u64   .mess 
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "ALINENO="
    callp          msys.m$print_str_nf 1 0
    load     i64   mc_decls.alineno 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .mess 
    setarg   u64   2
    loadimm  i64   65 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
;------------------------
#6329:
    return         
end

proc mm_support.txerror
    param    u64   .mess 
    param    u64   .p 
;------------------------
    setcall        3
    load     u64   .p 
    setarg   u64   3
    load     u64   .mess 
    setarg   u64   2
    loadimm  i64   84 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
;------------------------
#6331:
    return         
end

proc mm_support.txerror_s
    param    u64   .mess 
    param    u64   .a 
    param    u64   .p 
    local    u8:256 .str 
;------------------------
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .mess 
    callp          msys.m$print_setfmt 1 0
    load     u64   .a 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    loadimm  i64   84 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
;------------------------
#6332:
    return         
end

proc mm_support.txerror_ss
    param    u64   .mess 
    param    u64   .a 
    param    u64   .b 
    local    u8:256 .str 
;------------------------
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .mess 
    callp          msys.m$print_setfmt 1 0
    load     u64   .a 
    callp          msys.m$print_str_nf 1 0
    load     u64   .b 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    loadimm  i64   84 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
;------------------------
#6333:
    return         
end

proc mm_support.rxerror_s
    param    u64   .mess 
    param    u64   .a 
    param    u64   .p 
    local    u8:256 .str 
;------------------------
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .mess 
    callp          msys.m$print_setfmt 1 0
    load     u64   .a 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    loadimm  i64   78 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
;------------------------
#6334:
    return         
end

proc mm_support.gerror_s
    param    u64   .mess 
    param    u64   .s 
    param    u64   .p 
    local    u8:256 .str 
;------------------------
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .mess 
    callp          msys.m$print_setfmt 1 0
    load     u64   .s 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    loadimm  i64   71 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
;------------------------
#6335:
    return         
end

proc mm_support.gerror_t
    param    u64   .mess 
    param    u64   .p 
    local    u8:256 .str 
;------------------------
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .mess 
    callp          msys.m$print_setfmt 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        3
    load     u64   .p 
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    loadimm  i64   71 
    setarg   i64   1
    callp          mm_support.error_gen 3 0
;------------------------
#6336:
    return         
end

proc mm_support.lxerror_gen
    param    u64   .mess 
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "On line"
    callp          msys.m$print_str_nf 1 0
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   "in file"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.sourcefilespecs 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    loadimm  i64   24 
    loadimm  i64   31 
    loadbf         
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "**** Lex Error:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .mess 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "****"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    setcall        1
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    setarg   u64   1
    callf    i64   mm_support.getlineno 1 0
    setarg   i64   2
    loadref  u64   mm_decls.sourcefilespecs 
    loadref  u64   mm_decls.lx 
    loadimm  i64   4 
    iloadx   u32   1 0
    loadimm  i64   24 
    loadimm  i64   31 
    loadbf         
    iloadx   u64   8 0
    setarg   u64   1
    callp          mm_support.stopcompiler 2 0
;------------------------
#6337:
    return         
end

proc mm_support.lxerror
    param    u64   .mess 
;------------------------
    setcall        1
    load     u64   .mess 
    setarg   u64   1
    callp          mm_support.lxerror_gen 1 0
;------------------------
#6342:
    return         
end

proc mm_support.loaderror
    param    u64   .mess 
    param    u64   .mess2 
    param    u64   .mess3 
    local    u8:512 .str 
;------------------------
    setcall        2
    loadimm  u64   35 
    setarg   i32   2
    load     u64   .mess 
    setarg   u64   1
    callf    u64   strchr 2 0
    jumpf    u64   #6345 
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .mess 
    callp          msys.m$print_setfmt 1 0
    load     u64   .mess2 
    callp          msys.m$print_str_nf 1 0
    load     u64   .mess3 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    jump           #6344 
#6345:
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    load     u64   .mess 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
#6344:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Load Error:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   .str 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Stopping"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           1
;------------------------
#6343:
    return         
end

proc mm_support.gs_additem
    param    u64   .dest 
    param    u64   .s 
    local    u64   .d 
    local    i64   .lastchar 
    local    i64   .nextchar 
;------------------------
    load     u64   .dest 
    iload    u64   
    store    u64   .d 
    load     u64   .dest 
    loadimm  i64   8 
    iloadx   i32   1 0
    jumpf    i64   #6350 
    load     u64   .d 
    load     u64   .dest 
    loadimm  i64   8 
    iloadx   i32   1 0
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    iload    u8    
    store    i64   .lastchar 
    load     u64   .s 
    iload    u8    
    store    i64   .nextchar 
    setcall        1
    load     i64   .lastchar 
    setarg   i64   1
    callf    i64   mm_support.isalphanum 1 0
    jumpf    i64   #6352 
    setcall        1
    load     i64   .nextchar 
    setarg   i64   1
    callf    i64   mm_support.isalphanum 1 0
    jumpf    i64   #6352 
    setcall        3
    loadimm  i64   -1 
    setarg   i64   3
    loadimm  u64   " "
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
#6352:
#6351:
#6350:
#6349:
    setcall        3
    loadimm  i64   -1 
    setarg   i64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
;------------------------
#6348:
    return         
end

proc mm_support.gs_copytostr
    param    u64   .source 
    param    u64   .s 
;------------------------
    load     u64   .source 
    loadimm  i64   8 
    iloadx   i32   1 0
    jumpf    i64   #6356 
    setcall        3
    load     u64   .source 
    loadimm  i64   8 
    iloadx   i32   1 0
    setarg   u64   3
    load     u64   .source 
    iload    u64   
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   .s 
    load     u64   .source 
    loadimm  i64   8 
    iloadx   i32   1 0
    addptrx  u64   1 0
    istore   u8    
    jump           #6355 
#6356:
    loadimm  u64   0 
    load     u64   .s 
    istore   u8    
#6355:
;------------------------
#6354:
    return         
end

proc mm_support.isalphanum
    rettype  i64   
    param    i64   .c 
;------------------------
    load     i64   .c 
    loadimm  i64   65 
    jumplt   i64   #6361 
    load     i64   .c 
    loadimm  i64   90 
    jumple   i64   #6360 
#6361:
    load     i64   .c 
    loadimm  i64   97 
    jumplt   i64   #6362 
    load     i64   .c 
    loadimm  i64   122 
    jumple   i64   #6360 
#6362:
    load     i64   .c 
    loadimm  i64   48 
    jumplt   i64   #6359 
    load     i64   .c 
    loadimm  i64   57 
    jumpgt   i64   #6359 
#6360:
    loadimm  i64   1 
    setret   i64   
    jump           #6357 
#6359:
#6358:
    loadimm  i64   0 
    setret   i64   
    jump           #6357 
;------------------------
#6357:
    return         
end

proc mm_support.init_tt_tables
    local    i64   .i 
    local    i64   .size 
    local    i64   .bitsize 
    local    i64   .s 
    local    i64   .t 
    local    i64   .u 
    local    i64   .v 
    local    i64   .$av_1 
;------------------------
    loadimm  i64   0 
    store    i64   .i 
#6364:
    loadref  u64   mm_tables.stdnames 
    load     i64   .i 
    iloadx   u64   8 0
    loadref  u64   ttname 
    load     i64   .i 
    istorex  u64   8 0
    load     i64   .i 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .i 
    istorex  i32   4 0
    loadref  u64   mm_tables.stdbits 
    load     i64   .i 
    iloadx   u8    1 0
    store    i64   .bitsize 
    load     i64   .bitsize 
    switch         #6368 0 4
    opnd           #6369 
#6368:
    swlabel        #6370 
    swlabel        #6371 
    swlabel        #6371 
    swlabel        #6369 
    swlabel        #6371 
    endsw          
#6370:
    loadimm  i64   0 
    store    i64   .size 
    jump           #6367 
#6371:
    loadimm  i64   1 
    store    i64   .size 
    jump           #6367 
#6369:
    load     i64   .bitsize 
    loadimm  i64   8 
    div      i64   
    store    i64   .size 
#6367:
    load     i64   .size 
    loadref  u64   mm_decls.ttsize 
    load     i64   .i 
    istorex  u32   4 0
    load     i64   .i 
    loadimm  i64   15 
    jumpeq   i64   #6373 1
    loadimm  i64   16 
    jumpeq   i64   #6373 1
    loadimm  i64   17 
    jumpeq   i64   #6373 1
    loadimm  i64   3 
    jumpeq   i64   #6373 1
    loadimm  i64   18 
    jumpeq   i64   #6374 1
    loadimm  i64   19 
    jumpeq   i64   #6374 1
    loadimm  i64   20 
    jumpeq   i64   #6374 1
    loadimm  i64   2 
    jumpeq   i64   #6374 1
    loadimm  i64   13 
    jumpeq   i64   #6374 1
    loadimm  i64   1 
    jumpeq   i64   #6374 1
    loadimm  i64   4 
    jumpeq   i64   #6375 1
    loadimm  i64   5 
    jumpeq   i64   #6375 1
    loadimm  i64   7 
    jumpeq   i64   #6376 1
    loadimm  i64   21 
    jumpeq   i64   #6376 
    jump           #6377 
#6373:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttsigned 
    load     i64   .i 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .i 
    istorex  u8    1 0
    jump           #6372 
#6374:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .i 
    istorex  u8    1 0
    jump           #6372 
#6375:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisreal 
    load     i64   .i 
    istorex  u8    1 0
    jump           #6372 
#6376:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisref 
    load     i64   .i 
    istorex  u8    1 0
    jump           #6372 
#6377:
#6372:
    load     i64   .i 
    loadimm  i64   15 
    jumpeq   i64   #6379 1
    loadimm  i64   16 
    jumpeq   i64   #6379 1
    loadimm  i64   17 
    jumpeq   i64   #6379 1
    loadimm  i64   18 
    jumpeq   i64   #6379 1
    loadimm  i64   19 
    jumpeq   i64   #6379 1
    loadimm  i64   20 
    jumpeq   i64   #6379 1
    loadimm  i64   13 
    jumpeq   i64   #6379 
    jump           #6380 
#6379:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisshort 
    load     i64   .i 
    istorex  u8    1 0
    jump           #6378 
#6380:
#6378:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttlower 
    load     i64   .i 
    istorex  i32   4 0
    load     i64   .i 
    loadimm  i64   10 
    jumpeq   i64   #6382 1
    loadimm  i64   8 
    jumpeq   i64   #6382 1
    loadimm  i64   11 
    jumpeq   i64   #6382 1
    loadimm  i64   12 
    jumpeq   i64   #6382 1
    loadimm  i64   9 
    jumpeq   i64   #6382 
    jump           #6383 
#6382:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .i 
    istorex  u8    1 0
    jump           #6381 
#6383:
#6381:
#6365:
    forup          #6364 1
    opnd           .i 
    opnd           29 
#6366:
    loadimm  i64   7 
    loadref  u64   mm_decls.ttbasetype 
    loadimm  i64   21 
    istorex  i32   4 0
    loadimm  i64   13 
    loadref  u64   mm_decls.tttarget 
    loadimm  i64   21 
    istorex  i32   4 0
    loadimm  i64   29 
    store    i64   mm_decls.ntypes 
;------------------------
#6363:
    return         
end

proc mm_support.addspecialtypes
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   24 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    store    i64   mm_tables.trefproc 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   25 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    store    i64   mm_tables.treflabel 
;------------------------
#6384:
    return         
end

proc mm_support.getsupportfile
    rettype  i64   
    param    u64   .filename 
    param    u64   .ext 
    param    u64   .path 
    param    i64   .issyslib 
    param    i64   .issupport 
    local    u8:300 .filespec 
    local    u8:300 .filespec2 
    local    u64   .file 
    local    i64   .fileno 
;------------------------
    load     u64   .filename 
    store    u64   .file 
    load     i64   mm_decls.fverbose 
    loadimm  i64   3 
    jumpne   i64   #6387 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Get file:# (ext:#) (path:#)"
    callp          msys.m$print_setfmt 1 0
    load     u64   .filename 
    callp          msys.m$print_str_nf 1 0
    load     u64   .ext 
    callp          msys.m$print_str_nf 1 0
    load     u64   .path 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#6387:
#6386:
    load     u64   .ext 
    iload    u8    
    jumpf    u64   #6390 
    setcall        2
    setcall        2
    load     u64   .ext 
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   mlib.addext 2 0
    setarg   u64   2
    loadref  u64   .filespec 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadref  u64   .filespec 
    store    u64   .file 
#6390:
#6389:
    load     u8    mm_decls.freadma 
    jumpf    i64   #6392 
    setcall        3
    load     i64   .issupport 
    setarg   i64   3
    load     i64   .issyslib 
    setarg   i64   2
    load     u64   .file 
    setarg   u64   1
    callf    i64   mm_support.loadbundledfile 3 0
    store    i64   .fileno 
    load     i64   .fileno 
    jumpf    i64   #6394 
    load     i64   .fileno 
    setret   i64   
    jump           #6385 
#6394:
#6393:
#6392:
#6391:
    load     i64   .issyslib 
    jumpf    i64   #6396 
    load     u8    mm_decls.dointlibs 
    jumpf    i64   #6396 
    setcall        1
    load     u64   .file 
    setarg   u64   1
    callf    i64   mm_libsources.findsyslib 1 0
    store    i64   .fileno 
    load     i64   mm_decls.fverbose 
    loadimm  i64   3 
    jumpne   i64   #6398 
    load     i64   .fileno 
    jumpf    i64   #6398 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Found in syslib: #"
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   .fileno 
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#6398:
#6397:
    load     i64   .fileno 
    jumpf    i64   #6401 
    load     i64   .fileno 
    setret   i64   
    jump           #6385 
#6401:
#6400:
#6396:
#6395:
    setcall        1
    load     u64   .file 
    setarg   u64   1
    callf    i64   mm_support.isabspath 1 0
    jumpt    i64   #6403 
    setcall        2
    load     u64   .path 
    setarg   u64   2
    loadref  u64   .filespec2 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    load     u64   .file 
    setarg   u64   2
    loadref  u64   .filespec2 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    loadref  u64   .filespec2 
    store    u64   .file 
#6403:
#6402:
    load     i64   mm_decls.fverbose 
    loadimm  i64   3 
    jumpne   i64   #6405 
    load     i64   .fileno 
    jumpf    i64   #6405 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Checkfile:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .file 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#6405:
#6404:
    load     u64   .file 
    loadimm  u64   0 
    jumpeq   u64   #6409 
    setcall        1
    load     u64   .file 
    setarg   u64   1
    callf    i64   mlib.checkfile 1 0
    jumpt    i64   #6408 
#6409:
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    load     u64   .filename 
    setarg   u64   2
    loadimm  u64   "Can't find file: # #"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#6408:
#6407:
    setcall        1
    load     u64   .file 
    setarg   u64   1
    callf    i64   mm_support.loadsourcefile 1 0
    store    i64   .fileno 
    load     i64   mm_decls.fverbose 
    loadimm  i64   3 
    jumpne   i64   #6413 
    load     i64   .fileno 
    jumpf    i64   #6413 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Found:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .file 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#6413:
#6412:
    load     i64   .issupport 
    loadref  u64   mm_decls.sourcefilesupport 
    load     i64   .fileno 
    istorex  u8    1 0
    load     i64   .issyslib 
    loadref  u64   mm_decls.sourcefilesys 
    load     i64   .fileno 
    istorex  u8    1 0
    load     i64   .fileno 
    setret   i64   
    jump           #6385 
;------------------------
#6385:
    return         
end

proc mm_support.isabspath
    rettype  i64   
    param    u64   .filespec 
    local    u64   .path 
;------------------------
    setcall        1
    load     u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.extractpath 1 0
    store    u64   .path 
    load     u64   .path 
    iload    u8    
    loadimm  u64   92 
    jumpeq   u64   #6418 1
    loadimm  u64   47 
    jumpeq   u64   #6418 
    load     u64   .path 
    iload    u8    
    loadimm  i64   0 
    jumpeq   i64   #6417 
    load     u64   .path 
    loadimm  i64   1 
    addptrx  u64   1 0
    iload    u8    
    loadimm  u64   58 
    jumpne   u64   #6417 
#6418:
    loadimm  i64   1 
    setret   i64   
    jump           #6415 
#6417:
#6416:
    loadimm  i64   0 
    setret   i64   
    jump           #6415 
;------------------------
#6415:
    return         
end

proc mm_support.initbblib
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
#6420:
    loadimm  i64   1 
    loadref  u64   mm_decls.typestarterset 
    loadref  u64   mm_tables.d_typestarterset 
    load     i64   .i 
    iloadx   i64   8 -8
    istorex  u8    1 0
#6421:
    forup          #6420 1
    opnd           .i 
    opnd           9 
#6422:
;------------------------
#6419:
    return         
end

proc mm_support.getfileno
    rettype  i64   
    param    u64   .pos 
    local    i64   .fileno 
;------------------------
    load     u64   .pos 
    loadimm  i64   24 
    loadimm  i64   31 
    loadbf         
    store    i64   .fileno 
    load     i64   .fileno 
    loadimm  i64   1 
    jumplt   i64   #6426 
    load     i64   .fileno 
    load     i64   mm_decls.nsourcefiles 
    jumple   i64   #6425 
#6426:
    loadimm  i64   1 
    setret   i64   
    jump           #6423 
#6425:
#6424:
    load     i64   .fileno 
    setret   i64   
    jump           #6423 
;------------------------
#6423:
    return         
end

proc mm_support.getlineno
    rettype  i64   
    param    u64   .pos 
    local    u64   .source 
    local    u64   .sline 
    local    u64   .s 
    local    i64   .lineno 
;------------------------
    setcall        1
    load     u64   .pos 
    setarg   u64   1
    callf    u64   mm_support.getsourcestart 1 0
    store    u64   .source 
    setcall        1
    load     u64   .pos 
    setarg   u64   1
    callf    u64   mm_support.getsourceline 1 0
    store    u64   .sline 
    load     u64   .sline 
    store    u64   .s 
    loadimm  i64   1 
    store    i64   .lineno 
    jump           #6429 
#6428:
    load     u64   .s 
    iload    u8    
    loadimm  i64   10 
    jumpne   i64   #6432 
    loadref  u64   .lineno 
    incrto   i64   1
#6432:
#6431:
    loadref  u64   .s 
    decrto   u64   1
#6429:
    load     u64   .s 
    load     u64   .source 
    jumpge   u64   #6428 
#6430:
    load     i64   .lineno 
    setret   i64   
    jump           #6427 
;------------------------
#6427:
    return         
end

proc mm_support.getsourceline
    rettype  u64   
    param    u64   .pos 
    local    u64   .source 
    local    u64   .s 
;------------------------
    setcall        1
    load     u64   .pos 
    setarg   u64   1
    callf    u64   mm_support.getsourcestart 1 0
    store    u64   .source 
    setcall        1
    load     u64   .pos 
    setarg   u64   1
    callf    u64   mm_support.getsourcepos 1 0
    store    u64   .s 
    jump           #6435 
#6434:
    loadref  u64   .s 
    decrto   u64   1
#6435:
    load     u64   .s 
    load     u64   .source 
    jumplt   u64   #6437 
    load     u64   .s 
    iload    u8    
    loadimm  i64   10 
    jumpne   i64   #6434 
#6437:
#6436:
    load     u64   .s 
    load     u64   .source 
    jumplt   u64   #6439 
    load     u64   .s 
    iload    u8    
    loadimm  i64   10 
    jumpne   i64   #6439 
    loadref  u64   .s 
    incrto   u64   1
#6439:
#6438:
    load     u64   .s 
    setret   u64   
    jump           #6433 
;------------------------
#6433:
    return         
end

proc mm_support.getsourcestart
    rettype  u64   
    param    u64   .pos 
;------------------------
    loadref  u64   mm_decls.sourcefiletext 
    setcall        1
    load     u64   .pos 
    setarg   u64   1
    callf    i64   mm_support.getfileno 1 0
    iloadx   u64   8 0
    setret   u64   
    jump           #6440 
;------------------------
#6440:
    return         
end

proc mm_support.getsourcepos
    rettype  u64   
    param    u64   .pos 
;------------------------
    loadref  u64   mm_decls.sourcefiletext 
    setcall        1
    load     u64   .pos 
    setarg   u64   1
    callf    i64   mm_support.getfileno 1 0
    iloadx   u64   8 0
    load     u64   .pos 
    loadimm  i64   0 
    loadimm  i64   23 
    loadbf         
    addptrx  u64   1 0
    setret   u64   
    jump           #6441 
;------------------------
#6441:
    return         
end

proc mm_support.do_writema
    local    u8:300 .filename 
    local    u8:8000 .sflist 
    local    u64   .f 
    local    i64   .offset 
    local    i64   .nfiles 
    local    i64   .fileno 
    local    i64   .i 
;------------------------
    load     u8    mm_decls.fwritema 
    jumpt    i64   #6444 
    jump           #6442 
#6444:
#6443:
    setcall        2
    setcall        2
    loadimm  u64   "ma"
    setarg   u64   2
    loadref  u64   mm_decls.sourcefilespecs 
    loadimm  i64   1 
    iloadx   u64   8 0
    setarg   u64   1
    callf    u64   mlib.changeext 2 0
    setarg   u64   2
    loadref  u64   .filename 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadimm  i64   0 
    store    i64   .nfiles 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nsourcefiles 
    loadimm  i64   1 
    jumplt   i64   #6448 
#6446:
    loadref  u64   mm_decls.sourcefilesys 
    load     i64   .i 
    iloadx   u8    1 0
    jumpf    i64   #6450 
    load     u8    mm_decls.fwritema 
    loadimm  i64   1 
    jumpne   i64   #6450 
    jump           #6447 
#6450:
#6449:
    load     i64   .i 
    loadref  u64   .sflist 
    loadref  u64   .nfiles 
    incrload i64   1
    istorex  i64   8 -8
#6447:
    forup          #6446 1
    opnd           .i 
    opnd           mm_decls.nsourcefiles 
#6448:
    load     i64   .nfiles 
    loadimm  i64   0 
    jumpne   i64   #6452 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "MA: no files"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#6452:
#6451:
    setcall        2
    loadimm  u64   "wb"
    setarg   u64   2
    loadref  u64   .filename 
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    load     u64   .f 
    jumpt    u64   #6457 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadref  u64   .filename 
    setarg   u64   2
    loadimm  u64   "Can't create MA file #"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#6457:
#6456:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Writing "
    callp          msys.m$print_str_nf 1 0
    loadref  u64   .filename 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "=== MA # ==="
    callp          msys.m$print_setfmt 1 0
    load     i64   .nfiles 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nfiles 
    loadimm  i64   1 
    jumplt   i64   #6464 
#6462:
    loadref  u64   .sflist 
    load     i64   .i 
    iloadx   i64   8 -8
    store    i64   .fileno 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "=== # # # #/# ==="
    callp          msys.m$print_setfmt 1 0
    loadref  u64   mm_decls.sourcefilenames 
    load     i64   .fileno 
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.sourcefilesys 
    load     i64   .fileno 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.sourcefilesupport 
    load     i64   .fileno 
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    load     i64   .i 
    callp          msys.m$print_i64_nf 1 0
    load     i64   .nfiles 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i64   mlib.getfilepos 1 0
    store    i64   .offset 
    setcall        4
    loadref  u64   mm_decls.sourcefilesizes 
    load     i64   .fileno 
    iloadx   i64   8 0
    setarg   i64   4
    load     i64   .offset 
    setarg   i64   3
    loadref  u64   mm_decls.sourcefiledupl 
    load     i64   .fileno 
    iloadx   u64   8 0
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callf    i64   mlib.writerandom 4 0
    unload   i64   
#6463:
    forup          #6462 1
    opnd           .i 
    opnd           .nfiles 
#6464:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "=== END ==="
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nfiles 
    loadimm  i64   1 
    jumplt   i64   #6469 
#6467:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "# # # #"
    callp          msys.m$print_setfmt 1 0
    load     i64   .i 
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.sourcefilenames 
    loadref  u64   .sflist 
    load     i64   .i 
    iloadx   i64   8 -8
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_decls.sourcefilesys 
    loadref  u64   .sflist 
    load     i64   .i 
    iloadx   i64   8 -8
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    loadref  u64   mm_decls.sourcefilesupport 
    loadref  u64   .sflist 
    load     i64   .i 
    iloadx   i64   8 -8
    iloadx   u8    1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#6468:
    forup          #6467 1
    opnd           .i 
    opnd           .nfiles 
#6469:
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
;------------------------
#6442:
    return         
end

proc mm_tables.start
    local    i64   .genop 
    local    i64   .s 
    local    i64   .t 
    local    i64   .a 
    local    i64   .specop 
    local    i64   .$av_1 
    local    i64   .$av_2 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
#6472:
    loadimm  i64   1 
    loadref  u64   mm_tables.intresult 
    loadref  u64   mm_tables.intresultlist 
    load     i64   .i 
    iloadx   u8    1 -1
    istorex  u8    1 -1
#6473:
    forup          #6472 1
    opnd           .i 
    opnd           7 
#6474:
    loadimm  i64   1 
    store    i64   .i 
#6475:
    loadimm  i64   1 
    loadref  u64   mm_tables.endsexpr 
    loadref  u64   mm_tables.exprendsymbols 
    load     i64   .i 
    iloadx   u8    1 -1
    istorex  u8    1 -1
#6476:
    forup          #6475 1
    opnd           .i 
    opnd           12 
#6477:
    loadimm  i64   1 
    loadref  u64   mm_tables.isbooltag 
    loadimm  i64   30 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.isbooltag 
    loadimm  i64   31 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.isbooltag 
    loadimm  i64   12 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.isbooltag 
    loadimm  i64   13 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.isbooltag 
    loadimm  i64   14 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.isbooltag 
    loadimm  i64   15 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.isbooltag 
    loadimm  i64   40 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.isbooltag 
    loadimm  i64   41 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   3 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   43 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   45 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   48 
    istorex  u8    1 0
    loadimm  i64   2 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   49 
    istorex  u8    1 0
    loadimm  i64   2 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   50 
    istorex  u8    1 0
    loadimm  i64   2 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   1 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   46 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.ismemtag 
    loadimm  i64   47 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.islvalue 
    loadimm  i64   3 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.islvalue 
    loadimm  i64   43 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.islvalue 
    loadimm  i64   45 
    istorex  u8    1 0
    loadimm  i64   1 
    loadref  u64   mm_tables.islvalue 
    loadimm  i64   48 
    istorex  u8    1 0
    loadimm  i64   2 
    loadref  u64   mm_tables.islvalue 
    loadimm  i64   92 
    istorex  u8    1 0
    loadimm  i64   2 
    loadref  u64   mm_tables.islvalue 
    loadimm  i64   107 
    istorex  u8    1 0
    loadimm  i64   2 
    loadref  u64   mm_tables.islvalue 
    loadimm  i64   105 
    istorex  u8    1 0
    loadimm  i64   2 
    loadref  u64   mm_tables.islvalue 
    loadimm  i64   110 
    istorex  u8    1 0
;------------------------
#6471:
    return         
end

;
proc mm_type.tpass
    param    u64   .p 
    param    i64   .t 
    param    i64   .lv 
    local    u64   .d 
    local    u64   .a 
    local    u64   .b 
    local    u64   .c 
    local    u64   .q 
    local    i64   .oldmlineno 
    local    i64   .m 
    local    i64   .nparams 
    local    i64   .paramtype 
    local    i64   .restype 
    local    i64   .amode 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #6480 
    jump           #6478 
#6480:
#6479:
    load     i64   mm_tables.mlineno 
    store    i64   .oldmlineno 
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .b 
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .c 
    load     i64   .lv 
    loadimm  i64   1 
    jumpne   i64   #6482 
    loadref  u64   mm_tables.islvalue 
    load     u64   .p 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #6482 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Not Lvalue"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6482:
#6481:
    load     i64   .t 
    loadimm  i64   0 
    ne       i64   
    load     u64   .p 
    loadimm  i64   60 
    istorex  u8    1 0
    load     u64   .p 
    iload    u8    
    switch         #6485 1 126
    opnd           #6486 
#6485:
    swlabel        #6488 
    swlabel        #6486 
    swlabel        #6487 
    swlabel        #6518 
    swlabel        #6545 
    swlabel        #6486 
    swlabel        #6548 
    swlabel        #6548 
    swlabel        #6549 
    swlabel        #6592 
    swlabel        #6597 
    swlabel        #6505 
    swlabel        #6505 
    swlabel        #6506 
    swlabel        #6507 
    swlabel        #6530 
    swlabel        #6511 
    swlabel        #6594 
    swlabel        #6486 
    swlabel        #6593 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6495 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6503 
    swlabel        #6491 
    swlabel        #6589 
    swlabel        #6491 
    swlabel        #6492 
    swlabel        #6493 
    swlabel        #6494 
    swlabel        #6510 
    swlabel        #6492 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6501 
    swlabel        #6517 
    swlabel        #6504 
    swlabel        #6516 
    swlabel        #6516 
    swlabel        #6502 
    swlabel        #6496 
    swlabel        #6499 
    swlabel        #6508 
    swlabel        #6591 
    swlabel        #6526 
    swlabel        #6509 
    swlabel        #6489 
    swlabel        #6598 
    swlabel        #6486 
    swlabel        #6490 
    swlabel        #6490 
    swlabel        #6550 
    swlabel        #6553 
    swlabel        #6572 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6570 
    swlabel        #6486 
    swlabel        #6571 
    swlabel        #6571 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6556 
    swlabel        #6544 
    swlabel        #6544 
    swlabel        #6503 
    swlabel        #6521 
    swlabel        #6573 
    swlabel        #6525 
    swlabel        #6500 
    swlabel        #6523 
    swlabel        #6523 
    swlabel        #6524 
    swlabel        #6524 
    swlabel        #6535 
    swlabel        #6539 
    swlabel        #6533 
    swlabel        #6534 
    swlabel        #6532 
    swlabel        #6532 
    swlabel        #6532 
    swlabel        #6520 
    swlabel        #6515 
    swlabel        #6515 
    swlabel        #6514 
    swlabel        #6514 
    swlabel        #6512 
    swlabel        #6513 
    swlabel        #6564 
    swlabel        #6522 
    swlabel        #6522 
    swlabel        #6522 
    swlabel        #6522 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6558 
    swlabel        #6557 
    swlabel        #6486 
    swlabel        #6486 
    swlabel        #6531 
    swlabel        #6519 
    swlabel        #6590 
    swlabel        #6595 
    swlabel        #6596 
    endsw          
#6487:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_name 3 0
    jump           #6484 
#6488:
    jump           #6484 
#6489:
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6484 
#6490:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6484 
#6491:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_bin 3 0
    jump           #6484 
#6492:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_unary 2 0
    jump           #6484 
#6493:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_binto 3 0
    jump           #6484 
#6494:
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6484 
#6495:
    setcall        4
    load     i64   .t 
    setarg   i64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_assign 4 0
    jump           #6484 
#6496:
    load     u64   .a 
    iload    u8    
    loadimm  i64   48 
    jumpne   i64   #6498 
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    setcall        2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6497 
#6498:
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#6497:
    jump           #6484 
#6499:
    setcall        3
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_addroffirst 3 0
    jump           #6484 
#6500:
    setcall        6
    load     i64   .lv 
    setarg   i64   6
    load     i64   .t 
    setarg   i64   5
    load     u64   .c 
    setarg   u64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_if 6 0
    jump           #6484 
#6501:
    setcall        5
    load     i64   .lv 
    setarg   i64   5
    load     i64   .t 
    setarg   i64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_index 5 0
    jump           #6484 
#6502:
    setcall        4
    load     i64   .lv 
    setarg   i64   4
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_ptr 4 0
    jump           #6484 
#6503:
    setcall        4
    load     i64   .t 
    setarg   i64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_callproc 4 0
    jump           #6484 
#6504:
    setcall        4
    load     i64   .lv 
    setarg   i64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_dot 4 0
    jump           #6484 
#6505:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_andl 3 0
    jump           #6484 
#6506:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_notl 2 0
    jump           #6484 
#6507:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_istruel 2 0
    jump           #6484 
#6508:
    setcall        3
    loadimm  i64   1 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_convert 3 0
    jump           #6484 
#6509:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_typepun 2 0
    jump           #6484 
#6510:
    setcall        3
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_incrto 3 0
    jump           #6484 
#6511:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_makerange 3 0
    jump           #6484 
#6512:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_swap 3 0
    jump           #6484 
#6513:
    setcall        6
    load     i64   .lv 
    setarg   i64   6
    load     i64   .t 
    setarg   i64   5
    load     u64   .c 
    setarg   u64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_select 6 0
    jump           #6484 
#6514:
    setcall        6
    load     i64   .lv 
    setarg   i64   6
    load     i64   .t 
    setarg   i64   5
    load     u64   .c 
    setarg   u64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_switch 6 0
    jump           #6484 
#6515:
    setcall        6
    load     i64   .lv 
    setarg   i64   6
    load     i64   .t 
    setarg   i64   5
    load     u64   .c 
    setarg   u64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_case 6 0
    jump           #6484 
#6516:
    setcall        4
    load     i64   .lv 
    setarg   i64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_dotindex 4 0
    jump           #6484 
#6517:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_slice 3 0
    jump           #6484 
#6518:
    setcall        4
    load     i64   .lv 
    setarg   i64   4
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_block 4 0
    jump           #6484 
#6519:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6484 
#6520:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6484 
#6521:
    setcall        3
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_return 3 0
    jump           #6484 
#6522:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tx_unitlist 3 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.fixchararray 1 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.do_printlist 1 0
    setcall        1
    load     u64   .p 
    loadimm  i64   32 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.do_printlist 1 0
    jump           #6484 
#6523:
    setcall        3
    load     u64   .c 
    setarg   u64   3
    load     u64   .b 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tx_for 3 0
    jump           #6484 
#6524:
    setcall        3
    load     u64   .c 
    setarg   u64   3
    load     u64   .b 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tx_forall 3 0
    jump           #6484 
#6525:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .c 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6484 
#6526:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #6528 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "cast() needs type"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6528:
#6527:
    setcall        3
    loadimm  i64   1 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    jump           #6484 
#6530:
    setcall        4
    load     i64   .lv 
    setarg   i64   4
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_makelist 4 0
    jump           #6484 
#6531:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6484 
#6532:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_exit 2 0
    jump           #6484 
#6533:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_goto 2 0
    jump           #6484 
#6534:
    jump           #6484 
#6535:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_type.iscondtrue 1 0
    jumpf    i64   #6537 
    loadimm  i64   104 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .b 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    jump           #6536 
#6537:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_type.iscondfalse 1 0
    jumpf    i64   #6538 
    loadimm  i64   2 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
#6538:
#6536:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .c 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6484 
#6539:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callf    i64   mm_type.iscondtrue 1 0
    jumpt    i64   #6542 
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callf    i64   mm_type.iscondfalse 1 0
    jumpf    i64   #6541 
#6542:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "repeat/const cond"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6541:
#6540:
    jump           #6484 
#6544:
    jump           #6484 
#6545:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #6547 
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#6547:
#6546:
    loadimm  i64   1 
    store    i64   mm_type.inassem 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tx_unitlist 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tx_unitlist 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .c 
    setarg   u64   1
    callp          mm_type.tx_unitlist 3 0
    loadimm  i64   0 
    store    i64   mm_type.inassem 
    jump           #6484 
#6548:
    jump           #6484 
#6549:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6484 
#6550:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #6552 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    jump           #6551 
#6552:
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
#6551:
    loadimm  i64   55 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6484 
#6553:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #6555 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .m 
    jump           #6554 
#6555:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
#6554:
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   21 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    setcall        1
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   44 
    istorex  u8    1 0
    jump           #6484 
#6556:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6484 
#6557:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6484 
#6558:
    load     u64   .a 
    jumpf    u64   #6560 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
#6560:
#6559:
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .t 
    iloadx   u8    1 0
    jumpt    i64   #6563 
    loadref  u64   mm_decls.ttisreal 
    load     i64   .t 
    iloadx   u8    1 0
    jumpf    i64   #6562 
#6563:
    setcall        1
    load     i64   .t 
    setarg   i64   1
    callf    i64   mm_lib.gettypebase 1 0
    store    i64   .t 
#6562:
#6561:
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6484 
#6564:
    load     u64   .a 
    jumpf    u64   #6566 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #6568 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "recase must be const"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6568:
#6567:
#6566:
#6565:
    jump           #6484 
#6570:
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6484 
#6571:
    loadimm  i64   21 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6484 
#6572:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_bitfield 3 0
    jump           #6484 
#6573:
    loadimm  i64   0 
    store    i64   .restype 
    loadimm  i64   0 
    store    i64   .paramtype 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    loadimm  i64   29 
    jumpeq   i64   #6575 1
    loadimm  i64   30 
    jumpeq   i64   #6576 1
    loadimm  i64   31 
    jumpeq   i64   #6577 1
    loadimm  i64   32 
    jumpeq   i64   #6578 1
    loadimm  i64   33 
    jumpeq   i64   #6578 1
    loadimm  i64   34 
    jumpeq   i64   #6578 
    jump           #6579 
#6575:
    loadimm  i64   3 
    store    i64   .restype 
    jump           #6574 
#6576:
    loadimm  i64   3 
    store    i64   .paramtype 
    loadimm  i64   21 
    store    i64   .restype 
    jump           #6574 
#6577:
    loadimm  i64   3 
    store    i64   .paramtype 
    loadimm  i64   7 
    store    i64   .restype 
    jump           #6574 
#6578:
    loadimm  i64   7 
    store    i64   .restype 
    jump           #6574 
#6579:
#6574:
    load     i64   .paramtype 
    loadimm  i64   0 
    jumpeq   i64   #6581 
    load     u64   .a 
    loadimm  u64   0 
    jumpne   u64   #6583 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "sys: arg missing"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6583:
#6582:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .paramtype 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpf    u64   #6586 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "sys: too many args"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6586:
#6585:
    jump           #6580 
#6581:
    load     u64   .a 
    jumpf    u64   #6588 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "sys: too many args"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6588:
#6580:
    load     i64   .restype 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6484 
#6589:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_cmpchain 2 0
    jump           #6484 
#6590:
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    jump           #6484 
#6591:
    jump           #6484 
#6592:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_strinclude 2 0
    jump           #6484 
#6593:
    setcall        3
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_makeslice 3 0
    jump           #6484 
#6594:
    setcall        3
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_makeset 3 0
    jump           #6484 
#6595:
    jump           #6484 
#6596:
    jump           #6484 
#6597:
    jump           #6484 
#6598:
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    jump           #6484 
#6486:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "TXUNIT: CAN'T DO:"
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.jtagnames 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;doelse::
#6600:
    loadimm  i64   1 
    store    i64   .i 
    loadref  u64   mm_tables.jsubs 
    load     u64   .p 
    iload    u8    
    iloadx   u8    1 0
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #6603 
#6601:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_type.tx_unitlist 3 0
#6602:
    forup          #6601 1
    opnd           .i 
    opnd           .$av_1 
#6603:
#6484:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tevaluate 1 0
    load     u64   .p 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #6605 1
    loadimm  i64   89 
    jumpeq   i64   #6605 
    jump           #6606 
#6605:
    jump           #6604 
#6606:
    load     i64   .t 
    loadimm  i64   23 
    jumpeq   i64   #6608 
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #6608 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     i64   .t 
    jumpeq   i64   #6608 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
#6608:
#6607:
#6604:
    load     i64   .t 
    loadimm  i64   0 
    jumpne   i64   #6610 
    load     u64   .p 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #6612 1
    loadimm  i64   32 
    jumpeq   i64   #6612 1
    loadimm  i64   33 
    jumpeq   i64   #6612 1
    loadimm  i64   30 
    jumpeq   i64   #6612 1
    loadimm  i64   3 
    jumpeq   i64   #6613 
    jump           #6614 
#6612:
    jump           #6611 
#6613:
    loadref  u64   mm_decls.ttisref 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #6617 
    loadref  u64   mm_decls.tttarget 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   25 
    jumpeq   i64   #6616 
#6617:
#6616:
#6615:
    jump           #6611 
#6614:
#6611:
#6610:
#6609:
    load     i64   .oldmlineno 
    store    i64   mm_tables.mlineno 
;------------------------
#6478:
    return         
end

proc mm_type.tx_allprocs
    local    u64   .pp 
    local    u64   .pcode 
    local    u64   .d 
;------------------------
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #6622 
#6619:
    load     u64   .pp 
    iload    u64   
    store    u64   mm_decls.currproc 
    load     u64   mm_decls.currproc 
    loadimm  i64   56 
    iloadx   u64   1 0
    store    u64   .pcode 
    loadref  u64   mm_decls.ttisshort 
    load     u64   mm_decls.currproc 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #6624 
    load     u64   mm_decls.currproc 
    loadimm  i64   80 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "proc short ret type"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6624:
#6623:
    load     u64   mm_decls.currproc 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    jump           #6629 
#6626:
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   13 
    jumpne   i64   #6631 
    loadref  u64   mm_decls.ttisblock 
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #6633 
    load     u64   .d 
    loadimm  i64   152 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpeq   i64   #6633 
    loadimm  i64   2 
    load     u64   .d 
    loadimm  i64   152 
    istorex  u8    1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    load     u64   .d 
    loadimm  i64   64 
    istorex  i32   1 0
#6633:
#6632:
#6631:
#6630:
#6627:
    load     u64   .d 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .d 
#6629:
    load     u64   .d 
    jumpt    u64   #6626 
#6628:
#6620:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#6622:
    load     u64   .pp 
    jumpt    u64   #6619 
#6621:
    load     u64   mm_decls.proclist 
    store    u64   .pp 
    jump           #6635 
#6634:
    load     u64   .pp 
    iload    u64   
    store    u64   mm_decls.currproc 
    load     u64   mm_decls.currproc 
    loadimm  i64   56 
    iloadx   u64   1 0
    store    u64   .pcode 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    startmx        
    load     u64   mm_decls.currproc 
    loadimm  i64   115 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumple   i64   #6638 
    loadimm  i64   28 
    resetmx        
    jump           #6637 
#6638:
    load     u64   mm_decls.currproc 
    loadimm  i64   64 
    iloadx   i32   1 0
    endmx          
#6637:
    setarg   i64   2
    load     u64   .pcode 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   mm_decls.currproc 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpeq   i64   #6640 1
    loadimm  i64   28 
    jumpeq   i64   #6641 
    jump           #6642 
#6640:
    jump           #6639 
#6641:
    jump           #6639 
#6642:
    load     u64   .pcode 
    iload    u8    
    loadimm  i64   89 
    jumpeq   i64   #6644 
    setcall        2
    loadimm  i64   89 
    setarg   i64   2
    load     u64   .pcode 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     u64   mm_decls.currproc 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .pcode 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   1 
    load     u64   .pcode 
    loadimm  i64   60 
    istorex  u8    1 0
#6644:
#6643:
#6639:
    load     u64   .pp 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pp 
#6635:
    load     u64   .pp 
    jumpt    u64   #6634 
#6636:
;------------------------
#6618:
    return         
end

proc mm_type.tx_block
    param    u64   .p 
    param    u64   .a 
    param    i64   .t 
    param    i64   .lv 
;------------------------
    jump           #6647 
#6646:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .a 
#6647:
    load     u64   .a 
    jumpf    u64   #6649 
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    jumpt    u64   #6646 
#6649:
#6648:
    load     u64   .a 
    jumpf    u64   #6651 
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    startmx        
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #6653 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    resetmx        
    jump           #6652 
#6653:
    loadimm  i64   0 
    endmx          
#6652:
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#6651:
#6650:
;------------------------
#6645:
    return         
end

proc mm_type.tx_typetable
    local    u64   .d 
    local    i64   .i 
;------------------------
    loadimm  i64   30 
    store    i64   .i 
    load     i64   mm_decls.ntypes 
    loadimm  i64   30 
    jumplt   i64   #6657 
#6655:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .i 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpne   i64   #6659 
    setcall        1
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .i 
    iloadx   u64   8 0
    double         
    store    u64   .d 
    setarg   u64   1
    callp          mm_type.tx_passdef 1 0
#6659:
#6658:
    setcall        1
    load     i64   .i 
    setarg   i64   1
    callp          mm_type.setmodesize 1 0
#6656:
    forup          #6655 1
    opnd           .i 
    opnd           mm_decls.ntypes 
#6657:
;------------------------
#6654:
    return         
end

proc mm_type.setmodesize
    param    i64   .m 
    local    i64   .size 
    local    i64   .target 
;------------------------
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    iloadx   u32   4 0
    jumpf    i64   #6662 
    jump           #6660 
#6662:
#6661:
    loadref  u64   mm_decls.ttlineno 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   mm_tables.mlineno 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpeq   i64   #6664 1
    loadimm  i64   8 
    jumpeq   i64   #6665 1
    loadimm  i64   0 
    jumpeq   i64   #6666 1
    loadimm  i64   24 
    jumpeq   i64   #6666 1
    loadimm  i64   11 
    jumpeq   i64   #6667 1
    loadimm  i64   22 
    jumpeq   i64   #6668 1
    loadimm  i64   23 
    jumpeq   i64   #6669 1
    loadimm  i64   29 
    jumpeq   i64   #6670 1
    loadimm  i64   28 
    jumpeq   i64   #6671 
    jump           #6672 
#6664:
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callp          mm_type.setarraysize 1 0
    jump           #6663 
#6665:
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callp          mm_type.setrecordsize 1 0
    jump           #6663 
#6666:
    jump           #6663 
#6667:
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callp          mm_type.setslicesize 1 0
    jump           #6663 
#6668:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "SETMODESIZE/AUTO?"
    setarg   u64   1
    callp          mm_support.txerror 2 0
    jump           #6663 
#6669:
    jump           #6663 
#6670:
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .target 
    setcall        1
    load     i64   .target 
    setarg   i64   1
    callp          mm_type.setmodesize 1 0
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .target 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    istorex  i32   4 0
    loadref  u64   mm_decls.ttsize 
    load     i64   .target 
    iloadx   u32   4 0
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    istorex  u32   4 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .target 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .target 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    istorex  i32   4 0
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .target 
    iloadx   u64   8 0
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    istorex  u64   8 0
    jump           #6663 
#6671:
    jump           #6663 
#6672:
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    iloadx   u32   4 0
    double         
    store    i64   .size 
    jumpf    i64   #6675 
    load     i64   .size 
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    istorex  u32   4 0
    jump           #6660 
#6675:
#6674:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "SIZE 0:"
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "M="
    callp          msys.m$print_str_nf 1 0
    load     i64   .m 
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   "STDNAMES[TTBASETYPE[M]]="
    callp          msys.m$print_str_nf 1 0
    loadref  u64   mm_tables.stdnames 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Can't set mode size"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#6663:
;------------------------
#6660:
    return         
end

proc mm_type.setarraysize
    param    i64   .m 
    local    i64   .lower 
    local    i64   .length 
    local    i64   .elemsize 
    local    i64   .target 
    local    i64   .size 
    local    u64   .pdim 
    local    u64   .a 
    local    u64   .b 
;------------------------
    loadref  u64   mm_decls.ttsizeset 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #6682 
    jump           #6680 
#6682:
#6681:
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    iloadx   u64   8 0
    store    u64   .pdim 
    load     u64   .pdim 
    jumpf    u64   #6684 
    load     u64   .pdim 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .pdim 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .b 
    setcall        2
    load     u64   .pdim 
    setarg   u64   2
    loadref  u64   mm_decls.ttowner 
    load     i64   .m 
    iloadx   u64   8 0
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    load     u64   .pdim 
    iload    u8    
    loadimm  i64   17 
    jumpeq   i64   #6686 1
    loadimm  i64   23 
    jumpeq   i64   #6687 
    jump           #6688 
#6686:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_type.getconstint 1 0
    store    i64   .lower 
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callf    i64   mm_type.getconstint 1 0
    load     i64   .lower 
    sub      i64   
    loadimm  i64   1 
    add      i64   
    store    i64   .length 
    jump           #6685 
#6687:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_type.getconstint 1 0
    store    i64   .lower 
    load     u64   .b 
    jumpf    u64   #6690 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callf    i64   mm_type.getconstint 1 0
    store    i64   .length 
    jump           #6689 
#6690:
    loadimm  i64   0 
    store    i64   .length 
#6689:
    jump           #6685 
#6688:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .pdim 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        1
    load     u64   .pdim 
    setarg   u64   1
    callf    i64   mm_type.getconstint 1 0
    store    i64   .length 
    loadimm  i64   1 
    store    i64   .lower 
#6685:
    jump           #6683 
#6684:
    loadimm  i64   1 
    store    i64   .lower 
    loadimm  i64   0 
    store    i64   .length 
#6683:
    loadimm  u64   0 
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    istorex  u64   8 0
    load     i64   .lower 
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
    load     i64   .length 
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    istorex  i32   4 0
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .target 
    setcall        1
    load     i64   .target 
    setarg   i64   1
    callp          mm_type.setmodesize 1 0
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    iloadx   u32   4 0
    store    i64   .elemsize 
    load     i64   .length 
    load     i64   .elemsize 
    mul      i64   
    double         
    store    i64   .size 
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    istorex  u32   4 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttsizeset 
    load     i64   .m 
    istorex  u8    1 0
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callp          mm_type.checkblocktype 1 0
;------------------------
#6680:
    return         
end

proc mm_type.setslicesize
    param    i64   .m 
    local    u64   .pdim 
;------------------------
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    iloadx   u32   4 0
    jumpf    i64   #6693 
    jump           #6691 
#6693:
#6692:
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    iloadx   u64   8 0
    store    u64   .pdim 
    load     u64   .pdim 
    jumpf    u64   #6695 
    setcall        2
    load     u64   .pdim 
    setarg   u64   2
    loadref  u64   mm_decls.ttowner 
    load     i64   .m 
    iloadx   u64   8 0
    setarg   u64   1
    callp          mm_name.rx_unit 2 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .pdim 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        1
    load     u64   .pdim 
    setarg   u64   1
    callf    i64   mm_type.getconstint 1 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
    loadimm  u64   0 
    loadref  u64   mm_decls.ttdimexpr 
    load     i64   .m 
    istorex  u64   8 0
    jump           #6694 
#6695:
    loadimm  i64   1 
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
#6694:
    setcall        1
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   1
    callp          mm_type.setmodesize 1 0
    loadref  u64   mm_decls.ttsize 
    loadimm  i64   11 
    iloadx   u32   4 0
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    istorex  u32   4 0
;------------------------
#6691:
    return         
end

proc mm_type.tx_module
    rettype  i64   
    param    i64   .n 
    local    u8:70 .m 
    local    u64   .d 
    local    i64   .globalflag 
    local    i64   .status 
;------------------------
    load     i64   .n 
    store    i64   mm_decls.currmoduleno 
    setcall        1
    loadref  u64   mm_decls.moduletable 
    load     i64   .n 
    addptrx  u8:70 70 0
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tx_passdef 1 0
    loadimm  i64   1 
    setret   i64   
    jump           #6696 
;------------------------
#6696:
    return         
end

proc mm_type.tx_passdef
    param    u64   .p 
    local    u64   .d 
    local    i64   .oldmlineno 
    local    u64   .q 
;------------------------
    load     u64   .p 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   1 
    loadbit        
    jumpf    u64   #6699 
    jump           #6697 
#6699:
#6698:
    load     i64   mm_tables.mlineno 
    store    i64   .oldmlineno 
    load     u64   .p 
    loadimm  i64   80 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    jump           #6701 
#6700:
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_type.tx_passdef 1 0
    load     u64   .d 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .d 
#6701:
    load     u64   .d 
    jumpt    u64   #6700 
#6702:
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u64   1 0
    store    u64   .q 
    load     u64   .p 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpeq   i64   #6704 1
    loadimm  i64   10 
    jumpeq   i64   #6705 1
    loadimm  i64   16 
    jumpeq   i64   #6705 1
    loadimm  i64   11 
    jumpeq   i64   #6706 1
    loadimm  i64   12 
    jumpeq   i64   #6706 1
    loadimm  i64   13 
    jumpeq   i64   #6706 
    jump           #6707 
#6704:
    loadimm  u64   0 
    store    u64   mm_decls.currproc 
    jump           #6703 
#6705:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_namedconst 1 0
    jump           #6703 
#6706:
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_namedef 1 0
    jump           #6703 
#6707:
#6703:
    loadimm  u64   1 
    load     u64   .p 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   1 
    storebit       
    load     i64   .oldmlineno 
    store    i64   mm_tables.mlineno 
;------------------------
#6697:
    return         
end

proc mm_type.tx_unitlist
    param    u64   .p 
    param    i64   .t 
    param    i64   .lv 
;------------------------
    jump           #6710 
#6709:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .p 
#6710:
    load     u64   .p 
    jumpt    u64   #6709 
#6711:
;------------------------
#6708:
    return         
end

proc mm_type.tx_namedef
    param    u64   .d 
    local    i64   .m 
    local    i64   .mold 
    local    i64   .inidataold 
    local    u64   .dcode 
    local    u64   .pequiv 
;------------------------
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    store    i64   .m 
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callp          mm_type.setmodesize 1 0
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   2 
    loadbit        
    jumpf    u64   #6714 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Circular reference detected"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6714:
#6713:
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   1 
    loadbit        
    jumpf    u64   #6717 
    jump           #6712 
#6717:
#6716:
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    store    u64   .dcode 
    loadimm  u64   1 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   2 
    storebit       
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   5 
    loadbit        
    jumpf    u64   #6719 
    load     u64   .d 
    loadimm  i64   88 
    iloadx   u64   1 0
    store    u64   .pequiv 
    load     u64   .pequiv 
    iload    u8    
    loadimm  i64   49 
    jumpne   i64   #6721 
    setcall        2
    load     u64   .pequiv 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .pequiv 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
#6721:
#6720:
    load     u64   .pequiv 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #6723 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "@name needed"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6723:
#6722:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .pequiv 
    setarg   u64   1
    callp          mm_type.tpass 3 0
#6719:
#6718:
    load     u64   .dcode 
    jumpf    u64   #6726 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   12 
    jumpeq   i64   #6726 
    load     i64   .m 
    store    i64   .mold 
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    i64   mm_lib.gettypebase 1 0
    store    i64   .m 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   11 
    jumpne   i64   #6728 
    load     u64   .dcode 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #6728 
    load     u64   .dcode 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   21 
    jumpne   i64   #6728 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   21 
    setarg   i64   2
    load     u64   .dcode 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6727 
#6728:
    load     i64   mm_type.inidata 
    store    i64   .inidataold 
    loadimm  i64   1 
    store    i64   mm_type.inidata 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .dcode 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .inidataold 
    store    i64   mm_type.inidata 
#6727:
    loadimm  u64   0 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   2 
    storebit       
    loadimm  u64   1 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   1 
    storebit       
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpne   i64   #6730 
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpne   i64   #6730 
    load     u64   .dcode 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .d 
    loadimm  i64   64 
    istorex  i32   1 0
#6730:
#6729:
    load     i64   .mold 
    load     i64   .m 
    jumpeq   i64   #6732 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #6734 
    loadref  u64   mm_decls.ttisshort 
    load     i64   .mold 
    iloadx   u8    1 0
    jumpf    i64   #6734 
    setcall        2
    loadimm  i64   52 
    setarg   i64   2
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     i64   .mold 
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6733 
#6734:
    load     i64   .mold 
    loadimm  i64   4 
    jumpne   i64   #6735 
    load     i64   .mold 
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    loadimm  i64   48 
    istorex  i32   1 0
#6735:
#6733:
#6732:
#6731:
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   11 
    jumpne   i64   #6737 
    setcall        1
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.checkconstexpr 1 0
#6737:
#6736:
    jump           #6725 
#6726:
    load     u64   .dcode 
    jumpf    u64   #6738 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   12 
    jumpne   i64   #6738 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpne   i64   #6738 
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpne   i64   #6738 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .dcode 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .dcode 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .d 
    loadimm  i64   64 
    istorex  i32   1 0
    loadimm  u64   0 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   2 
    storebit       
    loadimm  u64   1 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   1 
    storebit       
    jump           #6725 
#6738:
    loadimm  u64   0 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   2 
    storebit       
    loadimm  u64   1 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   1 
    storebit       
#6725:
;------------------------
#6712:
    return         
end

proc mm_type.tx_namedconst
    param    u64   .d 
    local    i64   .m 
    local    u64   .q 
;------------------------
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   2 
    loadbit        
    jumpf    u64   #6741 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Circular const reference detected"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6741:
#6740:
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   1 
    loadbit        
    jumpf    u64   #6744 
    jump           #6739 
#6744:
#6743:
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    store    u64   .q 
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    store    i64   .m 
    loadimm  u64   1 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   2 
    storebit       
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    startmx        
    load     i64   .m 
    loadimm  i64   22 
    jumpne   i64   #6746 
    loadimm  i64   23 
    resetmx        
    jump           #6745 
#6746:
    load     i64   .m 
    endmx          
#6745:
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadimm  u64   0 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   2 
    storebit       
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.checkconstexpr 1 0
    load     i64   .m 
    loadimm  i64   22 
    jumpne   i64   #6748 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .d 
    loadimm  i64   64 
    istorex  i32   1 0
#6748:
#6747:
    loadimm  u64   1 
    load     u64   .d 
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   1 
    storebit       
;------------------------
#6739:
    return         
end

proc mm_type.checkconstexpr
    param    u64   .p 
    local    u64   .q 
    local    i64   .pmode 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #6751 1
    loadimm  i64   55 
    jumpeq   i64   #6751 1
    loadimm  i64   16 
    jumpeq   i64   #6752 1
    loadimm  i64   51 
    jumpeq   i64   #6753 1
    loadimm  i64   52 
    jumpeq   i64   #6754 1
    loadimm  i64   49 
    jumpeq   i64   #6755 1
    loadimm  i64   50 
    jumpeq   i64   #6755 1
    loadimm  i64   3 
    jumpeq   i64   #6756 
    jump           #6757 
#6751:
    jump           #6749 
    jump           #6750 
#6752:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #6759 
#6758:
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.checkconstexpr 1 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#6759:
    load     u64   .q 
    jumpt    u64   #6758 
#6760:
    jump           #6750 
#6753:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   7 
    jumpne   i64   #6762 
    loadref  u64   mm_decls.tttarget 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpne   i64   #6764 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    jump           #6763 
#6764:
    jump           #6765 
#6763:
#6762:
#6761:
;cerror::
#6765:
    jump           #6750 
#6754:
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.checkconstexpr 1 0
    jump           #6750 
#6755:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #6767 
    jump           #6768 
#6767:
    jump           #6766 
#6768:
    jump           #6769 
#6766:
    jump           #6750 
#6756:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   14 
    jumpne   i64   #6771 
    jump           #6749 
#6771:
#6770:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   17 
    jumpne   i64   #6773 
    jump           #6749 
#6773:
#6772:
    jump           #6769 
    unload   u64   
    jump           #6750 
#6757:
;error::
#6769:
    callp          msys.m$print_startcon 0 0
    loadref  u64   mm_tables.jtagnames 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Getconstexpr: not const"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6750:
;------------------------
#6749:
    return         
end

proc mm_type.getconstint
    rettype  i64   
    param    u64   .q 
;------------------------
    setcall        1
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.checkconstexpr 1 0
    loadref  u64   mm_decls.ttisinteger 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpt    i64   #6778 
    load     u64   .q 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #6777 
#6778:
    load     u64   .q 
    loadimm  i64   16 
    iloadx   i64   1 0
    setret   i64   
    jump           #6775 
    jump           #6776 
#6777:
    loadref  u64   mm_decls.ttisreal 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #6779 
    load     u64   .q 
    loadimm  i64   16 
    iloadx   r64   1 0
    fix      i64 r64 
    setret   i64   
    jump           #6775 
    jump           #6776 
#6779:
    callp          msys.m$print_startcon 0 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Getconstint: not int32/64"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6776:
    loadimm  i64   0 
    setret   i64   
    jump           #6775 
;------------------------
#6775:
    return         
end

proc mm_type.makenewconst
    param    u64   .p 
    param    i64   .x 
    param    i64   .t 
;------------------------
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  u64   0 
    double         
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    load     i64   .x 
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #6783 
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#6783:
#6782:
;------------------------
#6781:
    return         
end

proc mm_type.tx_name
    param    u64   .p 
    param    i64   .t 
    param    i64   .lv 
    local    u64   .d 
    local    i64   .oldmlineno 
    local    u64   .pcode 
;------------------------
    load     i64   mm_tables.mlineno 
    store    i64   .oldmlineno 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   80 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    switch         #6786 3 17
    opnd           #6787 
#6786:
    swlabel        #6804 
    swlabel        #6787 
    swlabel        #6807 
    swlabel        #6802 
    swlabel        #6802 
    swlabel        #6808 
    swlabel        #6787 
    swlabel        #6788 
    swlabel        #6794 
    swlabel        #6794 
    swlabel        #6794 
    swlabel        #6806 
    swlabel        #6787 
    swlabel        #6788 
    swlabel        #6803 
    endsw          
#6788:
    load     i64   .lv 
    jumpf    i64   #6790 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "&const"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6790:
#6789:
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_type.tx_namedconst 1 0
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    store    u64   .pcode 
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   32 
    istorex  u64   1 0
    load     u64   .pcode 
    iload    u8    
    loadimm  i64   51 
    jumpne   i64   #6793 
    load     u64   .pcode 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    jump           #6792 
#6793:
    load     u64   .pcode 
    loadimm  i64   16 
    iloadx   i64   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
#6792:
    load     u64   .pcode 
    loadimm  i64   40 
    iloadx   u32   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
    load     u64   .pcode 
    loadimm  i64   44 
    iloadx   u8    1 0
    load     u64   .p 
    loadimm  i64   44 
    istorex  u8    1 0
    jump           #6785 
#6794:
    load     u64   .d 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   3 
    loadbit        
    jumpf    u64   #6796 
    load     i64   .lv 
    jumpf    i64   #6796 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .d 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Can't use 'let' as lvalue: "
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#6796:
#6795:
    setcall        1
    load     u64   .d 
    setarg   u64   1
    callp          mm_type.tx_namedef 1 0
    load     i64   mm_type.inassem 
    jumpt    i64   #6799 
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .d 
    loadimm  i64   152 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpne   i64   #6801 
    setcall        2
    loadimm  i64   48 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadref  u64   mm_decls.tttarget 
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   i32   4 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#6801:
#6800:
    setcall        2
    load     i64   .lv 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.twiden 2 0
    jump           #6798 
#6799:
    loadimm  i64   21 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#6798:
    jump           #6785 
#6802:
    load     i64   mm_tables.trefproc 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6785 
#6803:
    load     i64   mm_tables.treflabel 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6785 
#6804:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .d 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Module name can't be used on it's own: #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
    jump           #6785 
#6806:
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   32 
    istorex  u64   1 0
    load     u64   .d 
    loadimm  i64   76 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
    jump           #6785 
#6807:
    loadimm  i64   55 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6785 
#6808:
    load     u64   .d 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #6810 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Can't init dllvar"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6810:
#6809:
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6785 
#6787:
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    store    i64   mm_tables.mlineno 
    setcall        3
    load     u64   .d 
    iload    u64   
    setarg   u64   3
    loadref  u64   mm_tables.namenames 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    iloadx   u64   8 0
    setarg   u64   2
    loadimm  u64   "TNAME? # #"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
#6785:
    load     i64   .oldmlineno 
    store    i64   mm_tables.mlineno 
;------------------------
#6784:
    return         
end

proc mm_type.tx_bin
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    u64   .q 
    local    i64   .amode 
    local    i64   .bmode 
    local    i64   .abase 
    local    i64   .bbase 
    local    i64   .cmode 
    local    i64   .resmode 
    local    i64   .relop 
    local    i64   .simpleset 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .bmode 
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    switch         #6815 64 175
    opnd           #6816 
#6815:
    swlabel        #6817 
    swlabel        #6826 
    swlabel        #6851 
    swlabel        #6864 
    swlabel        #6864 
    swlabel        #6864 
    swlabel        #6864 
    swlabel        #6864 
    swlabel        #6864 
    swlabel        #6878 
    swlabel        #6878 
    swlabel        #6869 
    swlabel        #6869 
    swlabel        #6838 
    swlabel        #6838 
    swlabel        #6838 
    swlabel        #6838 
    swlabel        #6838 
    swlabel        #6838 
    swlabel        #6872 
    swlabel        #6875 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6882 
    swlabel        #6882 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6883 
    swlabel        #6883 
    swlabel        #6875 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6816 
    swlabel        #6854 
    endsw          
#6817:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumx 3 0
    jumpf    i64   #6819 
    jump           #6813 
#6819:
#6818:
    loadref  u64   mm_decls.ttisref 
    load     i64   .amode 
    iloadx   u8    1 0
    jumpf    i64   #6821 
    loadref  u64   mm_decls.ttisref 
    load     i64   .bmode 
    iloadx   u8    1 0
    jumpf    i64   #6823 
    load     u64   .a 
    loadimm  i64   44 
    iloadx   u8    1 0
    jumpf    i64   #6823 
    load     u64   .b 
    loadimm  i64   44 
    iloadx   u8    1 0
    jumpf    i64   #6823 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.combinestrings 1 0
    jump           #6813 
#6823:
#6822:
    load     i64   .bmode 
    loadimm  i64   1 
    jumplt   i64   #6825 1
    loadimm  i64   5 
    jumpgt   i64   #6825 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   31 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .amode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6813 
#6825:
#6824:
#6821:
#6820:
    jump           #6814 
#6826:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumx 3 0
    jumpf    i64   #6828 
    jump           #6813 
#6828:
#6827:
    loadref  u64   mm_decls.ttisref 
    load     i64   .amode 
    iloadx   u8    1 0
    jumpf    i64   #6830 
    loadref  u64   mm_decls.ttisref 
    load     i64   .bmode 
    iloadx   u8    1 0
    jumpf    i64   #6832 
    setcall        2
    load     i64   .bmode 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpf    i64   #6834 
    loadimm  i64   33 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6813 
    jump           #6833 
#6834:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "ref-ref: not compat"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6833:
#6832:
#6831:
    load     i64   .bmode 
    loadimm  i64   1 
    jumplt   i64   #6837 1
    loadimm  i64   5 
    jumpgt   i64   #6837 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   32 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .amode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6813 
#6837:
#6836:
#6830:
#6829:
    jump           #6814 
#6838:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumx 3 0
    jumpf    i64   #6840 
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6813 
#6840:
#6839:
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadref  u64   mm_decls.ttisref 
    load     i64   .amode 
    iloadx   u8    1 0
    jumpf    i64   #6842 
    loadref  u64   mm_decls.ttisref 
    load     i64   .bmode 
    iloadx   u8    1 0
    jumpf    i64   #6842 
    setcall        2
    load     i64   .bmode 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #6844 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Cmp ref/ref not compat"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6844:
#6843:
    jump           #6813 
#6842:
#6841:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   77 
    jumpeq   i64   #6848 1
    loadimm  i64   78 
    jumpne   i64   #6847 
#6848:
    setcall        2
    load     i64   .bmode 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpf    i64   #6850 
    jump           #6813 
#6850:
#6849:
#6847:
#6846:
    jump           #6814 
#6851:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumx 3 0
    jumpf    i64   #6853 
    jump           #6813 
#6853:
#6852:
    jump           #6814 
#6854:
    load     i64   .amode 
    loadimm  i64   3 
    jumpeq   i64   #6857 1
    loadimm  i64   2 
    jumpeq   i64   #6857 1
    loadimm  i64   1 
    jumpne   i64   #6856 
#6857:
    load     i64   .bmode 
    loadimm  i64   3 
    jumpeq   i64   #6858 1
    loadimm  i64   2 
    jumpeq   i64   #6858 1
    loadimm  i64   1 
    jumpne   i64   #6856 
#6858:
    loadimm  i64   67 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #6859 
#6856:
#6855:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumf 3 0
    jumpf    i64   #6861 
    jump           #6813 
#6861:
#6860:
    load     i64   .amode 
    loadimm  i64   1 
    jumplt   i64   #6863 1
    loadimm  i64   5 
    jumpgt   i64   #6863 
    load     i64   .bmode 
    loadimm  i64   1 
    jumplt   i64   #6863 1
    loadimm  i64   5 
    jumpgt   i64   #6863 
    loadimm  i64   5 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   5 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   5 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    jump           #6813 
#6863:
#6862:
    jump           #6814 
#6864:
;doidiv::
#6859:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumi 3 0
    jumpf    i64   #6866 
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   69 
    jumpne   i64   #6868 
    setcall        0
    callf    i64   mm_lib.getintintmode 0 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#6868:
#6867:
    jump           #6813 
#6866:
#6865:
    jump           #6814 
#6869:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumx 3 0
    jumpf    i64   #6871 
    jump           #6813 
#6871:
#6870:
    jump           #6814 
#6872:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumx 3 0
    jumpf    i64   #6874 
    jump           #6813 
#6874:
#6873:
    jump           #6814 
#6875:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.dobinnumf 3 0
    jumpf    i64   #6877 
    jump           #6813 
#6877:
#6876:
    jump           #6814 
#6878:
    load     i64   .amode 
    loadimm  i64   3 
    jumpeq   i64   #6881 1
    loadimm  i64   2 
    jumpeq   i64   #6881 1
    loadimm  i64   1 
    jumpne   i64   #6880 
#6881:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    load     i64   .amode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #6813 
#6880:
#6879:
    jump           #6814 
#6882:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.doin 3 0
    unload   i64   
    jump           #6813 
    jump           #6814 
#6883:
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     i64   .amode 
    load     i64   .bmode 
    swapopnds      
    jumpne   i64   #6885 1
    loadimm  i64   6 
    jumpne   i64   #6885 
    jump           #6813 
#6885:
#6884:
    jump           #6814 
#6816:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "txbin?"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6814:
    setcall        3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .bmode 
    setarg   i64   1
    callf    u64   mm_lib.strmode2 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "BIN/CAN'T RESOLVE MODES"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
;------------------------
#6813:
    return         
end

proc mm_type.tx_binto
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    i64   .abase 
    local    i64   .bbase 
    local    i64   .amode 
    local    i64   .bmode 
    local    i64   .opc 
;------------------------
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .bmode 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .amode 
    iloadx   i32   4 0
    store    i64   .abase 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .bmode 
    iloadx   i32   4 0
    store    i64   .bbase 
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   176 
    jumpne   i64   #6890 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .abase 
    iloadx   u8    1 0
    jumpf    i64   #6890 
    loadimm  i64   88 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
#6890:
#6889:
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   85 
    jumpeq   i64   #6892 1
    loadimm  i64   86 
    jumpeq   i64   #6893 1
    loadimm  i64   93 
    jumpeq   i64   #6894 1
    loadimm  i64   94 
    jumpeq   i64   #6894 
    jump           #6895 
#6892:
    load     i64   .abase 
    loadimm  i64   7 
    jumpne   i64   #6897 
    load     i64   .bbase 
    loadimm  i64   7 
    jumpne   i64   #6897 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "to:ref+ref"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6897:
#6896:
    load     i64   .abase 
    loadimm  i64   7 
    jumpne   i64   #6900 
    load     i64   .bbase 
    loadimm  i64   5 
    jumpgt   i64   #6900 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   97 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #6888 
#6900:
#6899:
    jump           #6891 
#6893:
    load     i64   .abase 
    loadimm  i64   7 
    jumpne   i64   #6902 
    load     i64   .bbase 
    loadimm  i64   5 
    jumpgt   i64   #6902 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   98 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #6888 
#6902:
#6901:
    jump           #6891 
#6894:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    jump           #6888 
    jump           #6891 
#6895:
#6891:
    load     i64   .abase 
    loadimm  i64   1 
    jumplt   i64   #6904 1
    loadimm  i64   5 
    jumpgt   i64   #6904 
    load     i64   .bbase 
    loadimm  i64   1 
    jumplt   i64   #6904 1
    loadimm  i64   5 
    jumpgt   i64   #6904 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .abase 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    jump           #6903 
#6904:
    loadref  u64   mm_decls.ttisshort 
    load     i64   .abase 
    iloadx   u8    1 0
    jumpf    i64   #6905 
    load     i64   .bbase 
    loadimm  i64   1 
    jumplt   i64   #6905 1
    loadimm  i64   5 
    jumpgt   i64   #6905 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .abase 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    jump           #6903 
#6905:
    setcall        2
    load     i64   .bmode 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #6907 
    setcall        3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .bmode 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "BIN: modes not compatible: # #"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
#6907:
#6906:
#6903:
;------------------------
#6888:
    return         
end

proc mm_type.getdominantmode
    rettype  i64   
    param    i64   .amode 
    param    i64   .bmode 
    local    i64   .abase 
    local    i64   .bbase 
;------------------------
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .amode 
    iloadx   i32   4 0
    store    i64   .abase 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .bmode 
    iloadx   i32   4 0
    store    i64   .bbase 
    load     i64   .abase 
    loadimm  i64   1 
    jumplt   i64   #6911 1
    loadimm  i64   5 
    jumpgt   i64   #6911 
    load     i64   .bbase 
    loadimm  i64   1 
    jumplt   i64   #6911 1
    loadimm  i64   5 
    jumpgt   i64   #6911 
    load     i64   .abase 
    load     i64   .bbase 
    max      i64   
    setret   i64   
    jump           #6909 
#6911:
#6910:
    setcall        2
    load     i64   .bmode 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #6913 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Getdom: no dominant mode"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6913:
#6912:
    load     i64   .amode 
    setret   i64   
    jump           #6909 
;------------------------
#6909:
    return         
end

proc mm_type.tx_cmpchain
    param    u64   .p 
    param    u64   .a 
    local    i64   .u 
    local    i64   .genop 
    local    u64   .q 
    local    u64   .r 
;------------------------
    load     u64   .a 
    store    u64   .q 
    jump           #6917 
#6916:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .q 
    load     u64   .a 
    jumpne   u64   #6920 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .u 
    jump           #6919 
#6920:
    setcall        2
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
#6919:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#6917:
    load     u64   .q 
    jumpt    u64   #6916 
#6918:
    load     u64   .a 
    store    u64   .q 
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .r 
    jump           #6922 
#6921:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#6922:
    load     u64   .q 
    jumpt    u64   #6921 
#6923:
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#6915:
    return         
end

proc mm_type.tx_callproc
    param    u64   .p 
    param    u64   .a 
    param    u64   .pargs 
    param    i64   .t 
    local    u64   .q 
    local    u64   .d 
    local    u64   .e 
    local    u64   .pm 
    local    u8:800 .paramlist 
    local    u8:800 .arglist 
    local    u8:800 .newarglist 
    local    i64   .nparams 
    local    i64   .i 
    local    i64   .j 
    local    i64   .k 
    local    i64   .nargs 
    local    i64   .m 
    local    i64   .kwdused 
    local    i64   .qm 
    local    i64   .ismproc 
    local    u64   .name 
    local    u64   .ulist 
    local    u64   .ulistx 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadimm  i64   0 
    double         
    store    i64   .nparams 
    store    i64   .nargs 
    loadimm  i64   0 
    store    i64   .ismproc 
;retry::
#6925:
    load     u64   .a 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #6927 1
    loadimm  i64   92 
    jumpeq   i64   #6928 1
    loadimm  i64   110 
    jumpeq   i64   #6928 
    jump           #6929 
#6927:
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    jumpeq   i64   #6932 1
    loadimm  i64   7 
    jumpne   i64   #6931 
#6932:
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   6 
    eq       i64   
    store    i64   .ismproc 
;getparams::
#6933:
    load     u64   .d 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    jump           #6935 
#6934:
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   13 
    jumpne   i64   #6938 
    load     i64   .nparams 
    loadimm  i64   100 
    jumplt   i64   #6940 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Param overflow"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6940:
#6939:
    load     u64   .e 
    loadref  u64   .paramlist 
    loadref  u64   .nparams 
    incrload i64   1
    istorex  u64   8 -8
#6938:
#6937:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#6935:
    load     u64   .e 
    jumpt    u64   #6934 
#6936:
    jump           #6930 
#6931:
    jump           #6943 
#6942:
    setcall        2
    loadimm  i64   48 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    load     u64   .a 
    loadimm  i64   48 
    istorex  i32   1 0
#6943:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   7 
    jumpeq   i64   #6942 
#6944:
    jump           #6945 
#6930:
    jump           #6926 
#6928:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Can't do ifx/function"
    setarg   u64   1
    callp          mm_support.txerror 2 0
    jump           #6926 
#6929:
;dorefproc::
#6945:
    load     u64   .a 
    iload    u8    
    loadimm  i64   45 
    jumpne   i64   #6948 
    setcall        3
    load     u64   .pargs 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tmethodcall 3 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .pargs 
    jump           #6925 
#6948:
#6947:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   24 
    jumpeq   i64   #6950 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Function pointer expected"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6950:
#6949:
    loadref  u64   mm_decls.ttnamedef 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u64   8 0
    store    u64   .d 
    load     u64   .d 
    loadimm  u64   0 
    jumpne   u64   #6953 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Function expected"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6953:
#6952:
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #6956 
    loadimm  i64   88 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
#6956:
#6955:
    jump           #6933 
#6926:
    load     u64   .pargs 
    store    u64   .q 
    jump           #6958 
#6957:
    load     i64   .nargs 
    loadimm  i64   100 
    jumplt   i64   #6961 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Param overflow"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6961:
#6960:
    load     u64   .q 
    loadref  u64   .arglist 
    loadref  u64   .nargs 
    incrload i64   1
    istorex  u64   8 -8
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#6958:
    load     u64   .q 
    jumpt    u64   #6957 
#6959:
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    jumpf    i64   #6964 
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #6964 
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.twiden 2 0
#6964:
#6963:
    load     u64   .d 
    loadimm  i64   116 
    iloadx   u8    1 0
    jumpf    i64   #6966 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nargs 
    loadimm  i64   1 
    jumplt   i64   #6969 
#6967:
    load     i64   .i 
    load     i64   .nparams 
    jumpgt   i64   #6971 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadref  u64   .paramlist 
    load     i64   .i 
    iloadx   u64   8 -8
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    loadref  u64   .arglist 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #6970 
#6971:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    loadref  u64   .arglist 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_type.tpass 3 0
#6970:
#6968:
    forup          #6967 1
    opnd           .i 
    opnd           .nargs 
#6969:
    load     i64   .t 
    loadimm  i64   0 
    jumpne   i64   #6973 
    loadimm  i64   88 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
#6973:
#6972:
    jump           #6924 
#6966:
#6965:
    loadimm  i64   0 
    store    i64   .k 
    loadimm  i64   0 
    store    i64   .kwdused 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nparams 
    loadimm  i64   1 
    jumplt   i64   #6976 
#6974:
    loadimm  u64   0 
    loadref  u64   .newarglist 
    load     i64   .i 
    istorex  u64   8 -8
#6975:
    forup          #6974 1
    opnd           .i 
    opnd           .nparams 
#6976:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nargs 
    loadimm  i64   1 
    jumplt   i64   #6979 
#6977:
    loadref  u64   .arglist 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .q 
    load     u64   .q 
    iload    u8    
    switch         #6981 2 22
    opnd           #6982 
#6981:
    swlabel        #6994 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6982 
    swlabel        #6983 
    endsw          
#6983:
    load     u64   .q 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u64   
    store    u64   .name 
    loadimm  i64   1 
    store    i64   .j 
    load     i64   .nparams 
    loadimm  i64   1 
    jumplt   i64   #6987 
#6984:
    setcall        2
    load     u64   .name 
    setarg   u64   2
    loadref  u64   .paramlist 
    load     i64   .j 
    iloadx   u64   8 -8
    iload    u64   
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #6989 
    jump           #6986 
#6989:
#6988:
#6985:
    forup          #6984 1
    opnd           .j 
    opnd           .nparams 
#6987:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .name 
    setarg   u64   2
    loadimm  u64   "Can't find kwd param: #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#6986:
    loadref  u64   .newarglist 
    load     i64   .j 
    iloadx   u64   8 -8
    jumpf    u64   #6992 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .name 
    setarg   u64   2
    loadimm  u64   "Kwd: # already used or was implicit"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#6992:
#6991:
    load     u64   .q 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadref  u64   .newarglist 
    load     i64   .j 
    istorex  u64   8 -8
    loadimm  i64   1 
    store    i64   .kwdused 
    jump           #6980 
#6994:
    load     i64   .kwdused 
    jumpf    i64   #6996 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Normal param follows kwd"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#6996:
#6995:
    loadimm  u64   0 
    store    u64   .q 
    jump           #6998 
    jump           #6980 
#6982:
;doregparam::
#6998:
    load     i64   .kwdused 
    jumpf    i64   #7000 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Normal param follows kwd"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7000:
#6999:
    load     i64   .k 
    load     i64   .nparams 
    jumplt   i64   #7002 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "K="
    callp          msys.m$print_str_nf 1 0
    load     i64   .k 
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   "NPARAMS="
    callp          msys.m$print_str_nf 1 0
    load     i64   .nparams 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Too many params supplied"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7002:
#7001:
    load     u64   .q 
    loadref  u64   .newarglist 
    loadref  u64   .k 
    incrload i64   1
    istorex  u64   8 -8
#6980:
#6978:
    forup          #6977 1
    opnd           .i 
    opnd           .nargs 
#6979:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nparams 
    loadimm  i64   1 
    jumplt   i64   #7008 
#7006:
    loadref  u64   .newarglist 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .q 
    loadref  u64   .paramlist 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .pm 
    load     u64   .q 
    loadimm  u64   0 
    jumpne   u64   #7010 
    load     u64   .pm 
    loadimm  i64   153 
    iloadx   u8    1 0
    jumpt    i64   #7012 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .i 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadimm  u64   "Param not optional: #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7012:
#7011:
    load     u64   .pm 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #7015 
    setcall        2
    load     u64   .p 
    loadimm  i64   4 
    iloadx   u32   1 0
    setarg   i64   2
    load     u64   .pm 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    loadref  u64   .newarglist 
    load     i64   .i 
    istorex  u64   8 -8
    jump           #7014 
#7015:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    loadref  u64   .newarglist 
    load     i64   .i 
    istorex  u64   8 -8
#7014:
#7010:
#7009:
#7007:
    forup          #7006 1
    opnd           .i 
    opnd           .nparams 
#7008:
    loadimm  u64   0 
    store    u64   .ulist 
    loadimm  u64   0 
    store    u64   .ulistx 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nparams 
    loadimm  i64   1 
    jumplt   i64   #7018 
#7016:
    loadref  u64   .paramlist 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .pm 
    loadref  u64   .newarglist 
    load     i64   .i 
    iloadx   u64   8 -8
    store    u64   .q 
    load     u64   .pm 
    loadimm  i64   152 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpne   i64   #7020 
    setcall        3
    loadimm  i64   1 
    setarg   i64   3
    loadref  u64   mm_decls.tttarget 
    load     u64   .pm 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   i32   4 0
    double         
    store    i64   .m 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .qm 
    setcall        2
    load     i64   .m 
    setarg   i64   2
    load     i64   .qm 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7022 
    setcall        3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .qm 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "&param: type mismatch"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
#7022:
#7021:
    load     u64   .q 
    iload    u8    
    loadimm  i64   51 
    jumpeq   i64   #7025 
    setcall        2
    loadimm  i64   49 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     u64   .pm 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .q 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7024 
#7025:
    loadimm  i64   49 
    load     u64   .q 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .pm 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .q 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   48 
    istorex  i32   1 0
#7024:
    jump           #7019 
#7020:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .pm 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
#7019:
    setcall        3
    load     u64   .q 
    setarg   u64   3
    loadref  u64   .ulistx 
    setarg   u64   2
    loadref  u64   .ulist 
    setarg   u64   1
    callp          mm_lib.addlistunit 3 0
    loadimm  u64   0 
    load     u64   .q 
    loadimm  i64   8 
    istorex  u64   1 0
#7017:
    forup          #7016 1
    opnd           .i 
    opnd           .nparams 
#7018:
    load     u64   .ulist 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
;------------------------
#6924:
    return         
end

proc mm_type.tx_unary
    param    u64   .p 
    param    u64   .a 
    local    i64   .opc 
    local    i64   .size 
    local    i64   .amode 
    local    i64   .mbase 
    local    i64   .tmax 
    local    i64   .x 
    local    i64   .xhigh 
    local    i64   .resmode 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
    load     i64   .amode 
    store    i64   .resmode 
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    switch         #7028 99 166
    opnd           #7029 
#7028:
    swlabel        #7072 
    swlabel        #7072 
    swlabel        #7068 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7072 
    swlabel        #7029 
    swlabel        #7061 
    swlabel        #7060 
    swlabel        #7060 
    swlabel        #7060 
    swlabel        #7060 
    swlabel        #7060 
    swlabel        #7060 
    swlabel        #7060 
    swlabel        #7072 
    swlabel        #7060 
    swlabel        #7029 
    swlabel        #7072 
    swlabel        #7072 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7067 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7030 
    swlabel        #7030 
    swlabel        #7030 
    swlabel        #7036 
    swlabel        #7036 
    swlabel        #7030 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7029 
    swlabel        #7031 
    swlabel        #7031 
    swlabel        #7064 
    endsw          
#7030:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.do_bounds 2 0
    jump           #7026 
    jump           #7027 
#7031:
    loadref  u64   mm_decls.ttsize 
    startmx        
    load     u64   .a 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #7033 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    resetmx        
    jump           #7032 
#7033:
    load     i64   .amode 
    endmx          
#7032:
    iloadx   u32   4 0
    startmx        
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   165 
    jumpne   i64   #7035 
    loadimm  i64   1 
    resetmx        
    jump           #7034 
#7035:
    loadimm  i64   8 
    endmx          
#7034:
    mul      i64   
    store    i64   .size 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .size 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.makenewconst 3 0
    loadimm  i64   3 
    store    i64   .resmode 
    jump           #7027 
#7036:
    loadimm  i64   3 
    store    i64   .resmode 
    load     u64   .a 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #7038 
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    iloadx   i32   4 0
    store    i64   .mbase 
    jump           #7037 
#7038:
    loadref  u64   mm_decls.ttbasetype 
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_lib.getmemmode 1 0
    iloadx   i32   4 0
    store    i64   .mbase 
#7037:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   156 
    jumpne   i64   #7040 
    load     i64   .mbase 
    loadimm  i64   15 
    jumpeq   i64   #7042 1
    loadimm  i64   16 
    jumpeq   i64   #7043 1
    loadimm  i64   17 
    jumpeq   i64   #7044 1
    loadimm  i64   3 
    jumpeq   i64   #7045 1
    loadimm  i64   18 
    jumpeq   i64   #7046 1
    loadimm  i64   19 
    jumpeq   i64   #7046 1
    loadimm  i64   20 
    jumpeq   i64   #7046 1
    loadimm  i64   2 
    jumpeq   i64   #7046 1
    loadimm  i64   13 
    jumpeq   i64   #7046 1
    loadimm  i64   1 
    jumpeq   i64   #7046 
    jump           #7047 
#7042:
    loadimm  i64   -128 
    store    i64   .x 
    jump           #7041 
#7043:
    loadimm  i64   -32768 
    store    i64   .x 
    jump           #7041 
#7044:
    loadimm  i64   -2147483648 
    store    i64   .x 
    jump           #7041 
#7045:
    loadimm  i64   -9223372036854775808 
    store    i64   .x 
    jump           #7041 
#7046:
    loadimm  i64   0 
    store    i64   .x 
    jump           #7041 
#7047:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .mbase 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "Can't do minvalue on #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7041:
    jump           #7039 
#7040:
    load     i64   .mbase 
    loadimm  i64   15 
    jumpeq   i64   #7050 1
    loadimm  i64   16 
    jumpeq   i64   #7051 1
    loadimm  i64   17 
    jumpeq   i64   #7052 1
    loadimm  i64   3 
    jumpeq   i64   #7053 1
    loadimm  i64   18 
    jumpeq   i64   #7054 1
    loadimm  i64   13 
    jumpeq   i64   #7054 1
    loadimm  i64   19 
    jumpeq   i64   #7055 1
    loadimm  i64   20 
    jumpeq   i64   #7056 1
    loadimm  i64   2 
    jumpeq   i64   #7057 
    jump           #7058 
#7050:
    loadimm  i64   127 
    store    i64   .x 
    jump           #7049 
#7051:
    loadimm  i64   32767 
    store    i64   .x 
    jump           #7049 
#7052:
    loadimm  i64   2147483647 
    store    i64   .x 
    jump           #7049 
#7053:
    loadimm  i64   9223372036854775807 
    store    i64   .x 
    jump           #7049 
#7054:
    loadimm  i64   255 
    store    i64   .x 
    jump           #7049 
#7055:
    loadimm  i64   65535 
    store    i64   .x 
    jump           #7049 
#7056:
    loadimm  i64   4294967295 
    store    i64   .x 
    jump           #7049 
#7057:
    loadimm  i64   0 
    store    i64   .x 
    loadref  u64   .x 
    decrto   i64   1
    loadimm  i64   2 
    store    i64   .resmode 
    jump           #7049 
#7058:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .mbase 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "Can't do maxvalue on #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7049:
#7039:
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    load     i64   .x 
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
    jump           #7027 
#7060:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   5 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   5 
    store    i64   .resmode 
    jump           #7027 
#7061:
    load     i64   .amode 
    loadimm  i64   4 
    jumpeq   i64   #7063 1
    loadimm  i64   5 
    jumpeq   i64   #7063 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   5 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   5 
    store    i64   .resmode 
#7063:
#7062:
    jump           #7027 
#7064:
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #7066 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .amode 
    jump           #7065 
#7066:
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_lib.getmemmode 1 0
    store    i64   .amode 
#7065:
    loadimm  i64   21 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        1
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   44 
    istorex  u8    1 0
    setcall        1
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    jump           #7026 
    jump           #7027 
#7067:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_sliceptr 2 0
    jump           #7026 
    jump           #7027 
#7068:
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .amode 
    iloadx   u8    1 0
    jumpt    i64   #7070 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Inot"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7070:
#7069:
    jump           #7027 
#7072:
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .amode 
    iloadx   u8    1 0
    jumpt    i64   #7074 
    loadref  u64   mm_decls.ttisreal 
    load     i64   .amode 
    iloadx   u8    1 0
    jumpt    i64   #7074 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Neg/Abs?"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7074:
#7073:
    jump           #7027 
#7029:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "TX:UNARY NOT CHECKED"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7027:
    load     i64   .resmode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7026:
    return         
end

proc mm_type.tx_if
    param    u64   .p 
    param    u64   .pcond 
    param    u64   .plist 
    param    u64   .pelse 
    param    i64   .t 
    param    i64   .lv 
    local    u64   .pc 
    local    u64   .pl 
    local    i64   .u 
;------------------------
    load     u64   .pcond 
    store    u64   .pc 
    load     u64   .plist 
    store    u64   .pl 
    loadimm  i64   0 
    store    i64   .u 
    load     i64   .t 
    loadimm  i64   23 
    jumpeq   i64   #7079 
    load     i64   .t 
    store    i64   .u 
#7079:
#7078:
    jump           #7083 
#7080:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .pc 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .pl 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7085 
    load     i64   .u 
    loadimm  i64   0 
    jumpne   i64   #7087 
    load     u64   .pl 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .u 
    jump           #7086 
#7087:
    setcall        2
    load     u64   .pl 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
#7086:
#7085:
#7084:
#7081:
    load     u64   .pc 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pc 
    load     u64   .pl 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pl 
#7083:
    load     u64   .pc 
    jumpt    u64   #7080 
#7082:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7089 
    load     u64   .pelse 
    loadimm  u64   0 
    jumpne   u64   #7089 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "else needed"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7089:
#7088:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .pelse 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7092 
    setcall        2
    load     u64   .pelse 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
#7092:
#7091:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7094 
    load     u64   .plist 
    store    u64   .pl 
    jump           #7098 
#7095:
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7100 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .pl 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
#7100:
#7099:
#7096:
    load     u64   .pl 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pl 
#7098:
    load     u64   .pl 
    jumpt    u64   #7095 
#7097:
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7102 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .pelse 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
#7102:
#7101:
    load     i64   .u 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7094:
#7093:
    load     u64   .pcond 
    loadimm  i64   8 
    iloadx   u64   1 0
    load     u64   .plist 
    loadimm  i64   8 
    iloadx   u64   1 0
    swapopnds      
    jumpne   u64   #7104 1
    loadimm  u64   0 
    jumpne   u64   #7104 
    setcall        1
    load     u64   .pcond 
    setarg   u64   1
    callf    i64   mm_type.iscondtrue 1 0
    jumpf    i64   #7106 
    load     u64   .plist 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7108 
    setcall        2
    load     u64   .plist 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
#7108:
#7107:
    jump           #7105 
#7106:
    setcall        1
    load     u64   .pcond 
    setarg   u64   1
    callf    i64   mm_type.iscondfalse 1 0
    jumpf    i64   #7109 
    load     u64   .pelse 
    loadimm  u64   0 
    jumpne   u64   #7111 
    setcall        1
    loadimm  i64   4 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .pelse 
#7111:
#7110:
    load     u64   .pelse 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7113 
    setcall        2
    load     u64   .pelse 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
#7113:
#7112:
#7109:
#7105:
#7104:
#7103:
;------------------------
#7077:
    return         
end

proc mm_type.tx_incrto
    param    u64   .p 
    param    u64   .a 
    param    i64   .t 
;------------------------
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    loadref  u64   mm_decls.ttisref 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpt    i64   #7116 
    loadref  u64   mm_decls.ttisinteger 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpt    i64   #7116 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "incr not int/ref"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7116:
#7115:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7119 
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   125 
    jumpeq   i64   #7121 1
    loadimm  i64   128 
    jumpeq   i64   #7122 
    jump           #7123 
#7121:
    loadimm  i64   126 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #7120 
#7122:
    loadimm  i64   129 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #7120 
#7123:
#7120:
    setcall        1
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_lib.gettypebase 1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7118 
#7119:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   127 
    jumpeq   i64   #7125 1
    loadimm  i64   130 
    jumpeq   i64   #7126 
    jump           #7127 
#7125:
    loadimm  i64   125 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #7124 
#7126:
    loadimm  i64   128 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #7124 
#7127:
#7124:
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7118:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.twiden 2 0
;------------------------
#7114:
    return         
end

proc mm_type.tx_for
    param    u64   .pindex 
    param    u64   .pfrom 
    param    u64   .pbody 
    local    u64   .pto 
    local    u64   .pstep 
    local    u64   .plocal 
    local    u64   .plist 
    local    u64   .passign 
    local    i64   .u 
;------------------------
    load     u64   .pfrom 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pto 
    load     u64   .pto 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pstep 
    load     u64   .pindex 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .passign 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .pindex 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #7130 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Loop index not a variable"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7130:
#7129:
    load     u64   .pindex 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .u 
    load     u64   .passign 
    jumpf    u64   #7133 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .passign 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .passign 
    loadimm  i64   24 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #7136 1
    loadimm  i64   3 
    jumpne   i64   #7135 
#7136:
    loadimm  u64   0 
    load     u64   .pindex 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .passign 
    loadimm  i64   24 
    iloadx   u64   1 0
    double         
    load     u64   .pfrom 
    loadimm  i64   8 
    istorex  u64   1 0
    store    u64   .pto 
    load     u64   .pstep 
    load     u64   .pto 
    loadimm  i64   8 
    istorex  u64   1 0
    loadimm  u64   0 
    load     u64   .passign 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   84 
    addptrx  u64   1 0
    loadimm  i64   0 
    storebit       
#7135:
#7134:
#7133:
#7132:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .pfrom 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .pto 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .pstep 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .pbody 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .pbody 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpass 3 0
;------------------------
#7128:
    return         
end

proc mm_type.tx_forall
    param    u64   .pindex 
    param    u64   .plist 
    param    u64   .pbody 
    local    u64   .plocal 
    local    u64   .pfrom 
    local    u64   .pto 
    local    u64   .passign 
    local    i64   .u 
    local    i64   .mlist 
    local    i64   .elemtype 
;------------------------
    load     u64   .pindex 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .plocal 
    load     u64   .plocal 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pfrom 
    load     u64   .pfrom 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .pto 
    load     u64   .plist 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .passign 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .pindex 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .pfrom 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .pto 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .plist 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .plist 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .mlist 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .mlist 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpeq   i64   #7139 1
    loadimm  i64   11 
    jumpeq   i64   #7140 
    jump           #7141 
#7139:
    loadref  u64   mm_decls.tttarget 
    load     i64   .mlist 
    iloadx   i32   4 0
    store    i64   .elemtype 
    jump           #7138 
#7140:
    loadref  u64   mm_decls.tttarget 
    load     i64   .mlist 
    iloadx   i32   4 0
    store    i64   .elemtype 
    jump           #7138 
#7141:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "forall/can't iterate"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7138:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .plocal 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .plocal 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   23 
    jumpne   i64   #7144 
    load     i64   .elemtype 
    load     u64   .plocal 
    loadimm  i64   48 
    istorex  i32   1 0
    load     i64   .elemtype 
    load     u64   .plocal 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   64 
    istorex  i32   1 0
#7144:
#7143:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .passign 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .pbody 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .pbody 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpass 3 0
;------------------------
#7137:
    return         
end

proc mm_type.tx_index
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    i64   .t 
    param    i64   .lv 
    local    i64   .amode 
    local    i64   .emode 
    local    i64   .pmode 
    local    i64   .tmode 
    local    i64   .tbasemode 
;------------------------
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        2
    load     i64   .t 
    loadimm  i64   0 
    ne       i64   
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.deref 2 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .amode 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpeq   i64   #7147 1
    loadimm  i64   11 
    jumpeq   i64   #7147 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .amode 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "Can't index: #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7147:
#7146:
    loadref  u64   mm_decls.tttarget 
    load     i64   .amode 
    iloadx   i32   4 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        2
    load     i64   .lv 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.twiden 2 0
;------------------------
#7145:
    return         
end

proc mm_type.tx_makerange
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    i64   .amode 
    local    i64   .bmode 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .bmode 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   9 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7149:
    return         
end

proc mm_type.tx_ptr
    param    u64   .p 
    param    u64   .a 
    param    i64   .t 
    param    i64   .lv 
    local    u64   .d 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpeq   i64   #7152 1
    loadimm  i64   7 
    jumpeq   i64   #7153 1
    loadimm  i64   11 
    jumpeq   i64   #7154 
    jump           #7155 
#7152:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Deref Void"
    setarg   u64   1
    callp          mm_support.txerror 2 0
    jump           #7151 
#7153:
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7151 
#7154:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Can't deref slice"
    setarg   u64   1
    callp          mm_support.txerror 2 0
    jump           #7151 
#7155:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "PTR: need ref T"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7151:
    setcall        2
    load     i64   .lv 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.twiden 2 0
;------------------------
#7150:
    return         
end

proc mm_type.setrecordsize
    param    i64   .m 
    local    u8:1664 .fieldlist 
    local    i64   .i 
    local    i64   .nfields 
    local    i64   .indent 
    local    i64   .nrfields 
    local    i64   .size 
    local    i64   .index 
    local    i64   .maxalign 
    local    u64   .d 
    local    u64   .e 
    local    u64   .flags 
    local    i64   .flag 
;------------------------
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    iloadx   u32   4 0
    jumpf    i64   #7161 
    jump           #7159 
#7161:
#7160:
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    loadimm  i64   0 
    store    i64   .nfields 
    loadimm  u64   83 
    loadref  u64   .fieldlist 
    loadref  u64   .nfields 
    incrload i64   1
    istorex  u64   8 -8
    jump           #7163 
#7162:
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   14 
    jumpne   i64   #7166 
    load     i64   .nfields 
    loadimm  i64   200 
    jumplt   i64   #7168 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "srs:too many fields"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#7168:
#7167:
    setcall        1
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callp          mm_type.setmodesize 1 0
    load     u64   .e 
    loadimm  i64   128 
    addptrx  u64   1 0
    store    u64   .flags 
#7170:
    load     u64   .flags 
    iload    u8    
    loadimm  u64   83 
    jumpeq   u64   #7172 1
    loadimm  u64   85 
    jumpeq   u64   #7172 
    jump           #7173 
#7172:
    load     u64   .flags 
    iload    u8    
    store    i64   .flag 
    load     i64   .flag 
    loadref  u64   .fieldlist 
    loadref  u64   .nfields 
    incrload i64   1
    istorex  u64   8 -8
    loadref  u64   .flags 
    incrto   u64   1
    jump           #7170 
#7173:
    jump           #7171 
    jump           #7170 
#7171:
    load     u64   .e 
    loadref  u64   .fieldlist 
    loadref  u64   .nfields 
    incrload i64   1
    istorex  u64   8 -8
#7174:
    loadref  u64   .flags 
    loadincr u64   1
    iload    u8    
    store    i64   .flag 
    load     i64   .flag 
    loadimm  i64   42 
    jumpeq   i64   #7177 1
    loadimm  i64   69 
    jumpeq   i64   #7178 
    jump           #7179 
#7177:
    jump           #7176 
#7178:
    loadimm  u64   69 
    loadref  u64   .fieldlist 
    loadref  u64   .nfields 
    incrload i64   1
    istorex  u64   8 -8
    jump           #7176 
#7179:
    jump           #7175 
#7176:
    jump           #7174 
#7175:
#7166:
#7165:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#7163:
    load     u64   .e 
    jumpt    u64   #7162 
#7164:
    loadimm  u64   69 
    loadref  u64   .fieldlist 
    loadref  u64   .nfields 
    incrload i64   1
    istorex  u64   8 -8
    loadimm  u64   0 
    loadref  u64   .fieldlist 
    load     i64   .nfields 
    istorex  u64   8 0
    loadimm  i64   0 
    store    i64   mm_type.countedfields 
    loadimm  i64   2 
    store    i64   .index 
    loadimm  i64   1 
    store    i64   .maxalign 
    setcall        7
    loadref  u64   .maxalign 
    setarg   u64   7
    load     u64   .d 
    loadimm  i64   141 
    iloadx   u8    1 0
    setarg   i64   6
    loadimm  i64   0 
    setarg   i64   5
    loadref  u64   .size 
    setarg   u64   4
    loadref  u64   .index 
    setarg   u64   3
    loadref  u64   .fieldlist 
    setarg   u64   2
    loadimm  i64   83 
    setarg   i64   1
    callp          mm_type.scanrecord 7 0
    load     u64   .d 
    loadimm  i64   141 
    iloadx   u8    1 0
    jumpf    i64   #7181 
    setcall        2
    load     i64   .maxalign 
    setarg   i64   2
    load     i64   .size 
    setarg   i64   1
    callf    i64   mm_type.roundoffset 2 0
    store    i64   .size 
    load     i64   .maxalign 
    load     u64   .d 
    loadimm  i64   160 
    istorex  i16   1 0
    jump           #7180 
#7181:
    loadimm  i64   1 
    load     u64   .d 
    loadimm  i64   160 
    istorex  i16   1 0
#7180:
    load     i64   .size 
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    istorex  u32   4 0
    load     i64   mm_type.countedfields 
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    istorex  i32   4 0
    loadimm  i64   1 
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    istorex  i32   4 0
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callp          mm_type.checkblocktype 1 0
;------------------------
#7159:
    return         
end

proc mm_type.checkblocktype
    param    i64   .m 
;------------------------
    loadref  u64   mm_decls.ttsize 
    load     i64   .m 
    iloadx   u32   4 0
    loadimm  i64   1 
    jumpeq   i64   #7184 1
    loadimm  i64   2 
    jumpeq   i64   #7184 1
    loadimm  i64   4 
    jumpeq   i64   #7184 1
    loadimm  i64   8 
    jumpeq   i64   #7185 
    jump           #7186 
#7184:
    loadimm  i64   0 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    istorex  u8    1 0
    jump           #7183 
#7185:
    loadimm  i64   0 
    loadref  u64   mm_decls.ttisblock 
    load     i64   .m 
    istorex  u8    1 0
    jump           #7183 
#7186:
#7183:
;------------------------
#7182:
    return         
end

proc mm_type.scanrecord
    param    i64   .state 
    param    u64   .fields 
    param    u64   .index 
    param    u64   .isize 
    param    i64   .offset 
    param    i64   .calign 
    param    u64   .maxalign 
    local    u64   .e 
    local    u64   .f 
    local    u64   .ea 
    local    i64   .size 
    local    i64   .fieldsize 
    local    i64   .bitoffset 
    local    i64   .alignment 
    local    i64   .newoffset 
;------------------------
    loadimm  i64   0 
    store    i64   .size 
    loadimm  i64   0 
    store    i64   .bitoffset 
    jump           #7189 
#7188:
    load     u64   .f 
    loadimm  i64   83 
    jumpeq   i64   #7192 1
    loadimm  i64   85 
    jumpeq   i64   #7192 1
    loadimm  i64   69 
    jumpeq   i64   #7193 
    jump           #7194 
#7192:
    setcall        7
    load     u64   .maxalign 
    setarg   u64   7
    load     i64   .calign 
    setarg   i64   6
    load     i64   .offset 
    setarg   i64   5
    loadref  u64   .fieldsize 
    setarg   u64   4
    load     u64   .index 
    setarg   u64   3
    load     u64   .fields 
    setarg   u64   2
    load     u64   .f 
    setarg   i64   1
    callp          mm_type.scanrecord 7 0
    jump           #7191 
#7193:
    load     i64   .state 
    loadimm  i64   85 
    jumpne   i64   #7196 
    loadref  u64   mm_type.countedfields 
    incrto   i64   1
#7196:
#7195:
    load     i64   .size 
    load     u64   .isize 
    istore   i64   
    jump           #7187 
    jump           #7191 
#7194:
    load     u64   .f 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   27 
    jumpne   i64   #7198 
    loadimm  i64   0 
    store    i64   .fieldsize 
    load     u64   .f 
    loadimm  i64   120 
    iloadx   u64   1 0
    store    u64   .ea 
    load     u64   .ea 
    loadimm  i64   76 
    iloadx   i32   1 0
    load     u64   .f 
    loadimm  i64   76 
    istorex  i32   1 0
    load     i64   .bitoffset 
    load     u64   .f 
    loadimm  i64   142 
    istorex  u8    1 0
    loadref  u64   .bitoffset 
    load     u64   .f 
    loadimm  i64   140 
    iloadx   u8    1 0
    addto    i64   
    load     i64   .bitoffset 
    loadref  u64   mm_decls.ttsize 
    load     u64   .f 
    loadimm  i64   120 
    iloadx   u64   1 0
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u32   4 0
    loadimm  i64   8 
    mul      i64   
    jumple   i64   #7200 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Bit fields overflow type"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7200:
#7199:
    jump           #7197 
#7198:
    load     u64   .f 
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   4 
    loadbit        
    jumpf    u64   #7202 
    loadimm  i64   0 
    store    i64   .bitoffset 
    load     u64   .f 
    loadimm  i64   120 
    iloadx   u64   1 0
    store    u64   .e 
    loadimm  i64   0 
    store    i64   .fieldsize 
    load     u64   .e 
    loadimm  i64   76 
    iloadx   i32   1 0
    load     u64   .f 
    loadimm  i64   143 
    iloadx   u8    1 0
    add      i64   
    load     u64   .f 
    loadimm  i64   76 
    istorex  i32   1 0
    jump           #7197 
#7202:
    loadimm  i64   0 
    store    i64   .bitoffset 
    load     i64   .state 
    loadimm  i64   83 
    jumpne   i64   #7204 
    loadref  u64   mm_type.countedfields 
    incrto   i64   1
#7204:
#7203:
    loadref  u64   mm_decls.ttsize 
    load     u64   .f 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u32   4 0
    store    i64   .fieldsize 
    load     i64   .calign 
    jumpf    i64   #7206 
    setcall        1
    load     u64   .f 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_lib.getalignment 1 0
    store    i64   .alignment 
    load     i64   .alignment 
    load     u64   .maxalign 
    iload    i64   
    jumple   i64   #7208 
    load     i64   .alignment 
    load     u64   .maxalign 
    istore   i64   
#7208:
#7207:
    setcall        2
    load     i64   .alignment 
    setarg   i64   2
    load     i64   .offset 
    setarg   i64   1
    callf    i64   mm_type.roundoffset 2 0
    store    i64   .newoffset 
    loadref  u64   .size 
    load     i64   .newoffset 
    load     i64   .offset 
    sub      i64   
    addto    i64   
    jump           #7205 
#7206:
    load     i64   .offset 
    store    i64   .newoffset 
#7205:
    load     i64   .newoffset 
    load     u64   .f 
    loadimm  i64   76 
    istorex  i32   1 0
    load     i64   .newoffset 
    store    i64   .offset 
#7197:
#7191:
    load     i64   .state 
    loadimm  i64   83 
    jumpne   i64   #7210 
    loadref  u64   .offset 
    load     i64   .fieldsize 
    addto    i64   
    loadref  u64   .size 
    load     i64   .fieldsize 
    addto    i64   
    jump           #7209 
#7210:
    load     i64   .size 
    load     i64   .fieldsize 
    max      i64   
    store    i64   .size 
#7209:
#7189:
    load     u64   .fields 
    load     u64   .index 
    loadincr i64   1
    iloadx   u64   8 -8
    double         
    store    u64   .f 
    jumpt    u64   #7188 
#7190:
;------------------------
#7187:
    return         
end

proc mm_type.roundoffset
    rettype  i64   
    param    i64   .offset 
    param    i64   .alignment 
    local    i64   .mask 
;------------------------
    load     i64   .alignment 
    loadimm  i64   1 
    jumpne   i64   #7213 
    load     i64   .offset 
    setret   i64   
    jump           #7211 
#7213:
#7212:
    load     i64   .alignment 
    loadimm  i64   1 
    sub      i64   
    store    i64   .mask 
    jump           #7215 
#7214:
    loadref  u64   .offset 
    incrto   i64   1
#7215:
    load     i64   .offset 
    load     i64   .mask 
    bitand   i64   
    jumpt    i64   #7214 
#7216:
    load     i64   .offset 
    setret   i64   
    jump           #7211 
;------------------------
#7211:
    return         
end

proc mm_type.tx_convert
    param    u64   .p 
    param    u64   .a 
    param    i64   .hard 
;------------------------
    load     u64   .a 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #7219 
    jump           #7220 
#7219:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     u64   .p 
    loadimm  i64   52 
    iloadx   i32   1 0
    setarg   i64   3
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tx_makelist 4 0
    jump           #7218 
#7220:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    load     i64   .hard 
    setarg   i64   3
    load     u64   .p 
    loadimm  i64   52 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
#7218:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
;------------------------
#7217:
    return         
end

proc mm_type.tx_makelist
    param    u64   .p 
    param    u64   .a 
    param    i64   .t 
    param    i64   .lv 
    local    i64   .alength 
    local    i64   .tlength 
    local    i64   .elemtype 
    local    i64   .newt 
    local    i64   .i 
    local    i64   .nfields 
    local    i64   .isconst 
    local    i64   .m 
    local    u64   .q 
    local    u64   .b 
    local    u64   .e 
;------------------------
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    store    i64   .alength 
    loadimm  i64   0 
    store    i64   .newt 
    loadimm  i64   1 
    store    i64   .isconst 
    loadref  u64   mm_decls.ttlength 
    load     i64   .t 
    iloadx   i32   4 0
    store    i64   .tlength 
    load     i64   .tlength 
    jumpf    i64   #7223 
    load     i64   .alength 
    load     i64   .tlength 
    jumpge   i64   #7225 
    setcall        3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .tlength 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .alength 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadimm  u64   "Too few elements"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
    jump           #7224 
#7225:
    load     i64   .alength 
    load     i64   .tlength 
    jumple   i64   #7227 
    setcall        3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .tlength 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .alength 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    loadimm  u64   "Too many elements"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
#7227:
#7224:
#7223:
#7222:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpeq   i64   #7230 1
    loadimm  i64   8 
    jumpeq   i64   #7231 
    jump           #7232 
#7230:
    loadref  u64   mm_decls.tttarget 
    load     i64   .t 
    iloadx   i32   4 0
    store    i64   .elemtype 
    load     i64   .tlength 
    loadimm  i64   0 
    jumpne   i64   #7234 
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    load     i64   .alength 
    setarg   i64   4
    loadref  u64   mm_decls.ttlower 
    load     i64   .t 
    iloadx   i32   4 0
    setarg   i64   3
    load     i64   .elemtype 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createarraymodek 5 0
    store    i64   .newt 
    jump           #7233 
#7234:
    load     i64   .t 
    store    i64   .newt 
#7233:
    load     u64   .a 
    store    u64   .q 
    jump           #7236 
#7235:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .elemtype 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .q 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #7239 
    loadimm  i64   0 
    store    i64   .isconst 
#7239:
#7238:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#7236:
    load     u64   .q 
    jumpt    u64   #7235 
#7237:
    load     i64   .newt 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7229 
#7231:
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .t 
    iloadx   u64   8 0
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .e 
    load     u64   .a 
    store    u64   .q 
    jump           #7241 
#7240:
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   14 
    jumpne   i64   #7244 
    jump           #7246 
#7245:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
    load     u64   .e 
    jumpt    u64   #7249 
    jump           #7247 
#7249:
#7248:
#7246:
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   27 
    jumpeq   i64   #7245 
#7247:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .q 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #7251 
    loadimm  i64   0 
    store    i64   .isconst 
#7251:
#7250:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#7244:
#7243:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#7241:
    load     u64   .q 
    jumpf    u64   #7252 
    load     u64   .e 
    jumpt    u64   #7240 
#7252:
#7242:
    jump           #7254 
#7253:
    load     u64   .e 
    loadimm  i64   32 
    iloadx   u64   1 0
    store    u64   .e 
#7254:
    load     u64   .e 
    jumpf    u64   #7256 
    load     u64   .e 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   14 
    jumpne   i64   #7253 
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   27 
    jumpeq   i64   #7253 
#7256:
#7255:
    load     u64   .q 
    jumpt    u64   #7259 
    load     u64   .e 
    jumpf    u64   #7258 
#7259:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Can't initialise unions"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7258:
#7257:
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7229 
#7232:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .t 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "Unknown makelist type: #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7229:
    load     i64   .isconst 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   mm_type.inidata 
    jumpt    i64   #7263 
    load     i64   .isconst 
    jumpf    i64   #7263 
    setcall        2
    loadimm  i64   11 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    u64   mm_lib.getavname 2 0
    store    u64   .e 
    load     i64   .t 
    load     u64   .e 
    loadimm  i64   64 
    istorex  i32   1 0
    setcall        1
    load     u64   .e 
    setarg   u64   1
    callp          mm_lib.addstatic 1 0
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mm_lib.createunit0 1 0
    store    u64   .q 
    load     u64   .p 
    iload    u8:64 
    load     u64   .q 
    istore   u8:64 
    load     u64   .q 
    load     u64   .e 
    loadimm  i64   56 
    istorex  u64   1 0
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .e 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
#7263:
#7262:
;------------------------
#7221:
    return         
end

proc mm_type.tx_makeslice
    param    u64   .p 
    param    u64   .a 
    param    i64   .t 
;------------------------
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    loadimm  i64   2 
    jumpeq   i64   #7266 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "slice:=[a,b]"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7266:
#7265:
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    loadimm  u64   0 
    load     u64   .a 
    loadimm  i64   8 
    istorex  u64   1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   7 
    jumpeq   i64   #7269 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "slice init not ref"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7269:
#7268:
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpeq   i64   #7272 
    setcall        2
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadref  u64   mm_decls.tttarget 
    load     i64   .t 
    iloadx   i32   4 0
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    setarg   i64   2
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7274 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "slice/ptr mismatch"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7274:
#7273:
#7272:
#7271:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   20 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   60 
    istorex  u8    1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpass 3 0
;------------------------
#7264:
    return         
end

proc mm_type.tx_makeset
    param    u64   .p 
    param    u64   .a 
    param    i64   .t 
;------------------------
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    loadimm  i64   11 
    jumpne   i64   #7278 
    setcall        3
    load     i64   .t 
    setarg   i64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_makeslice 3 0
    jump           #7276 
#7278:
#7277:
    jump           #7282 
#7279:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   59 
    iloadx   u8    1 0
    jumpt    i64   #7284 
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
#7284:
#7283:
#7280:
    load     u64   .a 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .a 
#7282:
    load     u64   .a 
    jumpt    u64   #7279 
#7281:
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7276:
    return         
end

proc mm_type.tx_dot
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    i64   .lv 
    local    i64   .recmode 
    local    i64   .recbasemode 
    local    i64   .i 
    local    i64   .j 
    local    i64   .newtag 
    local    i64   .tmode 
    local    u64   .q 
    local    u64   .pindex 
    local    u64   .d 
    local    u64   .dequiv 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .recmode 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .recmode 
    iloadx   i32   4 0
    store    i64   .recbasemode 
    jump           #7287 
#7286:
    loadref  u64   mm_decls.tttarget 
    load     i64   .recmode 
    iloadx   i32   4 0
    store    i64   .tmode 
    setcall        2
    loadimm  i64   48 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     i64   .tmode 
    double         
    load     u64   .a 
    loadimm  i64   48 
    istorex  i32   1 0
    store    i64   .recmode 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .recmode 
    iloadx   i32   4 0
    store    i64   .recbasemode 
#7287:
    load     i64   .recbasemode 
    loadimm  i64   7 
    jumpeq   i64   #7286 
#7288:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .recmode 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpeq   i64   #7290 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Bad record type"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7290:
#7289:
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    load     u64   .d 
    loadimm  i64   70 
    iloadx   u8    1 0
    loadimm  i64   0 
    jumpne   i64   #7293 
    setcall        2
    load     i64   .recmode 
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_type.resolvefield 2 0
    double         
    load     u64   .b 
    loadimm  i64   16 
    istorex  u64   1 0
    store    u64   .d 
#7293:
#7292:
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    loadimm  i64   27 
    jumpne   i64   #7295 
    load     u64   .d 
    loadimm  i64   142 
    iloadx   u8    1 0
    store    i64   .i 
    load     i64   .i 
    load     u64   .d 
    loadimm  i64   140 
    iloadx   u8    1 0
    add      i64   
    loadimm  i64   1 
    sub      i64   
    store    i64   .j 
    load     u64   .d 
    loadimm  i64   120 
    iloadx   u64   1 0
    store    u64   .dequiv 
    load     u64   .dequiv 
    load     u64   .b 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .dequiv 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .b 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .d 
    loadimm  i64   76 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    load     i64   .i 
    load     i64   .j 
    jumpne   i64   #7297 
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .i 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    store    u64   .pindex 
    loadimm  i64   46 
    store    i64   .newtag 
    jump           #7296 
#7297:
    setcall        3
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .j 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .i 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .pindex 
    loadimm  i64   9 
    load     u64   .pindex 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   1 
    load     u64   .pindex 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   60 
    istorex  u8    1 0
    loadimm  i64   1 
    load     u64   .pindex 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   60 
    istorex  u8    1 0
    loadimm  i64   47 
    store    i64   .newtag 
#7296:
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        2
    load     i64   .lv 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.twiden 2 0
    setcall        2
    load     i64   .newtag 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadimm  i64   2 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .pindex 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   60 
    istorex  u8    1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   60 
    istorex  u8    1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   60 
    istorex  u8    1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    iload    u8    
    loadimm  i64   47 
    jumpne   i64   #7299 
    load     i64   .j 
    loadref  u64   mm_tables.stdbits 
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_lib.getmemmode 1 0
    iloadx   u8    1 0
    loadimm  i64   1 
    sub      i64   
    jumpne   i64   #7299 
    loadref  u64   mm_decls.ttsigned 
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callf    i64   mm_lib.getmemmode 1 0
    iloadx   u8    1 0
    jumpf    i64   #7299 
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7299:
#7298:
    jump           #7285 
#7295:
#7294:
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .b 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .d 
    loadimm  i64   76 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    setcall        2
    load     i64   .lv 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.twiden 2 0
;------------------------
#7285:
    return         
end

proc mm_type.resolvefield
    rettype  u64   
    param    u64   .d 
    param    i64   .m 
    local    u64   .e 
    local    u64   .t 
;------------------------
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpeq   i64   #7302 1
    loadimm  i64   7 
    jumpeq   i64   #7303 
    jump           #7304 
#7302:
    jump           #7301 
#7303:
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .m 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpeq   i64   #7306 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "3:record expected"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7306:
#7305:
    jump           #7301 
#7304:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "4:record expected"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7301:
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .m 
    iloadx   u64   8 0
    store    u64   .t 
    setcall        2
    load     u64   .d 
    setarg   u64   2
    load     u64   .t 
    setarg   u64   1
    callf    u64   mm_name.finddupl 2 0
    store    u64   .e 
    load     u64   .e 
    jumpt    u64   #7310 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .d 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Not a field: #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7310:
#7309:
    load     u64   .e 
    setret   u64   
    jump           #7300 
;------------------------
#7300:
    return         
end

proc mm_type.tx_andl
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   6 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   6 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7312:
    return         
end

proc mm_type.convintconst
    param    u64   .p 
    param    i64   .x 
;------------------------
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  u64   0 
    double         
    load     u64   .p 
    loadimm  i64   32 
    istorex  u64   1 0
    double         
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    load     i64   .x 
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
;------------------------
#7313:
    return         
end

proc mm_type.tx_sliceptr
    param    u64   .p 
    param    u64   .a 
    local    i64   .m 
    local    i64   .tmode 
;------------------------
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   11 
    jumpeq   i64   #7316 
    jump           #7317 
#7316:
    jump           #7315 
#7317:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "SLICEPTR #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7315:
    setcall        5
    loadimm  i64   0 
    setarg   i64   5
    loadimm  i64   0 
    setarg   i64   4
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   3
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createarraymodek 5 0
    store    i64   .tmode 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .tmode 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7314:
    return         
end

proc mm_type.tx_swap
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    i64   .av 
    local    i64   .bv 
;------------------------
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    setcall        2
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7321 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "SWAP: type mismatch"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7321:
#7320:
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7319:
    return         
end

proc mm_type.tx_select
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    param    i64   .t 
    param    i64   .lv 
    local    i64   .i 
    local    i64   .u 
    local    u64   .q 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .b 
    store    u64   .q 
    jump           #7325 
#7324:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .q 
    load     u64   .b 
    jumpne   u64   #7328 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .u 
    jump           #7327 
#7328:
    setcall        2
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
#7327:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#7325:
    load     u64   .q 
    jumpt    u64   #7324 
#7326:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .c 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        2
    load     u64   .c 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
    load     u64   .b 
    store    u64   .q 
    jump           #7330 
#7329:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#7330:
    load     u64   .q 
    jumpt    u64   #7329 
#7331:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7333 
    load     i64   .u 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7332 
#7333:
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7332:
;------------------------
#7323:
    return         
end

proc mm_type.tx_case
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    param    i64   .t 
    param    i64   .lv 
    local    i64   .amode 
    local    i64   .u 
    local    u64   .wt 
    local    u64   .w 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   106 
    jumpne   i64   #7336 
    load     i64   .lv 
    jumpf    i64   #7336 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "&docase"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#7336:
#7335:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  u64   0 
    jumpne   u64   #7339 
    loadimm  i64   23 
    store    i64   .amode 
    jump           #7338 
#7339:
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
#7338:
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .amode 
    iloadx   u8    1 0
    jumpf    i64   #7341 
    loadref  u64   mm_decls.ttsize 
    load     i64   .amode 
    iloadx   u32   4 0
    loadimm  i64   8 
    jumpge   i64   #7341 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   3 
    store    i64   .amode 
#7341:
#7340:
    loadimm  i64   0 
    store    i64   .u 
    load     u64   .b 
    store    u64   .wt 
    jump           #7343 
#7342:
    load     u64   .wt 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .w 
    jump           #7346 
#7345:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .w 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .w 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #7349 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .amode 
    iloadx   u8    1 0
    jumpt    i64   #7351 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "case: need int index"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7351:
#7350:
    jump           #7348 
#7349:
    load     i64   .amode 
    loadimm  i64   23 
    jumpne   i64   #7354 
    loadref  u64   mm_tables.isbooltag 
    load     u64   .w 
    iload    u8    
    iloadx   u8    1 0
    jumpt    i64   #7356 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "CASE/BOOL?"
    setarg   u64   1
    callp          mm_support.txerror 2 0
    setcall        2
    loadimm  i64   15 
    setarg   i64   2
    load     u64   .w 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
#7356:
#7355:
    jump           #7353 
#7354:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .amode 
    setarg   i64   2
    load     u64   .w 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
#7353:
#7348:
    load     u64   .w 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .w 
#7346:
    load     u64   .w 
    jumpt    u64   #7345 
#7347:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7359 
    load     i64   .u 
    jumpf    i64   #7361 
    setcall        2
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
    jump           #7360 
#7361:
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .u 
#7360:
#7359:
#7358:
    load     u64   .wt 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .wt 
#7343:
    load     u64   .wt 
    jumpt    u64   #7342 
#7344:
    load     u64   .c 
    jumpf    u64   #7363 
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .c 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7365 
    setcall        2
    load     u64   .c 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
#7365:
#7364:
    jump           #7362 
#7363:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7366 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "case needs else"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7366:
#7362:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7369 
    load     i64   .u 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7368 
#7369:
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7368:
;------------------------
#7334:
    return         
end

proc mm_type.tx_notl
    param    u64   .p 
    param    u64   .a 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7370:
    return         
end

proc mm_type.tx_istruel
    param    u64   .p 
    param    u64   .a 
    local    i64   .abase 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_tables.isbooltag 
    load     u64   .a 
    iload    u8    
    iloadx   u8    1 0
    jumpf    i64   #7373 
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    jump           #7371 
#7373:
#7372:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .abase 
    load     i64   .abase 
    loadimm  i64   7 
    jumpne   i64   #7375 
    loadimm  i64   3 
    store    i64   .abase 
#7375:
#7374:
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7371:
    return         
end

proc mm_type.tx_typepun
    param    u64   .p 
    param    u64   .a 
    local    i64   .smode 
    local    i64   .tmode 
;------------------------
    load     u64   .a 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #7378 
    jump           #7379 
#7378:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "TYPEPUN/LIST"
    setarg   u64   1
    callp          mm_support.txerror 2 0
    jump           #7377 
#7379:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .smode 
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .p 
    loadimm  i64   52 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .tmode 
    loadref  u64   mm_decls.ttisreal 
    load     i64   .smode 
    iloadx   u8    1 0
    jumpf    i64   #7383 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .tmode 
    iloadx   u8    1 0
    jumpt    i64   #7382 
#7383:
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .smode 
    iloadx   u8    1 0
    jumpf    i64   #7384 
    loadref  u64   mm_decls.ttisreal 
    load     i64   .tmode 
    iloadx   u8    1 0
    jumpt    i64   #7382 
#7384:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Invalid type-punning; only real<->int"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7382:
#7381:
    load     i64   .tmode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7377:
;------------------------
#7376:
    return         
end

proc mm_type.tx_exit
    param    u64   .p 
    param    u64   .a 
;------------------------
    load     u64   .a 
    loadimm  u64   0 
    jumpne   u64   #7388 
    jump           #7386 
#7388:
#7387:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #7390 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "exit/etc not const"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7390:
#7389:
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    load     u64   .p 
    loadimm  i64   40 
    istorex  i32   1 0
    loadimm  u64   0 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
;------------------------
#7386:
    return         
end

proc mm_type.tx_goto
    param    u64   .p 
    param    u64   .a 
    local    i64   .m 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   7 
    jumpne   i64   #7395 
    loadref  u64   mm_decls.ttbasetype 
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    iloadx   i32   4 0
    loadimm  i64   25 
    jumpeq   i64   #7394 
#7395:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "goto: not label"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7394:
#7393:
;------------------------
#7392:
    return         
end

proc mm_type.tx_switch
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    u64   .c 
    param    i64   .t 
    param    i64   .lv 
    local    u8:2048 .valueset 
    local    u64   .wt 
    local    u64   .w 
    local    i64   .ax 
    local    i64   .bx 
    local    i64   .i 
    local    i64   .u 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   108 
    jumpne   i64   #7399 
    load     i64   .lv 
    jumpf    i64   #7399 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "&doswitch"
    setarg   u64   1
    callf    i64   mm_support.gerror 2 0
    unload   i64   
#7399:
#7398:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  u64   2048 
    setarg   u64   3
    loadimm  i64   0 
    setarg   i32   2
    loadref  u64   .valueset 
    setarg   u64   1
    callp          memset 3 0
    loadimm  i64   0 
    store    i64   .u 
    load     u64   .b 
    store    u64   .wt 
    jump           #7402 
#7401:
    load     u64   .wt 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .w 
    jump           #7405 
#7404:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .w 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        1
    load     u64   .w 
    setarg   u64   1
    callf    i64   mm_lib.isconstunit 1 0
    jumpt    i64   #7408 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Switch not constant"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7408:
#7407:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .w 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   9 
    jumpeq   i64   #7411 
    jump           #7412 
#7411:
    load     u64   .w 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .ax 
    load     u64   .w 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .bx 
;dorange::
#7413:
    load     i64   .ax 
    store    i64   .i 
    load     i64   .i 
    load     i64   .bx 
    jumpgt   i64   #7416 
#7414:
    load     i64   .i 
    loadimm  i64   0 
    jumplt   i64   #7419 
    load     i64   .i 
    loadimm  i64   2047 
    jumple   i64   #7418 
#7419:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "switch: value out of range"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7418:
#7417:
    loadref  u64   .valueset 
    load     i64   .i 
    iloadx   u8    1 0
    jumpf    i64   #7422 
    callp          msys.m$print_startcon 0 0
    load     i64   .i 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Duplicate switch value"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7422:
#7421:
    loadimm  i64   1 
    loadref  u64   .valueset 
    load     i64   .i 
    istorex  u8    1 0
#7415:
    forup          #7414 1
    opnd           .i 
    opnd           .bx 
#7416:
    jump           #7410 
#7412:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .w 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    setcall        1
    load     u64   .w 
    setarg   u64   1
    callp          mm_type.tevaluate 1 0
    load     u64   .w 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #7425 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Switch value: not const int"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7425:
#7424:
    load     u64   .w 
    loadimm  i64   16 
    iloadx   i64   1 0
    double         
    store    i64   .bx 
    store    i64   .ax 
    jump           #7413 
#7410:
    load     u64   .w 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .w 
#7405:
    load     u64   .w 
    jumpt    u64   #7404 
#7406:
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7428 
    load     i64   .u 
    jumpf    i64   #7430 
    setcall        2
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
    jump           #7429 
#7430:
    load     u64   .wt 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .u 
#7429:
#7428:
#7427:
    load     u64   .wt 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .wt 
#7402:
    load     u64   .wt 
    jumpt    u64   #7401 
#7403:
    load     u64   .c 
    jumpf    u64   #7432 
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     u64   .c 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7434 
    setcall        2
    load     u64   .c 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     i64   .u 
    setarg   i64   1
    callf    i64   mm_type.getdominantmode 2 0
    store    i64   .u 
#7434:
#7433:
    jump           #7431 
#7432:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7435 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "switch needs else"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7435:
#7431:
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7438 
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .w 
    jump           #7440 
#7439:
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7443 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .b 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
#7443:
#7442:
    load     u64   .b 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .w 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .w 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .w 
#7440:
    load     u64   .w 
    jumpt    u64   #7439 
#7441:
    load     i64   .t 
    loadimm  i64   23 
    jumpne   i64   #7445 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .u 
    setarg   i64   2
    load     u64   .c 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    load     i64   .u 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7444 
#7445:
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7444:
    jump           #7437 
#7438:
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7437:
;------------------------
#7397:
    return         
end

proc mm_type.tx_addroffirst
    param    u64   .p 
    param    u64   .a 
    param    i64   .t 
    local    i64   .m 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpeq   i64   #7448 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "&. ref[] expected"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7448:
#7447:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadref  u64   mm_decls.tttarget 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    store    i64   .m 
    load     u64   .a 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #7451 
    loadimm  i64   1 
    load     u64   .a 
    loadimm  i64   40 
    istorex  u8    1 0
#7451:
#7450:
    load     i64   .m 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7446:
    return         
end

proc mm_type.tx_return
    param    u64   .p 
    param    u64   .a 
    param    i64   .t 
    local    i64   .m 
    local    i64   .nvalues 
    local    i64   .nret 
    local    i64   .i 
    local    u64   .pmult 
    local    u64   .q 
;------------------------
    load     u64   mm_decls.currproc 
    loadimm  i64   64 
    iloadx   i32   1 0
    store    i64   .m 
    load     u64   mm_decls.currproc 
    loadimm  i64   115 
    iloadx   u8    1 0
    store    i64   .nret 
    loadref  u64   mm_decls.ttmult 
    load     u64   mm_decls.currproc 
    loadimm  i64   64 
    iloadx   i32   1 0
    iloadx   u64   8 0
    store    u64   .pmult 
    load     u64   .a 
    loadimm  u64   0 
    jumpne   u64   #7454 
    load     i64   .nret 
    jumpf    i64   #7456 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "return value(s) missing"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7456:
#7455:
    jump           #7452 
    jump           #7453 
#7454:
    load     i64   .nret 
    loadimm  i64   0 
    jumpne   i64   #7458 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Superfluous return value"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7458:
#7453:
    load     u64   .a 
    iload    u8    
    loadimm  i64   16 
    jumpne   i64   #7461 
    loadimm  i64   21 
    load     u64   .a 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .a 
    loadimm  i64   40 
    iloadx   u32   1 0
    load     i64   .nret 
    jumpeq   i64   #7463 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   8 
    jumpeq   i64   #7465 1
    loadimm  i64   10 
    jumpeq   i64   #7465 
    jump           #7466 
#7465:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "return constructor not supported"
    setarg   u64   1
    callp          mm_support.txerror 2 0
    jump           #7464 
#7466:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Wrong number of return values"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7464:
#7463:
#7462:
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nret 
    loadimm  i64   1 
    jumplt   i64   #7471 
#7469:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .pmult 
    load     i64   .i 
    iloadx   i32   4 -4
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#7470:
    forup          #7469 1
    opnd           .i 
    opnd           .nret 
#7471:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   60 
    istorex  u8    1 0
    load     i64   .t 
    loadimm  i64   0 
    jumpne   i64   #7473 
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7472 
#7473:
    loadimm  i64   28 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7472:
    jump           #7460 
#7461:
    load     i64   .nret 
    loadimm  i64   1 
    jumple   i64   #7475 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "RETERROR?"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7475:
#7474:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   0 
    jumpne   i64   #7478 
    loadimm  i64   0 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7477 
#7478:
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
#7477:
#7460:
    loadref  u64   mm_decls.ttisshort 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #7480 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "SHORT RET TYPE"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7480:
#7479:
;------------------------
#7452:
    return         
end

proc mm_type.tx_dotindex
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    i64   .lv 
    local    i64   .pmode 
    local    u64   .i 
    local    u64   .j 
;------------------------
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadimm  i64   2 
    store    i64   .pmode 
    loadref  u64   mm_decls.ttisinteger 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpt    i64   #7484 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "a.[i]: not int/str value"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7484:
#7483:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   9 
    jumpeq   i64   #7487 
    jump           #7488 
#7487:
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .i 
    load     u64   .b 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .j 
    load     u64   .i 
    iload    u8    
    load     u64   .j 
    iload    u8    
    swapopnds      
    jumpne   i64   #7490 1
    loadimm  i64   1 
    jumpne   i64   #7490 
    load     u64   .i 
    loadimm  i64   16 
    iloadx   i64   1 0
    load     u64   .j 
    loadimm  i64   16 
    iloadx   i64   1 0
    jumple   i64   #7492 
    load     u64   .b 
    loadimm  i64   16 
    addptrx  u64   1 0
    load     u64   .b 
    loadimm  i64   24 
    addptrx  u64   1 0
    swapmem  u64   
#7492:
#7491:
#7490:
#7489:
    jump           #7486 
#7488:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
#7486:
    load     i64   .pmode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7482:
    return         
end

proc mm_type.tx_slice
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   21 
    jumpne   i64   #7495 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   1 
    setarg   i64   3
    loadimm  i64   13 
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    i64   mm_lib.createslicemodek 4 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7494 
#7495:
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.deref 2 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpeq   i64   #7497 1
    loadimm  i64   11 
    jumpeq   i64   #7498 
    jump           #7499 
#7497:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  i64   1 
    setarg   i64   3
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    setarg   i64   2
    load     u64   mm_decls.currproc 
    setarg   u64   1
    callf    i64   mm_lib.createslicemodek 4 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7496 
#7498:
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7496 
#7499:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "STRMODE(A.MODE)="
    callp          msys.m$print_str_nf 1 0
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "a[i..j]: not array"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7496:
#7494:
;------------------------
#7493:
    return         
end

proc mm_type.twiden
    param    u64   .p 
    param    i64   .lv 
    local    i64   .m 
    local    i64   .u 
    local    i64   .mbase 
;------------------------
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    double         
    store    i64   .m 
    iloadx   i32   4 0
    store    i64   .mbase 
    load     i64   .mbase 
    loadimm  i64   0 
    jumpne   i64   #7504 
    jump           #7502 
#7504:
#7503:
    load     i64   .lv 
    jumpf    i64   #7506 
    jump           #7502 
#7506:
#7505:
    loadref  u64   mm_decls.ttisshort 
    load     i64   .mbase 
    iloadx   u8    1 0
    jumpt    i64   #7508 
    jump           #7502 
#7508:
#7507:
    load     u64   .p 
    iload    u8    
    loadimm  i64   3 
    jumpeq   i64   #7510 1
    loadimm  i64   48 
    jumpeq   i64   #7510 1
    loadimm  i64   43 
    jumpeq   i64   #7510 1
    loadimm  i64   45 
    jumpeq   i64   #7510 1
    loadimm  i64   88 
    jumpeq   i64   #7511 1
    loadimm  i64   29 
    jumpeq   i64   #7511 
    jump           #7512 
#7510:
    load     i64   .m 
    load     u64   .p 
    loadimm  i64   63 
    istorex  u8    1 0
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    i64   mm_lib.gettypebase 1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7509 
#7511:
    load     i64   .m 
    load     u64   .p 
    loadimm  i64   63 
    istorex  u8    1 0
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    i64   mm_lib.gettypebase 1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7509 
#7512:
    setcall        4
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   "*"
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_diags.printunit 4 0
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    loadref  u64   mm_tables.jtagnames 
    load     u64   .p 
    iload    u8    
    iloadx   u64   8 0
    setarg   u64   2
    loadimm  u64   "widen? #"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7509:
;------------------------
#7502:
    return         
end

proc mm_type.tstringslice
    param    u64   .p 
    param    i64   .slicemode 
    local    u64   .a 
    local    u64   .b 
    local    u64   .prange 
    local    i64   .length 
;------------------------
    loadref  u64   mm_decls.tttarget 
    load     i64   .slicemode 
    iloadx   i32   4 0
    loadimm  i64   13 
    jumpeq   i64   #7517 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Not char slice"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7517:
#7516:
    load     u64   .p 
    store    u64   .a 
    setcall        2
    loadimm  i64   44 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7520 
    jump           #7519 
#7520:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_lib.duplunit 2 0
    store    u64   .b 
    setcall        2
    loadimm  i64   33 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    setcall        3
    load     u64   .b 
    setarg   u64   3
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    loadimm  u64   1 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .prange 
    loadimm  i64   9 
    load     u64   .prange 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .prange 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
#7519:
    load     i64   .slicemode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7515:
    return         
end

proc mm_type.tx_bitfield
    param    u64   .p 
    param    u64   .a 
    param    i64   .lv 
    local    i64   .i 
    local    i64   .j 
    local    i64   .bitsize 
    local    i64   .topbit 
    local    u64   .r 
;------------------------
    setcall        3
    load     i64   .lv 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_decls.ttisinteger 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpt    i64   #7523 
    loadref  u64   mm_decls.ttisref 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpt    i64   #7523 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Int/ref needed"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7523:
#7522:
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    iloadx   u32   4 0
    loadimm  i64   8 
    mul      i64   
    store    i64   .bitsize 
    load     i64   .bitsize 
    loadimm  i64   1 
    sub      i64   
    store    i64   .topbit 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    loadimm  i64   2 
    jumpeq   i64   #7526 1
    loadimm  i64   1 
    jumpeq   i64   #7527 1
    loadimm  i64   4 
    jumpeq   i64   #7528 1
    loadimm  i64   7 
    jumpeq   i64   #7529 1
    loadimm  i64   8 
    jumpeq   i64   #7529 1
    loadimm  i64   3 
    jumpeq   i64   #7530 1
    loadimm  i64   6 
    jumpeq   i64   #7531 1
    loadimm  i64   5 
    jumpeq   i64   #7532 
    jump           #7533 
#7526:
    loadimm  i64   0 
    store    i64   .i 
    loadimm  i64   7 
    store    i64   .j 
    jump           #7525 
#7527:
    load     i64   .topbit 
    store    i64   .j 
    load     i64   .topbit 
    loadimm  i64   7 
    sub      i64   
    store    i64   .i 
    jump           #7525 
#7528:
    loadimm  i64   0 
    double         
    store    i64   .j 
    store    i64   .i 
    jump           #7525 
#7529:
    load     i64   .lv 
    jumpf    i64   #7535 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Can't assign"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7535:
#7534:
    loadimm  i64   0 
    double         
    store    i64   .j 
    store    i64   .i 
    jump           #7525 
#7530:
    load     i64   .topbit 
    double         
    store    i64   .j 
    store    i64   .i 
    jump           #7525 
#7531:
    loadimm  i64   0 
    store    i64   .i 
    load     i64   .bitsize 
    loadimm  i64   2 
    div      i64   
    loadimm  i64   1 
    sub      i64   
    store    i64   .j 
    jump           #7525 
#7532:
    load     i64   .bitsize 
    loadimm  i64   2 
    div      i64   
    store    i64   .i 
    load     i64   .topbit 
    store    i64   .j 
    jump           #7525 
#7533:
    callp          msys.m$print_startcon 0 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "BITFIELD"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7525:
    load     i64   .i 
    load     i64   .j 
    jumpne   i64   #7539 
    loadimm  i64   46 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .i 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   60 
    istorex  u8    1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   60 
    istorex  u8    1 0
    load     u64   .p 
    loadimm  i64   40 
    iloadx   i16   1 0
    loadimm  i64   8 
    jumpne   i64   #7541 
    loadimm  i64   2 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.addnotl 1 0
#7541:
#7540:
    jump           #7538 
#7539:
    setcall        3
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .j 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .i 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    setarg   u64   2
    loadimm  i64   17 
    setarg   i64   1
    callf    u64   mm_lib.createunit2 3 0
    store    u64   .r 
    loadimm  i64   1 
    load     u64   .r 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   60 
    istorex  u8    1 0
    loadimm  i64   1 
    load     u64   .r 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   60 
    istorex  u8    1 0
    loadimm  i64   9 
    load     u64   .r 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   47 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .r 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
#7538:
    loadimm  i64   2 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7521:
    return         
end

proc mm_type.deref
    param    u64   .a 
    param    i64   .needres 
    local    i64   .abasemode 
    local    i64   .tmode 
;------------------------
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .abasemode 
    jump           #7544 
#7543:
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .tmode 
    setcall        2
    loadimm  i64   48 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     i64   .tmode 
    load     u64   .a 
    loadimm  i64   48 
    istorex  i32   1 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .abasemode 
#7544:
    load     i64   .abasemode 
    loadimm  i64   7 
    jumpeq   i64   #7543 
#7545:
;------------------------
#7542:
    return         
end

proc mm_type.tmethodcall
    param    u64   .p 
    param    u64   .pdot 
    param    u64   .pargs 
    local    i64   .mrec 
    local    u64   .prec 
    local    u64   .pfield 
    local    u64   .pfunc 
    local    u64   .d 
    local    u64   .e 
;------------------------
    load     u64   .pdot 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .prec 
    load     u64   .pdot 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .pfield 
    load     u64   .prec 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .mrec 
    load     u64   .pfield 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .d 
    setcall        2
    load     i64   .mrec 
    setarg   i64   2
    load     u64   .d 
    setarg   u64   1
    callf    u64   mm_type.resolvefield 2 0
    store    u64   .e 
    load     u64   .e 
    loadimm  u64   0 
    jumpne   u64   #7548 
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .d 
    iload    u64   
    setarg   u64   2
    loadimm  u64   "Can't resolve method:"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7548:
#7547:
    setcall        1
    load     u64   .e 
    setarg   u64   1
    callf    u64   mm_lib.createname 1 0
    store    u64   .pfunc 
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    load     u64   .pfunc 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .pargs 
    load     u64   .prec 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .pfunc 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .prec 
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
;------------------------
#7546:
    return         
end

proc mm_type.do_bounds
    param    u64   .p 
    param    u64   .a 
    local    i64   .m 
    local    i64   .mbase 
    local    i64   .opc 
    local    i64   .lower 
    local    i64   .upper 
;------------------------
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.deref 2 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
    load     u64   .a 
    iload    u8    
    loadimm  i64   55 
    jumpne   i64   #7552 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .m 
#7552:
#7551:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    store    i64   .mbase 
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   153 
    jumpeq   i64   #7554 1
    loadimm  i64   154 
    jumpeq   i64   #7555 1
    loadimm  i64   155 
    jumpeq   i64   #7556 1
    loadimm  i64   158 
    jumpeq   i64   #7557 
    jump           #7558 
#7554:
    load     i64   .mbase 
    loadimm  i64   10 
    jumpeq   i64   #7560 1
    loadimm  i64   11 
    jumpeq   i64   #7560 
    jump           #7561 
#7560:
    setcall        2
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.convintconst 2 0
    jump           #7550 
    jump           #7559 
#7561:
;error::
#7562:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .m 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "lwb/upb/len?"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7559:
    jump           #7553 
#7555:
    load     i64   .mbase 
    loadimm  i64   10 
    jumpeq   i64   #7565 1
    loadimm  i64   11 
    jumpeq   i64   #7566 
    jump           #7567 
#7565:
    setcall        2
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    add      i64   
    loadimm  i64   1 
    sub      i64   
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.convintconst 2 0
    jump           #7564 
#7566:
    loadimm  i64   154 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #7564 
#7567:
    jump           #7562 
#7564:
    jump           #7553 
#7556:
    load     i64   .mbase 
    loadimm  i64   10 
    jumpeq   i64   #7569 1
    loadimm  i64   11 
    jumpeq   i64   #7570 
    jump           #7571 
#7569:
    setcall        2
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.convintconst 2 0
    jump           #7568 
#7570:
    loadimm  i64   155 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    jump           #7568 
#7571:
    jump           #7562 
#7568:
    jump           #7553 
#7557:
    loadimm  i64   9 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     i64   .mbase 
    loadimm  i64   10 
    jumpeq   i64   #7573 1
    loadimm  i64   11 
    jumpeq   i64   #7574 
    jump           #7575 
#7573:
    loadref  u64   mm_decls.ttlower 
    load     i64   .m 
    iloadx   i32   4 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  i64   1 0
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .m 
    iloadx   i32   4 0
    add      i64   
    loadimm  i64   1 
    sub      i64   
    load     u64   .p 
    loadimm  i64   24 
    istorex  i64   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  u64   0 
    double         
    load     u64   .p 
    loadimm  i64   32 
    istorex  u64   1 0
    double         
    load     u64   .p 
    loadimm  i64   24 
    istorex  u64   1 0
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
    jump           #7550 
    jump           #7572 
#7574:
    jump           #7572 
#7575:
    jump           #7562 
#7572:
    jump           #7553 
#7558:
#7553:
;------------------------
#7550:
    return         
end

proc mm_type.addnotl
    param    u64   .p 
;------------------------
    setcall        2
    loadimm  i64   14 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   102 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
;------------------------
#7576:
    return         
end

proc mm_type.tevaluate
    param    u64   .p 
    local    u64   .a 
    local    u64   .b 
    local    u64   .pname 
    local    i64   .offset 
    local    i64   .tag 
;------------------------
    load     u64   .p 
    iload    u8    
    store    i64   .tag 
    loadref  u64   mm_tables.jisexpr 
    load     i64   .tag 
    iloadx   u8    1 0
    loadimm  i64   2 
    jumpne   i64   #7579 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tevalbinop 1 0
    jump           #7578 
#7579:
    loadref  u64   mm_tables.jisexpr 
    load     i64   .tag 
    iloadx   u8    1 0
    loadimm  i64   1 
    jumpne   i64   #7580 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tevalmonop 1 0
    jump           #7578 
#7580:
    load     i64   .tag 
    loadimm  i64   17 
    jumpeq   i64   #7582 
    jump           #7583 
#7582:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .b 
    loadref  u64   mm_decls.ttsize 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u32   4 0
    loadimm  i64   8 
    jumpgt   i64   #7585 
    setcall        1
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tevaluate 1 0
    setcall        1
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tevaluate 1 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7587 
    load     u64   .b 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7587 
    load     u64   .a 
    loadimm  i64   59 
    iloadx   u8    1 0
    load     u64   .b 
    loadimm  i64   59 
    iloadx   u8    1 0
    bitand   i64   
    load     u64   .p 
    loadimm  i64   59 
    istorex  u8    1 0
#7587:
#7586:
#7585:
#7584:
    jump           #7581 
#7583:
#7581:
#7578:
;------------------------
#7577:
    return         
end

proc mm_type.addrdotindex
    rettype  u64   
    param    u64   .p 
    param    u64   .offset 
    local    u64   .q 
    local    i64   .axmode 
;------------------------
    startmx        
    load     u64   .p 
    iload    u8    
    loadimm  i64   45 
    jumpeq   i64   #7590 1
    loadimm  i64   43 
    jumpeq   i64   #7591 
    jump           #7592 
#7590:
    startmx        
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #7594 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    load     u64   .offset 
    istore   i64   
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    resetmx        
    jump           #7593 
#7594:
    setcall        2
    load     u64   .offset 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_type.addrdotindex 2 0
    store    u64   .q 
    load     u64   .offset 
    load     u64   .p 
    loadimm  i64   40 
    iloadx   u32   1 0
    addto    i64   
    load     u64   .q 
    endmx          
#7593:
    resetmx        
    jump           #7589 
#7591:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .axmode 
    startmx        
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7596 
    startmx        
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #7598 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .axmode 
    iloadx   i32   4 0
    sub      i64   
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     i64   .axmode 
    iloadx   i32   4 0
    iloadx   u32   4 0
    mul      i64   
    load     u64   .offset 
    istore   i64   
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    resetmx        
    jump           #7597 
#7598:
    setcall        2
    load     u64   .offset 
    setarg   u64   2
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_type.addrdotindex 2 0
    store    u64   .q 
    load     u64   .q 
    jumpf    u64   #7600 
    load     u64   .offset 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    loadref  u64   mm_decls.ttlower 
    load     i64   .axmode 
    iloadx   i32   4 0
    sub      i64   
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     i64   .axmode 
    iloadx   i32   4 0
    iloadx   u32   4 0
    mul      i64   
    addto    i64   
#7600:
#7599:
    load     u64   .q 
    endmx          
#7597:
    resetmx        
    jump           #7595 
#7596:
    loadimm  u64   0 
    endmx          
#7595:
    resetmx        
    jump           #7589 
#7592:
    loadimm  u64   0 
    endmx          
#7589:
    setret   u64   
    jump           #7588 
;------------------------
#7588:
    return         
end

proc mm_type.tevalbinop
    param    u64   .p 
    local    i64   .a 
    local    i64   .b 
    local    i64   .c 
    local    i64   .offset 
    local    r64   .x 
    local    r64   .y 
    local    r64   .z 
    local    u64   .lhs 
    local    u64   .rhs 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .lhs 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .rhs 
    load     u64   .lhs 
    iload    u8    
    load     u64   .rhs 
    iload    u8    
    swapopnds      
    jumpne   i64   #7604 1
    loadimm  i64   1 
    jumpeq   i64   #7603 
#7604:
    load     u64   .lhs 
    iload    u8    
    loadimm  i64   49 
    jumpne   i64   #7606 
    load     u64   .rhs 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7606 
    load     u64   .lhs 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #7608 
    load     u64   .rhs 
    loadimm  i64   16 
    iloadx   i64   1 0
    loadref  u64   mm_decls.ttsize 
    loadref  u64   mm_decls.tttarget 
    load     u64   .lhs 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    iloadx   u32   4 0
    mul      i64   
    store    i64   .offset 
    load     u64   .lhs 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #7610 
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     i64   .offset 
    setarg   u64   1
    callf    u64   mm_lib.createconstunit 2 0
    load     u64   .lhs 
    loadimm  i64   24 
    istorex  u64   1 0
    jump           #7609 
#7610:
    load     u64   .lhs 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    addptrx  u64   1 0
    load     i64   .offset 
    addto    i64   
#7609:
    setcall        2
    load     u64   .lhs 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
#7608:
#7607:
#7606:
#7605:
    jump           #7601 
#7603:
#7602:
    loadref  u64   mm_decls.ttisreal 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #7612 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   r64   1 0
    store    r64   .x 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   r64   1 0
    store    r64   .y 
    jump           #7611 
#7612:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .a 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .b 
#7611:
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   3 
    jumpeq   i64   #7614 1
    loadimm  i64   2 
    jumpeq   i64   #7614 1
    loadimm  i64   5 
    jumpeq   i64   #7615 1
    loadimm  i64   4 
    jumpeq   i64   #7615 
    jump           #7616 
#7614:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    switch         #7618 64 162
    opnd           #7619 
#7618:
    swlabel        #7620 
    swlabel        #7621 
    swlabel        #7622 
    swlabel        #7623 
    swlabel        #7624 
    swlabel        #7619 
    swlabel        #7639 
    swlabel        #7640 
    swlabel        #7619 
    swlabel        #7625 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7626 
    swlabel        #7627 
    swlabel        #7628 
    swlabel        #7629 
    swlabel        #7630 
    swlabel        #7631 
    swlabel        #7641 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7619 
    swlabel        #7632 
    swlabel        #7635 
    endsw          
#7620:
    load     i64   .a 
    load     i64   .b 
    add      i64   
    store    i64   .c 
    jump           #7617 
#7621:
    load     i64   .a 
    load     i64   .b 
    sub      i64   
    store    i64   .c 
    jump           #7617 
#7622:
    load     i64   .a 
    load     i64   .b 
    mul      i64   
    store    i64   .c 
    jump           #7617 
#7623:
    load     i64   .a 
    load     i64   .b 
    div      i64   
    store    i64   .c 
    jump           #7617 
#7624:
    load     i64   .a 
    load     i64   .b 
    rem      i64   
    store    i64   .c 
    jump           #7617 
#7625:
    load     i64   .a 
    load     i64   .b 
    shl      i64   
    store    i64   .c 
    jump           #7617 
#7626:
    load     i64   .a 
    load     i64   .b 
    eq       i64   
    store    i64   .c 
    jump           #7617 
#7627:
    load     i64   .a 
    load     i64   .b 
    ne       i64   
    store    i64   .c 
    jump           #7617 
#7628:
    load     i64   .a 
    load     i64   .b 
    lt       i64   
    store    i64   .c 
    jump           #7617 
#7629:
    load     i64   .a 
    load     i64   .b 
    le       i64   
    store    i64   .c 
    jump           #7617 
#7630:
    load     i64   .a 
    load     i64   .b 
    ge       i64   
    store    i64   .c 
    jump           #7617 
#7631:
    load     i64   .a 
    load     i64   .b 
    gt       i64   
    store    i64   .c 
    jump           #7617 
#7632:
    startmx        
    load     i64   .a 
    jumpf    i64   #7633 
    load     i64   .b 
    jumpf    i64   #7633 
    loadimm  i64   1 
    resetmx        
    jump           #7634 
#7633:
    loadimm  i64   0 
    endmx          
#7634:
    store    i64   .c 
    jump           #7617 
#7635:
    startmx        
    load     i64   .a 
    jumpt    i64   #7636 
    load     i64   .b 
    jumpf    i64   #7637 
#7636:
    loadimm  i64   1 
    resetmx        
    jump           #7638 
#7637:
    loadimm  i64   0 
    endmx          
#7638:
    store    i64   .c 
    jump           #7617 
#7639:
    load     i64   .a 
    load     i64   .b 
    bitand   i64   
    store    i64   .c 
    jump           #7617 
#7640:
    load     i64   .a 
    load     i64   .b 
    bitor    i64   
    store    i64   .c 
    jump           #7617 
#7641:
    load     i64   .a 
    load     i64   .b 
    power    i64   
    store    i64   .c 
    jump           #7617 
#7619:
    jump           #7601 
#7617:
    jump           #7613 
#7615:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    switch         #7643 64 175
    opnd           #7644 
#7643:
    swlabel        #7645 
    swlabel        #7646 
    swlabel        #7647 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7644 
    swlabel        #7648 
    endsw          
#7645:
    load     r64   .x 
    load     r64   .y 
    add      r64   
    store    r64   .z 
    jump           #7642 
#7646:
    load     r64   .x 
    load     r64   .y 
    sub      r64   
    store    r64   .z 
    jump           #7642 
#7647:
    load     r64   .x 
    load     r64   .y 
    mul      r64   
    store    r64   .z 
    jump           #7642 
#7648:
    load     r64   .x 
    load     r64   .y 
    div      r64   
    store    r64   .z 
    jump           #7642 
#7644:
    jump           #7601 
#7642:
    jump           #7613 
#7616:
    jump           #7601 
#7613:
    loadref  u64   mm_decls.ttisreal 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #7650 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     r64   .z 
    typepun  i64 r64 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.makenewconst 3 0
    jump           #7649 
#7650:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .c 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.makenewconst 3 0
#7649:
;------------------------
#7601:
    return         
end

proc mm_type.tevalmonop
    param    u64   .p 
    local    i64   .a 
    local    i64   .b 
    local    i64   .c 
    local    r64   .x 
    local    r64   .z 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   31 
    jumpne   i64   #7653 
    jump           #7651 
#7653:
#7652:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #7655 
    jump           #7651 
#7655:
#7654:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .a 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   16 
    iloadx   r64   1 0
    store    r64   .x 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   3 
    jumpeq   i64   #7657 1
    loadimm  i64   2 
    jumpeq   i64   #7657 1
    loadimm  i64   5 
    jumpeq   i64   #7658 1
    loadimm  i64   4 
    jumpeq   i64   #7658 1
    loadimm  i64   6 
    jumpeq   i64   #7659 
    jump           #7660 
#7657:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    switch         #7662 99 103
    opnd           #7663 
#7662:
    swlabel        #7664 
    swlabel        #7668 
    swlabel        #7667 
    swlabel        #7666 
    swlabel        #7665 
    endsw          
#7664:
    load     i64   .a 
    neg      i64   
    store    i64   .c 
    jump           #7661 
#7665:
    load     i64   .a 
    notnot   i64   
    store    i64   .c 
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7661 
#7666:
    load     i64   .a 
    notnot   i64   
    not      i64   
    store    i64   .c 
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7661 
#7667:
    load     i64   .a 
    bitnot   i64   
    store    i64   .c 
    jump           #7661 
#7668:
    load     i64   .a 
    abs      i64   
    store    i64   .c 
    jump           #7661 
#7663:
    jump           #7651 
#7661:
    jump           #7656 
#7658:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    switch         #7670 99 112
    opnd           #7671 
#7670:
    swlabel        #7672 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7674 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7671 
    swlabel        #7673 
    endsw          
#7672:
    load     r64   .x 
    neg      r64   
    store    r64   .z 
    jump           #7669 
#7673:
    load     r64   .x 
    atan     r64   
    store    r64   .z 
    jump           #7669 
#7674:
    load     r64   .x 
    sqrt     r64   
    store    r64   .z 
    jump           #7669 
#7671:
    jump           #7651 
#7669:
    jump           #7656 
#7659:
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   103 
    jumpeq   i64   #7676 1
    loadimm  i64   102 
    jumpeq   i64   #7677 
    jump           #7678 
#7676:
    load     i64   .a 
    notnot   i64   
    store    i64   .c 
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7675 
#7677:
    load     i64   .a 
    notnot   i64   
    not      i64   
    store    i64   .c 
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7675 
#7678:
#7675:
    jump           #7656 
#7660:
    jump           #7651 
#7656:
    loadref  u64   mm_decls.ttisreal 
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpf    i64   #7680 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     r64   .z 
    typepun  i64 r64 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.makenewconst 3 0
    jump           #7679 
#7680:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .c 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.makenewconst 3 0
#7679:
;------------------------
#7651:
    return         
end

proc mm_type.iscondtrue
    rettype  i64   
    param    u64   .p 
;------------------------
    startmx        
    load     u64   .p 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7682 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    loadimm  i64   0 
    jumpeq   i64   #7682 
    loadimm  i64   1 
    resetmx        
    jump           #7683 
#7682:
    loadimm  i64   0 
    endmx          
#7683:
    setret   i64   
    jump           #7681 
;------------------------
#7681:
    return         
end

proc mm_type.iscondfalse
    rettype  i64   
    param    u64   .p 
;------------------------
    startmx        
    load     u64   .p 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7685 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    loadimm  i64   0 
    jumpne   i64   #7685 
    loadimm  i64   1 
    resetmx        
    jump           #7686 
#7685:
    loadimm  i64   0 
    endmx          
#7686:
    setret   i64   
    jump           #7684 
;------------------------
#7684:
    return         
end

proc mm_type.fixchararray
    param    u64   .a 
;------------------------
    load     u64   .a 
    jumpf    u64   #7689 
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   10 
    jumpne   i64   #7689 
    loadref  u64   mm_decls.tttarget 
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   13 
    jumpne   i64   #7689 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   21 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
#7689:
#7688:
;------------------------
#7687:
    return         
end

proc mm_type.combinestrings
    param    u64   .p 
    local    u64   .a 
    local    u64   .b 
    local    i64   .alen 
    local    i64   .blen 
    local    i64   .clen 
    local    u64   .s 
;------------------------
    load     u64   .p 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .a 
    load     u64   .p 
    loadimm  i64   24 
    iloadx   u64   1 0
    store    u64   .b 
    load     u64   .a 
    loadimm  i64   40 
    iloadx   u32   1 0
    store    i64   .alen 
    load     u64   .b 
    loadimm  i64   40 
    iloadx   u32   1 0
    store    i64   .blen 
    load     i64   .alen 
    load     i64   .blen 
    add      i64   
    store    i64   .clen 
    load     i64   .blen 
    loadimm  i64   0 
    jumpne   i64   #7692 
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    jump           #7690 
    jump           #7691 
#7692:
    load     i64   .alen 
    loadimm  i64   0 
    jumpne   i64   #7693 
    setcall        2
    load     u64   .b 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    jump           #7690 
#7693:
#7691:
    setcall        1
    load     i64   .clen 
    loadimm  i64   1 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .s 
    setcall        3
    load     i64   .alen 
    setarg   u64   3
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callp          memcpy 3 0
    setcall        3
    load     i64   .blen 
    setarg   u64   3
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .s 
    load     i64   .alen 
    addptrx  u64   1 0
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   .s 
    load     i64   .clen 
    addptrx  u64   1 0
    istore   u8    
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
    load     i64   .clen 
    load     u64   .p 
    loadimm  i64   40 
    istorex  u32   1 0
    load     u64   .s 
    load     u64   .p 
    loadimm  i64   16 
    istorex  u64   1 0
;------------------------
#7690:
    return         
end

proc mm_type.tx_strinclude
    param    u64   .p 
    param    u64   .a 
    local    i64   .fileno 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     u64   .a 
    iload    u8    
    loadimm  i64   1 
    jumpne   i64   #7697 
    load     u64   .a 
    loadimm  i64   44 
    iloadx   u8    1 0
    jumpt    i64   #7696 
#7697:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "strincl/not string"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7696:
#7695:
    loadref  u64   mm_decls.moduletable 
    load     u64   .p 
    loadimm  i64   56 
    iloadx   u8    1 0
    addptrx  u8:70 70 0
    loadimm  i64   64 
    iloadx   i16   1 0
    store    i64   .fileno 
    setcall        5
    loadimm  i64   1 
    setarg   i64   5
    loadimm  i64   0 
    setarg   i64   4
    loadref  u64   mm_decls.sourcefilepaths 
    load     i64   .fileno 
    iloadx   u64   8 0
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   mm_support.getsupportfile 5 0
    store    i64   .fileno 
    loadref  u64   mm_decls.sourcefiletext 
    load     i64   .fileno 
    iloadx   u64   8 0
    load     u64   .a 
    loadimm  i64   16 
    istorex  u64   1 0
    loadref  u64   mm_decls.sourcefilesizes 
    load     i64   .fileno 
    iloadx   i64   8 0
    load     u64   .a 
    loadimm  i64   40 
    istorex  u32   1 0
    setcall        2
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.deleteunit 2 0
;------------------------
#7694:
    return         
end

proc mm_type.coerceunit
    param    u64   .p 
    param    i64   .t 
    param    i64   .hard 
    local    i64   .opc 
    local    i64   .s 
;------------------------
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .s 
    load     i64   .t 
    loadimm  i64   0 
    jumpeq   i64   #7703 
    load     i64   .s 
    load     i64   .t 
    jumpne   i64   #7702 
#7703:
    jump           #7700 
#7702:
#7701:
    load     i64   .s 
    loadimm  i64   0 
    jumpne   i64   #7705 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Void expression/return value missing"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7705:
#7704:
    setcall        3
    load     i64   .hard 
    setarg   i64   3
    load     i64   .t 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    i64   mm_type.getconversionop 3 0
    store    i64   .opc 
    setcall        4
    load     i64   .opc 
    setarg   i64   4
    load     i64   .t 
    setarg   i64   3
    load     i64   .s 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.applyconversion 4 0
;------------------------
#7700:
    return         
end

proc mm_type.getconversionop
    rettype  i64   
    param    i64   .s 
    param    i64   .t 
    param    i64   .hard 
    local    i64   .opc 
    local    i64   .sbase 
    local    i64   .tbase 
    local    i64   .starg 
    local    i64   .ttarg 
;------------------------
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .s 
    iloadx   i32   4 0
    store    i64   .sbase 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    store    i64   .tbase 
    load     i64   .s 
    load     i64   .t 
    jumpne   i64   #7709 
    loadimm  i64   0 
    setret   i64   
    jump           #7707 
#7709:
#7708:
    loadimm  i64   168 
    store    i64   .opc 
    loadref  u64   mm_decls.tttarget 
    load     i64   .s 
    iloadx   i32   4 0
    store    i64   .starg 
    loadref  u64   mm_decls.tttarget 
    load     i64   .t 
    iloadx   i32   4 0
    store    i64   .ttarg 
    load     i64   .s 
    loadimm  i64   21 
    jumpne   i64   #7711 
    loadimm  i64   21 
    store    i64   .sbase 
#7711:
#7710:
    load     i64   .t 
    loadimm  i64   21 
    jumpne   i64   #7713 
    loadimm  i64   21 
    store    i64   .tbase 
#7713:
#7712:
    load     i64   .sbase 
    switch         #7715 1 26
    opnd           #7716 
#7715:
    swlabel        #7717 
    swlabel        #7717 
    swlabel        #7717 
    swlabel        #7717 
    swlabel        #7717 
    swlabel        #7733 
    swlabel        #7737 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7760 
    swlabel        #7773 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7750 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7716 
    swlabel        #7783 
    endsw          
#7717:
    load     i64   .tbase 
    switch         #7719 1 26
    opnd           #7720 
#7719:
    swlabel        #7721 
    swlabel        #7721 
    swlabel        #7721 
    swlabel        #7721 
    swlabel        #7721 
    swlabel        #7731 
    swlabel        #7722 
    swlabel        #7720 
    swlabel        #7720 
    swlabel        #7720 
    swlabel        #7720 
    swlabel        #7720 
    swlabel        #7726 
    swlabel        #7726 
    swlabel        #7726 
    swlabel        #7726 
    swlabel        #7726 
    swlabel        #7726 
    swlabel        #7726 
    swlabel        #7726 
    swlabel        #7722 
    swlabel        #7720 
    swlabel        #7720 
    swlabel        #7720 
    swlabel        #7720 
    swlabel        #7732 
    endsw          
#7721:
    loadref  u64   mm_tables.softconvtable 
    load     i64   .sbase 
    addptrx  u8:10 10 -10
    load     i64   .tbase 
    iloadx   i16   2 -2
    store    i64   .opc 
    jump           #7718 
#7722:
    loadimm  i64   167 
    store    i64   .opc 
;checkhard::
#7723:
    load     i64   .hard 
    jumpt    i64   #7725 
    loadimm  i64   169 
    store    i64   .opc 
#7725:
#7724:
    jump           #7718 
#7726:
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .sbase 
    iloadx   u8    1 0
    jumpf    i64   #7728 
    load     i64   .hard 
    jumpt    i64   #7730 
    loadimm  i64   170 
    store    i64   .opc 
    jump           #7729 
#7730:
    loadimm  i64   133 
    store    i64   .opc 
#7729:
#7728:
#7727:
    jump           #7718 
#7731:
    loadimm  i64   103 
    store    i64   .opc 
    jump           #7718 
#7732:
    loadimm  i64   167 
    store    i64   .opc 
    jump           #7718 
#7720:
#7718:
    jump           #7714 
#7733:
    load     i64   .tbase 
    loadimm  i64   3 
    jumpeq   i64   #7736 1
    loadimm  i64   2 
    jumpne   i64   #7735 
#7736:
    loadimm  i64   167 
    store    i64   .opc 
#7735:
#7734:
    jump           #7714 
#7737:
    load     i64   .tbase 
    loadimm  i64   3 
    jumpeq   i64   #7739 1
    loadimm  i64   2 
    jumpeq   i64   #7739 1
    loadimm  i64   7 
    jumpeq   i64   #7740 1
    loadimm  i64   21 
    jumpeq   i64   #7741 1
    loadimm  i64   6 
    jumpeq   i64   #7742 
    jump           #7743 
#7739:
    loadimm  i64   167 
    store    i64   .opc 
    jump           #7723 
    unload   u64   
    jump           #7738 
#7740:
    load     i64   .starg 
    loadimm  i64   0 
    jumpeq   i64   #7746 
    load     i64   .ttarg 
    loadimm  i64   0 
    jumpne   i64   #7745 
#7746:
    loadimm  i64   167 
    store    i64   .opc 
    jump           #7744 
#7745:
;checkref::
#7747:
    loadimm  i64   167 
    store    i64   .opc 
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7749 
    jump           #7723 
    unload   u64   
#7749:
#7748:
#7744:
    jump           #7738 
#7741:
    jump           #7747 
    unload   u64   
    jump           #7738 
#7742:
    loadimm  i64   103 
    store    i64   .opc 
    jump           #7738 
#7743:
#7738:
    jump           #7714 
#7750:
    load     i64   .tbase 
    loadimm  i64   3 
    jumpeq   i64   #7752 1
    loadimm  i64   2 
    jumpeq   i64   #7752 1
    loadimm  i64   7 
    jumpeq   i64   #7753 1
    loadimm  i64   6 
    jumpeq   i64   #7754 1
    loadimm  i64   11 
    jumpeq   i64   #7755 
    jump           #7756 
#7752:
    loadimm  i64   167 
    store    i64   .opc 
    jump           #7723 
    unload   u64   
    jump           #7751 
#7753:
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7759 
    load     i64   .hard 
    jumpf    i64   #7758 
#7759:
    loadimm  i64   167 
    store    i64   .opc 
    jump           #7757 
#7758:
    loadimm  i64   169 
    store    i64   .opc 
#7757:
    jump           #7751 
#7754:
    loadimm  i64   103 
    store    i64   .opc 
    jump           #7751 
#7755:
    loadimm  i64   171 
    store    i64   .opc 
    jump           #7751 
#7756:
#7751:
    jump           #7714 
#7760:
    load     i64   .tbase 
    loadimm  i64   10 
    jumpeq   i64   #7762 1
    loadimm  i64   11 
    jumpeq   i64   #7763 1
    loadimm  i64   21 
    jumpeq   i64   #7764 
    jump           #7765 
#7762:
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpf    i64   #7767 
    loadimm  i64   167 
    store    i64   .opc 
#7767:
#7766:
    jump           #7761 
#7763:
    setcall        2
    load     i64   .ttarg 
    setarg   i64   2
    load     i64   .starg 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpf    i64   #7769 
    loadimm  i64   172 
    store    i64   .opc 
#7769:
#7768:
    jump           #7761 
#7764:
    load     i64   .starg 
    loadimm  i64   13 
    jumpeq   i64   #7772 1
    loadimm  i64   18 
    jumpne   i64   #7771 
#7772:
    loadimm  i64   173 
    store    i64   .opc 
#7771:
#7770:
    jump           #7761 
#7765:
#7761:
    jump           #7714 
#7773:
    load     i64   .tbase 
    loadimm  i64   11 
    jumpeq   i64   #7775 1
    loadimm  i64   7 
    jumpeq   i64   #7776 
    jump           #7777 
#7775:
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpf    i64   #7779 
    loadimm  i64   167 
    store    i64   .opc 
#7779:
#7778:
    jump           #7774 
#7776:
    load     i64   .ttarg 
    loadimm  i64   0 
    jumpeq   i64   #7782 
    setcall        2
    load     i64   .ttarg 
    setarg   i64   2
    load     i64   .starg 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpf    i64   #7781 
#7782:
    loadimm  i64   140 
    store    i64   .opc 
#7781:
#7780:
    jump           #7774 
#7777:
#7774:
    jump           #7714 
#7783:
    load     i64   .tbase 
    loadimm  i64   5 
    jumpgt   i64   #7785 
    loadimm  i64   167 
    store    i64   .opc 
#7785:
#7784:
    jump           #7714 
#7716:
    loadimm  i64   168 
    setret   i64   
    jump           #7707 
#7714:
    load     i64   .opc 
    setret   i64   
    jump           #7707 
;------------------------
#7707:
    return         
end

proc mm_type.applyconversion
    param    u64   .p 
    param    i64   .s 
    param    i64   .t 
    param    i64   .opc 
    local    u64   .q 
;------------------------
    load     i64   .opc 
    loadimm  i64   174 
    jumpeq   i64   #7788 1
    loadimm  i64   168 
    jumpeq   i64   #7789 1
    loadimm  i64   169 
    jumpeq   i64   #7790 1
    loadimm  i64   167 
    jumpeq   i64   #7791 1
    loadimm  i64   170 
    jumpeq   i64   #7792 1
    loadimm  i64   172 
    jumpeq   i64   #7793 1
    loadimm  i64   171 
    jumpeq   i64   #7794 1
    loadimm  i64   173 
    jumpeq   i64   #7795 
    jump           #7796 
#7788:
    jump           #7786 
    jump           #7787 
#7789:
    setcall        3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .t 
    setarg   i64   1
    callf    u64   mm_lib.strmode2 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "Can't do conversion: # => #"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
    jump           #7787 
#7790:
    setcall        3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .t 
    setarg   i64   1
    callf    u64   mm_lib.strmode2 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "Need explicit cast: # => #"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
    jump           #7787 
#7791:
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7786 
    jump           #7787 
#7792:
    setcall        4
    load     i64   .opc 
    setarg   i64   4
    load     i64   .t 
    setarg   i64   3
    load     i64   .s 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.tevalconvert 4 0
    jumpf    i64   #7800 
    jump           #7786 
#7800:
#7799:
    setcall        2
    loadimm  i64   52 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7786 
    jump           #7787 
#7793:
    setcall        2
    loadimm  i64   44 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7786 
    jump           #7787 
#7794:
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tstringslice 2 0
    jump           #7786 
    jump           #7787 
#7795:
    setcall        2
    loadimm  i64   50 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    loadimm  i64   21 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7786 
    jump           #7787 
#7796:
#7787:
    setcall        4
    load     i64   .opc 
    setarg   i64   4
    load     i64   .t 
    setarg   i64   3
    load     i64   .s 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callf    i64   mm_type.tevalconvert 4 0
    jumpf    i64   #7802 
    jump           #7786 
#7802:
#7801:
;dorest::
#7803:
    setcall        2
    loadimm  i64   51 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_lib.insertunit 2 0
    load     i64   .opc 
    load     u64   .p 
    loadimm  i64   61 
    istorex  u8    1 0
    load     i64   .s 
    load     u64   .p 
    loadimm  i64   52 
    istorex  i32   1 0
    loadimm  i64   1 
    load     u64   .p 
    loadimm  i64   60 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttisshort 
    load     i64   .t 
    iloadx   u8    1 0
    jumpf    i64   #7805 
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   52 
    istorex  i32   1 0
    setcall        1
    load     i64   .t 
    setarg   i64   1
    callf    i64   mm_lib.gettypebase 1 0
    store    i64   .t 
#7805:
#7804:
    load     i64   .t 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7786:
    return         
end

proc mm_type.checkmodes
    param    i64   .s 
    param    i64   .t 
;------------------------
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7808 
    setcall        3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .t 
    setarg   i64   1
    callf    u64   mm_lib.strmode2 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .s 
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "Type-compare error: # <-> #"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
#7808:
#7807:
;------------------------
#7806:
    return         
end

proc mm_type.comparemodes
    rettype  i64   
    param    i64   .s 
    param    i64   .t 
    local    i64   .sbase 
    local    i64   .tbase 
    local    i64   .starg 
    local    i64   .ttarg 
    local    u64   .d 
    local    u64   .e 
;------------------------
    load     i64   .s 
    load     i64   .t 
    jumpne   i64   #7812 
    loadimm  i64   1 
    setret   i64   
    jump           #7810 
#7812:
#7811:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .s 
    iloadx   i32   4 0
    store    i64   .sbase 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    store    i64   .tbase 
    loadref  u64   mm_decls.tttarget 
    load     i64   .s 
    iloadx   i32   4 0
    store    i64   .starg 
    loadref  u64   mm_decls.tttarget 
    load     i64   .t 
    iloadx   i32   4 0
    store    i64   .ttarg 
    load     i64   .sbase 
    load     i64   .tbase 
    jumpne   i64   #7814 
    load     i64   .sbase 
    loadimm  i64   7 
    jumpeq   i64   #7816 1
    loadimm  i64   10 
    jumpeq   i64   #7817 1
    loadimm  i64   11 
    jumpeq   i64   #7818 1
    loadimm  i64   24 
    jumpeq   i64   #7819 
    jump           #7820 
#7816:
    load     i64   .starg 
    loadimm  i64   0 
    jumpeq   i64   #7823 
    load     i64   .ttarg 
    loadimm  i64   0 
    jumpne   i64   #7822 
#7823:
    loadimm  i64   1 
    setret   i64   
    jump           #7810 
#7822:
#7821:
    setcall        2
    load     i64   .ttarg 
    setarg   i64   2
    load     i64   .starg 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    setret   i64   
    jump           #7810 
    jump           #7815 
#7817:
    setcall        2
    load     i64   .ttarg 
    setarg   i64   2
    load     i64   .starg 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7825 
    loadimm  i64   0 
    setret   i64   
    jump           #7810 
#7825:
#7824:
    loadref  u64   mm_decls.ttlength 
    load     i64   .s 
    iloadx   i32   4 0
    loadref  u64   mm_decls.ttlength 
    load     i64   .t 
    iloadx   i32   4 0
    jumpeq   i64   #7828 
    loadref  u64   mm_decls.ttlength 
    load     i64   .s 
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpeq   i64   #7828 
    loadref  u64   mm_decls.ttlength 
    load     i64   .t 
    iloadx   i32   4 0
    loadimm  i64   0 
    jumpne   i64   #7827 
#7828:
    loadimm  i64   1 
    setret   i64   
    jump           #7810 
#7827:
#7826:
    jump           #7815 
#7818:
    setcall        2
    load     i64   .ttarg 
    setarg   i64   2
    load     i64   .starg 
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    setret   i64   
    jump           #7810 
    jump           #7815 
#7819:
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .s 
    iloadx   u64   8 0
    store    u64   .d 
    loadref  u64   mm_decls.ttnamedef 
    load     i64   .t 
    iloadx   u64   8 0
    store    u64   .e 
    load     u64   .d 
    jumpf    u64   #7830 
    load     u64   .e 
    jumpf    u64   #7830 
    setcall        2
    load     u64   .e 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .d 
    loadimm  i64   64 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7832 
    loadimm  i64   0 
    setret   i64   
    jump           #7810 
#7832:
#7831:
    load     u64   .d 
    loadimm  i64   104 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #7834 
    load     u64   .e 
    loadimm  i64   104 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #7834 
    loadimm  i64   1 
    setret   i64   
    jump           #7810 
#7834:
#7833:
#7830:
#7829:
    jump           #7815 
#7820:
#7815:
    jump           #7813 
#7814:
    load     i64   .sbase 
    loadimm  i64   13 
    jumpne   i64   #7837 
    load     i64   .tbase 
    loadimm  i64   18 
    jumpeq   i64   #7836 
#7837:
    load     i64   .sbase 
    loadimm  i64   18 
    jumpne   i64   #7835 
    load     i64   .tbase 
    loadimm  i64   13 
    jumpne   i64   #7835 
#7836:
    loadimm  i64   1 
    setret   i64   
    jump           #7810 
    jump           #7813 
#7835:
#7813:
    loadimm  i64   0 
    setret   i64   
    jump           #7810 
;------------------------
#7810:
    return         
end

proc mm_type.tevalconvert
    rettype  i64   
    param    u64   .p 
    param    i64   .s 
    param    i64   .t 
    param    i64   .opc 
    local    r64   .x 
    local    r64   .z 
    local    i64   .a 
    local    i64   .c 
    local    i64   .sbase 
    local    i64   .tbase 
;------------------------
    load     u64   .p 
    iload    u8    
    loadimm  i64   1 
    jumpeq   i64   #7840 
    loadimm  i64   0 
    setret   i64   
    jump           #7838 
#7840:
#7839:
    load     u64   .p 
    loadimm  i64   16 
    iloadx   i64   1 0
    store    i64   .a 
    load     u64   .p 
    loadimm  i64   16 
    iloadx   r64   1 0
    store    r64   .x 
    load     i64   .s 
    loadimm  i64   16 
    shl      i64   
    load     i64   .t 
    bitor    i64   
    loadimm  i64   196613 
    jumpeq   i64   #7842 1
    loadimm  i64   196612 
    jumpeq   i64   #7842 1
    loadimm  i64   327683 
    jumpeq   i64   #7843 1
    loadimm  i64   327684 
    jumpeq   i64   #7844 1
    loadimm  i64   196626 
    jumpeq   i64   #7845 1
    loadimm  i64   196624 
    jumpeq   i64   #7846 
    jump           #7847 
#7842:
    load     i64   .a 
    float    r64 i64 
    store    r64   .z 
    jump           #7841 
#7843:
    load     r64   .x 
    fix      i64 r64 
    store    i64   .c 
    jump           #7841 
#7844:
    load     r64   .x 
    fnarrow  r32 r64 
    fwiden   r64 r32 
    store    r64   .z 
    jump           #7841 
#7845:
    load     i64   .a 
    truncate i64 u8 
    store    i64   .c 
    jump           #7841 
#7846:
    load     i64   .a 
    truncate i64 i16 
    store    i64   .c 
    jump           #7841 
#7847:
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .s 
    iloadx   u8    1 0
    jumpf    i64   #7849 
    loadref  u64   mm_decls.ttisinteger 
    load     i64   .t 
    iloadx   u8    1 0
    jumpf    i64   #7849 
    loadref  u64   mm_decls.ttsize 
    load     i64   .s 
    iloadx   u32   4 0
    loadref  u64   mm_decls.ttsize 
    load     i64   .t 
    iloadx   u32   4 0
    jumpne   i64   #7849 
    load     i64   .a 
    store    i64   .c 
    jump           #7848 
#7849:
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .s 
    iloadx   i32   4 0
    store    i64   .sbase 
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .t 
    iloadx   i32   4 0
    store    i64   .tbase 
    load     i64   .sbase 
    load     i64   .tbase 
    jumpne   i64   #7851 
    loadimm  i64   1 
    setret   i64   
    jump           #7838 
#7851:
#7850:
    loadimm  i64   0 
    setret   i64   
    jump           #7838 
#7848:
#7841:
    loadref  u64   mm_decls.ttisreal 
    load     i64   .t 
    iloadx   u8    1 0
    jumpf    i64   #7853 
    setcall        3
    load     i64   .t 
    setarg   i64   3
    load     r64   .z 
    typepun  i64 r64 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.makenewconst 3 0
    jump           #7852 
#7853:
    setcall        3
    load     i64   .t 
    setarg   i64   3
    load     i64   .c 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.makenewconst 3 0
#7852:
    loadimm  i64   1 
    setret   i64   
    jump           #7838 
;------------------------
#7838:
    return         
end

proc mm_type.tx_assign
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    param    i64   .t 
    local    i64   .m 
    local    i64   .mm 
    local    i64   .needres 
    local    u64   .d 
;------------------------
    load     i64   .t 
    loadimm  i64   0 
    ne       i64   
    store    i64   .needres 
    load     u64   .a 
    iload    u8    
    loadimm  i64   16 
    jumpeq   i64   #7856 1
    loadimm  i64   46 
    jumpeq   i64   #7857 1
    loadimm  i64   47 
    jumpeq   i64   #7857 
    jump           #7858 
#7856:
    load     u64   .b 
    iload    u8    
    loadimm  i64   16 
    jumpne   i64   #7860 
    load     i64   .needres 
    jumpf    i64   #7862 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Mult assign has no result"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7862:
#7861:
    setcall        3
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_assignmultmult 3 0
    jump           #7859 
#7860:
    setcall        4
    load     i64   .t 
    setarg   i64   4
    load     u64   .b 
    setarg   u64   3
    load     u64   .a 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tx_assignmultscalar 4 0
#7859:
    jump           #7854 
    jump           #7855 
#7857:
    setcall        4
    loadimm  i64   1 
    setarg   i64   4
    load     u64   .a 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   3
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tx_dotindex 4 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadimm  i64   3 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7854 
    jump           #7855 
#7858:
#7855:
    load     u64   .a 
    iload    u8    
    loadimm  i64   3 
    jumpne   i64   #7865 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    loadimm  i64   84 
    iloadx   u16   1 0
    loadimm  i64   3 
    loadbit        
    jumpf    u64   #7865 
    load     u64   .p 
    loadimm  i64   58 
    iloadx   u8    1 0
    jumpf    i64   #7865 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #7864 
#7865:
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
#7864:
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .m 
    load     i64   .needres 
    load     u64   .a 
    loadimm  i64   60 
    istorex  u8    1 0
    loadref  u64   mm_decls.ttbasetype 
    load     i64   .m 
    iloadx   i32   4 0
    loadimm  i64   11 
    jumpne   i64   #7867 
    load     u64   .b 
    iload    u8    
    loadimm  i64   18 
    jumpeq   i64   #7868 1
    loadimm  i64   16 
    jumpne   i64   #7867 
#7868:
    setcall        3
    load     i64   .m 
    setarg   i64   3
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    setarg   u64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tx_makeslice 3 0
    load     i64   .m 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    jump           #7866 
#7867:
    loadref  u64   mm_decls.ttisshort 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #7869 
    load     i64   .needres 
    jumpf    i64   #7869 
    load     i64   .m 
    load     u64   .p 
    loadimm  i64   63 
    istorex  u8    1 0
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    i64   mm_lib.gettypebase 1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #7866 
#7869:
    load     u64   .b 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   67 
    jumpeq   i64   #7872 1
    loadimm  i64   68 
    jumpne   i64   #7871 
#7872:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #7870 
#7871:
    load     u64   .b 
    iload    u8    
    loadimm  i64   118 
    jumpne   i64   #7873 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #7870 
#7873:
    load     i64   .m 
    store    i64   .mm 
    loadref  u64   mm_decls.ttisshort 
    load     i64   .m 
    iloadx   u8    1 0
    jumpf    i64   #7875 
    setcall        1
    load     i64   .m 
    setarg   i64   1
    callf    i64   mm_lib.gettypebase 1 0
    store    i64   .mm 
#7875:
#7874:
    load     u64   .b 
    iload    u8    
    loadimm  i64   53 
    jumpeq   i64   #7877 1
    loadimm  i64   16 
    jumpeq   i64   #7878 
    jump           #7879 
#7877:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .mm 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #7876 
#7878:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .m 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #7876 
#7879:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
#7876:
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   28 
    jumpne   i64   #7881 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadref  u64   mm_decls.ttmult 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u64   8 0
    loadimm  i64   1 
    iloadx   i32   4 -4
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    loadimm  i64   26 
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #7880 
#7881:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .mm 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    load     i64   .mm 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
#7880:
#7870:
#7866:
;------------------------
#7854:
    return         
end

proc mm_type.tx_assignmultmult
    param    u64   .pp 
    param    u64   .a 
    param    u64   .b 
    local    u64   .p 
    local    u64   .q 
    local    u64   .lhs 
    local    u64   .rhs 
;------------------------
    loadimm  i64   25 
    load     u64   .pp 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .a 
    loadimm  i64   40 
    iloadx   u32   1 0
    load     u64   .b 
    loadimm  i64   40 
    iloadx   u32   1 0
    jumpeq   i64   #7884 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Mult assign: count mismatch"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7884:
#7883:
    load     u64   .a 
    loadimm  i64   40 
    iloadx   u32   1 0
    loadimm  i64   0 
    jumpne   i64   #7887 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "Invalid assignment"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7887:
#7886:
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .rhs 
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .lhs 
    load     u64   .lhs 
    store    u64   .p 
    jump           #7892 
#7889:
    setcall        2
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
#7890:
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .p 
#7892:
    load     u64   .p 
    jumpt    u64   #7889 
#7891:
    load     u64   .lhs 
    store    u64   .p 
    load     u64   .rhs 
    store    u64   .q 
    jump           #7896 
#7893:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .q 
    setarg   u64   1
    callp          mm_type.tpass 3 0
#7894:
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .p 
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#7896:
    load     u64   .q 
    jumpt    u64   #7893 
#7895:
;------------------------
#7882:
    return         
end

proc mm_type.tx_assignmultscalar
    param    u64   .pp 
    param    u64   .a 
    param    u64   .b 
    param    i64   .t 
    local    u64   .p 
    local    u64   .q 
    local    u64   .alist 
    local    i64   .nretmodes 
    local    i64   .i 
    local    i64   .alength 
    local    u64   .pmult 
;------------------------
    load     u64   .a 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .alist 
    load     u64   .a 
    loadimm  i64   40 
    iloadx   u32   1 0
    store    i64   .alength 
    loadimm  i64   0 
    store    i64   .nretmodes 
    loadimm  i64   26 
    load     u64   .pp 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    loadref  u64   mm_decls.ttbasetype 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    loadimm  i64   28 
    jumpeq   i64   #7899 1
    loadimm  i64   11 
    jumpeq   i64   #7900 1
    loadimm  i64   9 
    jumpeq   i64   #7901 1
    loadimm  i64   8 
    jumpeq   i64   #7902 
    jump           #7903 
#7899:
    loadref  u64   mm_decls.ttlength 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    store    i64   .nretmodes 
    load     i64   .alength 
    load     i64   .nretmodes 
    jumple   i64   #7905 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "mult ass/mult returns don't agree in number"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7905:
#7904:
    load     i64   .nretmodes 
    loadimm  i64   1 
    jumpgt   i64   #7908 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "mult ass rhs needs fn yielding 2+ values"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7908:
#7907:
    load     u64   .alist 
    store    u64   .p 
    loadref  u64   mm_decls.ttmult 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u64   8 0
    store    u64   .pmult 
    loadimm  i64   1 
    store    i64   .i 
    jump           #7913 
#7910:
    setcall        2
    load     u64   .pmult 
    loadref  u64   .i 
    loadincr i64   1
    iloadx   i32   4 -4
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
#7911:
    load     u64   .p 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .p 
#7913:
    load     u64   .p 
    jumpt    u64   #7910 
#7912:
    jump           #7898 
#7900:
    load     i64   .alength 
    loadimm  i64   2 
    jumpeq   i64   #7915 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "(a,b):=slice"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7915:
#7914:
    setcall        2
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadref  u64   mm_decls.tttarget 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   i32   4 0
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   mm_lib.createrefmode 3 0
    setarg   i64   2
    load     u64   .alist 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .alist 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    jump           #7898 
#7901:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "MULT:=RANGE"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #7898 
#7902:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "MULT:=RECORD"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #7898 
#7903:
    load     u64   .b 
    iload    u8    
    loadimm  i64   32 
    jumpne   i64   #7920 
    load     u64   .b 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   69 
    jumpne   i64   #7920 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "MULT:=DIVREM"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    load     i64   .alength 
    loadimm  i64   2 
    jumpeq   i64   #7923 
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "(a,b):=divrem"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7923:
#7922:
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .alist 
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    setcall        2
    loadimm  i64   3 
    setarg   i64   2
    load     u64   .alist 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpasslv 2 0
    loadimm  i64   27 
    load     u64   .pp 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #7919 
#7920:
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "Can't expand to mult values:"
    setarg   u64   1
    callp          mm_support.txerror_s 3 0
#7919:
#7898:
    load     i64   .t 
    load     u64   .pp 
    loadimm  i64   48 
    istorex  i32   1 0
;------------------------
#7897:
    return         
end

proc mm_type.tpasslv
    param    u64   .p 
    param    i64   .t 
;------------------------
    setcall        3
    loadimm  i64   1 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    load     i64   .t 
    loadimm  i64   23 
    jumpeq   i64   #7928 1
    loadimm  i64   0 
    jumpeq   i64   #7928 
    setcall        2
    load     i64   .t 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    i64   mm_type.comparemodes 2 0
    jumpt    i64   #7930 
    setcall        3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     i64   .t 
    setarg   i64   1
    callf    u64   mm_lib.strmode2 2 0
    setarg   u64   3
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .p 
    loadimm  i64   48 
    iloadx   i32   1 0
    setarg   i64   1
    callf    u64   mm_lib.strmode 2 0
    setarg   u64   2
    loadimm  u64   "PassLV type mismatch: #:=#"
    setarg   u64   1
    callp          mm_support.txerror_ss 3 0
#7930:
#7929:
#7928:
#7927:
;------------------------
#7926:
    return         
end

proc mm_type.dobinnumx
    rettype  i64   
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    i64   .amode 
    local    i64   .bmode 
    local    i64   .cmode 
;------------------------
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .bmode 
    load     i64   .amode 
    loadimm  i64   1 
    jumplt   i64   #7934 1
    loadimm  i64   5 
    jumpgt   i64   #7934 
    load     i64   .bmode 
    loadimm  i64   1 
    jumplt   i64   #7934 1
    loadimm  i64   5 
    jumpgt   i64   #7934 
    load     i64   .amode 
    load     i64   .bmode 
    max      i64   
    double         
    store    i64   .cmode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .cmode 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .cmode 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   1 
    setret   i64   
    jump           #7932 
#7934:
#7933:
    loadimm  i64   0 
    setret   i64   
    jump           #7932 
;------------------------
#7932:
    return         
end

proc mm_type.dobinnumf
    rettype  i64   
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    i64   .amode 
    local    i64   .bmode 
    local    i64   .cmode 
;------------------------
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .bmode 
    load     i64   .amode 
    loadimm  i64   5 
    jumpeq   i64   #7938 1
    loadimm  i64   4 
    jumpne   i64   #7937 
#7938:
    load     i64   .bmode 
    loadimm  i64   5 
    jumpeq   i64   #7939 1
    loadimm  i64   4 
    jumpne   i64   #7937 
#7939:
    load     i64   .amode 
    load     i64   .bmode 
    max      i64   
    double         
    store    i64   .cmode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .cmode 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .cmode 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   1 
    setret   i64   
    jump           #7935 
#7937:
#7936:
    loadimm  i64   0 
    setret   i64   
    jump           #7935 
;------------------------
#7935:
    return         
end

proc mm_type.dobinnumi
    rettype  i64   
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    i64   .amode 
    local    i64   .bmode 
    local    i64   .cmode 
;------------------------
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .amode 
    load     u64   .b 
    loadimm  i64   48 
    iloadx   i32   1 0
    store    i64   .bmode 
    load     i64   .amode 
    loadimm  i64   3 
    jumpeq   i64   #7943 1
    loadimm  i64   2 
    jumpeq   i64   #7943 1
    loadimm  i64   1 
    jumpne   i64   #7942 
#7943:
    load     i64   .bmode 
    loadimm  i64   3 
    jumpeq   i64   #7944 1
    loadimm  i64   2 
    jumpeq   i64   #7944 1
    loadimm  i64   1 
    jumpne   i64   #7942 
#7944:
    load     i64   .amode 
    load     i64   .bmode 
    max      i64   
    double         
    store    i64   .cmode 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .cmode 
    setarg   i64   2
    load     u64   .a 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .cmode 
    setarg   i64   2
    load     u64   .b 
    setarg   u64   1
    callp          mm_type.coerceunit 3 0
    loadimm  i64   1 
    setret   i64   
    jump           #7940 
#7942:
#7941:
    loadimm  i64   0 
    setret   i64   
    jump           #7940 
;------------------------
#7940:
    return         
end

proc mm_type.doin
    rettype  i64   
    param    u64   .p 
    param    u64   .a 
    param    u64   .b 
    local    i64   .simpleset 
    local    u64   .q 
;------------------------
    loadimm  i64   1 
    store    i64   .simpleset 
    load     u64   .b 
    iload    u8    
    loadimm  i64   18 
    jumpne   i64   #7947 
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    store    u64   .q 
    jump           #7951 
#7948:
    loadref  u64   mm_decls.ttisinteger 
    load     u64   .q 
    loadimm  i64   48 
    iloadx   i32   1 0
    iloadx   u8    1 0
    jumpt    i64   #7953 
    loadimm  i64   0 
    store    i64   .simpleset 
    jump           #7950 
#7953:
#7952:
#7949:
    load     u64   .q 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .q 
#7951:
    load     u64   .q 
    jumpt    u64   #7948 
#7950:
#7947:
#7946:
    load     u64   .a 
    loadimm  i64   48 
    iloadx   i32   1 0
    loadimm  i64   1 
    jumplt   i64   #7955 1
    loadimm  i64   5 
    jumpgt   i64   #7955 
    load     u64   .b 
    iload    u8    
    loadimm  i64   17 
    jumpeq   i64   #7956 1
    loadimm  i64   18 
    jumpne   i64   #7955 
#7956:
    load     i64   .simpleset 
    jumpf    i64   #7955 
    startmx        
    load     u64   .b 
    iload    u8    
    loadimm  i64   17 
    jumpne   i64   #7958 
    loadimm  i64   40 
    resetmx        
    jump           #7957 
#7958:
    loadimm  i64   41 
    endmx          
#7957:
    load     u64   .p 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #7954 
#7955:
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    loadimm  u64   "doin"
    setarg   u64   1
    callp          mm_support.txerror 2 0
#7954:
    loadimm  i64   6 
    load     u64   .p 
    loadimm  i64   48 
    istorex  i32   1 0
    load     u64   .p 
    loadimm  i64   61 
    iloadx   u8    1 0
    loadimm  i64   152 
    jumpne   i64   #7961 
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          mm_type.addnotl 1 0
#7961:
#7960:
    loadimm  i64   1 
    setret   i64   
    jump           #7945 
;------------------------
#7945:
    return         
end

proc mm_type.do_printlist
    param    u64   .b 
    local    u64   .c 
;------------------------
    jump           #7964 
#7963:
    load     u64   .b 
    iload    u8    
    loadimm  i64   85 
    jumpne   i64   #7967 
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    loadimm  i64   16 
    iloadx   u64   1 0
    double         
    store    u64   .c 
    setarg   u64   1
    callp          mm_type.tpass 3 0
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   21 
    setarg   i64   2
    load     u64   .b 
    loadimm  i64   24 
    iloadx   u64   1 0
    setarg   u64   1
    callp          mm_type.tpass 3 0
    jump           #7966 
#7967:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    loadimm  i64   23 
    setarg   i64   2
    load     u64   .b 
    double         
    store    u64   .c 
    setarg   u64   1
    callp          mm_type.tpass 3 0
#7966:
    setcall        1
    load     u64   .c 
    setarg   u64   1
    callp          mm_type.fixchararray 1 0
    load     u64   .b 
    loadimm  i64   8 
    iloadx   u64   1 0
    store    u64   .b 
#7964:
    load     u64   .b 
    jumpt    u64   #7963 
#7965:
;------------------------
#7962:
    return         
end

proc mm_topcl.codegen
    param    i64   .n 
;------------------------
    load     i64   .n 
    loadimm  i64   1 
    jumplt   i64   #7970 
    setcall        0
    callf    i64   mm_genpcl.codegen_pcl 0 0
    unload   i64   
    load     u8    mm_decls.fshowpcl 
    jumpf    i64   #7972 
    setcall        1
    load     u64   mm_decls.pclfilename 
    setarg   u64   1
    callp          mm_topcl.writepclfile 1 0
#7972:
#7971:
#7970:
#7969:
;------------------------
#7968:
    return         
end

proc mm_topcl.runlibfile
    rettype  i64   
    param    u64   .filename 
;------------------------
    loadimm  i64   0 
    setret   i64   
    jump           #7973 
;------------------------
#7973:
    return         
end

proc mm_topcl.writeexefile
    rettype  i64   
    param    u64   .filename 
    param    i64   .gendll 
;------------------------
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "No EXE backend"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
    loadimm  i64   0 
    setret   i64   
    jump           #7974 
;------------------------
#7974:
    return         
end

proc mm_topcl.writelibfile
    rettype  i64   
    param    u64   .filename 
;------------------------
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "No LIB (ML/MX/MC) backend"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
    loadimm  i64   0 
    setret   i64   
    jump           #7977 
;------------------------
#7977:
    return         
end

proc mm_topcl.writeasmfile
    rettype  i64   
    param    u64   .filename 
;------------------------
    setcall        1
    loadimm  i64   2 
    setarg   i64   1
    callp          mm_topcl.codegen 1 0
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "No ASM backend"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
    loadimm  i64   0 
    setret   i64   
    jump           #7980 
;------------------------
#7980:
    return         
end

proc mm_topcl.writepclfile
    param    u64   .filename 
    local    u64   .pclstr 
;------------------------
    setcall        0
    callf    u64   mm_diags.getpclstr 0 0
    store    u64   .pclstr 
    setcall        2
    load     u64   .pclstr 
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callp          mm_lib.writegsfile 2 0
    setcall        1
    load     u64   .pclstr 
    setarg   u64   1
    callp          mlib.gs_free 1 0
;------------------------
#7983:
    return         
end

proc mm_topcl.runpclfile
    param    u64   .filename 
    local    u8:300 .str 
    local    i64   .status 
;------------------------
    loadref  u64   .str 
    callp          msys.m$print_startstr 1 0
    loadimm  u64   "pci"
    callp          msys.m$print_str_nf 1 0
    load     u64   .filename 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    setcall        3
    loadimm  u64   0 
    setarg   u64   3
    loadimm  i64   0 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   mwindows.os_execwait 3 0
    store    i64   .status 
    load     i64   .status 
    loadimm  i64   0 
    jumpeq   i64   #7987 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "PCI failed"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#7987:
#7986:
;------------------------
#7984:
    return         
end

proc msys.start
    local    i32   .nargs 
    local    i64   .nargs64 
    local    u64   .args 
    local    i64   .res 
    local    i64   .j 
    local    i64   .i 
    callp          mlib.start 0 0
    callp          mclib.start 0 0
    callp          mwindows.start 0 0
    callp          mwindllc.start 0 0
;------------------------
    setcall        5
    loadref  u64   msys.start.startupinfo 
    setarg   u64   5
    loadimm  i64   0 
    setarg   i64   4
    loadref  u64   msys.envstrings 
    setarg   u64   3
    loadref  u64   .args 
    setarg   u64   2
    loadref  u64   .nargs 
    setarg   u64   1
    callf    i32   __getmainargs 5 0
    widen    i32   
    store    i64   .res 
    load     i32   .nargs 
    store    i64   msys.nsysparams 
    load     i64   msys.nsysparams 
    loadimm  i64   128 
    jumple   i64   #7992 
    setcall        1
    loadimm  u64   "Too many params\n"
    setarg   u64   1
    callp          printf 1 0
    stop           50
#7992:
#7991:
    load     i32   .nargs 
    store    i64   .nargs64 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .nargs64 
    loadimm  i64   1 
    jumplt   i64   #7996 
#7994:
    load     u64   .args 
    load     i64   .i 
    iloadx   u64   8 -8
    loadref  u64   msys.sysparams 
    load     i64   .i 
    istorex  u64   8 -8
#7995:
    forup          #7994 1
    opnd           .i 
    opnd           .nargs64 
#7996:
    load     i64   msys.nsysparams 
    load     i64   $cmdskip 
    loadimm  i64   1 
    add      i64   
    sub      i64   
    store    i64   msys.ncmdparams 
    loadref  u64   msys.sysparams 
    load     i64   $cmdskip 
    addptrx  u64   8 0
    store    u64   msys.cmdparams 
    loadimm  i64   1 
    store    i64   .j 
    loadimm  i64   0 
    store    i64   msys.nenvstrings 
    jump           #7998 
#7997:
    loadref  u64   msys.nenvstrings 
    incrto   i64   1
    loadref  u64   .j 
    incrto   i64   1
#7998:
    load     u64   msys.envstrings 
    load     i64   .j 
    iloadx   u64   8 -8
    jumpt    u64   #7997 
#7999:
;------------------------
#7990:
    return         
end

;
proc msys.pushio
;------------------------
    load     i64   msys.niostack 
    loadimm  i64   10 
    jumplt   i64   #8002 
    setcall        1
    loadimm  u64   "Too many io levels\n"
    setarg   u64   1
    callp          printf 1 0
    stop           53
#8002:
#8001:
    loadref  u64   msys.niostack 
    incrto   i64   1
    load     u64   msys.outchan 
    loadref  u64   msys.outchan_stack 
    load     i64   msys.niostack 
    istorex  u64   8 -8
    load     i64   msys.outdev 
    loadref  u64   msys.outdev_stack 
    load     i64   msys.niostack 
    istorex  i64   8 -8
    load     u64   msys.fmtstr 
    loadref  u64   msys.fmtstr_stack 
    load     i64   msys.niostack 
    istorex  u64   8 -8
    load     i64   msys.needgap 
    loadref  u64   msys.needgap_stack 
    load     i64   msys.niostack 
    istorex  u8    1 -1
    loadimm  i64   0 
    store    i64   msys.needgap 
    loadimm  u64   0 
    store    u64   msys.fmtstr 
    loadimm  u64   0 
    store    u64   msys.outchan 
;------------------------
#8000:
    return         
end

proc msys.m$print_startfile
    param    u64   .dev 
;------------------------
    setcall        0
    callp          msys.pushio 0 0
    load     u64   .dev 
    store    u64   msys.outchan 
    load     u64   .dev 
    jumpf    u64   #8006 
    loadimm  i64   2 
    store    i64   msys.outdev 
    jump           #8005 
#8006:
    loadimm  i64   1 
    store    i64   msys.outdev 
#8005:
    setcall        0
    callp          msys.resetprintbuffer 0 0
;------------------------
#8004:
    return         
end

proc msys.m$print_startstr
    param    u64   .s 
    local    u64   .p 
;------------------------
    setcall        0
    callp          msys.pushio 0 0
    load     u64   .s 
    loadref  u64   msys.ptr_stack 
    load     i64   msys.niostack 
    istorex  u64   8 -8
    loadref  u64   msys.ptr_stack 
    load     i64   msys.niostack 
    addptrx  u64   8 -8
    store    u64   .p 
    load     u64   .p 
    store    u64   msys.outchan 
    loadimm  i64   3 
    store    i64   msys.outdev 
;------------------------
#8007:
    return         
end

proc msys.m$print_startptr
    param    u64   .p 
;------------------------
    setcall        0
    callp          msys.pushio 0 0
    load     u64   .p 
    store    u64   msys.outchan 
    loadimm  i64   3 
    store    i64   msys.outdev 
;------------------------
#8008:
    return         
end

proc msys.m$print_startcon
;------------------------
    setcall        0
    callp          msys.pushio 0 0
    loadimm  i64   1 
    store    i64   msys.outdev 
    setcall        0
    callp          msys.resetprintbuffer 0 0
;------------------------
#8009:
    return         
end

proc msys.m$print_setfmt
    param    u64   .format 
;------------------------
    load     u64   .format 
    store    u64   msys.fmtstr 
;------------------------
#8010:
    return         
end

proc msys.m$print_end
;------------------------
    loadimm  i64   0 
    store    i64   msys.needgap 
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    load     i64   msys.niostack 
    loadimm  i64   1 
    jumpne   i64   #8013 
    load     i64   msys.outdev 
    loadimm  i64   1 
    jumpeq   i64   #8014 1
    loadimm  i64   2 
    jumpne   i64   #8013 
#8014:
#8013:
#8012:
    load     i64   msys.niostack 
    loadimm  i64   0 
    jumpne   i64   #8016 
    jump           #8011 
#8016:
#8015:
    loadref  u64   msys.outchan_stack 
    load     i64   msys.niostack 
    iloadx   u64   8 -8
    store    u64   msys.outchan 
    loadref  u64   msys.outdev_stack 
    load     i64   msys.niostack 
    iloadx   i64   8 -8
    store    i64   msys.outdev 
    loadref  u64   msys.fmtstr_stack 
    load     i64   msys.niostack 
    iloadx   u64   8 -8
    store    u64   msys.fmtstr 
    loadref  u64   msys.needgap_stack 
    load     i64   msys.niostack 
    iloadx   u8    1 -1
    store    i64   msys.needgap 
    loadref  u64   msys.niostack 
    decrto   i64   1
;------------------------
#8011:
    return         
end

proc msys.m$print_ptr
    param    u64   .a 
    param    u64   .fmtstyle 
    local    u8:20 .s 
;------------------------
    load     u64   .fmtstyle 
    loadimm  u64   0 
    jumpne   u64   #8019 
    loadimm  u64   "z8H"
    store    u64   .fmtstyle 
#8019:
#8018:
    setcall        2
    load     u64   .fmtstyle 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          msys.m$print_u64 2 0
;------------------------
#8017:
    return         
end

proc msys.m$print_ptr_nf
    param    u64   .a 
;------------------------
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          msys.m$print_ptr 2 0
;------------------------
#8021:
    return         
end

proc msys.m$print_i64
    param    i64   .a 
    param    u64   .fmtstyle 
    local    u8:40 .s 
    local    u8:16 .fmt 
    local    i64   .n 
;------------------------
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    load     u64   .fmtstyle 
    loadimm  u64   0 
    jumpne   u64   #8024 
    load     i64   .a 
    loadimm  i64   0 
    jumplt   i64   #8026 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  u64   10 
    setarg   u64   3
    loadref  u64   .s 
    setarg   u64   2
    load     i64   .a 
    setarg   u64   1
    callf    i64   msys.u64tostr 4 0
    store    i64   .n 
    jump           #8025 
#8026:
    loadimm  u64   45 
    loadref  u64   .s 
    loadimm  i64   1 
    istorex  u8    1 -1
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadimm  u64   10 
    setarg   u64   3
    loadref  u64   .s 
    loadimm  i64   2 
    addptrx  u8    1 -1
    setarg   u64   2
    load     i64   .a 
    neg      i64   
    setarg   u64   1
    callf    i64   msys.u64tostr 4 0
    loadimm  i64   1 
    add      i64   
    store    i64   .n 
#8025:
    setcall        2
    load     i64   .n 
    setarg   i64   2
    loadref  u64   .s 
    setarg   u64   1
    callp          msys.printstr_n 2 0
    jump           #8023 
#8024:
    setcall        3
    loadref  u64   .fmt 
    setarg   u64   3
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   .fmtstyle 
    setarg   u64   1
    callp          msys.strtofmt 3 0
    loadref  u64   .fmt 
    loadimm  i64   14 
    iloadx   u8    1 0
    loadimm  u64   86 
    jumpne   u64   #8028 
    load     i64   .a 
    store    i64   msys.fmtparam 
    loadimm  i64   0 
    store    i64   msys.needgap 
    jump           #8027 
#8028:
    setcall        2
    loadref  u64   .fmt 
    setarg   u64   2
    load     i64   .a 
    setarg   i64   1
    callp          msys.tostr_i64 2 0
#8027:
#8023:
    loadimm  i64   1 
    store    i64   msys.needgap 
;------------------------
#8022:
    return         
end

proc msys.m$print_i64_nf
    param    i64   .a 
;------------------------
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .a 
    setarg   i64   1
    callp          msys.m$print_i64 2 0
;------------------------
#8029:
    return         
end

proc msys.m$print_bool
    param    i64   .a 
    param    u64   .fmtstyle 
;------------------------
    load     i64   .a 
    jumpf    i64   #8032 
    setcall        2
    load     u64   .fmtstyle 
    setarg   u64   2
    loadimm  u64   "True"
    setarg   u64   1
    callp          msys.m$print_str 2 0
    jump           #8031 
#8032:
    setcall        2
    load     u64   .fmtstyle 
    setarg   u64   2
    loadimm  u64   "False"
    setarg   u64   1
    callp          msys.m$print_str 2 0
#8031:
;------------------------
#8030:
    return         
end

proc msys.m$print_u64
    param    u64   .a 
    param    u64   .fmtstyle 
    local    u8:40 .s 
    local    u8:16 .fmt 
;------------------------
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    load     u64   .fmtstyle 
    loadimm  u64   0 
    jumpne   u64   #8037 
    setcall        3
    load     u64   .a 
    setarg   u64   3
    loadimm  u64   "%llu"
    setarg   u64   2
    loadref  u64   .s 
    setarg   u64   1
    callp          sprintf 3 3
    setcall        1
    loadref  u64   .s 
    setarg   u64   1
    callp          msys.printstr 1 0
    jump           #8036 
#8037:
    setcall        3
    loadref  u64   .fmt 
    setarg   u64   3
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   .fmtstyle 
    setarg   u64   1
    callp          msys.strtofmt 3 0
    setcall        2
    loadref  u64   .fmt 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          msys.tostr_u64 2 0
#8036:
    loadimm  i64   1 
    store    i64   msys.needgap 
;------------------------
#8035:
    return         
end

proc msys.m$print_r64
    param    r64   .x 
    param    u64   .fmtstyle 
    local    u8:360 .s 
    local    u8:16 .fmt 
;------------------------
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    load     u64   .fmtstyle 
    loadimm  u64   0 
    jumpne   u64   #8041 
    setcall        3
    load     r64   .x 
    setarg   r64   3
    loadimm  u64   "%f"
    setarg   u64   2
    loadref  u64   .s 
    setarg   u64   1
    callp          sprintf 3 3
    setcall        1
    loadref  u64   .s 
    setarg   u64   1
    callp          msys.printstr 1 0
    jump           #8040 
#8041:
    setcall        3
    loadref  u64   .fmt 
    setarg   u64   3
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   .fmtstyle 
    setarg   u64   1
    callp          msys.strtofmt 3 0
    setcall        2
    loadref  u64   .fmt 
    setarg   u64   2
    load     r64   .x 
    setarg   r64   1
    callp          msys.tostr_r64 2 0
#8040:
    loadimm  i64   1 
    store    i64   msys.needgap 
;------------------------
#8039:
    return         
end

proc msys.m$print_r32
    param    r32   .x 
    param    u64   .fmtstyle 
;------------------------
    setcall        2
    load     u64   .fmtstyle 
    setarg   u64   2
    load     r32   .x 
    fwiden   r64 r32 
    setarg   r64   1
    callp          msys.m$print_r64 2 0
;------------------------
#8043:
    return         
end

proc msys.m$print_c8
    param    i64   .a 
    param    u64   .fmtstyle 
    local    u8:40 .s 
    local    u8:16 .fmt 
    local    i64   .n 
;------------------------
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    load     i64   .a 
    loadref  u64   .s 
    loadimm  i64   1 
    istorex  u8    1 -1
    loadimm  u64   0 
    loadref  u64   .s 
    loadimm  i64   2 
    istorex  u8    1 -1
    setcall        1
    loadref  u64   .s 
    setarg   u64   1
    callp          msys.printstr 1 0
    loadimm  i64   1 
    store    i64   msys.needgap 
;------------------------
#8044:
    return         
end

proc msys.m$print_str
    param    u64   .s 
    param    u64   .fmtstyle 
    local    u8:16 .fmt 
;------------------------
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #8047 
    setcall        1
    loadimm  u64   "<null>"
    setarg   u64   1
    callp          msys.printstr 1 0
    jump           #8045 
#8047:
#8046:
    load     u64   .fmtstyle 
    loadimm  u64   0 
    jumpne   u64   #8050 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callp          msys.printstr 1 0
    jump           #8049 
#8050:
    setcall        3
    loadref  u64   .fmt 
    setarg   u64   3
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   .fmtstyle 
    setarg   u64   1
    callp          msys.strtofmt 3 0
    setcall        3
    loadref  u64   .fmt 
    setarg   u64   3
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callp          msys.tostr_str 3 0
#8049:
    loadimm  i64   1 
    store    i64   msys.needgap 
;------------------------
#8045:
    return         
end

proc msys.m$print_strn
    param    u64   .s 
    param    i64   .length 
    param    u64   .fmtstyle 
    local    u8:16 .fmt 
;------------------------
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #8053 
    setcall        1
    loadimm  u64   "<null>"
    setarg   u64   1
    callp          msys.printstr 1 0
    jump           #8051 
#8053:
#8052:
    load     u64   .fmtstyle 
    loadimm  u64   0 
    jumpne   u64   #8055 
    setcall        2
    load     i64   .length 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callp          msys.printstr_n 2 0
    jump           #8054 
#8055:
    setcall        3
    loadref  u64   .fmt 
    setarg   u64   3
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   .fmtstyle 
    setarg   u64   1
    callp          msys.strtofmt 3 0
    setcall        3
    loadref  u64   .fmt 
    setarg   u64   3
    load     i64   .length 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callp          msys.tostr_str 3 0
#8054:
    loadimm  i64   1 
    store    i64   msys.needgap 
;------------------------
#8051:
    return         
end

proc msys.m$print_str_nf
    param    u64   .s 
;------------------------
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callp          msys.m$print_str 2 0
;------------------------
#8056:
    return         
end

proc msys.m$print_strsl
    param    u64   .s 
    param    u64   .fmtstyle 
    local    u8:16 .fmt 
;------------------------
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    setcall        1
    loadimm  u64   "FORMATED PRINT SLICE NOT READY"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
    loadimm  i64   1 
    store    i64   msys.needgap 
;------------------------
#8057:
    return         
end

proc msys.m$print_newline
;------------------------
    loadimm  i64   0 
    store    i64   msys.needgap 
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callp          msys.nextfmtchars 1 0
    setcall        1
    loadimm  u64   "\r\n"
    setarg   u64   1
    callp          msys.printstr 1 0
;------------------------
#8059:
    return         
end

proc msys.m$print_nogap
;------------------------
    loadimm  i64   0 
    store    i64   msys.needgap 
;------------------------
#8061:
    return         
end

proc msys.m$print_space
;------------------------
    loadimm  i64   0 
    store    i64   msys.needgap 
    setcall        1
    loadimm  u64   " "
    setarg   u64   1
    callp          msys.printstr 1 0
;------------------------
#8062:
    return         
end

proc msys.printstr
    param    u64   .s 
;------------------------
    setcall        2
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callp          msys.printstr_n 2 0
;------------------------
#8064:
    return         
end

proc msys.printstr_n
    param    u64   .s 
    param    i64   .n 
    local    u64   .p 
    local    u64   .f 
;------------------------
    load     i64   .n 
    loadimm  i64   0 
    jumpne   i64   #8067 
    jump           #8065 
#8067:
#8066:
    load     i64   msys.outdev 
    loadimm  i64   1 
    jumpeq   i64   #8069 1
    loadimm  i64   2 
    jumpeq   i64   #8070 
    jump           #8071 
#8069:
    setcall        3
    load     u64   .s 
    setarg   u64   3
    load     i64   .n 
    setarg   i64   2
    loadimm  u64   "%.*s"
    setarg   u64   1
    callp          printf 3 2
    jump           #8068 
#8070:
    setcall        4
    load     u64   .s 
    setarg   u64   4
    load     i64   .n 
    setarg   i64   3
    loadimm  u64   "%.*s"
    setarg   u64   2
    load     u64   msys.outchan 
    setarg   u64   1
    callp          fprintf 4 3
    jump           #8065 
    jump           #8068 
#8071:
    load     u64   msys.outchan 
    store    u64   .p 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .p 
    iload    u64   
    setarg   u64   1
    callp          memcpy 3 0
    load     u64   .p 
    load     i64   .n 
    addpxto  u64   1 0
    loadimm  u64   0 
    load     u64   .p 
    iload    u64   
    istore   u8    
#8068:
;------------------------
#8065:
    return         
end

proc msys.printstrn_app
    param    u64   .s 
    param    i64   .length 
    param    u64   .f 
;------------------------
    load     i64   .length 
    jumpf    i64   #8075 
    load     u64   .f 
    loadimm  u64   0 
    jumpne   u64   #8077 
    setcall        3
    load     u64   .s 
    setarg   u64   3
    load     i64   .length 
    setarg   i64   2
    loadimm  u64   "%.*s"
    setarg   u64   1
    callp          printf 3 2
    jump           #8076 
#8077:
    setcall        4
    load     u64   .s 
    setarg   u64   4
    load     i64   .length 
    setarg   i64   3
    loadimm  u64   "%.*s"
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callp          fprintf 4 3
#8076:
#8075:
#8074:
;------------------------
#8073:
    return         
end

proc msys.printchar
    param    i64   .ch 
    local    u64   .p 
    local    u32   .str 
;------------------------
    load     i64   .ch 
    loadref  u64   .str 
    loadimm  i64   1 
    istorex  u8    1 -1
    load     i64   .ch 
    loadref  u64   .str 
    loadimm  i64   0 
    istorex  u8    1 -1
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          msys.printstr_n 2 0
;------------------------
#8078:
    return         
end

proc msys.nextfmtchars
    param    i64   .lastx 
    local    u8    .c 
    local    u64   .pstart 
    local    i64   .n 
;------------------------
    load     u64   msys.fmtstr 
    jumpt    u64   #8081 
    load     i64   msys.needgap 
    jumpf    i64   #8083 
    setcall        1
    loadimm  i64   32 
    setarg   i64   1
    callp          msys.printchar 1 0
#8083:
#8082:
    loadimm  i64   0 
    store    i64   msys.needgap 
    jump           #8079 
#8081:
#8080:
    load     u64   msys.fmtstr 
    store    u64   .pstart 
    loadimm  i64   0 
    store    i64   .n 
#8084:
    load     u64   msys.fmtstr 
    iload    u8    
    store    u8    .c 
    load     u8    .c 
    switch         #8087 0 126
    opnd           #8088 
#8087:
    swlabel        #8095 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8089 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8088 
    swlabel        #8100 
    endsw          
#8089:
    load     i64   .lastx 
    jumpf    i64   #8091 
    jump           #8092 
#8091:
#8090:
    loadref  u64   msys.fmtstr 
    incrto   u64   1
    load     i64   .n 
    jumpf    i64   #8094 
    setcall        2
    load     i64   .n 
    setarg   i64   2
    load     u64   .pstart 
    setarg   u64   1
    callp          msys.printstr_n 2 0
#8094:
#8093:
    jump           #8079 
    jump           #8086 
#8095:
    load     i64   .n 
    jumpf    i64   #8097 
    setcall        2
    load     i64   .n 
    setarg   i64   2
    load     u64   .pstart 
    setarg   u64   1
    callp          msys.printstr_n 2 0
    jump           #8096 
#8097:
    load     i64   .lastx 
    jumpt    i64   #8098 
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    loadimm  u64   "|"
    setarg   u64   1
    callp          msys.printstr_n 2 0
#8098:
#8096:
    jump           #8079 
    jump           #8086 
#8100:
    load     i64   .n 
    jumpf    i64   #8102 
    setcall        2
    load     i64   .n 
    setarg   i64   2
    load     u64   .pstart 
    setarg   u64   1
    callp          msys.printstr_n 2 0
    loadimm  i64   0 
    store    i64   .n 
#8102:
#8101:
    loadref  u64   msys.fmtstr 
    incrto   u64   1
    load     u64   msys.fmtstr 
    iload    u8    
    store    u8    .c 
    load     u8    .c 
    jumpf    u64   #8104 
    loadref  u64   msys.fmtstr 
    incrto   u64   1
    setcall        1
    load     u8    .c 
    setarg   i64   1
    callp          msys.printchar 1 0
#8104:
#8103:
    load     u64   msys.fmtstr 
    store    u64   .pstart 
    jump           #8086 
#8088:
;skip::
#8092:
    loadref  u64   .n 
    incrto   i64   1
    loadref  u64   msys.fmtstr 
    incrto   u64   1
#8086:
    jump           #8084 
#8085:
;------------------------
#8079:
    return         
end

proc msys.strtofmt
    param    u64   .s 
    param    i64   .slen 
    param    u64   .fmt 
    local    i64   .c 
    local    i64   .base 
    local    u8    .wset 
    local    i64   .n 
    local    u8:100 .str 
;------------------------
    load     u8:16 msys.defaultfmt 
    load     u64   .fmt 
    istore   u8:16 
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #8107 
    jump           #8105 
#8107:
#8106:
    load     i64   .slen 
    loadimm  i64   -1 
    jumpne   i64   #8109 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .slen 
#8109:
#8108:
    setcall        3
    load     i64   .slen 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    loadref  u64   .str 
    load     i64   .slen 
    istorex  u8    1 0
    loadref  u64   .str 
    store    u64   .s 
    loadimm  i64   0 
    store    u8    .wset 
    jump           #8111 
#8110:
    load     u64   .s 
    iload    u8    
    store    i64   .c 
    loadref  u64   .s 
    incrto   u64   1
    load     i64   .c 
    switch         #8114 42 126
    opnd           #8115 
#8114:
    swlabel        #8154 
    swlabel        #8149 
    swlabel        #8148 
    swlabel        #8115 
    swlabel        #8147 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8131 
    swlabel        #8116 
    swlabel        #8151 
    swlabel        #8150 
    swlabel        #8144 
    swlabel        #8145 
    swlabel        #8146 
    swlabel        #8117 
    swlabel        #8115 
    swlabel        #8128 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8152 
    swlabel        #8115 
    swlabel        #8118 
    swlabel        #8137 
    swlabel        #8126 
    swlabel        #8115 
    swlabel        #8134 
    swlabel        #8140 
    swlabel        #8115 
    swlabel        #8153 
    swlabel        #8143 
    swlabel        #8119 
    swlabel        #8115 
    swlabel        #8133 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8148 
    swlabel        #8115 
    swlabel        #8132 
    swlabel        #8116 
    swlabel        #8151 
    swlabel        #8150 
    swlabel        #8144 
    swlabel        #8145 
    swlabel        #8146 
    swlabel        #8117 
    swlabel        #8115 
    swlabel        #8128 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8152 
    swlabel        #8115 
    swlabel        #8118 
    swlabel        #8137 
    swlabel        #8126 
    swlabel        #8115 
    swlabel        #8134 
    swlabel        #8140 
    swlabel        #8115 
    swlabel        #8153 
    swlabel        #8143 
    swlabel        #8119 
    swlabel        #8115 
    swlabel        #8133 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8115 
    swlabel        #8127 
    endsw          
#8116:
    loadimm  i64   2 
    load     u64   .fmt 
    loadimm  i64   2 
    istorex  u8    1 0
    jump           #8113 
#8117:
    loadimm  i64   16 
    load     u64   .fmt 
    loadimm  i64   2 
    istorex  u8    1 0
    jump           #8113 
#8118:
    loadimm  i64   8 
    load     u64   .fmt 
    loadimm  i64   2 
    istorex  u8    1 0
    jump           #8113 
#8119:
    loadimm  i64   0 
    store    i64   .base 
#8120:
    load     u64   .s 
    iload    u8    
    store    i64   .c 
    load     i64   .c 
    loadimm  i64   48 
    jumplt   i64   #8123 1
    loadimm  i64   57 
    jumpgt   i64   #8123 
    load     i64   .base 
    loadimm  i64   10 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    i64   .base 
    loadref  u64   .s 
    incrto   u64   1
    jump           #8122 
#8123:
    jump           #8121 
#8122:
    jump           #8120 
#8121:
    load     i64   .base 
    loadimm  i64   2 
    jumplt   i64   #8125 1
    loadimm  i64   16 
    jumpgt   i64   #8125 
    load     i64   .base 
    load     u64   .fmt 
    loadimm  i64   2 
    istorex  u8    1 0
#8125:
#8124:
    jump           #8113 
#8126:
    loadimm  u64   34 
    load     u64   .fmt 
    loadimm  i64   3 
    istorex  u8    1 0
    jump           #8113 
#8127:
    loadimm  u64   126 
    load     u64   .fmt 
    loadimm  i64   3 
    istorex  u8    1 0
    jump           #8113 
#8128:
    setcall        1
    load     u64   .s 
    iload    u8    
    setarg   i32   1
    callf    i32   toupper 1 0
    widen    i32   
    load     u64   .fmt 
    loadimm  i64   9 
    istorex  u8    1 0
    load     u64   .s 
    iload    u8    
    jumpf    u64   #8130 
    loadref  u64   .s 
    incrto   u64   1
#8130:
#8129:
    jump           #8113 
#8131:
    loadimm  u64   65 
    load     u64   .fmt 
    loadimm  i64   8 
    istorex  u8    1 0
    jump           #8113 
#8132:
    loadimm  u64   97 
    load     u64   .fmt 
    loadimm  i64   8 
    istorex  u8    1 0
    jump           #8113 
#8133:
    loadimm  u64   48 
    load     u64   .fmt 
    loadimm  i64   4 
    istorex  u8    1 0
    jump           #8113 
#8134:
    load     u64   .s 
    iload    u8    
    load     u64   .fmt 
    loadimm  i64   7 
    istorex  u8    1 0
    load     u64   .s 
    iload    u8    
    jumpf    u64   #8136 
    loadref  u64   .s 
    incrto   u64   1
#8136:
#8135:
    jump           #8113 
#8137:
    load     u64   .s 
    iload    u8    
    load     u64   .fmt 
    loadimm  i64   4 
    istorex  u8    1 0
    load     u64   .s 
    iload    u8    
    jumpf    u64   #8139 
    loadref  u64   .s 
    incrto   u64   1
#8139:
#8138:
    jump           #8113 
#8140:
    load     u64   .s 
    iload    u8    
    load     u64   .fmt 
    loadimm  i64   10 
    istorex  u8    1 0
    load     u64   .s 
    iload    u8    
    jumpf    u64   #8142 
    loadref  u64   .s 
    incrto   u64   1
#8142:
#8141:
    jump           #8113 
#8143:
    loadimm  u64   87 
    load     u64   .fmt 
    loadimm  i64   11 
    istorex  u8    1 0
    jump           #8113 
#8144:
    loadimm  u64   101 
    load     u64   .fmt 
    loadimm  i64   5 
    istorex  u8    1 0
    jump           #8113 
#8145:
    loadimm  u64   102 
    load     u64   .fmt 
    loadimm  i64   5 
    istorex  u8    1 0
    jump           #8113 
#8146:
    loadimm  u64   103 
    load     u64   .fmt 
    loadimm  i64   5 
    istorex  u8    1 0
    jump           #8113 
#8147:
    loadimm  i64   1 
    store    u8    .wset 
    jump           #8113 
#8148:
    load     i64   .c 
    load     u64   .fmt 
    loadimm  i64   7 
    istorex  u8    1 0
    jump           #8113 
#8149:
    loadimm  u64   43 
    load     u64   .fmt 
    loadimm  i64   6 
    istorex  u8    1 0
    jump           #8113 
#8150:
    loadimm  u64   77 
    load     u64   .fmt 
    loadimm  i64   12 
    istorex  u8    1 0
    jump           #8113 
#8151:
    loadimm  u64   67 
    load     u64   .fmt 
    loadimm  i64   12 
    istorex  u8    1 0
    jump           #8113 
#8152:
    loadimm  u64   77 
    load     u64   .fmt 
    loadimm  i64   12 
    istorex  u8    1 0
    jump           #8113 
#8153:
    loadimm  u64   86 
    load     u64   .fmt 
    loadimm  i64   14 
    istorex  u8    1 0
    jump           #8113 
#8154:
    load     i64   msys.fmtparam 
    store    i64   .n 
    jump           #8155 
    jump           #8113 
#8115:
    load     i64   .c 
    loadimm  i64   48 
    jumplt   i64   #8157 
    load     i64   .c 
    loadimm  i64   57 
    jumpgt   i64   #8157 
    load     i64   .c 
    loadimm  i64   48 
    sub      i64   
    store    i64   .n 
#8158:
    load     u64   .s 
    iload    u8    
    store    i64   .c 
    load     u64   .s 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8161 
    jump           #8159 
#8161:
#8160:
    load     i64   .c 
    loadimm  i64   48 
    jumplt   i64   #8163 
    load     i64   .c 
    loadimm  i64   57 
    jumpgt   i64   #8163 
    loadref  u64   .s 
    incrto   u64   1
    load     i64   .n 
    loadimm  i64   10 
    mul      i64   
    load     i64   .c 
    add      i64   
    loadimm  i64   48 
    sub      i64   
    store    i64   .n 
    jump           #8162 
#8163:
    jump           #8159 
#8162:
    jump           #8158 
#8159:
;gotwidth::
#8155:
    load     u8    .wset 
    jumpt    i64   #8165 
    load     i64   .n 
    load     u64   .fmt 
    loadimm  i64   0 
    istorex  u8    1 0
    loadimm  i64   1 
    store    u8    .wset 
    jump           #8164 
#8165:
    load     i64   .n 
    load     u64   .fmt 
    loadimm  i64   1 
    istorex  i8    1 0
#8164:
#8157:
#8156:
#8113:
#8111:
    load     u64   .s 
    iload    u8    
    jumpt    u64   #8110 
#8112:
;------------------------
#8105:
    return         
end

proc msys.domultichar
    rettype  i64   
    param    u64   .p 
    param    i64   .n 
    param    u64   .dest 
    param    u64   .fmt 
    local    u8:20 .str 
    local    u64   .q 
    local    i64   .i 
    local    i64   .nchars 
    local    i64   .$av_1 
;------------------------
    loadref  u64   .str 
    store    u64   .q 
    load     i64   .n 
    store    i64   .nchars 
    load     i64   .n 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #8169 
#8167:
    load     u64   .p 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8171 
    jump           #8169 
#8171:
#8170:
    load     u64   .p 
    iload    u8    
    load     u64   .q 
    istore   u8    
    loadref  u64   .q 
    incrto   u64   1
    loadref  u64   .p 
    incrto   u64   1
#8168:
    to             #8167 
    opnd           .$av_1 
#8169:
    loadimm  u64   0 
    load     u64   .q 
    istore   u8    
    setcall        4
    load     u64   .fmt 
    setarg   u64   4
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   strlen 1 0
    setarg   i64   3
    load     u64   .dest 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   msys.expandstr 4 0
    setret   i64   
    jump           #8166 
;------------------------
#8166:
    return         
end

proc msys.expandstr
    rettype  i64   
    param    u64   .s 
    param    u64   .t 
    param    i64   .n 
    param    u64   .fmt 
    local    i64   .i 
    local    i64   .w 
    local    i64   .m 
    local    i64   .$av_1 
    local    i64   .$av_2 
    local    i64   .$av_3 
    local    i64   .$av_4 
    local    i64   .$av_5 
;------------------------
    load     u64   .fmt 
    iload    u8    
    store    i64   .w 
    load     i64   .w 
    loadimm  i64   0 
    jumpeq   i64   #8175 
    load     i64   .w 
    load     i64   .n 
    jumpgt   i64   #8174 
#8175:
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .t 
    setarg   u64   1
    callf    u64   strncpy 3 0
    unload   u64   
    loadimm  u64   0 
    load     u64   .t 
    load     i64   .n 
    addptrx  u64   1 0
    istore   u8    
    load     i64   .n 
    setret   i64   
    jump           #8172 
#8174:
#8173:
    load     u64   .fmt 
    loadimm  i64   9 
    iloadx   u8    1 0
    loadimm  u64   76 
    jumpne   u64   #8177 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .t 
    setarg   u64   1
    callf    u64   strncpy 3 0
    unload   u64   
    loadref  u64   .t 
    load     i64   .n 
    addpxto  u64   1 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .w 
    load     i64   .n 
    sub      i64   
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #8180 
#8178:
    load     u64   .fmt 
    loadimm  i64   4 
    iloadx   u8    1 0
    load     u64   .t 
    istore   u8    
    loadref  u64   .t 
    incrto   u64   1
#8179:
    forup          #8178 1
    opnd           .i 
    opnd           .$av_1 
#8180:
    loadimm  u64   0 
    load     u64   .t 
    istore   u8    
    jump           #8176 
#8177:
    load     u64   .fmt 
    loadimm  i64   9 
    iloadx   u8    1 0
    loadimm  u64   82 
    jumpne   u64   #8181 
    load     u64   .fmt 
    loadimm  i64   4 
    iloadx   u8    1 0
    loadimm  u64   48 
    jumpne   u64   #8183 
    load     u64   .fmt 
    loadimm  i64   2 
    iloadx   u8    1 0
    jumpf    i64   #8183 
    load     u64   .s 
    iload    u8    
    loadimm  u64   45 
    jumpeq   u64   #8184 
    load     u64   .s 
    iload    u8    
    loadimm  u64   43 
    jumpne   u64   #8183 
#8184:
    load     u64   .s 
    iload    u8    
    load     u64   .t 
    istore   u8    
    loadref  u64   .t 
    incrto   u64   1
    load     i64   .w 
    load     i64   .n 
    sub      i64   
    store    i64   .$av_2 
    load     i64   .$av_2 
    loadimm  i64   0 
    jumple   i64   #8187 
#8185:
    load     u64   .fmt 
    loadimm  i64   4 
    iloadx   u8    1 0
    load     u64   .t 
    istore   u8    
    loadref  u64   .t 
    incrto   u64   1
#8186:
    to             #8185 
    opnd           .$av_2 
#8187:
    setcall        3
    load     i64   .n 
    loadimm  i64   1 
    sub      i64   
    setarg   u64   3
    load     u64   .s 
    loadimm  i64   1 
    addptrx  u64   1 0
    setarg   u64   2
    load     u64   .t 
    setarg   u64   1
    callf    u64   strncpy 3 0
    unload   u64   
    loadimm  u64   0 
    load     u64   .t 
    load     i64   .n 
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    istore   u8    
    jump           #8182 
#8183:
    load     i64   .w 
    load     i64   .n 
    sub      i64   
    store    i64   .$av_3 
    load     i64   .$av_3 
    loadimm  i64   0 
    jumple   i64   #8190 
#8188:
    load     u64   .fmt 
    loadimm  i64   4 
    iloadx   u8    1 0
    load     u64   .t 
    istore   u8    
    loadref  u64   .t 
    incrto   u64   1
#8189:
    to             #8188 
    opnd           .$av_3 
#8190:
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .t 
    setarg   u64   1
    callf    u64   strncpy 3 0
    unload   u64   
    loadimm  u64   0 
    load     u64   .t 
    load     i64   .n 
    addptrx  u64   1 0
    istore   u8    
#8182:
    jump           #8176 
#8181:
    load     i64   .w 
    load     i64   .n 
    sub      i64   
    loadimm  i64   1 
    add      i64   
    loadimm  i64   2 
    div      i64   
    store    i64   .m 
    load     i64   .m 
    store    i64   .$av_4 
    load     i64   .$av_4 
    loadimm  i64   0 
    jumple   i64   #8193 
#8191:
    load     u64   .fmt 
    loadimm  i64   4 
    iloadx   u8    1 0
    load     u64   .t 
    istore   u8    
    loadref  u64   .t 
    incrto   u64   1
#8192:
    to             #8191 
    opnd           .$av_4 
#8193:
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .t 
    setarg   u64   1
    callf    u64   strncpy 3 0
    unload   u64   
    loadref  u64   .t 
    load     i64   .n 
    addpxto  u64   1 0
    load     i64   .w 
    load     i64   .n 
    sub      i64   
    load     i64   .m 
    sub      i64   
    store    i64   .$av_5 
    load     i64   .$av_5 
    loadimm  i64   0 
    jumple   i64   #8196 
#8194:
    load     u64   .fmt 
    loadimm  i64   4 
    iloadx   u8    1 0
    load     u64   .t 
    istore   u8    
    loadref  u64   .t 
    incrto   u64   1
#8195:
    to             #8194 
    opnd           .$av_5 
#8196:
    loadimm  u64   0 
    load     u64   .t 
    istore   u8    
#8176:
    load     i64   .w 
    setret   i64   
    jump           #8172 
;------------------------
#8172:
    return         
end

proc msys.u64tostr
    rettype  i64   
    param    u64   .aa 
    param    u64   .s 
    param    u64   .base 
    param    i64   .sep 
    local    u8:360 .t 
    local    u64   .dd 
    local    i64   .i 
    local    i64   .j 
    local    i64   .k 
    local    i64   .g 
    local    i64   .cc 
    local    i64   .dummy 
    local    u64   .s0 
;------------------------
    loadimm  i64   0 
    store    i64   .i 
    loadimm  i64   0 
    store    i64   .k 
    startmx        
    load     u64   .base 
    loadimm  i64   10 
    jumpne   i64   #8199 
    loadimm  i64   3 
    resetmx        
    jump           #8198 
#8199:
    loadimm  i64   4 
    endmx          
#8198:
    store    i64   .g 
#8200:
    load     u64   .aa 
    load     u64   .base 
    rem      u64   
    store    u64   .dd 
    load     u64   .aa 
    load     u64   .base 
    div      u64   
    store    u64   .aa 
    loadref  u64   msys.digits 
    load     u64   .dd 
    iloadx   u8    1 0
    loadref  u64   .t 
    loadref  u64   .i 
    incrload i64   1
    istorex  u8    1 0
    loadref  u64   .k 
    incrto   i64   1
    load     i64   .sep 
    jumpf    i64   #8204 
    load     u64   .aa 
    loadimm  i64   0 
    jumpeq   i64   #8204 
    load     i64   .k 
    load     i64   .g 
    jumpne   i64   #8204 
    load     i64   .sep 
    loadref  u64   .t 
    loadref  u64   .i 
    incrload i64   1
    istorex  u8    1 0
    loadimm  i64   0 
    store    i64   .k 
#8204:
#8203:
#8201:
    load     u64   .aa 
    loadimm  i64   0 
    jumpne   i64   #8200 
#8202:
    load     i64   .i 
    store    i64   .j 
    load     u64   .s 
    store    u64   .s0 
    jump           #8206 
#8205:
    loadref  u64   .t 
    loadref  u64   .i 
    loaddecr i64   1
    iloadx   u8    1 0
    load     u64   .s 
    istore   u8    
    loadref  u64   .s 
    incrto   u64   1
#8206:
    load     i64   .i 
    jumpt    i64   #8205 
#8207:
    loadimm  u64   0 
    load     u64   .s 
    istore   u8    
    load     i64   .j 
    setret   i64   
    jump           #8197 
;------------------------
#8197:
    return         
end

proc msys.i64tostrfmt
    rettype  i64   
    param    i64   .aa 
    param    u64   .s 
    param    u64   .fmt 
    local    u8:360 .str 
    local    i64   .i 
    local    i64   .j 
    local    i64   .k 
    local    i64   .n 
    local    i64   .w 
    local    i64   .usigned 
;------------------------
    loadimm  i64   0 
    store    i64   .usigned 
    load     u64   .fmt 
    loadimm  i64   11 
    iloadx   u8    1 0
    jumpf    u64   #8210 
    loadimm  i64   1 
    store    i64   .usigned 
#8210:
#8209:
    load     i64   .aa 
    loadimm  i64   -9223372036854775808 
    jumpne   i64   #8212 
    load     i64   .usigned 
    jumpt    i64   #8212 
    loadimm  u64   45 
    loadref  u64   .str 
    loadimm  i64   0 
    istorex  u8    1 0
    setcall        3
    load     u64   .fmt 
    loadimm  i64   7 
    iloadx   u8    1 0
    setarg   i64   3
    load     u64   .fmt 
    loadimm  i64   2 
    iloadx   u8    1 0
    setarg   i64   2
    loadref  u64   .str 
    loadimm  i64   1 
    addptrx  u8    1 0
    setarg   u64   1
    callf    i64   msys.i64mintostr 3 0
    loadimm  i64   1 
    add      i64   
    store    i64   .n 
    jump           #8211 
#8212:
    load     i64   .usigned 
    jumpt    i64   #8216 
    load     i64   .aa 
    loadimm  i64   0 
    jumplt   i64   #8215 
#8216:
    load     u64   .fmt 
    loadimm  i64   6 
    iloadx   u8    1 0
    jumpf    u64   #8214 
#8215:
    load     i64   .aa 
    loadimm  i64   0 
    jumpge   i64   #8218 
    load     i64   .aa 
    neg      i64   
    store    i64   .aa 
    loadimm  u64   45 
    loadref  u64   .str 
    loadimm  i64   0 
    istorex  u8    1 0
    jump           #8217 
#8218:
    loadimm  u64   43 
    loadref  u64   .str 
    loadimm  i64   0 
    istorex  u8    1 0
#8217:
    setcall        4
    load     u64   .fmt 
    loadimm  i64   7 
    iloadx   u8    1 0
    setarg   i64   4
    load     u64   .fmt 
    loadimm  i64   2 
    iloadx   u8    1 0
    setarg   u64   3
    loadref  u64   .str 
    loadimm  i64   1 
    addptrx  u8    1 0
    setarg   u64   2
    load     i64   .aa 
    setarg   u64   1
    callf    i64   msys.u64tostr 4 0
    loadimm  i64   1 
    add      i64   
    store    i64   .n 
    jump           #8213 
#8214:
    setcall        4
    load     u64   .fmt 
    loadimm  i64   7 
    iloadx   u8    1 0
    setarg   i64   4
    load     u64   .fmt 
    loadimm  i64   2 
    iloadx   u8    1 0
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    load     i64   .aa 
    setarg   u64   1
    callf    i64   msys.u64tostr 4 0
    store    i64   .n 
#8213:
#8211:
    load     u64   .fmt 
    loadimm  i64   10 
    iloadx   u8    1 0
    jumpf    u64   #8220 
    load     u64   .fmt 
    loadimm  i64   10 
    iloadx   u8    1 0
    loadref  u64   .str 
    load     i64   .n 
    istorex  u8    1 0
    loadimm  u64   0 
    loadref  u64   .str 
    loadref  u64   .n 
    incrload i64   1
    istorex  u8    1 0
#8220:
#8219:
    load     u64   .fmt 
    loadimm  i64   2 
    iloadx   u8    1 0
    loadimm  i64   10 
    jumpgt   i64   #8223 
    load     u64   .fmt 
    loadimm  i64   10 
    iloadx   u8    1 0
    jumpf    u64   #8222 
#8223:
    load     u64   .fmt 
    loadimm  i64   8 
    iloadx   u8    1 0
    loadimm  u64   97 
    jumpne   u64   #8222 
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
#8222:
#8221:
    setcall        4
    load     u64   .fmt 
    setarg   u64   4
    load     i64   .n 
    setarg   i64   3
    load     u64   .s 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   msys.expandstr 4 0
    setret   i64   
    jump           #8208 
;------------------------
#8208:
    return         
end

proc msys.u64tostrfmt
    rettype  i64   
    param    i64   .aa 
    param    u64   .s 
    param    u64   .fmt 
    local    u8:360 .str 
    local    i64   .i 
    local    i64   .j 
    local    i64   .k 
    local    i64   .n 
    local    i64   .w 
;------------------------
    setcall        4
    load     u64   .fmt 
    loadimm  i64   7 
    iloadx   u8    1 0
    setarg   i64   4
    load     u64   .fmt 
    loadimm  i64   2 
    iloadx   u8    1 0
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    load     i64   .aa 
    setarg   u64   1
    callf    i64   msys.u64tostr 4 0
    store    i64   .n 
    load     u64   .fmt 
    loadimm  i64   10 
    iloadx   u8    1 0
    jumpf    u64   #8226 
    load     u64   .fmt 
    loadimm  i64   10 
    iloadx   u8    1 0
    loadref  u64   .str 
    load     i64   .n 
    istorex  u8    1 0
    loadimm  u64   0 
    loadref  u64   .str 
    loadref  u64   .n 
    incrload i64   1
    istorex  u8    1 0
#8226:
#8225:
    load     u64   .fmt 
    loadimm  i64   2 
    iloadx   u8    1 0
    loadimm  i64   10 
    jumpgt   i64   #8229 
    load     u64   .fmt 
    loadimm  i64   10 
    iloadx   u8    1 0
    jumpf    u64   #8228 
    load     u64   .fmt 
    loadimm  i64   8 
    iloadx   u8    1 0
    loadimm  u64   97 
    jumpne   u64   #8228 
#8229:
#8228:
#8227:
    setcall        4
    load     u64   .fmt 
    setarg   u64   4
    load     i64   .n 
    setarg   i64   3
    load     u64   .s 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   msys.expandstr 4 0
    setret   i64   
    jump           #8224 
;------------------------
#8224:
    return         
end

proc msys.i64mintostr
    rettype  i64   
    param    u64   .s 
    param    i64   .base 
    param    i64   .sep 
    local    u8:360 .t 
    local    i64   .i 
    local    i64   .j 
    local    i64   .k 
    local    i64   .g 
    local    i64   .neg 
;------------------------
    load     i64   .base 
    switch         #8232 2 16
    opnd           #8233 
#8232:
    swlabel        #8238 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8234 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8233 
    swlabel        #8236 
    endsw          
#8234:
    setcall        2
    loadimm  u64   "9223372036854775808"
    setarg   u64   2
    loadref  u64   .t 
    loadimm  i64   0 
    addptrx  u8    1 0
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadimm  i64   3 
    store    i64   .j 
    jump           #8231 
#8236:
    setcall        2
    loadimm  u64   "8000000000000000"
    setarg   u64   2
    loadref  u64   .t 
    loadimm  i64   0 
    addptrx  u8    1 0
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadimm  i64   1 
    store    i64   .j 
    jump           #8231 
#8238:
    setcall        2
    loadimm  u64   "1000000000000000000000000000000000000000000000000000000000000000"
    setarg   u64   2
    loadref  u64   .t 
    loadimm  i64   0 
    addptrx  u8    1 0
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadimm  i64   7 
    store    i64   .j 
    jump           #8231 
#8233:
    setcall        2
    loadimm  u64   "<mindint>"
    setarg   u64   2
    loadref  u64   .t 
    loadimm  i64   0 
    addptrx  u8    1 0
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
#8231:
    setcall        1
    loadref  u64   .t 
    loadimm  i64   0 
    addptrx  u8    1 0
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .i 
    loadref  u64   .s 
    load     i64   .i 
    addpxto  u64   1 0
    load     i64   .sep 
    jumpf    i64   #8242 
    loadref  u64   .s 
    load     i64   .j 
    addpxto  u64   1 0
#8242:
#8241:
    loadimm  u64   0 
    load     u64   .s 
    istore   u8    
    loadimm  i64   0 
    store    i64   .k 
    startmx        
    load     i64   .base 
    loadimm  i64   10 
    jumpne   i64   #8244 
    loadimm  i64   3 
    resetmx        
    jump           #8243 
#8244:
    loadimm  i64   4 
    endmx          
#8243:
    store    i64   .g 
    jump           #8246 
#8245:
    loadref  u64   .s 
    decrto   u64   1
    loadref  u64   .t 
    loadref  u64   .i 
    loaddecr i64   1
    iloadx   u8    1 -1
    load     u64   .s 
    istore   u8    
    load     i64   .sep 
    jumpf    i64   #8249 
    load     i64   .i 
    jumpf    i64   #8249 
    loadref  u64   .k 
    incrload i64   1
    load     i64   .g 
    jumpne   i64   #8249 
    loadref  u64   .s 
    decrto   u64   1
    load     i64   .sep 
    load     u64   .s 
    istore   u8    
    loadimm  i64   0 
    store    i64   .k 
#8249:
#8248:
#8246:
    load     i64   .i 
    jumpt    i64   #8245 
#8247:
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    setret   i64   
    jump           #8230 
;------------------------
#8230:
    return         
end

proc msys.strtostrfmt
    rettype  i64   
    param    u64   .s 
    param    u64   .t 
    param    i64   .n 
    param    u64   .fmt 
    local    u64   .u 
    local    u64   .v 
    local    u8:256 .str 
    local    i64   .w 
    local    i64   .nheap 
;------------------------
    loadimm  i64   0 
    store    i64   .nheap 
    load     u64   .fmt 
    loadimm  i64   3 
    iloadx   u8    1 0
    jumpt    u64   #8253 
    load     u64   .fmt 
    loadimm  i64   8 
    iloadx   u8    1 0
    jumpf    u64   #8252 
#8253:
    load     i64   .n 
    loadimm  i64   256 
    jumpge   i64   #8255 
    loadref  u64   .str 
    store    u64   .u 
    jump           #8254 
#8255:
    load     i64   .n 
    loadimm  i64   3 
    add      i64   
    store    i64   .nheap 
    setcall        1
    load     i64   .nheap 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .u 
#8254:
    load     u64   .fmt 
    loadimm  i64   3 
    iloadx   u8    1 0
    jumpf    u64   #8257 
    load     u64   .u 
    store    u64   .v 
    load     u64   .fmt 
    loadimm  i64   3 
    iloadx   u8    1 0
    load     u64   .v 
    istore   u8    
    loadref  u64   .v 
    incrto   u64   1
    load     i64   .n 
    jumpf    i64   #8259 
    setcall        2
    load     u64   .s 
    setarg   u64   2
    load     u64   .v 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadref  u64   .v 
    load     i64   .n 
    addpxto  u64   1 0
#8259:
#8258:
    load     u64   .fmt 
    loadimm  i64   3 
    iloadx   u8    1 0
    load     u64   .v 
    istore   u8    
    loadref  u64   .v 
    incrto   u64   1
    loadimm  u64   0 
    load     u64   .v 
    istore   u8    
    loadref  u64   .n 
    loadimm  i64   2 
    addto    i64   
    jump           #8256 
#8257:
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .u 
    setarg   u64   1
    callp          memcpy 3 0
#8256:
    load     u64   .fmt 
    loadimm  i64   8 
    iloadx   u8    1 0
    switch         #8261 65 97
    opnd           #8262 
#8261:
    swlabel        #8264 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8262 
    swlabel        #8263 
    endsw          
#8263:
    setcall        1
    load     u64   .u 
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
    jump           #8260 
#8264:
    setcall        1
    load     u64   .u 
    setarg   u64   1
    callf    u64   mlib.convucstring 1 0
    unload   u64   
    jump           #8260 
#8262:
#8260:
    load     u64   .u 
    store    u64   .s 
#8252:
#8251:
    load     u64   .fmt 
    iload    u8    
    store    i64   .w 
    load     i64   .w 
    load     i64   .n 
    jumple   i64   #8266 
    setcall        4
    load     u64   .fmt 
    setarg   u64   4
    load     i64   .n 
    setarg   i64   3
    load     u64   .t 
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callf    i64   msys.expandstr 4 0
    store    i64   .n 
    jump           #8265 
#8266:
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .t 
    setarg   u64   1
    callp          memcpy 3 0
#8265:
    load     i64   .nheap 
    jumpf    i64   #8268 
    setcall        2
    load     i64   .nheap 
    setarg   i64   2
    load     u64   .u 
    setarg   u64   1
    callp          mlib.pcm_free 2 0
#8268:
#8267:
    load     i64   .n 
    setret   i64   
    jump           #8250 
;------------------------
#8250:
    return         
end

proc msys.tostr_i64
    param    i64   .a 
    param    u64   .fmt 
    local    u8:360 .str 
    local    i64   .n 
;------------------------
    load     u64   .fmt 
    loadimm  i64   12 
    iloadx   u8    1 0
    loadimm  u64   0 
    jumpeq   u64   #8271 1
    loadimm  u64   77 
    jumpeq   u64   #8272 1
    loadimm  u64   109 
    jumpeq   u64   #8272 
    jump           #8273 
#8271:
    setcall        3
    load     u64   .fmt 
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    load     i64   .a 
    setarg   i64   1
    callf    i64   msys.i64tostrfmt 3 0
    store    i64   .n 
    jump           #8270 
#8272:
    setcall        4
    load     u64   .fmt 
    setarg   u64   4
    loadref  u64   .str 
    setarg   u64   3
    loadimm  i64   8 
    setarg   i64   2
    loadref  u64   .a 
    setarg   u64   1
    callf    i64   msys.domultichar 4 0
    store    i64   .n 
    jump           #8270 
#8273:
    setcall        1
    load     i64   .a 
    setarg   i64   1
    callp          msys.printchar 1 0
    jump           #8269 
#8270:
    setcall        2
    load     i64   .n 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          msys.printstr_n 2 0
;------------------------
#8269:
    return         
end

proc msys.tostr_u64
    param    u64   .a 
    param    u64   .fmt 
    local    u8:360 .str 
    local    i64   .n 
;------------------------
    load     u64   .fmt 
    loadimm  i64   12 
    iloadx   u8    1 0
    loadimm  u64   68 
    jumpeq   u64   #8276 1
    loadimm  u64   100 
    jumpeq   u64   #8276 1
    loadimm  u64   67 
    jumpeq   u64   #8277 1
    loadimm  u64   99 
    jumpeq   u64   #8277 
    jump           #8278 
#8276:
    setcall        4
    load     u64   .fmt 
    setarg   u64   4
    loadref  u64   .str 
    setarg   u64   3
    loadimm  i64   8 
    setarg   i64   2
    loadref  u64   .a 
    setarg   u64   1
    callf    i64   msys.domultichar 4 0
    store    i64   .n 
    jump           #8275 
#8277:
    setcall        1
    load     u64   .a 
    setarg   i64   1
    callp          msys.printchar 1 0
    jump           #8274 
    jump           #8275 
#8278:
    setcall        3
    load     u64   .fmt 
    setarg   u64   3
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .a 
    setarg   i64   1
    callf    i64   msys.u64tostrfmt 3 0
    store    i64   .n 
#8275:
    setcall        2
    load     i64   .n 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          msys.printstr_n 2 0
;------------------------
#8274:
    return         
end

proc msys.tostr_r64
    param    r64   .x 
    param    u64   .fmt 
    local    u8:360 .str 
    local    u8:360 .str2 
    local    u8:10 .cfmt 
    local    i64   .n 
;------------------------
    loadimm  u64   37 
    loadref  u64   .cfmt 
    loadimm  i64   0 
    istorex  u8    1 0
    load     u64   .fmt 
    loadimm  i64   1 
    iloadx   i8    1 0
    jumpf    i64   #8281 
    loadimm  u64   46 
    loadref  u64   .cfmt 
    loadimm  i64   1 
    istorex  u8    1 0
    loadimm  u64   42 
    loadref  u64   .cfmt 
    loadimm  i64   2 
    istorex  u8    1 0
    load     u64   .fmt 
    loadimm  i64   5 
    iloadx   u8    1 0
    loadref  u64   .cfmt 
    loadimm  i64   3 
    istorex  u8    1 0
    loadimm  u64   0 
    loadref  u64   .cfmt 
    loadimm  i64   4 
    istorex  u8    1 0
    setcall        4
    load     r64   .x 
    setarg   r64   4
    load     u64   .fmt 
    loadimm  i64   1 
    iloadx   i8    1 0
    setarg   i64   3
    loadref  u64   .cfmt 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          sprintf 4 3
    jump           #8280 
#8281:
    load     u64   .fmt 
    loadimm  i64   5 
    iloadx   u8    1 0
    loadref  u64   .cfmt 
    loadimm  i64   1 
    istorex  u8    1 0
    loadimm  u64   0 
    loadref  u64   .cfmt 
    loadimm  i64   2 
    istorex  u8    1 0
    setcall        3
    load     r64   .x 
    setarg   r64   3
    loadref  u64   .cfmt 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          sprintf 3 3
#8280:
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .n 
    load     i64   .n 
    load     u64   .fmt 
    iload    u8    
    jumpge   i64   #8283 
    setcall        4
    load     u64   .fmt 
    setarg   u64   4
    load     i64   .n 
    setarg   i64   3
    loadref  u64   .str2 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   msys.expandstr 4 0
    store    i64   .n 
    setcall        2
    loadref  u64   .str2 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
#8283:
#8282:
    setcall        2
    load     i64   .n 
    setarg   i64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          msys.printstr_n 2 0
;------------------------
#8279:
    return         
end

proc msys.tostr_str
    param    u64   .s 
    param    i64   .oldlen 
    param    u64   .fmt 
    local    i64   .newlen 
    local    i64   .n 
    local    u64   .t 
;------------------------
    load     i64   .oldlen 
    loadimm  i64   -1 
    jumpne   i64   #8286 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .oldlen 
#8286:
#8285:
    load     i64   .oldlen 
    store    i64   .newlen 
    load     u64   .fmt 
    loadimm  i64   3 
    iloadx   u8    1 0
    jumpt    u64   #8289 
    load     u64   .fmt 
    iload    u8    
    load     i64   .newlen 
    jumpgt   i64   #8289 
    load     u64   .fmt 
    loadimm  i64   8 
    iloadx   u8    1 0
    jumpt    u64   #8289 
    load     u64   .fmt 
    loadimm  i64   1 
    iloadx   i8    1 0
    jumpf    i64   #8288 
#8289:
    load     u64   .fmt 
    loadimm  i64   3 
    iloadx   u8    1 0
    jumpf    u64   #8291 
    loadref  u64   .newlen 
    loadimm  i64   2 
    addto    i64   
#8291:
#8290:
    load     u64   .fmt 
    iload    u8    
    load     i64   .newlen 
    jumple   i64   #8293 
    load     u64   .fmt 
    iload    u8    
    store    i64   .newlen 
#8293:
#8292:
    setcall        1
    load     i64   .newlen 
    loadimm  i64   1 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .t 
    setcall        4
    load     u64   .fmt 
    setarg   u64   4
    load     i64   .oldlen 
    setarg   i64   3
    load     u64   .t 
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callf    i64   msys.strtostrfmt 4 0
    store    i64   .n 
    load     u64   .fmt 
    loadimm  i64   1 
    iloadx   i8    1 0
    jumpf    i64   #8295 
    loadref  u64   .n 
    load     u64   .fmt 
    loadimm  i64   1 
    iloadx   i8    1 0
    minto    i64   
#8295:
#8294:
    setcall        2
    load     i64   .n 
    setarg   i64   2
    load     u64   .t 
    setarg   u64   1
    callp          msys.printstr_n 2 0
    setcall        2
    load     i64   .newlen 
    loadimm  i64   1 
    add      i64   
    setarg   i64   2
    load     u64   .t 
    setarg   u64   1
    callp          mlib.pcm_free 2 0
    jump           #8287 
#8288:
    setcall        2
    load     i64   .oldlen 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callp          msys.printstr_n 2 0
#8287:
;------------------------
#8284:
    return         
end

proc msys.getfmt
    rettype  u64   
    param    u64   .fmtstyle 
;------------------------
    startmx        
    load     u64   .fmtstyle 
    jumpf    u64   #8298 
    setcall        3
    loadref  u64   msys.getfmt.fmt 
    setarg   u64   3
    loadimm  i64   -1 
    setarg   i64   2
    load     u64   .fmtstyle 
    setarg   u64   1
    callp          msys.strtofmt 3 0
    loadref  u64   msys.getfmt.fmt 
    resetmx        
    jump           #8297 
#8298:
    loadref  u64   msys.defaultfmt 
    endmx          
#8297:
    setret   u64   
    jump           #8296 
;------------------------
#8296:
    return         
end

proc msys.strint
    rettype  u64   
    param    i64   .a 
    param    u64   .fmtstyle 
    local    u64   .fmt 
;------------------------
    setcall        1
    loadref  u64   msys.strint.str 
    setarg   u64   1
    callp          msys.m$print_startstr 1 0
    setcall        2
    setcall        1
    load     u64   .fmtstyle 
    setarg   u64   1
    callf    u64   msys.getfmt 1 0
    double         
    store    u64   .fmt 
    setarg   u64   2
    load     i64   .a 
    setarg   i64   1
    callp          msys.tostr_i64 2 0
    setcall        0
    callp          msys.m$print_end 0 0
    setcall        2
    load     u64   .fmt 
    setarg   u64   2
    loadref  u64   msys.strint.str 
    setarg   u64   1
    callf    u64   msys.getstr 2 0
    setret   u64   
    jump           #8299 
;------------------------
#8299:
    return         
end

proc msys.getstrint
    param    i64   .a 
    param    u64   .dest 
;------------------------
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callp          msys.m$print_startstr 1 0
    setcall        2
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   msys.getfmt 1 0
    setarg   u64   2
    load     i64   .a 
    setarg   i64   1
    callp          msys.tostr_i64 2 0
    setcall        0
    callp          msys.m$print_end 0 0
;------------------------
#8300:
    return         
end

proc msys.strword
    rettype  u64   
    param    u64   .a 
    param    u64   .fmtstyle 
    local    u64   .fmt 
;------------------------
    setcall        1
    loadref  u64   msys.strword.str 
    setarg   u64   1
    callp          msys.m$print_startstr 1 0
    setcall        2
    setcall        1
    load     u64   .fmtstyle 
    setarg   u64   1
    callf    u64   msys.getfmt 1 0
    double         
    store    u64   .fmt 
    setarg   u64   2
    load     u64   .a 
    setarg   u64   1
    callp          msys.tostr_u64 2 0
    setcall        0
    callp          msys.m$print_end 0 0
    setcall        2
    load     u64   .fmt 
    setarg   u64   2
    loadref  u64   msys.strword.str 
    setarg   u64   1
    callf    u64   msys.getstr 2 0
    setret   u64   
    jump           #8301 
;------------------------
#8301:
    return         
end

proc msys.strreal
    rettype  u64   
    param    r64   .a 
    param    u64   .fmtstyle 
    local    u64   .fmt 
;------------------------
    setcall        1
    loadref  u64   msys.strreal.str 
    setarg   u64   1
    callp          msys.m$print_startstr 1 0
    setcall        2
    setcall        1
    load     u64   .fmtstyle 
    setarg   u64   1
    callf    u64   msys.getfmt 1 0
    double         
    store    u64   .fmt 
    setarg   u64   2
    load     r64   .a 
    setarg   r64   1
    callp          msys.tostr_r64 2 0
    setcall        0
    callp          msys.m$print_end 0 0
    setcall        2
    load     u64   .fmt 
    setarg   u64   2
    loadref  u64   msys.strreal.str 
    setarg   u64   1
    callf    u64   msys.getstr 2 0
    setret   u64   
    jump           #8302 
;------------------------
#8302:
    return         
end

proc msys.getstr
    rettype  u64   
    param    u64   .s 
    param    u64   .fmt 
;------------------------
    startmx        
    load     u64   .fmt 
    loadimm  i64   13 
    iloadx   u8    1 0
    jumpf    u64   #8305 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    resetmx        
    jump           #8304 
#8305:
    load     u64   .s 
    endmx          
#8304:
    setret   u64   
    jump           #8303 
;------------------------
#8303:
    return         
end

proc msys.initreadbuffer
;------------------------
    load     u64   msys.rd_buffer 
    jumpf    u64   #8308 
    jump           #8306 
#8308:
#8307:
    setcall        1
    loadimm  i64   16384 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   msys.rd_buffer 
    loadimm  u64   0 
    load     u64   msys.rd_buffer 
    istore   u8    
    load     u64   msys.rd_buffer 
    double         
    store    u64   msys.rd_lastpos 
    store    u64   msys.rd_pos 
;------------------------
#8306:
    return         
end

proc msys.m$read_conline
;------------------------
    setcall        0
    callp          msys.initreadbuffer 0 0
    setcall        3
    loadimm  i64   16384 
    setarg   i64   3
    load     u64   msys.rd_buffer 
    setarg   u64   2
    loadimm  u64   0 
    setarg   u64   1
    callp          mlib.readlinen 3 0
    setcall        1
    load     u64   msys.rd_buffer 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   msys.rd_length 
    load     u64   msys.rd_buffer 
    store    u64   msys.rd_pos 
    loadimm  u64   0 
    store    u64   msys.rd_lastpos 
;------------------------
#8309:
    return         
end

proc msys.m$read_fileline
    param    u64   .f 
    local    u64   .p 
;------------------------
    setcall        0
    callp          msys.initreadbuffer 0 0
    load     u64   .f 
    loadimm  u64   1 
    jumpne   u64   #8312 
    setcall        1
    loadimm  u64   "READ CMDLINE"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
    jump           #8310 
#8312:
#8311:
    setcall        3
    loadimm  i64   16384 
    setarg   i64   3
    load     u64   msys.rd_buffer 
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callp          mlib.readlinen 3 0
    setcall        1
    load     u64   msys.rd_buffer 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   msys.rd_length 
    load     u64   msys.rd_buffer 
    store    u64   msys.rd_pos 
    loadimm  u64   0 
    store    u64   msys.rd_lastpos 
;------------------------
#8310:
    return         
end

proc msys.m$read_strline
    param    u64   .s 
    local    i64   .n 
;------------------------
    setcall        0
    callp          msys.initreadbuffer 0 0
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .n 
    load     i64   .n 
    loadimm  i64   16384 
    jumpge   i64   #8316 
    setcall        2
    load     u64   .s 
    setarg   u64   2
    load     u64   msys.rd_buffer 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #8315 
#8316:
    setcall        3
    loadimm  u64   16383 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   msys.rd_buffer 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   msys.rd_buffer 
    loadimm  i64   16384 
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    istore   u8    
#8315:
    load     i64   .n 
    store    i64   msys.rd_length 
    load     u64   msys.rd_buffer 
    store    u64   msys.rd_pos 
    loadimm  u64   0 
    store    u64   msys.rd_lastpos 
;------------------------
#8314:
    return         
end

proc msys.readitem
    rettype  u64   
    param    u64   .itemlength 
    local    u64   .p 
    local    u64   .s 
    local    u64   .itemstr 
    local    u8    .quotechar 
    local    u8    .c 
;------------------------
    load     u64   msys.rd_buffer 
    jumpt    u64   #8319 
    setcall        0
    callp          msys.initreadbuffer 0 0
#8319:
#8318:
    load     u64   msys.rd_pos 
    store    u64   .s 
    jump           #8321 
#8320:
    loadref  u64   .s 
    incrto   u64   1
#8321:
    load     u64   .s 
    iload    u8    
    loadimm  u64   32 
    jumpeq   u64   #8320 
    load     u64   .s 
    iload    u8    
    loadimm  i64   9 
    jumpeq   i64   #8320 
#8322:
    load     u64   .s 
    store    u64   .itemstr 
    load     u64   .s 
    double         
    store    u64   msys.rd_pos 
    store    u64   msys.rd_lastpos 
    load     u64   .s 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8324 
    loadimm  i64   0 
    store    i64   msys.termchar 
    loadimm  i64   0 
    load     u64   .itemlength 
    istore   i64   
    load     u64   .s 
    setret   u64   
    jump           #8317 
#8324:
#8323:
    loadimm  u64   0 
    store    u8    .quotechar 
    load     u64   .s 
    iload    u8    
    loadimm  u64   34 
    jumpne   u64   #8326 
    loadimm  u64   34 
    store    u8    .quotechar 
    loadref  u64   .s 
    incrto   u64   1
    jump           #8325 
#8326:
    load     u64   .s 
    iload    u8    
    loadimm  u64   39 
    jumpne   u64   #8327 
    loadimm  u64   39 
    store    u8    .quotechar 
    loadref  u64   .s 
    incrto   u64   1
#8327:
#8325:
    load     u64   .s 
    double         
    store    u64   .itemstr 
    store    u64   .p 
    jump           #8329 
#8328:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    store    u8    .c 
    load     u8    .c 
    switch         #8332 9 61
    opnd           #8333 
#8332:
    swlabel        #8334 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8334 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8334 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8333 
    swlabel        #8334 
    endsw          
#8334:
    load     u8    .quotechar 
    jumpt    u64   #8337 
    load     u64   .p 
    load     u64   .s 
    jumpne   u64   #8336 
#8337:
    jump           #8338 
#8336:
#8335:
    load     u8    .c 
    store    i64   msys.termchar 
    jump           #8330 
    jump           #8331 
#8333:
;normalchar::
#8338:
    load     u8    .c 
    load     u8    .quotechar 
    jumpne   u64   #8340 
    load     u64   .s 
    iload    u8    
    load     u8    .quotechar 
    jumpne   u64   #8342 
    load     u8    .c 
    load     u64   .p 
    istore   u8    
    loadref  u64   .s 
    incrto   u64   1
    loadref  u64   .p 
    incrto   u64   1
    jump           #8341 
#8342:
    load     u64   .s 
    iload    u8    
    store    i64   msys.termchar 
    load     i64   msys.termchar 
    loadimm  i64   44 
    jumpeq   i64   #8345 
    load     i64   msys.termchar 
    loadimm  i64   61 
    jumpne   i64   #8344 
#8345:
    loadref  u64   .s 
    incrto   u64   1
    load     u64   .s 
    iload    u8    
    store    i64   msys.termchar 
#8344:
#8343:
    jump           #8330 
#8341:
    jump           #8339 
#8340:
    load     u8    .c 
    load     u64   .p 
    istore   u8    
    loadref  u64   .p 
    incrto   u64   1
#8339:
#8331:
#8329:
    load     u64   .s 
    iload    u8    
    jumpt    u64   #8328 
#8330:
    load     u64   .s 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8347 
    loadimm  i64   0 
    store    i64   msys.termchar 
#8347:
#8346:
    load     u64   .p 
    load     u64   .itemstr 
    subptr   u64   1
    load     u64   .itemlength 
    istore   i64   
    load     u64   .s 
    store    u64   msys.rd_pos 
    load     u64   .itemstr 
    setret   u64   
    jump           #8317 
;------------------------
#8317:
    return         
end

proc msys.strtoint
    rettype  i64   
    param    u64   .s 
    param    i64   .length 
    param    u64   .base 
    local    u8    .signd 
    local    u64   .aa 
    local    u64   .c 
    local    u64   .d 
;------------------------
    loadimm  i64   0 
    store    i64   msys.itemerror 
    load     i64   .length 
    loadimm  i64   -1 
    jumpne   i64   #8350 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .length 
#8350:
#8349:
    loadimm  i64   0 
    store    u8    .signd 
    load     i64   .length 
    jumpf    i64   #8352 
    load     u64   .s 
    iload    u8    
    loadimm  u64   45 
    jumpne   u64   #8352 
    loadimm  i64   1 
    store    u8    .signd 
    loadref  u64   .s 
    incrto   u64   1
    loadref  u64   .length 
    decrto   i64   1
    jump           #8351 
#8352:
    load     i64   .length 
    jumpf    i64   #8353 
    load     u64   .s 
    iload    u8    
    loadimm  u64   43 
    jumpne   u64   #8353 
    loadref  u64   .s 
    incrto   u64   1
    loadref  u64   .length 
    decrto   i64   1
#8353:
#8351:
    loadimm  u64   0 
    store    u64   .aa 
    jump           #8355 
#8354:
    loadref  u64   .s 
    loadincr u64   1
    iload    u8    
    store    u64   .c 
    loadref  u64   .length 
    decrto   i64   1
    load     u64   .c 
    switch         #8358 39 102
    opnd           #8359 
#8358:
    swlabel        #8363 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8362 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8360 
    swlabel        #8360 
    swlabel        #8360 
    swlabel        #8360 
    swlabel        #8360 
    swlabel        #8360 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8359 
    swlabel        #8363 
    swlabel        #8359 
    swlabel        #8361 
    swlabel        #8361 
    swlabel        #8361 
    swlabel        #8361 
    swlabel        #8361 
    swlabel        #8361 
    endsw          
#8360:
    load     u64   .c 
    loadimm  u64   65 
    sub      u64   
    loadimm  i64   10 
    add      i64   
    store    u64   .d 
    jump           #8357 
#8361:
    load     u64   .c 
    loadimm  u64   97 
    sub      u64   
    loadimm  i64   10 
    add      i64   
    store    u64   .d 
    jump           #8357 
#8362:
    load     u64   .c 
    loadimm  u64   48 
    sub      u64   
    store    u64   .d 
    jump           #8357 
#8363:
    jump           #8355 
    jump           #8357 
#8359:
    loadimm  i64   1 
    store    i64   msys.itemerror 
    jump           #8356 
#8357:
    load     u64   .d 
    load     u64   .base 
    jumplt   u64   #8365 
    loadimm  i64   1 
    store    i64   msys.itemerror 
    jump           #8356 
#8365:
#8364:
    load     u64   .aa 
    load     u64   .base 
    mul      u64   
    load     u64   .d 
    add      u64   
    store    u64   .aa 
#8355:
    load     i64   .length 
    jumpt    i64   #8354 
#8356:
    startmx        
    load     u8    .signd 
    jumpf    i64   #8367 
    load     u64   .aa 
    neg      u64   
    resetmx        
    jump           #8366 
#8367:
    load     u64   .aa 
    endmx          
#8366:
    setret   i64   
    jump           #8348 
;------------------------
#8348:
    return         
end

proc msys.m$read_i64
    rettype  i64   
    param    i64   .fmt 
    local    u64   .s 
    local    i64   .length 
    local    i64   .c 
    local    i64   .aa 
;------------------------
    load     i64   .fmt 
    loadimm  i64   67 
    jumpeq   i64   #8370 1
    loadimm  i64   99 
    jumpeq   i64   #8370 1
    loadimm  i64   84 
    jumpeq   i64   #8371 1
    loadimm  i64   116 
    jumpeq   i64   #8371 1
    loadimm  i64   69 
    jumpeq   i64   #8372 1
    loadimm  i64   101 
    jumpeq   i64   #8372 
    jump           #8373 
#8370:
    load     u64   msys.rd_pos 
    store    u64   msys.rd_lastpos 
    load     u64   msys.rd_pos 
    iload    u8    
    jumpf    u64   #8375 
    loadref  u64   msys.rd_pos 
    loadincr u64   1
    iload    u8    
    setret   i64   
    jump           #8368 
    jump           #8374 
#8375:
    loadimm  i64   0 
    setret   i64   
    jump           #8368 
#8374:
    jump           #8369 
#8371:
    load     i64   msys.termchar 
    setret   i64   
    jump           #8368 
    jump           #8369 
#8372:
    load     i64   msys.itemerror 
    setret   i64   
    jump           #8368 
    jump           #8369 
#8373:
#8369:
    setcall        1
    loadref  u64   .length 
    setarg   u64   1
    callf    u64   msys.readitem 1 0
    store    u64   .s 
    load     i64   .fmt 
    loadimm  i64   0 
    jumpeq   i64   #8377 1
    loadimm  i64   73 
    jumpeq   i64   #8377 1
    loadimm  i64   105 
    jumpeq   i64   #8377 1
    loadimm  i64   66 
    jumpeq   i64   #8378 1
    loadimm  i64   98 
    jumpeq   i64   #8378 1
    loadimm  i64   72 
    jumpeq   i64   #8379 1
    loadimm  i64   104 
    jumpeq   i64   #8379 
    jump           #8380 
#8377:
    setcall        3
    loadimm  u64   10 
    setarg   u64   3
    load     i64   .length 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    i64   msys.strtoint 3 0
    setret   i64   
    jump           #8368 
    jump           #8376 
#8378:
    setcall        3
    loadimm  u64   2 
    setarg   u64   3
    load     i64   .length 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    i64   msys.strtoint 3 0
    setret   i64   
    jump           #8368 
    jump           #8376 
#8379:
    setcall        3
    loadimm  u64   16 
    setarg   u64   3
    load     i64   .length 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    i64   msys.strtoint 3 0
    setret   i64   
    jump           #8368 
    jump           #8376 
#8380:
#8376:
    loadimm  i64   0 
    setret   i64   
    jump           #8368 
;------------------------
#8368:
    return         
end

proc msys.m$read_r64
    rettype  r64   
    param    i64   .fmt 
    local    u8:512 .str 
    local    u64   .s 
    local    i64   .length 
    local    i32   .numlength 
    local    r64   .x 
;------------------------
    setcall        1
    loadref  u64   .length 
    setarg   u64   1
    callf    u64   msys.readitem 1 0
    store    u64   .s 
    load     i64   .length 
    loadimm  i64   0 
    jumpeq   i64   #8384 
    load     i64   .length 
    loadimm  i64   512 
    jumplt   i64   #8383 
#8384:
    loadimm  r64   0.00000000000000000000 
    setret   r64   
    jump           #8381 
#8383:
#8382:
    setcall        3
    load     i64   .length 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    loadref  u64   .str 
    load     i64   .length 
    istorex  u8    1 0
    loadimm  i64   0 
    store    i64   msys.itemerror 
    setcall        4
    loadref  u64   .numlength 
    setarg   u64   4
    loadref  u64   .x 
    setarg   u64   3
    loadimm  u64   "%lf%n"
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    i32   sscanf 4 3
    widen    i32   
    loadimm  i64   0 
    jumpeq   i64   #8387 
    load     i32   .numlength 
    load     i64   .length 
    jumpeq   i64   #8386 
#8387:
    loadimm  r64   0.00000000000000000000 
    store    r64   .x 
    loadimm  i64   1 
    store    i64   msys.itemerror 
#8386:
#8385:
    load     r64   .x 
    setret   r64   
    jump           #8381 
;------------------------
#8381:
    return         
end

proc msys.m$read_str
    param    u64   .dest 
    param    i64   .destlen 
    param    i64   .fmt 
    local    u64   .s 
    local    i64   .length 
    local    i64   .numlength 
    local    r64   .x 
;------------------------
    loadimm  i64   0 
    store    i64   msys.itemerror 
    load     i64   .fmt 
    loadimm  i64   76 
    jumpeq   i64   #8392 
    load     i64   .fmt 
    loadimm  i64   108 
    jumpne   i64   #8391 
#8392:
    load     u64   msys.rd_pos 
    store    u64   .s 
    load     u64   msys.rd_buffer 
    load     i64   msys.rd_length 
    addptrx  u64   1 0
    load     u64   msys.rd_pos 
    subptr   u64   1
    store    i64   .length 
    jump           #8390 
#8391:
    setcall        1
    loadref  u64   .length 
    setarg   u64   1
    callf    u64   msys.readitem 1 0
    store    u64   .s 
    load     i64   .fmt 
    loadimm  i64   78 
    jumpeq   i64   #8395 
    load     i64   .fmt 
    loadimm  i64   110 
    jumpne   i64   #8394 
#8395:
    setcall        2
    load     i64   .length 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callp          mlib.iconvlcn 2 0
#8394:
#8393:
#8390:
    load     i64   .destlen 
    loadimm  i64   0 
    jumple   i64   #8397 
    load     i64   .length 
    load     i64   .destlen 
    jumplt   i64   #8399 
    load     i64   .destlen 
    loadimm  i64   1 
    sub      i64   
    store    i64   .length 
    loadimm  i64   1 
    store    i64   msys.itemerror 
#8399:
#8398:
#8397:
#8396:
    setcall        3
    load     i64   .length 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   .dest 
    load     i64   .length 
    addptrx  u64   1 0
    istore   u8    
;------------------------
#8389:
    return         
end

proc msys.readstr
    param    u64   .dest 
    param    i64   .fmt 
    param    i64   .destlen 
;------------------------
    setcall        3
    load     i64   .fmt 
    setarg   i64   3
    load     i64   .destlen 
    setarg   i64   2
    load     u64   .dest 
    setarg   u64   1
    callp          msys.m$read_str 3 0
;------------------------
#8400:
    return         
end

proc msys.rereadln
;------------------------
    load     u64   msys.rd_buffer 
    store    u64   msys.rd_pos 
    load     u64   msys.rd_pos 
    store    u64   msys.rd_lastpos 
;------------------------
#8401:
    return         
end

proc msys.reread
;------------------------
    load     u64   msys.rd_lastpos 
    store    u64   msys.rd_pos 
;------------------------
#8402:
    return         
end

proc msys.valint
    rettype  i64   
    param    u64   .s 
    param    i64   .fmt 
    local    u64   .old_pos 
    local    u64   .old_lastpos 
    local    i64   .aa 
;------------------------
    setcall        0
    callp          msys.initreadbuffer 0 0
    load     u64   msys.rd_pos 
    store    u64   .old_pos 
    load     u64   msys.rd_lastpos 
    store    u64   .old_lastpos 
    load     u64   .s 
    store    u64   msys.rd_pos 
    setcall        1
    load     i64   .fmt 
    setarg   i64   1
    callf    i64   msys.m$read_i64 1 0
    store    i64   .aa 
    load     u64   .old_pos 
    store    u64   msys.rd_pos 
    load     u64   .old_lastpos 
    store    u64   msys.rd_lastpos 
    load     i64   .aa 
    setret   i64   
    jump           #8403 
;------------------------
#8403:
    return         
end

proc msys.valreal
    rettype  r64   
    param    u64   .s 
    local    u64   .old_pos 
    local    u64   .old_lastpos 
    local    r64   .x 
;------------------------
    setcall        0
    callp          msys.initreadbuffer 0 0
    load     u64   msys.rd_pos 
    store    u64   .old_pos 
    load     u64   msys.rd_lastpos 
    store    u64   .old_lastpos 
    load     u64   .s 
    store    u64   msys.rd_pos 
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    r64   msys.m$read_r64 1 0
    store    r64   .x 
    load     u64   .old_pos 
    store    u64   msys.rd_pos 
    load     u64   .old_lastpos 
    store    u64   msys.rd_lastpos 
    load     r64   .x 
    setret   r64   
    jump           #8404 
;------------------------
#8404:
    return         
end

proc msys.mclunimpl
    param    u64   .mess 
;------------------------
    setcall        2
    load     u64   .mess 
    setarg   u64   2
    loadimm  u64   "MCL-UNIMPL: %s\n"
    setarg   u64   1
    callp          printf 2 2
    stop           1
;------------------------
#8405:
    return         
end

proc msys.dumpstr
    param    u64   .s 
    param    i64   .n 
    param    i64   .fbuffer 
    local    u64   .p 
;------------------------
    load     i64   .n 
    loadimm  i64   0 
    jumpne   i64   #8409 
    jump           #8407 
#8409:
#8408:
    load     i64   msys.outdev 
    loadimm  i64   3 
    jumpne   i64   #8411 
    load     u64   msys.outchan 
    store    u64   .p 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .p 
    iload    u64   
    setarg   u64   1
    callp          memcpy 3 0
    load     u64   .p 
    load     i64   .n 
    addpxto  u64   1 0
    loadimm  u64   0 
    load     u64   .p 
    iload    u64   
    istore   u8    
    jump           #8407 
#8411:
#8410:
    load     i64   .fbuffer 
    jumpf    i64   #8413 
    load     i64   .n 
    loadimm  i64   2 
    jumplt   i64   #8413 
    load     i64   msys.outdev 
    loadimm  i64   1 
    jumpne   i64   #8413 
    loadref  u64   msys.printptr 
    decrto   u64   1
    load     u64   msys.printptr 
    iload    u8    
    loadimm  i64   10 
    jumpne   i64   #8415 
    load     u64   msys.printptr 
    loadimm  i64   1 
    subptrx  u64   1 0
    iload    u8    
    loadimm  i64   13 
    jumpne   i64   #8417 
    loadimm  u64   0 
    load     u64   msys.printptr 
    loadimm  i64   1 
    subptrx  u64   1 0
    istore   u8    
    jump           #8416 
#8417:
    loadimm  u64   0 
    load     u64   msys.printptr 
    istore   u8    
#8416:
    setcall        1
    loadref  u64   msys.printbuffer 
    setarg   u64   1
    callf    i32   puts 1 0
    unload   i32   
    jump           #8407 
#8415:
#8414:
#8413:
#8412:
    load     i64   msys.outdev 
    loadimm  i64   1 
    jumpeq   i64   #8419 1
    loadimm  i64   2 
    jumpeq   i64   #8420 
    jump           #8421 
#8419:
    setcall        3
    load     u64   .s 
    setarg   u64   3
    load     i64   .n 
    setarg   i64   2
    loadimm  u64   "%.*s"
    setarg   u64   1
    callp          printf 3 2
    jump           #8418 
#8420:
    setcall        4
    load     u64   .s 
    setarg   u64   4
    load     i64   .n 
    setarg   i64   3
    loadimm  u64   "%.*s"
    setarg   u64   2
    load     u64   msys.outchan 
    setarg   u64   1
    callp          fprintf 4 3
    jump           #8418 
#8421:
#8418:
;------------------------
#8407:
    return         
end

proc msys.dumpprintbuffer
;------------------------
    load     i64   msys.printlen 
    jumpf    i64   #8425 
    setcall        3
    loadimm  i64   1 
    setarg   i64   3
    load     i64   msys.printlen 
    setarg   i64   2
    loadref  u64   msys.printbuffer 
    setarg   u64   1
    callp          msys.dumpstr 3 0
#8425:
#8424:
    setcall        0
    callp          msys.resetprintbuffer 0 0
;------------------------
#8423:
    return         
end

proc msys.resetprintbuffer
;------------------------
    loadref  u64   msys.printbuffer 
    store    u64   msys.printptr 
    loadimm  i64   0 
    store    i64   msys.printlen 
;------------------------
#8426:
    return         
end

proc msys.addtobuffer
    param    u64   .s 
    param    i64   .n 
;------------------------
    load     i64   msys.printlen 
    load     i64   .n 
    add      i64   
    loadimm  i64   4088 
    jumplt   i64   #8429 
    setcall        0
    callp          msys.dumpprintbuffer 0 0
#8429:
#8428:
    load     i64   .n 
    loadimm  i64   4096 
    jumpge   i64   #8431 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   msys.printptr 
    setarg   u64   1
    callp          memcpy 3 0
    loadref  u64   msys.printptr 
    load     i64   .n 
    addpxto  u64   1 0
    loadref  u64   msys.printlen 
    load     i64   .n 
    addto    i64   
    jump           #8427 
#8431:
#8430:
    setcall        3
    loadimm  i64   0 
    setarg   i64   3
    load     i64   .n 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callp          msys.dumpstr 3 0
;------------------------
#8427:
    return         
end

proc msys.m$power_i64
    rettype  i64   
    param    i64   .a 
    param    i64   .n 
;------------------------
    startmx        
    load     i64   .n 
    loadimm  i64   0 
    jumpge   i64   #8434 
    loadimm  i64   0 
    resetmx        
    jump           #8433 
#8434:
    load     i64   .n 
    loadimm  i64   0 
    jumpne   i64   #8435 
    loadimm  i64   1 
    resetmx        
    jump           #8433 
#8435:
    load     i64   .n 
    loadimm  i64   1 
    jumpne   i64   #8436 
    load     i64   .a 
    resetmx        
    jump           #8433 
#8436:
    load     i64   .n 
    loadimm  i64   1 
    bitand   i64   
    loadimm  i64   0 
    jumpne   i64   #8437 
    setcall        2
    load     i64   .n 
    loadimm  i64   2 
    div      i64   
    setarg   i64   2
    load     i64   .a 
    sqr      i64   
    setarg   i64   1
    callf    i64   msys.m$power_i64 2 0
    resetmx        
    jump           #8433 
#8437:
    setcall        2
    load     i64   .n 
    loadimm  i64   1 
    sub      i64   
    loadimm  i64   2 
    div      i64   
    setarg   i64   2
    load     i64   .a 
    sqr      i64   
    setarg   i64   1
    callf    i64   msys.m$power_i64 2 0
    load     i64   .a 
    mul      i64   
    endmx          
#8433:
    setret   i64   
    jump           #8432 
;------------------------
#8432:
    return         
end

proc mlib.pcm_alloc
    rettype  u64   
    param    i64   .n 
    local    u64   .p 
;------------------------
    load     u8    mlib.pcm_setup 
    jumpt    i64   #8440 
    setcall        0
    callp          mlib.pcm_init 0 0
#8440:
#8439:
    load     i64   .n 
    loadimm  i64   2048 
    jumple   i64   #8442 
    setcall        1
    load     i64   .n 
    setarg   i64   1
    callf    i64   mlib.pcm_getac 1 0
    store    i64   mlib.alloccode 
    loadref  u64   mlib.allocupper 
    load     i64   mlib.alloccode 
    iloadx   i64   8 0
    store    i64   mlib.allocbytes 
    setcall        1
    load     i64   mlib.allocbytes 
    setarg   i64   1
    callf    u64   mlib.allocmem 1 0
    store    u64   .p 
    load     u64   .p 
    jumpt    u64   #8444 
    setcall        1
    loadimm  u64   "pcm_alloc failure"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
#8444:
#8443:
    load     u64   .p 
    setret   u64   
    jump           #8438 
#8442:
#8441:
    loadref  u64   mlib.sizeindextable 
    load     i64   .n 
    iloadx   u8    1 0
    store    i64   mlib.alloccode 
    loadref  u64   mlib.allocupper 
    load     i64   mlib.alloccode 
    iloadx   i64   8 0
    store    i64   mlib.allocbytes 
    loadref  u64   mlib.smallmemtotal 
    load     i64   mlib.allocbytes 
    addto    i64   
    loadref  u64   mlib.freelist 
    load     i64   mlib.alloccode 
    iloadx   u64   8 0
    double         
    store    u64   .p 
    jumpf    u64   #8447 
    loadref  u64   mlib.freelist 
    load     i64   mlib.alloccode 
    iloadx   u64   8 0
    iload    u64   
    loadref  u64   mlib.freelist 
    load     i64   mlib.alloccode 
    istorex  u64   8 0
    load     u64   .p 
    setret   u64   
    jump           #8438 
#8447:
#8446:
    load     u64   mlib.pcheapptr 
    store    u64   .p 
    loadref  u64   mlib.pcheapptr 
    load     i64   mlib.allocbytes 
    addpxto  u64   1 0
    load     u64   mlib.pcheapptr 
    load     u64   mlib.pcheapend 
    jumplt   u64   #8449 
    setcall        1
    load     i64   mlib.allocbytes 
    setarg   i64   1
    callf    u64   mlib.pcm_newblock 1 0
    store    u64   .p 
    load     u64   .p 
    setret   u64   
    jump           #8438 
#8449:
#8448:
    load     u64   .p 
    setret   u64   
    jump           #8438 
;------------------------
#8438:
    return         
end

proc mlib.pcm_free
    param    u64   .p 
    param    i64   .n 
    local    i64   .acode 
;------------------------
    load     i64   .n 
    loadimm  i64   0 
    jumpne   i64   #8452 
    jump           #8450 
#8452:
#8451:
    load     i64   .n 
    loadimm  i64   2048 
    jumple   i64   #8454 
    loadref  u64   mlib.memtotal 
    load     i64   .n 
    subto    i64   
    setcall        1
    load     u64   .p 
    setarg   u64   1
    callp          free 1 0
    jump           #8450 
#8454:
#8453:
    load     u64   .p 
    jumpf    u64   #8456 
    loadref  u64   mlib.sizeindextable 
    load     i64   .n 
    iloadx   u8    1 0
    store    i64   .acode 
    loadref  u64   mlib.smallmemtotal 
    loadref  u64   mlib.allocupper 
    load     i64   .acode 
    iloadx   i64   8 0
    subto    i64   
    loadref  u64   mlib.freelist 
    load     i64   .acode 
    iloadx   u64   8 0
    load     u64   .p 
    istore   u64   
    load     u64   .p 
    loadref  u64   mlib.freelist 
    load     i64   .acode 
    istorex  u64   8 0
#8456:
#8455:
;------------------------
#8450:
    return         
end

proc mlib.pcm_freeac
    param    u64   .p 
    param    i64   .alloc 
;------------------------
    setcall        2
    loadref  u64   mlib.allocupper 
    load     i64   .alloc 
    iloadx   i64   8 0
    setarg   i64   2
    load     u64   .p 
    setarg   u64   1
    callp          mlib.pcm_free 2 0
;------------------------
#8457:
    return         
end

proc mlib.pcm_clearmem
    param    u64   .p 
    param    i64   .n 
;------------------------
    setcall        3
    load     i64   .n 
    setarg   u64   3
    loadimm  i64   0 
    setarg   i32   2
    load     u64   .p 
    setarg   u64   1
    callp          memset 3 0
;------------------------
#8458:
    return         
end

proc mlib.pcm_init
    local    i64   .j 
    local    i64   .k 
    local    i64   .k1 
    local    i64   .k2 
    local    i64   .size 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    loadimm  i64   0 
    store    i64   mlib.alloccode 
    load     u8    mlib.pcm_setup 
    jumpf    i64   #8461 
    jump           #8459 
#8461:
#8460:
    setcall        1
    loadimm  i64   0 
    setarg   i64   1
    callf    u64   mlib.pcm_newblock 1 0
    unload   u64   
    loadimm  i64   1 
    store    i64   .i 
#8462:
    loadimm  i64   1 
    store    i64   .j 
    loadimm  i64   16 
    store    i64   .k 
    jump           #8466 
#8465:
    load     i64   .k 
    loadimm  i64   1 
    shl      i64   
    store    i64   .k 
    loadref  u64   .j 
    incrto   i64   1
#8466:
    load     i64   .i 
    load     i64   .k 
    jumpgt   i64   #8465 
#8467:
    load     i64   .j 
    loadref  u64   mlib.sizeindextable 
    load     i64   .i 
    istorex  u8    1 0
#8463:
    forup          #8462 1
    opnd           .i 
    opnd           2048 
#8464:
    loadimm  u64   16 
    loadref  u64   mlib.allocupper 
    loadimm  i64   1 
    istorex  u64   8 0
    loadimm  i64   16 
    store    i64   .size 
    loadimm  i64   2 
    store    i64   .i 
#8468:
    loadref  u64   .size 
    loadimm  i64   2 
    multo    i64   
    load     i64   .size 
    loadref  u64   mlib.allocupper 
    load     i64   .i 
    istorex  u64   8 0
    load     i64   .size 
    loadimm  i64   33554432 
    jumplt   i64   #8472 
    load     i64   .i 
    store    i64   .k 
    jump           #8470 
#8472:
#8471:
#8469:
    forup          #8468 1
    opnd           .i 
    opnd           27 
#8470:
    load     i64   .k 
    loadimm  i64   1 
    add      i64   
    store    i64   .i 
    load     i64   .i 
    loadimm  i64   300 
    jumpgt   i64   #8475 
#8473:
    loadref  u64   .size 
    loadimm  i64   33554432 
    addto    i64   
    load     i64   .size 
    loadimm  i64   8589934592 
    jumpge   i64   #8477 
    load     i64   .size 
    loadref  u64   mlib.allocupper 
    load     i64   .i 
    istorex  u64   8 0
    load     i64   .size 
    store    u64   mlib.maxmemory 
    jump           #8476 
#8477:
    load     i64   .i 
    loadimm  i64   1 
    sub      i64   
    store    i64   mlib.maxalloccode 
    jump           #8475 
#8476:
#8474:
    forup          #8473 1
    opnd           .i 
    opnd           300 
#8475:
    loadimm  i64   1 
    store    u8    mlib.pcm_setup 
;------------------------
#8459:
    return         
end

proc mlib.pcm_getac
    rettype  i64   
    param    i64   .size 
;------------------------
    load     i64   .size 
    loadimm  i64   2048 
    jumpgt   i64   #8480 
    loadref  u64   mlib.sizeindextable 
    load     i64   .size 
    iloadx   u8    1 0
    setret   i64   
    jump           #8478 
#8480:
#8479:
    load     i64   .size 
    loadimm  i64   255 
    add      i64   
    loadimm  i64   8 
    shr      i64   
    store    i64   .size 
    load     i64   .size 
    loadimm  i64   2048 
    jumpgt   i64   #8482 
    loadref  u64   mlib.sizeindextable 
    load     i64   .size 
    iloadx   u8    1 0
    loadimm  i64   8 
    add      i64   
    setret   i64   
    jump           #8478 
#8482:
#8481:
    load     i64   .size 
    loadimm  i64   63 
    add      i64   
    loadimm  i64   6 
    shr      i64   
    store    i64   .size 
    load     i64   .size 
    loadimm  i64   2048 
    jumpgt   i64   #8484 
    loadref  u64   mlib.sizeindextable 
    load     i64   .size 
    iloadx   u8    1 0
    loadimm  i64   14 
    add      i64   
    setret   i64   
    jump           #8478 
#8484:
#8483:
    load     i64   .size 
    loadimm  i64   2048 
    sub      i64   
    loadimm  i64   2047 
    add      i64   
    loadimm  i64   2048 
    div      i64   
    loadimm  i64   22 
    add      i64   
    store    i64   .size 
    load     i64   .size 
    setret   i64   
    jump           #8478 
;------------------------
#8478:
    return         
end

proc mlib.pcm_newblock
    rettype  u64   
    param    i64   .itemsize 
    local    u64   .p 
;------------------------
    loadref  u64   mlib.pcm_newblock.totalheapsize 
    loadimm  i64   2097152 
    addto    i64   
    loadimm  i64   0 
    store    i64   mlib.alloccode 
    setcall        1
    loadimm  i64   2097152 
    setarg   i64   1
    callf    u64   mlib.allocmem 1 0
    store    u64   .p 
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #8487 
    setcall        1
    loadimm  u64   "Can't alloc pc heap"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
#8487:
#8486:
    load     u64   .p 
    store    u64   mlib.pcheapptr 
    load     u64   .p 
    loadimm  i64   2097152 
    addptrx  u64   1 0
    store    u64   mlib.pcheapend 
    load     u64   mlib.pcheapstart 
    loadimm  u64   0 
    jumpne   u64   #8490 
    load     u64   .p 
    store    u64   mlib.pcheapstart 
#8490:
#8489:
    loadref  u64   mlib.pcheapptr 
    load     i64   .itemsize 
    addpxto  u64   1 0
    load     u64   .p 
    setret   u64   
    jump           #8485 
;------------------------
#8485:
    return         
end

proc mlib.pcm_round
    rettype  i64   
    param    i64   .n 
;------------------------
    startmx        
    load     i64   .n 
    loadimm  i64   2048 
    jumple   i64   #8493 
    load     i64   .n 
    resetmx        
    jump           #8492 
#8493:
    loadref  u64   mlib.pcm_round.allocbytes 
    loadref  u64   mlib.sizeindextable 
    load     i64   .n 
    iloadx   u8    1 0
    iloadx   i32   4 0
    endmx          
#8492:
    setret   i64   
    jump           #8491 
;------------------------
#8491:
    return         
end

proc mlib.pcm_allocz
    rettype  u64   
    param    i64   .n 
    local    u64   .p 
;------------------------
    setcall        1
    load     i64   .n 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .p 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    loadimm  i64   0 
    setarg   i32   2
    load     u64   .p 
    setarg   u64   1
    callp          memset 3 0
    load     u64   .p 
    setret   u64   
    jump           #8494 
;------------------------
#8494:
    return         
end

proc mlib.pcm_copyheapstring
    rettype  u64   
    param    u64   .s 
    local    u64   .q 
    local    i64   .n 
;------------------------
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #8497 
    loadimm  u64   0 
    setret   u64   
    jump           #8495 
#8497:
#8496:
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    loadimm  i64   1 
    add      i64   
    store    i64   .n 
    setcall        1
    load     i64   .n 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .q 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .q 
    setarg   u64   1
    callp          memcpy 3 0
    load     u64   .q 
    setret   u64   
    jump           #8495 
;------------------------
#8495:
    return         
end

proc mlib.pcm_copyheapstringn
    rettype  u64   
    param    u64   .s 
    param    i64   .n 
    local    u64   .q 
;------------------------
    load     u64   .s 
    loadimm  u64   0 
    jumpne   u64   #8500 
    loadimm  u64   0 
    setret   u64   
    jump           #8498 
#8500:
#8499:
    setcall        1
    load     i64   .n 
    loadimm  i64   1 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .q 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .q 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   .q 
    load     i64   .n 
    addptrx  u64   1 0
    istore   u8    
    load     u64   .q 
    setret   u64   
    jump           #8498 
;------------------------
#8498:
    return         
end

proc mlib.pcm_copyheapblock
    rettype  u64   
    param    u64   .s 
    param    i64   .length 
    local    u64   .q 
;------------------------
    load     i64   .length 
    loadimm  i64   0 
    jumpne   i64   #8503 
    loadimm  u64   0 
    setret   u64   
    jump           #8501 
#8503:
#8502:
    setcall        1
    load     i64   .length 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .q 
    setcall        3
    load     i64   .length 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .q 
    setarg   u64   1
    callp          memcpy 3 0
    load     u64   .q 
    setret   u64   
    jump           #8501 
;------------------------
#8501:
    return         
end

proc mlib.allocmem
    rettype  u64   
    param    i64   .n 
    local    u64   .p 
;------------------------
    setcall        1
    load     i64   .n 
    setarg   u64   1
    callf    u64   malloc 1 0
    store    u64   .p 
    load     u64   .p 
    jumpf    u64   #8506 
    loadref  u64   mlib.memtotal 
    load     i64   .n 
    addto    i64   
    load     u64   .p 
    setret   u64   
    jump           #8504 
#8506:
#8505:
    callp          msys.m$print_startcon 0 0
    load     i64   .n 
    callp          msys.m$print_i64_nf 1 0
    load     i64   mlib.memtotal 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "Alloc mem failure"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
    loadimm  u64   0 
    setret   u64   
    jump           #8504 
;------------------------
#8504:
    return         
end

proc mlib.reallocmem
    rettype  u64   
    param    u64   .p 
    param    i64   .n 
;------------------------
    setcall        2
    load     i64   .n 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   realloc 2 0
    store    u64   .p 
    load     u64   .p 
    jumpf    u64   #8510 
    load     u64   .p 
    setret   u64   
    jump           #8508 
#8510:
#8509:
    callp          msys.m$print_startcon 0 0
    load     i64   .n 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "Realloc mem failure"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
    loadimm  u64   0 
    setret   u64   
    jump           #8508 
;------------------------
#8508:
    return         
end

proc mlib.abortprogram
    param    u64   .s 
;------------------------
    callp          msys.m$print_startcon 0 0
    load     u64   .s 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "ABORTING: Press key..."
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           5
;------------------------
#8512:
    return         
end

proc mlib.getfilesize
    rettype  i64   
    param    u64   .handlex 
    local    u32   .p 
    local    u32   .size 
;------------------------
    setcall        1
    load     u64   .handlex 
    setarg   u64   1
    callf    i32   ftell 1 0
    widen    i32   
    store    u32   .p 
    setcall        3
    loadimm  i64   2 
    setarg   i32   3
    loadimm  i64   0 
    setarg   i32   2
    load     u64   .handlex 
    setarg   u64   1
    callf    i32   fseek 3 0
    unload   i32   
    setcall        1
    load     u64   .handlex 
    setarg   u64   1
    callf    i32   ftell 1 0
    widen    i32   
    store    u32   .size 
    setcall        3
    loadimm  i64   0 
    setarg   i32   3
    load     u32   .p 
    setarg   i32   2
    load     u64   .handlex 
    setarg   u64   1
    callf    i32   fseek 3 0
    unload   i32   
    load     u32   .size 
    setret   i64   
    jump           #8514 
;------------------------
#8514:
    return         
end

proc mlib.readrandom
    param    u64   .handlex 
    param    u64   .mem 
    param    i64   .offset 
    param    i64   .size 
    local    i64   .a 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i32   3
    load     i64   .offset 
    setarg   i32   2
    load     u64   .handlex 
    setarg   u64   1
    callf    i32   fseek 3 0
    unload   i32   
    setcall        4
    load     u64   .handlex 
    setarg   u64   4
    load     i64   .size 
    setarg   u64   3
    loadimm  u64   1 
    setarg   u64   2
    load     u64   .mem 
    setarg   u64   1
    callf    i64   fread 4 0
    store    i64   .a 
;------------------------
#8515:
    return         
end

proc mlib.writerandom
    rettype  i64   
    param    u64   .handlex 
    param    u64   .mem 
    param    i64   .offset 
    param    i64   .size 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i32   3
    load     i64   .offset 
    setarg   i32   2
    load     u64   .handlex 
    setarg   u64   1
    callf    i32   fseek 3 0
    unload   i32   
    setcall        4
    load     u64   .handlex 
    setarg   u64   4
    load     i64   .size 
    setarg   u64   3
    loadimm  u64   1 
    setarg   u64   2
    load     u64   .mem 
    setarg   u64   1
    callf    i64   fwrite 4 0
    setret   i64   
    jump           #8516 
;------------------------
#8516:
    return         
end

proc mlib.setfilepos
    rettype  i64   
    param    u64   .file 
    param    i64   .offset 
;------------------------
    setcall        3
    loadimm  i64   0 
    setarg   i32   3
    load     i64   .offset 
    setarg   i32   2
    load     u64   .file 
    setarg   u64   1
    callf    i32   fseek 3 0
    widen    i32   
    setret   i64   
    jump           #8517 
;------------------------
#8517:
    return         
end

proc mlib.getfilepos
    rettype  i64   
    param    u64   .file 
;------------------------
    setcall        1
    load     u64   .file 
    setarg   u64   1
    callf    i32   ftell 1 0
    widen    i32   
    setret   i64   
    jump           #8518 
;------------------------
#8518:
    return         
end

proc mlib.readfile
    rettype  u64   
    param    u64   .filename 
    local    u64   .f 
    local    i64   .size 
    local    u64   .m 
    local    u64   .p 
;------------------------
    setcall        2
    loadimm  u64   "rb"
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    load     u64   .f 
    loadimm  u64   0 
    jumpne   u64   #8522 
    loadimm  u64   0 
    setret   u64   
    jump           #8519 
#8522:
#8521:
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i64   mlib.getfilesize 1 0
    double         
    store    i64   .size 
    store    i64   mlib.rfsize 
    setcall        1
    load     i64   .size 
    loadimm  i64   2 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .m 
    load     u64   .m 
    loadimm  u64   0 
    jumpne   u64   #8524 
    loadimm  u64   0 
    setret   u64   
    jump           #8519 
#8524:
#8523:
    setcall        4
    load     i64   .size 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .m 
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callp          mlib.readrandom 4 0
    load     u64   .m 
    load     i64   .size 
    addptrx  u64   1 0
    store    u64   .p 
    loadimm  i64   0 
    load     u64   .p 
    istore   u16   
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
    load     u64   .m 
    setret   u64   
    jump           #8519 
;------------------------
#8519:
    return         
end

proc mlib.writefile
    rettype  i64   
    param    u64   .filename 
    param    u64   .data 
    param    i64   .size 
    local    u64   .f 
    local    i64   .n 
;------------------------
    setcall        2
    loadimm  u64   "wb"
    setarg   u64   2
    load     u64   .filename 
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    load     u64   .f 
    loadimm  u64   0 
    jumpne   u64   #8528 
    loadimm  i64   0 
    setret   i64   
    jump           #8525 
#8528:
#8527:
    setcall        4
    load     i64   .size 
    setarg   i64   4
    loadimm  i64   0 
    setarg   i64   3
    load     u64   .data 
    setarg   u64   2
    load     u64   .f 
    setarg   u64   1
    callf    i64   mlib.writerandom 4 0
    store    i64   .n 
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
    load     i64   .n 
    setret   i64   
    jump           #8525 
;------------------------
#8525:
    return         
end

proc mlib.checkfile
    rettype  i64   
    param    u64   .file 
    local    u64   .f 
;------------------------
    setcall        2
    loadimm  u64   "rb"
    setarg   u64   2
    load     u64   .file 
    setarg   u64   1
    callf    u64   fopen 2 0
    double         
    store    u64   .f 
    jumpf    u64   #8531 
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
    loadimm  i64   1 
    setret   i64   
    jump           #8529 
#8531:
#8530:
    loadimm  i64   0 
    setret   i64   
    jump           #8529 
;------------------------
#8529:
    return         
end

proc mlib.readlinen
    param    u64   .handlex 
    param    u64   .buffer 
    param    i64   .size 
    local    i64   .ch 
    local    u64   .p 
    local    i64   .n 
    local    u8:100 .buff 
    local    u8    .crseen 
;------------------------
    load     u64   .handlex 
    loadimm  u64   0 
    jumpne   u64   #8535 
    setcall        0
    callf    u64   mwindows.os_getstdin 0 0
    store    u64   .handlex 
#8535:
#8534:
    load     u64   .handlex 
    loadimm  u64   0 
    jumpne   u64   #8537 
    loadimm  i64   0 
    store    i64   .n 
    load     u64   .buffer 
    store    u64   .p 
#8538:
    setcall        0
    callf    i32   getchar 0 0
    widen    i32   
    store    i64   .ch 
    load     i64   .ch 
    loadimm  i64   13 
    jumpeq   i64   #8542 
    load     i64   .ch 
    loadimm  i64   10 
    jumpeq   i64   #8542 
    load     i64   .ch 
    loadimm  i64   -1 
    jumpne   i64   #8541 
#8542:
    loadimm  u64   0 
    load     u64   .p 
    istore   u8    
    jump           #8533 
#8541:
#8540:
    load     i64   .ch 
    loadref  u64   .p 
    loadincr u64   1
    istore   u8    
    loadref  u64   .n 
    incrto   i64   1
    load     i64   .n 
    load     i64   .size 
    loadimm  i64   2 
    sub      i64   
    jumplt   i64   #8544 
    loadimm  u64   0 
    load     u64   .p 
    istore   u8    
    jump           #8533 
#8544:
#8543:
    jump           #8538 
#8539:
#8537:
#8536:
    loadimm  u64   0 
    load     u64   .buffer 
    istore   u8    
    setcall        3
    load     u64   .handlex 
    setarg   u64   3
    load     i64   .size 
    loadimm  i64   2 
    sub      i64   
    setarg   i64   2
    load     u64   .buffer 
    setarg   u64   1
    callf    u64   fgets 3 0
    loadimm  u64   0 
    jumpne   u64   #8546 
    jump           #8533 
#8546:
#8545:
    setcall        1
    load     u64   .buffer 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .n 
    load     i64   .n 
    loadimm  i64   0 
    jumpne   i64   #8548 
    jump           #8533 
#8548:
#8547:
    load     u64   .buffer 
    load     i64   .n 
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    store    u64   .p 
    loadimm  i64   0 
    store    u8    .crseen 
    jump           #8550 
#8549:
    load     u64   .p 
    iload    u8    
    loadimm  i64   13 
    jumpeq   i64   #8554 
    load     u64   .p 
    iload    u8    
    loadimm  i64   10 
    jumpne   i64   #8553 
#8554:
    loadimm  i64   1 
    store    u8    .crseen 
#8553:
#8552:
    loadimm  u64   0 
    loadref  u64   .p 
    loaddecr u64   1
    istore   u8    
#8550:
    load     u64   .p 
    load     u64   .buffer 
    jumplt   u64   #8555 
    load     u64   .p 
    iload    u8    
    loadimm  i64   13 
    jumpeq   i64   #8549 
    load     u64   .p 
    iload    u8    
    loadimm  i64   10 
    jumpeq   i64   #8549 
#8555:
#8551:
    load     u8    .crseen 
    jumpt    i64   #8557 
    load     i64   .n 
    loadimm  i64   4 
    add      i64   
    load     i64   .size 
    jumple   i64   #8557 
    callp          msys.m$print_startcon 0 0
    load     i64   .size 
    callp          msys.m$print_i64_nf 1 0
    load     i64   .n 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    loadimm  u64   "line too long"
    setarg   u64   1
    callp          mlib.abortprogram 1 0
#8557:
#8556:
;------------------------
#8533:
    return         
end

proc mlib.iconvlcn
    param    u64   .s 
    param    i64   .n 
    local    i64   .$av_1 
;------------------------
    load     i64   .n 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #8562 
#8560:
    setcall        1
    load     u64   .s 
    iload    u8    
    setarg   i32   1
    callf    i32   tolower 1 0
    widen    i32   
    load     u64   .s 
    istore   u8    
    loadref  u64   .s 
    incrto   u64   1
#8561:
    to             #8560 
    opnd           .$av_1 
#8562:
;------------------------
#8559:
    return         
end

proc mlib.iconvucn
    param    u64   .s 
    param    i64   .n 
    local    i64   .$av_1 
;------------------------
    load     i64   .n 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #8566 
#8564:
    setcall        1
    load     u64   .s 
    iload    u8    
    setarg   i32   1
    callf    i32   toupper 1 0
    widen    i32   
    load     u64   .s 
    istore   u8    
    loadref  u64   .s 
    incrto   u64   1
#8565:
    to             #8564 
    opnd           .$av_1 
#8566:
;------------------------
#8563:
    return         
end

proc mlib.convlcstring
    rettype  u64   
    param    u64   .s 
    local    u64   .s0 
;------------------------
    load     u64   .s 
    store    u64   .s0 
    jump           #8569 
#8568:
    setcall        1
    load     u64   .s 
    iload    u8    
    setarg   i32   1
    callf    i32   tolower 1 0
    widen    i32   
    load     u64   .s 
    istore   u8    
    loadref  u64   .s 
    incrto   u64   1
#8569:
    load     u64   .s 
    iload    u8    
    jumpt    u64   #8568 
#8570:
    load     u64   .s0 
    setret   u64   
    jump           #8567 
;------------------------
#8567:
    return         
end

proc mlib.convucstring
    rettype  u64   
    param    u64   .s 
    local    u64   .s0 
;------------------------
    load     u64   .s 
    store    u64   .s0 
    jump           #8573 
#8572:
    setcall        1
    load     u64   .s 
    iload    u8    
    setarg   i32   1
    callf    i32   toupper 1 0
    widen    i32   
    load     u64   .s 
    istore   u8    
    loadref  u64   .s 
    incrto   u64   1
#8573:
    load     u64   .s 
    iload    u8    
    jumpt    u64   #8572 
#8574:
    load     u64   .s0 
    setret   u64   
    jump           #8571 
;------------------------
#8571:
    return         
end

proc mlib.changeext
    rettype  u64   
    param    u64   .s 
    param    u64   .newext 
    local    u8:32 .newext2 
    local    u64   .sext 
    local    i64   .n 
;------------------------
    setcall        2
    load     u64   .s 
    setarg   u64   2
    loadref  u64   mlib.changeext.newfile 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    load     u64   .newext 
    iload    u8    
    loadimm  u64   0 
    jumpeq   u64   #8577 1
    loadimm  u64   46 
    jumpeq   u64   #8578 
    jump           #8579 
#8577:
    loadimm  u64   0 
    loadref  u64   .newext2 
    loadimm  i64   1 
    istorex  u8    1 -1
    loadimm  u64   0 
    loadref  u64   .newext2 
    loadimm  i64   2 
    istorex  u8    1 -1
    jump           #8576 
#8578:
    setcall        2
    load     u64   .newext 
    setarg   u64   2
    loadref  u64   .newext2 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    jump           #8576 
#8579:
    setcall        2
    loadimm  u64   "."
    setarg   u64   2
    loadref  u64   .newext2 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    load     u64   .newext 
    setarg   u64   2
    loadref  u64   .newext2 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#8576:
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.extractext 2 0
    store    u64   .sext 
    load     u64   .sext 
    iload    u8    
    loadimm  u64   0 
    jumpeq   u64   #8582 1
    loadimm  u64   46 
    jumpeq   u64   #8583 
    jump           #8584 
#8582:
    setcall        2
    loadref  u64   .newext2 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setarg   u64   2
    loadref  u64   mlib.changeext.newfile 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #8581 
#8583:
    setcall        2
    loadref  u64   .newext2 
    loadimm  i64   2 
    addptrx  u8    1 -1
    setarg   u64   2
    loadref  u64   mlib.changeext.newfile 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    jump           #8581 
#8584:
    load     u64   .sext 
    load     u64   .s 
    subptr   u64   1
    loadimm  i64   2 
    sub      i64   
    store    i64   .n 
    setcall        2
    loadref  u64   .newext2 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setarg   u64   2
    loadref  u64   mlib.changeext.newfile 
    loadimm  i64   1 
    addptrx  u8    1 -1
    load     i64   .n 
    addptrx  u64   1 0
    loadimm  i64   1 
    addptrx  u64   1 0
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
#8581:
    loadref  u64   mlib.changeext.newfile 
    loadimm  i64   1 
    addptrx  u8    1 -1
    setret   u64   
    jump           #8575 
;------------------------
#8575:
    return         
end

proc mlib.extractext
    rettype  u64   
    param    u64   .s 
    param    i64   .period 
    local    u64   .t 
    local    u64   .u 
;------------------------
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.extractfile 1 0
    store    u64   .t 
    load     u64   .t 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8587 
    loadimm  u64   ""
    setret   u64   
    jump           #8585 
#8587:
#8586:
    load     u64   .t 
    setcall        1
    load     u64   .t 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    store    u64   .u 
    jump           #8590 
#8589:
    load     u64   .u 
    iload    u8    
    loadimm  u64   46 
    jumpne   u64   #8593 
    load     u64   .u 
    loadimm  i64   1 
    addptrx  u64   1 0
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8595 
    startmx        
    load     i64   .period 
    jumpf    i64   #8597 
    loadimm  u64   "."
    resetmx        
    jump           #8596 
#8597:
    loadimm  u64   ""
    endmx          
#8596:
    setret   u64   
    jump           #8585 
#8595:
#8594:
    load     u64   .u 
    loadimm  i64   1 
    addptrx  u64   1 0
    setret   u64   
    jump           #8585 
#8593:
#8592:
    loadref  u64   .u 
    decrto   u64   1
#8590:
    load     u64   .u 
    load     u64   .t 
    jumpge   u64   #8589 
#8591:
    loadimm  u64   ""
    setret   u64   
    jump           #8585 
;------------------------
#8585:
    return         
end

proc mlib.extractpath
    rettype  u64   
    param    u64   .s 
    local    u64   .t 
    local    i64   .n 
;------------------------
    load     u64   .s 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    store    u64   .t 
    jump           #8602 
#8601:
    load     u64   .t 
    iload    u8    
    switch         #8605 47 92
    opnd           #8606 
#8605:
    swlabel        #8607 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8607 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8606 
    swlabel        #8607 
    endsw          
#8607:
    load     u64   .t 
    load     u64   .s 
    subptr   u64   1
    loadimm  i64   1 
    add      i64   
    store    i64   .n 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    loadref  u64   mlib.extractpath.str 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    loadref  u64   mlib.extractpath.str 
    load     i64   .n 
    istorex  u8    1 0
    loadref  u64   mlib.extractpath.str 
    setret   u64   
    jump           #8600 
    jump           #8604 
#8606:
#8604:
    loadref  u64   .t 
    decrto   u64   1
#8602:
    load     u64   .t 
    load     u64   .s 
    jumpge   u64   #8601 
#8603:
    loadimm  u64   ""
    setret   u64   
    jump           #8600 
;------------------------
#8600:
    return         
end

proc mlib.extractfile
    rettype  u64   
    param    u64   .s 
    local    u64   .t 
;------------------------
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.extractpath 1 0
    store    u64   .t 
    load     u64   .t 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8610 
    load     u64   .s 
    setret   u64   
    jump           #8608 
#8610:
#8609:
    load     u64   .s 
    setcall        1
    load     u64   .t 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    setret   u64   
    jump           #8608 
;------------------------
#8608:
    return         
end

proc mlib.extractbasefile
    rettype  u64   
    param    u64   .s 
    local    u64   .f 
    local    u64   .e 
    local    i64   .n 
    local    i64   .flen 
;------------------------
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.extractfile 1 0
    store    u64   .f 
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .flen 
    load     i64   .flen 
    loadimm  i64   0 
    jumpne   i64   #8613 
    loadimm  u64   ""
    setret   u64   
    jump           #8611 
#8613:
#8612:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .f 
    setarg   u64   1
    callf    u64   mlib.extractext 2 0
    store    u64   .e 
    load     u64   .e 
    iload    u8    
    jumpf    u64   #8615 
    load     i64   .flen 
    setcall        1
    load     u64   .e 
    setarg   u64   1
    callf    i64   strlen 1 0
    sub      i64   
    loadimm  i64   1 
    sub      i64   
    store    i64   .n 
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .f 
    setarg   u64   2
    loadref  u64   mlib.extractbasefile.str 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    loadref  u64   mlib.extractbasefile.str 
    load     i64   .n 
    istorex  u8    1 0
    loadref  u64   mlib.extractbasefile.str 
    setret   u64   
    jump           #8611 
#8615:
#8614:
    load     u64   .f 
    load     i64   .flen 
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    iload    u8    
    loadimm  u64   46 
    jumpne   u64   #8617 
    setcall        3
    load     i64   .flen 
    loadimm  i64   1 
    sub      i64   
    setarg   u64   3
    load     u64   .f 
    setarg   u64   2
    loadref  u64   mlib.extractbasefile.str 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    loadref  u64   mlib.extractbasefile.str 
    load     i64   .flen 
    istorex  u8    1 -1
    loadref  u64   mlib.extractbasefile.str 
    setret   u64   
    jump           #8611 
#8617:
#8616:
    load     u64   .f 
    setret   u64   
    jump           #8611 
;------------------------
#8611:
    return         
end

proc mlib.addext
    rettype  u64   
    param    u64   .s 
    param    u64   .newext 
    local    u64   .sext 
;------------------------
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.extractext 2 0
    store    u64   .sext 
    load     u64   .sext 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8620 
    setcall        2
    load     u64   .newext 
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   mlib.changeext 2 0
    setret   u64   
    jump           #8618 
#8620:
#8619:
    load     u64   .s 
    setret   u64   
    jump           #8618 
;------------------------
#8618:
    return         
end

proc mlib.pcm_alloc32
    rettype  u64   
    local    u64   .p 
;------------------------
    loadimm  i64   32 
    store    i64   mlib.allocbytes 
    loadref  u64   mlib.smallmemtotal 
    loadimm  i64   32 
    addto    i64   
    loadref  u64   mlib.freelist 
    loadimm  i64   2 
    iloadx   u64   8 0
    double         
    store    u64   .p 
    jumpf    u64   #8623 
    loadref  u64   mlib.freelist 
    loadimm  i64   2 
    iloadx   u64   8 0
    iload    u64   
    loadref  u64   mlib.freelist 
    loadimm  i64   2 
    istorex  u64   8 0
    load     u64   .p 
    setret   u64   
    jump           #8621 
#8623:
#8622:
    setcall        1
    loadimm  i64   32 
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    setret   u64   
    jump           #8621 
;------------------------
#8621:
    return         
end

proc mlib.pcm_free32
    param    u64   .p 
;------------------------
    loadref  u64   mlib.smallmemtotal 
    loadimm  i64   32 
    subto    i64   
    loadref  u64   mlib.freelist 
    loadimm  i64   2 
    iloadx   u64   8 0
    load     u64   .p 
    istore   u64   
    load     u64   .p 
    loadref  u64   mlib.freelist 
    loadimm  i64   2 
    istorex  u64   8 0
;------------------------
#8624:
    return         
end

proc mlib.outbyte
    param    u64   .f 
    param    i64   .x 
;------------------------
    setcall        4
    load     u64   .f 
    setarg   u64   4
    loadimm  u64   1 
    setarg   u64   3
    loadimm  u64   1 
    setarg   u64   2
    loadref  u64   .x 
    setarg   u64   1
    callf    u64   fwrite 4 0
    unload   u64   
;------------------------
#8625:
    return         
end

proc mlib.outword16
    param    u64   .f 
    param    u64   .x 
;------------------------
    setcall        4
    load     u64   .f 
    setarg   u64   4
    loadimm  u64   1 
    setarg   u64   3
    loadimm  u64   2 
    setarg   u64   2
    loadref  u64   .x 
    setarg   u64   1
    callf    u64   fwrite 4 0
    unload   u64   
;------------------------
#8626:
    return         
end

proc mlib.outword32
    param    u64   .f 
    param    u64   .x 
;------------------------
    setcall        4
    load     u64   .f 
    setarg   u64   4
    loadimm  u64   1 
    setarg   u64   3
    loadimm  u64   4 
    setarg   u64   2
    loadref  u64   .x 
    setarg   u64   1
    callf    u64   fwrite 4 0
    unload   u64   
;------------------------
#8627:
    return         
end

proc mlib.outword64
    param    u64   .f 
    param    u64   .x 
;------------------------
    setcall        4
    load     u64   .f 
    setarg   u64   4
    loadimm  u64   1 
    setarg   u64   3
    loadimm  u64   8 
    setarg   u64   2
    loadref  u64   .x 
    setarg   u64   1
    callf    u64   fwrite 4 0
    unload   u64   
;------------------------
#8628:
    return         
end

proc mlib.outstring
    param    u64   .f 
    param    u64   .s 
;------------------------
    setcall        4
    load     u64   .f 
    setarg   u64   4
    loadimm  u64   1 
    setarg   u64   3
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    loadimm  i64   1 
    add      i64   
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   fwrite 4 0
    unload   u64   
;------------------------
#8629:
    return         
end

proc mlib.outblock
    param    u64   .f 
    param    u64   .p 
    param    i64   .n 
;------------------------
    setcall        4
    load     u64   .f 
    setarg   u64   4
    loadimm  u64   1 
    setarg   u64   3
    load     i64   .n 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    u64   fwrite 4 0
    unload   u64   
;------------------------
#8630:
    return         
end

proc mlib.myeof
    rettype  i64   
    param    u64   .f 
    local    i64   .c 
;------------------------
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fgetc 1 0
    widen    i32   
    store    i64   .c 
    load     i64   .c 
    loadimm  i64   -1 
    jumpne   i64   #8633 
    loadimm  i64   1 
    setret   i64   
    jump           #8631 
#8633:
#8632:
    setcall        2
    load     u64   .f 
    setarg   u64   2
    load     i64   .c 
    setarg   i32   1
    callf    i32   ungetc 2 0
    unload   i32   
    loadimm  i64   0 
    setret   i64   
    jump           #8631 
;------------------------
#8631:
    return         
end

proc mlib.strbuffer_add
    param    u64   .dest 
    param    u64   .s 
    param    i64   .n 
    local    i64   .newlen 
    local    i64   .oldlen 
    local    u64   .newptr 
;------------------------
    load     i64   .n 
    loadimm  i64   0 
    jumpne   i64   #8636 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "N=0"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#8636:
#8635:
    load     i64   .n 
    loadimm  i64   -1 
    jumpne   i64   #8639 
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .n 
#8639:
#8638:
    load     u64   .dest 
    loadimm  i64   8 
    iloadx   i32   1 0
    store    i64   .oldlen 
    load     i64   .oldlen 
    loadimm  i64   0 
    jumpne   i64   #8641 
    setcall        1
    load     i64   .n 
    loadimm  i64   1 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    load     u64   .dest 
    loadimm  i64   0 
    istorex  u64   1 0
    load     i64   mlib.allocbytes 
    load     u64   .dest 
    loadimm  i64   12 
    istorex  i32   1 0
    load     i64   .n 
    load     u64   .dest 
    loadimm  i64   8 
    istorex  i32   1 0
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .dest 
    iload    u64   
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   .dest 
    iload    u64   
    load     i64   .n 
    addptrx  u64   1 0
    istore   u8    
    jump           #8634 
#8641:
#8640:
    load     i64   .oldlen 
    load     i64   .n 
    add      i64   
    store    i64   .newlen 
    load     i64   .newlen 
    loadimm  i64   1 
    add      i64   
    load     u64   .dest 
    loadimm  i64   12 
    iloadx   i32   1 0
    jumple   i64   #8643 
    setcall        1
    load     i64   .newlen 
    loadimm  i64   1 
    add      i64   
    setarg   i64   1
    callf    u64   mlib.pcm_alloc 1 0
    store    u64   .newptr 
    setcall        3
    load     i64   .oldlen 
    setarg   u64   3
    load     u64   .dest 
    iload    u64   
    setarg   u64   2
    load     u64   .newptr 
    setarg   u64   1
    callp          memcpy 3 0
    load     u64   .newptr 
    load     u64   .dest 
    loadimm  i64   0 
    istorex  u64   1 0
    load     i64   mlib.allocbytes 
    load     u64   .dest 
    loadimm  i64   12 
    istorex  i32   1 0
#8643:
#8642:
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .dest 
    iload    u64   
    load     i64   .oldlen 
    addptrx  u64   1 0
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    load     u64   .dest 
    iload    u64   
    load     i64   .newlen 
    addptrx  u64   1 0
    istore   u8    
    load     i64   .newlen 
    load     u64   .dest 
    loadimm  i64   8 
    istorex  i32   1 0
;------------------------
#8634:
    return         
end

proc mlib.gs_init
    param    u64   .dest 
;------------------------
    setcall        2
    loadimm  i64   16 
    setarg   i64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.pcm_clearmem 2 0
;------------------------
#8644:
    return         
end

proc mlib.gs_free
    param    u64   .dest 
;------------------------
    load     u64   .dest 
    loadimm  i64   12 
    iloadx   i32   1 0
    jumpf    i64   #8647 
    setcall        2
    load     u64   .dest 
    loadimm  i64   12 
    iloadx   i32   1 0
    setarg   i64   2
    load     u64   .dest 
    iload    u64   
    setarg   u64   1
    callp          mlib.pcm_free 2 0
#8647:
#8646:
;------------------------
#8645:
    return         
end

proc mlib.gs_str
    param    u64   .dest 
    param    u64   .s 
;------------------------
    setcall        3
    loadimm  i64   -1 
    setarg   i64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
;------------------------
#8648:
    return         
end

proc mlib.gs_char
    param    u64   .dest 
    param    i64   .c 
    local    u8:16 .s 
;------------------------
    load     i64   .c 
    loadref  u64   .s 
    loadimm  i64   1 
    istorex  u8    1 -1
    loadimm  u64   0 
    loadref  u64   .s 
    loadimm  i64   2 
    istorex  u8    1 -1
    setcall        3
    loadimm  i64   1 
    setarg   i64   3
    loadref  u64   .s 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
;------------------------
#8649:
    return         
end

proc mlib.gs_strn
    param    u64   .dest 
    param    u64   .s 
    param    i64   .length 
;------------------------
    setcall        3
    load     i64   .length 
    setarg   i64   3
    load     u64   .s 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
;------------------------
#8650:
    return         
end

proc mlib.gs_strvar
    param    u64   .dest 
    param    u64   .s 
;------------------------
    setcall        3
    loadimm  i64   -1 
    setarg   i64   3
    load     u64   .s 
    iload    u64   
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
;------------------------
#8651:
    return         
end

proc mlib.gs_strint
    param    u64   .dest 
    param    i64   .a 
;------------------------
    setcall        3
    loadimm  i64   -1 
    setarg   i64   3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .a 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
;------------------------
#8652:
    return         
end

proc mlib.gs_strln
    param    u64   .dest 
    param    u64   .s 
;------------------------
    setcall        2
    load     u64   .s 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        1
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_line 1 0
;------------------------
#8653:
    return         
end

proc mlib.gs_strsp
    param    u64   .dest 
    param    u64   .s 
;------------------------
    setcall        2
    load     u64   .s 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
    setcall        2
    loadimm  u64   " "
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
;------------------------
#8654:
    return         
end

proc mlib.gs_line
    param    u64   .dest 
;------------------------
    setcall        3
    loadimm  i64   -1 
    setarg   i64   3
    loadimm  u64   "\r\n"
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.strbuffer_add 3 0
;------------------------
#8656:
    return         
end

proc mlib.gs_getcol
    rettype  i64   
    param    u64   .dest 
;------------------------
    load     u64   .dest 
    loadimm  i64   8 
    iloadx   i32   1 0
    setret   i64   
    jump           #8658 
;------------------------
#8658:
    return         
end

proc mlib.gs_leftstr
    param    u64   .dest 
    param    u64   .s 
    param    i64   .w 
    param    i64   .padch 
    local    i64   .col 
    local    i64   .i 
    local    i64   .n 
    local    i64   .slen 
    local    u8:2560 .str 
;------------------------
    load     u64   .dest 
    loadimm  i64   8 
    iloadx   i32   1 0
    store    i64   .col 
    setcall        2
    load     u64   .s 
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .slen 
    load     i64   .w 
    load     i64   .slen 
    sub      i64   
    store    i64   .n 
    load     i64   .n 
    loadimm  i64   0 
    jumple   i64   #8661 
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .n 
    loadimm  i64   1 
    jumplt   i64   #8664 
#8662:
    load     i64   .padch 
    loadref  u64   .str 
    load     i64   .slen 
    load     i64   .i 
    add      i64   
    istorex  u8    1 -1
#8663:
    forup          #8662 1
    opnd           .i 
    opnd           .n 
#8664:
    loadimm  u64   0 
    loadref  u64   .str 
    load     i64   .slen 
    load     i64   .n 
    add      i64   
    istorex  u8    1 0
#8661:
#8660:
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
;------------------------
#8659:
    return         
end

proc mlib.gs_leftint
    param    u64   .dest 
    param    i64   .a 
    param    i64   .w 
    param    i64   .padch 
;------------------------
    setcall        4
    load     i64   .padch 
    setarg   i64   4
    load     i64   .w 
    setarg   i64   3
    setcall        2
    loadimm  u64   0 
    setarg   u64   2
    load     i64   .a 
    setarg   i64   1
    callf    u64   msys.strint 2 0
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_leftstr 4 0
;------------------------
#8665:
    return         
end

proc mlib.gs_padto
    param    u64   .dest 
    param    i64   .col 
    param    i64   .ch 
    local    i64   .n 
    local    u8:2560 .str 
    local    i64   .i 
;------------------------
    load     i64   .col 
    load     u64   .dest 
    loadimm  i64   8 
    iloadx   i32   1 0
    sub      i64   
    store    i64   .n 
    load     i64   .n 
    loadimm  i64   0 
    jumpgt   i64   #8668 
    jump           #8666 
#8668:
#8667:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   .n 
    loadimm  i64   1 
    jumplt   i64   #8671 
#8669:
    load     i64   .ch 
    loadref  u64   .str 
    load     i64   .i 
    istorex  u8    1 -1
#8670:
    forup          #8669 1
    opnd           .i 
    opnd           .n 
#8671:
    loadimm  u64   0 
    loadref  u64   .str 
    load     i64   .n 
    istorex  u8    1 0
    setcall        2
    loadref  u64   .str 
    setarg   u64   2
    load     u64   .dest 
    setarg   u64   1
    callp          mlib.gs_str 2 0
;------------------------
#8666:
    return         
end

proc mlib.gs_println
    param    u64   .dest 
    param    u64   .f 
;------------------------
    load     u64   .dest 
    loadimm  i64   8 
    iloadx   i32   1 0
    loadimm  i64   0 
    jumpne   i64   #8674 
    jump           #8672 
#8674:
#8673:
    loadimm  u64   0 
    load     u64   .dest 
    iload    u64   
    load     u64   .dest 
    loadimm  i64   8 
    iloadx   i32   1 0
    addptrx  u64   1 0
    istore   u8    
    load     u64   .f 
    loadimm  u64   0 
    jumpne   u64   #8676 
    callp          msys.m$print_startcon 0 0
    load     u64   .dest 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #8675 
#8676:
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     u64   .dest 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#8675:
;------------------------
#8672:
    return         
end

proc mlib.nextcmdparamnew
    rettype  i64   
    param    u64   .paramno 
    param    u64   .name 
    param    u64   .value 
    param    u64   .defext 
    local    u64   .q 
    local    u64   .item 
    local    u64   .fileext 
    local    u64   .rest 
;------------------------
;reenter::
#8678:
    loadimm  u64   0 
    load     u64   .value 
    istore   u64   
    loadimm  u64   0 
    load     u64   .name 
    istore   u64   
    load     i64   mlib.nextcmdparamnew.infile 
    jumpf    i64   #8680 
    setcall        2
    loadref  u64   .item 
    setarg   u64   2
    loadref  u64   mlib.nextcmdparamnew.fileptr 
    setarg   u64   1
    callf    i64   mlib.readnextfileitem 2 0
    loadimm  i64   0 
    jumpne   i64   #8682 
    setcall        2
    load     i64   mlib.nextcmdparamnew.atsize 
    setarg   i64   2
    load     u64   mlib.nextcmdparamnew.filestart 
    setarg   u64   1
    callp          mlib.pcm_free 2 0
    loadimm  i64   0 
    store    i64   mlib.nextcmdparamnew.infile 
    jump           #8678 
#8682:
#8681:
    jump           #8679 
#8680:
    load     u64   .paramno 
    iload    i64   
    load     i64   msys.ncmdparams 
    jumple   i64   #8684 
    loadimm  i64   0 
    setret   i64   
    jump           #8677 
#8684:
#8683:
    load     u64   msys.cmdparams 
    load     u64   .paramno 
    iload    i64   
    iloadx   u64   8 0
    store    u64   .item 
    load     u64   .paramno 
    incrto   i64   1
    load     u64   .item 
    iload    u8    
    loadimm  u64   64 
    jumpne   u64   #8686 
    load     i64   mlib.nextcmdparamnew.infile 
    jumpf    i64   #8688 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Nested @"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           1
#8688:
#8687:
    setcall        1
    load     u64   .item 
    loadimm  i64   1 
    addptrx  u64   1 0
    setarg   u64   1
    callf    u64   mlib.readfile 1 0
    double         
    store    u64   mlib.nextcmdparamnew.fileptr 
    store    u64   mlib.nextcmdparamnew.filestart 
    load     u64   mlib.nextcmdparamnew.filestart 
    loadimm  u64   0 
    jumpne   u64   #8691 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Can't open"
    callp          msys.m$print_str_nf 1 0
    load     u64   .item 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           7
#8691:
#8690:
    loadimm  i64   1 
    store    i64   mlib.nextcmdparamnew.infile 
    load     i64   mlib.allocbytes 
    store    i64   mlib.nextcmdparamnew.atsize 
    jump           #8678 
#8686:
#8685:
    load     u64   .item 
    iload    u8    
    loadimm  u64   58 
    jumpne   u64   #8694 
    loadimm  i64   1 
    store    u8    mlib.nextcmdparamnew.colonseen 
    loadimm  i64   4 
    setret   i64   
    jump           #8677 
#8694:
#8693:
#8679:
    loadimm  u64   0 
    load     u64   .value 
    istore   u64   
    load     u64   .item 
    iload    u8    
    loadimm  u64   45 
    jumpne   u64   #8696 
    load     u64   .item 
    startmx        
    load     u8    mlib.nextcmdparamnew.colonseen 
    jumpf    i64   #8698 
    loadimm  i64   0 
    resetmx        
    jump           #8697 
#8698:
    loadimm  i64   1 
    endmx          
#8697:
    addptrx  u64   1 0
    load     u64   .name 
    istore   u64   
    setcall        2
    loadimm  u64   58 
    setarg   i32   2
    load     u64   .item 
    setarg   u64   1
    callf    u64   strchr 2 0
    store    u64   .q 
    load     u64   .q 
    jumpt    u64   #8700 
    setcall        2
    loadimm  u64   61 
    setarg   i32   2
    load     u64   .item 
    setarg   u64   1
    callf    u64   strchr 2 0
    store    u64   .q 
#8700:
#8699:
    load     u64   .q 
    jumpf    u64   #8702 
    load     u64   .q 
    loadimm  i64   1 
    addptrx  u64   1 0
    load     u64   .value 
    istore   u64   
    loadimm  u64   0 
    load     u64   .q 
    istore   u8    
#8702:
#8701:
    startmx        
    load     u8    mlib.nextcmdparamnew.colonseen 
    jumpf    i64   #8704 
    loadimm  i64   5 
    resetmx        
    jump           #8703 
#8704:
    loadimm  i64   1 
    endmx          
#8703:
    setret   i64   
    jump           #8677 
#8696:
#8695:
    setcall        2
    loadimm  i64   0 
    setarg   i64   2
    load     u64   .item 
    setarg   u64   1
    callf    u64   mlib.extractext 2 0
    store    u64   .fileext 
    load     u64   .item 
    load     u64   .name 
    istore   u64   
    load     u64   .fileext 
    iload    u8    
    loadimm  i64   0 
    jumpne   i64   #8706 
    setcall        2
    load     u64   .name 
    iload    u64   
    setarg   u64   2
    loadref  u64   mlib.nextcmdparamnew.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    load     u64   .defext 
    jumpf    u64   #8708 
    load     u8    mlib.nextcmdparamnew.colonseen 
    jumpt    i64   #8708 
    setcall        2
    load     u64   .defext 
    setarg   u64   2
    loadref  u64   mlib.nextcmdparamnew.str 
    setarg   u64   1
    callf    u64   mlib.addext 2 0
    load     u64   .name 
    istore   u64   
#8708:
#8707:
    jump           #8705 
#8706:
    setcall        2
    loadimm  u64   "dll"
    setarg   u64   2
    load     u64   .fileext 
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpt    i64   #8710 
    setcall        2
    loadimm  u64   "mcx"
    setarg   u64   2
    load     u64   .fileext 
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #8709 
#8710:
    startmx        
    load     u8    mlib.nextcmdparamnew.colonseen 
    jumpf    i64   #8714 
    loadimm  i64   5 
    resetmx        
    jump           #8713 
#8714:
    loadimm  i64   3 
    endmx          
#8713:
    setret   i64   
    jump           #8677 
#8709:
#8705:
    startmx        
    load     u8    mlib.nextcmdparamnew.colonseen 
    jumpf    i64   #8716 
    loadimm  i64   5 
    resetmx        
    jump           #8715 
#8716:
    loadimm  i64   2 
    endmx          
#8715:
    setret   i64   
    jump           #8677 
;------------------------
#8677:
    return         
end

proc mlib.readnextfileitem
    rettype  i64   
    param    u64   .fileptr 
    param    u64   .item 
    local    u64   .p 
    local    u64   .pstart 
    local    u64   .pend 
    local    i64   .n 
;------------------------
    load     u64   .fileptr 
    iload    u64   
    store    u64   .p 
;reenter::
#8718:
#8719:
    load     u64   .p 
    iload    u8    
    loadimm  u64   32 
    jumpeq   u64   #8722 1
    loadimm  u64   9 
    jumpeq   u64   #8722 1
    loadimm  u64   13 
    jumpeq   u64   #8722 1
    loadimm  u64   10 
    jumpeq   u64   #8722 1
    loadimm  u64   26 
    jumpeq   u64   #8723 1
    loadimm  u64   0 
    jumpeq   u64   #8723 
    jump           #8724 
#8722:
    loadref  u64   .p 
    incrto   u64   1
    jump           #8721 
#8723:
    loadimm  i64   0 
    setret   i64   
    jump           #8717 
    jump           #8721 
#8724:
    jump           #8720 
#8721:
    jump           #8719 
#8720:
    load     u64   .p 
    iload    u8    
    loadimm  u64   33 
    jumpeq   u64   #8726 1
    loadimm  u64   35 
    jumpeq   u64   #8726 
    jump           #8727 
#8726:
    loadref  u64   .p 
    incrto   u64   1
#8728:
    loadref  u64   .p 
    loadincr u64   1
    iload    u8    
    loadimm  u64   10 
    jumpeq   u64   #8730 1
    loadimm  u64   26 
    jumpeq   u64   #8731 1
    loadimm  u64   0 
    jumpeq   u64   #8731 
    jump           #8732 
#8730:
    jump           #8718 
    jump           #8728 
#8731:
    load     u64   .p 
    loadimm  i64   1 
    subptrx  u64   1 0
    load     u64   .fileptr 
    istore   u64   
    loadimm  i64   0 
    setret   i64   
    jump           #8717 
    jump           #8728 
#8732:
    jump           #8728 
#8729:
    jump           #8725 
#8727:
#8725:
    load     u64   .p 
    iload    u8    
    loadimm  u64   34 
    jumpeq   u64   #8734 
    jump           #8735 
#8734:
    loadref  u64   .p 
    incrload u64   1
    store    u64   .pstart 
#8736:
    load     u64   .p 
    iload    u8    
    loadimm  u64   0 
    jumpeq   u64   #8739 1
    loadimm  u64   26 
    jumpeq   u64   #8739 1
    loadimm  u64   34 
    jumpeq   u64   #8740 
    jump           #8741 
#8739:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Unexpected EOF in @file"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           8
    jump           #8738 
#8740:
    loadref  u64   .p 
    loadincr u64   1
    store    u64   .pend 
    load     u64   .p 
    iload    u8    
    loadimm  u64   44 
    jumpne   u64   #8744 
    loadref  u64   .p 
    incrto   u64   1
#8744:
#8743:
    jump           #8737 
    jump           #8738 
#8741:
#8738:
    loadref  u64   .p 
    incrto   u64   1
    jump           #8736 
#8737:
    jump           #8733 
#8735:
    load     u64   .p 
    store    u64   .pstart 
#8745:
    load     u64   .p 
    iload    u8    
    loadimm  u64   0 
    jumpeq   u64   #8748 1
    loadimm  u64   26 
    jumpeq   u64   #8748 1
    loadimm  u64   32 
    jumpeq   u64   #8749 1
    loadimm  u64   9 
    jumpeq   u64   #8749 1
    loadimm  u64   44 
    jumpeq   u64   #8749 1
    loadimm  u64   13 
    jumpeq   u64   #8749 1
    loadimm  u64   10 
    jumpeq   u64   #8749 
    jump           #8750 
#8748:
    load     u64   .p 
    store    u64   .pend 
    jump           #8746 
    jump           #8747 
#8749:
    loadref  u64   .p 
    loadincr u64   1
    store    u64   .pend 
    jump           #8746 
    jump           #8747 
#8750:
#8747:
    loadref  u64   .p 
    incrto   u64   1
    jump           #8745 
#8746:
#8733:
    load     u64   .pend 
    load     u64   .pstart 
    subptr   u64   1
    store    i64   .n 
    load     i64   .n 
    loadimm  i64   256 
    jumplt   i64   #8752 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "@file item too long"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           9
#8752:
#8751:
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .pstart 
    setarg   u64   2
    loadref  u64   mlib.readnextfileitem.str 
    setarg   u64   1
    callp          memcpy 3 0
    loadimm  u64   0 
    loadref  u64   mlib.readnextfileitem.str 
    load     i64   .n 
    istorex  u8    1 0
    loadref  u64   mlib.readnextfileitem.str 
    load     u64   .item 
    istore   u64   
    load     u64   .p 
    load     u64   .fileptr 
    istore   u64   
    loadimm  i64   1 
    setret   i64   
    jump           #8717 
;------------------------
#8717:
    return         
end

proc mlib.ipadstr
    param    u64   .s 
    param    i64   .width 
    param    u64   .padchar 
    local    i64   .n 
    local    i64   .$av_1 
;------------------------
    setcall        1
    load     u64   .s 
    setarg   u64   1
    callf    i64   strlen 1 0
    store    i64   .n 
    load     i64   .width 
    load     i64   .n 
    sub      i64   
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   0 
    jumple   i64   #8757 
#8755:
    setcall        2
    load     u64   .padchar 
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
#8756:
    to             #8755 
    opnd           .$av_1 
#8757:
;------------------------
#8754:
    return         
end

proc mlib.padstr
    rettype  u64   
    param    u64   .s 
    param    i64   .width 
    param    u64   .padchar 
;------------------------
    setcall        2
    load     u64   .s 
    setarg   u64   2
    loadref  u64   mlib.padstr.str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        3
    load     u64   .padchar 
    setarg   u64   3
    load     i64   .width 
    setarg   i64   2
    loadref  u64   mlib.padstr.str 
    setarg   u64   1
    callp          mlib.ipadstr 3 0
    loadref  u64   mlib.padstr.str 
    setret   u64   
    jump           #8758 
;------------------------
#8758:
    return         
end

proc mlib.chr
    rettype  u64   
    param    i64   .c 
;------------------------
    load     i64   .c 
    loadref  u64   mlib.chr.str 
    loadimm  i64   1 
    istorex  u8    1 -1
    loadimm  u64   0 
    loadref  u64   mlib.chr.str 
    loadimm  i64   2 
    istorex  u8    1 -1
    loadref  u64   mlib.chr.str 
    setret   u64   
    jump           #8759 
;------------------------
#8759:
    return         
end

proc mlib.cmpstring
    rettype  i64   
    param    u64   .s 
    param    u64   .t 
    local    i64   .res 
;------------------------
    startmx        
    setcall        2
    load     u64   .t 
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callf    i32   strcmp 2 0
    widen    i32   
    double         
    store    i64   .res 
    loadimm  i64   0 
    jumpge   i64   #8762 
    loadimm  i64   -1 
    resetmx        
    jump           #8761 
#8762:
    load     i64   .res 
    loadimm  i64   0 
    jumple   i64   #8763 
    loadimm  i64   1 
    resetmx        
    jump           #8761 
#8763:
    loadimm  i64   0 
    endmx          
#8761:
    setret   i64   
    jump           #8760 
;------------------------
#8760:
    return         
end

proc mlib.cmpstringn
    rettype  i64   
    param    u64   .s 
    param    u64   .t 
    param    i64   .n 
    local    i64   .res 
;------------------------
    startmx        
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .t 
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callf    i32   strncmp 3 0
    widen    i32   
    double         
    store    i64   .res 
    loadimm  i64   0 
    jumpge   i64   #8766 
    loadimm  i64   -1 
    resetmx        
    jump           #8765 
#8766:
    load     i64   .res 
    loadimm  i64   0 
    jumple   i64   #8767 
    loadimm  i64   1 
    resetmx        
    jump           #8765 
#8767:
    loadimm  i64   0 
    endmx          
#8765:
    setret   i64   
    jump           #8764 
;------------------------
#8764:
    return         
end

proc mlib.eqstring
    rettype  i64   
    param    u64   .s 
    param    u64   .t 
;------------------------
    setcall        2
    load     u64   .t 
    setarg   u64   2
    load     u64   .s 
    setarg   u64   1
    callf    i32   strcmp 2 0
    widen    i32   
    loadimm  i64   0 
    eq       i64   
    setret   i64   
    jump           #8768 
;------------------------
#8768:
    return         
end

proc mlib.cmpbytes
    rettype  i64   
    param    u64   .p 
    param    u64   .q 
    param    i64   .n 
    local    i64   .res 
;------------------------
    startmx        
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .q 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i32   memcmp 3 0
    widen    i32   
    double         
    store    i64   .res 
    loadimm  i64   0 
    jumpge   i64   #8771 
    loadimm  i64   -1 
    resetmx        
    jump           #8770 
#8771:
    load     i64   .res 
    loadimm  i64   0 
    jumple   i64   #8772 
    loadimm  i64   1 
    resetmx        
    jump           #8770 
#8772:
    loadimm  i64   0 
    endmx          
#8770:
    setret   i64   
    jump           #8769 
;------------------------
#8769:
    return         
end

proc mlib.eqbytes
    rettype  i64   
    param    u64   .p 
    param    u64   .q 
    param    i64   .n 
;------------------------
    setcall        3
    load     i64   .n 
    setarg   u64   3
    load     u64   .q 
    setarg   u64   2
    load     u64   .p 
    setarg   u64   1
    callf    i32   memcmp 3 0
    widen    i32   
    loadimm  i64   0 
    eq       i64   
    setret   i64   
    jump           #8773 
;------------------------
#8773:
    return         
end

proc mlib.mseed
    param    u64   .a 
    param    u64   .b 
;------------------------
    load     u64   .a 
    loadref  u64   mlib.seed 
    loadimm  i64   1 
    istorex  u64   8 -8
    load     u64   .b 
    jumpf    u64   #8776 
    load     u64   .b 
    loadref  u64   mlib.seed 
    loadimm  i64   2 
    istorex  u64   8 -8
    jump           #8775 
#8776:
    loadref  u64   mlib.seed 
    loadimm  i64   2 
    addptrx  u64   8 -8
    load     u64   .a 
    bitxorto u64   
#8775:
;------------------------
#8774:
    return         
end

proc mlib.mrandom
    rettype  u64   
    local    i64   .x 
    local    i64   .y 
;------------------------
    loadref  u64   mlib.seed 
    loadimm  i64   1 
    iloadx   i64   8 -8
    store    i64   .x 
    loadref  u64   mlib.seed 
    loadimm  i64   2 
    iloadx   i64   8 -8
    store    i64   .y 
    load     i64   .y 
    loadref  u64   mlib.seed 
    loadimm  i64   1 
    istorex  u64   8 -8
    loadref  u64   .x 
    load     i64   .x 
    loadimm  i64   23 
    shl      i64   
    bitxorto i64   
    load     i64   .x 
    load     i64   .y 
    bitxor   i64   
    load     i64   .x 
    loadimm  i64   17 
    shr      i64   
    bitxor   i64   
    load     i64   .y 
    loadimm  i64   26 
    shr      i64   
    bitxor   i64   
    loadref  u64   mlib.seed 
    loadimm  i64   2 
    istorex  u64   8 -8
    loadref  u64   mlib.seed 
    loadimm  i64   2 
    iloadx   i64   8 -8
    load     i64   .y 
    add      i64   
    setret   u64   
    jump           #8777 
;------------------------
#8777:
    return         
end

proc mlib.mrandomp
    rettype  i64   
;------------------------
    setcall        0
    callf    i64   mlib.mrandom 0 0
    loadimm  i64   9223372036854775807 
    bitand   i64   
    setret   i64   
    jump           #8778 
;------------------------
#8778:
    return         
end

proc mlib.mrandomint
    rettype  i64   
    param    i64   .n 
;------------------------
    setcall        0
    callf    i64   mlib.mrandomp 0 0
    load     i64   .n 
    rem      i64   
    setret   i64   
    jump           #8779 
;------------------------
#8779:
    return         
end

proc mlib.mrandomrange
    rettype  i64   
    param    i64   .a 
    param    i64   .b 
    local    i64   .span 
;------------------------
    load     i64   .b 
    load     i64   .a 
    sub      i64   
    loadimm  i64   1 
    add      i64   
    store    i64   .span 
    load     i64   .span 
    loadimm  i64   0 
    jumpgt   i64   #8782 
    loadimm  i64   0 
    setret   i64   
    jump           #8780 
#8782:
#8781:
    setcall        0
    callf    i64   mlib.mrandomp 0 0
    load     i64   .span 
    rem      i64   
    load     i64   .a 
    add      i64   
    setret   i64   
    jump           #8780 
;------------------------
#8780:
    return         
end

proc mlib.mrandomreal
    rettype  r64   
    local    r64   .x 
;------------------------
#8784:
    setcall        0
    callf    i64   mlib.mrandomp 0 0
    float    r64 i64 
    loadimm  r64   9223372036854775800.00000000000000000000 
    div      r64   
    store    r64   .x 
#8785:
    load     r64   .x 
    loadimm  r64   1.00000000000000000000 
    jumpeq   r64   #8784 
#8786:
    load     r64   .x 
    setret   r64   
    jump           #8783 
;------------------------
#8783:
    return         
end

proc mlib.mrandomreal1
    rettype  r64   
;------------------------
    setcall        0
    callf    i64   mlib.mrandomp 0 0
    loadimm  i64   9223372036854775807 
    div      i64   
    float    r64 i64 
    setret   r64   
    jump           #8787 
;------------------------
#8787:
    return         
end

proc mlib.readline
    rettype  u64   
;------------------------
    callp          msys.m$read_conline 0 0
    load     u64   msys.rd_buffer 
    setret   u64   
    jump           #8788 
;------------------------
#8788:
    return         
end

proc mlib.findfunction
    rettype  u64   
    param    u64   .name 
    local    i64   .$av_1 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
;SYSCALL
    load     i64   $nprocs 
    store    i64   .$av_1 
    load     i64   .$av_1 
    loadimm  i64   1 
    jumplt   i64   #8792 
#8790:
    setcall        2
    load     u64   .name 
    setarg   u64   2
;SYSCALL
    loadref  u64   $procname 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #8794 
;SYSCALL
    loadref  u64   $procaddr 
    load     i64   .i 
    iloadx   u64   8 -8
    setret   u64   
    jump           #8789 
#8794:
#8793:
#8791:
    forup          #8790 1
    opnd           .i 
    opnd           .$av_1 
#8792:
    loadimm  u64   0 
    setret   u64   
    jump           #8789 
;------------------------
#8789:
    return         
end

proc mlib.roundtoblock
    rettype  i64   
    param    i64   .n 
    param    i64   .align 
;------------------------
    load     i64   .n 
    load     i64   .align 
    loadimm  i64   1 
    sub      i64   
    bitand   i64   
    loadimm  i64   0 
    jumpne   i64   #8797 
    load     i64   .n 
    setret   i64   
    jump           #8795 
#8797:
#8796:
    load     i64   .n 
    load     i64   .align 
    load     i64   .n 
    load     i64   .align 
    loadimm  i64   1 
    sub      i64   
    bitand   i64   
    sub      i64   
    add      i64   
    setret   i64   
    jump           #8795 
;------------------------
#8795:
    return         
end

proc mwindows.os_init
    local    i64   .i 
    local    i64   .count 
    local    u8:22 .info 
;------------------------
    setcall        1
    loadimm  i64   -11 
    truncate i64 u32 
    setarg   u32   1
    callf    u64   GetStdHandle 1 0
    store    u64   mwindows.hconsole 
    setcall        1
    loadimm  i64   -10 
    truncate i64 u32 
    setarg   u32   1
    callf    u64   GetStdHandle 1 0
    store    u64   mwindows.hconsolein 
    loadimm  i64   0 
    loadref  u64   mwindows.lastkey 
    loadimm  i64   8 
    istorex  u16   1 0
    loadimm  i64   0 
    store    i64   mwindows.keypending 
    setcall        2
    loadimm  i64   1 
    setarg   i64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   SetConsoleCtrlHandler 2 0
    unload   i64   
    setcall        2
    loadimm  i64   3 
    setarg   u32   2
    load     u64   mwindows.hconsole 
    setarg   u64   1
    callf    i64   SetConsoleMode 2 0
    unload   i64   
    loadimm  i64   1 
    store    i64   mwindows.init_flag 
;------------------------
#8798:
    return         
end

proc mwindows.os_execwait
    rettype  i64   
    param    u64   .cmdline 
    param    i64   .newconsole 
    param    u64   .workdir 
    local    u32   .exitcode 
    local    i64   .status 
    local    i64   .cflags 
    local    u8:104 .si 
    local    u8:24 .xpi 
;------------------------
    loadimm  i64   0 
    store    i64   .cflags 
    loadref  u64   .si 
    clear    u8:104 
    loadref  u64   .xpi 
    clear    u8:24 
    load     i64   .newconsole 
    switch         #8801 0 2
    opnd           #8802 
#8801:
    swlabel        #8803 
    swlabel        #8804 
    swlabel        #8805 
    endsw          
#8803:
    loadimm  i64   32 
    store    i64   .cflags 
    jump           #8800 
#8804:
    loadimm  i64   48 
    store    i64   .cflags 
    jump           #8800 
#8805:
    loadimm  i64   48 
    store    i64   .cflags 
    jump           #8800 
#8802:
#8800:
    loadimm  i64   104 
    loadref  u64   .si 
    loadimm  i64   0 
    istorex  u32   1 0
    setcall        10
    loadref  u64   .xpi 
    setarg   u64   10
    loadref  u64   .si 
    setarg   u64   9
    loadimm  u64   0 
    setarg   u64   8
    loadimm  u64   0 
    setarg   u64   7
    load     i64   .cflags 
    setarg   u32   6
    loadimm  i64   1 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .cmdline 
    setarg   u64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   CreateProcessA 10 0
    store    i64   .status 
    load     i64   .status 
    loadimm  i64   0 
    jumpne   i64   #8807 
    setcall        0
    callf    u32   GetLastError 0 0
    widen    u32   
    store    i64   .status 
    setcall        2
    load     i64   .status 
    setarg   i64   2
    loadimm  u64   "Winexec error: %lld\n"
    setarg   u64   1
    callp          printf 2 2
    loadimm  i64   -1 
    setret   i64   
    jump           #8799 
#8807:
#8806:
    setcall        2
    loadimm  i64   4294967295 
    setarg   u32   2
    loadref  u64   .xpi 
    iload    u64   
    setarg   u64   1
    callf    u32   WaitForSingleObject 2 0
    unload   u32   
    setcall        2
    loadref  u64   .exitcode 
    setarg   u64   2
    loadref  u64   .xpi 
    iload    u64   
    setarg   u64   1
    callf    i64   GetExitCodeProcess 2 0
    unload   i64   
    setcall        1
    loadref  u64   .xpi 
    iload    u64   
    setarg   u64   1
    callf    i64   CloseHandle 1 0
    unload   i64   
    setcall        1
    loadref  u64   .xpi 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   CloseHandle 1 0
    unload   i64   
    load     u32   .exitcode 
    setret   i64   
    jump           #8799 
;------------------------
#8799:
    return         
end

proc mwindows.os_execcmd
    rettype  i64   
    param    u64   .cmdline 
    param    i64   .newconsole 
    local    u32   .exitcode 
    local    i64   .i 
    local    i64   .j 
    local    i64   .k 
    local    u8:104 .si 
    local    u8:24 .xpi 
;------------------------
    loadref  u64   .si 
    clear    u8:104 
    loadref  u64   .xpi 
    clear    u8:24 
    loadimm  i64   104 
    loadref  u64   .si 
    loadimm  i64   0 
    istorex  u32   1 0
    setcall        10
    loadref  u64   .xpi 
    setarg   u64   10
    loadref  u64   .si 
    setarg   u64   9
    loadimm  u64   0 
    setarg   u64   8
    loadimm  u64   0 
    setarg   u64   7
    loadimm  i64   32 
    startmx        
    load     i64   .newconsole 
    jumpf    i64   #8811 
    loadimm  i64   16 
    resetmx        
    jump           #8810 
#8811:
    loadimm  i64   0 
    endmx          
#8810:
    bitor    i64   
    setarg   u32   6
    loadimm  i64   1 
    setarg   i64   5
    loadimm  u64   0 
    setarg   u64   4
    loadimm  u64   0 
    setarg   u64   3
    load     u64   .cmdline 
    setarg   u64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    i64   CreateProcessA 10 0
    unload   i64   
    setcall        1
    loadref  u64   .xpi 
    iload    u64   
    setarg   u64   1
    callf    i64   CloseHandle 1 0
    unload   i64   
    setcall        1
    loadref  u64   .xpi 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    i64   CloseHandle 1 0
    unload   i64   
    loadimm  i64   1 
    setret   i64   
    jump           #8809 
;------------------------
#8809:
    return         
end

proc mwindows.os_getch
    rettype  i64   
    local    i64   .k 
;------------------------
    setcall        0
    callf    i64   mwindows.os_getchx 0 0
    loadimm  i64   255 
    bitand   i64   
    store    i64   .k 
    load     i64   .k 
    setret   i64   
    jump           #8812 
;------------------------
#8812:
    return         
end

proc mwindows.os_kbhit
    rettype  i64   
    local    u32   .count 
;------------------------
    load     i64   mwindows.init_flag 
    jumpt    i64   #8815 
    setcall        0
    callp          mwindows.os_init 0 0
#8815:
#8814:
    setcall        2
    loadref  u64   .count 
    setarg   u64   2
    load     u64   mwindows.hconsolein 
    setarg   u64   1
    callf    i64   GetNumberOfConsoleInputEvents 2 0
    unload   i64   
    load     u32   .count 
    loadimm  i64   1 
    gt       i64   
    setret   i64   
    jump           #8813 
;------------------------
#8813:
    return         
end

proc mwindows.os_getdllinst
    rettype  u64   
    param    u64   .name 
    local    u64   .hinst 
;------------------------
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   LoadLibraryA 1 0
    store    u64   .hinst 
    load     u64   .hinst 
    setret   u64   
    jump           #8816 
;------------------------
#8816:
    return         
end

proc mwindows.os_getdllprocaddr
    rettype  u64   
    param    i64   .hinst 
    param    u64   .name 
;------------------------
    setcall        2
    load     u64   .name 
    setarg   u64   2
    load     i64   .hinst 
    setarg   u64   1
    callf    u64   GetProcAddress 2 0
    setret   u64   
    jump           #8817 
;------------------------
#8817:
    return         
end

proc mwindows.os_initwindows
;------------------------
    setcall        0
    callp          mwindows.os_init 0 0
    setcall        1
    loadimm  u64   "pcc001"
    setarg   u64   1
    callp          mwindows.os_gxregisterclass 1 0
;------------------------
#8818:
    return         
end

proc mwindows.os_gxregisterclass
    param    u64   .classname 
    local    u8:80 .r 
;------------------------
    load     u8    mwindows.os_gxregisterclass.registered 
    jumpf    i64   #8822 
    jump           #8820 
#8822:
#8821:
    loadref  u64   .r 
    clear    u8:80 
    loadimm  i64   80 
    loadref  u64   .r 
    loadimm  i64   0 
    istorex  u32   1 0
    loadimm  i64   40 
    loadref  u64   .r 
    loadimm  i64   4 
    istorex  u32   1 0
    loadref  u64   mwindows.mainwndproc 
    loadref  u64   .r 
    loadimm  i64   8 
    istorex  u64   1 0
    loadimm  u64   0 
    loadref  u64   .r 
    loadimm  i64   24 
    istorex  u64   1 0
    loadimm  u64   0 
    loadref  u64   .r 
    loadimm  i64   32 
    istorex  u64   1 0
    setcall        2
    loadimm  u64   32512 
    setarg   u64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   LoadCursorA 2 0
    loadref  u64   .r 
    loadimm  i64   40 
    istorex  u64   1 0
    loadimm  u64   16 
    loadref  u64   .r 
    loadimm  i64   48 
    istorex  u64   1 0
    loadimm  u64   0 
    loadref  u64   .r 
    loadimm  i64   56 
    istorex  u64   1 0
    load     u64   .classname 
    loadref  u64   .r 
    loadimm  i64   64 
    istorex  u64   1 0
    loadimm  u64   0 
    loadref  u64   .r 
    loadimm  i64   72 
    istorex  u64   1 0
    setcall        1
    loadref  u64   .r 
    setarg   u64   1
    callf    u32   RegisterClassExA 1 0
    widen    u32   
    loadimm  i64   0 
    jumpne   i64   #8824 
    setcall        3
    setcall        0
    callf    u32   GetLastError 0 0
    widen    u32   
    setarg   i64   3
    load     u64   .classname 
    setarg   u64   2
    loadimm  u64   "Regclass error: %lld %lld\n"
    setarg   u64   1
    callp          printf 3 2
    stop           1
#8824:
#8823:
    loadimm  i64   1 
    store    u8    mwindows.os_gxregisterclass.registered 
;------------------------
#8820:
    return         
end

proc mwindows.mainwndproc
    rettype  i64   
    param    u64   .hwnd 
    param    u32   .message 
    param    u64   .wparam 
    param    u64   .lparam 
    local    u8:48 .m 
    local    i64   .i 
    local    i64   .result 
    local    i64   .l 
;------------------------
    load     u64   .hwnd 
    loadref  u64   .m 
    loadimm  i64   0 
    istorex  u64   1 0
    load     u32   .message 
    loadref  u64   .m 
    loadimm  i64   8 
    istorex  u32   1 0
    load     u64   .wparam 
    loadref  u64   .m 
    loadimm  i64   16 
    istorex  u64   1 0
    load     u64   .lparam 
    loadref  u64   .m 
    loadimm  i64   24 
    istorex  u64   1 0
    loadimm  i64   0 
    loadref  u64   .m 
    loadimm  i64   40 
    istorex  i32   1 0
    loadimm  i64   0 
    loadref  u64   .m 
    loadimm  i64   44 
    istorex  i32   1 0
    load     u64   mwindows.wndproc_callbackfn 
    jumpf    u64   #8828 
    setcall        1
    loadref  u64   .m 
    setarg   u64   1
    load     u64   mwindows.wndproc_callbackfn 
    icallf   i64   1 0
    store    i64   .result 
    jump           #8827 
#8828:
    loadimm  i64   0 
    store    i64   .result 
#8827:
    loadref  u64   .m 
    loadimm  i64   8 
    iloadx   u32   1 0
    loadimm  i64   2 
    jumpne   i64   #8830 
    loadimm  i64   0 
    setret   i64   
    jump           #8826 
#8830:
#8829:
    startmx        
    load     i64   .result 
    jumpt    i64   #8832 
    setcall        4
    load     u64   .lparam 
    setarg   u64   4
    load     u64   .wparam 
    setarg   u64   3
    load     u32   .message 
    setarg   u32   2
    load     u64   .hwnd 
    setarg   u64   1
    callf    i64   DefWindowProcA 4 0
    resetmx        
    jump           #8831 
#8832:
    loadimm  i64   0 
    endmx          
#8831:
    setret   i64   
    jump           #8826 
;------------------------
#8826:
    return         
end

proc mwindows.os_setmesshandler
    param    u64   .addr 
;------------------------
    load     u64   .addr 
    store    u64   mwindows.wndproc_callbackfn 
;------------------------
#8833:
    return         
end

proc mwindows.os_getchx
    rettype  i64   
    local    i64   .count 
    local    i64   .charcode 
    local    i64   .keyshift 
    local    i64   .keycode 
    local    i64   .altdown 
    local    i64   .ctrldown 
    local    i64   .shiftdown 
    local    i64   .capslock 
;------------------------
    load     i64   mwindows.init_flag 
    jumpt    i64   #8836 
    setcall        0
    callp          mwindows.os_init 0 0
#8836:
#8835:
    load     i64   mwindows.keypending 
    jumpf    i64   #8838 
    load     u8:20 mwindows.pendkey 
    store    u8:20 mwindows.lastkey 
    loadimm  i64   0 
    store    i64   mwindows.keypending 
    jump           #8837 
#8838:
    loadref  u64   mwindows.lastkey 
    loadimm  i64   8 
    iloadx   u16   1 0
    loadimm  i64   0 
    jumpne   i64   #8840 
#8841:
    loadimm  i64   0 
    store    i64   .count 
    setcall        4
    loadref  u64   .count 
    setarg   u64   4
    loadimm  i64   1 
    setarg   u32   3
    loadref  u64   mwindows.lastkey 
    setarg   u64   2
    load     u64   mwindows.hconsolein 
    setarg   u64   1
    callf    i64   ReadConsoleInputA 4 0
    unload   i64   
#8842:
    loadref  u64   mwindows.lastkey 
    iload    u16   
    loadimm  i64   1 
    jumpne   i64   #8841 
    loadref  u64   mwindows.lastkey 
    loadimm  i64   4 
    iloadx   u32   1 0
    loadimm  i64   1 
    jumpne   i64   #8841 
#8843:
#8840:
#8839:
#8837:
    startmx        
    loadref  u64   mwindows.lastkey 
    loadimm  i64   16 
    iloadx   u32   1 0
    loadimm  i64   3 
    bitand   i64   
    jumpf    i64   #8845 
    loadimm  i64   1 
    resetmx        
    jump           #8844 
#8845:
    loadimm  i64   0 
    endmx          
#8844:
    store    i64   .altdown 
    startmx        
    loadref  u64   mwindows.lastkey 
    loadimm  i64   16 
    iloadx   u32   1 0
    loadimm  i64   12 
    bitand   i64   
    jumpf    i64   #8847 
    loadimm  i64   1 
    resetmx        
    jump           #8846 
#8847:
    loadimm  i64   0 
    endmx          
#8846:
    store    i64   .ctrldown 
    startmx        
    loadref  u64   mwindows.lastkey 
    loadimm  i64   16 
    iloadx   u32   1 0
    loadimm  i64   16 
    bitand   i64   
    jumpf    i64   #8849 
    loadimm  i64   1 
    resetmx        
    jump           #8848 
#8849:
    loadimm  i64   0 
    endmx          
#8848:
    store    i64   .shiftdown 
    startmx        
    loadref  u64   mwindows.lastkey 
    loadimm  i64   16 
    iloadx   u32   1 0
    loadimm  i64   128 
    bitand   i64   
    jumpf    i64   #8851 
    loadimm  i64   1 
    resetmx        
    jump           #8850 
#8851:
    loadimm  i64   0 
    endmx          
#8850:
    store    i64   .capslock 
    loadref  u64   mwindows.lastkey 
    loadimm  i64   8 
    addptrx  u64   1 0
    decrto   u16   1
    loadref  u64   mwindows.lastkey 
    loadimm  i64   14 
    iloadx   u8    1 0
    store    i64   .charcode 
    loadref  u64   mwindows.lastkey 
    loadimm  i64   10 
    iloadx   u16   1 0
    loadimm  i64   255 
    bitand   i64   
    store    i64   .keycode 
    load     i64   .charcode 
    loadimm  i64   0 
    jumpge   i64   #8853 
    load     i64   .charcode 
    loadimm  i64   -128 
    jumpge   i64   #8855 
    loadimm  i64   0 
    store    i64   .charcode 
    jump           #8854 
#8855:
    loadref  u64   .charcode 
    loadimm  i64   256 
    addto    i64   
#8854:
#8853:
#8852:
    load     i64   .altdown 
    jumpf    i64   #8857 
    load     i64   .ctrldown 
    jumpf    i64   #8857 
    load     i64   .charcode 
    loadimm  i64   166 
    jumpne   i64   #8857 
    loadimm  i64   0 
    double         
    store    i64   .ctrldown 
    store    i64   .altdown 
    jump           #8856 
#8857:
    load     i64   .altdown 
    jumpt    i64   #8860 
    load     i64   .ctrldown 
    jumpf    i64   #8859 
#8860:
    loadimm  i64   0 
    store    i64   .charcode 
    load     i64   .keycode 
    loadimm  i64   65 
    jumplt   i64   #8862 
    load     i64   .keycode 
    loadimm  i64   90 
    jumpgt   i64   #8862 
    load     i64   .keycode 
    loadimm  i64   64 
    sub      i64   
    store    i64   .charcode 
#8862:
#8861:
#8859:
#8858:
#8856:
    load     i64   .capslock 
    loadimm  i64   3 
    shl      i64   
    load     i64   .altdown 
    loadimm  i64   2 
    shl      i64   
    bitor    i64   
    load     i64   .ctrldown 
    loadimm  i64   1 
    shl      i64   
    bitor    i64   
    load     i64   .shiftdown 
    bitor    i64   
    store    i64   .keyshift 
    load     i64   .keyshift 
    loadimm  i64   24 
    shl      i64   
    load     i64   .keycode 
    loadimm  i64   16 
    shl      i64   
    bitor    i64   
    load     i64   .charcode 
    bitor    i64   
    setret   i64   
    jump           #8834 
;------------------------
#8834:
    return         
end

proc mwindows.os_getos
    rettype  u64   
;------------------------
    startmx        
    loadimm  i64   64 
    loadimm  i64   32 
    jumpne   i64   #8865 
    loadimm  u64   "W32"
    resetmx        
    jump           #8864 
#8865:
    loadimm  u64   "W64"
    endmx          
#8864:
    setret   u64   
    jump           #8863 
;------------------------
#8863:
    return         
end

proc mwindows.os_gethostsize
    rettype  i64   
;------------------------
    loadimm  i64   64 
    setret   i64   
    jump           #8868 
;------------------------
#8868:
    return         
end

proc mwindows.os_shellexec
    rettype  i64   
    param    u64   .opc 
    param    u64   .file 
;------------------------
    setcall        1
    load     u64   .file 
    setarg   u64   1
    callf    i32   system 1 0
    widen    i32   
    setret   i64   
    jump           #8869 
;------------------------
#8869:
    return         
end

proc mwindows.os_sleep
    param    i64   .a 
;------------------------
    setcall        1
    load     i64   .a 
    setarg   u32   1
    callp          Sleep 1 0
;------------------------
#8870:
    return         
end

proc mwindows.os_getstdin
    rettype  u64   
;------------------------
    setcall        2
    loadimm  u64   "rb"
    setarg   u64   2
    loadimm  u64   "con"
    setarg   u64   1
    callf    u64   fopen 2 0
    setret   u64   
    jump           #8871 
;------------------------
#8871:
    return         
end

proc mwindows.os_getstdout
    rettype  u64   
;------------------------
    setcall        2
    loadimm  u64   "wb"
    setarg   u64   2
    loadimm  u64   "con"
    setarg   u64   1
    callf    u64   fopen 2 0
    setret   u64   
    jump           #8874 
;------------------------
#8874:
    return         
end

proc mwindows.os_gethostname
    rettype  u64   
;------------------------
    setcall        3
    loadimm  i64   300 
    setarg   u32   3
    loadref  u64   mwindows.os_gethostname.name 
    setarg   u64   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u32   GetModuleFileNameA 3 0
    unload   u32   
    loadref  u64   mwindows.os_gethostname.name 
    setret   u64   
    jump           #8877 
;------------------------
#8877:
    return         
end

proc mwindows.os_getmpath
    rettype  u64   
;------------------------
    loadimm  u64   "C:\\m\\"
    setret   u64   
    jump           #8878 
;------------------------
#8878:
    return         
end

proc mwindows.os_clock
    rettype  i64   
;------------------------
    setcall        0
    callf    i32   clock 0 0
    widen    i32   
    setret   i64   
    jump           #8880 
;------------------------
#8880:
    return         
end

proc mwindows.os_ticks
    rettype  i64   
;------------------------
    setcall        0
    callf    i64   GetTickCount64 0 0
    setret   i64   
    jump           #8881 
;------------------------
#8881:
    return         
end

proc mwindows.os_hptimer
    rettype  i64   
    local    i64   .t 
;------------------------
    setcall        1
    loadref  u64   .t 
    setarg   u64   1
    callf    u32   QueryPerformanceCounter 1 0
    unload   u32   
    load     i64   .t 
    setret   i64   
    jump           #8882 
;------------------------
#8882:
    return         
end

proc mwindows.os_iswindows
    rettype  i64   
;------------------------
    loadimm  i64   1 
    setret   i64   
    jump           #8883 
;------------------------
#8883:
    return         
end

proc mwindows.os_getsystime
    param    u64   .tm 
;------------------------
    setcall        1
    load     u64   .tm 
    setarg   u64   1
    callp          GetLocalTime 1 0
;------------------------
#8884:
    return         
end

proc mwindows.os_peek
    local    i64   .ticks 
    local    u8:100 .m 
;------------------------
    setcall        0
    callf    i64   GetTickCount64 0 0
    store    i64   .ticks 
    load     i64   .ticks 
    load     i64   mwindows.os_peek.lastticks 
    sub      i64   
    loadimm  i64   1000 
    jumplt   i64   #8887 
    load     i64   .ticks 
    store    i64   mwindows.os_peek.lastticks 
    setcall        5
    loadimm  i64   0 
    setarg   u32   5
    loadimm  i64   0 
    setarg   u32   4
    loadimm  i64   0 
    setarg   u32   3
    loadimm  u64   0 
    setarg   u64   2
    loadref  u64   .m 
    setarg   u64   1
    callf    u32   PeekMessageA 5 0
    unload   u32   
#8887:
#8886:
;------------------------
#8885:
    return         
end

proc mwindows.os_allocexecmem
    rettype  u64   
    param    i64   .n 
    local    u64   .p 
    local    u32   .oldprot 
    local    i64   .status 
;------------------------
    setcall        4
    loadimm  i64   1 
    setarg   u32   4
    loadimm  i64   12288 
    setarg   u32   3
    load     i64   .n 
    setarg   u32   2
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   VirtualAlloc 4 0
    store    u64   .p 
    load     u64   .p 
    loadimm  u64   0 
    jumpne   u64   #8890 
    loadimm  u64   0 
    setret   u64   
    jump           #8888 
#8890:
#8889:
    setcall        4
    loadref  u64   .oldprot 
    setarg   u64   4
    loadimm  i64   64 
    setarg   u32   3
    load     i64   .n 
    setarg   u32   2
    load     u64   .p 
    setarg   u64   1
    callf    u32   VirtualProtect 4 0
    widen    u32   
    store    i64   .status 
    load     i64   .status 
    loadimm  i64   0 
    jumpne   i64   #8892 
    loadimm  u64   0 
    setret   u64   
    jump           #8888 
#8892:
#8891:
    load     u64   .p 
    setret   u64   
    jump           #8888 
;------------------------
#8888:
    return         
end

proc mwindows.start
;------------------------
;------------------------
#8893:
    return         
end

;
proc mwindllc.os_calldllfunction
    rettype  u64   
    param    u64   .fnaddr 
    param    i64   .retcode 
    param    i64   .nargs 
    param    u64   .args 
    param    u64   .argcodes 
    local    u64   .a 
    local    r64   .x 
    local    i64   .oddstack 
    local    i64   .nextra 
    local    i64   .pushedbytes 
;------------------------
    startmx        
    load     i64   .retcode 
    loadimm  i64   73 
    jumpne   i64   #8896 
    setcall        3
    load     i64   .nargs 
    setarg   i64   3
    load     u64   .args 
    setarg   u64   2
    load     u64   .fnaddr 
    setarg   u64   1
    callf    u64   mwindllc.calldll_cint 3 0
    resetmx        
    jump           #8895 
#8896:
    setcall        3
    load     i64   .nargs 
    setarg   i64   3
    load     u64   .args 
    setarg   u64   2
    load     u64   .fnaddr 
    setarg   u64   1
    callf    u64   mwindllc.calldll_creal 3 0
    endmx          
#8895:
    setret   u64   
    jump           #8894 
;------------------------
#8894:
    return         
end

proc mwindllc.os_pushargs
    rettype  u64   
    param    u64   .args 
    param    i64   .nargs 
    param    i64   .nextra 
    param    u64   .fnaddr 
    param    i64   .isfloat 
    local    u64   .a 
    local    r64   .x 
;------------------------
    setcall        5
    loadimm  u64   0 
    setarg   u64   5
    load     u64   .args 
    setarg   u64   4
    load     i64   .nargs 
    setarg   i64   3
    startmx        
    load     i64   .isfloat 
    jumpf    i64   #8899 
    loadimm  i64   0 
    resetmx        
    jump           #8898 
#8899:
    loadimm  i64   73 
    endmx          
#8898:
    setarg   i64   2
    load     u64   .fnaddr 
    setarg   u64   1
    callf    u64   mwindllc.os_calldllfunction 5 0
    setret   u64   
    jump           #8897 
;------------------------
#8897:
    return         
end

proc mwindllc.calldll_cint
    rettype  i64   
    param    u64   .fnaddr 
    param    u64   .params 
    param    i64   .nparams 
;------------------------
    load     i64   .nparams 
    switch         #8902 0 14
    opnd           #8903 
#8902:
    swlabel        #8904 
    swlabel        #8905 
    swlabel        #8906 
    swlabel        #8907 
    swlabel        #8908 
    swlabel        #8909 
    swlabel        #8910 
    swlabel        #8903 
    swlabel        #8903 
    swlabel        #8911 
    swlabel        #8912 
    swlabel        #8913 
    swlabel        #8914 
    swlabel        #8903 
    swlabel        #8915 
    endsw          
#8904:
    setcall        0
    load     u64   .fnaddr 
    icallf   i64   0 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8905:
    setcall        1
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   1 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8906:
    setcall        2
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   2 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8907:
    setcall        3
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   3 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8908:
    setcall        4
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    setarg   i64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   4 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8909:
    setcall        5
    load     u64   .params 
    loadimm  i64   5 
    iloadx   i64   8 -8
    setarg   i64   5
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    setarg   i64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   5 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8910:
    setcall        6
    load     u64   .params 
    loadimm  i64   6 
    iloadx   i64   8 -8
    setarg   i64   6
    load     u64   .params 
    loadimm  i64   5 
    iloadx   i64   8 -8
    setarg   i64   5
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    setarg   i64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   6 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8911:
    setcall        9
    load     u64   .params 
    loadimm  i64   9 
    iloadx   i64   8 -8
    setarg   i64   9
    load     u64   .params 
    loadimm  i64   8 
    iloadx   i64   8 -8
    setarg   i64   8
    load     u64   .params 
    loadimm  i64   7 
    iloadx   i64   8 -8
    setarg   i64   7
    load     u64   .params 
    loadimm  i64   6 
    iloadx   i64   8 -8
    setarg   i64   6
    load     u64   .params 
    loadimm  i64   5 
    iloadx   i64   8 -8
    setarg   i64   5
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    setarg   i64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   9 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8912:
    setcall        10
    load     u64   .params 
    loadimm  i64   10 
    iloadx   i64   8 -8
    setarg   i64   10
    load     u64   .params 
    loadimm  i64   9 
    iloadx   i64   8 -8
    setarg   i64   9
    load     u64   .params 
    loadimm  i64   8 
    iloadx   i64   8 -8
    setarg   i64   8
    load     u64   .params 
    loadimm  i64   7 
    iloadx   i64   8 -8
    setarg   i64   7
    load     u64   .params 
    loadimm  i64   6 
    iloadx   i64   8 -8
    setarg   i64   6
    load     u64   .params 
    loadimm  i64   5 
    iloadx   i64   8 -8
    setarg   i64   5
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    setarg   i64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   10 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8913:
    setcall        11
    load     u64   .params 
    loadimm  i64   11 
    iloadx   i64   8 -8
    setarg   i64   11
    load     u64   .params 
    loadimm  i64   10 
    iloadx   i64   8 -8
    setarg   i64   10
    load     u64   .params 
    loadimm  i64   9 
    iloadx   i64   8 -8
    setarg   i64   9
    load     u64   .params 
    loadimm  i64   8 
    iloadx   i64   8 -8
    setarg   i64   8
    load     u64   .params 
    loadimm  i64   7 
    iloadx   i64   8 -8
    setarg   i64   7
    load     u64   .params 
    loadimm  i64   6 
    iloadx   i64   8 -8
    setarg   i64   6
    load     u64   .params 
    loadimm  i64   5 
    iloadx   i64   8 -8
    setarg   i64   5
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    setarg   i64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   11 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8914:
    setcall        12
    load     u64   .params 
    loadimm  i64   12 
    iloadx   i64   8 -8
    setarg   i64   12
    load     u64   .params 
    loadimm  i64   11 
    iloadx   i64   8 -8
    setarg   i64   11
    load     u64   .params 
    loadimm  i64   10 
    iloadx   i64   8 -8
    setarg   i64   10
    load     u64   .params 
    loadimm  i64   9 
    iloadx   i64   8 -8
    setarg   i64   9
    load     u64   .params 
    loadimm  i64   8 
    iloadx   i64   8 -8
    setarg   i64   8
    load     u64   .params 
    loadimm  i64   7 
    iloadx   i64   8 -8
    setarg   i64   7
    load     u64   .params 
    loadimm  i64   6 
    iloadx   i64   8 -8
    setarg   i64   6
    load     u64   .params 
    loadimm  i64   5 
    iloadx   i64   8 -8
    setarg   i64   5
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    setarg   i64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   12 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8915:
    setcall        14
    load     u64   .params 
    loadimm  i64   14 
    iloadx   i64   8 -8
    setarg   i64   14
    load     u64   .params 
    loadimm  i64   13 
    iloadx   i64   8 -8
    setarg   i64   13
    load     u64   .params 
    loadimm  i64   12 
    iloadx   i64   8 -8
    setarg   i64   12
    load     u64   .params 
    loadimm  i64   11 
    iloadx   i64   8 -8
    setarg   i64   11
    load     u64   .params 
    loadimm  i64   10 
    iloadx   i64   8 -8
    setarg   i64   10
    load     u64   .params 
    loadimm  i64   9 
    iloadx   i64   8 -8
    setarg   i64   9
    load     u64   .params 
    loadimm  i64   8 
    iloadx   i64   8 -8
    setarg   i64   8
    load     u64   .params 
    loadimm  i64   7 
    iloadx   i64   8 -8
    setarg   i64   7
    load     u64   .params 
    loadimm  i64   6 
    iloadx   i64   8 -8
    setarg   i64   6
    load     u64   .params 
    loadimm  i64   5 
    iloadx   i64   8 -8
    setarg   i64   5
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    setarg   i64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    setarg   i64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   i64   14 0
    setret   i64   
    jump           #8900 
    jump           #8901 
#8903:
    callp          msys.m$print_startcon 0 0
    load     i64   .nparams 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "calldll/c/int unsupported # of params"
    callp          msys.m$print_str_nf 1 0
    load     i64   .nparams 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           1
#8901:
    loadimm  i64   0 
    setret   i64   
    jump           #8900 
;------------------------
#8900:
    return         
end

proc mwindllc.calldll_creal
    rettype  i64   
    param    u64   .fnaddr 
    param    u64   .params 
    param    i64   .nparams 
    local    r64   .x 
;------------------------
    load     i64   .nparams 
    switch         #8919 0 2
    opnd           #8920 
#8919:
    swlabel        #8921 
    swlabel        #8922 
    swlabel        #8923 
    endsw          
#8921:
    setcall        0
    load     u64   .fnaddr 
    icallf   r64   0 0
    fix      i64 r64 
    setret   i64   
    jump           #8917 
    jump           #8918 
#8922:
    setcall        4
    load     u64   .params 
    loadimm  i64   4 
    iloadx   i64   8 -8
    float    r64 i64 
    setarg   r64   4
    load     u64   .params 
    loadimm  i64   3 
    iloadx   i64   8 -8
    float    r64 i64 
    setarg   r64   3
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    float    r64 i64 
    setarg   r64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    float    r64 i64 
    setarg   r64   1
    callp          mwindllc.os_dummycall 4 0
    setcall        1
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   r64   1 0
    store    r64   .x 
    jump           #8918 
#8923:
    setcall        2
    load     u64   .params 
    loadimm  i64   2 
    iloadx   i64   8 -8
    setarg   i64   2
    load     u64   .params 
    loadimm  i64   1 
    iloadx   i64   8 -8
    setarg   i64   1
    load     u64   .fnaddr 
    icallf   r64   2 0
    store    r64   .x 
    jump           #8918 
#8920:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "calldll/c/real too many params"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           1
#8918:
    load     r64   .x 
    typepun  i64 r64 
    setret   i64   
    jump           #8917 
;------------------------
#8917:
    return         
end

proc mwindllc.os_dummycall
    param    r64   .a 
    param    r64   .b 
    param    r64   .c 
    param    r64   .d 
;------------------------
;------------------------
#8925:
    return         
end

proc main*
    local    u64   .p 
    local    u64   .q 
    local    u64   .r 
    local    i64   .m 
    local    i64   .fileno 
    local    i64   .ntokens 
    local    i64   .t 
    callp          msys.start 0 0
    callp          mm_cli.start 0 0
;------------------------
    setcall        0
    callf    i64   mwindows.os_clock 0 0
    store    i64   mm_cli.startclock 
    setcall        0
    callp          mm_cli.stepruncount 0 0
    setcall        0
    callp          mm_cli.initdata 0 0
    setcall        0
    callp          mm_cli.getinputoptions 0 0
    setcall        0
    callf    i32   clock 0 0
    widen    i32   
    store    i64   mm_cli.rpclock 
    setcall        1
    load     u64   mm_cli.inputfile 
    setarg   u64   1
    callp          mm_modules.readprojectfile 1 0
    load     i64   mm_decls.fverbose 
    loadimm  i64   1 
    jumplt   i64   #8928 
    load     i64   mm_decls.passlevel 
    loadimm  i64   13 
    jumpne   i64   #8930 
    load     u8    mm_cli.msfile 
    jumpf    i64   #8933 
    load     i64   mm_decls.fverbose 
    loadimm  i64   1 
    jumple   i64   #8932 
#8933:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Compiling"
    callp          msys.m$print_str_nf 1 0
    load     u64   mm_cli.inputfile 
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "to memory"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#8932:
#8931:
    jump           #8929 
#8930:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "M7 Compiling # to #"
    callp          msys.m$print_setfmt 1 0
    loadimm  u64   "14jlp-"
    load     u64   mm_cli.inputfile 
    callp          msys.m$print_str 2 0
    setcall        2
    load     u64   mm_cli.outext 
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mlib.changeext 2 0
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_space 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#8929:
#8928:
#8927:
    setcall        1
    loadimm  u64   "mx.log"
    setarg   u64   1
    callf    i32   remove 1 0
    unload   i32   
    setcall        0
    callp          mm_cli.do_loadmodules 0 0
    setcall        0
    callp          mm_cli.do_parse 0 0
    loadimm  i64   1 
    store    i64   mm_lib.parsedone 
    setcall        0
    callp          mm_cli.do_name 0 0
    setcall        0
    callp          mm_cli.do_type 0 0
    setcall        0
    callp          mm_support.do_writema 0 0
    load     u8    mm_decls.fwritema 
    jumpf    i64   #8940 
    jump           #8941 
    unload   u64   
#8940:
#8939:
    setcall        0
    callp          mm_cli.do_writeexports 0 0
    load     i64   mm_decls.passlevel 
    loadimm  i64   7 
    jumpeq   i64   #8943 1
    loadimm  i64   13 
    jumpeq   i64   #8943 
    jump           #8944 
#8943:
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callp          mm_topcl.codegen 1 0
    setcall        1
    load     u64   mm_decls.pclfilename 
    setarg   u64   1
    callp          mm_topcl.writepclfile 1 0
    load     i64   mm_decls.passlevel 
    loadimm  i64   13 
    jumpne   i64   #8946 
    setcall        1
    load     u64   mm_decls.pclfilename 
    setarg   u64   1
    callp          mm_topcl.runpclfile 1 0
#8946:
#8945:
    jump           #8942 
#8944:
    load     i64   mm_decls.passlevel 
    loadimm  i64   6 
    jumple   i64   #8948 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Pass not supported"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#8948:
#8947:
#8942:
;finish::
#8941:
    load     i64   mm_decls.fverbose 
    loadimm  i64   2 
    jumplt   i64   #8952 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Finished."
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#8952:
#8951:
    load     i64   mm_decls.debugmode 
    jumpf    i64   #8955 
    setcall        0
    callp          mm_diags.showlogfile 0 0
#8955:
#8954:
    load     u8    mm_decls.fshowtiming 
    jumpf    i64   #8957 
    setcall        0
    callf    i64   mwindows.os_clock 0 0
    store    i64   mm_cli.endclock 
    load     i64   mm_cli.endclock 
    load     i64   mm_cli.startclock 
    sub      i64   
    loadimm  i64   10000 
    div      i64   
    store    i64   .t 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Time"
    callp          msys.m$print_str_nf 1 0
    load     i64   .t 
    callp          msys.m$print_i64_nf 1 0
    loadimm  u64   "ms"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_end 0 0
    load     i64   .t 
    jumpf    i64   #8961 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   ","
    callp          msys.m$print_str_nf 1 0
    load     i64   mm_lex.lxalllines 
    float    r64 i64 
    load     i64   .t 
    float    r64 i64 
    div      r64   
    fix      i64 r64 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   "K lines per second ("
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     i64   mm_lex.lxalllines 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_nogap 0 0
    loadimm  u64   ")"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    jump           #8960 
#8961:
    callp          msys.m$print_startcon 0 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#8960:
#8957:
#8956:
;------------------------
#8926:
    stop           0
end

;
proc mm_cli.do_loadmodules
    local    i64   .tt 
;------------------------
    load     i64   mm_decls.passlevel 
    loadimm  i64   2 
    jumpge   i64   #8967 
    jump           #8965 
#8967:
#8966:
    load     u8    mm_cli.fmodinfo 
    jumpf    i64   #8969 
    setcall        0
    callp          mm_cli.showmoduleinfo 0 0
    stop           0
#8969:
#8968:
    setcall        0
    callp          mm_modules.loadmodules 0 0
    load     u8    mm_decls.fshowtiming 
    jumpf    i64   #8971 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "LOAD"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "TT="
    callp          msys.m$print_str_nf 1 0
    load     i64   .tt 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#8971:
#8970:
    setcall        0
    callp          mm_support.addspecialtypes 0 0
;------------------------
#8965:
    return         
end

proc mm_cli.do_parse
    local    i64   .tt 
    local    i64   .i 
;------------------------
    load     i64   mm_decls.passlevel 
    loadimm  i64   3 
    jumpge   i64   #8976 
    jump           #8974 
#8976:
#8975:
    load     u8    mm_decls.fwritedocs 
    jumpf    i64   #8978 
    setcall        2
    loadimm  u64   "w"
    setarg   u64   2
    setcall        2
    loadimm  u64   "txt"
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mlib.changeext 2 0
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   mm_parse.docfile 
#8978:
#8977:
    setcall        0
    callf    i32   clock 0 0
    widen    i32   
    store    i64   .tt 
    loadimm  i64   2 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   2 
    jumplt   i64   #8983 
#8981:
    setcall        1
    load     i64   .i 
    setarg   i64   1
    callf    i64   mm_parse.parsemodule 1 0
    unload   i64   
#8982:
    forup          #8981 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#8983:
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callf    i64   mm_parse.parsemodule 1 0
    unload   i64   
    setcall        0
    callf    i32   clock 0 0
    widen    i32   
    load     i64   .tt 
    sub      i64   
    store    i64   .tt 
    load     u8    mm_decls.fshowtiming 
    jumpf    i64   #8985 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "PARSE"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "TT="
    callp          msys.m$print_str_nf 1 0
    load     i64   .tt 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#8985:
#8984:
    load     u64   mm_parse.docfile 
    jumpf    u64   #8989 
    setcall        1
    load     u64   mm_parse.docfile 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
#8989:
#8988:
    load     i64   mm_decls.debugmode 
    jumpf    i64   #8992 
    load     i64   mm_decls.passlevel 
    loadimm  i64   4 
    jumplt   i64   #8991 
#8992:
    setcall        0
    callp          mm_name.fixusertypes 0 0
#8991:
#8990:
    setcall        0
    callp          mm_cli.fixstartprocs 0 0
    load     i64   mm_decls.debugmode 
    jumpf    i64   #8994 
    load     u8    mm_decls.fshowast1 
    jumpf    i64   #8994 
    setcall        1
    loadimm  u64   "AST1"
    setarg   u64   1
    callp          mm_diags.showast 1 0
#8994:
#8993:
;------------------------
#8974:
    return         
end

proc mm_cli.do_name
    local    i64   .tt 
    local    i64   .i 
;------------------------
    load     i64   mm_decls.passlevel 
    loadimm  i64   5 
    jumpge   i64   #8998 
    jump           #8996 
#8998:
#8997:
    setcall        0
    callp          mm_name.rx_typetable 0 0
    setcall        0
    callf    i32   clock 0 0
    widen    i32   
    store    i64   .tt 
    loadimm  i64   2 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   2 
    jumplt   i64   #9001 
#8999:
    setcall        1
    load     i64   .i 
    setarg   i64   1
    callf    i64   mm_name.rx_module 1 0
    unload   i64   
#9000:
    forup          #8999 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#9001:
    setcall        1
    loadimm  i64   1 
    setarg   i64   1
    callf    i64   mm_name.rx_module 1 0
    unload   i64   
    setcall        0
    callf    i32   clock 0 0
    widen    i32   
    load     i64   .tt 
    sub      i64   
    store    i64   .tt 
    load     u8    mm_decls.fshowtiming 
    jumpf    i64   #9003 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "NAME"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "TT="
    callp          msys.m$print_str_nf 1 0
    load     i64   .tt 
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#9003:
#9002:
    load     i64   mm_decls.debugmode 
    jumpf    i64   #9007 
    load     u8    mm_decls.fshowast2 
    jumpf    i64   #9007 
    setcall        1
    loadimm  u64   "AST2"
    setarg   u64   1
    callp          mm_diags.showast 1 0
#9007:
#9006:
;------------------------
#8996:
    return         
end

proc mm_cli.do_type
    local    i64   .tt 
    local    i64   .i 
;------------------------
    load     i64   mm_decls.passlevel 
    loadimm  i64   6 
    jumpge   i64   #9011 
    jump           #9009 
#9011:
#9010:
    setcall        0
    callf    i32   clock 0 0
    widen    i32   
    store    i64   .tt 
    setcall        0
    callp          mm_type.tx_typetable 0 0
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   1 
    jumplt   i64   #9014 
#9012:
    setcall        1
    load     i64   .i 
    setarg   i64   1
    callf    i64   mm_type.tx_module 1 0
    unload   i64   
#9013:
    forup          #9012 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#9014:
    setcall        0
    callp          mm_type.tx_allprocs 0 0
    load     u8    mm_decls.fshowtiming 
    jumpf    i64   #9016 
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "TYPE"
    callp          msys.m$print_str_nf 1 0
    setcall        0
    callf    i32   clock 0 0
    widen    i32   
    load     i64   .tt 
    sub      i64   
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#9016:
#9015:
    load     i64   mm_decls.debugmode 
    jumpf    i64   #9019 
    load     u8    mm_decls.fshowast3 
    jumpf    i64   #9019 
    setcall        1
    loadimm  u64   "AST3"
    setarg   u64   1
    callp          mm_diags.showast 1 0
#9019:
#9018:
;------------------------
#9009:
    return         
end

proc mm_cli.initdata
;------------------------
    setcall        0
    callp          mlib.pcm_init 0 0
    setcall        0
    callp          mm_lex.lexsetup 0 0
    setcall        0
    callp          mm_cli.initassemsymbols 0 0
    setcall        0
    callp          mm_support.init_tt_tables 0 0
    setcall        0
    callp          mm_support.initbblib 0 0
    setcall        0
    callf    i64   mwindows.os_iswindows 0 0
    jumpf    i64   #9023 
    loadimm  i64   1 
    store    u8    mm_decls.fwindows 
    jump           #9022 
#9023:
    loadimm  i64   1 
    store    u8    mm_decls.flinux 
#9022:
;------------------------
#9021:
    return         
end

proc mm_cli.getinputoptions
    local    i64   .i 
    local    i64   .j 
    local    i64   .k 
    local    i64   .paramno 
    local    i64   .pmtype 
    local    i64   .sw 
    local    i64   .ncolons 
    local    i64   .passfixed 
    local    u64   .name 
    local    u64   .value 
    local    u64   .filename 
    local    u64   .ext 
    local    u8:300 .filespec 
    local    i64   .$av_1 
;------------------------
    loadimm  i64   1 
    store    i64   mm_decls.prodmode 
    loadimm  i64   1 
    store    i64   .paramno 
    loadimm  i64   0 
    store    i64   .ncolons 
    setcall        2
    loadimm  u64   "ms.exe"
    setarg   u64   2
    setcall        1
    setcall        0
    callf    u64   mwindows.os_gethostname 0 0
    setarg   u64   1
    callf    u64   mlib.extractfile 1 0
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #9026 
    loadimm  i64   1 
    store    u8    mm_cli.msfile 
    setcall        2
    loadimm  u64   ""
    setarg   u64   2
    loadimm  i64   20 
    setarg   i64   1
    callp          mm_cli.do_option 2 0
#9026:
#9025:
    jump           #9030 
#9029:
    load     i64   .pmtype 
    loadimm  i64   1 
    jumpeq   i64   #9033 1
    loadimm  i64   2 
    jumpeq   i64   #9034 1
    loadimm  i64   3 
    jumpeq   i64   #9035 
    jump           #9036 
#9033:
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
    loadimm  i64   1 
    store    i64   .sw 
#9037:
    setcall        2
    loadref  u64   mm_cli.optionnames 
    load     i64   .sw 
    iloadx   u64   8 -8
    setarg   u64   2
    load     u64   .name 
    setarg   u64   1
    callf    i64   mlib.eqstring 2 0
    jumpf    i64   #9042 
    setcall        2
    load     u64   .value 
    setarg   u64   2
    load     i64   .sw 
    setarg   i64   1
    callp          mm_cli.do_option 2 0
    jump           #9039 
#9042:
#9041:
#9038:
    forup          #9037 1
    opnd           .sw 
    opnd           65 
#9040:
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Unknown option:"
    callp          msys.m$print_str_nf 1 0
    load     u64   .name 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           99
#9039:
    jump           #9032 
#9034:
    load     u64   mm_cli.inputfile 
    jumpf    u64   #9045 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Specify one lead module only"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#9045:
#9044:
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   mlib.convlcstring 1 0
    unload   u64   
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   mm_cli.inputfile 
    load     i64   mm_decls.passlevel 
    loadimm  i64   13 
    jumpne   i64   #9049 
    load     i64   .paramno 
    loadimm  i64   1 
    sub      i64   
    load     i64   $cmdskip 
    add      i64   
    store    i64   mm_topcl.cmdskip 
    jump           #9031 
#9049:
#9048:
    jump           #9032 
#9035:
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Lib files go in module headers"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
    jump           #9032 
#9036:
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Invalid params"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#9032:
#9030:
    setcall        4
    loadimm  u64   "m"
    setarg   u64   4
    loadref  u64   .value 
    setarg   u64   3
    loadref  u64   .name 
    setarg   u64   2
    loadref  u64   .paramno 
    setarg   u64   1
    callf    i64   mlib.nextcmdparamnew 4 0
    double         
    store    i64   .pmtype 
    jumpt    i64   #9029 
#9031:
    load     u8    mm_decls.fshowast1 
    load     u8    mm_decls.fshowast2 
    add      i64   
    load     u8    mm_decls.fshowast3 
    add      i64   
    load     u8    mm_decls.fshowasm 
    add      i64   
    load     u8    mm_decls.fshowpcl 
    add      i64   
    load     u8    mm_decls.fshowst 
    add      i64   
    load     u8    mm_decls.fshowstflat 
    add      i64   
    load     u8    mm_decls.fshowtypes 
    add      i64   
    load     u8    mm_decls.fshowmodules 
    add      i64   
    store    i64   mm_decls.debugmode 
    load     i64   mm_decls.debugmode 
    jumpf    i64   #9056 
    loadimm  i64   0 
    store    i64   mm_decls.prodmode 
#9056:
#9055:
    load     i64   mm_decls.passlevel 
    loadimm  i64   0 
    jumpne   i64   #9058 
    loadimm  i64   7 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "pcl"
    store    u64   mm_cli.outext 
#9058:
#9057:
    load     u8    mm_decls.msyslevel 
    loadimm  i64   -1 
    jumpne   i64   #9061 
    startmx        
    load     i64   mm_decls.prodmode 
    jumpf    i64   #9063 
    loadimm  i64   2 
    resetmx        
    jump           #9062 
#9063:
    loadimm  i64   0 
    endmx          
#9062:
    store    u8    mm_decls.msyslevel 
#9061:
#9060:
    load     u64   mm_cli.inputfile 
    loadimm  u64   0 
    jumpne   u64   #9065 
    setcall        0
    callp          mm_cli.showcaption 0 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Usage:"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "\t"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   msys.cmdparams 
    loadimm  i64   0 
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "filename[.m]     # Compile project to executable"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "\t"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_nogap 0 0
    load     u64   msys.cmdparams 
    loadimm  i64   0 
    iloadx   u64   8 0
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "-help            # Other options"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    stop           0
    jump           #9064 
#9065:
    load     u64   mm_cli.inputfile 
    store    u64   .filename 
    setcall        1
    load     u64   .filename 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   mm_decls.outfile 
    load     u8    mm_decls.fwritema 
    jumpf    i64   #9072 
    loadimm  u64   "ma"
    store    u64   mm_cli.outext 
#9072:
#9071:
    load     u64   mm_decls.destfilename 
    jumpf    u64   #9075 
    load     u64   mm_decls.destfilename 
    store    u64   mm_decls.outfile 
    jump           #9074 
#9075:
    load     u64   mm_decls.destfilepath 
    jumpf    u64   #9076 
    setcall        2
    load     u64   mm_decls.destfilepath 
    setarg   u64   2
    loadref  u64   .filespec 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    load     u64   mm_decls.outfile 
    setarg   u64   2
    setcall        1
    loadref  u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.extractfile 1 0
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        1
    loadref  u64   .filespec 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   mm_decls.outfile 
#9076:
#9074:
#9064:
    setcall        2
    loadimm  u64   "asm"
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mm_cli.getoutfilename 2 0
    store    u64   mm_decls.asmfilename 
    setcall        2
    loadimm  u64   "pcl"
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mm_cli.getoutfilename 2 0
    store    u64   mm_decls.pclfilename 
    setcall        2
    loadimm  u64   "exe"
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mm_cli.getoutfilename 2 0
    store    u64   mm_decls.exefilename 
    setcall        2
    startmx        
    load     i64   mm_decls.libmode 
    jumpf    i64   #9081 
    loadimm  u64   "ml"
    resetmx        
    jump           #9080 
#9081:
    loadimm  u64   "mx"
    endmx          
#9080:
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mm_cli.getoutfilename 2 0
    store    u64   mm_decls.libfilename 
    setcall        2
    loadimm  u64   "obj"
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mm_cli.getoutfilename 2 0
    store    u64   mm_decls.objfilename 
    setcall        2
    loadimm  u64   "ma"
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mm_cli.getoutfilename 2 0
    store    u64   mm_decls.mafilename 
    setcall        2
    setcall        2
    loadimm  u64   ""
    setarg   u64   2
    load     u64   mm_decls.outfile 
    setarg   u64   1
    callf    u64   mlib.changeext 2 0
    setarg   u64   2
    loadref  u64   .filespec 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "_exp"
    setarg   u64   2
    loadref  u64   .filespec 
    setarg   u64   1
    callf    u64   strcat 2 0
    unload   u64   
    setcall        2
    loadimm  u64   "m"
    setarg   u64   2
    loadref  u64   .filespec 
    setarg   u64   1
    callf    u64   mm_cli.getoutfilename 2 0
    store    u64   mm_decls.expfilename 
;------------------------
#9024:
    return         
end

proc mm_cli.do_option
    param    i64   .sw 
    param    u64   .value 
;------------------------
    load     i64   .sw 
    switch         #9091 1 65
    opnd           #9092 
#9091:
    swlabel        #9093 
    swlabel        #9094 
    swlabel        #9096 
    swlabel        #9095 
    swlabel        #9097 
    swlabel        #9098 
    swlabel        #9099 
    swlabel        #9100 
    swlabel        #9101 
    swlabel        #9102 
    swlabel        #9104 
    swlabel        #9105 
    swlabel        #9092 
    swlabel        #9107 
    swlabel        #9108 
    swlabel        #9113 
    swlabel        #9115 
    swlabel        #9110 
    swlabel        #9112 
    swlabel        #9117 
    swlabel        #9126 
    swlabel        #9127 
    swlabel        #9128 
    swlabel        #9129 
    swlabel        #9130 
    swlabel        #9168 
    swlabel        #9169 
    swlabel        #9170 
    swlabel        #9171 
    swlabel        #9119 
    swlabel        #9121 
    swlabel        #9123 
    swlabel        #9122 
    swlabel        #9124 
    swlabel        #9131 
    swlabel        #9132 
    swlabel        #9133 
    swlabel        #9155 
    swlabel        #9156 
    swlabel        #9157 
    swlabel        #9158 
    swlabel        #9159 
    swlabel        #9160 
    swlabel        #9161 
    swlabel        #9162 
    swlabel        #9163 
    swlabel        #9164 
    swlabel        #9165 
    swlabel        #9166 
    swlabel        #9167 
    swlabel        #9173 
    swlabel        #9125 
    swlabel        #9134 
    swlabel        #9135 
    swlabel        #9136 
    swlabel        #9137 
    swlabel        #9138 
    swlabel        #9138 
    swlabel        #9139 
    swlabel        #9140 
    swlabel        #9145 
    swlabel        #9154 
    swlabel        #9092 
    swlabel        #9172 
    swlabel        #9174 
    endsw          
#9093:
    loadimm  i64   1 
    store    i64   mm_decls.passlevel 
    jump           #9090 
#9094:
    loadimm  i64   2 
    store    i64   mm_decls.passlevel 
    jump           #9090 
#9095:
    loadimm  i64   3 
    store    i64   mm_decls.passlevel 
    jump           #9090 
#9096:
    loadimm  i64   4 
    store    i64   mm_decls.passlevel 
    jump           #9090 
#9097:
    loadimm  i64   5 
    store    i64   mm_decls.passlevel 
    jump           #9090 
#9098:
    loadimm  i64   6 
    store    i64   mm_decls.passlevel 
    jump           #9090 
#9099:
    loadimm  i64   3 
    store    i64   mm_decls.passlevel 
    loadimm  i64   1 
    store    u8    mm_decls.fshowast1 
    jump           #9090 
#9100:
    loadimm  i64   5 
    store    i64   mm_decls.passlevel 
    loadimm  i64   1 
    store    u8    mm_decls.fshowast2 
    jump           #9090 
#9101:
    loadimm  i64   6 
    store    i64   mm_decls.passlevel 
    loadimm  i64   1 
    store    u8    mm_decls.fshowast3 
    jump           #9090 
#9102:
    loadimm  i64   7 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "pcl"
    store    u64   mm_cli.outext 
    jump           #9090 
#9104:
    loadimm  i64   7 
    store    i64   mm_decls.passlevel 
    loadimm  i64   1 
    store    u8    mm_decls.fshowpcl 
    jump           #9090 
#9105:
    loadimm  i64   9 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "asm"
    store    u64   mm_cli.outext 
    jump           #9090 
#9107:
    loadimm  i64   8 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "asm"
    store    u64   mm_cli.outext 
    jump           #9090 
#9108:
    loadimm  i64   10 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "obj"
    store    u64   mm_cli.outext 
    jump           #9090 
#9110:
    loadimm  i64   11 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "exe"
    store    u64   mm_cli.outext 
    jump           #9090 
#9112:
    loadimm  i64   12 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "exe"
    store    u64   mm_cli.outext 
    loadimm  i64   1 
    store    i64   mm_decls.mxstub 
    jump           #9090 
#9113:
    loadimm  i64   12 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "mx"
    store    u64   mm_cli.outext 
    jump           #9090 
#9115:
    loadimm  i64   12 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "ml"
    store    u64   mm_cli.outext 
    loadimm  i64   1 
    store    i64   mm_decls.libmode 
    jump           #9090 
#9117:
    loadimm  i64   13 
    store    i64   mm_decls.passlevel 
    loadimm  u64   "mem"
    store    u64   mm_cli.outext 
    jump           #9090 
#9119:
    loadimm  i64   1 
    store    u8    mm_decls.fwritema 
    loadimm  u64   "ma"
    store    u64   mm_cli.outext 
    jump           #9090 
#9121:
    loadimm  i64   2 
    store    u8    mm_decls.fwritema 
    loadimm  u64   "ma"
    store    u64   mm_cli.outext 
    jump           #9090 
#9122:
    loadimm  i64   1 
    store    u8    mm_decls.fwriteexports 
    jump           #9090 
#9123:
    loadimm  i64   1 
    store    u8    mm_decls.fwritedocs 
    jump           #9090 
#9124:
    loadimm  i64   1 
    store    i64   mm_decls.libmode 
    jump           #9090 
#9125:
    loadimm  i64   1 
    store    u8    mm_decls.ffuntab 
    jump           #9090 
#9126:
    loadimm  i64   2 
    store    u8    mm_decls.msyslevel 
    jump           #9090 
#9127:
    loadimm  i64   1 
    store    u8    mm_decls.msyslevel 
    jump           #9090 
#9128:
    loadimm  i64   0 
    store    u8    mm_decls.msyslevel 
    jump           #9090 
#9129:
    loadimm  i64   1 
    store    u8    mm_decls.minos 
    jump           #9090 
#9130:
    loadimm  i64   1 
    store    u8    mm_decls.fnofile 
    jump           #9090 
#9131:
    loadimm  i64   2 
    store    u8    mm_decls.foptim 
    jump           #9090 
#9132:
    loadimm  i64   1 
    store    u8    mm_decls.foptim 
    jump           #9090 
#9133:
    loadimm  i64   2 
    store    u8    mm_decls.foptim 
    jump           #9090 
#9134:
    loadimm  i64   1 
    store    u8    mm_decls.fshowtiming 
    jump           #9090 
#9135:
    loadimm  i64   2 
    store    i64   mm_decls.fverbose 
    jump           #9090 
#9136:
    loadimm  i64   3 
    store    i64   mm_decls.fverbose 
    jump           #9090 
#9137:
    loadimm  i64   0 
    store    i64   mm_decls.fverbose 
    jump           #9090 
#9138:
    setcall        0
    callp          mm_cli.showhelp 0 0
    stop           0
    jump           #9090 
#9139:
    loadimm  i64   0 
    store    u8    mm_decls.dointlibs 
    jump           #9090 
#9140:
    load     u8    mm_cli.do_option.outpathused 
    jumpf    i64   #9142 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "mixed out/path"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#9142:
#9141:
    setcall        1
    load     u64   .value 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   mm_decls.destfilename 
    loadimm  i64   1 
    store    u8    mm_cli.do_option.outused 
    jump           #9090 
#9145:
    load     u8    mm_cli.do_option.outused 
    jumpf    i64   #9147 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "mixed out/path"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#9147:
#9146:
    load     u64   .value 
    setcall        1
    load     u64   .value 
    setarg   u64   1
    callf    i64   strlen 1 0
    addptrx  u64   1 0
    loadimm  i64   1 
    subptrx  u64   1 0
    iload    u8    
    loadimm  u64   92 
    jumpeq   u64   #9151 1
    loadimm  u64   47 
    jumpeq   u64   #9151 
    setcall        3
    loadimm  u64   ""
    setarg   u64   3
    loadimm  u64   ""
    setarg   u64   2
    loadimm  u64   "Path needs to end with \\ or /"
    setarg   u64   1
    callp          mm_support.loaderror 3 0
#9151:
#9150:
    setcall        1
    load     u64   .value 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    store    u64   mm_decls.destfilepath 
    loadimm  i64   1 
    store    u8    mm_cli.do_option.outpathused 
    jump           #9090 
#9154:
    loadimm  i64   1 
    store    u8    mm_decls.fcheckunusedlocals 
    jump           #9090 
#9155:
    loadimm  i64   1 
    store    u8    mm_decls.fshowast1 
    jump           #9090 
#9156:
    loadimm  i64   1 
    store    u8    mm_decls.fshowast2 
    jump           #9090 
#9157:
    loadimm  i64   1 
    store    u8    mm_decls.fshowast3 
    jump           #9090 
#9158:
    loadimm  i64   1 
    store    u8    mm_decls.fshowmx 
    jump           #9090 
#9159:
    loadimm  i64   1 
    store    u8    mm_decls.fshowasm 
    jump           #9090 
#9160:
    loadimm  i64   1 
    store    u8    mm_decls.fshowpcl 
    jump           #9090 
#9161:
    loadimm  i64   1 
    store    u8    mm_decls.fshowst 
    jump           #9090 
#9162:
    loadimm  i64   1 
    store    u8    mm_decls.fshowstflat 
    jump           #9090 
#9163:
    loadimm  i64   1 
    store    u8    mm_decls.fshowtypes 
    jump           #9090 
#9164:
    loadimm  i64   1 
    store    u8    mm_decls.fshowoverloads 
    jump           #9090 
#9165:
    loadimm  i64   1 
    store    u8    mm_decls.fshowss 
    jump           #9090 
#9166:
    loadimm  i64   1 
    store    u8    mm_decls.fshowmodules 
    jump           #9090 
#9167:
    loadimm  i64   1 
    store    u8    mm_topcl.fshortnames 
    jump           #9090 
#9168:
    loadimm  i64   1 
    store    i64   mm_decls.ccompiler 
    jump           #9090 
#9169:
    loadimm  i64   2 
    store    i64   mm_decls.ccompiler 
    jump           #9090 
#9170:
    loadimm  i64   3 
    store    i64   mm_decls.ccompiler 
    jump           #9090 
#9171:
    loadimm  i64   4 
    store    i64   mm_decls.ccompiler 
    jump           #9090 
#9172:
    loadimm  i64   1 
    store    u8    mm_decls.flinux 
    loadimm  i64   0 
    store    u8    mm_decls.fwindows 
    jump           #9090 
#9173:
    loadimm  i64   1 
    store    u8    mm_cli.fmodinfo 
    jump           #9090 
#9174:
    loadimm  i64   1 
    store    u8    mm_decls.fnowindll 
    jump           #9090 
#9092:
#9090:
;------------------------
#9089:
    return         
end

proc mm_cli.showcaption
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "M"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "Compiler [M7]"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "16-May-2023"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "00:00:55"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;------------------------
#9175:
    return         
end

proc mm_cli.showhelp
;------------------------
    callp          msys.m$print_startcon 0 0
    load     u64   mm_cli.showhelp.helptext 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
;------------------------
#9180:
    return         
end

proc mm_cli.initassemsymbols
    local    u8:32 .str 
    local    i64   .i 
    local    i64   .$av_1 
    local    i64   .$av_2 
    local    i64   .$av_3 
    local    i64   .$av_4 
    local    i64   .$av_5 
    local    i64   .$av_6 
    local    i64   .$av_7 
    local    i64   .$av_8 
    local    i64   .$av_9 
    local    i64   .$av_10 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
#9182:
    load     i64   .i 
    loadimm  i64   31 
    jumpeq   i64   #9186 
    load     i64   .i 
    loadimm  i64   151 
    jumpge   i64   #9186 
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     i64   .i 
    setarg   i64   3
    loadimm  i64   91 
    setarg   i64   2
    loadref  u64   mclnames 
    load     i64   .i 
    iloadx   u64   8 -8
    loadimm  i64   2 
    addptrx  u64   1 0
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9186:
#9185:
#9183:
    forup          #9182 1
    opnd           .i 
    opnd           151 
#9184:
    loadimm  i64   1 
    store    i64   .i 
#9187:
    setcall        4
    loadref  u64   regsizes 
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   4
    loadref  u64   regindices 
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   3
    loadimm  i64   83 
    setarg   i64   2
    loadref  u64   dregnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9188:
    forup          #9187 1
    opnd           .i 
    opnd           136 
#9189:
    loadimm  i64   1 
    store    i64   .i 
#9190:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     i64   .i 
    loadimm  i64   1 
    add      i64   
    loadimm  i64   1 
    sub      i64   
    setarg   i64   3
    loadimm  i64   84 
    setarg   i64   2
    loadref  u64   xmmregnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9191:
    forup          #9190 1
    opnd           .i 
    opnd           16 
#9192:
    loadimm  i64   1 
    store    i64   .i 
#9193:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     i64   .i 
    setarg   i64   3
    loadimm  i64   85 
    setarg   i64   2
    loadref  u64   fregnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9194:
    forup          #9193 1
    opnd           .i 
    opnd           8 
#9195:
    loadimm  i64   1 
    store    i64   .i 
#9196:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     i64   .i 
    setarg   i64   3
    loadimm  i64   86 
    setarg   i64   2
    loadref  u64   mregnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9197:
    forup          #9196 1
    opnd           .i 
    opnd           8 
#9198:
    loadimm  i64   1 
    store    i64   .i 
#9199:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadref  u64   jmpcccodes 
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   3
    loadimm  i64   87 
    setarg   i64   2
    loadref  u64   jmpccnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9200:
    forup          #9199 1
    opnd           .i 
    opnd           18 
#9201:
    loadimm  i64   1 
    store    i64   .i 
#9202:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadref  u64   setcccodes 
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   3
    loadimm  i64   88 
    setarg   i64   2
    loadref  u64   setccnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9203:
    forup          #9202 1
    opnd           .i 
    opnd           16 
#9204:
    loadimm  i64   1 
    store    i64   .i 
#9205:
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    loadref  u64   cmovcccodes 
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   3
    loadimm  i64   89 
    setarg   i64   2
    loadref  u64   cmovccnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9206:
    forup          #9205 1
    opnd           .i 
    opnd           16 
#9207:
    loadimm  i64   1 
    store    i64   .i 
#9208:
    setcall        2
    loadref  u64   segmentnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   2
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   strcpy 2 0
    unload   u64   
    loadimm  u64   0 
    loadref  u64   .str 
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    i64   strlen 1 0
    istorex  u8    1 -4
    setcall        4
    loadimm  i64   0 
    setarg   i64   4
    load     i64   .i 
    setarg   i64   3
    loadimm  i64   90 
    setarg   i64   2
    setcall        1
    loadref  u64   .str 
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9209:
    forup          #9208 1
    opnd           .i 
    opnd           5 
#9210:
    loadimm  i64   1 
    store    i64   .i 
#9211:
    setcall        4
    loadref  u64   mm_cli.initassemsymbols.sizes 
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   4
    loadref  u64   mm_cli.initassemsymbols.regnos 
    load     i64   .i 
    iloadx   u8    1 -1
    setarg   i64   3
    loadimm  i64   83 
    setarg   i64   2
    loadref  u64   mm_cli.initassemsymbols.regnames 
    load     i64   .i 
    iloadx   u64   8 -8
    setarg   u64   1
    callp          mm_lex.addreservedword 4 0
#9212:
    forup          #9211 1
    opnd           .i 
    opnd           6 
#9213:
;------------------------
#9181:
    return         
end

proc mm_cli.do_writeexports
    local    u8:300 .str 
;------------------------
    load     u8    mm_decls.fwriteexports 
    jumpt    i64   #9216 
    load     i64   mm_decls.passlevel 
    loadimm  i64   12 
    jumpeq   i64   #9216 
    jump           #9214 
#9216:
#9215:
    load     i64   mm_decls.libmode 
    jumpt    i64   #9218 
    jump           #9214 
#9218:
#9217:
    setcall        2
    setcall        1
    load     u64   mm_decls.libfilename 
    setarg   u64   1
    callf    u64   mlib.extractbasefile 1 0
    setarg   u64   2
    load     u64   mm_decls.expfilename 
    setarg   u64   1
    callp          mm_export.writeexports 2 0
    load     u8    mm_decls.fwriteexports 
    jumpf    i64   #9220 
    stop           0
#9220:
#9219:
;------------------------
#9214:
    return         
end

proc mm_cli.getoutfilename
    rettype  u64   
    param    u64   .file 
    param    u64   .ext 
;------------------------
    setcall        1
    setcall        2
    load     u64   .ext 
    setarg   u64   2
    load     u64   .file 
    setarg   u64   1
    callf    u64   mlib.changeext 2 0
    setarg   u64   1
    callf    u64   mlib.pcm_copyheapstring 1 0
    setret   u64   
    jump           #9221 
;------------------------
#9221:
    return         
end

proc mm_cli.fixstartprocs
    local    u64   .ms 
    local    u64   .d 
    local    u64   .p 
    local    u64   .q 
    local    i64   .i 
;------------------------
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   1 
    jumplt   i64   #9225 
#9223:
    loadref  u64   mm_decls.moduletable 
    load     i64   .i 
    addptrx  u8:70 70 0
    store    u64   .ms 
    load     u64   .ms 
    loadimm  i64   32 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #9227 
    setcall        4
    load     i64   .i 
    setarg   i64   4
    loadimm  i64   2 
    setarg   i64   3
    loadimm  u64   "start"
    setarg   u64   2
    load     u64   .ms 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_cli.addstartproc 4 0
    load     u64   .ms 
    loadimm  i64   32 
    istorex  u64   1 0
#9227:
#9226:
    load     u64   .ms 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #9230 
    setcall        1
    load     u64   .ms 
    loadimm  i64   56 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    store    u64   .p 
    load     u64   .ms 
    loadimm  i64   32 
    iloadx   u64   1 0
    loadimm  i64   56 
    iloadx   u64   1 0
    store    u64   .q 
    load     u64   .q 
    loadimm  i64   16 
    iloadx   u64   1 0
    load     u64   .p 
    loadimm  i64   8 
    istorex  u64   1 0
    load     u64   .p 
    load     u64   .ms 
    loadimm  i64   32 
    iloadx   u64   1 0
    loadimm  i64   56 
    iloadx   u64   1 0
    loadimm  i64   16 
    istorex  u64   1 0
#9230:
#9229:
    load     i64   .i 
    load     i64   mm_decls.mainmoduleno 
    jumpne   i64   #9232 
    load     u64   .ms 
    loadimm  i64   40 
    iloadx   u64   1 0
    loadimm  u64   0 
    jumpne   u64   #9232 
    load     u64   .ms 
    loadimm  i64   56 
    iloadx   u64   1 0
    jumpf    u64   #9232 
    setcall        4
    load     i64   .i 
    setarg   i64   4
    loadimm  i64   3 
    setarg   i64   3
    loadimm  u64   "main"
    setarg   u64   2
    load     u64   .ms 
    loadimm  i64   8 
    iloadx   u64   1 0
    setarg   u64   1
    callf    u64   mm_cli.addstartproc 4 0
    load     u64   .ms 
    loadimm  i64   40 
    istorex  u64   1 0
#9232:
#9231:
#9224:
    forup          #9223 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#9225:
;------------------------
#9222:
    return         
end

proc mm_cli.addstartproc
    rettype  u64   
    param    u64   .owner 
    param    u64   .name 
    param    i64   .scope 
    param    i64   .moduleno 
    local    u64   .stproc 
;------------------------
    setcall        3
    loadimm  i64   6 
    setarg   i64   3
    setcall        1
    load     u64   .name 
    setarg   u64   1
    callf    u64   mm_lex.addnamestr 1 0
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callf    u64   mm_lib.getduplnameptr 3 0
    store    u64   .stproc 
    load     i64   .scope 
    load     u64   .stproc 
    loadimm  i64   191 
    istorex  u8    1 0
    load     i64   .moduleno 
    load     u64   .stproc 
    loadimm  i64   86 
    istorex  u8    1 0
    loadref  u64   mm_decls.moduletosub 
    load     i64   .moduleno 
    iloadx   u8    1 0
    load     u64   .stproc 
    loadimm  i64   87 
    istorex  u8    1 0
    setcall        1
    loadimm  u64   0 
    setarg   u64   1
    callf    u64   mm_parse.makeblock 1 0
    load     u64   .stproc 
    loadimm  i64   56 
    istorex  u64   1 0
    setcall        2
    load     u64   .stproc 
    setarg   u64   2
    load     u64   .owner 
    setarg   u64   1
    callp          mm_lib.adddef 2 0
    setcall        1
    load     u64   .stproc 
    setarg   u64   1
    callp          mm_lib.addtoproclist 1 0
    load     u64   .stproc 
    setret   u64   
    jump           #9234 
;------------------------
#9234:
    return         
end

proc mm_cli.stepruncount
    local    i64   .count 
    local    u64   .f 
;------------------------
    setcall        2
    loadimm  u64   "r+"
    setarg   u64   2
    loadimm  u64   "C:/mxp//bcrun.txt"
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    load     u64   .f 
    jumpt    u64   #9239 
    jump           #9235 
#9239:
#9238:
    load     u64   .f 
    callp          msys.m$read_fileline 1 0
    loadimm  i64   0 
    callf    i64   msys.m$read_i64 1 0
    store    i64   .count 
    setcall        3
    loadimm  i64   0 
    setarg   i32   3
    loadimm  i64   0 
    setarg   i32   2
    load     u64   .f 
    setarg   u64   1
    callf    i32   fseek 3 0
    unload   i32   
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    load     i64   .count 
    loadimm  i64   1 
    add      i64   
    callp          msys.m$print_i64_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
;------------------------
#9235:
    return         
end

proc mm_cli.showmoduleinfo
    local    u64   .f 
    local    u64   .pm 
    local    i64   .i 
;------------------------
    callp          msys.m$print_startcon 0 0
    loadimm  u64   "Writing to"
    callp          msys.m$print_str_nf 1 0
    loadimm  u64   "$temp"
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
    setcall        2
    loadimm  u64   "wb"
    setarg   u64   2
    loadimm  u64   "$temp"
    setarg   u64   1
    callf    u64   fopen 2 0
    store    u64   .f 
    load     u64   mm_cli.projectmodule 
    jumpf    u64   #9246 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "module"
    callp          msys.m$print_str_nf 1 0
    load     u64   mm_cli.projectmodule 
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#9246:
#9245:
    loadimm  i64   1 
    store    i64   .i 
    load     i64   mm_decls.nmodules 
    loadimm  i64   1 
    jumplt   i64   #9250 
#9248:
    loadref  u64   mm_decls.moduletable 
    load     i64   .i 
    addptrx  u8:70 70 0
    store    u64   .pm 
    load     u64   .f 
    callp          msys.m$print_startfile 1 0
    loadimm  u64   "module ##.m"
    callp          msys.m$print_setfmt 1 0
    startmx        
    load     u64   .pm 
    loadimm  i64   24 
    iloadx   u64   1 0
    jumpf    u64   #9253 
    load     u64   .pm 
    loadimm  i64   24 
    iloadx   u64   1 0
    resetmx        
    jump           #9252 
#9253:
    loadimm  u64   "--"
    endmx          
#9252:
    callp          msys.m$print_str_nf 1 0
    load     u64   .pm 
    iload    u64   
    callp          msys.m$print_str_nf 1 0
    callp          msys.m$print_newline 0 0
    callp          msys.m$print_end 0 0
#9249:
    forup          #9248 1
    opnd           .i 
    opnd           mm_decls.nmodules 
#9250:
    setcall        1
    load     u64   .f 
    setarg   u64   1
    callf    i32   fclose 1 0
    unload   i32   
;------------------------
#9240:
    return         
end

proc mm_cli.start
    callp          mm_assem.start 0 0
    callp          mm_blockpcl.start 0 0
    callp          mm_decls.start 0 0
    callp          mm_diags.start 0 0
    callp          mm_export.start 0 0
    callp          mm_genpcl.start 0 0
    callp          mm_lex.start 0 0
    callp          mm_lib.start 0 0
    callp          mm_libpcl.start 0 0
    callp          mm_libsources.start 0 0
    callp          mm_modules.start 0 0
    callp          mm_name.start 0 0
    callp          mm_parse.start 0 0
    callp          mm_pcl.start 0 0
    callp          mm_support.start 0 0
    callp          mm_tables.start 0 0
    callp          mm_type.start 0 0
    callp          mm_topcl.start 0 0
    callp          mc_decls.start 0 0
;------------------------
;------------------------
#9255:
    return         
end

;
proc mm_assem.start
;------------------------
;------------------------
#9256:
    return         
end

;
proc mm_decls.start
;------------------------
;------------------------
#9257:
    return         
end

;
proc mm_diags.start
;------------------------
;------------------------
#9258:
    return         
end

;
proc mm_export.start
;------------------------
;------------------------
#9259:
    return         
end

;
proc mm_genpcl.start
;------------------------
;------------------------
#9260:
    return         
end

;
proc mm_lib.start
;------------------------
;------------------------
#9261:
    return         
end

;
proc mm_libpcl.start
;------------------------
;------------------------
#9262:
    return         
end

;
proc mm_libsources.start
;------------------------
;------------------------
#9263:
    return         
end

;
proc mm_modules.start
;------------------------
;------------------------
#9264:
    return         
end

;
proc mm_name.start
;------------------------
;------------------------
#9265:
    return         
end

;
proc mm_parse.start
;------------------------
;------------------------
#9266:
    return         
end

;
proc mm_pcl.start
;------------------------
;------------------------
#9267:
    return         
end

;
proc mm_support.start
;------------------------
;------------------------
#9268:
    return         
end

;
proc mm_type.start
;------------------------
;------------------------
#9269:
    return         
end

;
proc mm_topcl.start
;------------------------
;------------------------
#9270:
    return         
end

;
proc mc_decls.start
;------------------------
;------------------------
#9271:
    return         
end

;
proc mlib.start
;------------------------
;------------------------
#9272:
    return         
end

;
proc mclib.start
;------------------------
;------------------------
#9273:
    return         
end

;
proc mwindllc.start
;------------------------
;------------------------
#9274:
    return         
end

;
;Function Table
    istatic  i64   $nprocs 
    data     i64   54 
;
    istatic  u8:432 $procname 
    data     u64   "dx_block"
    data     u64   "dx_eval"
    data     u64   "dx_const"
    data     u64   "dx_name"
    data     u64   "dx_bin"
    data     u64   "dx_binto"
    data     u64   "dx_unary"
    data     u64   "dx_unaryto"
    data     u64   "dx_maths"
    data     u64   "dx_maths2"
    data     u64   "dx_labeldef"
    data     u64   "dx_goto"
    data     u64   "dx_while"
    data     u64   "dx_repeat"
    data     u64   "dx_print"
    data     u64   "dx_do"
    data     u64   "dx_exit"
    data     u64   "dx_return"
    data     u64   "dx_returnmult"
    data     u64   "dx_read"
    data     u64   "dx_readln"
    data     u64   "dx_assign"
    data     u64   "dx_if"
    data     u64   "dx_istruel"
    data     u64   "dx_incrto"
    data     u64   "dx_callproc"
    data     u64   "dx_forup"
    data     u64   "dx_to"
    data     u64   "dx_index"
    data     u64   "dx_addrof"
    data     u64   "dx_swap"
    data     u64   "dx_stop"
    data     u64   "dx_ptr"
    data     u64   "dx_dot"
    data     u64   "do_dotref"
    data     u64   "dx_convert"
    data     u64   "dx_shorten"
    data     u64   "dx_empty"
    data     u64   "dx_switch"
    data     u64   "dx_assem"
    data     u64   "dx_case"
    data     u64   "dx_syscall"
    data     u64   "dx_dotindex"
    data     u64   "dx_dotslice"
    data     u64   "dx_typepun"
    data     u64   "dx_select"
    data     u64   "dx_cmpchain"
    data     u64   "dx_andl"
    data     u64   "dx_orl"
    data     u64   "dx_notl"
    data     u64   "dx_forall"
    data     u64   "dx_assignmm"
    data     u64   "dx_debug"
    data     u64   "dx_assignms"
;
    istatic  u8:432 $procaddr 
    data     u64   mm_blockpcl.dx_block 
    data     u64   mm_blockpcl.dx_eval 
    data     u64   mm_blockpcl.dx_const 
    data     u64   mm_blockpcl.dx_name 
    data     u64   mm_blockpcl.dx_bin 
    data     u64   mm_blockpcl.dx_binto 
    data     u64   mm_blockpcl.dx_unary 
    data     u64   mm_blockpcl.dx_unaryto 
    data     u64   mm_blockpcl.dx_maths 
    data     u64   mm_blockpcl.dx_maths2 
    data     u64   mm_blockpcl.dx_labeldef 
    data     u64   mm_blockpcl.dx_goto 
    data     u64   mm_blockpcl.dx_while 
    data     u64   mm_blockpcl.dx_repeat 
    data     u64   mm_blockpcl.dx_print 
    data     u64   mm_blockpcl.dx_do 
    data     u64   mm_blockpcl.dx_exit 
    data     u64   mm_blockpcl.dx_return 
    data     u64   mm_blockpcl.dx_returnmult 
    data     u64   mm_blockpcl.dx_read 
    data     u64   mm_blockpcl.dx_readln 
    data     u64   mm_blockpcl.dx_assign 
    data     u64   mm_blockpcl.dx_if 
    data     u64   mm_blockpcl.dx_istruel 
    data     u64   mm_blockpcl.dx_incrto 
    data     u64   mm_blockpcl.dx_callproc 
    data     u64   mm_blockpcl.dx_forup 
    data     u64   mm_blockpcl.dx_to 
    data     u64   mm_blockpcl.dx_index 
    data     u64   mm_blockpcl.dx_addrof 
    data     u64   mm_blockpcl.dx_swap 
    data     u64   mm_blockpcl.dx_stop 
    data     u64   mm_blockpcl.dx_ptr 
    data     u64   mm_blockpcl.dx_dot 
    data     u64   mm_blockpcl.do_dotref 
    data     u64   mm_blockpcl.dx_convert 
    data     u64   mm_blockpcl.dx_shorten 
    data     u64   mm_blockpcl.dx_empty 
    data     u64   mm_blockpcl.dx_switch 
    data     u64   mm_blockpcl.dx_assem 
    data     u64   mm_blockpcl.dx_case 
    data     u64   mm_blockpcl.dx_syscall 
    data     u64   mm_blockpcl.dx_dotindex 
    data     u64   mm_blockpcl.dx_dotslice 
    data     u64   mm_blockpcl.dx_typepun 
    data     u64   mm_blockpcl.dx_select 
    data     u64   mm_blockpcl.dx_cmpchain 
    data     u64   mm_blockpcl.dx_andl 
    data     u64   mm_blockpcl.dx_orl 
    data     u64   mm_blockpcl.dx_notl 
    data     u64   mm_blockpcl.dx_forall 
    data     u64   mm_blockpcl.dx_assignmm 
    data     u64   mm_blockpcl.dx_debug 
    data     u64   mm_blockpcl.dx_assignms 
;
extproc u64 malloc
    extparam u64   
extend

;
extproc u64 realloc
    extparam u64   
    extparam u64   
extend

;
extproc void free
    extparam u64   
extend

;
extproc void memset
    extparam u64   
    extparam i32   
    extparam u64   
extend

;
extproc void memcpy
    extparam u64   
    extparam u64   
    extparam u64   
extend

;
extproc i32 clock
extend

;
extproc i32 ftell
    extparam u64   
extend

;
extproc i32 fseek
    extparam u64   
    extparam i32   
    extparam i32   
extend

;
extproc u64 fread
    extparam u64   
    extparam u64   
    extparam u64   
    extparam u64   
extend

;
extproc u64 fwrite
    extparam u64   
    extparam u64   
    extparam u64   
    extparam u64   
extend

;
extproc i32 ungetc
    extparam i32   
    extparam u64   
extend

;
extproc u64 fopen
    extparam u64   
    extparam u64   
extend

;
extproc i32 fclose
    extparam u64   
extend

;
extproc u64 fgets
    extparam u64   
    extparam i64   
    extparam u64   
extend

;
extproc i32 remove
    extparam u64   
extend

;
extproc i32 getchar
extend

;
extproc i64 strlen
    extparam u64   
extend

;
extproc u64 strcpy
    extparam u64   
    extparam u64   
extend

;
extproc i32 strcmp
    extparam u64   
    extparam u64   
extend

;
extproc i32 strncmp
    extparam u64   
    extparam u64   
    extparam u64   
extend

;
extproc u64 strncpy
    extparam u64   
    extparam u64   
    extparam u64   
extend

;
extproc i32 memcmp
    extparam u64   
    extparam u64   
    extparam u64   
extend

;
extproc u64 strcat
    extparam u64   
    extparam u64   
extend

;
extproc i32 tolower
    extparam i32   
extend

;
extproc i32 toupper
    extparam i32   
extend

;
extproc i32 puts
    extparam u64   
extend

;
extproc i32 printf
    extparam u64   
    extvariadic      2 
extend

;
extproc i32 sprintf
    extparam u64   
    extparam u64   
    extvariadic      3 
extend

;
extproc i32 sscanf
    extparam u64   
    extparam u64   
    extvariadic      3 
extend

;
extproc i32 system
    extparam u64   
extend

;
extproc i32 fgetc
    extparam u64   
extend

;
extproc i32 fputc
    extparam i32   
    extparam u64   
extend

;
extproc i32 fprintf
    extparam u64   
    extparam u64   
    extvariadic      3 
extend

;
extproc u64 strchr
    extparam u64   
    extparam i32   
extend

;
extproc i32 __getmainargs
    extparam u64   
    extparam u64   
    extparam u64   
    extparam i64   
    extparam u64   
extend

;
extproc u64 GetStdHandle
    extparam u32   
extend

;
extproc i64 SetConsoleCtrlHandler
    extparam u64   
    extparam i64   
extend

;
extproc i64 SetConsoleMode
    extparam u64   
    extparam u32   
extend

;
extproc i64 CreateProcessA
    extparam u64   
    extparam u64   
    extparam u64   
    extparam u64   
    extparam i64   
    extparam u32   
    extparam u64   
    extparam u64   
    extparam u64   
    extparam u64   
extend

;
extproc u32 GetLastError
extend

;
extproc u32 WaitForSingleObject
    extparam u64   
    extparam u32   
extend

;
extproc i64 GetExitCodeProcess
    extparam u64   
    extparam u64   
extend

;
extproc i64 CloseHandle
    extparam u64   
extend

;
extproc i64 GetNumberOfConsoleInputEvents
    extparam u64   
    extparam u64   
extend

;
extproc u64 LoadLibraryA
    extparam u64   
extend

;
extproc u64 GetProcAddress
    extparam u64   
    extparam u64   
extend

;
extproc u64 LoadCursorA
    extparam u64   
    extparam u64   
extend

;
extproc u32 RegisterClassExA
    extparam u64   
extend

;
extproc i64 DefWindowProcA
    extparam u64   
    extparam u32   
    extparam u64   
    extparam u64   
extend

;
extproc i64 ReadConsoleInputA
    extparam u64   
    extparam u64   
    extparam u32   
    extparam u64   
extend

;
extproc void Sleep
    extparam u32   
extend

;
extproc u32 GetModuleFileNameA
    extparam u64   
    extparam u64   
    extparam u32   
extend

;
extproc u32 QueryPerformanceCounter
    extparam u64   
extend

;
extproc void GetLocalTime
    extparam u64   
extend

;
extproc u64 GetTickCount64
extend

;
extproc u32 PeekMessageA
    extparam u64   
    extparam u64   
    extparam u32   
    extparam u32   
    extparam u32   
extend

;
extproc u64 VirtualAlloc
    extparam u64   
    extparam u32   
    extparam u32   
    extparam u32   
extend

;
extproc u32 VirtualProtect
    extparam u64   
    extparam u32   
    extparam u32   
    extparam u64   
extend

;

