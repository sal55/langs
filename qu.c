
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

//#include <stdio.h>
//#include <stdlib.h>
//#include <ctype.h>
//#include <string.h>
//#include <math.h>
//#include <time.h>
//#include <sys/types.h>
//#include <sys/stat.h>

//#pragma pack(1)

typedef signed char         i8;
typedef short              i16;
typedef int                i32;
typedef long long          i64;

typedef unsigned char       u8;
typedef unsigned short     u16;
typedef unsigned int       u32;
typedef unsigned long long u64;

typedef unsigned char     byte;

typedef float              r32;
typedef double             r64;

extern r64 sqrt(r64);
extern r64 fabs(r64);

typedef struct {void* ptr; u64 length;} Slice;

#define NULL ((void*)0)

#ifndef CALLBACK
#define CALLBACK
#endif

i64 m$llabs(i64 a){ return (a>=0?a:-a);}
#define m$infinity (1.0/0.0)

i64 $rtemp;


/* Forward Struct Declarations */
struct qq_decimal$constrec;
struct qq_decls$packfieldrec;
struct qq_decls$procrec;
struct qq_decls$userxrec;
struct qq_decls$strec;
struct qq_decls$lexrec;
struct qq_decls$uflagsrec;
struct qq_decls$fieldrec;
struct qq_decls$unitrec;
struct qq_decls$locrec;
struct qq_decls$genfieldrec;
struct qq_decls$filerec;
struct qq_decls$subprogrec;
struct qq_decls$varrec;
struct qq_decls$objrec;
struct qq_decls$stringrec;
struct qq_host$dimrec;
struct qq_parse$readterm$dummy;
struct msysc$procinforec;
struct msysc$fmtrec;
struct mlib$strbuffer;
struct mlinux$termios;
struct mlinux$timeval;
struct mlinux$tm_rec;
struct mlinux$rsystemtime;

/* Struct Definitions */
struct qq_decimal$constrec {
    i64 value;
    struct qq_decls$objrec *  bnvalue;
    struct qq_decimal$constrec* nextconst;
};

struct qq_decls$packfieldrec {
    struct qq_decls$objrec *  structobj;
    u8 *  name;
    i32 packmode;
    i32 offset;
    i32 size;
    i32 length;
};

struct qq_decls$procrec {
    struct qq_decls$strec *  def;
    struct qq_decls$procrec* nextproc;
};

struct qq_decls$userxrec {
    struct qq_decls$strec *  owner;
    i16 *  pmode;
    struct qq_decls$userxrec* nextmode;
};

struct qq_decls$strec {
    u8 *  name;
    struct qq_decls$strec* owner;
    struct qq_decls$strec* deflist;
    struct qq_decls$strec* deflistx;
    struct qq_decls$strec* nextdef;
    struct qq_decls$strec* nextdupl;
    struct qq_decls$strec* firstdupl;
    struct qq_decls$strec* alias;
    union {
        u64 a;
        i64 *  pcaddress;
        struct qq_decls$varrec *  varptr;
        u8 *  truename;
        struct qq_decls$strec* atfield;
        i64 labelno;
    };
    union {
        u64 b;
        struct qq_decls$unitrec *  code;
        struct qq_decls$strec** topfieldlist;
    };
    union {
        u64 c;
        struct {
            i32 index;
            i32 capindex;
        };
    };
    union {
        u64 d;
        struct {
            i16 nparams;
            i16 nlocals;
        };
        struct {
            i16 nfields;
            i16 maxalign;
            i16 fieldoffset;
            i16 baseclassindex;
        };
        i64 genfieldindex;
    };
    u16 subcode;
    byte moduleno;
    byte subprogno;
    i16 mode;
    i16 hint;
    u16 flags;
    byte forindex;
    byte symbolcode;
    byte nameid;
    byte mutable;
    byte namelen;
    byte procfixed;
};

struct qq_decls$lexrec {
    union {
        i64 value;
        r64 xvalue;
        u64 uvalue;
        u8 *  svalue;
        struct qq_decls$strec *  symptr;
    };
    i32 pos;
    i16 symbol;
    i16 subcode;
};

struct qq_decls$uflagsrec {
    byte codes[7];
    byte ulength;
};

struct qq_decls$fieldrec {
    u8 *  name;
    i16 recordtype;
    i16 fieldtype;
    i32 fieldoffset;
};

struct qq_decls$unitrec {
    union {
        struct {
            i16 tag;
            union {
                byte elemtype;
            };
            union {
                byte nparams;
                byte enumindex;
            };
            i32 pos;
        };
        void *  word1;
    };
    struct qq_decls$unitrec* nextunit;
    union {
        struct qq_decls$unitrec* a;
        struct qq_decls$strec *  def;
        struct qq_decls$strec *  labeldef;
        i64 value;
        u64 uvalue;
        r64 xvalue;
        u8 *  svalue;
        i64 range_lower;
        i64 pclopcode;
    };
    union {
        struct qq_decls$unitrec* b;
        i64 range_upper;
        i64 slength;
        i16 mode;
        byte cmpgenop[4];
        struct {
            i32 length;
            i32 lower;
        };
        i64 index;
    };
};

struct qq_decls$locrec {
    struct qq_decls$subprogrec *  sp;
    struct qq_decls$filerec *  pm;
    struct qq_decls$strec *  def;
    u8 *  startline;
    i64 lineno;
    i64 column;
};

struct qq_decls$genfieldrec {
    struct qq_decls$strec *  def;
    struct qq_decls$genfieldrec* nextdef;
};

struct qq_decls$filerec {
    u8 *  name;
    u8 *  path;
    u8 *  filespec;
    u8 *  text;
    i64 size;
    byte isstring;
    byte issyslib;
    byte issupport;
    byte compiled;
    byte subprogno;
    byte islead;
    union {
        i16 moduleno;
        i16 fileno;
    };
    struct qq_decls$unitrec *  ast;
    i64 *  pcstart;
    i64 *  pcend;
    i64 pcsize;
    i32 *  pcsrcstart;
    union {
        struct qq_decls$strec *  stmodule;
        struct qq_decls$strec *  def;
    };
    struct qq_decls$strec *  stsubprog;
    struct qq_decls$strec *  startfn;
    struct qq_decls$strec *  mainfn;
};

struct qq_decls$subprogrec {
    u8 *  name;
    u8 *  path;
    u8 *  filespec;
    i16 firstmodule;
    i16 lastmodule;
    i16 compiled;
    byte issyslib;
    byte subprogno;
};

struct qq_decls$varrec {
    union {
        struct {
            union {
                struct {
                    byte tag;
                    byte hasref;
                    byte bitoffset;
                    union {
                        byte bitlength;
                        byte exceptiontype;
                        byte genmarker;
                    };
                };
                u32 tagx;
            };
            union {
                u32 elemtag;
                u32 frameptr_low;
                struct {
                    i16 frameoffset;
                    i16 nexceptions;
                };
            };
        };
        i64 dummy;
    };
    union {
        i64 value;
        r64 xvalue;
        u64 uvalue;
        u64 range_upper;
        struct qq_decls$objrec *  objptr;
        struct qq_decls$varrec* varptr;
        byte *  ptr;
        struct qq_decls$strec *  def;
        i64 *  retaddr;
    };
};

struct qq_decls$objrec {
    u32 refcount;
    struct {
        byte flags;
        byte objtype;
        union {
            u16 elemtag;
            u16 usertag;
            u16 itertag;
            struct {
                byte bitoffset;
                byte indexoffset;
            };
            i16 lower16;
        };
    };
    union {
        struct {
            union {
                i64 value;
                r64 xvalue;
                u64 uvalue;
                u8 *  strptr;
                struct qq_decls$varrec *  varptr;
                struct qq_decls$varrec *  genstack;
                byte *  ptr;
                i32 (*num)[];
                u64 b;
                i64 *  retaddr;
            };
            union {
                i64 length;
                i64 lower64;
                struct {
                    u32 rows;
                    u32 columns;
                };
                u64 c;
                byte *  frameptr;
                struct {
                    i32 iterpos;
                    i32 iterupper;
                };
            };
            union {
                i64 alloc64;
                struct qq_decls$objrec* objptr2;
                struct {
                    i16 neg;
                    i16 numtype;
                    i32 expon;
                };
                struct {
                    u32 alloc32;
                    u32 dictitems;
                };
                struct {
                    u16 genstacksize;
                    byte ngenparams;
                };
                u64 d;
            };
        };
        byte bignumdescr[24];
    };
};

struct qq_decls$stringrec {
    u8 *  svalue;
    i64 length;
};

struct qq_host$dimrec {
    i64 lbound;
    i64 upper;
    i64 length;
};

struct qq_parse$readterm$dummy {
    union {
        u8 str[20];
        i64 sa;
    };
};

struct msysc$procinforec {
    u16 fnindex;
    byte rettype;
    byte nparams;
    byte paramlist[12];
};

struct msysc$fmtrec {
    byte minwidth;
    i8 precision;
    byte base;
    u8 quotechar;
    u8 padchar;
    u8 realfmt;
    u8 plus;
    u8 sepchar;
    u8 lettercase;
    u8 justify;
    u8 suffix;
    u8 usigned;
    u8 charmode;
    u8 heapmode;
    u8 param;
    byte spare;
};

struct mlib$strbuffer {
    u8 *  strptr;
    i32 length;
    i32 allocated;
};

struct mlinux$termios {
    i32 c_iflag;
    i32 c_oflag;
    i32 c_cflag;
    i32 c_lflag;
    u8 c_line;
    u8 c_cc[32];
    byte filler[3];
    i32 c_ispeed;
    i32 c_ospeed;
};

struct mlinux$timeval {
    i64 tv_sec;
    i64 tv_usec;
};

struct mlinux$tm_rec {
    i32 tm_sec;
    i32 tm_min;
    i32 tm_hour;
    i32 tm_mday;
    i32 tm_mon;
    i32 tm_year;
    i32 tm_wday;
    i32 tm_yday;
    i32 tm_isdst;
    byte padding[20];
};

struct mlinux$rsystemtime {
    i32 year;
    i32 month;
    i32 dayofweek;
    i32 day;
    i32 hour;
    i32 minute;
    i32 second;
    i64 milliseconds;
};


/* PROCDECLS */
int main(int, char**);
static void qq_cli$getinputoptions(void);
static void qq_cli$do_option(i64 sw,u8 *value);
void qq_cli$start(void);
void qq_api$compile_sp(u8 *filename,u8 *source);
void qq_api$setcli(u8 *(*cmds)[],i64 ncmds);
static void qq_api$fixup_sp(struct qq_decls$subprogrec *sp);
void qq_api$writeqafile(void);
void qq_api$initdata(void);
static void qq_api$fixproc(struct qq_decls$strec *d);
static void qq_api$fixupmodule(struct qq_decls$filerec *pm);
i64 qq_api$runqprogram(struct qq_decls$subprogrec *sp);
static void qq_api$disploop(void);
static void qq_api$disploop_fn(void);
static void qq_api$disploop_deb(i64 fdeb);
void qq_api$setcmdmap(void);
i64 qq_api$runproc_m(void *amsg);
void qq_api$runproc(void *fnptr,struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *dest);
static void qq_api$resetcompiler(void);
void qq_api$loadsyslib(void);
void qq_api$start(void);
void qq_arrays$var_empty_array(i64 tag,i64 elemtype,i64 lower,struct qq_decls$varrec *dest);
void qq_arrays$obj_free_array(struct qq_decls$objrec *p);
void qq_arrays$obj_free_vector(struct qq_decls$objrec *p);
void qq_arrays$var_make_array(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 lower,i64 n,i64 axtype,i64 elemtype);
struct qq_decls$objrec *qq_arrays$obj_newarray(i64 elemtype,i64 lower,i64 length);
struct qq_decls$objrec *qq_arrays$obj_newarray_u(i64 usertag);
void qq_arrays$var_getix_array(struct qq_decls$varrec *a,i64 index);
void qq_arrays$var_putix_array(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_arrays$var_getixref_array(struct qq_decls$varrec *a,i64 index);
static void qq_arrays$obj_append_array(struct qq_decls$objrec *a,struct qq_decls$varrec *x);
void qq_arrays$var_appendto_array(struct qq_decls$varrec *a,struct qq_decls$varrec *x);
void qq_arrays$obj_resize_array(struct qq_decls$objrec *p,i64 n);
void qq_arrays$var_dupl_array(struct qq_decls$varrec *a);
void qq_arrays$var_dupl_vector(struct qq_decls$varrec *a);
i64 qq_arrays$var_equal_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_arrays$var_concatto_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_arrays$var_getslice_array(struct qq_decls$varrec *a,i64 i,i64 j);
static i64 qq_arrays$u8inarray(byte a,struct qq_decls$objrec *p);
i64 qq_arrays$u16inarray(u16 a,struct qq_decls$objrec *p);
i64 qq_arrays$u32inarray(u32 a,struct qq_decls$objrec *p);
i64 qq_arrays$u64inarray(u64 a,struct qq_decls$objrec *p);
i64 qq_arrays$var_inx_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b,i64 usertag);
void qq_arrays$var_expand_array(struct qq_decls$varrec *p,struct qq_decls$varrec *dest,i64 m);
void qq_arrays$start(void);
void qq_bits$obj_free_bits(struct qq_decls$objrec *p,i64 tag);
void qq_bits$var_make_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 lower,i64 n,i64 bxtype,i64 elemtype);
struct qq_decls$objrec *qq_bits$obj_newbits(i64 elemtype,i64 lower,i64 length);
void qq_bits$var_getix_bits(struct qq_decls$varrec *a,i64 index);
void qq_bits$var_putix_bits(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_bits$var_getixref_bits(struct qq_decls$varrec *a,i64 index);
static byte *qq_bits$getindexoffset(byte *p,i64 offset,i64 index,i64 t,i64 *newoffset);
static void qq_bits$obj_append_bits(struct qq_decls$objrec *a,struct qq_decls$varrec *x);
void qq_bits$var_appendto_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *x);
void qq_bits$obj_resize_bits(struct qq_decls$objrec *p,i64 n);
void qq_bits$var_dupl_bits(struct qq_decls$varrec *a);
i64 qq_bits$var_equal_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_bits$var_concatto_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_bits$var_getslice_bits(struct qq_decls$varrec *a,i64 i,i64 j);
i64 qq_bits$bits_bytesize(struct qq_decls$objrec *p);
i64 qq_bits$getbitssize(i64 n,i64 t);
void qq_bits$start(void);
void qq_calldll$calldll(struct qq_decls$strec *d,struct qq_decls$varrec *args,struct qq_decls$varrec *result,i64 nargs);
static void (*qq_calldll$getlibprocaddr(struct qq_decls$strec *d))(void);
static u64 qq_calldll$vartopacked(struct qq_decls$varrec *p,struct qq_decls$strec *d);
static void qq_calldll$packedtovar(u64 retval,i64 t,struct qq_decls$varrec *dest);
static void (*qq_calldll$loaddllfunction(struct qq_decls$strec *d))(void);
void qq_calldll$start(void);
void qq_decimal$obj_free_dec(struct qq_decls$objrec *p);
void qq_decimal$var_dupl_dec(struct qq_decls$varrec *a);
void qq_decimal$var_empty_dec(struct qq_decls$varrec *dest);
void qq_decimal$var_make_dec_str(u8 *s,i64 length,struct qq_decls$varrec *dest);
void qq_decimal$var_make_dec_int(i64 a,struct qq_decls$varrec *dest);
static struct qq_decls$objrec *qq_decimal$badnumber(void);
static struct qq_decls$objrec *qq_decimal$bn_makestr(u8 *s,i64 length);
static i64 qq_decimal$readexpon(u8 *s);
static struct qq_decls$objrec *qq_decimal$bn_makeint(i64 x);
u8 *qq_decimal$var_tostr_dec(struct qq_decls$varrec *a,i64 fmt);
static u8 *qq_decimal$obj_tostr_dec(struct qq_decls$objrec *a,i64 fmt);
static u8 *qq_decimal$tostring_scient(struct qq_decls$objrec *a);
static u8 *qq_decimal$tostring_float(struct qq_decls$objrec *a,i64 fmt);
static i64 qq_decimal$strvaln(u8 *s,i64 n);
static i64 qq_decimal$bn_isint(struct qq_decls$objrec *a);
i64 qq_decimal$obj_len_dec(struct qq_decls$objrec *a);
i64 qq_decimal$bn_iszero(struct qq_decls$objrec *a);
i64 qq_decimal$var_equal_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_add_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_sub_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_mul_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_div_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_idiv_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_irem_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_neg_dec(struct qq_decls$varrec *a);
void qq_decimal$var_abs_dec(struct qq_decls$varrec *a);
i64 qq_decimal$var_compare_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
static i64 qq_decimal$bn_cmp(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_equal(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_add(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_sub(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_addu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_subu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static struct qq_decls$objrec *qq_decimal$makebignum(i64 length);
static i32 *qq_decimal$makesmallnum(i64 length);
static struct qq_decls$objrec *qq_decimal$smalltobig(struct qq_decls$objrec *c,i32 *a,i64 length,i64 alloc,i64 offset);
static void qq_decimal$freesmall(i32 *p,i64 length);
struct qq_decls$objrec *qq_decimal$bn_init(void);
static void qq_decimal$bn_setzero(struct qq_decls$objrec *a);
static void qq_decimal$bn_move(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_dupl(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_setinf(struct qq_decls$objrec *dest);
static void qq_decimal$bn_setnan(struct qq_decls$objrec *dest);
void qq_decimal$var_setnan(struct qq_decls$varrec *dest);
void qq_decimal$var_setinf(struct qq_decls$varrec *dest);
static i64 qq_decimal$getbintype(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_negto(struct qq_decls$objrec *a);
static void qq_decimal$bn_absto(struct qq_decls$objrec *a);
static i64 qq_decimal$bn_mul(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_mulp(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 prec);
static void qq_decimal$bn_mulu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$smallmulto(i32 *p,i32 *q,i64 plen,i64 m);
static i64 qq_decimal$bn_div(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 prec);
static i64 qq_decimal$bn_idiv(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_idivrem(struct qq_decls$objrec *dest,struct qq_decls$objrec *rm,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_irem(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_idivu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,struct qq_decls$objrec *rm);
static void qq_decimal$bn_fdivu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 precision);
static i64 qq_decimal$smalldiv(i32 *x,i32 *b,i64 *xlen,i64 nb);
static i64 qq_decimal$smallsubto(i32 *p,i32 *q,i64 plen,i64 qlen);
static i64 qq_decimal$bn_getprec(struct qq_decls$objrec *a);
static void qq_decimal$bn_setprec(struct qq_decls$objrec *a,i64 prec);
static i64 qq_decimal$bn_getglobalprec(void);
static void qq_decimal$bn_setglobalprec(i64 prec);
static struct qq_decls$objrec *qq_decimal$bn_makefloat(r64 x);
struct qq_decls$varrec *qq_decimal$dectemp(struct qq_decls$varrec *a);
void qq_decimal$freedectemp(void);
static void qq_decimal$bn_ipower(struct qq_decls$objrec *d,struct qq_decls$objrec *a,i64 n);
void qq_decimal$var_power_dec(struct qq_decls$varrec *a,i64 n);
i64 qq_decimal$var_convert_dec_int(struct qq_decls$varrec *a);
static i64 qq_decimal$bn_toint(struct qq_decls$objrec *a);
void qq_decimal$start(void);
void qq_decls$start(void);
void qq_dicts$var_make_dict(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n);
struct qq_decls$objrec *qq_dicts$obj_new_dict(i64 n);
void qq_dicts$obj_free_dict(struct qq_decls$objrec *p,i64 internal);
void qq_dicts$var_dupl_dict(struct qq_decls$varrec *a);
i64 qq_dicts$var_equal_dict(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
struct qq_decls$varrec *qq_dicts$var_finddictitem(struct qq_decls$varrec *vd,struct qq_decls$varrec *p,i64 doins);
static void qq_dicts$expanddict(struct qq_decls$varrec *vd);
static void qq_dicts$adddictitem(struct qq_decls$varrec *d,struct qq_decls$varrec *p,struct qq_decls$varrec *q);
void qq_dicts$start(void);
i64 qq_jhandlers_hll$asmavailable(void);
i64 *qq_jhandlers_hll$disploop_asm(void);
void qq_jhandlers_hll$initjhandlers(void);
void qq_jhandlers_hll$start(void);
void qq_khandlers$kunimpl(void);
void qq_khandlers$k_pushci(void);
void qq_khandlers$k_pushnil(void);
void qq_khandlers$k_pushcs(void);
void qq_khandlers$k_pushcr(void);
void qq_khandlers$k_stop(void);
void qq_khandlers$k_stoprunproc(void);
void qq_khandlers$k_pushm(void);
void qq_khandlers$k_pushf(void);
void qq_khandlers$k_pushff(void);
void qq_khandlers$k_pushmref(void);
void qq_khandlers$k_pushfref(void);
void qq_khandlers$k_popm(void);
void qq_khandlers$k_storem(void);
void qq_khandlers$k_zpopm(void);
void qq_khandlers$k_popf(void);
void qq_khandlers$k_storef(void);
void qq_khandlers$k_zpopf(void);
void qq_khandlers$k_popretval(void);
void qq_khandlers$k_tom(void);
void qq_khandlers$k_tof(void);
void qq_khandlers$k_add(void);
void qq_khandlers$k_sub(void);
void qq_khandlers$k_mul(void);
void qq_khandlers$k_div(void);
void qq_khandlers$k_idiv(void);
void qq_khandlers$k_irem(void);
void qq_khandlers$k_iand(void);
void qq_khandlers$k_ior(void);
void qq_khandlers$k_ixor(void);
void qq_khandlers$k_shl(void);
void qq_khandlers$k_shr(void);
void qq_khandlers$k_sqr(void);
void qq_khandlers$k_sign(void);
void qq_khandlers$k_sqrt(void);
void qq_khandlers$k_sin(void);
void qq_khandlers$k_cos(void);
void qq_khandlers$k_tan(void);
void qq_khandlers$k_asin(void);
void qq_khandlers$k_acos(void);
void qq_khandlers$k_atan(void);
void qq_khandlers$k_log(void);
void qq_khandlers$k_log10(void);
void qq_khandlers$k_exp(void);
void qq_khandlers$k_round(void);
void qq_khandlers$k_floor(void);
void qq_khandlers$k_ceil(void);
void qq_khandlers$k_fract(void);
void qq_khandlers$k_neg(void);
void qq_khandlers$k_negto(void);
void qq_khandlers$k_absto(void);
void qq_khandlers$k_inotto(void);
void qq_khandlers$k_atan2(void);
void qq_khandlers$k_fmod(void);
void qq_khandlers$k_abs(void);
void qq_khandlers$k_inot(void);
void qq_khandlers$k_istruel(void);
void qq_khandlers$k_notl(void);
void qq_khandlers$k_jumpeq(void);
void qq_khandlers$k_jumpne(void);
void qq_khandlers$k_jumplt(void);
void qq_khandlers$k_jumple(void);
void qq_khandlers$k_jumpge(void);
void qq_khandlers$k_jumpgt(void);
void qq_khandlers$k_jumpfalse(void);
void qq_khandlers$k_jumptrue(void);
void qq_khandlers$k_incrtom(void);
void qq_khandlers$k_incrtof(void);
void qq_khandlers$k_decrtom(void);
void qq_khandlers$k_decrtof(void);
void qq_khandlers$k_incrload(void);
void qq_khandlers$k_loadincr(void);
void qq_khandlers$k_decrload(void);
void qq_khandlers$k_loaddecr(void);
void qq_khandlers$k_incrptr(void);
void qq_khandlers$k_decrptr(void);
void qq_khandlers$k_pushvoid(void);
void qq_khandlers$k_callproc(void);
void qq_khandlers$k_callptr(void);
void qq_khandlers$k_procentry(void);
void qq_khandlers$k_return(void);
void qq_khandlers$k_return0(void);
void qq_khandlers$k_unshare(void);
void qq_khandlers$k_unshare1(void);
void qq_khandlers$k_formci(void);
void qq_khandlers$k_forfci(void);
void qq_khandlers$k_fordmci(void);
void qq_khandlers$k_fordfci(void);
void qq_khandlers$k_formm(void);
void qq_khandlers$k_fordmm(void);
void qq_khandlers$k_forff(void);
void qq_khandlers$k_fordff(void);
void qq_khandlers$k_comment(void);
void qq_khandlers$k_makelist(void);
void qq_khandlers$k_makedict(void);
void qq_khandlers$k_makeset(void);
void qq_khandlers$k_makerecord(void);
void qq_khandlers$k_makestruct(void);
void qq_khandlers$k_makearray(void);
void qq_khandlers$k_makebits(void);
void qq_khandlers$k_index(void);
void qq_khandlers$k_popindex(void);
void qq_khandlers$k_indexref(void);
void qq_khandlers$k_keyindex(void);
void qq_khandlers$k_popkeyindex(void);
void qq_khandlers$k_keyindexref(void);
void qq_khandlers$k_dot(void);
void qq_khandlers$k_dotref(void);
void qq_khandlers$k_popdot(void);
void qq_khandlers$k_dotindex(void);
void qq_khandlers$k_dotindexref(void);
void qq_khandlers$k_popdotindex(void);
void qq_khandlers$k_len(void);
void qq_khandlers$k_upb(void);
void qq_khandlers$k_lwb(void);
void qq_khandlers$k_bounds(void);
void qq_khandlers$k_boundsx(void);
static void qq_khandlers$do_bounds(i64 sx);
void qq_khandlers$k_dictitems(void);
void qq_khandlers$k_isfound(void);
void qq_khandlers$k_append(void);
void qq_khandlers$k_concat(void);
void qq_khandlers$k_appendto(void);
void qq_khandlers$k_concatto(void);
void qq_khandlers$k_addto(void);
void qq_khandlers$k_subto(void);
void qq_khandlers$k_multo(void);
void qq_khandlers$k_divto(void);
void qq_khandlers$k_idivto(void);
void qq_khandlers$k_iandto(void);
void qq_khandlers$k_iorto(void);
void qq_khandlers$k_ixorto(void);
void qq_khandlers$k_shlto(void);
void qq_khandlers$k_shrto(void);
void qq_khandlers$k_copy(void);
void qq_khandlers$k_dupl(void);
void qq_khandlers$k_makerange(void);
void qq_khandlers$k_makerangelen(void);
void qq_khandlers$k_makedecimal(void);
void qq_khandlers$k_makeclosure(void);
static struct qq_decls$strec *qq_khandlers$resolvefield(i64 index,i64 rectype);
void qq_khandlers$k_pushptr(void);
void qq_khandlers$k_popptr(void);
void qq_khandlers$k_islist(void);
void qq_khandlers$k_isarray(void);
void qq_khandlers$k_isstring(void);
void qq_khandlers$k_isrecord(void);
void qq_khandlers$k_swap(void);
void qq_khandlers$k_jumptesteq(void);
void qq_khandlers$k_jumptestne(void);
void qq_khandlers$k_jump(void);
void qq_khandlers$k_jumpptr(void);
void qq_khandlers$k_incr(void);
void qq_khandlers$k_decr(void);
void qq_khandlers$k_chr(void);
void qq_khandlers$k_asc(void);
void qq_khandlers$k_pusht(void);
void qq_khandlers$k_type(void);
void qq_khandlers$k_basetype(void);
void qq_khandlers$k_usertype(void);
void qq_khandlers$k_elemtype(void);
void qq_khandlers$k_nop(void);
void qq_khandlers$k_modulecall(void);
void qq_khandlers$k_modulereturn(void);
void qq_khandlers$k_maxvalue(void);
void qq_khandlers$k_minvalue(void);
void qq_khandlers$k_callhost(void);
void qq_khandlers$k_expand(void);
void qq_khandlers$k_pushsymbol(void);
void qq_khandlers$k_eq(void);
void qq_khandlers$k_ne(void);
void qq_khandlers$k_lt(void);
void qq_khandlers$k_le(void);
void qq_khandlers$k_ge(void);
void qq_khandlers$k_gt(void);
static void qq_khandlers$do_cmp(i64 opc);
void qq_khandlers$k_calldll(void);
void qq_khandlers$k_in(void);
void qq_khandlers$k_notin(void);
void qq_khandlers$k_inx(void);
void qq_khandlers$k_convrefpack(void);
void qq_khandlers$k_isdef(void);
void qq_khandlers$k_isvoid(void);
void qq_khandlers$k_isint(void);
void qq_khandlers$k_isnumber(void);
void qq_khandlers$k_ismutable(void);
void qq_khandlers$k_isreal(void);
void qq_khandlers$k_isrange(void);
void qq_khandlers$k_isset(void);
void qq_khandlers$k_ispointer(void);
static void qq_khandlers$istype(i64 t1,i64 t2);
void qq_khandlers$k_convert(void);
void qq_khandlers$k_switch(void);
void qq_khandlers$k_bytesize(void);
void qq_khandlers$k_bitwidth(void);
void qq_khandlers$k_min(void);
void qq_khandlers$k_max(void);
void qq_khandlers$k_addsp(void);
void qq_khandlers$k_pushtry(void);
void qq_khandlers$k_raise(void);
void qq_khandlers$k_isequal(void);
void qq_khandlers$k_minto(void);
void qq_khandlers$k_maxto(void);
void qq_khandlers$k_power(void);
static void qq_khandlers$domaths(i64 opcode);
static r64 qq_khandlers$getmaths(i64 opcode,r64 x);
void qq_khandlers$k_typepun(void);
void qq_khandlers$k_andlto(void);
void qq_khandlers$k_orlto(void);
void qq_khandlers$k_notlto(void);
void qq_khandlers$k_pushoperator(void);
void qq_khandlers$k_maps(void);
void qq_khandlers$k_mapss(void);
void qq_khandlers$k_idivrem(void);
void qq_khandlers$k_odd(void);
void qq_khandlers$k_even(void);
void qq_khandlers$start(void);
void qq_host$callhostfunction(i64 hostfn);
void qq_host$pch_leftstr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
void qq_host$pch_rightstr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
void qq_host$pch_convlc(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
void qq_host$pch_convuc(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
void qq_host$pch_waitkey(struct qq_decls$varrec *result);
void qq_host$pch_execwait(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
void qq_host$pch_execcmd(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
void qq_host$pch_makestr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
void qq_host$pch_makeref(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
void qq_host$pch_getcmdparam(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_clock(struct qq_decls$varrec *result);
void qq_host$pch_allocexec(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_runnative(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
void qq_host$pch_setlwb(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_host$pch_ticks(struct qq_decls$varrec *result);
void qq_host$pch_sleep(struct qq_decls$varrec *a);
void qq_host$pch_random(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_system(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_$getparam(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static i64 qq_host$checkparam(struct qq_decls$varrec *p,i64 tag,i64 defaultx);
static void qq_host$leftstring(struct qq_decls$varrec *a,i64 n,struct qq_decls$varrec *result);
static void qq_host$rightstring(struct qq_decls$varrec *a,i64 n,struct qq_decls$varrec *result);
static void qq_host$padstring_right(struct qq_decls$varrec *a,i64 n,i64 fillchar,struct qq_decls$varrec *result);
static void qq_host$padstring_left(struct qq_decls$varrec *a,i64 n,i64 fillchar,struct qq_decls$varrec *result);
static void qq_host$getbounds(struct qq_decls$varrec *p,struct qq_host$dimrec *dims,i64 lower);
void qq_host$pch_new(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *d,struct qq_decls$varrec *result);
void qq_host$pch_gethostname(struct qq_decls$varrec *result);
void qq_host$pch_getprogname(struct qq_decls$varrec *result);
void qq_host$pch_$test(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
void qq_host$pch_$test2(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_$refcount(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_testkey(struct qq_decls$varrec *result);
void qq_host$pch_getos(struct qq_decls$varrec *result);
void qq_host$pch_setmesshandler(struct qq_decls$varrec *fn);
void qq_host$pch_$smallmemtotal(struct qq_decls$varrec *result);
void qq_host$pch_$id(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_iswindows(struct qq_decls$varrec *result);
void qq_host$pch_$setdebug(struct qq_decls$varrec *a);
void qq_host$pch_copy(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_host$pch_gethash(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_makeempty(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_$infinity(struct qq_decls$varrec *dest);
void qq_host$pch_$nan(struct qq_decls$varrec *dest);
void qq_host$setcmdparam(i64 index,u8 *s);
void qq_host$pch_$nprocs(struct qq_decls$varrec *result);
static void qq_host$initprocrefs(void);
void qq_host$pch_$procname(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_$procref(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$start(void);
void qq_lex$lexreadtoken(void);
static void qq_lex$lxreadstring(i64 termchar);
void qq_lex$lexinit(void);
static void qq_lex$readrawstring(void);
i64 qq_lex$lookup(u8 *name,i64 length,i64 hashindex);
i64 qq_lex$gethashvaluez(u8 *s);
void qq_lex$start(void);
static void qq_lex$inithashtable(void);
static void qq_lex$addstname(u8 *name,i64 symbol,i64 subcode);
void qq_lex$startlex(struct qq_decls$filerec *pm);
struct qq_decls$strec *qq_lex$addnamestr(u8 *name);
void qq_lex$ps(u8 *caption);
void qq_lex$psnext(u8 *caption);
void qq_lex$lex(void);
void qq_lex$lxerror_s(u8 *mess,u8 *a);
static void qq_lex$makedecimal(u8 *s,i64 length,i64 base);
static void qq_lex$readdec(void);
static void qq_lex$readhex(void);
static void qq_lex$readbin(void);
static void qq_lex$readreal(void);
static void qq_lex$readrawxname(void);
void qq_lib$reportcterror(u8 *errortype,u8 *mess,i64 pos,struct qq_decls$strec *currproc);
struct qq_decls$locrec qq_lib$geterrorinfo(u64 pos,struct qq_decls$strec *currproc);
void qq_lib$setlineno(struct qq_decls$locrec *loc,i64 offset);
static void qq_lib$showerrorsource(struct qq_decls$locrec loc);
void qq_lib$stopcompiler(struct qq_decls$locrec loc);
void qq_lib$gerror(u8 *mess,struct qq_decls$unitrec *p);
void qq_lib$gerror_s(u8 *mess,u8 *param,struct qq_decls$unitrec *p);
void qq_lib$serror(u8 *mess);
void qq_lib$serror_s(u8 *mess,u8 *param);
void qq_lib$rxerror(u8 *mess,struct qq_decls$unitrec *p);
void qq_lib$rxerror_s(u8 *mess,u8 *param,struct qq_decls$unitrec *p);
void qq_lib$lxerror(u8 *mess);
void qq_lib$pcnotmut(void);
void qq_lib$pcerror(u8 *mess);
void qq_lib$pcerror_s(u8 *mess,u8 *param);
void qq_lib$reportpcerror(u8 *mess,i64 *pcptr);
struct qq_decls$locrec qq_lib$getpcerrorpos(i64 *pc);
void qq_lib$loaderror(u8 *mess,u8 *mess2);
static i64 qq_lib$findmodulefrompc(i64 *pc);
void qq_lib$prterror(u8 *mess);
void qq_lib$pcustype(u8 *mess,struct qq_decls$varrec *x);
void qq_lib$pcustype_t(u8 *mess,i64 t);
void qq_lib$pcmxtypes(u8 *mess,struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_lib$pcmxtypestt(u8 *mess,i64 t,i64 u);
struct qq_decls$unitrec *qq_lib$allocunitrec(void);
struct qq_decls$unitrec *qq_lib$createintunit(i64 a);
struct qq_decls$unitrec *qq_lib$createrealunit(r64 x);
struct qq_decls$unitrec *qq_lib$createstringunit(u8 *s,i64 slength);
struct qq_decls$unitrec *qq_lib$createunit0(i64 tag);
struct qq_decls$unitrec *qq_lib$createunit1(i64 tag,struct qq_decls$unitrec *p);
struct qq_decls$unitrec *qq_lib$createunit2(i64 tag,struct qq_decls$unitrec *p,struct qq_decls$unitrec *q);
struct qq_decls$unitrec *qq_lib$createname(struct qq_decls$strec *p);
void qq_lib$addlistunit(struct qq_decls$unitrec **ulist,struct qq_decls$unitrec **ulistx,struct qq_decls$unitrec *p);
struct qq_decls$unitrec *qq_lib$createavname(void);
u8 *qq_lib$convtostringz(u8 *svalue,i64 length);
u8 *qq_lib$findprocname(void (*fnptr)(void));
struct mlib$strbuffer *qq_lib$strexpr(struct qq_decls$unitrec *p);
u8 *qq_lib$strexpr_s(struct qq_decls$unitrec *p);
static void qq_lib$jeval(struct qq_decls$unitrec *p);
static void qq_lib$jevallist(struct qq_decls$unitrec *p);
void qq_lib$additem(u8 *s);
static i64 qq_lib$isalphanum(i64 c);
u8 *qq_lib$getopcname(i64 opc);
void qq_lib$convertstring(u8 *s,u8 *t);
struct qq_decls$unitrec *qq_lib$createavnamex(struct qq_decls$strec *owner);
void qq_lib$storemode(struct qq_decls$strec *owner,i64 m,i16 *p);
i64 qq_lib$nextpoweroftwo(i64 x);
i64 *qq_lib$raiseexception(i64 exceptno);
void qq_lib$raise_error(i64 error_no);
i64 qq_lib$testelem(byte (*p)[],i64 n);
void qq_lib$setelem(byte (*p)[],i64 n);
void qq_lib$setelemblock(byte (*p)[],i64 a,i64 b);
i64 qq_lib$ispoweroftwo(i64 x);
void qq_lib$deleteunit(struct qq_decls$unitrec *p,struct qq_decls$unitrec *q);
void qq_lib$skipsemi(void);
void qq_lib$checksymbol(i64 symbol);
void qq_lib$skipsymbol(i64 symbol);
void qq_lib$start(void);
void qq_lists$start(void);
void qq_lists$var_empty_list(i64 lower,struct qq_decls$varrec *dest);
void qq_lists$var_make_list(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 lower);
struct qq_decls$objrec *qq_lists$obj_newlist(i64 n,i64 lower,struct qq_decls$varrec *defval);
void qq_lists$obj_free_list(struct qq_decls$objrec *p);
void qq_lists$var_getix_list(struct qq_decls$varrec *a,i64 index);
void qq_lists$var_getslice_list(struct qq_decls$varrec *a,i64 i,i64 j);
void qq_lists$var_getixref_list(struct qq_decls$varrec *a,i64 index);
void qq_lists$var_putix_list(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_lists$var_putslice_list(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x);
static void qq_lists$obj_append_list(struct qq_decls$objrec *a,struct qq_decls$varrec *x);
void qq_lists$obj_resize_list(struct qq_decls$objrec *p,i64 n);
void qq_lists$var_appendto_list(struct qq_decls$varrec *a,struct qq_decls$varrec *x);
void qq_lists$var_dupl_list(struct qq_decls$varrec *a);
void qq_lists$var_mul_list(struct qq_decls$varrec *p,i64 m);
i64 qq_lists$var_equal_list(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_lists$var_concatto_list(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_lists$var_inx_list(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
struct qq_decls$subprogrec *qq_modules$loadsp(u8 *filename,u8 *source);
static u8 *qq_modules$getmodulefilename(u8 *path,u8 *name);
struct qq_decls$filerec *qq_modules$loadsourcefile(u8 *filespec,i64 issyslib);
struct qq_decls$filerec *qq_modules$loadstring(u8 *name,u8 *source);
static u8 *qq_modules$readfileline(u8 *s);
static u8 *qq_modules$findnextlineheader(u8 *s);
static i64 qq_modules$loadqafile(struct qq_decls$filerec *pm);
void qq_modules$readqabundle(void);
void qq_modules$start(void);
struct qq_decls$strec *qq_names$addglobalname(u8 *name);
static struct qq_decls$strec *qq_names$newstrec(void);
struct qq_decls$strec *qq_names$addsymbol(struct qq_decls$strec *owner,struct qq_decls$strec *d,i64 id,i64 isglobal);
void qq_names$addproc(struct qq_decls$strec *d);
i64 qq_names$newusertypex(struct qq_decls$strec *d,struct qq_decls$strec *e);
struct qq_decls$strec *qq_names$resolvedottedname(struct qq_decls$strec *owner,struct qq_decls$strec *d);
void qq_names$addgenfield(struct qq_decls$strec *d);
i64 qq_names$makereftype(i64 target,struct qq_decls$strec *owner);
i64 qq_names$makeaxtype(i64 target,struct qq_decls$unitrec *plower,struct qq_decls$unitrec *plength);
i64 qq_names$makeslicetype(i64 target);
i64 qq_names$makestrtype(i64 m,struct qq_decls$unitrec *pwidth);
i64 qq_names$addanontype(void);
void qq_names$createusertype(struct qq_decls$strec *d,i64 m);
i64 qq_names$getalignment(i64 m);
void qq_names$duplfield(struct qq_decls$strec *p,struct qq_decls$strec *q);
static void qq_names$writesig(struct qq_decls$strec *d,void *dev);
struct qq_decls$strec *qq_names$createdupldef(struct qq_decls$strec *owner,struct qq_decls$strec *symptr,i64 id);
void qq_names$start(void);
void qq_optimdummy$optimise_module(i64 n);
void qq_optimdummy$start(void);
void qq_packed$var_loadpacked(void *p,i64 t,struct qq_decls$varrec *dest,struct qq_decls$objrec *ownerobj);
void qq_packed$var_storepacked(byte *p,struct qq_decls$varrec *q,i64 t);
static void qq_packed$setfslength(u8 *s,i64 m,i64 n);
i64 qq_packed$getfslength(u8 *s,i64 m);
void qq_packed$var_make_struct(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 rectype);
struct qq_decls$objrec *qq_packed$obj_new_struct(i64 m);
void qq_packed$var_dupl_struct(struct qq_decls$varrec *a);
void qq_packed$obj_free_struct(struct qq_decls$objrec *p);
i64 qq_packed$var_equal_struct(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_packed$var_getix_struct(struct qq_decls$varrec *a,i64 index);
void qq_packed$start(void);
void qq_parse$parsemodule(struct qq_decls$filerec *pm);
static struct qq_decls$unitrec *qq_parse$readexpression(void);
static struct qq_decls$unitrec *qq_parse$readassignment(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readorterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readandterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readcmpterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readinterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readrangeterm(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readaddterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readmulterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readpowerterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readterm2(void);
static struct qq_decls$unitrec *qq_parse$readtermsuffix(struct qq_decls$unitrec *p,i64 pos);
static struct qq_decls$unitrec *qq_parse$readterm(void);
static struct qq_decls$unitrec *qq_parse$readsunit(i64 inwhile);
static void qq_parse$checkequals(void);
static struct qq_decls$unitrec *qq_parse$readindex(struct qq_decls$unitrec *p,i64 dot);
static struct qq_decls$unitrec *qq_parse$readdotsuffix(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readslist(i64 *nparams,i64 ftrailing);
static struct qq_decls$unitrec *qq_parse$readcondsuffix(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readkeyindex(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readlbrack(void);
static struct qq_decls$unitrec *qq_parse$readif(void);
static void qq_parse$checkend(i64 endkwd1,i64 endkwd2,i64 startline);
static struct qq_decls$unitrec *qq_parse$readunless(void);
static struct qq_decls$unitrec *qq_parse$readwhile(void);
static struct qq_decls$unitrec *qq_parse$readrepeat(void);
static struct qq_decls$unitrec *qq_parse$readfor(void);
static struct qq_decls$unitrec *qq_parse$readdo(void);
static struct qq_decls$unitrec *qq_parse$readto(void);
static struct qq_decls$unitrec *qq_parse$makeblock(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readvardef(i64 isglobal,i64 isstatic);
static void qq_parse$readconstdef(i64 isglobal);
static struct qq_decls$unitrec *qq_parse$readreturn(void);
static struct qq_decls$unitrec *qq_parse$readprint(void);
static struct qq_decls$unitrec *qq_parse$readread(void);
static struct qq_decls$unitrec *qq_parse$readloopcontrol(void);
static struct qq_decls$unitrec *qq_parse$readintunit(void);
static struct qq_decls$unitrec *qq_parse$readswitchcase(void);
static struct qq_decls$unitrec *qq_parse$readgoto(void);
static struct qq_decls$unitrec *qq_parse$readstop(void);
static struct qq_decls$unitrec *qq_parse$readcast(void);
static struct qq_decls$unitrec *qq_parse$readset(void);
void qq_parse$readtabledef(i64 isglobal);
static struct qq_decls$unitrec *qq_parse$readtry(void);
static struct qq_decls$unitrec *qq_parse$readsprint(void);
static struct qq_decls$unitrec *qq_parse$readsread(void);
static void qq_parse$readimportdll(void);
static void qq_parse$readffiparams(struct qq_decls$strec *stproc);
static void qq_parse$readtypeparams(struct qq_decls$strec *stproc,i64 ptype);
static void qq_parse$readtypenameparams(struct qq_decls$strec *stproc,i64 ptype);
void qq_parse$readrecorddef(i64 isglobal,struct qq_decls$strec *d);
static i64 qq_parse$readrecordbody(struct qq_decls$strec *owner);
static void qq_parse$readrecordfields(struct qq_decls$strec *owner);
static i64 qq_parse$readstructbody(struct qq_decls$strec *owner,i64 caligned);
static void qq_parse$addstructflag(struct qq_decls$strec *owner,i64 id);
static void qq_parse$readprocdef(i64 isglobal);
static struct qq_decls$strec *qq_parse$readatfield(void);
static i64 qq_parse$istypestarter(void);
static void qq_parse$readmacrodef(i64 isglobal);
static struct qq_decls$unitrec *qq_parse$readhostparams(struct qq_decls$unitrec *lhs,i64 isfn);
static void qq_parse$pushlisttype(i64 ltype);
static void qq_parse$poplisttype(void);
static struct qq_decls$unitrec *qq_parse$readcompilervar(void);
static struct qq_decls$unitrec *qq_parse$readpair(i64 opc);
void qq_parse$lexchecksymbol(i64 symbol);
static void qq_parse$readtypedef(i64 isglobal);
static i64 qq_parse$readtypespec(i64 allowvar,struct qq_decls$strec *owner);
static void qq_parse$readparams(struct qq_decls$strec *stproc);
static struct qq_decls$unitrec *qq_parse$checkoperator(void);
static struct qq_decls$unitrec *qq_parse$readlambda(void);
static void qq_parse$readpackvars(struct qq_decls$strec *owner,i64 id);
void qq_parse$start(void);
void qq_print$pch_print(struct qq_decls$varrec *p,struct qq_decls$varrec *fmt);
void qq_print$pch_print_nf(struct qq_decls$varrec *p);
void qq_print$pch_printnogap(void);
void qq_print$pch_println(void);
void qq_print$pch_reread(void);
void qq_print$pch_rereadln(void);
void qq_print$pch_startprint(struct qq_decls$varrec *p);
void qq_print$pch_startprintcon(void);
void qq_print$pch_endprint(void);
void qq_print$pch_strstartprint(void);
void qq_print$pch_strendprint(struct qq_decls$varrec *dest);
void qq_print$pch_printspace(void);
void qq_print$pch_readln(struct qq_decls$varrec *dev);
void qq_print$pch_sread(struct qq_decls$varrec *fmt,struct qq_decls$varrec *dest);
void qq_print$pch_sreadln(struct qq_decls$varrec *dev,struct qq_decls$varrec *dest);
static u8 *qq_print$readname(u8 *s,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readstring(u8 *s,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readint(u8 *sold,i64 length,struct qq_decls$varrec *dest,i64 dodec);
static u8 *qq_print$readhex(u8 *sold,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readbin(u8 *sold,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readreal(u8 *sold,i64 length,struct qq_decls$varrec *dest);
i64 qq_print$getreadfmtcode(struct qq_decls$varrec *p);
static void qq_print$stepkbpos(u8 *s);
static u8 *qq_print$readany(u8 *sold,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readitem(u8 *s,i64 length,u8 **itemstr,i64 *itemlength);
static void qq_print$strtoreal(u8 *s,i64 length,struct qq_decls$varrec *dest);
static void qq_print$strtoint(u8 *s,i64 length,struct qq_decls$varrec *dest,i64 dodec);
static void qq_print$printnextfmtchars(i64 lastx);
void qq_print$pch_setformat(struct qq_decls$varrec *p);
struct msysc$fmtrec *qq_print$pc_getfmt(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt);
void qq_print$addstring(struct qq_decls$objrec *p,u8 *t,i64 n);
static void qq_print$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt);
static void qq_print$printstr_n(u8 *s,i64 n);
void qq_print$pch_strtoval(struct qq_decls$varrec *p,struct qq_decls$varrec *fmt,struct qq_decls$varrec *dest);
static void qq_print$tostr_int(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_real(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_str(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
void qq_print$pch_tostr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
static void qq_print$tostr_range(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_array(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_bits(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_struct(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_set(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_dict(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_decimal(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_list(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest);
void qq_print$start(void);
void qq_pclgen$evalunit(struct qq_decls$unitrec *p,i64 res);
void qq_pclgen$gencodemodule(struct qq_decls$subprogrec *sp,i64 moduleno);
static void qq_pclgen$do_procdef(struct qq_decls$strec *p);
static void qq_pclgen$genprocentry(struct qq_decls$strec *p,i64 *nfreevars,i64 *nnofreevars);
static void qq_pclgen$genprocexit(i64 nfree,i64 nnofree,i64 isfunc);
static void qq_pclgen$evalref(struct qq_decls$unitrec *p);
static void qq_pclgen$genjumpcond(i64 opc,struct qq_decls$unitrec *p,i64 lab);
static void qq_pclgen$gcomparejump(i64 jumpopc,i64 cond,i64 lab);
static void qq_pclgen$genjumpl(i64 lab);
static i64 qq_pclgen$reversecond(i64 op);
void qq_pclgen$stacklooplabels(i64 *a,i64 *b,i64 *c);
void qq_pclgen$unstacklooplabels(void);
i64 qq_pclgen$findlooplabel(i64 k,i64 n);
static void qq_pclgen$do_assign(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 res,i64 deepcopy);
static void qq_pclgen$do_bin(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 opc);
static void qq_pclgen$do_binref(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 opc);
static void qq_pclgen$do_unary(struct qq_decls$unitrec *a,i64 opc);
static void qq_pclgen$do_unaryref(struct qq_decls$unitrec *a,i64 opc);
static void qq_pclgen$do_pushlist(struct qq_decls$unitrec *a,i64 n);
static void qq_pclgen$do_makedict(struct qq_decls$unitrec *a,i64 n);
static void qq_pclgen$do_call(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 res,i64 *procflag);
static i64 qq_pclgen$pushparams(struct qq_decls$strec *d,struct qq_decls$unitrec *(*arglist)[],i64 nargs,i64 kwdindex);
static void qq_pclgen$evalparam(struct qq_decls$unitrec *a,i64 byref);
static void qq_pclgen$pushkwdparams(struct qq_decls$strec *d,struct qq_decls$unitrec *(*arglist)[],i64 nargs,i64 kwdindex);
static void qq_pclgen$do_if(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,struct qq_decls$unitrec *pelse,i64 res);
static void qq_pclgen$do_do(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a);
static void qq_pclgen$do_exit(struct qq_decls$unitrec *p,i64 k);
static void qq_pclgen$do_to(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pcount,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_while(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pcond,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_repeat(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_for(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pvar,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_forx(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pvar,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_print(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_fprint(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,struct qq_decls$unitrec *c);
static void qq_pclgen$do_read(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_forall(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_case(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res);
static void qq_pclgen$do_case_nc(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res);
static void qq_pclgen$do_try(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static i64 qq_pclgen$unitstoarray(struct qq_decls$unitrec *p,struct qq_decls$unitrec *(*plist)[],i64 maxunits);
static void qq_pclgen$do_select(struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pplist,i64 res);
static void qq_pclgen$do_andl(struct qq_decls$unitrec *x,struct qq_decls$unitrec *y);
static void qq_pclgen$do_orl(struct qq_decls$unitrec *x,struct qq_decls$unitrec *y);
static void qq_pclgen$do_incr(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,i64 res);
static void qq_pclgen$do_new(struct qq_decls$unitrec *p);
static i64 qq_pclgen$checkblockreturn(struct qq_decls$unitrec *p);
static void qq_pclgen$do_callhost(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,i64 res);
static void qq_pclgen$callhostfn(i64 fnindex,i64 calledasfn);
static void qq_pclgen$genfree(i64 n);
static void qq_pclgen$do_return(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a);
static void qq_pclgen$do_multassign(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 deepcopy,i64 res);
static void qq_pclgen$do_store(struct qq_decls$unitrec *a,i64 res);
static i64 qq_pclgen$getconstvalue(struct qq_decls$unitrec *p);
static void qq_pclgen$do_convert(struct qq_decls$unitrec *pconv);
static void qq_pclgen$checkelems(i64 n,i64 length,struct qq_decls$unitrec *p);
static void qq_pclgen$do_switch(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res);
static void qq_pclgen$do_simpleswitch(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,struct qq_decls$unitrec *pelse,i64 a,i64 b,i64 res);
static void qq_pclgen$do_makerecordkv(i64 m,i64 nkeyvals,struct qq_decls$unitrec *(*kvlist)[]);
static void qq_pclgen$do_idiv(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_irem(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_map(struct qq_decls$unitrec *p,struct qq_decls$unitrec *popcode,struct qq_decls$unitrec *x);
static void qq_pclgen$pushstring(u8 *s,i64 length);
void qq_pclgen$start(void);
void qq_pcllib$start(void);
void qq_pcllib$resetpcl(i64 sourcesize);
void qq_pcllib$genpc(i64 opc);
void qq_pcllib$genopnd_int(i64 x);
void qq_pcllib$genopnd_name(struct qq_decls$strec *d);
void qq_pcllib$genpc_int(i64 opc,i64 a);
void qq_pcllib$genpc_int2(i64 opc,i64 a,i64 b);
void qq_pcllib$genpc_int4(i64 opc,i64 a,i64 b,i64 c,i64 d);
void qq_pcllib$genpc_name(i64 opc,struct qq_decls$strec *d);
void qq_pcllib$genopnd_strz(u8 *s);
void qq_pcllib$genopnd_str(struct qq_decls$objrec *s);
void qq_pcllib$genopnd_obj(struct qq_decls$objrec *p);
void qq_pcllib$genpc_real(i64 opc,r64 x);
void qq_pcllib$genpc_lab(i64 opc,i64 a);
void qq_pcllib$genopnd_lab(i64 a);
void qq_pcllib$gencomment(u8 *s);
static void qq_pcllib$extendpcldata(void);
void qq_pcllib$extendlabeltable(void);
i64 qq_pcllib$definelabel(void);
i64 qq_pcllib$createfwdlabel(void);
void qq_pcllib$definefwdlabel(i64 *lab);
void qq_records$var_make_record(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 rectype);
struct qq_decls$objrec *qq_records$obj_new_record(i64 m,struct qq_decls$varrec *defval);
void qq_records$obj_free_record(struct qq_decls$objrec *p);
void qq_records$var_dupl_record(struct qq_decls$varrec *a);
i64 qq_records$var_equal_record(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_records$var_getix_record(struct qq_decls$varrec *a,i64 index);
void qq_records$var_putix_record(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_records$var_getixref_record(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *dest);
void qq_records$start(void);
void qq_resolve$rx_module(struct qq_decls$filerec *pm);
void qq_resolve$rx_passdef(struct qq_decls$strec *owner,struct qq_decls$strec *p);
void qq_resolve$rx_deflist(struct qq_decls$strec *owner,struct qq_decls$strec *p,i64 doanon);
void qq_resolve$rx_unit(struct qq_decls$strec *owner,struct qq_decls$unitrec *p);
static void qq_resolve$rx_unitlist(struct qq_decls$strec *owner,struct qq_decls$unitrec *p);
static void qq_resolve$evalmonop(struct qq_decls$unitrec *p);
static void qq_resolve$evalbinop(struct qq_decls$unitrec *p,struct qq_decls$unitrec *lhs,struct qq_decls$unitrec *rhs);
static void qq_resolve$makeintconst(struct qq_decls$unitrec *p,i64 value);
static void qq_resolve$makerealconst(struct qq_decls$unitrec *p,r64 xvalue);
void qq_resolve$resolvename(struct qq_decls$strec *owner,struct qq_decls$unitrec *p,i64 mode);
struct qq_decls$strec *qq_resolve$resolvetopname(struct qq_decls$strec *owner,struct qq_decls$strec *stnewname,i64 moduleno,i64 allowmod);
static void qq_resolve$resolvedot(struct qq_decls$strec *owner,struct qq_decls$unitrec *p);
static void qq_resolve$resolvedot_sym(struct qq_decls$strec *owner,struct qq_decls$unitrec *p);
struct qq_decls$strec *qq_resolve$finddupl(struct qq_decls$strec *d,struct qq_decls$strec *pdupl);
static void qq_resolve$expandmacro(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static struct qq_decls$unitrec *qq_resolve$copylistunit(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_resolve$copyunit(struct qq_decls$unitrec *p);
static void qq_resolve$replaceunit(struct qq_decls$unitrec *p,struct qq_decls$unitrec *q);
static void qq_resolve$fixmode(struct qq_decls$strec *owner,struct qq_decls$strec *p);
static i64 qq_resolve$fixmode2(struct qq_decls$strec *owner,i64 m);
void qq_resolve$fixusertypes(void);
void qq_resolve$tx_typetable(void);
static i64 qq_resolve$getconstint(struct qq_decls$strec *owner,struct qq_decls$unitrec *a,i64 ownerid);
void qq_resolve$converttype(i64 m);
static void qq_resolve$scanstruct(i64 smode,struct qq_decls$strec *(*fields)[],i64 *index,i64 *isize,i64 offset,i64 calign,i64 *maxalign,i64 countmode);
static void qq_resolve$dobaseclass(i64 baseclassindex);
void qq_resolve$start(void);
void qq_sets$obj_free_set(struct qq_decls$objrec *p);
void qq_sets$var_dupl_set(struct qq_decls$varrec *a);
i64 qq_sets$var_equal_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
static i64 qq_sets$getsetbytes(struct qq_decls$varrec *x);
void qq_sets$var_make_set(struct qq_decls$varrec *data,struct qq_decls$varrec *dest,i64 n);
struct qq_decls$objrec *qq_sets$obj_newset(i64 length);
void qq_sets$var_emptyset(struct qq_decls$varrec *dest);
void qq_sets$var_getix_set(struct qq_decls$varrec *a,i64 index);
void qq_sets$var_putix_set(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_sets$var_getixref_set(struct qq_decls$varrec *a,i64 index);
static byte *qq_sets$getoffset(byte *p,i64 index,i64 *newoffset);
i64 qq_sets$var_in_set(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_sets$iresizeset(struct qq_decls$varrec *p,i64 n);
void qq_sets$obj_resize_set(struct qq_decls$objrec *p,i64 n);
void qq_sets$iorsetbits(i64 *p,i64 *q,i64 n);
void qq_sets$ixorsetbits(i64 *p,i64 *q,i64 n);
void qq_sets$iandsetbits(u64 *p,u64 *q,i64 n);
void qq_sets$inotsetbits(u64 *p,i64 n);
void qq_sets$var_iorto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_sets$var_iandto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_sets$var_ixorto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_sets$var_inotto_set(struct qq_decls$varrec *x);
void qq_sets$start(void);
void qq_strings$start(void);
void qq_strings$var_empty_string(struct qq_decls$varrec *dest,i64 mutable);
void qq_strings$var_make_string(u8 *s,struct qq_decls$varrec *dest,i64 mutable);
void qq_strings$var_make_stringn(u8 *s,i64 length,struct qq_decls$varrec *dest,i64 mutable);
struct qq_decls$objrec *qq_strings$obj_new_string(i64 n);
struct qq_decls$objrec *qq_strings$obj_make_string(u8 *s,i64 mutable);
struct qq_decls$objrec *qq_strings$obj_make_stringn(u8 *s,i64 length,i64 mutable);
void qq_strings$obj_free_string(struct qq_decls$objrec *p);
void qq_strings$var_dupl_string(struct qq_decls$varrec *a);
void qq_strings$var_getix_string(struct qq_decls$varrec *a,i64 index);
void qq_strings$var_getixref_string(struct qq_decls$varrec *a,i64 index);
void qq_strings$var_getdotix_string(struct qq_decls$varrec *a,i64 index);
void qq_strings$var_getdotixref_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *dest);
void qq_strings$var_getslice_string(struct qq_decls$varrec *a,i64 i,i64 j);
static void qq_strings$stringslice(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *dest);
void qq_strings$var_putix_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_strings$var_putslice_string(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x);
void qq_strings$var_putdotix_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_strings$obj_resize_string(struct qq_decls$objrec *p,i64 n);
void qq_strings$var_add_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_strings$var_addto_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_strings$var_addto_string_ch(struct qq_decls$varrec *a,i64 ch);
i64 qq_strings$var_equal_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
i64 qq_strings$var_compare_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
static i64 qq_strings$cmpstring_len(u8 *s,u8 *t,i64 slen,i64 tlen);
i64 qq_strings$var_inx_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_strings$var_iconvcase(struct qq_decls$varrec *a,struct qq_decls$varrec *b,i64 upper);
void qq_strings$var_makestrslicexobj(u8 *s,i64 length,struct qq_decls$varrec *dest);
struct qq_decls$objrec *qq_strings$obj_make_strslicexobj(u8 *s,i64 length);
static i64 qq_strings$var_asc(struct qq_decls$varrec *a);
void qq_strings$var_new_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *dest);
void qq_strings$var_new_stringn(i64 length,struct qq_decls$varrec *dest);
void qq_strings$var_mul_string(struct qq_decls$varrec *a,i64 m);
void qq_strings$var_convert_string_list(struct qq_decls$varrec *a,i64 t,struct qq_decls$varrec *dest);
void qq_strings$var_expand_string(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 m);
void qq_strings$var_makechar(i64 ch,struct qq_decls$varrec *dest);
static u8 *qq_syslibs$findsyslib(u8 *filename);
i64 qq_syslibs$loadsysmodule(struct qq_decls$filerec *pm);
void qq_syslibs$start(void);
void qq_tables$start(void);
void qq_show$printunit(struct qq_decls$unitrec *p,i64 level,u8 *prefix,void *dev);
static void qq_show$printunitlist(void *dev,struct qq_decls$unitrec *p,i64 level,u8 *prefix);
static u8 *qq_show$getprefix(i64 level,u8 *prefix,struct qq_decls$unitrec *p);
static u8 *qq_show$getlineinfok(void);
static void qq_show$gstr(u8 *s);
static void qq_show$gstrln(u8 *s);
static void qq_show$gline(void);
static void qq_show$gstrint(i64 a);
static void qq_show$glabeldef(u64 lab);
void qq_show$printglobalsymbols(void *f);
void qq_show$printst(void *f,struct qq_decls$strec *p,i64 level);
static void qq_show$printstrec(void *f,struct qq_decls$strec *p,i64 level);
void qq_show$printtypetables(void *f);
void qq_show$showsttree(void);
void qq_show$showtypes(void);
void qq_show$showpcl(struct qq_decls$subprogrec *sp,i64 pass);
void qq_show$showpcl2(struct qq_decls$subprogrec *sp,i64 pass);
void qq_show$showast(struct qq_decls$subprogrec *sp,u8 *file);
void qq_show$showast2(void *f,struct qq_decls$subprogrec *sp);
void qq_show$showlogfile(void);
static void qq_show$addtolog(u8 *filename,void *logdest);
void qq_show$showstflat(void);
void qq_show$showmoduleinfo(void *dev);
void qq_show$printsymbol(struct qq_decls$lexrec *lp);
u8 *qq_show$strmode(i64 t,i64 expand);
static void qq_show$istrmode(i64 t,u8 *dest,i64 expand);
static void qq_show$writepcl(i64 *pcstart,i64 *pc,i32 *pclsource,i64 pass,u8 *sourcecode);
static u8 *qq_show$writepclopnd(i64 fmt,i64 x,i64 n,i64 cmdcode,i64 pass,i64 *pcstart);
void qq_show$writeallpcl(struct qq_decls$filerec *pm,i64 pass);
void qq_show$deletetempfiles(void);
void qq_show$start(void);
void qq_vars$var_unshareu(struct qq_decls$varrec *p);
void qq_vars$obj_shareu(struct qq_decls$objrec *p);
struct qq_decls$varrec *qq_vars$void_new(void);
struct qq_decls$objrec *qq_vars$obj_new(void);
i64 qq_vars$var_getintvalue(struct qq_decls$varrec *p);
void qq_vars$var_fromobj(i64 tag,struct qq_decls$objrec *p,struct qq_decls$varrec *dest);
void qq_vars$var_free(struct qq_decls$varrec *a);
void qq_vars$var_duplu(struct qq_decls$varrec *a);
void qq_vars$var_neg(struct qq_decls$varrec *a);
void qq_vars$var_abs(struct qq_decls$varrec *a);
void qq_vars$var_inot(struct qq_decls$varrec *a);
i64 qq_vars$var_istruel(struct qq_decls$varrec *a);
void qq_vars$var_add(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_addmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_addto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
void qq_vars$var_sub(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_submixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_mul(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_mulmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_div(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_divmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_idiv(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_irem(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_iand(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_ior(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_ixor(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_shl(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_shr(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_in(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_inx(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_equal(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_equalmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_compare(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_comparemixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_concat(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_append(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_min(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_max(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_concatto(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_appendto(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_getix(struct qq_decls$varrec *a,i64 index);
void qq_vars$var_putix(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_vars$var_getixref(struct qq_decls$varrec *a,i64 index);
void qq_vars$var_getslice(struct qq_decls$varrec *a,i64 i,i64 j);
void qq_vars$var_putslice(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x);
void qq_vars$var_getdotix(struct qq_decls$varrec *a,i64 index);
void qq_vars$var_putdotix(struct qq_decls$varrec *p,i64 index,struct qq_decls$varrec *x);
void qq_vars$var_getdotixref(struct qq_decls$varrec *p,i64 index);
void qq_vars$var_getdotslice(struct qq_decls$varrec *a,i64 i,i64 j);
void qq_vars$var_putdotslice(struct qq_decls$varrec *p,i64 i,i64 j,struct qq_decls$varrec *x);
void qq_vars$var_getdotsliceref(struct qq_decls$varrec *p,i64 i,i64 j);
void qq_vars$var_expand(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 m);
void qq_vars$var_inplace(struct qq_decls$varrec *px,struct qq_decls$varrec *y,void (*fnadd)(struct qq_decls$varrec *,struct qq_decls$varrec *,...),void (*fnaddmixed)(struct qq_decls$varrec *,struct qq_decls$varrec *,...));
void qq_vars$var_inplace_unary(struct qq_decls$varrec *px,void (*fnneg)(struct qq_decls$varrec *,...));
void qq_vars$var_loadptr(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_vars$var_storeptr(struct qq_decls$varrec *p,struct qq_decls$varrec *q);
void qq_vars$var_loadbit(byte *p,i64 shift,i64 t,i64 bitlength,struct qq_decls$varrec *dest);
void qq_vars$var_storebit(byte *p,i64 shift,struct qq_decls$varrec *q,i64 t,i64 bitlength);
void qq_vars$var_convert(struct qq_decls$varrec *x,i64 t,struct qq_decls$varrec *dest);
i64 qq_vars$var_gethashvalue(struct qq_decls$varrec *p);
void qq_vars$var_objtovar(i64 tag,struct qq_decls$objrec *p,struct qq_decls$varrec *q);
void qq_vars$var_putdotix_intint(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *b);
void qq_vars$var_power(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_powermixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$start(void);
void msysc$m_init(i64 nargs,u8 *(*args)[]);
i64 msysc$m_getdotindex(u64 a,i64 i);
u64 msysc$m_setdotindex(u64 a,i64 i,i64 x);
i64 msysc$m_getdotslice(u64 a,i64 i,i64 j);
u64 msysc$m_setdotslice(u64 a,i64 i,i64 j,u64 x);
i64 msysc$m_get_nprocs(void);
i64 msysc$m_get_nexports(void);
u8 *msysc$m_get_procname(i64 n);
void *msysc$m_get_procaddr(i64 n);
void *msysc$m_get_procexport(i64 n);
static void msysc$pushio(void);
void msysc$m_print_startfile(void *dev);
void msysc$m_print_startstr(u8 *s);
void msysc$m_print_startptr(u8 **p);
void msysc$m_print_startcon(void);
void msysc$m_print_setfmt(u8 *format);
void msysc$m_print_end(void);
void msysc$m_print_ptr(void *a,u8 *fmtstyle);
void msysc$m_print_i64(i64 a,u8 *fmtstyle);
void msysc$m_print_u64(u64 a,u8 *fmtstyle);
void msysc$m_print_r64(r64 x,u8 *fmtstyle);
void msysc$m_print_r32(r32 x,u8 *fmtstyle);
void msysc$m_print_c8(i64 a,u8 *fmtstyle);
void msysc$m_print_str(u8 *s,u8 *fmtstyle);
void msysc$m_print_newline(void);
void msysc$m_print_nogap(void);
void msysc$m_print_space(void);
void msysc$printstr(u8 *s);
void msysc$printstr_n(u8 *s,i64 n);
void msysc$printstrn_app(u8 *s,i64 length,void *f);
static u8 *msysc$makezstring(u8 *s,i64 n,u8 *local);
static void msysc$freezstring(u8 *t,i64 n);
static void msysc$printchar(i64 ch);
void msysc$nextfmtchars(i64 lastx);
void msysc$strtofmt(u8 *s,i64 slen,struct msysc$fmtrec *fmt);
static i64 msysc$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt);
i64 msysc$expandstr(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt);
static i64 msysc$u64tostr(u64 aa,u8 *s,u64 base,i64 sep);
i64 msysc$i64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt);
i64 msysc$u64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt);
static i64 msysc$i64mintostr(u8 *s,i64 base,i64 sep);
i64 msysc$strtostrfmt(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt);
static void msysc$tostr_i64(i64 a,struct msysc$fmtrec *fmt);
static void msysc$tostr_u64(u64 a,struct msysc$fmtrec *fmt);
static void msysc$tostr_r64(r64 x,struct msysc$fmtrec *fmt);
static void msysc$tostr_str(u8 *s,struct msysc$fmtrec *fmt);
static struct msysc$fmtrec *msysc$getfmt(u8 *fmtstyle);
u8 *msysc$strint(i64 a,u8 *fmtstyle);
void msysc$getstrint(i64 a,u8 *dest);
u8 *msysc$strword(u64 a,u8 *fmtstyle);
u8 *msysc$strreal(r64 a,u8 *fmtstyle);
static u8 *msysc$getstr(u8 *s,struct msysc$fmtrec *fmt);
static void msysc$initreadbuffer(void);
void msysc$m_read_conline(void);
void msysc$m_read_fileline(void *f);
void msysc$m_read_strline(u8 *s);
static u8 *msysc$readitem(i64 *itemlength);
i64 msysc$strtoint(u8 *s,i64 length,i64 base);
i64 msysc$m_read_i64(i64 fmt);
r64 msysc$m_read_r64(i64 fmt);
void msysc$m_read_str(u8 *dest,i64 destlen,i64 fmt);
void msysc$readstr(u8 *dest,i64 fmt,i64 destlen);
void msysc$rereadln(void);
void msysc$reread(void);
i64 msysc$valint(u8 *s,i64 fmt);
r64 msysc$valreal(u8 *s);
static void msysc$iconvlcn(u8 *s,i64 n);
static void msysc$iconvucn(u8 *s,i64 n);
static void msysc$convlcstring(u8 *s);
static void msysc$convucstring(u8 *s);
i64 msysc$m_power_i64(i64 n,i64 a);
void msysc$m_intoverflow(void);
void msysc$m_dotindex(u64 i,u64 a);
void msysc$m_dotslice(u64 j,u64 i,u64 a);
void msysc$m_popdotindex(u64 i,u64 *p,u64 x);
void msysc$m_popdotslice(u64 j,u64 i,u64 *p,u64 x);
i64 msysc$m_imin(i64 a,i64 b);
i64 msysc$m_imax(i64 a,i64 b);
r64 msysc$m_sign(r64 x);
r64 msysc$m_tp_i64tor64(i64 a);
i64 msysc$m_tp_r64toi64(r64 x);
i64 msysc$m_tp_reftoi64(void *p);
void *msysc$m_tp_i64toref(i64 a);
void msysc$start(void);
void *mlib$pcm_alloc(i64 n);
void mlib$pcm_free(void *p,i64 n);
void mlib$pcm_freeac(void *p,i64 alloc);
void mlib$pcm_clearmem(void *p,i64 n);
void mlib$pcm_init(void);
i64 mlib$pcm_getac(i64 size);
void *mlib$pcm_newblock(i64 itemsize);
i64 mlib$pcm_round(i64 n);
void *mlib$pcm_allocz(i64 n);
u8 *mlib$pcm_copyheapstring(u8 *s);
u8 *mlib$pcm_copyheapstringn(u8 *s,i64 n);
u8 *mlib$pcm_copyheapblock(u8 *s,i64 length);
void *mlib$allocmem(i64 n);
void *mlib$reallocmem(void *p,i64 n);
void mlib$abortprogram(u8 *s);
i64 mlib$getfilesize(void *handlex);
void mlib$readrandom(void *handlex,byte *mem,i64 offset,i64 size);
i64 mlib$writerandom(void *handlex,byte *mem,i64 offset,i64 size);
i64 mlib$setfilepos(void *file,i64 offset);
i64 mlib$getfilepos(void *file);
byte *mlib$readfile(u8 *filename);
i64 mlib$writefile(u8 *filename,byte *data,i64 size);
i64 mlib$checkfile(u8 *file);
void mlib$readlinen(void *handlex,u8 *buffer,i64 size);
void mlib$iconvlcn(u8 *s,i64 n);
void mlib$iconvucn(u8 *s,i64 n);
u8 *mlib$convlcstring(u8 *s);
u8 *mlib$convucstring(u8 *s);
u8 *mlib$changeext(u8 *s,u8 *newext);
u8 *mlib$extractext(u8 *s,i64 period);
u8 *mlib$extractpath(u8 *s);
u8 *mlib$extractfile(u8 *s);
u8 *mlib$extractbasefile(u8 *s);
u8 *mlib$addext(u8 *s,u8 *newext);
void *mlib$pcm_alloc32(void);
void mlib$pcm_free32(void *p);
void mlib$outbyte(void *f,i64 x);
void mlib$outword16(void *f,u64 x);
void mlib$outword32(void *f,u64 x);
void mlib$outword64(void *f,u64 x);
void mlib$outstring(void *f,u8 *s);
void mlib$outblock(void *f,void *p,i64 n);
i64 mlib$myeof(void *f);
void mlib$strbuffer_add(struct mlib$strbuffer *dest,u8 *s,i64 n);
void mlib$gs_init(struct mlib$strbuffer *dest);
void mlib$gs_free(struct mlib$strbuffer *dest);
void mlib$gs_str(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_char(struct mlib$strbuffer *dest,i64 c);
void mlib$gs_strn(struct mlib$strbuffer *dest,u8 *s,i64 length);
void mlib$gs_strvar(struct mlib$strbuffer *dest,struct mlib$strbuffer *s);
void mlib$gs_strint(struct mlib$strbuffer *dest,i64 a);
void mlib$gs_strln(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_strsp(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_line(struct mlib$strbuffer *dest);
i64 mlib$gs_getcol(struct mlib$strbuffer *dest);
void mlib$gs_leftstr(struct mlib$strbuffer *dest,u8 *s,i64 w,i64 padch);
void mlib$gs_leftint(struct mlib$strbuffer *dest,i64 a,i64 w,i64 padch);
void mlib$gs_padto(struct mlib$strbuffer *dest,i64 col,i64 ch);
void mlib$gs_println(struct mlib$strbuffer *dest,void *f);
i64 mlib$nextcmdparamnew(i64 *paramno,u8 **name,u8 **value,u8 *defext);
static i64 mlib$readnextfileitem(u8 **fileptr,u8 **item);
void mlib$ipadstr(u8 *s,i64 width,u8 *padchar);
u8 *mlib$padstr(u8 *s,i64 width,u8 *padchar);
u8 *mlib$chr(i64 c);
i64 mlib$cmpstring(u8 *s,u8 *t);
i64 mlib$cmpstringn(u8 *s,u8 *t,i64 n);
i64 mlib$eqstring(u8 *s,u8 *t);
i64 mlib$cmpbytes(void *p,void *q,i64 n);
i64 mlib$eqbytes(void *p,void *q,i64 n);
void mlib$mseed(u64 a,u64 b);
u64 mlib$mrandom(void);
i64 mlib$mrandomp(void);
i64 mlib$mrandomint(i64 n);
i64 mlib$mrandomrange(i64 a,i64 b);
r64 mlib$mrandomreal(void);
r64 mlib$mrandomreal1(void);
u8 *mlib$readline(void);
void *mlib$findfunction(u8 *name);
i64 mlib$roundtoblock(i64 n,i64 align);
void *mlib$pcm_allocnfz(i64 n);
void mlib$start(void);
extern void *malloc(u64 $1);
extern void *realloc(void *$1,u64 $2);
extern void free(void *$1);
extern void memset(void *$1,i32 $2,u64 $3);
extern void memcpy(void *$1,void *$2,u64 $3);
extern void memmove(void *$1,void *$2,u64 $3);
extern i32 clock(void);
extern i32 ftell(void *$1);
extern i32 fseek(void *$1,i32 $2,i32 $3);
extern u64 fread(void *$1,u64 $2,u64 $3,void *$4);
extern u64 fwrite(void *$1,u64 $2,u64 $3,void *$4);
extern i32 getc(void *$1);
extern i32 ungetc(i32 $1,void *$2);
extern void *fopen(u8 *a,u8 *b);
extern i32 fclose(void *$1);
extern u8 *fgets(u8 *$1,i64 $2,void *$3);
extern i32 remove(u8 *$1);
extern i32 rename(u8 *$1,u8 *$2);
extern i32 getchar(void);
extern void putchar(i32 $1);
extern void setbuf(void *$1,byte *$2);
extern i64 strlen(u8 *$1);
extern u8 *strcpy(u8 *$1,u8 *$2);
extern i32 strcmp(u8 *$1,u8 *$2);
extern i32 strncmp(u8 *$1,u8 *$2,u64 $3);
extern u64 strncpy(u8 *$1,u8 *$2,u64 $3);
extern i32 memcmp(void *$1,void *$2,u64 $3);
extern u8 *strcat(u8 *$1,u8 *$2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u8 *strstr(u8 *$1,u8 *$2);
extern i64 atol(u8 *$1);
extern i32 atoi(u8 *$1);
extern r64 strtod(u8 *$1,u8 **$2);
extern u8 *_strdup(u8 *$1);
extern i32 puts(u8 *$1);
extern i32 printf(u8 *$1,...);
extern i32 sprintf(u8 *$1,u8 *$2,...);
extern i32 sscanf(u8 *$1,u8 *$2,...);
extern i32 scanf(u8 *$1,...);
extern i32 rand(void);
extern void srand(u32 $1);
extern i32 system(u8 *$1);
extern i32 fgetc(void *$1);
extern i32 fputc(i32 $1,void *$2);
extern i32 fprintf(void *$1,u8 *$2,...);
extern i32 fputs(u8 *$1,void *$2);
extern i32 feof(void *$1);
extern i32 getch(void);
extern i32 _getch(void);
extern i32 kbhit(void);
extern i32 _mkdir(u8 *$1);
extern i32 mkdir(u8 *$1);
extern u8 *strchr(u8 *$1,i32 $2);
extern i32 _setmode(i32 $1,i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1,r64 $2);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern i64 llabs(i64 $1);
extern void qsort(void *$1,u64 $2,u64 $3,void (*$4)(void));
extern i32 __getmainargs(i32 *$1,void *$2,void *$3,i64 $4,void *$5);
void mclib$start(void);
extern void *dlopen(u8 *$1,i32 $2);
extern void *dlsym(void *$1,u8 *$2);
extern i32 tcgetattr(i32 $1,struct mlinux$termios *$2);
extern i32 tcsetattr(i32 $1,i32 $2,struct mlinux$termios *$3);
extern i32 gettimeofday(struct mlinux$timeval *$1,void *$2);
extern void *gmtime_r(i64 *$1,struct mlinux$tm_rec *$2);
void mlinux$os_init(void);
i64 mlinux$os_execwait(u8 *cmdline,i64 newconsole,u8 *workdir);
i64 mlinux$os_execcmd(u8 *cmdline,i64 newconsole);
i64 mlinux$os_getch(void);
i64 mlinux$os_kbhit(void);
void mlinux$os_flushkeys(void);
void *mlinux$os_getconsolein(void);
void *mlinux$os_getconsoleout(void);
void *mlinux$os_proginstance(void);
u64 mlinux$os_getdllinst(u8 *name);
void *mlinux$os_getdllprocaddr(i64 hlib,u8 *name);
void mlinux$os_initwindows(void);
i64 mlinux$os_getchx(void);
u8 *mlinux$os_getos(void);
i64 mlinux$os_gethostsize(void);
i64 mlinux$os_iswindows(void);
i64 mlinux$os_shellexec(u8 *opc,u8 *file);
void mlinux$os_sleep(i64 a);
void *mlinux$os_getstdin(void);
void *mlinux$os_getstdout(void);
u8 *mlinux$os_gethostname(void);
u8 *mlinux$os_getmpath(void);
void mlinux$os_exitprocess(i64 x);
i64 mlinux$os_clock(void);
i64 mlinux$os_ticks(void);
i64 mlinux$os_getclockspersec(void);
void mlinux$os_setmesshandler(void *addr);
i64 mlinux$os_hpcounter(void);
i64 mlinux$os_hpfrequency(void);
i64 mlinux$os_filelastwritetime(u8 *filename);
void mlinux$os_getsystime(struct mlinux$rsystemtime *tm);
void mlinux$os_peek(void);
byte *mlinux$os_allocexecmem(i64 n);
i64 mlinux$dirlist(u8 *filespec,u8 *(*dest)[],i64 capacity,i64 t);
void mlinux$start(void);
u64 mwindllc$os_calldllfunction(void (*fnaddr)(void),i64 retcode,i64 nargs,i64 (*args)[],byte (*argcodes)[]);
u64 mwindllc$os_pushargs(u64 (*args)[],i64 nargs,i64 nextra,void (*fnaddr)(void),i64 isfloat);
static i64 mwindllc$calldll_cint(void (*fnaddr)(void),i64 (*params)[],i64 nparams);
static i64 mwindllc$calldll_creal(void (*fnaddr)(void),i64 (*params)[],i64 nparams);
void mwindllc$os_dummycall(r64 a,r64 b,r64 c,r64 d);
void mwindllc$start(void);

/* VARS */
static i64 qq_cli$cmdstartindex;
static u8 *  qq_api$runnames[6] = {(byte*)"load_cc",(byte*)"parse_cc",(byte*)"names_cc",(byte*)"gencode_cc",(byte*)"fixup_cc",(byte*)"run_cc"};
static byte qq_api$fshowpcl1;
static byte qq_api$fshowpcl2;
static byte qq_api$fshowpcl3;
static byte qq_api$fshowast1;
static byte qq_api$fshowast2;
static byte qq_api$fshowst;
static byte qq_api$fshowstflat;
static byte qq_api$fshowtypes;
static byte qq_api$foptimise = (byte)(i64)1;
static byte qq_api$fwriteqa;
static byte qq_api$fshowmodules;
static byte qq_api$fallsp;
static byte qq_api$runcode = (byte)(i64)6;
static u8 *  qq_api$sourcestr;
static u8 *  qq_api$inputfile;
static struct qq_decls$varrec *  qq_api$statictable[11000];
static struct qq_decls$strec *  qq_api$staticdefs[11000];
static i64 qq_api$nstatics;
static i64 *  qq_api$proctable[11000];
static struct qq_decls$strec *  qq_api$procdefs[11000];
static i64 qq_api$nprocs;
static struct mlib$strbuffer *  qq_api$pclstr;
static u8 *  qq_decimal$fpnames[4] = {(byte*)"zero_type",(byte*)"normal_type",(byte*)"inf_type",(byte*)"nan_type"};
static i64 qq_decimal$currprec = (i64)55;
static i64 qq_decimal$stblz;
static struct qq_decimal$constrec *  qq_decimal$constlist = 0;
static i64 qq_decimal$decstrsize;
static struct qq_decls$varrec qq_decimal$vtemp;
static byte qq_decls$dispatchtype = (byte)(i64)6;
static i64 qq_decls$hasbytecodes = (i64)1;
static struct qq_decls$lexrec qq_decls$nextlx;
static struct qq_decls$lexrec qq_decls$lx;
static i64 qq_decls$qpos;
static i64 qq_decls$pcerrorpos;
static struct qq_decls$filerec *  qq_decls$pcerrormodule;
static struct qq_decls$varrec qq_decls$varstack[70000];
static struct qq_decls$varrec *  qq_decls$sptr;
static struct qq_decls$varrec *  qq_decls$stacklimit;
static byte *  qq_decls$frameptr;
static i64 *  qq_decls$pcptr;
static i64 qq_decls$stopped;
static struct qq_decls$strec *  qq_decls$stprogram;
static struct qq_decls$strec *  qq_decls$stmodule;
static struct qq_decls$strec *  qq_decls$stsubprog;
static struct qq_decls$strec *  qq_decls$stcurrmodule;
static struct qq_decls$strec *  qq_decls$stcurrproc;
static struct qq_decls$filerec *  qq_decls$currmodule;
static i64 qq_decls$debug;
static i64 qq_decls$inproc;
static struct qq_decls$genfieldrec *  qq_decls$genfieldtable[1000];
static i64 qq_decls$ngenfields;
static i64 qq_decls$nlibfiles;
static struct qq_decls$strec *  qq_decls$libtable[50];
static byte qq_decls$libtypes[50];
static u64 qq_decls$dllinsttable[50];
static i64 qq_decls$ndllprocs;
static struct qq_decls$strec *  qq_decls$dllproctable[2000];
static byte qq_decls$dllproclibindex[2000];
static void *  qq_decls$dllprocaddr[2000];
static byte qq_decls$usebundled = (byte)(i64)1;
static u8 *  qq_decls$dispatchnames[6] = {(byte*)"-lab",(byte*)"-sw",(byte*)"-fn",(byte*)"-debug",(byte*)"-fdebug",(byte*)"-asm"};
static i64 qq_decls$nqparams;
static u8 *  qq_decls$qparamtable[32];
static u8 *  qq_decls$err_message;
static struct qq_decls$varrec qq_decls$err_var1;
static struct qq_decls$varrec qq_decls$err_var2;
static i64 *  qq_decls$err_pcptr;
static i64 *  qq_decls$stopseq;
static i64 *  qq_decls$raiseseq;
static struct qq_decls$procrec *  qq_decls$proclist;
static struct qq_decls$procrec *  qq_decls$proclistx;
static i64 qq_decls$nproclist;
static void (*qq_decls$pcl_callbackfn)(void) = 0;
static struct qq_decls$objrec *  qq_decls$chrtable[256];
static byte qq_decls$fnosys;
static byte qq_decls$fverbose;
static i16 qq_decls$baseclasstable[256];
static struct qq_decls$strec *  qq_decls$baseclassdef[256];
static i64 qq_decls$nbaseclasses;
static i64 qq_decls$lastretindex;
static struct qq_decls$filerec *  qq_decls$modules[201];
static struct qq_decls$subprogrec *  qq_decls$subprogs[30];
static i64 qq_decls$nmodules;
static i64 qq_decls$nsubprogs;
static i64 qq_decls$pclcounts[263];
static i64 qq_decls$nalllines;
static u8 *  qq_decls$qafilenames[100];
static u8 *  qq_decls$qatext[100];
static i64 qq_decls$qasize[100];
static i64 qq_decls$nqafiles;
static u8 *  qq_decls$optionnames[28] = {
    (byte*)"load",
    (byte*)"parse",
    (byte*)"names",
    (byte*)"gen",
    (byte*)"fixup",
    (byte*)"run",
    (byte*)"ast1",
    (byte*)"ast2",
    (byte*)"pcl1",
    (byte*)"pcl2",
    (byte*)"pcl3",
    (byte*)"allsp",
    (byte*)"st",
    (byte*)"stflat",
    (byte*)"types",
    (byte*)"modules",
    (byte*)"fn",
    (byte*)"asm",
    (byte*)"debug",
    (byte*)"fdebug",
    (byte*)"sw",
    (byte*)"opt",
    (byte*)"asmopt",
    (byte*)"ext",
    (byte*)"qa",
    (byte*)"qas",
    (byte*)"v",
    (byte*)"nosys"
};
static byte *  qq_decls$optionvars[28] = {
    &qq_api$runcode,
    &qq_api$runcode,
    &qq_api$runcode,
    &qq_api$runcode,
    &qq_api$runcode,
    &qq_api$runcode,
    &qq_api$fshowast1,
    &qq_api$fshowast2,
    &qq_api$fshowpcl1,
    &qq_api$fshowpcl2,
    &qq_api$fshowpcl3,
    &qq_api$fallsp,
    &qq_api$fshowst,
    &qq_api$fshowstflat,
    &qq_api$fshowtypes,
    &qq_api$fshowmodules,
    &qq_decls$dispatchtype,
    &qq_decls$dispatchtype,
    &qq_decls$dispatchtype,
    &qq_decls$dispatchtype,
    &qq_decls$dispatchtype,
    &qq_api$foptimise,
    0,
    &qq_decls$usebundled,
    &qq_api$fwriteqa,
    &qq_api$fwriteqa,
    &qq_decls$fverbose,
    &qq_decls$fnosys
};
static byte qq_decls$optionvalues[28] = {
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)3u,
    (u8)6u,
    (u8)4u,
    (u8)5u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)1u
};
static void (*qq_jhandlers_hll$jhandlertable[263])(void);
static struct qq_decls$strec *(*qq_host$procrefs)[];
static u8 *  qq_lex$lxsource;
static u8 *  qq_lex$lxstart;
static u8 *  qq_lex$lxsptr;
static i64 qq_lex$lxifcond;
static i64 qq_lex$longsuffix;
static i64 qq_lex$lxfileno;
static i64 qq_lex$nextlxlength;
static i64 qq_lex$lxlength;
static struct qq_decls$strec qq_lex$hashtable[32768];
static struct qq_decls$strec *  qq_lex$hashtablelast;
static u8 *  qq_lex$u64maxstr = (byte*)"18446744073709551615";
static byte qq_lex$namemap[256];
static i64 qq_lib$currlineno;
static i64 qq_lib$nextavindex = (i64)0;
static struct mlib$strbuffer qq_lib$exprstrvar;
static struct mlib$strbuffer *  qq_lib$exprstr = (struct mlib$strbuffer *)&qq_lib$exprstrvar;
static i64 qq_lib$nlocalunits;
static u8 *  qq_lib$errormess;
static byte qq_lib$bytemasks[8] = {(u8)1u,(u8)2u,(u8)4u,(u8)8u,(u8)16u,(u8)32u,(u8)64u,(u8)128u};
static struct qq_decls$objrec *  qq_lists$emptylist;
static i64 qq_names$sdsize;
static i64 qq_names$sdoffset;
static i64 qq_names$sdaligned;
static i64 qq_names$sdlevel;
static i64 qq_names$sdmode;
static i64 qq_names$sdnfields;
static i64 qq_names$sdmaxalign;
static byte qq_names$sdunion[10];
static i64 qq_names$sdmaxsize[10];
static i64 qq_parse$intabledata;
static u8 *  qq_parse$tabledataname = 0;
static struct qq_decls$unitrec *  qq_parse$dollarstack[10];
static i64 qq_parse$ndollar = (i64)0;
static byte qq_parse$yieldseen;
static i64 qq_parse$currdllindex;
static i64 qq_parse$nextlambdaindex;
static i64 qq_parse$listtypestack[20];
static i64 qq_parse$nlisttype;
static i64 qq_parse$listtype;
static i64 qq_print$mindev;
static i64 qq_print$moutdev;
static i64 *  qq_print$minchan;
static void *  qq_print$moutchan;
static struct qq_decls$varrec qq_print$minvar;
static struct qq_decls$varrec qq_print$moutvar;
static i32 qq_print$moutdevstack[6];
static void *  qq_print$moutchanstack[6];
static struct qq_decls$varrec qq_print$moutvarstack[6];
static byte qq_print$mgapstack[6];
static u8 *  qq_print$mfmtstrstack[6];
static u8 *  qq_print$mfmtcurrstack[6];
static i64 qq_print$noclevels;
static u8 *  qq_print$mfmtstr;
static u8 *  qq_print$mfmtcurr;
static struct msysc$fmtrec qq_print$defaultfmt = {
    (u8)0u,
    (i8)(i64)0,
    (u8)10u,
    (u8)(i64)0,
    (u8)' ',
    (u8)'f',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)'R',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)0u
};
static byte qq_print$mgapneeded;
static u8 *  qq_print$kb_start;
static u8 *  qq_print$kb_pos;
static u8 *  qq_print$kb_lastpos;
static i64 qq_print$kb_size;
static i64 qq_print$kb_linelength;
static i64 qq_print$kb_length;
static i64 qq_print$kb_lastlength;
static u8 qq_print$termchar;
static i64 qq_print$itemerror;
static void *  qq_print$testfilech;
static i64 qq_print$listdepth = (i64)0;
static i64 *  qq_pclgen$loopstack[20][4];
static i64 qq_pclgen$trylevelstack[20];
static i64 qq_pclgen$loopindex = (i64)0;
static i64 qq_pclgen$looptrylevel;
static i64 qq_pclgen$trylevel = (i64)0;
static i64 qq_pclgen$currfunction = (i64)0;
static i64 qq_pclgen$retindex;
static i64 qq_pclgen$retvaloffset;
static i64 qq_pclgen$nprocparams;
static i64 qq_pclgen$nproclocals;
static i64 *  qq_pclgen$pproclocals;
static i64 qq_pclgen$procskiplabel;
static i64 *  qq_pcllib$pclstart;
static i64 *  qq_pcllib$pclnext;
static i64 *  qq_pcllib$pclend;
static i64 *  qq_pcllib$pcllast;
static i64 qq_pcllib$pclalloc;
static i32 *  qq_pcllib$pclsrcstart;
static i32 *  qq_pcllib$pclsrcnext;
static i64 qq_pcllib$pclcurrlineno;
static i64 (*qq_pcllib$labeloffsettable)[];
static i64 qq_pcllib$labelalloc;
static i64 qq_pcllib$nextlabelno;
static i64 qq_pcllib$labelflag;
static byte qq_pcllib$pclnopnds[263];
static i64 qq_resolve$nprocs;
static i64 qq_resolve$noexpand;
static i64 qq_resolve$symbolmode;
static i64 qq_resolve$macrolevels;
static i64 qq_resolve$allowmodname;
static struct qq_decls$strec *  qq_resolve$macroparams[50];
static struct qq_decls$strec *  qq_resolve$macroparamsgen[50];
static struct qq_decls$unitrec *  qq_resolve$macroargs[50];
static i64 qq_resolve$nmacroparams;
static i64 qq_resolve$nmacroargs;
static struct qq_decls$strec *  qq_resolve$structfields[100];
static i64 qq_resolve$ntopfields;
static i64 qq_resolve$nallfields;
static struct qq_decls$objrec *  qq_strings$emptystring;
static u8 *  qq_syslibs$syslibnames[13] = {
    (byte*)"qlib.q",
    (byte*)"sysp.q",
    (byte*)"clibp.q",
    (byte*)"smlib.q",
    (byte*)"winapi.q",
    (byte*)"gxlib.q",
    (byte*)"bmlib.q",
    (byte*)"console.q",
    (byte*)"winconsts.q",
    (byte*)"wingxlib.q",
    (byte*)"winmessages.q",
    (byte*)"gxmisc.q",
    (byte*)"dates.q"
};
static u8 *  qq_syslibs$libtext[13] = {
    (byte*)"module sysp\nmodule clibp\nmodule winapi\n\nmodule gxlib\nmodule bmlib\nmodule console\nmodule winconsts\nmodule wingxlib\nmodule winmessages\nmodule gxmisc\nmodule dates\nmodule smlib\n\n\n!module minsys\n",
    
(byte*)"!Q standard library\n\n!===============================\n!module sysp\nmodule clibp\nmodule winapi\n\nmodule gxlib\nmodule bmlib\nmodule console\nmodule winconsts\nmodule wingxlib\nmodule winmessages\nmodule gxmisc\nmodule dates\nmodule smlib\n!===============================\n\n\n\nexport type rkey=struct\t!key info as it's used locally\n\tword16\tcharcode\n\tbyte\tkeycode\n\tbyte\tshift\nend\n\nexport var ncmdparams\nexport var cmdparams\nexport var stclock=0\n\nexport const tab=\"\\t\"\n\nexport var readfilesize\n\nexport var infinity=$infinity()\nexport var nan=$nan()\n\nproc start=\n\n\tncmdparams:=getcmdparam()\n\n\tcmdparams:=new(list,1..ncmdparams)\n\n\ts::=\"\"\n\tfor i:=1 to ncmdparams do\n\t\tcmdparams[i]:=getcmdparam(i)\n\t\ts+:=cmdparams[i]+\" \"\n    od\n\n\tsreadln(s)\nend\n\nexport proc reporterror(m)=\n#print \"Error:\" followed by message m. Is that it? Count as being deprecated\n\n\tprintln \"Error:\",m\nend\n\nexport func splitstring(s,sep)=\n#split up the string s into strings separated by the sep sequence\n#return a list of all the individual strings, excluding the sep seq\n\n\ta::=()\n\tns:=0\n\tif s=\"\" or sep=\"\" then return (s,) fi\n\tdo\n\t\tn:=sep inx s\n\t\tif not n.isfound then\n\t\t\ta[++ns]:=s\n\t\t\treturn a\n\t\tfi\n\t\tt:=leftstr(s,n-1)\n\t\ta[++ns]:=t\n\t\ts:=rightstr(s,-(n+sep.len-1))\n\tod\n\treturn \"\"\nend\n\nexport func joinstrings(a,sep)=\n#join the strings in list, using the given separator string\n#return new single string\n\tif a.upb=0 then return \"\" fi\n\ts:=a[1]\n\tfor i:=2 to a.upb do\n\t\ts:=s+sep+a[i]\n\tod\n\treturn s\nend\n\nexport proc abort(s)=\n#Print message, pause for keypress, then stop the interpreter with stopcode 1\n\n\tprintln \"Abort:\",s,\"Error\"\n\twaitkey()\n\tstop 1\nend\n\nexport func extractpath(fs)=\n#fs is a full filespec string\n#extract any path from it and return that; ie, strip the filename\n#otherwise return \"\"\n\tl:=fs.len\n\tfor i:=l downto 1 do\n\t\tif chr(fs.[i]) in \"\\\\/:\" then\n\t\t\treturn leftstr(fs,i)\n\t\tfi\n\tod\n\treturn \"\"\nend\n\nexport func extractfile(fs)=\n#return filename portion of path fs\n\tp:=extractpath(fs)\n\tif p=\"\" then return fs fi\n\treturn rightstr(fs,-p.len)\nend\n\nexport func extractbasefile(fs)=\n#return filename portion of path fs\n\tf:=extractfile(fs)\n\tif f=\"\" then return \"\" fi\n\te:=extractext(f)\n\tif e.len then\n\t\tf:=leftstr(f,-e.len)\n\tfi\n\tif rightstr(f)=\".\" then\n\t\tf:=leftstr(f,-1)\n\tfi\n\treturn f\nend\n\nexport func extractext(fs,period=0)=\n#extract extension part of filespec fs\n#endings of \"xxx\" (no extension) and \"xxx.\" both return \"\"\n#with period=1, then \"xxx\" returns \"\" and \"xxx.\" returns . (so can be used to\n#override default extensions)\n\n\tf:=extractfile(fs)\n\tif f=\"\" then return \"\" fi\n\te:=\"\"\n\tdo\n\t\tn:=\".\" inx f\n\t\tif n.isfound then\n\t\t\te:=rightstr(f,-n)\n\t\t\tif e=\"\" then\t\t!. ending\n\t\t\t\treturn (period.defined and period|\".\"|\"\")\n\t\t\tfi\n\n\t\t\tf:=e\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\n\treturn e\nend\n\nexport func changeext(file,newext,soft=0)=\n#normally face a change of extension to the file spec\n#use soft=1 to only change extension if no extension is present (a \".\" ending is an extension)\n\text:=extractext(file)\n\n\tp:=extractpath(file)\n\tbf:=extractbasefile(file)\n\tep:=extractext(file,1)\n\n\tif soft and ep<>\"\" then return file fi\t\t!has extension, don't change!\n\n\tif newext=\"\" then\n\t\treturn p+bf\n\telsif leftstr(newext)=\".\" then\n\t\treturn p+bf+newext\n\telse\n\t\treturn p+bf+\".\"+newext\n\tfi\nend\n\nexport func addpath(path,file)=\n#If file doesn't already have an absolute path (here, starting with \\ / or ?:)\n#then prepend 'path', which must end with \\ or /\n\tif leftstr(file) in \"/\\\\.\" or file.len>=2 and file.[2]=\":\" then\n\t\treturn file\n\tfi\n\treturn path+file\nend\n\nexport func addext(file,ext)=\n#add extension to filename, if it doesn't already have it's own extenstion\n\n\tif extractext(file,1)=\"\" then\n\t\treturn changeext(file,ext)\n\tfi\n\treturn file\nend\n\nexport func replacestr (s,a,b)=\n#if string a exists in s, then replace with b\n#return original or modified s\n\tdo\n\t\tn:=a inx s\n\t\tif not n.isfound then return s fi\n\t\ts:=leftstr(s,n-1)+b+rightstr(s,1-n-a.len)\n\tod\n\treturn \"\"\nend\n\nexport func parsecmdparams(cmd)=\n#cmd consists of:\n#blocks of text separated by whitespace or commas\n#each block is one of these formats\n# ...\t\tparam only\n# /...\t\tconsists of switches only\n# .../...\tparam followed by switches\n#return of (params,switches), where each is a list of strings\n#note that any correspondence between params and switches is lost; all switches assumed\n#to be global, but can appear anywhere\n#NOTE: cmd can also already be a list of blocks\n\nconst dash=\"-\"\n\n\tif cmd.islist then\n\t\tblocks:=cmd\n\telse\n\t\tsreadln(cmd)\n\t\tblocks::=()\n\t\tdo\n\t\t\tread a:\"s\"\n\t\t\tif a=\"\" then exit fi\n\t\t\tblocks append:=a\n\t\tod\n\tfi\n\n\tparams::=()\n\tswitches::=()\n\n\tfor x in blocks do\n\t\tn:=dash inx x\n!\t\tif n=0 then\t\t!pure param\n!\t\t\tparams append:=x\n\t\tif n=1 then\t\t!pure switches\n\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-1)),\"/\")\n\t\telse\t\t\t!param followed by switches\n\t\t\tparams append:=x\n!\t\t\tparams append:=leftstr(x,n-1)\n!\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-n)),\"/\")\n\t\tfi\n\tod\n\n\treturn (params,switches)\nend\n\nexport proc waitsec(secs)=\n#wait for given number of seconds, which can be a float. Call sleep()\n\tsleep(int(secs*1000))\nend\n\nexport func cmd_getswitches=\n#params is a list of strings, which\n#read all switches, and return a list of switch names (minus the \"/\")\n#each string can have more than one switch\n#some switches can follow a name in a string\n\n\tswitches::=()\n\tfor i:=1 to cmdparams.upb do\t\t!use 1..len in case called on <cmdparams> which has lwb 0\n\t\ts:=cmdparams[i]\n\t\tif leftstr(s) in \"-/\" then\n\t\t\tswitches append:=convlc(rightstr(s,-1))\n\t\tfi\n\tod\n\treturn switches\nend\n\nexport func cmd_getparams=\n#params is a list of strings\n#return list of actual params, not including any switches\n#switches are read separately using cmd_getswitches, but are not associated with\n#specific params. That would need to be done here (when / is detected in the middle\n#of a param, then make use readswitches. But to return that info, may be best to\n#create a parallel function)\n\n\tcmds::=()\n\n\tfor i:=1 to cmdparams.upb do\n\t\tpm:=cmdparams[i]\n!for pm in params do\n\t\tif leftstr(pm) in \"/-\" then\n\t\t\tnextloop\n\t\tfi\n!\tn:=\"/\" in pm\n!\tif n=0 then\n\t\t\tcmds append:=pm\n!\telse\n!\t\tcmds append:=leftstr(pm,n-1)\n!\tfi\n\tod\n\treturn cmds\nend\n\nexport func starttimer=\n#Start timer and remember ticks at this point\n\treturn stclock:=ticks()\nend\n\nexport func stoptimer=\n#Return number of ticks since starttimer was called, or last stoptimer\n#as the count is reset\n\n \td:=ticks()-stclock\n\tstclock:=ticks()\n\treturn d\nend\n\nexport func bnfact(n)=\n#n is limited to 9 million million million\n\n\tif n<=2 then\n\t\treturn longint(n)\n\tfi\n\n\tf:=1L\n\tg:=2L\n\tto n-1 do\n\t\tf:=f*g\n\t\tg:=g+1L\n\n\tod\n\treturn f\nend\n\nexport proc isort(a,?ll,?rr)=\n#inplace quicksort of a, which is anything that is indexable\n#ll rr are used for recursive calls\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a[i] and i<rr do ++i od\n\t\twhile pivot<a[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a[i],a[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then isort(a,ll,j) fi\n\tif i<rr then isort(a,i,rr) fi\nend\n\nexport func sort(a)=\n#quicksort a and return newly sorted list. Duplicates a then uses isort\n\tb::=a\n\tisort(b)\n\treturn b\nend\n\nexport func pcerror(m)=\n#Force an interpreter error; advantage is that source location is reported.\n\n\tprintln \"Internal error:\",m\n\ta:=b+c\n\treturn 0\nend\n\n\n\n!=========================================\nexport proc insert(&a, b, c)=\n#insert value c just before index b\n#c is always a single value; to insert a sequence c, use insertn()\n\tn:=a.upb\n\ta[n+1]:=c\n\tfor i:=n downto b do\n\t\tswap(a[i+1],a[i])\n\tod\nend\n\nexport proc isort2(a,b,?ll,?rr)=\n#Like isort but also sorts b in parallel; sort order is determined by a however\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a[i] and i<rr do ++i od\n\t\twhile pivot<a[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a[i],a[j])\n\t\t\tswap(b[i],b[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then isort2(a,b,ll,j) fi\n\tif i<rr then isort2(a,b,i,rr) fi\nend\n\nexport func left(a,n=1)=\n#return leftmost n elements of a (default left element)\n#when n is negative, all except rightmost -n\n\n\tif n>=0 then\n\t\treturn take(a,n)\n\telse\n\t\treturn take(a,a.len+n)\n\tfi\nend\n\nexport func right(a,n=1)=\n#return rightmost n elements of a (default right element)\n#when n is negative, all except leftmost -n\n\n\tif n>=0 then\n\t\treturn drop(a,a.len-n)\n\telse\n\t\treturn drop(a,-n)\n\tfi\nend\n\nexport func reverse(a)=\n#return reversed version of a\n#when 0, returns empty\n#when 1 element, returns a distinct, writeable copy\n\n\tif a.len=0 then\n\t\treturn makeempty(a)\n\tfi\n\tb::=a\n\n\tif a then\n\t\tfor i in a.bounds do\n\t\t\tb[a.upb-i+a.lwb]:=a[i]\n\t\tod\n\tfi\n\treturn b\nend\n\nexport func expandrange(a,step=1)=\n#Turn range a into a list of inclusive values\n\tx::=()\n\ti:=a.lwb\n\twhile i<=a.upb do\n\t\tx append:=i\n\t\ti+:=step\n\tod\n\treturn x\nend\n\nexport func head(a)=\n#return first element, or empty when empty\n\n\tif a.len then\n\t\treturn a[a.lwb]\n\telse\n\t\treturn makeempty(a)\n\tfi\nend\n\nexport func tail(a)=\n#return all except the first element\n#returns empty when only 0 or 1 elements\n\n\tcase a.len\n\twhen 0,1 then\n\t\treturn makeempty(a)\n\tesac\n\treturn a[2..$]\nend\n\nexport func init(a)=\n#return all except last element\n#returns empty when only 0 or 1 elements\n\tcase a.len\n\twhen 0,1 then\n\t\treturn makeempty(a)\n\tesac\n\treturn a[a.lwb..$-1]\nend\n\nexport func last(a)=\n#return last element, or empty\n\tif a.len then\n\t\treturn a[$]\n\telse\n\t\treturn makeempty(a)\n\tfi\nend\n\nexport func take(a,n)=\n#return first n elements from list/string a\n#returns () or \"\" when a is empty\n#n > 0 (n<=0 returns empty)\n\n\tif a.len=0 or n<=0 then\n\t\treturn makeempty(a)\n\tfi\n\tif n>=a.len then\n\t\treturn a\n\tfi\n\treturn a[a.lwb..a.lwb+n-1]\nend\n\nexport func drop(a,n)=\n#skips first n elements of a then returns the rest\n#returns () when empty, or skipping the whole list\n#n >= 0\n\n\tif a.len=0 or n>=a.len then\n\t\treturn makeempty(a)\n\tfi\n\tif n<=0 then\n\t\treturn a\n\tfi\n\treturn a[a.lwb+n..$]\nend\n\nexport func zip(a,b)=\n#return a list consisting of alternate elements from a and b\n#uses smaller of the two dimensions\n\n\tn:=min(a.len,b.len)\n\tc::=()\n\n!\tj:=a.lwb; k:=b.lwb\n\t(j, k) := (a.lwb, b.lwb)\n\n\tto n do\n\t\tc append:=a[j++]\n\t\tc append:=b[k++]\n\tod\n\treturn c\nend\n\nexport func repeatlist(a,n)=\n#duplicate a n times, and return the result\n#this ought to be built-in as a*n, but that's only implemented for a.len=1\n\n\tb:=makeempty(a)\n\tto n do\n\t\tb concat:=a\n\tod\n\treturn b\nend\n\n!export func minimum(a)=\n!#return minimum value of elements in a\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx min:=y\n!\tod\n!\treturn x\n!end\n!\n!export func maximum(a)=\n!#return maximum value of elements in a\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx max:=y\n!\tod\n!\treturn x\n!end\n!\n!export func sumlist(a)=\n!# apply \"+\" between all elements of a, and return result\n!# all elements must be compatble (all strings or all numbers for example)\n!# returns void then a is empty, or head(a) when just one element\n!\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx +:=y\n!\tod\n!\treturn x\n!end\n\nexport proc delete(&a,?b)=\n#delete element b\n\tn:=a.upb\n\tif b.isvoid then b:=n fi\n\n\tif n=b=1 then\n\t\ta::=()\n\t\treturn\n\tfi\n\n\tif b>n then return fi\n\tif b<a.lwb then return fi\n\tfor i:=b to n-1 do\n\t\tswap(a[i],a[i+1])\t\t\t!swap is faster for complex elements\n\tod\n!a[n]:=0\t\t!don't leave any heap data beyond new end of list\n\n\tresize(a,n-1)\nend\n\nexport proc resize(&a,n)=\n#hange the upper bound of a to n\n\n\tif n<a.lwb then\n\t\ta:=makeempty(a)\n\t\treturn\n\tfi\n\n\ta::=a[a.lwb..n]\t\t\t!duplication forces original to be freed\nend\n \nexport func makebits(data,t=bit)=\n#turn data (list, array, or bit array of different type) into a bit array\n\n\ta:=new(bits,t,data.bounds)\n\tfor i:=data.lwb to data.upb do\n\t\ta[i]:=data[i]\n\tod\n\treturn a\nend\n\nexport func makearray(data,t=int64)=\n#turn data (list, array of different type, or bit array) into an array of \n#given element type\n\n\ta:=new(array,t,data.bounds)\n\tfor i:=data.lwb to data.upb do\n\t\ta[i]:=data[i]\n\tod\n\treturn a\nend\n\nexport func tolist(a)=\n#convert a, a string, array or bits, to a list, and return that list\n\n\tcase a.basetype\n\twhen array,string,bits then\n\t\tb:=new(list,a.bounds)\n\t\tfor i,x in a do\n\t\t\tb[i]:=x\n\t\tod\n\t\treturn b\n!\twhen string then\n!\t\tb:=new(list,a.len)\n!\t\ti:=1\n!\t\tfor i,x in a do\n!\t\t\tb[i++]:=x\n!\t\tod\n!\t\treturn b\n\n\twhen list then\n\t\treturn a\n\telse\n\t\tpcerror(\"tolist:\"+tostr(a.type))\n\tesac\n\treturn 0\nend\n\nexport func toarray(a,?t)=\n#convert a, a list, string, array or bits, to an array, and return that array\n#can be used to turn one array type into another\n\tcase a.basetype\n\twhen list then\n\t\tif t.isvoid then\n\t\t\tif a then\n\t\t\t\tt:=a[a.lwb].type\n\t\t\telse\n\t\t\t\tt:=int32\n\t\t\tfi\n\t\tfi\n\n\twhen bits then\n\t\tif t.isvoid then\n\t\t\tt:=byte\n\t\tfi\n\n\twhen string then\n\t\tif t.isvoid then t:=byte fi\n\t\tb:=new(array,t,a.len)\n\t\tforeach i,x in a do\n\t\t\tb[i]:=x\n\t\tod\n\t\treturn b\n\twhen array then\n\t\tif t.isvoid then\n\t\t\treturn a\n\t\tfi\n\t\tu:=e.elemtype\n\t\tif t=u then return a fi\n\telse\n\t\tpcerror(\"toarray:\"+tostr(a.type))\n\tesac\n\tb:=new(array,t,a.bounds)\n\n\tfor i,x in a do\n\t\tb[i]:=x\n\tod\n\treturn b\nend\n\nexport func tobits(a,t=bit)=\n#convert a, a list, array or other bit array, into a bit array\n\n\tcase a.basetype\n\twhen list,array then\n\n\twhen bits then\n\t\tif a.elemtype=t then\n\t\t\treturn a\n\t\tfi\n\n\telse\n\t\tpcerror(\"tobits:\"+tostr(a.type))\n\tesac\n\tb:=new(bits,t,a.bounds)\n\tfor i,x in a do\n\t\tb[i]:=x\n\tod\n\treturn b\nend\n\nexport func listtostring(a)=\n#a should be a list or array\n#interpreter elements as characters and form a single string\n\ts:=\"\"\n\tfor x in a do\n\t\ts+:=chr(x)\n\tod\n\treturn s\nend\n\nexport func qversion=\n\treturn \"4.0\"\nend\n\nexport proc issort(a,?ll,?rr)=\n#Version of isort that works with dot-indexing\n\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a.[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a.[i] and i<rr do ++i od\n\t\twhile pivot<a.[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a.[i],a.[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then issort(a,ll,j) fi\n\tif i<rr then issort(a,i,rr) fi\nend\n\nexport func ssort(a)=\n#Version of sort() with dot-indexing, eg. strings, or int bits\n\n\tb::=a\n\tissort(b)\n\treturn b\nend\n\nexport func maketable(rows, cols, initval=0)=\n#Create a table: a rectangular list, set to either 0 or to initval\n#Each rows/cols is a range, or length\n\n\trow:=new(list,cols,initval)\n\n\ttable::=new(list,rows)\n\tif rows.isint then rows:=1..rows fi\n\n\tfor i in rows do\n\t\ttable[i]::=row\n\tod\n\n\treturn table\nend\n\nexport func mapv(op,a)=\n#Apply operator or suitable unary func to all elements of vector a,\n#and return new list \n\tb::=makeempty(a)\n\tfor i,x in a do\n\t\t\tb[i]:=mapss(op,x)\n\tod\n\treturn b\nend\n\nexport func mapvv(op,a,b)=\n#Apply op or func between corresponding elements of vectors a and b\n\tc::=makeempty(a)\n\tfor i,x in a do\n\t\tc[i]:=mapss(op,x,b[i])\n\tod\n\treturn c\nend\n\nexport func mapvs(op,a,bs)=\n#Apply op or func between elements of vector a and single value bs\n\tc::=makeempty(a)\n\tfor i,x in a do\n\t\tc[i]:=mapss(op,x,bs)\n\tod\n\treturn c\nend\n\nexport func mapsv(op,as,b)=\n#Apply op or func between elements of single value as and vector b\n!\tc::=makeempty(b)\n\tc::=()\n\tfor i,x in b do\n\t\tc[i]:=mapss(op,as,x)\n\tod\n\treturn c\nend\n\nexport func openfile(name,option=\"rb\")=\n#Open a file for reading. Uses C's fopen and default option is for binary mode\n#Return a valid file handle, which is an int64 value, or 0 when not found\n\tif not name.isstring or name=\"\" then\n\t\treturn 0\n\tfi\n\treturn fopen(name,option)\nend\n\nexport func createfile(name,options=\"wb\")=\n#Create a new file and return its handle, or 0 if there was an error\n\tif not name.isstring or name=\"\" then return 0 fi\n\treturn fopen(name,options)\nend\n\nexport func closefile(f)=\n#close the file associated with handle f\n\treturn fclose(f)=0\nend\n\nexport func checkfile(name)=\n#return 1 if file name exists, otherwise 0\n\tfile:=fopen(name,\"rb\")\n\tif file=0 then return 0 fi\n\tfclose(file)\n\treturn 1\nend\n\nexport func eof(f)=\n#return 1 if at eof on currently open file handle f\n\tc:=fgetc(f)\n\tif c=-1 then return 1 fi\n\n\tungetc(c,f)\n\treturn 0\nend\n\nexport func getfilesize(f)=\n#return size of bytes of currently open file f\n\tp:=ftell(f)\t\t\t!p=current position\n\tfseek(f,0,2)\t\t!get eof position\n\tsize:=ftell(f)\t\t!size in bytes\n\tfseek(f,p,0)\t\t!restore file position\n\treturn size\nend\n\nexport func setfilepos(f,offset)=\n#set position in file f to given byte offset\n\treturn fseek(f,offset,0)\nend\n\nexport func getfilepos(f)=\n#return current file position\n\treturn ftell(f)\nend\n\nexport func readrandom(f,mem,offset,size)=\n#read size bytes from file f, to memory at mem, from given offset\n#returns number of bytes read\n#mem needs to be a pointer\n#new file offset will be offset+size (or offset+byte read if smaller)\n\tfseek(f,offset,0)\n\treturn fread(mem,1,size,f)\nend\n\nexport func writerandom(f,mem,offset,size)=\n#write size bytes from memory at mem, to current file f from given offset\n#returns bytes written\n\tfseek(f,offset,0)\n\treturn fwrite(mem,1,size,f)\nend\n\nexport func readbytes(f,mem,size)=\n#read size bytes from current position in file f to mem\n\treturn fread(mem,1,size,f)\nend\n\nexport func writebytes(f,mem,size)=\n#write size bytes from mem to current position in f\n\treturn fwrite(mem,1,size,f)\nend\n\nexport func inbyte(file)=\t\t!INBYTE\n\treturn fgetc(file)\nend\n\nexport func inword(file)=\t\t!INWORD\n\tbb:=fgetc(file)\n\treturn fgetc(file)<<8+bb\nend\n\nexport func inlong(file)=\t\t!INLONG\n\tww:=inword(file)\n\treturn inword(file)<<16+ww\nend\n\nexport proc outbyte(file,x)=\t\t!OUTBYTE\n!writerandom(file,&x,getfilepos(file),1)\n\tfputc(x,file)\nend\n\nexport proc outword(file,x)=\t\t!OUTWORD\n\toutbyte(file,x iand 255)\n\toutbyte(file,x.[15..8])\nend\n\nexport proc outlong(file,x)=\t\t!OUTLONG\n\toutword(file,x iand 65535)\n\toutword(file,x>>16)\nend\n\nexport func instring(file)=\t\t!INSTRING\n\ts::=\"\"\n\tdo\n\t\tc:=inbyte(file)\n\t\tif c=0 then return s fi\n\t\ts+:=c\n\tod\n\treturn s\nend\n\nexport func appendfile(a,b)=\n#append line-based text file a to file b\n\nf:=openfile(a)\nif f=0 then return 0 fi\n\nh:=openfile(b,\"ab\")\nif h=0 then return 0 fi\n\nwhile not eof(f) do\n\treadln @f,x:\"l\"\n\tprintln @h,x\nod\n\nclosefile(f)\nclosefile(h)\nreturn 1\nend\n\nexport func readblockfile(filename,doetx=0)=\n#read text file into a memory block\n#block is allocated here\n#return byte pointer to start of block, or nil\n#doetx=1 to add etx byte to end\n\nf:=openfile(filename)\nif f=0 then return nil fi\n\nn:=getfilesize(f)\nreadfilesize:=n\n\ns:=malloc(n+doetx)\nif s=0 then abort(\"Readfile/Malloc fails\") fi\nsptr:=makeref(s,byte)\n\n!readrandom(f,&s,0,n)\nreadrandom(f,s,0,n)\n\nif doetx then\n\t(sptr+n)^:=26\nfi\n\nclosefile(f)\nreturn sptr\nend\n\nexport func readstrfile(filename,doetx=0)=\n#read text file into a single string\n#return string, or 0 if there was an error\n\nf:=openfile(filename)\nif f=0 then return 0 fi\n\nn:=getfilesize(f)\nreadfilesize:=n\n\nptr:=malloc(n+1+doetx)\nif ptr=0 then abort(\"Readfile/Malloc fails\") fi\n\nreadrandom(f,ptr,0,n)\nif doetx then\n\t(makeref(ptr,byte)+n)^:=26\nfi\n\nclosefile(f)\n\ns::=makestr(ptr,n+doetx)\n\nfree(ptr)\nreturn s\nend\n\nexport func writestrfile(filename,s)=\n#read text file from a single string\n#return status\n\nf:=createfile(filename)\nif f=0 then return 0 fi\n\nwriterandom(f,makeref(s,byte),0,s.len)\n\nreturn closefile(f)\nend\n\nexport func readbinfile(filename)=\n#read binary file into byte array\n#return () (empty list not array) on error\n\nf:=openfile(filename)\nif f=0 then return 0 fi\n\nn:=getfilesize(f)\nreadfilesize:=n\n\na:=new(array,byte,n)\nreadrandom(f,&a,0,n)\n\nclosefile(f)\nreturn a\nend\n\nexport func writebinfile(filename,a)=\n#write binary file from byte array a\n#return status 1/0\n\nf:=createfile(filename)\nif f=0 then return 0 fi\n\nwriterandom(f,(&a),0,a.len)\n\nclosefile(f)\nreturn 1\nend\n\nexport func writeblockfile(filename,p,length)=\n#return status 1/0\n\nf:=createfile(filename)\nif f=0 then return 0 fi\n\nif not writerandom(f,p,0,length) then return 0 fi\n\nclosefile(f)\nreturn 1\nend\n\nexport func erasefile(filename)=\n#delete given file, return status (check msdn)\nreturn remove(filename)\nend\n\nexport func renamefile(oldfilename,newfilename)=\n#rename file, return status (check msnd)\nreturn rename(oldfilename,newfilename)\nend\n\nexport func readtextfile(file)=\n#read text file into a list of strings; one per line\n#return list, or 0 on error\nf:=openfile(file)\nif not f then\n\treturn 0 \nfi\n\nreadfilesize:=getfilesize(f)\na::=()\n\nwhile not eof(f) do\n\ta append:= sreadln(f)\nod\nclosefile(f)\nreturn a\nend\n\nexport func writetextfile(file,a)=\n#write list of strings <a> as a text file <file>\nf:=createfile(file)\nif not f then return 0 fi\n\nfor i:=a.lwb to a.upb do\n\tprintln @f,a[i]\nod\nclosefile(f)\nreturn 1\nend\n\nexport func readbinaryfile(filename,t)=\n#read binary file consisting of an array of type t values, into array of t\n#return () (empty list not array) on error\n\n\tf:=openfile(filename)\n\tif f=0 then return () fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\telems:=n%t.bytes\n\n\ta:=new(array,t,elems)\n\treadrandom(f,&a,0,n)\n\n\tclosefile(f)\n\treturn a\nend\n\nexport func writebinaryfile(filename,data)=\n#write binary file from array of a fixed type to a file\n#return 1/0 status\n\treturn writeblockfile(filename,&data,data.bytes)\nend\n\nexport func confirm(m,caption=\"Confirm\",default=1)=\n#Pop-up box to ask for confirmationdefault=1/2/3 for yes/no/cancel button\n#Return 1 or 0\n\n\tflags:=0x20000+0x20\t!foreground window/question mark icon\n\tflags ior:=3\t\t!yes/no/cancel\n\n\tflags ior:=(default|0,0x100,0x200|0)\n\n\tstatus:=messagebox(nil,m,caption,flags)\n\treturn status=6\nend\n\nexport func messagebox(a=nil,mess,caption=\"Caption\",d=0)=\n#Standard Windows' Messagebox\n\treturn messageboxa(nil,mess,caption,d)\nend\n\nexport func dirlist(s,t=1)=\n#s is a export filename (eg. \"*.dwg\") with possible drive/path; scan\n#directory for all matching files and return as a list of names\n#also returns total no. of files so far\n#t= +1\tInclude normal files, no sub-directory names\n#t= +2  Include directories\n#t= +3  Include all files including directories\n#t= +4  Convert to lower case\n#t=  0  Defaults to +1\n\n!CPL \"DIRLIST/WINLIB\"\n\n\tif t.isvoid then t:=1 fi\t\t\t!files only\n\n\tnfiles:=0\n\tdata::=()\n\tfile:=new(ws_finddata)\n\n\tif (hfind:=findfirstfile(s,&file))<>-1 then\t!at least one file\n\t\trepeat\n\t\t\tif (file.fileattributes iand 16) then\t\t!this is a directory\n\t\t\t\tif (t iand 2)=0 then goto skip fi\t\t!no directories\n\t\t\telse\t\t\t\t\t\t!this is a file\n\t\t\t\tif (t iand 1)=0 then goto skip fi\n\t\t\tfi\n\t\t\t++nfiles\n\t\t\tif (t iand 4) then\t\t\t\t!to lower case\n\t\t\t\tdata[nfiles]:=convlc(file.filename)\n\t\t\telse\n\t\t\t\tdata[nfiles]::=file.filename\n\t\t\tfi\n\tskip:\n\t\tuntil not findnextfile(hfind,&file)\n\t\tfindclose(hfind)\n\tfi\n\treturn data\nend\n\nexport func setcurrdir(newdir)=\n#Set current directory; return Windows' status code\n\treturn setcurrentdirectory(newdir)\nend\n\nexport func getcurrdir=\n#Return current directory name, always ends with \\ or /\n\ta:=new(array,byte,256)\n\tn:=getcurrentdirectory(a.len,&a[1])\n\n\tif n then\n\t\tdir::=makestr(&a[1],n)\n\telse\n\t\tdir:=\"\"\n\tfi\n\n\tif not (rightstr(dir) in \"\\\\/\") then dir +:= \"\\\\\" fi\n\treturn dir\nend\n\nexport func createdir(name)=\n#Create a new directory\n\treturn createdirectory(name,0)\nend\n\nexport func direxists(path)=\n#Return 1 if directory path exists\n\tconst file_attribute_directory=16\n\tconst invalid_file_attributes=-1\n\n\tattrib := getfileattributesa(path)\n\n\treturn attrib<>invalid_file_attributes and (attrib iand file_attribute_directory)\nend\n\nexport proc beep1=\n#Standard beep\n\tmessagebeep(0)\nend\n\nexport proc mem(mess)=\n\tstatic var startmem\n\tif startmem.isvoid then\n\t\tstartmem:=$smallmemtotal()\n\tfi\n\tprintln mess,,\":\",$smallmemtotal()-startmem\nend\n\nexport func reduce(op, a)=\n\tx:=head(a)\n\tfor y in tail(a) do\n\t\tx:=mapss(op,x,y)\n\tod\n\tx\nend\n",
    (byte*)"importdll msvcrt=\n\tfunc \"malloc\"        (int64)ref byte\n\tfunc realloc(int64, int32)int64\n\tproc free        (int64)\n\tproc memset      (ref byte, int32, int32)\n\tproc memcpy      (ref byte, ref byte, int32)\n\tfunc memcmp      (ref byte, ref byte, int32)int32\n!\tfunc clock       :int32\n\tfunc ftell       (int64)int32\n\tfunc fseek       (int64, int32, int32)int32\n\tfunc fread       (ref byte, int32, int32, int64)int32\n\tfunc fwrite      (ref byte, int32, int32, int64)int32\n\tfunc getc   (int64)int32\n\tfunc ungetc (int32, int64)int32\n\tfunc fopen       (stringz, stringz)int64\n\tfunc fclose      (int64)int32\n\tfunc fgets       (ref byte, int32, int64)ref byte\n\tfunc remove      (stringz)int32\n\tfunc rename      (stringz, stringz)int32\n\tfunc getchar     :int32\n\tproc putchar     (int32)\n\tproc setbuf      (int64, int64)\n\n\tfunc rand        :int32\n\tproc srand       (int32)\n\n\tfunc puts        (stringz)int32\n\tfunc printf      (stringz, ...)int32\n\n\tfunc sprintf     (stringz, stringz, ...)int32\n\n\tfunc sscanf      (stringz, stringz, ...)int32\n\tfunc isalpha     (int32)int32\n\tfunc tolower     (int32)int32\n\tfunc strlen      (ref byte)int32\n\tfunc atoi        (stringz)int32\n\n!   clang func system      (stringz)int32\n\n\tfunc fgetc  (int64)int32\n\tfunc fputc  (int32,  int64)int32\n\tfunc fprintf     (int64, stringz, ...)int32\n\tfunc fputs       (stringz,  int64)int32\n\tfunc feof        (int64)int32\n!   clang func getch       :int32\n\tfunc _getch      :int32\n\nend\n\nglobal const c_eof     = -1\nglobal const seek_set  = 0\nglobal const seek_curr = 1\nglobal const seek_end  = 2\n\n",
    
(byte*)"!import sys\n!\n!import gxmisc\n!import gxlib\n\nexport var popuplist::=()\nexport var focuslist::=()\nexport var npopups=0\nexport var message\nexport var messw\nexport var wpopup=nil\n\nrecord blockrec=\n\tvar posx, posy\t\t\t\t!pixel position of top left of block: relative to other\n\t\t\t\t\t\t\t\t!blocks, later within client area of containing window\n\tvar dimx,dimy\t\t\t\t!'client' area of block, including margins, cells and gaps\n\tvar celldimx, celldimy\t\t!size of each cell, in pixels\n\tvar cellsx, cellsy\t\t\t!number of identically-svert hoz and vertical controls\n\tvar gapx, gapy\t\t\t\t!gap between cells, in pixels\n\tvar marginx, marginy\t\t!margins around all cells\n\tvar labelwidth\t\t\t\t!for edit boxes, how many pixels on left are for label\n\tvar cellposx,cellposy\t\t!position of top left cell within block\n\tvar pitchx,pitchy\t\t\t!1st cell is at for edit boxes, how many pixels on left are for label\n\tvar blockstyle\t\t\t\t!style record for blocks\n\tvar name\t\t\t\t\t!name for debugging\n\tvar dir\t\t\t\t\t\t!'H' or 'V' for stepping direction\n\nend\n\nvar blocklist::=()\nvar nblocks=0\nvar\tcurrblock =nil\t\t\t\t!current blockrec\nvar\tcurrgroup =nil\t\t\t\t!rwindow corresponding to currblock\nvar\tcurrpopup =nil\t\t\t\t!rwindow for menu to contain current set of blocks\nvar cellx, celly\t\t\t\t!current cell within current block\nvar slposx,slposy,sldir\t\t\t!set by smcreate in case sl-functions are used\n\nproc start=\n!CPL \"-----------SMLIB\"\n!TOGGLETEST()\nend\n\nproc toggletest=\n\n!CPL \"SMLIB TOGGLETEST\"\ngxloadfont(1,\"Arial\",\"I\",20)\ngxloadfont(2,\"COURIER\",\"B\",20)\n\na:=smdefblock(\"X\"*26,6,\"CNR\")\n\na:=smdefblock(\"X\"*26,5,\"\",labeldim:\"*\"*12)\nb:=smdefblock(\"X\"*26,5,\"\",labeldim:\"*\"*12)\nc:=smdefblock(\"X\"*26,5,\"\",labeldim:\"*\"*12)\nd:=smdefblock(\"X\"*10,2)\n\nsmorder((a,b,c,d))\n!smorder((b,c),\"r\")\nsmcreate(\"TOGGLES\",smmenusize())\n\nwa:=smblock(a)\nd1:=\"One\"\nd2:=\"Two\"\nd3:=\"Three\"\nd4:=\"Four\"\nd5:=\"five\"\nwd::=()\n\nwd[1]:=smeditbox(\"Edit d1:\",^d1,211,enable:1)\nwd[2]:=smeditbox(\"Edit d2:\",^d2,212,enable:1)\n!wd[3]:=smeditbox(\"Edit d3:\",^d3,213,enable:1)\n!wd[4]:=smeditbox(\"Edit d4:\",^d4,214,enable:1)\n!wd[5]:=smeditbox(\"Edit d5:\",^d5,215,enable:1)\n!\n\n!wb:=smblock(b)\n!s1:=\"Six\"\n!s2:=\"Seven\"\n!s3:=\"Eight\"\n!s4:=\"Nine\"\n!s5:=\"Ten\"\n!ws:=()\n!\n!ws[1]:=smeditbox(\"Edit s1:\",^s1,221,enable:1)\n!ws[2]:=smeditbox(\"Edit s2:\",^s2,222,enable:1)\n!ws[3]:=smeditbox(\"Edit s3:\",^s3,223,enable:1)\n!ws[4]:=smeditbox(\"Edit s4:\",^s4,224,enable:1)\n!ws[5]:=smeditbox(\"Edit s5:\",^s5,225,enable:1)\n!\n!wc:=smblock(c)\n!t1:=\"XSix\"\n!t2:=\"XSeven\"\n!t3:=\"XEight\"\n!t4:=\"XNine\"\n!t5:=\"XTen\"\n!wt:=()\n!\n!wt[1]:=smeditbox(\"Edit t1:\",^t1,231,enable:1)\n!wt[2]:=smeditbox(\"Edit t2:\",^t2,232,enable:1)\n!wt[3]:=smeditbox(\"Edit t3:\",^t3,233,enable:1)\n!wt[4]:=smeditbox(\"Edit t4:\",^t4,234,enable:1)\n!wt[5]:=smeditbox(\"Edit t5:\",^t5,235,enable:1)\n\n!wbutton:=smcmd(\"Button\",210,0)\n\nsmblock(d)\nwok:=smok(enable:0)\nwcancel:=smcancel()\n\nsetfocus(wd[1])\n\n!gxenable(wtoggle,0)\n!gxenable(wselect1,0)\n!gxenable(wok,0)\n!gxenable(wbutton,0)\n\ndo\n!    gxfocus(wlb)\n\n\tm:=gxaskmess(1)\nCPL \"MESSAGELOOP:\",MESSAGENAMES[CURRMESS.MESSAGE],M,currmess.a,=TOGGLE,=SELECT,=abc\n\n\tcase m\n\twhen mm_pick then\nCPL \"PICK\"\n\t\texit\n\twhen mm_ok then\n\t\texit\n\twhen mm_cancel then\n\t\texit\n!\twhen mm_lbchange then\t\t\t\t!dummy message, allows windex to be updated\n!CPL \"LBCHANGE\"\n\twhen mm_tabkey then\nCPL \"TABKEY\"\n!\t\tgxenable(wtoggle,1)\n\tesac\nod\n\n!$SETDEBUG(1)\n\nsmoff()\n\n\n\nend\n\nproc main=\nCPL \"SMLIB MAIN\"\n!proc start=\n\ntoggletest()\nstop\n\nsminit()\n\nA:=smdefblock(\n\tdim:\"X\"*28,\n\tcells:(1,10),\n\tgap:0,\n\tmargin:10)\nB:=smdefblock(\n\tdim:\"X\"*10,\n\tcells:(1,3)\n)\n\nsmorder((a,b))\nwpopup:=smcreate(\"TEST MENU\",smmenusize())\n!smcreate(\"TEST MENU\",(500,100))\n\nwa:=smblock(a)\n!xx:=0\n!for i to 10 do\n!\tsmtoggle(\"BART\"+tostr(i),^xx)\n!od\nxx:=()\n!for i to 1000 do\nfor i to 130 do\n\txx append:=tostr(i)\nod\n\n!xx:=(\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\")\nwlb:=smlistbox(^xx)\nwlb.style.lbchange:=1\nWLB.NAME:=\"FREDDY\"\n\nSMBLOCK(B)\nSMOK()\nSMCMD(\"HELLO\",201)\n\nNN:=0\ndo\n! \tgxcaption(windex,tostr(wlb.attrs.currpos)+\"/\"+tostr(info.getbounds().len))\n\n    gxfocus(wlb)\n\n\tm:=gxaskmess(1)\n!!CPL =M\nCPL \"MESSAGELOOP:\",MESSAGENAMES[CURRMESS.MESSAGE],M,currmess.a\n\n\tcase m\n\twhen mm_pick then\nCPL \"PICK\"\n\t\tretval:=currmess.a\n\t\texit\n\twhen mm_ok then\n\t\tretval:=gxcurrpos(wlb)\n\t\texit\n\twhen mm_cancel then\n!\t\tsmoff(wpopup)\n\t\tretval:=0\n\t\texit\n\twhen mm_lbchange then\t\t\t\t!dummy message, allows windex to be updated\nCPL \"LBCHANGE\"\n\twhen mm_tabkey then\nCPL \"TABKEY\"\n\tesac\nod\n\n!$SETDEBUG(1)\n\nsmoff()\n\n!EVENTLOOP()\nend\n\n!proc showblockinfo(block)=\n!println \"Block:      \",(block.name.isdef|block.name|\"\")\n!println \"Pos:        \",block.posx,block.posy\n!println \"Dim:        \",block.dimx,block.dimy\n!println \"CellDim:    \",block.celldimx,block.celldimy\n!println \"Gap:        \",block.gapx,block.gapy\n!println \"Cells:      \",block.cellsx,block.cellsy\n!println \"Gaps:       \",block.gapx,block.gapy\n!println \"Margins:    \",block.marginx,block.marginy\n!println \"Labelwidth: \",block.labelwidth\n!println \"Cellpos:    \",block.cellposx,block.cellposy\n!println \"Pitch:      \",block.pitchx,block.pitchy\n!println \"Dir:        \",block.dir\n!println\n!end\n\nexport proc sminit=\nblocklist::=()\nnblocks:=0\n\nend\n\nexport func smdefblock(?dim,cells=1,style=\"\",gap=0,labeldim=\"\",margin=0,dir='V')=\n!define a matrix of cells, all the same size, to be used as controls\n!dim\tis a the size of each cell, as pixel dims, or as a sample string\n!cells\tis a the hoz and vert cell count. Or it can be an int for vert column only\n!gap\tis the inter-cell gap, specified in pixels. Default is to use chx or chy.\n!\t\tgap can be (x,y), or just n for the same gap in hoz and vert\n!style\tCurrently, a string containing various styles and options. Will be\n!\tcompatible with old uses of these functions. Or can be replaced with a dict\n!label\tWhen specified, is a sample string givibg the length of the label on the left\n!\t\tof edit boxes; can also be a pixel width\n!return handle to block\n!also add block to export blocklist\n\nblock:=new(blockrec,0)\nblock.dir:=dir\n!block.dir:='H'\n\nif dim.isstring then\n\tblock.celldimx:=gxtextwidth(labelfont,dim)+smx*2\n\tblock.celldimy:=chy+smy*2\nelse\n\t(block.celldimx,block.celldimy):=dim\nfi\n\nif cells.isint then\n\tblock.cellsx:=1\n\tblock.cellsy:=cells\nelse\n\t(block.cellsx,block.cellsy):=cells\nfi\n\nif gap.isint then\n\tblock.gapx:=gap\n\tblock.gapy:=gap\nelse\n\t(block.gapx,block.gapy):=gap\nfi\n\nif margin.isint then\n\tblock.marginx:=margin\n\tblock.marginy:=margin\nelse\n\t(block.marginx,block.marginy):=margin\nfi\n\nif labeldim then\n\tif labeldim.isstring then\n\t\tblock.labelwidth:=gxtextwidth(labelfont,labeldim)+smx*2\n\telse\n\t\tblock.labelwidth:=labeldim\n\tfi\n\tblock.celldimx+:=block.labelwidth\nfi\n\nblock.blockstyle:=readstylestr(style)\n\n!CPL \"BLOCKSTYLE\",STYLE,BLOCK.BLOCKSTYLE\n\n!now work out overall size of the block, and the pitch between cells\n!this needs to take account of the frame size of each cell, which depends on\n!its border style\n!block position is done at a higher level using smorder\n\nbdx:=bdy:=1\t\t\t\t!use border widths of 0 for now (and assume same all round)\n\nblock.pitchx:=block.celldimx+bdx*2+block.gapx\t\t!hoz pitch\nblock.pitchy:=block.celldimy+bdy*2+block.gapy\t\t!vert\n\n!CPL \"PITCHY\",BLOCK.PITCHY,=BDY,=BLOCK.GAPY\n!CPL \"MARGINY\",BLOCK.MARGINY\n\nblock.cellposx:=block.marginx+bdx\t\t\t\t\t!position of client area of 1st cell\nblock.cellposy:=block.marginy+bdy\n\nblock.dimx:=block.pitchx*block.cellsx-block.gapx+block.marginx*2\nblock.dimy:=block.pitchy*block.cellsy-block.gapy+block.marginy*2\n\nblocklist[++nblocks]:=block\n\nreturn block\nend\n\nexport func smmenusize(margin=chy)=\n!work out overall bounding box for all blocks, and relocate blocks (or set their\n!pos values) so that each is positioned within to the bounding box rectangle\n!return (dimx,dimy)\n\n!get bounding box in (x1,y1), (x2,y2)\nfor i,block in blocklist do\n\tif i=1 then\t\t\t\t!first block\n\t\tx1:=block.posx\n\t\ty1:=block.posy\n\t\tx2:=x1+block.dimx-1\n\t\ty2:=y1+block.dimy-1\n\telse\n\t\tx1 min:=block.posx\n\t\ty1 min:=block.posy\n\t\tx2 max:=block.posx+block.dimx-1\n\t\ty2 max:=block.posy+block.dimy-1\n\tfi\nod\n\n!now, need to relocate each block so they stay at the same position relative to\n!each other, but are positioned within the client area of an owner window\n!this effectively relocates (x1,y1) to (0,0), so the offset to be applied to\n!each block is -(x1,y1), plus (margin,margin)\n\nfor block in blocklist do\n\tblock.posx+:=margin-x1\n\tblock.posy+:=margin-y1\nod\n\n!return (x1-margin,y1-margin,x2-y1+margin*2+1,y2-y1+margin*2+1)\nreturn (x2-x1+margin*2+1,y2-y1+margin*2+1)\nend\n\nexport proc smorder(blocks,dir='D')=\n!take a blocks, and arrange all in a line, relative to the first\n!dir is one of \"U\", \"D\", \"L\", \"R\" (or can be char codes or in lower case)\n!some block elements can be an integer specifing a gap between the blocks.\n!the gap is specified in pixels. The default gap is chx for hoz and chy for vertical\n!(***I THINK that the gap override is only between two blocks, so needs the reset to\n!default after. That mean also that the first list item must be a block***)\n\nif dir.isstring then\n\tdir:=asc(convuc(dir))\t\t\t!\"r\",\"R\" or 'R' possible, but not 'r'\nfi\n\nbdx:=bdy:=1\t\t\t\t\t\t!border widths for the blocks\n\ndx:=chx+bdx\ndy:=chy+bdy\nfirstblock:=1\n\nfor block in blocks do\n\tif block.isint then\t\t\t!is a gap\n\t\tdx:=block+bdx*2\n\t\tdy:=block+bdy*2\n\t\tnextloop\n\tfi\n\tif firstblock then\n\t\tlastblock:=block\n\t\tfirstblock:=0\n\t\tnextloop\n\tfi\n\tcase dir\n\twhen 'D' then\t\t\t!add below\n\t\tblock.posx:=lastblock.posx\n\t\tblock.posy:=lastblock.posy+lastblock.dimy+dy\n\twhen 'R' then\n\t\tblock.posx:=lastblock.posx+lastblock.dimx+dx\n\t\tblock.posy:=lastblock.posy\n\twhen 'U' then\t\t\t!add above\n\t\tblock.posx:=lastblock.posx\n\t\tblock.posy:=lastblock.posy-block.dimy-dy\n\twhen 'L' then\n\t\tblock.posx:=lastblock.posx-block.dimx-dx\n\t\tblock.posy:=lastblock.posy\n\tesac\n\tlastblock:=block\nod\nend\n\nproc showtestmenu(dim)=\n\nwapplic:=gxcreatewindow(dim:dim,caption:\"test\")\n\nfor block in blocklist do\n\tgxbutton(pos:(block.posx,block.posy),dim:(block.dimx,block.dimy),caption:block.name,\n\towner:wapplic,style:[ss_border:bs_simplew])\nod\n\neventloop()\n\nend\n\nexport func smcreate(caption=\"\",?dim,?pos)=\n!create a pop-up menu window\n!dim ix (x,y) client area size in pixels\n!?pos is optional position, but can also existing button, then menu is placed nearby\n!Normally used after after series of smdefblock etc calls to setup a menu layout\n!Dim usually is a call to smmenusize which exactly contains the blocks\n!return handle to window\n\n!CPL \"SMCREATE\"\n\nw:=gxcreatewindow(caption:caption, dim:dim, options:[wf_minmax:0],pos:pos)\n!w:=gxcreatewindow(caption:caption, dim:dim)\nw.windclass:=popup_class\ncurrpopup:=w\n\nslposx:=chx\nslposy:=chy\nsldir:=(dim[1]>dim[2]|'H'|'V')\n\nwpopup:=w\n\noldfocus:=wfocus\nif wfocus then\n\tgxkillfocus()\nfi\n\npopuplist[++npopups]:=w\nfocuslist[npopups]:=oldfocus\t\t!of underlying window\n\nreturn w\nend\n\nexport func smblock(block,border=0)=\n!set block as the current block for subsequent \n!unlike old versions of the library, an actual window is created for the block,\n!and a handle to that is returned. That is a child group control.\n\ncase border\nwhen 0 then\tbord:=bs_none\nwhen 1 then\tbord:=bs_simple\nwhen 2 then\tbord:=bs_panel\nelse\n\tbord:=bs_none\nesac\n\nwblock:=gxgroup(pos:(block.posx,block.posy),dim:(block.dimx,block.dimy),\n!\t\towner:currpopup, style:[ss_border:bs_none])\n\t\towner:currpopup, style:[ss_border:bord])\ncurrblock:=block\ncurrgroup:=wblock\ncellx:=celly:=1\n\nreturn wblock\nend\n\nexport proc smclose=\n!NOTE: for nested menus, ie. invoking another popup menu while one is still\n!on the screen, requires:\n! * blocklist needs to be moved elsewhere, eg. to data field of current popup rwindow\n! * Then smclose can close blocks in that list, not the export one\n! * Global blocklist can be reused\n! * It might require that the owner window is disabled from being clicked on, but\n!   that will be awkward to do without disabling each control within it. Or perhaps\n!   this is a check that can be done within process_wmmessage, to see if click-window\n!   has an owner that has been disabled.\n!    Disabling is one with smcreate, and re-enableing here in smclose\n\ngxclose(wpopup)\n!for block in blocklist do\n!\tblock:=0\n!!\tfreehandle(block)\n!od\n\noldfocus:=focuslist[npopups]\n--npopups\nif npopups then\n\twpopup:=popuplist[npopups]\n\tif oldfocus then\n\t\tgxfocus(oldfocus)\n\tfi\nelse\n\twpopup:=nil\nfi\nend\n\nexport proc smoff=\nsmclose()\nend\n\nproc nextcell=\n!step cellx,y to next cell within current block\nif currblock.dir='V' then\n\t++celly\n\tif celly>currblock.cellsy then\n\t\tcelly:=1\n\t\t++cellx\n\tfi\nelse\t\t\t\t\t!hoz\n\t++cellx\n\tif cellx>currblock.cellsx then\n\t\tcellx:=1\n\t\t++celly\n\tfi\nfi\nend\n\nfunc getsmpos=\nreturn ((cellx-1)*currblock.pitchx+currblock.cellposx,\n        (celly-1)*currblock.pitchy+currblock.cellposy)\nend\n\nfunc getsmdim=\nreturn (currblock.celldimx,currblock.celldimy)\nend\n\nfunc getslpos=\nreturn (slposx,slposy)\nend\n\nfunc getsldim(s)=\nif s.isint then\n\treturn (s*chx+chx*2,chy+smy*2)\nelse\n\treturn (gxtextwidth(labelfont,s)+smx*2,chy+smy*2)\nfi\nend\n\nproc nextslcell(dim)=\nif sldir='H' then\n\tslposx+:=dim[1]+chx\nelse\n\tslposy+:=dim[2]+chy\nfi\nend\n\nexport func smcmd(caption,id=0,enable=1)=\n!create button within current block\n!caption can also be an integer code:\n! 0\t\tskip this cell (just leave a blank space)\n! -1\tinsert divider line\n!when id is omitted or is zero, then creates a static label instead\n\n!CPL \"SMCMD\",CAPTION,ID\n\nif caption.isint then\n\tcase caption\n\twhen 0 then\n\twhen -1 then\n\tesac\n\tnextcell()\n\treturn nil\nfi\n\nif id=0 then\n\treturn smlabel(caption)\nfi\n\npos:=getsmpos()\ndim:=(currblock.celldimx,currblock.celldimy)\nss:=[ss_border:bs_simplew]\n\nw:=gxbutton(pos:pos,dim:dim,caption:caption,id:id,owner:currgroup, \n\tstyle:ss, enable:enable)\nnextcell()\nreturn w\nend\n\nexport func smlabel(caption)=\npos:=getsmpos()\ndim:=(currblock.celldimx,currblock.celldimy)\n\nw:=gxlabel(pos:pos,dim:dim,caption:caption,owner:currgroup)\nnextcell()\nreturn w\nend\n\nexport func smarrow(dir,id)=\npos:=getsmpos()\ndim:=(currblock.celldimx,currblock.celldimy)\n\nw:=gxarrow(pos:pos,dim:dim,dir:dir,owner:currgroup)\nnextcell()\nreturn w\nend\n\nexport func smtoggle(caption,linkvar,id=0,enable=1)=\n!create toggle control within current block\n\nw:=gxtoggle(pos:getsmpos(), dim:getsmdim(), caption:caption,\n\t\t\tlinkvar:linkvar,id:id,owner:currgroup, enable:enable,\n\t\t\tstyle:currblock.blockstyle)\n!style:[ss_marktype:radio_mark])\n!style:[ss_marktype:check_mark])\n!style:[ss_marktype:bold_mark])\n\n!\t(radio_mark,\t\t$),\n!\t(tick_mark,\t\t\t$),\n!\t(check_mark,\t\t$),\n!\t(invert_mark,\t\t$),\n!\t(outline_mark,\t\t$),\n!\t(bold_mark,\t\t\t$),\n\nnextcell()\nreturn w\nend\n\nexport func smselect(caption,linkvar,onvalue=1,id=0,enable=1)=\n!create toggle control within current block\n\nw:=gxselect(pos:getsmpos(), dim:getsmdim(), caption:caption,\n\t\t\tlinkvar:linkvar,onvalue:onvalue,\n\t\t\tid:id,owner:currgroup, enable:enable, style:currblock.blockstyle)\n\nnextcell()\nreturn w\nend\n\nexport func smeditbox(?caption,linkvar,id=0,enable=1,?style)=\n!create toggle control within current block\n\npos:=getsmpos()\ndim:=getsmdim()\n\nif caption.isdef then\n\tgxlabel(pos:pos, dim:(currblock.labelwidth-chx,dim[2]), caption:caption,\n\t owner:currgroup)\n\tpos[1]+:=currblock.labelwidth\n\tdim[1]-:=currblock.labelwidth\nfi\n\nw:=gxeditbox(pos:pos, dim:dim,\n\t\t\tlinkvar:linkvar,\n\t\t\tid:id,owner:currgroup, enable:enable, style:getstyle(style))\n!gxdrawmode(w,dm_screenmemory)\n\nnextcell()\nreturn w\nend\n\nexport func smlistbox(linkvar,id=0,enable=1)=\n\n!CPL =CURRBLOCK.CELLSY,\"(ROWS)\"\n!CPL =CURRBLOCK.PITCHY,\"(PITCH)\"\n!CPL =CURRBLOCK.CELLDIMY,\"(CELLDIMY)\"\n!CPL =CURRBLOCK.CELLPOSY,\"(OFFSET)\"\n!CPL =CURRBLOCK.GAPY,\"(GAPY)\"\n!CPL =CURRBLOCK.DIMY,\"(DIMY)\"\n!CPL \"LBDIMY=\",CURRBLOCK.DIMY-CURRBLOCK.MARGINY*2\n!CPL =CURRBLOCK.MARGINY\n\nCPL \"SMLB1\"\n!$SETDEBUG(1)\nw:=gxlistbox(pos:getsmpos(),\n\tdim:(currblock.dimx-currblock.marginx*2,currblock.dimy-currblock.marginy*2),\n\tlinkvar:linkvar,\n\tstyle:[ss_vscroll:1,\n\tss_border:bs_simplew],\n\trows:currblock.cellsy,\n\tpitch:currblock.pitchy,\n!\toffset:currblock.cellposy,\n\tid:id,owner:currgroup)\nCPL \"SMLB2\"\nreturn w\nend\n\nexport func sllabel(caption)=\npos:=getslpos()\ndim:=getsldim(caption)\n\nw:=gxlabel(pos:pos,dim:dim,caption:caption,owner:currpopup)\nnextslcell(dim)\nreturn w\nend\n\nexport func slcmd(caption,id=201,enable=1)=\n!create button within current block\n!caption can also be an integer code:\n! 0\t\tskip this cell (just leave a blank space)\n! -1\tinsert divider line\n!when id is omitted or is zero, then creates a static label instead\n\npos:=getslpos()\ndim:=getsldim(caption)\nss:=[ss_border:bs_simplew]\n\nw:=gxbutton(pos:pos,dim:dim,caption:caption,id:id,owner:currpopup, \n\tstyle:ss)\nnextslcell(dim)\nreturn w\nend\n\nexport func sleditbox(linkvar,width=30,id=0,enable=1)=\npos:=getslpos()\ndim:=getsldim(width)\n\nw:=gxeditbox(pos:pos, dim:dim,\n\t\t\tlinkvar:linkvar,\n\t\t\tid:id,owner:currpopup)\n\nnextslcell(dim)\nreturn w\nend\n\nexport func smok(caption=\"OK\",enable=1)=\nreturn smcmd(caption,mm_ok,enable)\nend\n\nexport func smcancel(caption=\"Cancel\",enable=1)=\nreturn smcmd(caption,mm_cancel,enable)\nend\n\nexport func slok(caption=\"OK\")=\nreturn slcmd(caption,mm_ok)\nend\n\nexport func slcancel(caption=\"Cancel\")=\nreturn slcmd(caption,mm_cancel)\nend\n\nexport proc smokcancel=\nsmok()\nsmcancel()\nend\n\nexport proc slinit(w)=\ncurrpopup:=w\nslposx:=chx\nslposy:=0\nsldir:=(w.dimx>w.dimy|'H'|'V')\nend\n\nexport func smerror(mess) =\n!a:=b+c\n!println \"Unimplemented SM/CCI function:\", mess\npcerror(\"Unimplemented SM/CCI function: \"+mess+\"\\n\\n\\n\")\nprintln\nprintln\nprintln\nstop\nreturn 0\nend\n\nexport proc settab(?a,?b,?c,?d,?e,?f,?g,?h,?i)=\nstatic var oldtabs\n\nif not a.defined then\n\tgxtabstops(oldtabs)\n\treturn\nfi\n\noldtabs:=gxtabstops()\nparams::=allparams()\n\n!gxtabstops(allparams())\ngxtabstops(param)\nend\n\nexport proc smupdatevalue(w)=\ngxupdate(w)\nend\n\nexport proc setfocus(w,?b)= gxfocus(w) end\n\nexport proc askmenu(a)=\nmessage:=gxaskmess(1)\nmessw:=currmess.wind\nend\n\nfunc readstylestr(s)=\n!read cell style string s, and return option dict\nd:=new(dict)\nif s=\"\" then return d fi\n\ns:=convuc(s)\n\nforeach c in s do\n\tcase c\n\twhen 'X' then d{ss_marktype}:=check_mark\n\twhen 'M' then d{ss_marktype}:=radio_mark\n\twhen 'I' then d{ss_marktype}:=invert_mark\n\twhen 'R' then d{ss_returnmess}:=1\n\twhen 'N' then d{ss_noupdate}:=1\n\tesac\nod\nreturn d\nend\n\nfunc getstyle(style)=\nif style.defined then\n\treturn readstylestr(style)\nelse\n\treturn currblock.blockstyle\nfi\n\nend\n\nexport func smmark(a,b,c)= return smerror($function) end\nexport func smcheck(?a,?b,?c,?d,?e)= return smerror($function) end\nexport func smmenu(?a)= return smerror($function) end\nexport func smshowmenu(a,?b,?c,?d)= return smerror($function) end\nexport func smdown= return smerror($function) end\nexport func smup= return smerror($function) end\nexport func smleft= return smerror($function) end\nexport func smright= return smerror($function) end\nexport func smedit(a,b,c,?d)= return smerror($function) end\n!export func smoff= return smerror($function) end\nexport func smbutton(a,b)= return smerror($function) end\nexport func smstartmenu(a)= return smerror($function) end\nexport func smsize(a)= return smerror($function) end\n\n\n",
    
(byte*)"\nexport type wt_word\t\t= word16\nexport type wt_bool\t\t= word32\nexport type wt_dword\t= word32\nexport type wt_wchar\t= word16\nexport type wt_char\t\t= byte\nexport type wt_ichar\t= stringz\nexport type wt_string\t= stringz\nexport type wt_ptr\t\t= ref byte\nexport type wt_wndproc\t= word64\n\nexport type wt_handle\t= ref void\nexport type wt_int\t\t= int32\nexport type wt_uint\t\t= word32\nexport type wt_long\t\t= int32\nexport type wt_wparam\t= word64\nexport type wt_lparam\t= word64\nexport type wt_size\t\t= word64\n\nexport type wt_wparam32\t= word32\nexport type wt_lparam32\t= word32\nexport type wt_handle32\t= word32\nexport type wt_ptr32\t= word32\nexport type wt_string32\t= word32\nexport type wt_wndproc32\t= word32\n\nexport type wt_wparam64\t= word64\nexport type wt_lparam64\t= word64\nexport type wt_handle64\t= word64\nexport type wt_ptr64\t= word64\nexport type wt_string64\t= word64\nexport type wt_wndproc64= word64\n\nexport type wt_result\t= word64\nexport type wt_intptr\t= word64\nexport type wt_coord\t= word32\n\nexport type ws_spoint= struct\n\tint16 x,y\nend\n\nexport type ws_srect=struct\n\tint16 leftx,top, rightx,bottom\nend\n\nexport type ws_charinfo=struct\n\tunion\n\t\twt_word\tunicodechar\n\t\twt_char\tasciichar\n\tend union\n\twt_word\t\tattributes\nend\n\nexport type ws_palette16=[0..15]int32\n\nexport type ws_console=struct\n\tws_spoint size,pos\n\twt_word attributes\n\tws_srect window\n\tws_spoint maxwindowsize\nend\n\nexport type ws_consoleex=struct\n\tint32 recsize\n\tws_spoint size,pos\n\twt_word attributes\n\tws_srect window\n\tws_spoint maxwindowsize\n\twt_word wpopup\n\tint32 fullscreen\n\tws_palette16 palette\nend\n\nexport type ws_keyevent = struct $caligned\n\twt_word\teventtype\n\t\twt_bool\tkeydown\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nexport type ws_cursor=struct\n\tint32 size,visible\nend\n\nexport var hconsole, hconsolein\n\nexport const stdoutputhandle=0xffff_fff5\nexport const stdinputhandle=0xfffffff6\nexport const stderrorputhandle=0xfffffff4\nexport const invalidhandlevalue=0xffffffff\n\nexport const maxpathlen=260\n\ntype spath=stringz*maxpathlen\ntype sshort=stringz*14\n!\nexport type ws_filetime=struct\n\tint32 ftlow\n\tint32 fthigh\nend\n\nexport type ws_finddata=struct\n\tint32\t\tfileattributes\n\tws_filetime\tcreationtime\n\tws_filetime\tlastaccesstime\n\tws_filetime\tlastwritetime\n\tint32\t\tfilesizehigh\n\tint32\t\tfilesizelow\n\tint32\t\treserved0\n\tint32\t\treserved1\n\tspath\t\tfilename\n\tsshort\t\tshortfilename\nend\n\nexport type ws_systemtime = struct\n\tword16\tyear\n\tword16\tmonth\n\tword16\tdayofweek\n\tword16\tday\n\tword16\thour\n\tword16\tminute\n\tword16\tsecond\n\tword16\tmilliseconds\nend\n\nexport type ws_msg64 = struct $caligned\n\tref void\thwnd\n\tint32\t\tmessage\n\tint64\t\twparam\n\tint64\t\tlparam\n\tint32\t\ttime\n\tint32\t\tptx\n\tint32\t\tpty\nend\n\nexport type ws_point = struct\n\tint32 x, y\nend\n\nexport type ws_rect=struct\t\t!rect record occupying 16 bytes\n\tunion\n\t\tstruct\n\t\t\tint32 leftx,top, rightx,bottom\n\t\tend\n\t\tstruct\n\t\t\tunion int32 x,x1 end\n\t\t\tunion int32 y,y1 end\n\t\t\tint32 x2,y2\n\t\tend\n\tend\nend\n\nexport type ws_logbrush = struct\n\tint32 lbstyle\n\tint32 lbcolour\n\tint32 lbhatch\nend\n\nexport type ws_textmetrics = struct\n\tint32\theight\n\tint32\tascent\n\tint32\tdescent\n\tint32\tint32ernalleading\n\tint32\texternalleading\n\tint32\tavecharwidth\n\tint32\tmaxcharwidth\n\tint32\tweight\n\tint32\toverhang\n\tint32\tdigitizedaspectx\n\tint32\tdigitizedaspecty\n\tbyte\tfirstchar\n\tbyte\tlastchar\n\tbyte\tdefaultchar\n\tbyte\tbreakchar\n\tbyte\titalic\n\tbyte\tunderlined\n\tbyte\tstruckout\n\tbyte\tpitchandfamily\n\tbyte\tcharset\nend\n!=========================================\n\nexport type ws_bitmapv5header = struct\n\tint32\tsize\n\tint32\twidth\n\tint32\theight\n\tword16\tplanes\n\tword16\tbitcount\n\tint32\tcompression\n\tint32\tsizeimage\n\tint32\txpelspermeter\n\tint32\typelspermeter\n\tint32\tclrused\n\tint32\tclrimportant\n\tint32\tredmask\n\tint32\tgreenmask\n\tint32\tbluemask\n\tint32\talphamask\n\tint32\tcstype\n\t[1..9]int32 endpoints\n\tint32\tredgamma\n\tint32\tgreengamma\n\tint32\tbluegamma\n\tint32\tintent\n\tint32\tprofiledata\n\tint32\tprofilesize\n\tint32\treserved\nend\n\nexport type ws_bitmapfileheader = struct\n\twt_word\t\ttypex\n\twt_dword\tsize\n\twt_word\t\tres1, res2\n\twt_dword\toffbits\nend\n\nexport type ws_bitmapinfoheader = struct\n\twt_dword \tsize\n\twt_long\t\twidth\n\twt_long\t\theight\n\twt_word\t\tplanes\n\twt_word\t\tbitcount\n\twt_dword\tcompression\n\twt_dword\tsizeimage\n\twt_long\t\txpelspermetre\n\twt_long\t\typelspermetre\n\twt_dword\tclrused\n\twt_dword\tclrimportant\nend\n\nexport type ws_paintstruct = struct\n!\tint64\t\thdc\n\tint64\t\thdc\n\tint32\t\terase\n\tws_rect\t\tpaintrect\n\tint32\t\trestore\n\tint32\t\tincupdate\n\t[32]byte\trgbreserved\nend\n\n!32-BIT VERSION\nexport type ws_openfilename32 = struct\n\twt_dword\t\tstructsize\n\twt_handle32\t\towner\n\twt_handle32\t\tinstance\n\twt_string32\t\tfilter\n\twt_string32\t\tcustomfilter\n\twt_dword\t\tmaxcustfilter\n\twt_dword\t\tfilterindex\n\twt_string32\t\tfile\n\twt_dword\t\tmaxfile\n\twt_string32\t\tfiletitle\n\twt_dword\t\tmaxfiletitle\n\twt_string32\t\tinitialdir\n\twt_string32\t\ttitle\n\twt_dword\t\tflags\n\twt_word\t\t\tfileoffset\n\twt_word\t\t\tfileextension\n\twt_string32\t\tdefext\n\twt_lparam32\t\tcustdata\n\twt_wndproc32\thook\n\twt_string32\t\ttemplatename\n\twt_ptr32\t\treserved1\n\twt_dword\t\treserved2\n\twt_dword\t\tflagsex\nend\n\n!64-BIT VERSION\nexport type ws_openfilename64 = struct $caligned\n\twt_dword\t\tstructsize\n\twt_handle64\t\towner\n\twt_handle64\t\tinstance\n\twt_string64\t\tfilter\n\twt_string64\t\tcustomfilter\n\twt_dword\t\tmaxcustfilter\n\twt_dword\t\tfilterindex\n\twt_string64\t\tfile\n\twt_dword\t\tmaxfile\n\twt_string64\t\tfiletitle\n\twt_dword\t\tmaxfiletitle\n\twt_string64\t\tinitialdir\n\twt_string64\t\ttitle\n\twt_dword\t\tflags\n\twt_word\t\t\tfileoffset\n\twt_word\t\t\tfileextension\n\twt_string64\t\tdefext\n\twt_lparam64\t\tcustdata\n\twt_wndproc64\thook\n\twt_string64\t\ttemplatename\n\twt_ptr64\t\treserved1\n\twt_dword\t\treserved2\n\twt_dword\t\tflagsex\nend\n\nimportdll kernel32=\n\twindows func\t\"GetLastError\"\t\t\t\t\t:wt_dword\n\twindows func\t\"GetStdHandle\"\t\t\t\t\t(wt_dword)wt_handle\n\twindows func\t\"WriteConsoleA\" as writeconsole\t\t\t\t(wt_handle,wt_string,wt_dword,wt_ptr,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleCursorPosition\"\t\t(wt_handle,wt_coord)wt_bool\n\twindows func\t\"GetConsoleScreenBufferInfo\"\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleMode\"\t\t\t\t(wt_handle,wt_dword)wt_bool\n\twindows func\t\"WriteConsoleOutputA\" as writeconsoleoutput\t\t\t(wt_handle,wt_ptr,wt_coord,wt_coord,wt_ptr)wt_bool\n\n\twindows func\t\"GetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetConsoleWindow\"\t\t\t\t:wt_handle\n\n\twindows func\t\"SetConsoleTextAttribute\"\t\t(wt_handle,wt_word)wt_bool\n\twindows func\t\"SetConsoleTitleA\" as setconsoletitle\t\t\t\t(wt_string)wt_bool\n\twindows func\t\"ReadConsoleInputA\" as readconsoleinput\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\n\twindows func\t\"PeekConsoleInputA\"\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\n\twindows func\t\"FlushConsoleInputBuffer\"\t\t(wt_handle)wt_bool\n\twindows func\t\"SetConsoleWindowInfo\"\t\t\t(wt_handle,wt_bool,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleScreenBufferSize\"\t(wt_handle,wt_coord)wt_bool\n\twindows func\t\"GetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)wt_bool\n\n\twindows func\t\"FindFirstFileA\" as findfirstfile\t\t(stringz,ref int32)int32\n\twindows func\t\"FindNextFileA\"  as findnextfile\t\t\t(int32,ref int32)int32\n\twindows func\t\"FindClose\"\t\t\t\t\t(int32)int32\n\twindows func\t\"SetCurrentDirectoryA\" as setcurrentdirectory\t(stringz)int32\n\twindows func\t\"GetCurrentDirectoryA\" as getcurrentdirectory\t(int32,int32)int32\n\twindows func\t\"CreateDirectoryA\" as createdirectory\t\t(stringz,int32)int32\n\twindows func\t\"GetFileAttributesA\"\t\t\t(stringz)int32\n\twindows func\t\"GetModuleHandleA\" as getmodulehandle\t\t(wt_string)wt_handle\n\twindows func\t\"GetTickCount\"\t\t\t\t\t\t\t\t:wt_dword\n\twindows func\t\"GlobalAlloc\"\t\t\t\t\t\t\t\t\t(wt_uint,wt_size)wt_handle\n\twindows func\t\"GlobalLock\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_ptr\n\twindows func\t\"GlobalUnlock\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"GlobalSize\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_size\n\n\twindows func\t\"GetSystemTime\"(ref byte)int32\n\twindows func\t\"Beep\"\t\t\t\t\t\t\t(wt_dword, wt_dword)wt_bool\n\twindows func\t\"SetConsoleCP\"\t\t\t\t\t\t\t\t(wt_uint)wt_bool\nend\n\nimportdll user32=\n\twindows func\t\"CreateWindowExA\" as createwindowex\t\t(wt_dword, wt_string, wt_string, wt_dword, wt_int,wt_int,wt_int,wt_int,\n\t\t\t\t\t\t\t\t\t\t\t\t\t wt_handle, wt_handle, wt_handle, wt_ptr)wt_handle\n\n\twindows func\t\"GetMessageA\" as getmessage\t\t\t\t(wt_ptr, wt_handle, wt_uint, wt_uint)wt_bool\n\twindows func\t\"TranslateMessage\"\t\t\t\t\t\t(wt_ptr)wt_bool\n\twindows func\t\"DispatchMessageA\" as dispatchmessage\t\t(wt_ptr)wt_result\n\twindows func\t\"SetTimer\"\t\t\t\t\t\t\t\t(wt_handle,wt_intptr,wt_uint,wt_ptr)wt_intptr\n\twindows func\t\"KillTimer\"\t\t\t\t\t\t\t\t(wt_handle,wt_intptr)wt_bool\n\twindows func\t\"SystemParametersInfoA\"\t\t\t\t\t(wt_uint,wt_uint,wt_ptr,wt_uint)wt_bool\n\twindows func\t\"GetSystemMetrics\"\t\t\t\t\t\t(wt_int)wt_int\n!\twindows func\t\"CreateMenu\"\t\t\t\t\t\t\t\t:int\n\twindows func\t\"AppendMenuA\" as appendmenu\t\t\t\t(wt_handle,wt_uint,wt_intptr,wt_string)wt_bool\n\twindows func\t\"GetDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\twindows func\t\"ReleaseDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_int\n\n\twindows func\t\"SendMessageA\" as sendmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_result\n\twindows func\t\"PostMessageA\" as postmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_bool\n\twindows func\t\"PeekMessageA\" as peekmessage\t\t\t\t(wt_ptr,wt_handle,wt_uint,wt_uint,wt_uint)wt_bool\n\twindows func\t\"BeginPaint\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_handle\n\twindows func\t\"EndPaint\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows proc     \t\"PostQuitMessage\"\t\t\t\t\t(wt_int)\n\twindows func\t\"LoadIconA\" as loadicon\t\t\t\t\t(wt_handle,wt_string)wt_handle\n\twindows func\t\"LoadCursorA\" as loadcursor\t\t\t\t(wt_handle,wt_string)wt_handle\n\twindows func\t\"SetCursor\"\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\twindows func\t\"DrawMenuBar\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"GetSystemMenu\"\t\t\t\t\t\t\t(wt_handle,wt_bool)wt_handle\n\twindows func\t\"CreateMenu\"\t\t\t\t\t\t\t\t:wt_handle\n\twindows func\t\"CreatePopupMenu\"\t\t\t\t\t\t\t:wt_handle\n\twindows func\t\"DestroyMenu\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"CheckMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_dword\n\twindows func\t\"EnableMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\twindows func\t\"GetSubMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_handle\n\twindows func\t\"GetMenuItemID\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_uint\n\twindows func\t\"GetMenuItemCount\"\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"InsertMenuA\" as insertmenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\n\twindows func\t\"ModifyMenuA\" as modifymenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\n\twindows func\t\"RemoveMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\twindows func\t\"DeleteMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\n\twindows func\t\"DestroyWindow\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"InvalidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_bool)wt_bool\n\twindows func\t\"ValidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"ShowWindow\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\n\twindows func\t\"GetClassLongA\" as getclassint\t\t\t(wt_handle,wt_int)wt_word\n\twindows func\t\"SetClassLongA\" as setclasslong\t\t\t(wt_handle,wt_int,wt_dword)wt_word\n\twindows func\t\"SetWindowTextA\" as setwindowtext\t\t\t(wt_handle,wt_string)wt_bool\n\twindows func\t\"GetWindowTextA\" as getwindowtext\t\t\t(wt_handle,wt_string,wt_int)wt_int\n\twindows func\t\"GetWindowTextLengthA\" as getwindowtextlength\t(wt_handle)wt_int\n\twindows func\t\"GetKeyState\"\t\t\t\t\t\t\t\t(wt_int)wt_word\n\n!\twindows func\t\"GetWindowLongPtrA\" as getwindowlongptr\t(wt_handle,wt_int)int64\n!\twindows func\t\"SetWindowLongPtrA\" as setwindowlongptr\t(wt_handle,wt_int,wt_int)int64\n\twindows func\t\"GetWindowLongA\" as getwindowlongptr\t\t(wt_handle,wt_int)int64\n\twindows func\t\"SetWindowLongA\" as setwindowlongptr\t\t(wt_handle,wt_int,int64)int64\n\n\twindows func\t\"GetClientRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"ClientToScreen\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"ScreenToClient\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetWindowRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetSysColor\" as getsyscolour\t\t\t\t(wt_int)wt_dword\n\twindows func\t\"GetScrollInfo\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_bool\n\twindows func\t\"GetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\twindows func\t\"SetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_ptr\n\twindows func\t\"TrackPopupMenu\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_int,wt_int,wt_int,wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetMenuState\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_uint\n\twindows func\t\"MessageBoxA\" \\\n\t\t\t\t\t\t\t\t(wt_handle a=nil,wt_string message, wt_string caption=\"Caption\", wt_uint b=0)wt_int\n\twindows func\t\"OpenClipboard\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"CloseClipboard\"\t\t\t\t\t\t\t:wt_bool\n\twindows func\t\"EmptyClipboard\"\t\t\t\t\t\t\t:wt_bool\n\twindows func\t\"GetClipboardData\"\t\t\t\t\t\t(wt_uint)wt_handle\n\twindows func\t\"SetClipboardData\"\t\t\t\t\t\t(wt_uint,wt_handle)wt_handle\n\twindows func\t\"MessageBeep\"\t\t\t\t\t\t\t(wt_uint x=0)wt_bool\nend\n\nimportdll gdi32=\n\twindows func\t\"Rectangle\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"RoundRect\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Ellipse\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Arc\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Chord\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Pie\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Polygon\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_int)wt_bool\n\twindows func\t\"TextOutA\" as textout\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_string,wt_int)wt_bool\n\twindows func\t\"TextOutW\" \t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_ptr,wt_int)wt_bool\n\twindows func\t\"GetStockObject\"\t\t\t\t\t\t\t(wt_int)wt_handle\n\twindows func\t\"SelectObject\"\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_handle\n\twindows func\t\"CreateDCA\" as createdc\t\t\t\t\t(wt_string,wt_string,wt_string,wt_ptr)wt_handle\n\twindows func\t\"MoveToEx\"\t\t\t\t\t\t(wt_handle a,wt_int b,wt_int c,wt_ptr d=nil)wt_bool\n\twindows func\t\"CreatePen\"\t\t\t\t\t\t\t\t(wt_int,wt_int,wt_dword)wt_handle\n\twindows func\t\"CreateSolidBrush\"\t\t\t\t\t\t(wt_dword)wt_handle\n\twindows func\t\"CreateBrushIndirect\"\t\t\t\t\t\t(wt_ptr)wt_handle\n\twindows func\t\"LineTo\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\n\twindows func\t\"GetPixel\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_dword\n\twindows func\t\"SetPixel\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword)wt_dword\n\twindows func\t\"SetGraphicsMode\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\twindows func\t\"CreateFontIndirectA\" as createfontindirect\t(wt_ptr)wt_handle\n\twindows func\t\"CreateFontA\" as createfont \\\n\t\t\t(wt_int height, wt_int width=0, wt_int escapement=0, wt_int orientation=0, wt_int bold=0,\n\t\t\t wt_dword italic=0, wt_dword underline=0, wt_dword strikeout=0, wt_dword charset=0,\n\t\t\t wt_dword outprec=0, wt_dword clipprec=0, wt_dword quality=0, wt_dword pitch=0, wt_string facename)wt_handle\n\twindows func\t\"SaveDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"GetTextMetricsA\" as gettextmetrics\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"DeleteObject\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"RestoreDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\n\twindows func\t\"GetTextExtentPoint32A\" as gettextextentpoint32\t(wt_handle,wt_string,wt_int,wt_ptr)wt_bool\n\twindows func\t\"GetObjectA\" as getobject\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_int\n\twindows func\t\"CreatePalette\"\t\t\t\t\t\t\t(wt_ptr)wt_handle\n\twindows func\t\"GetWindowExtEx\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"CreateCompatibleBitmap\"\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_handle\n\twindows func\t\"SetBitmapBits\"\t\t\t\t\t\t\t(wt_handle,wt_dword,wt_ptr)wt_long\n\twindows func\t\"SelectPalette\"\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_bool)wt_handle\n\twindows func\t\"RealizePalette\"\t\t\t\t\t\t\t(wt_handle)wt_uint\n\twindows func\t\"SetDIBitsToDevice\"\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword,wt_dword,wt_int,wt_int,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\n\twindows func\t\"StretchDIBits\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_ptr,wt_ptr,wt_uint,wt_dword)wt_int\n\twindows func\t\"SetStretchBltMode\"\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\twindows func\t\"PatBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_dword)wt_bool\n\twindows func\t\"BitBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_handle,wt_int,wt_int,wt_dword)wt_bool\n\twindows func\t\"SetROP2\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\twindows func\t\"CreateCompatibleDC\"\t\t\t\t\t\t(wt_handle)wt_handle\n\twindows func\t\"DeleteDC\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"CreateBitmap\"\t\t\t\t\t\t\t(wt_int,wt_int,wt_uint,wt_uint,wt_ptr)wt_handle\n\twindows func\t\"CreateBitmapIndirect\"\t\t\t\t\t(wt_ptr)wt_handle\n\twindows func\t\"CreateDIBitmap\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr,wt_ptr,wt_uint)wt_handle\n\twindows func\t\"CreateDIBSection\"\t\t\t\t\t\t(wt_handle,wt_ptr,wt_uint,wt_ptr,wt_handle,wt_dword)wt_handle\n\twindows func\t\"StretchBlt\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int, wt_int,wt_int,wt_handle, wt_int,wt_int,wt_int, wt_int,wt_dword)wt_bool\n\twindows func\t\"PlgBlt\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_handle, wt_int,wt_int,wt_int,wt_int, wt_handle, wt_int,wt_int)wt_bool\n\twindows func\t\"SetTextColor\"  as settextcolour\t\t\t(wt_handle,wt_dword)wt_dword\n\twindows func\t\"SetTextAlign\"\t\t\t\t\t\t\t(wt_handle,wt_uint)wt_uint\n\twindows func\t\"SetTextJustification\"\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\n\twindows func\t\"SetBkColor\"  as setbkcolour\t\t\t\t(wt_handle,wt_dword)wt_dword\n\twindows func\t\"SetBkMode\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\twindows func\t\"GetBkColor\"  as getbkcolour\t\t\t\t(wt_handle)wt_dword\n\twindows func\t\"GetBkMode\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"StartDocA\" as startdoc\t\t\t\t\t(wt_handle,wt_ptr)wt_int\n\twindows func\t\"StartPage\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"EndPage\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"EndDoc\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"AbortDoc\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"GetViewportOrgEx\"\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetDIBits\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\n\twindows func\t\"GetDIBColorTable\" as getdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\n\twindows func\t\"SetDIBColorTable\" as setdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\n\twindows func\t\"GetTextAlign\"\t\t\t\t\t\t\t(wt_handle)wt_uint\nend\n\nimportdll comdlg32=\n\twindows func\t\"GetOpenFileNameA\"\t\t\t\t\t\t(wt_ptr)wt_bool\n\twindows func\t\"GetSaveFileNameA\"\t\t\t\t\t\t(wt_ptr)wt_bool\nend\n",
    
(byte*)"!MODULE winmessages\nmodule sysp\n\nmodule winconsts\nmodule winapi\nmodule wingxlib\nmodule gxmisc\n\nexport var debug=0\n\nexport var messhandlertable=9000\t!message by windowclass table of message handlers\nexport var actionhandlertable\n\nexport var chx,chy\t\t!default text sizes for menus\nexport var cha,chd\t\t!ascender/descender heights\nexport const smx=3\t\t!margins around button text in pixels (both sides)\nexport const smy=4\nexport var arrowdim\nexport var markdim\nexport var buttonheight\nexport var listrowheight\nexport const labelfont=1\n\nexport var tabstops=(8,)*20\n\nexport var wmouse=0\nexport var wfocus=0\nexport var wprinter=0\nexport var lastmousepos=0\nexport var lastmousewindow=0\nexport var currmousewindow=0\n\nexport var mousepos\nexport var mousesw\nexport var quitmess=0\nexport var dragmode=0\nexport var lastbuttontime=0\n\nexport var buttonstate=0\nexport var wmessagetable\t\t!see initdata\nexport var buttontable\t\t!see initdata\n\nconst maxqueuesize=100\nexport var messagequeue=()\nexport var nmessages=()\n\nconst dragtol=1\n\nexport var copymode=4\n\nvar vktomesstable\n\n!Describe gx window (also bitmap, control or child window)\nexport record rwindow =\n\n\tvar windclass\t\t\t\t\t! type of window (popup, control, etc)\n\tvar flags\t\t\t\t\t\t! general purpose flags\n\tvar style\t\t\t\t\t\t! stylerec entry\n\tvar name\t\t\t\t\t\t! Optional debugging name\n\n\tvar owner\t\t\t\t\t\t! owner when this is a child window\n\tvar index\t\t\t\t\t\t! index 1..n when part of a list (eg. .childlist of owner)\n\tvar childlist\t\t\t\t\t! list of child windows\n\n!framepos/dim describe the overall window size including Windows or gx-drawn borders,\n\tvar frameposx, frameposy\t\t! top left of frame, in screen or owner window client coords\n\tvar framedimx, framedimy\t\t! pixels dims including frame and caption\n\n\tvar\tposx, posy\t\t\t\t\t! Pixel pos client area as seen by application\n\tvar\tdimx, dimy\t\t\t\t\t! Pixel dims of client area as seen by application\n\n\tvar gdi\t\t\t\t\t\t\t! (rgdistate)\tgdi state record\n\n\tvar enable\t\t\t\t\t\t! 1 to enable toggle/button/arrow etc, 0 to disable and show greyed out\n\tvar id\t\t\t\t\t\t\t! button/et al: command code associated with control\n\tvar text\t\t\t\t\t\t! caption or label or primary data\n!\t\tvar data \t@text\n\tvar linkvar\t\t\t\t\t\t! pointer to linked var for toggle/select/scroll\n\tvar gindex\t\t\t\t\t\t! window export index\n\n\tvar attrs\t\t\t\t\t\t! general purpose attributes, depends on window class\n\n!bitmap data\n\tvar pixelbits\t\t\t\t\t! 1, 4, 16, 24, 32 bits per pixel\n\tvar pixelptr\t\t\t\t\t! pointer to image data\n\tvar pixelbytes\t\t\t\t\t!bytes/pixel (round up to next whole byte)\n\tvar linebytes\t\t\t\t\t!bytes/per row, also pitch\n\tvar framebytes\n\tvar paltype\t\t\t\t\t\t!0, or palette type\nend\n\nexport enumdata paltypenames =\n\t(no_pal=0,\t\t$),\n\t(greyscale_pal,\t$),\n\t(tinted_pal,\t$),\n\t(colour_pal,\t$),\n\t(uv_pal,\t\t$),\nend\n\nexport type rgdistate = struct\n\tref void hwnd\t\t\t\t! win32 handle (hwnd)\n\tref void hdc\t\t\t\t! 0 or device context handle for hwnd\n\tref void hwnd2\t\t\t\t! secondary window/memory backup\n\tref void hdc2\t\t\t\t! 0 or hwnd3 DC screen or memory hdc\n\tint64 originalwndproc\t! win32 control handling proc\n\tunion\n\t\tint64 menuhandle\t\t! win32 handle to any menubar\n\t\tint64 oldbmobj\t\t\t!used for bitmaps\n\tend\n\tint32 drawmode\t\t\t! see dm- drawcodes\n\tint32 updated\t\t\t\t! 1 when pixels have changed\n\n\tint32 posx,posy\t\t\t!current drawing position\n\tint32 pencolour\t\t\t! current line colour (rgb)\n\tint32 penwidth\t\t\t! current line width\n\n\tint32 penstyle\t\t\t! current line dotted style\n\n\tint32 xormode\t\t\t\t! 0=normal, 1=xor\n\tint32 brushcolour\t\t\t! current brush colour\n\tint32 brushstyle\t\t\t! current brush style (bs_solid/etc)\n\tint32 brushpattern\t\t! current brush hatch/bitmap pattern\n\n\tint32 font\t\t\t\t! current font number\nend\n\nexport enumdata marktypenames =\n\t(no_mark=0,\t\t\t$),\n\t(radio_mark,\t\t$),\n\t(tick_mark,\t\t\t$),\n\t(check_mark,\t\t$),\n\t(invert_mark,\t\t$),\n\t(outline_mark,\t\t$),\n\t(bold_mark,\t\t\t$),\nend\n\nexport enumdata hilitetypenames =\n\t(no_hilite=0,\t\t$),\n\t(invert_hilite,\t\t$),\n\t(outline_hilite,\t$),\nend\n\nexport record togglerec=\t\t!for toggle and select\n\tvar textoffset\n\tvar onvalue\nend\n\nexport record scrollbarrec=\t\t!scroll bars\n\tvar limits\t\t\t\t\t\t!range\n\tvar span\t\t\t\t\t\t!portion of limits represented by visible data (0 means not relevant)\n\tvar thumbsize\t\t\t\t\t!pixel length of thumb (vert or hoz extent along scrollbar)\n\tvar thumbspan\t\t\t\t\t!pixels that the thumb can move\n\tvar thumbpos\t\t\t\t\t!current thumb position in pixels from start of scrollbar\n\tvar currpos\t\t\t\t\t\t!current position, will be in limits range\n\tvar dragmode\t\t\t\t\t!1 if thum currently being dragged\nend\n\nexport record editboxrec=\t\t!edit boxes\n!current char position within edit text\n!if text has N characters, then position will be 1..N+1\n!The position is just /before/ the stated character\n!This matches column position within the MED text editor\n\tvar currpos\t\t\t\t\t\t!cursor position, 1 to N+1 (N=chars in edit text)\n\tvar caretpos\t\t\t\t\t!current pixel position of any caret\n\tvar textpos\t\t\t\t\t\t!start x,y pixel position of text, set by gxjust_text\nend\n\nexport record listboxrec=\n\tvar rows\t\t\t\t\t\t!number of displayed rows\n\tvar pagepos\t\t\t\t\t\t!data position corresponding to row 1 of display\n\tvar length\t\t\t\t\t\t!all data items, same as linkvar^.len\n\tvar currpos\t\t\t\t\t\t!cursor position within the data, 1 to N (can be 0 when N=0)\n\tvar pitch, offset\t\t\t\t!pixel dims of each row\nend\n\nexport record rmessage=\n\tvar\t\twind\t\t!main window/button associated with message\n\tvar\t\tmenuwind\t!top-level window owning button\n\tvar\t\tmessage\t\t!message number\n\tvar\t\tstate\t\t!button/shift key state at time of message\n\tvar\t\ta,b\t\t\t!general purpose data, depends on message\n\tvar\t\tx,y\t\t\t!current mouse position\nend\n\n!contains many different flags and style codes for assorted controls\n!But at one mostly byte each, is very low overhead (32 values is same as two vars)\n\nexport type stylerec = struct\n\tbyte\tborder\t\t\t\t!bs_ code\n\tbyte\tjustify\t\t\t\t!'L', 'R', 'C'\n\tbyte\tvjustify\t\t\t!'T', 'B', 'M'\n\tbyte\twindbgnd\t\t\t!colour index for window background\n\tbyte\ttextfgnd\t\t\t!colour index\n\tbyte\ttextbgnd\t\t\t!\n\tbyte\tbgndmode\t\t\t!\n\tbyte\ttextfont\t\t\t!font index\n\tbyte\ttextsize\t\t\t!pixel size\n\tbyte\ttextbold\t\t\t!1 if bold\n\tbyte\ttextitalic\t\t\t!1 if italic\n\tbyte\tispassword\t\t\t!1 when edit field is a password\n\tbyte\tfieldwidth\t\t\t!edit field maximum char width\n\tbyte\tdir\t\t\t\t\t!'L','R','U','D'\n\tbyte\tmarktype\t\t\t!xxx_mark style, or:\n\tbyte\thilitetype\t\t\t!xxx_hilite style\n\tbyte\tiframe\t\t\t\t!1: pos/dim include frame\n\tbyte\timark\t\t\t\t!1: pos/dim include mark for toggle/select\n\tbyte\thscroll\t\t\t\t!1: include windows-drawn hoz scroll bar\n\tbyte\tvscroll\t\t\t\t!1: include windows-drawn vert scroll bar\n\tbyte\tlbchange\t\t\t!1: return mm_change on list boxes when row has changed\n\tbyte\treturnmess\t\t\t!1: return id code when clicking toggle/select/editbox\n\tbyte\tnoupdate\t\t\t!1: don't change or allow editing on toggle/select/editbox\nend\n\nexport record rpoint = var x,y end\nexport record rrect  =\n\tvar pos,dim\nend\n\nexport record rframe =\n\tvar x1,y1,x2,y2\nend\n\nexport record getrec=\n\tfun getbounds(&self)= 0\n\tfun getitem(&self,n)= 0\n\tfun getstritem(&self,n)= \"\"\nend\n\nexport enumdata stylenames =\t! (default)\n\t(ss_border,\t\t\t$),\t\t! Border style (wbs_simple)\n\t(ss_justify,\t\t$),\t\t! 'L' 'C' 'R'\tHorizontal text justify ('L')\n\t(ss_vjustify,\t\t$),\t\t! 'T' 'M' 'B'\tVertical text justify ('M' for buttons)\n\t(ss_textfgnd,\t\t$),\t\t! Text colour index (black)\n\t(ss_textbgnd,\t\t$),\t\t! Text background colour index (if opaque mode) (0)\n\t(ss_bgndmode,\t\t$),\t\t! 0\n\t(ss_textfont,\t\t$),\t\t! Text font number (1)\n\t(ss_textsize,\t\t$),\t\t! (0)\n\t(ss_textbold,\t\t$),\t\t! (0)\n\t(ss_textitalic,\t\t$),\t\t! (0)\n\t(ss_ispassword,\t\t$),\t\t! (0)\n\t(ss_marktype,\t\t$),\t\t! Toggle/select mark style (radio_mark)\n\t(ss_hilitetype,\t\t$),\t\t! Toggle/select hilite style (no_hilite)\n\t(ss_iframe,\t\t\t$),\t\t! Whether pos and dim include frame width (also caption bar/menu for windows)\n\t(ss_windbgnd,\t\t$),\t\t! Background colour of window or button (ltgrey)\n\t(ss_imark,\t\t\t$),\t\t! Background colour of window or button (ltgrey)\n\t(ss_hscroll,\t\t$),\t\t! (0)\n\t(ss_vscroll,\t\t$),\t\t! (0)\n\t(ss_lbchange,\t\t$),\t\t! (0)\n\t(ss_returnmess,\t\t$),\t\t! (0) Toggle/select/editbox, return id when clicked\n\t(ss_noupdate,\t\t$),\t\t! (0) Toggle/select/editbox, don't change or allow edit\nend\n\nexport enumdata drawmodenames =\n\t\t\t\t\t\t\t\t!HDC\tHDC2\tRestore\n\t(dm_screen=0,\t\t$),\t\t!screen\t--\t\tCustom routine\tDraw directly to screen; no mem backup\n\t(dm_memory,\t\t\t$),\t\t!memory\t--\t\tNA\t\t\t\tDraw to memory only; no screen hdc (eg. bitmap)\n\t(dm_screenmemory,\t$),\t\t!screen\tmemory\tBlit mem->scr\tDraw to both screen and memory at same time\n\t(dm_memoryscreen,\t$),\t\t!memory\tscreen\tBlit mem->scr\tDraw to memory; update screen periodically\nend\n\n!var windowlist=nil\n\nexport enumdata wfnames =\n\t(wa_rightclick=0,\t$),\t\t!allow right click\n\t(wa_middleclick,\t$),\t\t!allow middle click\n\t(wa_leftdbl,\t\t$),\t\t!allow left double click\n\t(wa_rightdbl,\t\t$),\t\t!allow right double click\n\t(wa_middledbl,\t\t$),\t\t!allow middle double click\n\t(wa_leftdrag,\t\t$),\t\t!allow left drag\n\t(wa_rightdrag,\t\t$),\t\t!etc\n\t(wa_middledrag,\t\t$),\n\t(wa_autoupdate,\t\t$),\t\t!auto update screen for toggles/etc\n\t(wa_tab,\t\t\t$), \t!allow tab to switch to next button which has watab\n\t(wa_strvar,\t\t\t$), \t!1 for listbox linkvar to use string not index\n\t(wa_retmess,\t\t$), \t!1 for button to return .value as mess not qmcommand\n\t(wa_retsel,\t\t\t$), \t!1 for button to return .value as mess not qmcommand\n\t(wa_memory,\t\t\t$), \t!1 when hdc/hdcmem have been switched, hdc points to memory dev\n\t(wa_maximised,\t\t$),\t\t!1 when maximised, 0 when normal/minimised\n\t(wa_param1,\t\t\t$), \t!general purpose control-specific flags\n\t(wa_param2,\t\t\t$), \n\t(wa_useenter,\t\t$),\n\t(wa_closed,\t\t\t$),\t\t!whether window has been closed\n\n\t(wa_$last,\t\t\t$)\nend\n\nconst wa_needdbl\t= wa_param1\t!1 requires double-click on listbox to return wmcommand\nconst wa_editdd\t\t= wa_param2\t!1 means editable dropdown box\n\n!GX border styles, used for child windows.\n!some child windows\nexport enumdata bsnames, bscat, bswidths=\n\t(bs_none=0,\t\t$,\t0,\tws_rect(0,0,0,0)),\t\t\t!no border\n!\t(bs_windows,\t$,\t'W',\tws_rect(0,0,0,0)),\t\t\t!windows-drawn, but no own-drawn border\n\t(bs_simplew,\t$,\t'W',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line, windows drawn\n\t(bs_simple,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line\n\t(bs_thick,\t\t$,\t'X',\tws_rect(2,2,2,2)),\t\t\t!2-pixel border\n\t(bs_panel,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!raised panel, 1-pixel\n\t(bs_inset,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!inset panel, 1-pixel\n\t(bs_ownsimple,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\n\t(bs_ownpanel,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\n\t(bs_owninset,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel\n\t(bs_testext,\t$,\t'X',\tws_rect(10,10,10,10)),\n\t(bs_testint,\t$,\t'I',\tws_rect(8,8,8,8)),\n\t(bs_dummy,\t\t$,\t0,\tws_rect(0,0,0,0))\nend\n\nexport enumdata windowclassnames, defaultborderstyles =\n\t(no_class=0,\t\t$,\tbs_none),\t\t\t!Unassigned\n\t(window_class,\t\t$,\twbs_resize),\t\t!Main window\n\t(memwindow_class,\t$,\twbs_none),\t\t\t!memory backup to any window\n\t(popup_class,\t\t$,\twbs_thick),\t\t\t!Pop-up window (forms a stack)\n\t(float_class,\t\t$,\tbs_thick),\t\t\t!Independent window\n\t(bitmap_class,\t\t$,\tbs_none),\t\t\t!(image handling)\n\t(screen_class,\t\t$,\tbs_none),\t\t\t!Describes the desktop screen (not owned by my app)\n\t(printer_class,\t\t$,\tbs_none),\t\t\t!Used for printing\n\n\t(group_class,\t\t$,\tbs_inset),\t\t\t!Used mainly for grouping other buttons (eg. for Smdefblock)\n\t(panel_class,\t\t$,\tbs_inset),\t\t\t!General purpose panel for drawing in etc\n!\t(button_class,\t\t$,\tbs_panel),\t\t\t!Click button\n\t(button_class,\t\t$,\tbs_simplew),\t\t!Click button\n\t(toggle_class,\t\t$,\tbs_none),\t\t\t!Toggle button (can be composite, eg mark and label)\n\t(select_class,\t\t$,\tbs_none),\t\t\t!Select from several choices\n\t(editbox_class,\t\t$,\tbs_simplew),\t\t!Single-line edit control\n\t(scrollbar_class,\t$,\tbs_simplew),\t\t!Hoz or vert scroll bar (Some windows can also have Windows-drawn scroll bars)\n\t(listbox_class,\t\t$,\tbs_simplew),\t\t!List of options (scrollable usually)\n\t(dropdown_class,\t$,\tbs_none),\t\t\t!Button revealing attached listbox when clicked\n\t(framebar_class,\t$,\tbs_panel),\t\t\t!Left or right full-height panel used for toolboxes etc\n\t(statusbar_class,\t$,\tbs_panel),\t\t\t!Top or bottom full-width panel used for scrollbars\n\t(tooltip_class,\t\t$,\tbs_simplew),\t\t!Tooltops displayed when hovering over enabled buttons\n\t(arrow_class,\t\t$,\tbs_ownpanel),\t\t!Click button normally displaying an error in one of 4 orientations\n\t(mark_class,\t\t$,\tbs_none),\t\t\t!Toggle or select mark\n\t(label_class,\t\t$,\tbs_none),\t\t\t!Contains unclickable text usually\n\t(dummy_class,\t\t$,\tbs_none)\nend\n\nexport enumdata actionnames=\n\t(draw_w,\t\t$),\n\t(update_w,\t\t$),\n\t(last_w,\t\t$),\nend\n\n!MM Message Numbers\n\nexport enumdata messagenames=\n\n!all messages have x,y coord relative to top most window or child window\n!\n\t(mm_null=0,\t\t\t$),\t\t! empty message\n\n!window messages\n\t(mm_activate,\t\t$),\t\t! (w,a) a=1/0 activate/deactivate window\n\t(mm_close,\t\t\t$),\t\t! (w) close window (X button clicked)\n\t(mm_sizewindow,\t\t$),\t\t! (w...) resize window\n\t(mm_movewindow,\t\t$),\t\t! (w...) move window\n\t(mm_restore,\t\t$),\t\t! (w...) repaint window\n\n!cursor/focus messages\n\t(mm_setcursor,\t\t$),\t\t! (w...) update cursor type\n\t(mm_setfocus,\t\t$),\t\t! (w...) set focus to w\n\t(mm_killfocus,\t\t$),\t\t! (w...) lose focus from w\n\n!basic mouse messages (click messages can be promoted to other messages eg mm_command)\n\t(mm_move,\t\t\t$),\t\t! (w,x,y,b) mouse move, btns up/down (also drag messages when down)\n\t(mm_click,\t\t\t$),\t\t! (w,x,y) left btn click, can be promoted to mm_command etc depending on context\n\t(mm_dblclick,\t\t$),\t\t! (w,x,y) left btn dbl click, usu promoted\n\t(mm_clickup,\t\t$),\t\t! (w,x,y) left btn released\n\t(mm_rclick,\t\t\t$),\t\t! (w,x,y) right click in window, these usu. promoted\n\t(mm_rdblclick,\t\t$),\t\t! (w,x,y) right double click\n\t(mm_rclickup,\t\t$),\t\t! (w,x,y) right button released\n\t(mm_mclick,\t\t\t$),\t\t! (w,x,y) middle button versions of above\n\t(mm_mdblclick,\t\t$),\t\t! (w,x,y)\n\t(mm_mclickup,\t\t$),\t\t! (w,x,y)\n\t(mm_hover,\t\t\t$),\t\t! (w,x,y) paused over button\n\n\t(mm_onwindow,\t\t$),\t\t! (w,x,y) newly over a window\n\t(mm_offwindow,\t\t$),\t\t! (w,x,y) just came off window\n\t(mm_draw,\t\t\t$),\t\t! (w,x,y) redraw window\n\t(mm_update,\t\t\t$),\t\t! (w,x,y) update window (change of pos etc)\n\n!drag messages\n\t(mm_startdrag,\t\t$),\t\t! (w) start mouse movement with some btns down\n\t(mm_rstartdrag,\t\t$),\t\t! (w)\n\t(mm_mstartdrag,\t\t$),\t\t! (w)\n\t(mm_drag,\t\t\t$),\t\t! (w,x,y) moving mouse with buttons down (also qmmove sent)\n\t(mm_enddrag,\t\t$),\t\t! (w,x,y) all buttons up after drag\n\n!left command\n\t(mm_command,\t\t$),\t\t! (w,id) button clicked, id and sub-event given\n\t(mm_dblcommand,\t\t$),\t\t! (w,id) button double clicked\n\n!right command\n\t(mm_rcommand,\t\t$),\t\t! (w,id) right click button\n\t(mm_rdblcommand,\t$),\t\t! (w,id) right double click button\n\n!middle command\n\t(mm_mcommand,\t\t$),\t\t! (w,id)\n\t(mm_mdblcommand,\t$),\t\t! (w,id)\n\n!general key messages\n\t(mm_char,\t\t\t$),\t\t! (w,ch)\n\t(mm_key,\t\t\t$),\t\t! (w,k,shift)\n\t(mm_keyup,\t\t\t$),\t\t! (w,k,shift)\n\n!scroll/select/wheel messages\n\t(mm_sethozpos,\t\t$),\t\t! (w,pos)\t\tNew logical position set by hoz scrollbar\n\t(mm_setvertpos,\t\t$),\t\t! (w,pos)\t\tfrom vertical scrollbar\n\t(mm_select,\t\t\t$),\t\t! (w,n)\t\t\tSet nth item as current/highlighted/selected item\n\t(mm_pick,\t\t\t$),\t\t! (w,n)\t\t\tPick and return item n\n\t(mm_wheel,\t\t\t$),\t\t! (w,delta)\t\tMove log pos etc but depends on context\n\t(mm_lbchange,\t\t$),\t\t! (w,n)\t\t\tA listbox position has changed\n\n!misc messages\n\t(mm_timer,\t\t\t$),\t\t! (w)\n\n!high level window messages\n\t(mm_cancel,\t\t\t$),\t\t! (w)\n\t(mm_ok,\t\t\t\t$),\t\t! (w)\n\t(mm_help,\t\t\t$),\t\t! (w,id)\n\t(mm_cmdline,\t\t$),\t\t! (w,s)\n\n!specific key messages\n\t(mm_leftkey ,\t\t$),\t\t! (w,shift)\n\t(mm_rightkey,\t\t$),\t\t! (w,shift)\n\t(mm_upkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_downkey,\t\t$),\t\t! (w,shift)\n\t(mm_pageupkey,\t\t$),\t\t! (w,shift)\n\t(mm_pagedownkey,\t$),\t\t! (w,shift)\n\t(mm_homekey,\t\t$),\t\t! (w,shift)\n\t(mm_endkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_tabkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_bskey,\t\t\t$),\t\t! (w,shift)\n\t(mm_deletekey,\t\t$),\t\t! (w,shift)\n\t(mm_enterkey,\t\t$),\t\t! (w,shift)\n\t(mm_insertkey,\t\t$),\t\t! (w,shift)\n\t(mm_functionkey,\t$),\t\t! (w,shift)\n\n!Other messages for controls, mainly for attached arrow buttons\n\t(mm_up,\t\t\t\t$),\t\t! (w,id) Arrow up/etc\n\t(mm_down,\t\t\t$),\t\t! (w,id)\n\t(mm_right,\t\t\t$),\t\t! (w,id)\n\t(mm_left,\t\t\t$),\t\t! (w,id)\n\t(mm_edit,\t\t\t$),\t\t! (w,id)\tUpdate of edit box\n\t(mm_edited,\t\t\t$),\t\t! (w,id)\tFinished edit box entry (tab etc)\n\t(mm_last,\t\t\t$)\nend\n\n!export const mm_scroll\t= mm_hscroll\t!general scroll independent of orientation\n\n!!other messages wmuser+ are user assigned, usually applied as\n!ids to controls. Depending on the options to Waitmess(), a wm_commmand message\n!is coverted to a direct message number. So (wm_command, 230) is covered to\n!message 230. So message ids have to start from 200 so that they occupy a different\n!number space from normal message codes.\nexport const mm_user\t= 200\n\nexport const kb_lbutton\t= 0x1\t!used in buttonstate\nexport const kb_rbutton\t= 0x2\nexport const kb_mbutton\t= 0x4\n\nexport const kb_shift\t= 0x8\t!used in shiftstate\nexport const kb_ctrl\t= 0x10\nexport const kb_alt\t\t= 0x20\nexport const kb_capslock\t= 0x40\nexport const kb_dblclick\t= 0x80\t!used for some messages that don't have dblclick versions,\n\nexport const kb_rshift\t= 0x100\nexport const kb_rctrl\t= 0x200\nexport const kb_ralt\t= 0x400\n\nexport enumdata colournames, colourvalues =\n!\t\t\t\t\t   BB'GG'RR\n\t(black,\t\t$,\t0x_00'00'00),\n\t(red,\t\t$,\t0x_00'00'C0),\n\t(dkred,\t\t$,\t0x_00'00'90),\n\t(red3,\t\t$,\t0x_00'00'70),\n\t(green,\t\t$,\t0x_00'C0'00),\n\t(dkgreen,\t$,\t0x_00'90'00),\n\t(green3,\t$,\t0x_00'70'00),\n\t\n\t(blue,\t\t$,\t0x_C0'00'00),\n\t(dkblue,\t$,\t0x_90'00'00),\n\t(blue3,\t\t$,\t0x_70'00'00),\n\n\t(cyan,\t\t$,\t0x_c0'c0'00),\n\t(dkcyan,\t$,\t0x_90'90'00),\n\t(cyan3,\t\t$,\t0x_70'70'00),\n\n\t(magenta,\t$,\t0x_c0'00'c0),\n\t(dkmagenta,\t$,\t0x_90'00'90),\n\t(magenta3,\t$,\t0x_70'00'70),\n\n\t(yellow,\t$,\t0x_00'C0'C0),\n\t(dkyellow,\t$,\t0x_00'90'90),\n\t(yellow3,\t$,\t0x_00'70'70),\n\t(yellow4,\t$,\t0x_00'50'50),\n\n\t(white,\t\t$,\t0x_FF'FF'FF),\n\t(ltgrey,\t$,\t0x_C0'C0'C0),\n\t(grey,\t\t$,\t0x_90'90'90),\n\t(dkgrey,\t$,\t0x_70'70'70),\n\n\t(ltorange,\t$,\t0x_00'A0'FF),\n\t(orange,\t$,\t0x_00'60'FF),\n\t(flesh,\t\t$,\t0x_70'85'EE),\n\t(pink,\t\t$,\t0x_9A'32'DB),\n\t(dkpink,\t$,\t0x_72'24'A9),\n\t(brown,\t\t$,\t0x_46'43'7D),\n\t(blue4,\t\t$,\t0x_B7'1C'5E),\n\t(blue5,\t\t$,\t0x_6F'3D'0D),\n\t(olive,\t\t$,\t0x_05'A0'88),\n\t(ltbrown,\t$,\t0x_00'70'B0),\n\n\t(blue6,\t\t$,\t0x_9C'63'1C),\n\t(green4,\t$,\t0x_12'51'11),\n\t(purple,\t$,\t0x_5E'0D'73),\n\t(blue7,\t\t$,\t0x_E6'27'1C),\n\t(crimson,\t$,\t0x_15'2A'D3),\n\t(violet,\t$,\t0x_54'16'A0),\n\t(blue8,\t\t$,\t0x_86'68'1E),\n\t(dkorange,\t$,\t0x_25'6A'D4),\n\t(green5,\t$,\t0x_09'46'41),\n\t(blue9,\t\t$,\t0x_65'0A'1D),\n\n\t(ltred,\t\t$,\t0x_00'00'FF),\n\t(ltgreen,\t$,\t0x_00'FF'00),\n\t(ltblue,\t$,\t0x_FF'00'00),\n\t(ltcyan,\t$,\t0x_FF'FF'00),\n\t(ltmagenta,\t$,\t0x_FF'00'FF),\n\t(ltyellow,\t$,\t0x_00'FF'FF),\n\n!The following are the Windows system colours, set up as indices\n!Init needs need to retrieve the values and set up the rgb values in this table\n\t(button_col,\t$,\t0),\t\t!button colour\n\t(window_col,\t$,\t0),\t\t!window colour\n\t(text_col,\t\t$,\t0),\t\t!text in windows\nend\n\nexport const skipmess = 1\t\t!message has been processed; caller must wait for another message\nexport const thismess = 0\t\t!caller should deal with this message (it has not been processed, or has been but caller can process it too)\n\nexport var bmbgnd\nexport var defstyle\t\t\t!set initdata\nexport var currmess\n\nexport var wapplic=nil\nexport var wscreen=nil\n\nvar data,ndata\nvar tabstack,ntab\nvar breakflag\n\nconst k_menu=30000\nconst kdivide=30001\nconst kcolumn=30002\nconst kfilehistory=30003\n\nvar caretdrawn=0\nvar dkcolour=0x000000\nvar ltcolour=0xFFFFFF\nvar thumbdragmode=0\nvar thumbstartpos=0\n\nvar dirtomess=['L':mm_left,'R':mm_right,'U':mm_up,'D':mm_down]\n\nproc start=\n!CPL \"GXLIB START\"\n\ninitdata()\nmxinit()\ninitmenuhandlers()\nend\n\nexport proc setupgdi(w,hwnd)=\t\t\t!SETUPGDI\n!NOTE: rare care of a func within a data header. This is to allow bitmap module\n!to be higher up the hierarchy than gx, but still let it use some gx functions.\n\n!set up the default gdi descriptor for window w\n\nif w.gdi then\n\treturn\t\t\t!assume already done\nfi\n\ngdi:=new(rgdistate)\ngdi.hwnd:=hwnd\n\n!start with default drawmodes of dm_screen, or dm_memory for bitmaps\n!These can be converted later using gxdrawmode\n\nif w.usertype=rwindow then\n\tgdi.hdc:=getdc(hwnd)\n\tgdi.drawmode:=dm_screen\nelse\t\t\t\t\t\t!assume bitmap\n\tgdi.hdc:=createcompatibledc(nil)\n\tgdi.drawmode:=dm_memory\nfi\n\ngdi.posx:=gdi.posy:=0\ngdi.updated:=0\ngdi.font:=0\ngdi.pencolour:=getsyscolour(colour_windowtext)\ngdi.penwidth:=0\ngdi.penstyle:=ps_solid\ngdi.xormode:=0\ngdi.brushcolour:=0xff'ff'ff\ngdi.brushstyle:=bs_solid\ngdi.brushpattern:=0\nw.gdi:=gdi\nend\n\nexport const arleft = \"<\"\nexport const arright = \">\"\nexport const arup = \"^\"\nexport const ardown = \"V\"\n\nexport var allwindows::=()\t\t\t!list of all windows and controls\n\nexport func ctrlpressed = return (currmess.state iand kb_ctrl) end\nexport func shiftpressed = return (currmess.state iand kb_shift) end\n\nproc initdata=\nmessagequeue:=new(list,100)\nnmessages:=0\n\ncolourvalues::=colourvalues\n\ncolourvalues[button_col]:=getsyscolour(colour_btnface)\n\ncolourvalues[window_col]:=getsyscolour(colour_window)\ncolourvalues[text_col]:=getsyscolour(colour_windowtext)\n\ndefstyle:=new(stylerec)\ndefstyle.border\t\t:= bs_simplew\ndefstyle.justify\t:= 'L'\ndefstyle.vjustify\t:= 'M'\ndefstyle.textfgnd\t:= black\ndefstyle.marktype\t:= check_mark\ndefstyle.hilitetype\t:= no_hilite\ndefstyle.windbgnd\t:= button_col\ndefstyle.imark\t\t:= 1\n!defstyle.windbgnd\t:= window_col\n\ninit_handlertables()\nd:=gxchardim(labelfont)\nchx:=d.x\nchy:=d.y\n\nd:=gxchardim(0,1)\ncha:=d.x\nchd:=d.y\narrowdim:=chy+2\nmarkdim:=arrowdim-2\n\nbuttonheight:=chy+smy*2\nlistrowheight:=chy+smy*2\nend\n\nexport func gxcreatewindow(?caption,?pos,?dim,?options,owner=nil)=\t\t!CREATEWINDOW\n#create a popup window which is not a child window.\n#(nevertheless, it can have an owner window, such as the main window of the\n#application)\n#returns an rwindow handle\n#caption\toptional caption txt\n#pos\t\t(x,y) is pixel pos of top left corner in screen coordinates (of frame?)\n#\t\t\"cent\" to place centrally\n#\t\tomitted: use default placement\n#dim\t\t(width,height) overall pixel size\n#\t\t\"max\" maximised\n#\t\t\"desktop\" fill desktop screen\n#\t\tomitted: use (640,480)\n#owner\toptional owner window (default nil)\n#options\toption dict, default is [wf_caption:1, wf_border:wbs_resize]\n\nhwnd:=wx_createpopup(caption,pos,dim,options,(owner|owner.gdi.hwnd|nil))\n!CPL \"CW2\"\n\nw:=newwindow(hwnd,0,no_class,bs_windows)\n\nif wapplic=nil then\n\twapplic:=w\nfi\n\nW.STYLE:=NEW(STYLEREC)\nW.STYLE.BORDER:=0\nW.WINDCLASS:=WINDOW_CLASS\nW.STYLE.WINDBGND:=WINDOW_COL\nW.ENABLE:=1\nW.FLAGS.[WA_LEFTDRAG]:=1\nW.FLAGS.[WA_LEFTDBL]:=1\n\nsetwindowdims_w(w,hwnd)\n\nsetupgdi(w,hwnd)\ngxfont(w,1)\n\nGXDRAWMODE(W,DM_SCREENMEMORY)\nGXCLEAR(W)\n\nreturn w\nend\n\nproc setwindowdims_w(w,hwnd)=\t\t\t!SETWINDOWDIMS\n!use windows functions to set up client and frame pos and dims of top-level window\n\nbox:=new(ws_rect)\ngetwindowrect(hwnd,&box)\nw.frameposx:=box.x\nw.frameposy:=box.y\nw.framedimx:=box.x2-box.x\nw.framedimy:=box.y2-box.y\n\ngetclientrect(hwnd,&box)\n\nw.dimx:=box.x2-box.x\nw.dimy:=box.y2-box.y\n\npt:=ws_point(0,0)\nclienttoscreen(hwnd,&pt)\t\t!pos starts at 0,0\nw.posx:=pt.x\nw.posy:=pt.y\nend\n\nproc setwindowdims_c(w,hwnd)=\t\t\t!SETWINDOWDIMS\n!use windows functions to set up client and frame pos and dims of child window\n\n\nbox:=new(ws_rect)\ngetwindowrect(hwnd,&box)\t\t\t!client dims also Windows frame dims as has no Windows border\nw.posx:=box.x-w.owner.posx\nw.posy:=box.y-w.owner.posy\nw.dimx:=box.x2-box.x\nw.dimy:=box.y2-box.y\n\nwidths:=bswidths[w.style.border]\nif bscat[w.style.border]='I' then widths:=ws_rect(0,0,0,0) fi\n\nw.frameposx:=w.posx-widths.x1\nw.frameposy:=w.posy-widths.y1\nw.framedimx:=w.dimx+widths.x1+widths.x2\nw.framedimy:=w.dimy+widths.y1+widths.y2\nend\n\nexport proc gxclear(w,?colour)=\t\t\t!GXCLEAR\n#fill window w with <colour>, or with current background if omitted\n\n!RETURN\ngdi:=w.gdi\ngdi.updated:=1\n\ngxcolour(w,getrgb(black))\ngxstyle(w,0)\n\nif colour.isvoid then\n\tcolour:=getrgb(w.style.windbgnd)\nfi\n\noldpenstyle:=gdi.penstyle\noldbrushstyle:=gdi.brushstyle\n\ngxbrushstyle(w,bs_solid)\ngxstyle(w,ps_null)\n\ngxfillrect(w,0,0,w.dimx,w.dimy,colour)\ngxbrushstyle(w,oldbrushstyle)\ngxstyle(w,oldpenstyle)\nend\n\nexport func gxstyle(w,?style)=\t\t\t!GXSTYLE\n#style omitted: get pen current pen style\n#style supplied: set pen style for subsequent line drawing\n#Style is a char code or int refering to a small variety of Windows dotted styles:\n#\t0 S |\t\tSolid\n#\tSpace\t\tNull (pen up?)\n#\t-\t\t\tDotted\n#\t:\t\t\tDashdotdot\n#\t!\t\t\tDashdotd\n#\tF\t\t\tInside frame\n\ngdi:=w.gdi\n\nif style.isdef and gdi.penstyle<>style then\n\tcase style\n\twhen '!' then style:=ps_dashdot\n\twhen ':' then style:=ps_dashdotdot\n\twhen '-' then style:=ps_dot\n\twhen ' ' then style:=ps_null\n\twhen 'D' then style:=ps_alternate\n\twhen '|','S',0 then style:=ps_solid\n\twhen 'F' then style:=ps_insideframe\n\tesac\n\n\tgdi.penstyle:=style\n\tif style>=10 then style:=ps_dot fi\n\tdeleteobject(selectobject(gdi.hdc,createpen(style,gdi.penwidth,gdi.pencolour)))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(style,gdi.penwidth,gdi.pencolour)))\n\tfi\nfi\nreturn gdi.penstyle\nend\n\nexport proc gxbrushstyle(w,?style,?pattern)=\t\t!GXBRUSHSTYLE\n#Set Windows brush style and pattern\n#Style supplied:\tset style\n#pattern supplied:\tset style\n#style is:\t\tS, H, Space, B for Solid, Hatched, Null, DIB\n#pattern is:\t- | \\ / + x/X for Hoz, Vert, Diag, Fwd Diag, Cross, Diag Cross\n\ngdi:=w.gdi\nbrush:=new(ws_logbrush)\n\nif style.isdef then\n\tif style<>gdi.brushstyle then\n\t\tcase style\n\t\twhen 'S' then style:=bs_solid\n\t\twhen 'H' then style:=bs_hatched\n\t\twhen ' ' then style:=bs_null\n\t\twhen 'B' then style:=bs_dibpattern\n\t\tesac\n\n\t\tgdi.brushstyle:=style\n\tfi\n\tgdi.brushpattern:=0\t\t!default to no pattern, will be changed by pattern if supplied\nfi\n\nif pattern.isdef and pattern<>gdi.brushpattern then\n\tcase pattern\n\twhen '-' then pattern:=hs_horizontal\n\twhen '|' then pattern:=hs_vertical\n\twhen '\\\\' then pattern:=hs_fdiagonal\n\twhen '/' then pattern:=hs_bdiagonal\n\twhen '+' then pattern:=hs_cross\n\twhen 'x','X' then pattern:=hs_diagcross\n\tesac\n\tgdi.brushpattern:=pattern\nfi\n\nbrush.lbstyle:=gdi.brushstyle\nbrush.lbcolour:=gdi.brushcolour\nbrush.lbhatch:=gdi.brushpattern\n\ndeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\nif gdi.drawmode=dm_screenmemory then\n\tdeleteobject(x:=selectobject(gdi.hdc2,createbrushindirect(&brush)))\nfi\nend\n\nexport func gxbrushcolour(w,?colour)=\t\t\t!GXBRUSHCOLOUR\n#colour supplied:\tset current fill colour\n#colour omitted:\treturn current fill colour\n\ngdi:=w.gdi\n\nif colour.isdef and colour<>gdi.brushcolour then\n\tgdi.brushcolour:=colour\n\tbrush:=new(ws_logbrush)\n\tbrush.lbstyle:=gdi.brushstyle\n\tbrush.lbcolour:=colour\n\tbrush.lbhatch:=gdi.brushpattern\n\n\tdeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(selectobject(gdi.hdc2,createbrushindirect(&brush)))\n\tfi\nfi\nreturn gdi.brushcolour\nend\n\nexport proc gxfillrect(w,x,y,width,height,?colour,mode=0)=\t\t!GXFILLRECT\n#Draw filled rectangle with optional outline\n#x,y are top-left coordinates\n#width, height are overall pixel dimensions, inclusive; they include any outline\n#(When the outline is drawn, the filled region is 1 pixel smaller all round)\n#colour is the colour of the filled region (current brush colour when omitted)\n#mode=1 to draw the outline, or mode=0 (default) to omit it\n#The outline is drawn in the current pen colour\n\ngdi:=w.gdi\ngdi.updated:=1\n\noldbrushcolour:=gdi.brushcolour\nif colour.isdef then\n\tgxbrushcolour(w,colour)\nfi\n\noldpenstyle:=gdi.penstyle\nif mode=0 then\t\t!inside only\n\tgxstyle(w,ps_null)\nfi\n\nif height<0 then y:=y+height+1; height:=-height fi\nif width<0 then x:=x+width+1; width:=-width fi\n\nif mode=0 then\t\t!inside only, needs extra pixel width\n\trectangle(gdi.hdc,x, y,x+width+1,y+height+1)\n\tif gdi.drawmode=dm_screenmemory then\n\t\trectangle(gdi.hdc2,x,y,x+width+1,y+height+1)\n\tfi\nelse\t\t\t!inside and outside\n\trectangle(gdi.hdc,x, y, x+width, y+height)\n\tif gdi.drawmode=dm_screenmemory then\n\t\trectangle(gdi.hdc2,x,y,x+width,y+height)\n\tfi\nfi\ngxstyle(w,oldpenstyle)\ngxbrushcolour(w,oldbrushcolour)\nend\n\nexport func gxcolour(w,?colour)=\t\t!GXCOLOUR\n# colour supplied:\tset current outline colour for subsequent line drawing\n# colour omitted:\treturn current outline colour\n\ngdi:=w.gdi\n\nif colour.isdef and gdi.pencolour<>colour then\n\tgdi.pencolour:=colour\n\tgdi.xormode:=0\n\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\tsetrop2(gdi.hdc,r2_copypen)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\tsetrop2(gdi.hdc2,r2_copypen)\n\tfi\n\nfi\n\nreturn gdi.pencolour\nend\n\nexport proc gxsetpen(w,pen)=\ngxcolour(w,getrgb(pen))\nend\n\nexport proc gxline(w,x,y,?x2,?y2)=\t\t!GXLINE\n#gxline(w,x,y)\t\t\tDraw line from current position to x,y\n#gxline(w,x,y,x2,y2)\tDraw line from x,y to x2,y2\n\ngdi:=w.gdi\n\nif x2.isvoid then\t\t!assume 2 params\n\tx2:=x\n\ty2:=y\n\n\tmovetoex(gdi.hdc,gdi.posx, gdi.posy)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\n\tfi\nelse\n\tmovetoex(gdi.hdc,x, y)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2,x, y)\n\tfi\n\tgdi.posx:=x\n\tgdi.posy:=y\nfi\n\nlineto(gdi.hdc,x2,y2)\n\nif gdi.drawmode=dm_screenmemory then\n\tlineto(gdi.hdc2,x2,y2)\nfi\ngdi.posx:=x2\ngdi.posy:=y2\nend\n\nexport func gxwidth(w,width)=\n!get/set pen width for subsequent line drawing\ngdi:=w.gdi\nif width.isvoid then\n\treturn gdi.penwidth\nfi\n\nif gdi.penwidth<>width then\n\tgdi.penwidth:=width\n\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\tfi\n\nfi\nreturn width\nEND\n\nexport proc gxlinerel(w,dx,dy)=\t\t!GXLINEREL\n#Draw line from current position, to current position + (dx,dy)\n\ngdi:=w.gdi\nmovetoex(gdi.hdc, gdi.posx, gdi.posy)\nif gdi.drawmode=dm_screenmemory then\n\tmovetoex(gdi.hdc2, gdi.posx, gdi.posy)\nfi\nx:=gdi.posx+dx\ny:=gdi.posy+dy\ngxline(w,x,y)\ngdi.posx:=x\ngdi.posy:=y\nend\n\nexport proc gxmove(w,x2,y2)=\t\t!GXMOVE\n#Set current position to x2,y2\n\ngdi:=w.gdi\n\nmovetoex(gdi.hdc, x2, y2)\nif gdi.drawmode=dm_screenmemory then\n\tmovetoex(gdi.hdc2,x2, y2)\nfi\ngdi.posx:=x2\ngdi.posy:=y2\nend\n\nexport proc gxmoverel(w,dx,dy)=\t\t!GXMOVEREL\n#\tSet current position to current position+(dx,dy)\ngdi:=w.gdi\n\ngdi.posx+:=dx\ngdi.posy+:=dy\n\nmovetoex(gdi.hdc,gdi.posx, gdi.posy)\nif gdi.drawmode=dm_screenmemory then\n\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\nfi\nend\n\nexport proc gxrect(w,x,y,width,height)=\t\t!GXRECT\n#draw outline rectangle starting from x,y at top left, in current pen colour\n#overall size is width by height pixels inclusive (x,y to x+width+1,y+height-1)\n#outline is 1 pixel wide\n\ngdi:=w.gdi\ngdi.updated:=1\nif height<0 then y:=y+height+1; height:=-height fi\nif width<0 then x:=x+width+1; width:=-width fi\n\noldbrushstyle:=gdi.brushstyle\ngxbrushstyle(w,bs_hollow)\n\nrectangle(gdi.hdc,x, y, x+width, y+height)\nif gdi.drawmode=dm_screenmemory then\n\trectangle(gdi.hdc2,x, y, x+width,y+height)\nfi\ngxbrushstyle(w,oldbrushstyle)\nend\n\nexport proc gxcircle(w,x,y,r)=\t\t!GXCIRCLE\n#draw circle at centre x,y in window w, of radius r, using current pen colour\n#outline is 1 pixel wide\n\ngdi:=w.gdi\ngdi.updated:=1\noldbrushstyle:=gdi.brushstyle\ngxbrushstyle(w,bs_hollow)\n\nellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\nif gdi.drawmode=dm_screenmemory then\n\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\nfi\ngxbrushstyle(w,oldbrushstyle)\nend\n\nexport proc gxfillcircle(w,x,y,r,?colour,mode=0)=\t\t!GXFILLCIRCLE\n#Draw filled circle with optional outline\n#x,y is the centre, r is the radius\n#(When the outline is drawn, the filled region is 1 pixel smaller all round)\n#colour is the colour of the filled region (current brush colour when omitted)\n#mode=1 to draw the outline, or mode=0 (default) to omit it\n#The outline is drawn in the current pen colour\ngdi:=w.gdi\n\ngdi.updated:=1\noldbrushcolour:=gdi.brushcolour\nif colour.isdef then\n\tgxbrushcolour(w,colour)\nfi\n\noldpenstyle:=gdi.penstyle\nif mode=0 then\t\t!inside only\n\tgxstyle(w,ps_null)\nfi\n\nellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\nif gdi.drawmode=dm_screenmemory then\n\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\nfi\n\ngxstyle(w,oldpenstyle)\ngxbrushcolour(w,oldbrushcolour)\nend\n\nexport func gxpixel(w,x,y,?colour)=\t\t!GXPIXEL\n#colour provided: set pixel at point x,y of window w to colour\n#colour omitted: return pixel colour from point x,y\n!set pixel at x,y with given rgb colour, or return pixel value if omitted (-1)\nw.gdi.updated:=1\n\nif colour.isvoid then\t\t!get pixel\n\tres:=getpixel(w.gdi.hdc, x, y)\n\tif w.gdi.drawmode=dm_screenmemory then\n\t\tgetpixel(w.gdi.hdc2, x, y)\n\tfi\n\treturn res\nelse\n\tsetpixel(w.gdi.hdc,x, y, colour)\n\tif w.gdi.drawmode=dm_screenmemory then\n\t\tsetpixel(w.gdi.hdc2,x,y,colour)\n\tfi\n\treturn colour\nfi\nend\n\nexport func gxcaption(w,?caption)=\t\t!GXCAPTION\n#caption omitted:  return current window caption text\n#caption provided: set new window caption text\n\ncase w.windclass\nwhen window_class,popup_class then\n\n\tif caption.isdef then\t\t!set text\n\t\tsetwindowtext(w.gdi.hwnd,caption)\n\t\treturn caption\n\telse\n\t\tbuffer:=new(array,byte,512)\n\t\tn:=getwindowtext(w.gdi.hwnd,int(&buffer),buffer.len)\n\t\tif n then\n\t\t\ts:=makestr(&buffer,n)\t\t!needs assigment to ensure a copy is made befor buffer\n\t\t\t\t\t\t\t\t\t\t!is freed (assignment of return value might do the same)\n\t\telse\n\t\t\ts:=\"\"\n\t\tfi\n\t\treturn s\n\tfi\nesac\n\nif caption.isdef then\t\t!set text\n\tw.text:=caption\n\tgxdraw(w)\nfi\n\nreturn w.text\nend\n\nexport proc gxtext(w,s,?x,?y)=\t\t!GXTEXT\n#Display text s\n#Text is drawn starting at (x,y) when provided, otherwise at current position\n#insertion point refers either to base line, or to top left of cell (not sure)\n#Text is drawn in current font, size, style and mode\n#Text typically contains no control codes, but can also contain cr and lf (also\n#tabs, but currently position isn't changed). However, text with control codes is\n#drawn a character at a time\n#Finishes with current position set to the end of the text\n\n!uses chr(16) for reverse tab. Reverse tabs are usually encoded as:\n!  chr(9)+chr(16), ie. normal tab then reverse tab\n!Reverse tab, after tabbing to next stop, then moves position back by width\n!of next substring\n\nreturn when s=\"\"\n\ngdi:=w.gdi\n\nif x.isvoid then x:=gdi.posx fi\nif y.isvoid then y:=gdi.posy fi\ngdi.updated:=1\n\n!scan the string and create a table of substrings and control codes\nstartpos::=lengths::=()\nngroups:=0\n\nforeach i,c in s do\n\tif c<32 then\n\t\t++ngroups\n\t\tstartpos[ngroups]:=i\n\t\tlengths[ngroups]:=0\n\telse\n\t\tif ngroups and lengths[ngroups] then\t\t!extend this group\n\t\t\t++lengths[ngroups]\n\t\telse\t\t\t\t\t\t\t\t\t\t!start new substring group\n\t\t\t++ngroups\n\t\t\tstartpos[ngroups]:=i\n\t\t\tlengths[ngroups]:=1\n\t\tfi\n\tfi\nod\n\nfor i,l in lengths do\n\tpos:=startpos[i]\n\tif l then\n\t\tslicex:=pos..pos+l-1\n\t\ttextout(gdi.hdc,x, y,s.[slicex],l)\n\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\ttextout(gdi.hdc2,x,y,s.[slicex],l)\n\t\tfi\n\t\tx +:= gxtextwidth(w,s.[slicex])\n\n\telse\t\t\t\t!Deal with control codes\n\t\tcase s.[pos]\n\t\twhen 13 then\n\t\t\tx:=0\n\t\twhen 10 then\n\t\t\ty+:=20\t\t\t\t!NEEDS TO PICK CURRENT FONT DIMS\n\n\t\twhen 9,16 then\t\t\t!16 will be used as reverse tab\n\t\t\tcurrx:=x\n\t\t\tx:=0\n\t\t\tfor t in tabstops do\n\t\t\t\tx+:=t*chx\t\t\t\t!MUST BE CURRENT FONT NOT CHX\n\t\t\t\tif x>currx then exit fi\n\t\t\tod\n\t\t\twhile x<=currx do x+:=chx*8 od\n\n\t\t\tif s.[pos]=16 and i<ngroups and lengths[i+1] then\t!reverse offset for next substring\n\t\t\t\tpos:=startpos[i+1]\n\t\t\t\tx -:= gxtextwidth(w,s.[pos..pos+lengths[i+1]-1])+1\n\t\t\tfi\n\n\t\tesac\t\n\tfi\nod\n\ngdi.posx:=x\ngdi.posy:=y\nend\n\nexport func gxtextcolour(w,?colour,?bgndcolour)=\t\t!GXTEXTCOLOUR\n#Set either text foreground colour or background colour, or both, or neither,\n#depending on which are supplied\n#Text colours will be colour indices, not rgb\n#Always returned current or new foreground\n\ngdi:=w.gdi\n\nif colour.isdef and colour<>w.style.textfgnd then\n\tw.style.textfgnd:=colour\n\tsettextcolour(gdi.hdc,getrgb(colour))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tsettextcolour(gdi.hdc2,getrgb(colour))\n\tfi\nfi\nif bgndcolour.isdef and bgndcolour<>w.style.textbgnd then\n\tgxbgndcolour(w,bgndcolour)\nfi\n\nreturn w.style.textfgnd\nend\n\nexport func gxtextwidth(font,?s)=\t\t!GXTEXTWIDTH\n# font is a window, or a font number within fonttable\n# font can be zero (then uses font 1)\n# return total pixel width of string s, using given font\n\nif s=\"\" then return 0 fi\n\n!if not font.isint then\t\t\t!aasume font is window\n!CPL =FONT\n!CPL =FONT.TYPE\n\n\n!if not font.ispointer then\t\t\t!aasume font is window\nif not font.isint then\t\t\t!aasume font is window\n\tfont:=font.gdi.font\nfi\nif font=0 then font:=1 fi\n\nselectobject(screendc,fonttable[font])\nwidthheight:=new(ws_point)\n\n!CPL =S\n\ngettextextentpoint32(screendc,s,s.len,&widthheight)\n\nreturn widthheight.x\nend\n\nexport func gxloadfont(n,facename,?style,height=0,width=0)=\t\t!GXLOADFONT\n#define new font\n#N is index into fonttable\n#facename is the name of the font\n#Style is optional font style, a string containing any of:\n#\tB,b\t\tBold\n#\tI,i\t\tItalic\n#\tU,u\t\tUnderline\n#\tS,s\t\tStrikeout\n#Height is height of text (default 0, gives default height?)\n#Weight is width; defautl 0 normally used for normal aspect of text\n\nCPL \"GXLOADFONT\"\n\nif n<=0 then return 0 fi\n!n:=min(n,nglobalfonts)\n\nif style.isvoid then style:=\"\" fi\n\nif n<=nglobalfonts and fonttable[n] then\t\t\t!remove existing font\n\tigxremovefont(n)\nfi\n\np:=style\nbold:=400\nitalic:=0\nunderline:=0\nstrikeout:=0\nfor c in style do\n\tcase asc(convuc(c))\n\twhen 'B' then bold:=700\n\twhen 'I' then italic:=1\n\twhen 'U' then underline:=1\n\twhen 'S' then strikeout:=1\n\tesac\nod\n\nhfont:=createfont(\n\tfacename:\tfacename,\n\theight:\t\theight,\n\twidth:\t\twidth,\n\tbold:\t\tbold,\n\titalic:\t\titalic,\n\tunderline:\tunderline,\n\tcharset:\t0,\n\tquality:\t2,\n\tescapement:\t0,\n\torientation:0)\n\nif hfont=0 then\n\thfont:=getstockobject(system_font)\nfi\n\nfonttable[n]:=hfont\nnglobalfonts:=max(n,nglobalfonts)\n\nselectobject(screendc,fonttable[n])\n\ntm:=new(ws_textmetrics)\n\ngettextmetrics(screendc,&tm)\n\nfontdimtable[n]::=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\nfontvdimtable[n]::=ws_point(tm.ascent, tm.descent)\n\nselectobject(screendc,getstockobject(system_font))\n\nreturn n\nend\n\nproc igxremovefont(n)=\n!unload font n, free table entry\n\nunless n in 1..nglobalfonts then return end\nif fonttable[n]=0 then return fi\t!already freed\n\n!w:=windowlist\n!while w<>nil do\n!\tif w.gdi.hdc and w.gdi.font>0 then\t\t!font was in use, set as undefined\n!\t\tw.gdi.font:=1\n!\t\tselectobject(w.gdi.hdc,fonttable[w.gdi.font])\n!\t\tif w.gdi.hdc2 then\n!\t\t\tselectobject(w.gdi.hdc2,fonttable[w.gdi.font])\n!\t\tfi\n!\tfi\n!\tw:=w.nextwind\n!od\n\ndeleteobject(fonttable[n])\t\t!get rid of this font\nfonttable[n]:=0\nend\n\nexport func gxfont(w,font=1)=\t\t!GXFONT\n# select font from font table for subsequent text display; default is font 1\n\nif not w then w:=wapplic fi\nif not w then w:=wscreen fi\ngdi:=w.gdi\n\nif font.isdef and font<>gdi.font then\n\tif font not in 1..nglobalfonts then\n\t\tabort(\"Bad font number \"+tostr(font))\n\tfi\n\tgdi.font:=font\n\tif fonttable[font]=0 then\n\t\tabort(\"Font not in use \"+tostr(font))\n\tfi\n\n\toldhfont:=selectobject(gdi.hdc,fonttable[font])\n\tsendmessage(gdi.hwnd,wm_setfont,fonttable[font],0)\n\n\tif gdi.drawmode=dm_screenmemory then\n\t\toldhfont:=selectobject(gdi.hdc2,fonttable[font])\n\t\tsendmessage(gdi.hwnd2,wm_setfont,fonttable[font],0)\n\tfi\n\tif fontdimtable[font].x=0 then\t\t!set up dims\n\t\tgxchardim(font,0)\n\tfi\nfi\nreturn gdi.font\nend\n\nfunc hascontrolchars(s)=\t\t!TESTCTRLCHAR\n!scan string s looking for control chars\n!return 1 if control chars (<20H) are present\n\nforeach c in s do\n\tif c<32 then return 1 fi\nod\nreturn 0\nend\n\nexport func gxchardim(font,vert=0)=\t\t\t!GXCHARDIM\n#return font char average width/height info as a point rec\n#wfont is a font number, or hwindow when the current font in that window is used\n#vert=1 means get ascent/descent pair instead of (vert=0) average width/height\n\nif not font.isint then\n\tfont:=font.gdi.font\nfi\nif font=0 then font:=1 fi\n\n!CPL =FONTDIMTABLE,=FONT\n\nif fontdimtable[font].x=0 then\t\t!probably stock fonts not setup with gxloadfont\n\tselectobject(screendc,fonttable[font])\n\ttm:=new(ws_textmetrics)\n\tgettextmetrics(screendc,&tm)\n\n\tfontdimtable[font]::=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\n\n\tfontvdimtable[font]::=ws_point(tm.ascent, fontvdimtable[font].y:=tm.descent)\n\n\tselectobject(screendc,getstockobject(ansi_var_font))\nfi\n\nif vert then\n\treturn fontvdimtable[font]\nfi\n\nreturn fontdimtable[font]\nEND\n\nexport func gxbgndcolour(w,?colour)=\t\t!GXBGNDCOLOUR\n#Set background colour (for text mainly)\n#colour will be a colour index\n#return current colour when omitted\ngdi:=w.gdi\n\nif colour.isdef then\n\n\tif colour<>w.style.textbgnd then\n\t\tw.style.textbgnd:=colour\n\t\tsetbkcolour(gdi.hdc,getrgb(colour))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tsetbkcolour(gdi.hdc2,getrgb(colour))\n\t\tfi\n\tfi\n\tgxbgndmode(w,(colour<>w.style.windbgnd|1|0))\nfi\nreturn w.style.textbgnd\nend\n\nexport func gxbgndmode(w,?mode)=\t\t!GXBGNDMODE\n#\tmode supplied: set new background mode:\n#\t\t1 y Y T\t\tSet opaque (T for True? Looks like Transparent)\n#\t\t0 n N F\t\tSet Transparent\n\ngdi:=w.gdi\n\nif mode.isdef  then\n\tcase mode\n\twhen 1,'y','Y','T' then\n\t\tw.style.bgndmode:=opaque\n\telse\n\t\tw.style.bgndmode:=transparent\n\tesac\n\n\tsetbkmode(gdi.hdc,mode+1)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tsetbkmode(gdi.hdc2,mode+1)\n\tfi\nfi\nreturn w.style.bgndmode\nend\n\nexport proc gxhighlight(w,x,y,width,height)=\t\t!GXHIGHLIGHT\n#Invert rectangular region\nconst dstinvert=0x00550009\t!patblt\ngdi:=w.gdi\n\ngdi.updated:=1\npatblt(gdi.hdc, x, y, width,height,dstinvert)\nif gdi.drawmode=dm_screenmemory then\n\tpatblt(gdi.hdc2, x,y, width,height,dstinvert)\nfi\nend\n\nexport proc gxbitblt(w,x2,y2,width,height,x,y)=\t\t\t!GXBITBLT\n#Copy rectangular region of window to another location\ngdi:=w.gdi\ngdi.updated:=1\nbitblt(gdi.hdc, x2, y2, width,height,\n\t\t\tgdi.hdc,x,y,srccopy)\n\nif gdi.drawmode=dm_screenmemory then\n\tbitblt(gdi.hdc2,x2,y2,width,height,gdi.hdc2,x,y,srccopy)\nfi\nend\n\nexport func gxaskmess(mode=0)=\n#wait for next message and return message number\n#return 0 if close or quit message seen\n#some messages will be ignored here (processsed via procmess) and will wait for next\n#mode=0\t\tReturn currmess.message\n#mode=1\t\tReturn currmess.message, but if a mm_command message, then return\n#\t\t\tthe command id. This means message numbers and command ids share the\n#\t\t\tsame space. This should work because messages are below 200, and ids above 200\n\nrepeat\n\tif mxwait_mm_message()=0 then\n\t\treturn mm_cancel\n\tfi\n\tif quitmess then return mm_cancel fi\n\tx:=process_message(currmess)\n\n\tif currmess.message=mm_key and currmess.a=27 then\n\t\treturn mm_cancel\n\tfi\n\nuntil x=thismess\t\t\t\t\t!message ready to return\n\nif mode=1 and currmess.message=mm_command then\n\treturn currmess.a\nfi\n\nreturn currmess.message\nend\n\nfunc process_message(mess)=\n#user or default event processing for mm message\n#will call event handler if there is one\n#returns 1 (skipmess) if message has been processed here; caller must wait for another message\n#returns 0 (thismess) caller should deal with this message (it has not been processed, or has beenbut caller can process it too)\n\nif mess.wind=nil then\n\treturn thismess\nfi\n\ncase mess.message\nwhen mm_close then\n\treturn thismess\nesac\n\n!CPL \"PROCESS MESSAGE\"\n\nstatus:=domessage(mess)\n!CPL =STATUS\n\nreturn status\nend\n\nexport proc docs=\n!export proc where dostringzs for entire lib can go\n#Option dicts: used as args to gccreatewindow/gxcreatechildwindow:\n#\twf_border\t\tBorder style; see wbs_ enums\n#\twf_resize\t\t1 for resizable border (for top-level windows)\n# wf_hscroll\t\t1 for horizontal scrollbar\n# wf_vscroll\t\t1 for vertical scrollbar\n# wf_menu\t\t\t1 for a menubar\n# wf_caption\t\t1 for a caption bar (needs to be the right kind of border too)\n# wf_max\t\t\t1 for a max button\n# wf_minmax\t\t1 for a min/max buttons\n# wf_sysmenu\t\t1 for a system menu (right-click on top left I think)\n# wf_desktop\t\t1 to fill desktop\n# wf_clip\t\t\t1 to clip windows to desktop\n# wf_show\t\t\t1 to show window after creating\n# wf_iframe\t\t1 for pos/dim to refer to frame rather than client area\n# wf_cent\t\t\t1 to centre window\n# wf_toolwind\t\t1 for tool window (not sure what this means)\n\nend\n\nfunc newwindow(hwnd,index,windclass,borderstyle)=\n\nw:=new(rwindow,0)\nw.windclass:=windclass\n!w.style.borderstyle:=borderstyle\nw.index:=index\nw.childlist::=()\nw.owner:=nil\n\naddwindow(w)\nwx_setw(hwnd,w.gindex)\nreturn w\nend\n\nexport func getrgb(index)=\nif index=0 then return 0 fi\nreturn colourvalues[index]\nend\n\nfunc readstyle(owner,windclass,options)=\n!process gx options stored in the given dict type\n!return a stylerec all filled in\n\nif options.usertype=stylerec then\t\t\t!already a stylerec\n\treturn options\nfi\n\nss:=new(stylerec)\nif options.isvoid then\t\t\t\t!use bunch of defaults\n\td::=defstyle\n\td.border:=defaultborderstyles[windclass]\n\treturn d\nfi\n\nss.border\t:=options{ss_border,defaultborderstyles[windclass]}\nss.justify\t:=options{ss_justify,defstyle.justify}\nss.vjustify\t:=options{ss_vjustify,defstyle.vjustify}\nss.textfgnd\t:=options{ss_textfgnd,defstyle.textfgnd}\nss.textbgnd\t:=options{ss_textbgnd,defstyle.textbgnd}\nss.bgndmode\t:=options{ss_bgndmode,defstyle.bgndmode}\n\nss.iframe\t:=options{ss_iframe,0}\n\nss.hilitetype\t:=options{ss_hilitetype,defstyle.hilitetype}\nss.marktype\t:=options{ss_marktype,(ss.hilitetype|0|defstyle.marktype)}\nss.imark\t:=options{ss_imark,defstyle.imark}\n\nif windclass in [toggle_class, select_class,mark_class] and ss.marktype then\n\tdef:=owner.style.windbgnd\nelse\n\tdef:=defstyle.windbgnd\nfi\n\nss.windbgnd\t:=options{ss_windbgnd,def}\nss.hscroll\t:=options{ss_hscroll,0}\nss.vscroll\t:=options{ss_vscroll,0}\nss.lbchange\t:=options{ss_lbchange,0}\nss.returnmess\t:=options{ss_returnmess,0}\nss.noupdate\t:=options{ss_noupdate,0}\n\nreturn ss\nend\n\nexport func gxpanel(owner,pos,dim,?style)=\nss:=readstyle(owner,panel_class,style)\n\nw:=gxcontrol(owner,panel_class,pos,dim,ss)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxstatusbar(owner,pos,dim,?style)=\n\nss:=readstyle(owner,statusbar_class,style)\n\nif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\n\tbs:=ss.border\n\tif bscat[bs]<>'I' then\t\t\t!do adjustments\n\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\n\tfi\n\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\nfi\n\n(ecapos,ecadim):=gxclientarea(owner)\n\nif pos.isint then pos:=chr(pos) fi\n!if pos.ispointer then pos:=chr(pos) fi\nif convuc(pos) in \"T TOP\" then\t\t\t!along the top\n\tpos:=ecapos\n\tdir:='T'\nelse\t\t\t\t\t\t\t\t\t!along the bottom\n\tpos:=(ecapos[1],ecadim[2]-dim+ecapos[2])\n\tdir:='B'\nfi\ndim:=(ecadim[1],dim)\n\nss.dir:=dir\n\nw:=gxcontrol(owner,statusbar_class,pos,dim,ss)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxframebar(owner,pos,dim,?style)=\n\nss:=readstyle(owner,framebar_class,style)\nif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\n\tbs:=ss.border\n\tif bscat[bs]<>'I' then\t\t\t!do adjustments\n\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\n\tfi\n\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\nfi\n\n(ecapos,ecadim):=gxclientarea(owner)\n\n!if pos.isint then pos:=chr(pos) fi\nif pos.ispointer then pos:=chr(pos) fi\nif convuc(pos) in \"L LEFT\" then\t\t\t!along the left\n\tpos:=ecapos\n\tdir:='L'\nelse\t\t\t\t\t\t\t\t\t!along the right\n\tpos:=(ecadim[1]-dim+ecapos[1],ecapos[2])\n\tdir:='R'\nfi\ndim:=(dim,ecadim[2])\n\nss.dir:=dir\n\nw:=gxcontrol(owner,\tframebar_class,pos,dim,ss)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxbutton(owner,pos,dim,caption,?style,id=201,enable=1)=\n#create clickable button\n#returns rwindow\n\nss:=readstyle(owner,button_class,style)\n\nw:=gxcontrol(owner,button_class,pos,dim,ss)\nw.id:=id\n\nw.text:=caption\nw.enable:=enable\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxlabel(owner,pos,dim,caption,?style)=\n#create static label button\n#returns rwindow\n\nss:=readstyle(owner,label_class,style)\n\nw:=gxcontrol(owner,label_class,pos,dim,ss)\n\nw.text:=caption\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxgroup(owner,pos,dim,?style)=\n#create group window that encapsulates a set of controls\n#returns rwindow\n\nss:=readstyle(owner,group_class,style)\n\nw:=gxcontrol(owner,group_class,pos,dim,ss)\n\ngxdraw(w)\n\nreturn w\nend\n\nfunc gxcontrol(owner,windclass=button_class,pos,dim,?ss)=\n\nif ss.type=dict or ss.isvoid then\n\tss:=readstyle(owner,windclass,ss)\nfi\nwb:=wbs_none\ncase ss.border\t\t\t!find wbs- version of windows-drawn borders\nwhen bs_simplew then\n\twb:=wbs_simple\nesac\n\nif ss.iframe and bscat[ss.border]<>'I' then\n\twidths:=bswidths[ss.border]\n\tpos[1]+:=widths.x1\n\tpos[2]+:=widths.y1\n\tdim[1]-:=widths.x1+widths.x2\n\tdim[2]-:=widths.y1+widths.y2\nFI\n\nhwnd:=wx_createcontrol(pos:pos,dim:dim,border:wb,owner:owner.gdi.hwnd)\n\nif hwnd=0 then\n\tabort(\"Can't create control window\")\nfi\n\nw:=newwindow(hwnd,0,no_class,ss.border)\nw.windclass:=windclass\nw.style:=ss\nw.owner:=owner\nw.enable:=1\n\nsetwindowdims_c(w,hwnd)\nsetupgdi(w,hwnd)\n\ngxdrawmode(w,dm_screenmemory)\n\ngxfont(w,labelfont)\n\ngxtextcolour(w,w.style.textfgnd,w.style.textbgnd)\n\ngxbgndmode(w,w.style.bgndmode)\n\n!link into owner\nw.owner.childlist append:=w\nw.index:=w.owner.childlist.upb\n\nreturn w\nend\n\nexport func gxtoggle(owner,pos,dim,caption=\"\",linkvar,?style,id=201,enable=1)=\n\n(posx,posy):=pos\n(dimx,dimy):=dim\ntextoffset:=0\n\n\nss:=readstyle(owner,toggle_class,style)\n\n!work out whether an auxiliary window is needed\n\nif ss.marktype then\n\tif ss.imark=0 then\t\t\t!dims don't include the mark\n\t\tposx-:=markdim\n\t\tdimx+:=markdim\n\t\ttextoffset:=markdim\n\tfi\nfi\n\nw:=gxcontrol(owner,toggle_class,(posx,posy),(dimx,dimy),ss)\n!RETURN 0\nw.linkvar:=linkvar\nw.id:=id\nw.text:=caption\nw.attrs:=togglerec(textoffset,1)\nw.enable:=enable\n\nif w.style.marktype then\n!\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id,style:style)\n\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:ss)\nfi\n\ngxdraw(w)\nreturn w\nend\n\nexport func gxselect(owner,pos,dim,caption=\"\",linkvar,onvalue,?style,id=201,enable=1)=\n\n(posx,posy):=pos\n(dimx,dimy):=dim\ntextoffset:=0\n\nss:=readstyle(owner,select_class,style)\n\n!work out whether an auxiliary window is needed\nif ss.marktype and ss.imark=0 then\t\t\t!dims don't include the mark\n\tposx-:=markdim\n\tdimx+:=markdim\n\ttextoffset:=markdim\nfi\n\nw:=gxcontrol(owner,select_class,(posx,posy),(dimx,dimy),ss)\n\nw.linkvar:=linkvar\nw.id:=id\nw.text:=caption\nw.attrs:=togglerec(textoffset,onvalue)\nw.enable:=enable\nif w.style.marktype then\n\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:style)\nfi\n\ngxdraw(w)\nreturn w\nend\n\nexport proc showmessage(mess)=\nRETURN\nCPL MESS.MESSAGE\ncp \"Message:\",leftstr(messagenames[mess.message],20)\ncp \"A:\",,mess.a,\"B:\",,mess.b\ncp \" (X:\",,mess.x,\"Y:\",,mess.y,,\") Buttons:\",mess.state:\"b\"\n\ncpl \"\tWindow:\",mess.wind.name\nend\n\nfunc domessage(mess)=\n\nm:=mess.message\nw:=mess.wind\n\nIF W.GDI=0 THEN PCERROR(\"DOM/GDI=0\") FI\n\ncase m\nwhen mm_move,mm_setcursor then\n\treturn skipmess\nesac\n\nx:=messhandlertable[m,w.windclass](mess,w)\nreturn x\nend\n\nproc init_handlertables=\n\tmesshandlertable:=maketable(mm_null..mm_last, no_class..dummy_class, nil)\n\tactionhandlertable:=maketable(actionnames.bounds, no_class..dummy_class, nil)\n\n\tmessalltable:=new(list,mm_null..mm_last,0)\t\t!for all mess_mess_all handlers\n\tfnallall:=nil\t\t\t\t\t\t\t\t\t!for single mess_all_all handler\n\tfnfixups:=nil\n\n\tactionalltable:=new(list,actionnames.bounds,0)\n\n\tfor d to $nprocs() do\n\t\tfnptr:=$procref(d)\n\t\tfnname:=$procname(d)\n\t\t(name,messname,windname):=splitstring(fnname,\"_\")\t\t\t!split func name\n\n\t\tif fnname=\"gxhandler_fixups\" then\n\t\t\tfnfixups:=fnptr\n\t\telsif leftstr(fnname,5)=\"mess_\" then\n\t\t\tif messname=\"all\" and windname=\"all\" then\n\t\t\t\tfnallall:=fnptr\n\t\t\telse\n\t\t\t\tmessage:=(\"mm_\"+messname) inx messagenames\n\t\t\t\tif not message.isfound then\n\t\t\t\t\tABORT(\"CAN'T FIND MESSAGE <\"+messname+\">\")\n\t\t\t\tfi\n\n\t\t\t\tif windname=\"all\" then\t\t\t\t!assume <mess> all\n\t\t\t\t\tmessalltable[message]:=fnptr\n\t\t\t\telse\n\t\t\t\t\tmesshandlertable[message,WX:=findwindclass(windname)]:=fnptr\n\t\t\t\tfi\n\t\t\tfi\n\n\t\telsif leftstr(fnname,8)=\"do_draw_\" or leftstr(fnname,10)=\"do_update_\" then\n\t\t\taction:=messname+\"_w\" inx actionnames\n\t\t\tif not action.isfound then\n\t\t\t\tABORT(\"CAN'T FIND ACTION \"+MESSNAME)\n\t\t\tfi\n\t\t\tif windname=\"all\" then\n\t\t\t\tactionalltable[action]:=fnptr\n\t\t\telse\n\t\t\t\twindclass:=findwindclass(windname)\n\t\t\t\tactionhandlertable[action,windclass]:=fnptr\n\t\t\tfi\n\t\tfi\n\tod\n\n!!do some manual fixups\n\tif fnfixups then\n\t\tfnfixups()\n\tfi\n\n\tfor mx:=0 to mm_last do\n\t\tfor wx:=0 to dummy_class do\n\t\t\tif not messhandlertable[mx,wx] then\n\t\t\t\tmesshandlertable[mx,wx]:=(messalltable[mx]|messalltable[mx]|fnallall)\n\t\t\tfi\n\t\tod\n\tod\n\n\tif not fnallall then\n\t\tpcerror(\"Can't find all/all mess handler\")\n\tfi\n\n\tfor ax:=1 to DRAW_w do\n\t\tfor wx:=0 to dummy_class do\n\t\t\tif not actionhandlertable[ax,wx] then\n\t\t\t\tif not actionalltable then\n\t\t\t\t\tpcerror(\"No DO/ALL handler for:\"+actionnames[ax])\n\t\t\t\tfi\n\t\t\t\tactionhandlertable[ax,wx]:=actionalltable[ax]\n\t\t\tfi\n\t\tod\n\tod\nend\n\nfunc findwindclass(name)=\n\twindclass:=name+\"_class\" inx windowclassnames\n\tunless windclass.isfound then\n\t\tABORT(\"CAN'T FIND WINDOW \"+windname)\n\tend\n\treturn windclass\nend\n\nexport proc gxdraw(w)=\nfnptr:=actionhandlertable[draw_w,w.windclass]\n\nif fnptr then\n\tfnptr(w)\nelse\n\tcpl \"NO DRAW HANDLER\",windowclassnames[w.windclass],w.name\n\twaitkey()\n\tstop\nfi\nend\n\nexport proc gxupdate(w)=\nfnptr:=actionhandlertable[update_w,w.windclass]\nif fnptr then\n\tfnptr(w)\nelse\n\tgxdraw(w)\nfi\nend\n\nexport proc eventloop=\ndo\n\tm:=gxaskmess()\n\n\tSHOWMESSAGE(CURRMESS)\n\n\tcase m\n\twhen 0,mm_cancel then\n\t\treturn\n\tesac\n\nod\nend\n\nexport func gxeditbox(owner,pos,dim,linkvar,?style,id=201,enable=1)=\n\nss:=readstyle(owner,editbox_class,style)\n\nw:=gxcontrol(owner,editbox_class,pos,dim,ss)\n\nw.linkvar:=linkvar\nw.id:=id\nw.attrs:=new(editboxrec)\nw.attrs.currpos:=linkvar^.len+1\nw.enable:=enable\n\ngxdraw(w)\nreturn w\nend\n\nexport proc gxebchange(w,?linkvar,charpos=-1)=\n\nif linkvar.isdef then\n\tw.linkvar:=linkvar\nfi\n\nif charpos=-1 then\n\tw.attrs.currpos:=w.linkvar^.len+1\nelse\n\tw.attrs.currpos:=charpos\nfi\ngxupdate(w)\nend\n\nexport proc gxsetlbdata(w,linkvar,?pos)=\nw.linkvar:=linkvar\nif pos.isvoid then\n\tpos:=(linkvar^|1|0)\nfi\nw.attrs.currpos:=pos\n\nif w.childlist[1] then\n!\tgxsetscrolllimits(ws,linkvar^.bounds,w.attrs.rows)\n\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\n\tgxscrollpos(ws,pos)\nfi\nend\n\nexport proc gxsetlbpos(w,pos)=\n!change in pos\nw.attrs.currpos:=pos\n\n!work out screen row\nif pos then\n\toldpagepos:=w.attrs.pagepos\n\tif pos<oldpagepos then\n\t\tw.attrs.pagepos:=pos\n\telsif pos>oldpagepos+w.attrs.rows-1 then\n\t\tw.attrs.pagepos:=pos-w.attrs.rows+1\n\tfi\n\tif w.attrs.pagepos<>oldpagepos then\n\t\tif w.childlist then\n\t\t\tgxscrollpos(w.childlist[1],w.attrs.pagepos)\n\t\tfi\n\t\tm:=mm_draw\n\telse\n\t\tm:=mm_update\n\tfi\nelse\n\tm:=mm_draw\nfi\n\npostmess(w,m)\nif w.style.lbchange then\n\tpostmess(w,mm_lbchange,w.attrs.currpos)\nfi\nend\n\nexport proc gxsetlbpage(w,pagepos)=\n!change in pagepos (originates from scrollbar message)\nw.attrs.pagepos:=pagepos\n\noldpos:=w.attrs.currpos\nif oldpos<pagepos then\n\tw.attrs.currpos:=pagepos\nelsif oldpos>=pagepos+w.attrs.rows then\n\tw.attrs.currpos:=pagepos+w.attrs.rows-1\nfi\n\nif w.childlist then\n\tgxscrollpos(w.childlist[1],pagepos)\nfi\n\npostmess(w,mm_draw)\nif w.style.lbchange and oldpos<>w.attrs.currpos then\n\tpostmess(w,mm_lbchange,w.attrs.currpos)\nfi\nend\n\nexport func gxlistbox(owner,pos,dim,linkvar,?style,id=201,rows=0,pitch=0,offset=0)=\n\nss:=readstyle(owner,listbox_class,style)\n\n(dimx,dimy):=dim\nif ss_vscroll and ss_imark=0 then\t\t\t!dims don't include the scrollbar\n\tdimx+:=arrowdim\nfi\n\nw:=gxcontrol(owner,listbox_class,pos,(dimx,dimy),ss)\nw.linkvar:=linkvar\nw.id:=id\nw.attrs:=new(listboxrec)\n\nif pitch=0 then\t\t\t\t\t\t\t\t!calculate all these here\n\tpitch:=listrowheight\n\toffset:=0\n\trows:=w.dimy%pitch\nfi\nw.attrs.rows:=rows\nw.attrs.pitch:=pitch\nw.attrs.offset:=offset\n\nw.attrs.pagepos:=1\nw.attrs.currpos:=(getlvbounds(linkvar).len|1|0)\n\nif w.style.vscroll then\n\tws:=gxvertscrollbar(owner:w,pos:(w.dimx-arrowdim,0),dim:w.dimy,id:id,style:style)\n\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\n\n\tgxscrollpos(ws,getlvbounds(linkvar).lwb)\nfi\n\ngxdraw(w)\nreturn w\nend\n\nexport func gxarrow(owner,pos,?dim,dir,?style,id=201)=\n\nss:=readstyle(owner,arrow_class,style)\nif dim.isvoid then\n\tdim:=(arrowdim,arrowdim)\nfi\n\nw:=gxcontrol(owner,arrow_class,pos,dim,ss)\nw.id:=id\nif dir.isstring then dir:=asc(dir) fi\ncase dir\t\t\t\t\t!allow compass bearings too, but convert to UDLR\nwhen 'N' then dir:='U'\nwhen 'E' then dir:='R'\nwhen 'S' then dir:='D'\nwhen 'W' then dir:='L'\nesac\n\nw.style.dir:=dir\t\t\t!don't dir allow via style options\ngxdraw(w)\n\nreturn w\nend\n\nexport proc gxsetscrolllimits(w,limits,span=0)=\n!set up or change scrollbar limits\n!span=0:\n!\tPure ranging control. Limits are actual range of the thumb.\n!\tThumb is drawn at a fixed, nominal size. Might be suppressed when limits are <=1\n!\tInitial position set to limits.lwb\n!span=M:\n!\tPaging control, such as used on a listbox or text editor.\n!\tSpan can be the number of rows display at one time.\n!\tLimit can be single number N, or range 1..N.\n!\tActual scroll bar range will be 1..N-M+1. When upper limit<1 then\n!\tlimit will be 1..1, and thumb might not be drawn\n!\tData position will: actually there /is/ not data position, except for the\n!\tdata position represented by the top row, which will be the same as the scroll\n!\tposition.\n!Arrows should be disabled (and perhaps thumb suppressed) when scroll range if 1..1,\n!or data range is nor larger than a span\n\nw.attrs.span:=span\nif w.style.dir='H' then\n\twidth:=w.dimx\nelse\n\twidth:=w.dimy\nfi\nm:=width-arrowdim*2\t\t\t\t!number of pixels movement between arrows\n\nif span=0 then\t\t\t\t\t\t!pure scrolling control\n\tw.attrs.limits:=limits\n\tw.attrs.currpos:=limits.lwb\n\tw.attrs.thumbsize:=arrowdim\n\tenable:=limits.len>1\n\tw.attrs.thumbsize:=arrowdim*enable\nelse\n\tif limits.isrange then\n\t\tlength:=limits.len\n\telse\n\t\tlength:=limits\n\tfi\n\tif length<=span then\n\t\tenable:=0\n\t\tw.attrs.limits:=1..1\n\t\tw.attrs.thumbsize:=0\n\telse\n\t\tw.attrs.limits:=1..length-span+1\n\t\tenable:=1\n\t\tw.attrs.thumbsize:=max(10,int(m*(span/length)))\n\tfi\nfi\n\nw.attrs.currpos:=w.attrs.limits.lwb\nw.enable:=enable\n\nw.attrs.thumbspan:=m-w.attrs.thumbsize\t\t!movement available to thumb\nw.attrs.thumbpos:=arrowdim\npostmess(w,mm_draw)\nend\n\nexport func gxscrollpos(w,pos,u=0)=\n!\nif pos.isvoid then\n\treturn w.attrs.currpos\nfi\n\nw.attrs.currpos:=pos\nif pos not in w.attrs.limits then\n\tpcerror(\"Bad scroll pos\")\nfi\n\ntpos:=int(w.attrs.thumbspan*((pos-w.attrs.limits.lwb)/(w.attrs.limits.len-1)))\nw.attrs.thumbpos:=arrowdim+tpos\n\nw.childlist[1].enable:=pos>w.attrs.limits.lwb\nw.childlist[2].enable:=pos<w.attrs.limits.upb\n\nif u then\n\tpostmess(w,mm_update)\nfi\nreturn 0\nend\n\nexport func gxhozscrollbar(owner,pos,dim,?style,id=201)=\n\nss:=readstyle(owner,scrollbar_class,style)\nwidth:=arrowdim\nif dim.isint then\n!if dim.ispointer then\n\tdim:=(dim,width)\nelse\n\twidth:=dim[1]\nfi\n\nw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\nw.id:=id\nw.style.dir:='H'\n\nw.attrs:=new(scrollbarrec)\nw.flags.[wa_leftdrag]:=1\n\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\n!it's just a drawn box\nwa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'L')\nwb:=gxarrow(owner:w, pos:(dim[1]-width,0), dim:(width,width),dir:'R')\n\ngxsetscrolllimits(w,1..200,20)\ngxscrollpos(w,1)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxvertscrollbar(owner,pos,dim,?style,id=201)=\nss:=readstyle(owner,scrollbar_class,style)\nwidth:=arrowdim\nif dim.isint then\n!if dim.ispointer then\n\tdim:=(width,dim)\nelse\n\twidth:=dim[2]\nfi\n\nw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\nw.id:=id\nw.style.dir:='V'\n\nw.attrs:=new(scrollbarrec)\nw.flags.[wa_leftdrag]:=1\n\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\n!it's just a drawn box\nwa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'U')\nwb:=gxarrow(owner:w, pos:(0,dim[2]-width), dim:(width,width),dir:'D')\ngxsetscrolllimits(w,100..200,2)\n\ngxscrollpos(w,100)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxmark(owner,pos,?dim,?style,id=201)=\n\nss:=readstyle(owner,mark_class,style)\nif dim.isvoid then\n\tdim:=(markdim,markdim)\nfi\n\nw:=gxcontrol(owner,mark_class,pos,dim,style)\nw.id:=id\ngxdraw(w)\n\nreturn w\nend\n\nexport proc gxfocus(w)=\n!switch focus to window w\nif wfocus==w then\n\treturn\nfi\n\nif wfocus then\n\tdomessage(makemess(wfocus,mm_killfocus))\nfi\ncaretdrawn:=0\ndomessage(makemess(w,mm_setfocus))\nend\n\nexport proc gxkillfocus=\nif wfocus then\n\tdrawcaret(0)\nfi\nwfocus:=nil\nend\n\nexport func gxcopy(w,?bm,x=0,y=0,scalex=1.0,scaley=0,sx=0,sy=0,dimx=0,dimy=0)=\t\t!GXCOPY\n!copy bitmap bm to window w, at position x,y in w. Scalex/y can be 0 for 1:1,\n!or Scalex/y can be any real value for unequal x/y scaling\n!For equal x/y scaling, Scaley can be 0\n!Entire bitmap is copied (sx,sy,w,h all 0); for portion, set sx,sy to top left of rect\n!and w,h to size to be copied\n![1..100]char str\n\nif bm.isvoid then\n\tbm:=w\n\tw:=nil\nfi\nif bm.isvoid then\n\treturn nil\nfi\n\nif dimx=0 then dimx:=bm.dimx-sx fi\nif dimy=0 then dimy:=bm.dimy-sy fi\n\nif scalex=0 then scalex:=1.0 fi\nif scaley=0 then scaley:=scalex fi\n\nif w=nil then\t\t!create appropriate window\n\tw:=gxcreatewindow(caption:\"Bitmap \"+tostr(bm.pixelbits)+\" bit\",pos:(500,500),\n\t\t\tdim:(bm.dimx*scalex,bm.dimy*scaley))\n\tw.gdi.drawmode:=dm_screenmemory\t\t\t!default when using auto-window\nfi\n\ngdi:=w.gdi\ngdi.updated:=1\n\nmode:=copymode\n\nsetstretchbltmode(gdi.hdc,mode)\nstretchblt(gdi.hdc, x, y,int(dimx*scalex),int(dimy*scaley),\n\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\nif gdi.drawmode=dm_screenmemory then\n\tsetstretchbltmode(gdi.hdc2,mode)\n\tstretchblt(gdi.hdc2,x,y,int(dimx*scalex),int(dimy*scaley),\n\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\nfi\nreturn w\nend\n\nexport proc gxrestore(w,?r)=\n!repaint window w\n!only called when repaint can be done from a backup\n!r is the region to restore within w; or restore all if omitted\n\nif r.isvoid then\n\tx1:=y1:=0\n\n\twidth:=w.dimx\n\theight:=w.dimy\nelse\n\tx1:=r.x1\n\ty1:=r.x2\n\twidth:=r.x2-x1+1\n\theight:=r.y2-y1+1\nfi\n\ncase w.gdi.drawmode\nwhen dm_screen then\t\t\t!can't restore; need to call gx_draw\n\tgxdraw(w)\nwhen dm_screenmemory then\n\tdestdc:=w.gdi.hdc\n\tsourcedc:=w.gdi.hdc2\nwhen dm_memoryscreen then\n\tdestdc:=w.gdi.hdc2\n\tsourcedc:=w.gdi.hdc\nelse\n\tabort(\"gxrest/?\")\nesac\n\nbitblt(destdc,x1,y1, width,height, sourcedc, x1,y1, srccopy)\n\nend\n\nexport func gxdrawmode(w,?drawmode)=\n!set or get drawmode\n!really requires window to be cleared afterwards.\n\nolddrawmode:=w.gdi.drawmode\nif drawmode.isvoid then\n\treturn olddrawmode\nfi\n\nif olddrawmode=drawmode then\t\t!already set\n\treturn drawmode\nelsif olddrawmode<>dm_screen then\t!can only change screen => screenmemory/memoryscreen\n\tabort(\"gxdrawmode2\")\t\t\t!not memory to anything else\nfi\n\n!assuming currently on screen, will need extra compatible bitmap\nmemhwnd:=createcompatiblebitmap(screendc,w.dimx,w.dimy)\nmemhdc:=createcompatibledc(nil)\nselectobject(memhdc,memhwnd)\n\n!need to change draw mode\ncase drawmode\nwhen dm_screenmemory then\n\tw.gdi.hwnd2:=memhwnd\n\tw.gdi.hdc2:=memhdc\nwhen dm_memoryscreen then\n\tw.gdi.hwnd2:=w.gdi.hwnd\t\t\t!screen becomes secondary\n\tw.gdi.hdc2:=w.gdi.hdc\n\tw.gdi.hwnd:=memhwnd\n\tw.gdi.hdc:=memhdc\nelse\n\tabort(\"gxdrawmode?\")\nesac\n\nw.gdi.drawmode:=drawmode\nreturn drawmode\nend\n\nexport proc switchdest(w)=\n!for a window with screenmemory drawmode, switch things around so that\n!it's drawing into the memory area only\ngdi:=w.gdi\n\ncase gdi.drawmode\nwhen dm_screenmemory then\n\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\n\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\n\tgdi.drawmode:=dm_memory\nwhen dm_memory then\n\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\n\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\n\tgdi.drawmode:=dm_screenmemory\nesac\nend\n\nexport proc gxclose(w)=\n\ncase w.windclass\nwhen bitmap_class then\nelse\n\tif issubwindow(w,wfocus) then\n\t\twfocus:=nil\n\tfi\n\n\tif issubwindow(w,wmouse) then\t\n\t\tlastmousewindow:=nil\n\t\twmouse:=nil\n\tfi\n\n\tdestroywindow(w.gdi.hwnd)\n\tgxfreewindow(w)\nesac\nend\n\nproc gxfreewindow(w)=\n!recover memory used by this window and all childwindows\nfor wc in w.childlist do\n\tgxfreewindow(wc)\nod\n\nremovewindow(w)\n\nw.gdi:=0\nw:=0\nend\n\nexport func gxmsgbox(message,caption=\"\",options=\"\")=\n\nconst mb_abortretryignore\t= 0x02\nconst mb_applmodal\t\t\t= 0x00\nconst mb_defbutton1\t\t\t= 0x00\nconst mb_defbutton2\t\t\t= 100\nconst mb_defbutton3\t\t\t= 200\nconst mb_defbutton4\t\t\t= 300\nconst mb_help\t\t\t\t= 4000\nconst mb_iconasterisk\t\t= 40\nconst mb_iconerror\t\t\t= 10\nconst mb_iconexclamation\t= 30\nconst mb_iconhand\t\t\t= mb_iconerror\nconst mb_iconinformation\t= mb_iconasterisk\nconst mb_iconquestion\t\t= 20\nconst mb_iconstop\t\t\t= mb_iconhand\nconst mb_iconwarning\t\t= mb_iconexclamation\nconst mb_ok\t\t\t\t\t= 0x00\nconst mb_okcancel\t\t\t= 0x01\nconst mb_retrycancel\t\t= 0x05\nconst mb_right\t\t\t\t= 80000\nconst mb_setforeground\t\t= 10000\nconst mb_systemmodal \t\t= 1000\nconst mb_taskmodal\t\t\t= 2000\nconst mb_yesno\t\t\t\t= 0x04\nconst mb_yesnocancel\t\t= 0x03\nconst mb_topmost\t\t\t= 0x040000\n\n!return values\nconst idfail\t= 0\nconst idok\t\t= 1\nconst idcancel\t= 2\nconst idabort\t= 3\nconst idretry\t= 4\nconst idignore\t= 5\nconst idyes\t\t= 6\nconst idno\t\t= 7\n\nstatic var rettable=(0:\"fail\",\"ok\",\"cancel\",\"abort\",\"retry\",\"ignore\",\"yes\",\"no\",\n\t\t\"\",\"\",\"tryagain\",\"continue\")\n\nstatic var styletable=(\n(\"bari\",mb_abortretryignore),\n(\"bo\",mb_ok),\n(\"boc\",mb_okcancel),\n(\"brc\",mb_retrycancel),\n(\"byn\",mb_yesno),\n(\"bync\",mb_yesnocancel),\n(\"ix\",mb_iconexclamation),\n(\"iw\",mb_iconwarning),\n(\"ii\",mb_iconinformation),\n(\"iq\",mb_iconquestion),\n(\"is\",mb_iconstop),\n(\"ie\",mb_iconerror),\n(\"ih\",mb_iconhand),\n(\"d1\",mb_defbutton1),\n(\"d2\",mb_defbutton2),\n(\"d3\",mb_defbutton3),\n(\"d4\",mb_defbutton4),\n(\"h\",mb_help),\n(\"rj\",mb_right),\n(\"sm\",mb_systemmodal))\n\nhwnd:=nil\n\nstyle:=0\noptioncodes:=splitstring(options,\" \")\n\nfor opt in optioncodes do\n\tfor i to styletable.len do\n\t\tif styletable[i,1]=opt then style ior:=styletable[i,2] fi\n\tod\nod\n\nstyle ior:=0x10000\n\nx:=messageboxa(hwnd,message,caption,style)\nreturn rettable[x]\nEND\n\n\nexport proc gxhandler(windclass,mess,fnptr)=\n!windclass is a window, or a window class\n!override the current message handler for w's window class, and fo message mess\n\n!if not windclass.isint then\nif not windclass.ispointer then\n\twindclass:=windclass.windclass\nfi\n\n!CPL \"SETTING GXHANDLER\",MESS,WINDCLASS,FNPTR\nmesshandlertable[mess,windclass]:=fnptr\nend\n\nexport func gxaskfile(caption=\"File\",filespec=\"*.*\",deffile=\"\",startdir=\"\")=\n\nsave:=0\nif caption='*' then\n\tsave:=1\n\tcaption:=rightstr(caption,-1)\nfi\n\nfilters:=array(filespec+\"@@@\")\t\t!turn into a byte-array\n\nfor i,bb in filters do\t\t\t!convert all @ into embedded zeros\n\tif bb='@' then filters[i]:=0 fi\nod\n\nofn:=new((iswin32|ws_openfilename32|ws_openfilename64))\n\nofn.structsize:=ofn.bytes\nofn.owner:=wapplic.gdi.hwnd\nofn.instance:=getmodulehandle(0)\nofn.filter:=int(&filters)\nofn.flags:=ofn_explorer ior ofn_nochangedir ior ofn_hidereadonly !IOR OFN_NOVALIDATE\n\nofn.initialdir:=getstringz(startdir)\n\nofn.defext:=getstringz(\"\")\n\nresult:=new(array,byte,300)\n\nresult[1]:=0\nif deffile<>\"\" then\n\tmemcpy(&result,&deffile,deffile.len)\nfi\n\nofn.file:=int(&result)\n\nofn.maxfile:=256\nofn.title:=getstringz(caption)\n\nif not (not save | getopenfilenamea(&ofn) | getsavefilenamea(&ofn)) then\n\tresult[1]:=0\t\t!return \"\" on error\nfi\n\nreturn string(result)\nEND\n\nexport func gxcurrpos(w)=\nreturn w.attrs.currpos\nend\n\nexport func gxtabstops(?tabs,signed=0)=\nif tabs.isdef then\n\ttabstops::=tabs\n\tif signed then\n\t\tfor i,x in tabstops do\n\t\t\ttabstops[i]:=abs(x)\n\t\tod\n\tfi\nfi\nreturn tabstops\n\nend\n\nexport func getlvbounds(linkvar)=\nif linkvar.ispointer and linkvar^.islist then\n\treturn linkvar^.bounds\nelse\n\treturn linkvar.getbounds()\nfi\nreturn 0\nend\n\nexport func getlvitem(linkvar,n)=\nif linkvar.ispointer and linkvar^.islist then\n\treturn linkvar^[n]\nelse\n\tPCERROR(\"GETLVITEM\")\nfi\nreturn 0\nend\n\nexport func getlvstritem(linkvar,n)=\nif linkvar.ispointer and linkvar^.islist then\n\treturn tostr(linkvar^[n])\nelse\n\treturn linkvar.getstritem(n)\nfi\nreturn 0\nend\n\nexport proc gxtext16(w,s,n,x=0,y=0)=\t\t!GXTEXT\n\tgdi:=w.gdi\n\n\ttextoutw(gdi.hdc,x, y,&s,n)\n\tif gdi.drawmode=dm_screenmemory then\n\t\ttextoutw(gdi.hdc2,x,y,&s,n)\n\tfi\nend\n\nexport func gxenable(w,flag)=\nif flag.isdef then\n\tw.enable:=flag\n\tgxupdate(w)\nfi\nreturn w.enable\nend\n\nexport func gxclientarea(w)=\n!scan child windows of w, work out remaining client area after taking account of\n!framebars etc\n!return (pos, dim), each being a 2-element list\n\naposx:=aposy:=0\n\nadimx:=w.dimx\nadimy:=w.dimy\n\ncentx:=(aposx+adimx)%2\ncenty:=(aposy+adimy)%2\n\n!for cw in w.childlist when cw.windclass in [statusbar_class,framebar_class] do\nfor cw in w.childlist do\n\n\t(posx,posy):=(cw.frameposx,cw.frameposy)\n\t(dimx,dimy):=(cw.framedimx,cw.framedimy)\n\n!need to find out which of the four sides the bar is against, and set up side= L R T B\n\tcase cw.style.dir\n\twhen 'B' then\t\t\t\t!bottom\n\t\tif posy<(aposy+adimy) then\n\t\t\tadimy-:=dimy\n\t\tfi\n\n\twhen 'T' then\t\t\t\t!top\n\t\tif (posy+dimy)>aposy then\t\t!\n\t\t\taposy+:=(posy+dimy)\n\t\t\tadimy-:=(posy+dimy)\n\t\tfi\n\n\twhen 'R' then\t\t\t\t!right\n\t\tif posx<(aposx+adimx) then\n\t\t\tadimx-:=dimx\n\t\tfi\n\n\twhen 'L' then\t\t\t\t!LEFT\n\t\tif (posx+dimx)>aposx then\t\t!\n\t\t\taposx+:=(posx+dimx)\n\t\t\tadimx-:=(posx+dimx)\n\t\tfi\n\telse\n\n\t\tif dimx>dimy then\t\t\t!assume hoz\n\t\t\tif posy>centy then\t\t\t!assume bottom\n\t\t\t\tif posy<(aposy+adimy) then\n\t\t\t\t\tadimy-:=dimy\n\t\t\t\tfi\n\n\t\t\telse\t\t\t\t\t!top\n\t\t\t\tif (posy+dimy)>aposy then\t\t!\n\t\t\t\t\taposy+:=(posy+dimy)\n\t\t\t\t\tadimy-:=(posy+dimy)\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\t\t\t\t\t!assume vert\n\t\t\tif posx>centx then\t\t\t!assume right\n\n\t\t\t\tif posx<(aposx+adimx) then\n\t\t\t\t\tadimx-:=dimx\n\t\t\t\tfi\n\n\t\t\telse\t\t\t\t\t!left\n\n\t\t\t\tif (posx+dimx)>aposx then\t\t!\n\t\t\t\t\taposx+:=(posx+dimx)\n\t\t\t\t\tadimx-:=(posx+dimx)\n\t\t\t\tfi\n\n\t\t\tfi\n\t\tfi\n\tesac\nod\n\nreturn ((aposx,aposy), (adimx,adimy))\nEND\n\nexport func addwindow(w)=\n!w is a newly created window\n!add it to all windows\nn:=nil inx allwindows\nif not n.isfound then\n\tn:=allwindows.len+1\nfi\n\nallwindows[n]:=w\nw.gindex:=n\nreturn n\nend\n\nexport proc removewindow(w)=\n!remove w from all windows\nn:=w inx allwindows\nif n.isfound then\n\tallwindows[n]:=nil\nfi\nend\n\nfunc process_wmmessage(msg)=\n!STATIC VAR CC=0\n!CPL \"PROCESS/WMMESSAGE\",++CC\n\tx:=process_wmmessage2(msg)\n!CPL \"RETURN X:\",X\n!$SETDEBUG(1)\n\treturn x\nend\n\nfunc process_wmmessage2(msg)=\n!msg is a windows rmsg record\n!Called from MainWndProc callback func (via mechanisms for B code to call into MPL code)\n!this func processes some wm_ Windows messages and converts them\n!into mm_ messages as necessary\n!It returns:\n!\t0 The wm_ message has been processed\n!\t1 The wm_ message has not been processed, and the caller should call DefWindowProc.\n!\t  Or, the DefWindowProc should also be called anyway.\n\n!CPL \"PROCESSWMM2\",MSG.MESSAGE, WINMESSAGENAMES{MSG.MESSAGE}\n\nhwnd:=msg.hwnd\nw:=getwindow(hwnd)\n\nmessage:=msg.message\nwparam:=msg.wparam\nlparam:=msg.lparam\n\ncase msg.message\nwhen wm_command then\n\tw:=getwindow(lparam)\t\t\t!w was owner, use control window\n\ti:=wparam iand 0xffff\t\t\t!id\n\tj:=wparam>>16\t\t\t\t!notify code\n\tm:=mm_command\n\n\tif not w then\n\t\tw:=wapplic\n\tfi\n\n\tpostmess(w,m,i,j,0)\n\n\treturn 0\n\nwhen wm_activate then\n\tif wparam then\t\t\t\t!being activated\n\tfi\n\nwhen wm_syskeydown,wm_syskeyup,wm_keydown,wm_keyup then\n\nSTATIC VAR COUNT=0\n\nIF MSG.MESSAGE=WM_KEYDOWN THEN\nCPL \"KEY\",++COUNT\nFI\n\n\tif dokeymessage(hwnd,message,wparam,lparam) then\n\t\treturn 0\n\tfi\n\nwhen wm_char then\n\tpostmess((wfocus|wfocus|w),mm_char,wparam,lparam,0)\n\nwhen wm_close then\n\tif w==wapplic then\n\t\tpostmess(w,mm_close,0,0,0)\n\t\treturn 0\n\telse\n\t\tpostmess(w,mm_cancel,0,0,0)\n\t\treturn 0\n\tfi\n\nwhen wm_timer then\n\tif not background and not stationary then\t\t!test for pausing of mouse\n\t\tif gettickcount()-lastxytime>pausetime then\n\t\t\tstationary:=1\n\t\tfi\n\tfi\n\nwhen wm_destroy then\n\tif w and wapplic and w==wapplic then\n\t\tkilltimer(hwnd,1)\n!*\t\tif tick then killtimer(hwnd,1) fi\n\t\tpostquitmessage(0)\t\t\t!mm_quit message\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n\n!when wm_setcursor then\n!\tpostmess(w,mm_setcursor,wparam,lparam,0)\n\nwhen wm_mousemove then\n\n\tbuttonstate:=wparam iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\n\tmousepos.x:=lparam iand 65535\n\tmousepos.y:=lparam>>16\n\ndomousemove:\n\txyvalid:=1\t\t\t\t!known again\n\tsetnewmousewindow(w)\n\n\twmouse:=w\n\tpostmess(wmouse,mm_move)\n\n\tlastxy::=getscreencoords(wmouse,mousepos)\n\tlastxytime:=gettickcount()\n\tstationary:=0\n\n!do drag processing; states are:\n!pen up/recent pen down/first drag/subsequent drag\n!any drag messages are sent as well as mm_move messages\n!dragmode=1/2/3 indicates drag has started (reset by buttonswitching)\n\n\tif buttonstate<>0 and lastmousewindow<>nil then\t\t!switch pressed\n\t\tpt:=getscreencoords(lastmousewindow,lastmousepos)\n\t\tdx:=lastxy.x-pt.x\n\t\tdy:=lastxy.y-pt.y\n\n\t\tif dragmode then\t\t!1st drag message already generated\n\t\t\tpostmess(lastmousewindow,mm_drag,dx,dy,-1)\t\t\t!send latest drag coords\n\n\t\telse\t\t\t\t!test for drag enabling\n\t\t\tif ((mousesw=1 and lastmousewindow.flags.[wa_leftdrag]<>0) or \\\n\t\t\t\t\t\t\t(mousesw=2 and lastmousewindow.flags.[wa_rightdrag]<>0) or \\\n\t\t\t\t\t\t\t(mousesw=3 and lastmousewindow.flags.[wa_middledrag]<>0)) and \\\n\t\t\t\t\t\t(abs(dx)>dragtol or abs(dy)>dragtol) then\n\t\t\t\tdragmode:=mousesw\n\t\t\t\tpostmess(lastmousewindow,mm_startdrag,dx,dy,-1)\t\t!send latest drag coords\n\t\t\tfi\n\n\t\tfi\n\telse\n\t\tif dragmode then\n\t\t\tpostmess(lastmousewindow,mm_enddrag,dx,dy,-1)\t!send latest drag coords\n\t\t\tdragmode:=0\n\t\tfi\n\tfi\n\n\treturn 0\n\nwhen wm_enteridle then\t\t!enter idle\n\tidlemode:=1\n\treturn 0\n\nwhen wm_paint then\n\n\tif w<>nil then\n\t\tps:=new(ws_paintstruct)\n\t\trect:=new(ws_rect)\n\t\tbeginpaint(hwnd,&ps)\n\t\tpostmess(w,mm_restore,0,0,0)\n\t\tendpaint(hwnd,&ps)\n\t\treturn 0\n\tfi\n\nwhen wm_erasebkgnd then\n\nwhen wm_move then\n\tif w<>nil then\n!*!\t\tgxmovewindow(w,lparam iand 65535,lparam>>16)\n\tfi\n\nwhen wm_size then\n\tx:=lparam iand 0xffff\n\ty:=lparam>>16\n\tif w<>nil  and (w.dimx<>x or w.dimy<>y) then\n!*!\t\tgxmplresize(w,x,y,wparam)\n\t\treturn 0\n\tfi\n\n!when wm_killfocus,wm_setfocus then\n\nwhen wm_contextmenu then\n\tsendmess(w,mm_rclick,wparam>>16,wparam iand 0xffff,0)\n\treturn 0\n\nwhen wm_mousewheel then\n\tif not wmouse then wmouse:=w fi\n\tpostmess(wmouse,mm_wheel,int(wparam>>16),wparam iand 0xffff,0)\n\treturn 0\n\nwhen wm_nclbuttondown,wm_nclbuttondblclick then\n\nwhen wm_activateapp then\n\tif wparam then\n\t\tpostmess(w,mm_activate,1,0,0)\n\tfi\n\nelse\nbtnmessages:\n!check for sequential messages\n!CPL \"FALLTHROUGH\"\n\tif message>=wm_lbuttondown and message<=wm_mbuttondblclk then\n\t\tbuttonmessages(hwnd,message,wparam,lparam)\n\t\treturn 0\n\tfi\nesac\n!end\n!fall-through here to do default message processing instead of/in addition to local processing\n!CPL \"HERE, RETURN 1\"\nreturn 1\t!defwindowproc(hwnd,imsg,wparam,lparam)\nend\n\nexport proc mxinit=\nwmessagetable := [\\\n\twm_lbuttondown:\t\tmm_click,\n\twm_lbuttonup:\t\tmm_clickup,\n\twm_lbuttondblclk:\tmm_dblclick,\n\n\twm_rbuttondown:\t\tmm_rclick,\n\twm_rbuttonup:\t\tmm_rclickup,\n\twm_rbuttondblclk:\tmm_rdblclick,\n\n\twm_mbuttondown:\t\tmm_mclick,\n\twm_mbuttonup:\t\tmm_mclickup,\n\twm_mbuttondblclk:\tmm_mdblclick]\n\n!table gives button number 1,2,3 for Windows button message (always 0 for button up)\nbuttontable\t:= [\\\n\twm_lbuttondown:\t\t1,\n\twm_lbuttonup:\t\t0,\n\twm_lbuttondblclk:\t1,\n\n\twm_rbuttondown:\t\t2,\n\twm_rbuttonup:\t\t0,\n\twm_rbuttondblclk:\t2,\n\n\twm_mbuttondown:\t\t3,\n\twm_mbuttonup:\t\t0,\n\twm_mbuttondblclk:\t3]\n\nmousepos:=new(ws_point)\n\nsetmesshandler(process_wmmessage)\n!CPL =PROCESS_WMMESSAGE\n!setmesshandler(bill)\n\nvktomesstable:=[\\\n\tvkleft:\t\tmm_leftkey,\n\tvkright:\tmm_rightkey,\n\tvkup:\t\tmm_upkey,\n\tvkdown:\t\tmm_downkey,\n\tvkpageup:\tmm_pageupkey,\n\tvkpagedown:\tmm_pagedownkey,\n\tvkhome:\t\tmm_homekey,\n\tvkend:\t\tmm_endkey,\n\tvktab:\t\tmm_tabkey,\n\tvkbackspace:\tmm_bskey,\n\tvkdelete:\tmm_deletekey,\n\tvkenter:\tmm_enterkey,\n\tvkinsert:\tmm_insertkey,\n\tvkescape:\tmm_cancel\n]\nend\n\nexport func postmess(w,mess,a=0,b=0,c=0)=\n!add message m to end of message queue\n!use mess+1000 to add message to start of queue rather than the end\n\nif w=nil then w:=wapplic fi\nif w=nil then\n return 0 fi\n\nif w.flags.[wa_closed] then\n\n return 0 fi\n\nif mess>=1000 then\n\theadx:=1; mess-:=1000\nelse\n\theadx:=0\nfi\n\n!check if new message can be combined with an old message\ncase mess\nwhen mm_sethozpos,mm_setvertpos,mm_draw,mm_restore,mm_update then\n\tfor i:=1 to nmessages do\n\t\tm:=messagequeue[i].message\n\t\tif m=mess and w==messagequeue[i].wind then\t\t\t\t!use the old message but update any params\n\t\t\tmessagequeue[i].a:=a\n\t\t\tmessagequeue[i].b:=b\n\t\t\treturn 0\n\t\telsif mess=mm_draw and m=mm_update then\t\t!convert update to draw\n\t\t\tmessagequeue[i].message:=mm_draw\n\t\t\treturn 0\n\t\tfi\n\tod\nesac\n\nif quitmess or nmessages>=maxqueuesize then\n\treturn 0\nfi\n\npostmsg(makemess(w,mess,a,b,c))\n\nreturn 0\t\t\t\t\t!return zero for use in mainwndproc\nend\n\nexport func postmsg(msg,headx=0)=\n!add complete message msg to end of message queue\n!use head=1 to add to start of queue rather than the end\n\nif quitmess or nmessages>=maxqueuesize then\n\treturn 0\nfi\n\nif msg.wind.flags.[wa_closed] then return 0 fi\n\nif headx then\n\n!avoid dupl paint messages\n\t++nmessages\n\tfor i:=nmessages downto 2 do\n\t\tmessagequeue[i]:=messagequeue[i-1]\n\tod\n\tmessagequeue[1]:=msg\n\nelse\n\t++nmessages\n\tmessagequeue[nmessages]:=msg\nfi\n\nreturn 0\t\t\t\t\t!return zero for use in mainwndproc\nend\n\nexport proc sendmess(w,mess,a=0,b=0,c=0)=\n!add message m to head of message queue\n!(may be 100% handled in q smlib)\n\nif w=nil then return fi\nif w.flags.[wa_closed] then return fi\n\nsendmsg(makemess(w,mess,a,b,c))\nend\n\nproc sendmsg(msg)=\n!call event handler for msg or add to head of queue\nif msg.wind.flags.[wa_closed] then return fi\npostmsg(msg,1)\nend\n\nexport func makemess(w,mess,a=0,b=0,state=-1)=\n!turn params into a new messrec @nemm_ess\n!the q version makemess also accepts makemess(w,msg)\n\nif w=nil then w:=wapplic fi\n\nm:=new(rmessage,0)\n\nm.wind:=w\n\nm.message:=mess\nm.a:=a\nm.b:=b\nm.state:=state\n\nm.x:=mousepos.x\nm.y:=mousepos.y\n\nif m.state=-1 then m.state:=getshiftstate() fi\n\nreturn m\nend\n\nfunc dokeymessage(hwnd,msg,wparam,lparam)=\n!return 1 if message has been dealt with\ncase msg\nwhen wm_syskeydown then\n\tif wparam=vkf10 then msg:=wm_keydown; goto dokey fi\n\nwhen wm_syskeyup then\n\tif wparam=vkf10 then msg:=wm_keyup; goto dokey fi\n\nwhen wm_keydown,wm_keyup then\ndokey:\n\tcase wparam\n\twhen vkshift,vkctrl,vkalt,vkcapslock then\n\telse\n\t\tw:=wfocus\n!\t\tif not w then w:=wx_getw(hwnd) fi\n\t\tif not w then w:=getwindow(hwnd) fi\n!CPL =GETSHIFTSTATE()\n!\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,getshiftstate(),lparam)\n\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,lparam,-1)\n\t\treturn 1\n\tesac\nesac\nreturn 0\nend\n\nfunc getshiftstate=\nstate:=0\n\nif getkeystate(vklshift) iand 0x8000 then state ior:=kb_shift fi\nif getkeystate(vklcontrol) iand 0x8000 then state ior:=kb_ctrl fi\nif getkeystate(vklalt) iand 0x8000 then state ior:=kb_alt fi\n\nif getkeystate(vkrshift) iand 0x8000 then state ior:=kb_rshift fi\nif getkeystate(vkrcontrol) iand 0x8000 then state ior:=kb_rctrl fi\nif getkeystate(vkralt) iand 0x8000 then\n\tstate ior:=kb_ralt\n\tstate iand:=(inot kb_ctrl)\t\t\t!AltGr gives Lctrl+Ralt; return Ralt only\nfi\nif getkeystate(vkcapslock) iand 1 then state ior:=kb_capslock fi\n\nreturn state ior buttonstate\nEND\n\nproc buttonmessages(hwnd,msg,wp,lp)=\n!process Windows mouse message <msg>\n\n!update button from wparam, excluding ctrl/shift (which are updated from key msgs)\nbuttonstate:=wp iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\n\n!update mouse position\nmousepos.x:=lp iand 0xffff\nmousepos.y:=int(lp)>>16\nwmouse:=getwindow(hwnd)\n\n!set mousesw to last pressed button (1,2,3) or 0 if one just released\n!(note other buttons may still be down, used for drag processing)\nmousesw:=buttontable{msg}\n\nif mousesw then\t\t\t!down up on click or dblclick\n\tlastbuttontime:=gettickcount()\n\tlastmousepos::=mousepos\n\tlastmousewindow:=wmouse\nelse\n\tmousesw:=0\n\n\tif dragmode then\n\t\tpostmess(lastmousewindow,mm_enddrag,0,0,-1)\n\t\tdragmode:=0\n\tfi\n\n\tlastbuttontime:=0\n\tlastmousewindow:=nil\nfi\n\nnewmess:=wmessagetable{msg}\n\n!filter double-click messages and convert to repeated click if not enabled\ncase newmess\nwhen mm_dblclick then unless wmouse.flags.[wa_leftdbl] then newmess:=mm_click end\nwhen mm_rdblclick then unless wmouse.flags.[wa_rightdbl] then newmess:=mm_click end\nesac\n\npostmess(wmouse,newmess,wmouse.id,0,-1)\nEND\n\nproc setnewmousewindow(w)=\nreturn when not currmousewindow\nunless w==currmousewindow then\t\t!changed\n\tif currmousewindow<>nil then\n\t\tpostmess(currmousewindow,mm_offwindow,0,0,0)\n\tfi\n\n\tcurrmousewindow:=w\n\tpostmess(w,mm_onwindow,0,0,0)\nend unless\nend\n\nproc frame2rect(f,r)=\nr^.x:=f^.x\nr^.y:=f^.y\n\nr^.dimx:=f^.x2-f^.x1+1\nr^.dimy:=f^.y2-f^.y1+1\nend\n\nexport func mxwait_mm_message=\n#do windows dispatch loop\n#calling dispatchmessage() results in mainwndproc being called in interpreter,\n#which passes the Windows message params on to process_wmmessage() in this module\n#process_wmmessage() converts wm-messages to mpl mm-messages\n#return when at least one mm message is ready; (will return immediately if there\n#is already one in the queue)\n#return value is normall 1, or 0 when quitmess has been encountered\n\nif quitmess then\t\t\t\t!quit message already seen\n\treturn 0\nfi\n\nwindmsg:=new((iswin32|ws_msg32|ws_msg64))\n\nwhile nmessages<=0 do\n\tif x:=getmessage(&windmsg,nil,0,0)<>0 then\n\t\tw:=windmsg.hwnd\n\t\ttranslatemessage(&windmsg)\n\t\tdispatchmessage(&windmsg)\n\telse\n\t\tquitmess:=1\n\t\texit\n\tfi\nod\n\nif not nmessages then\t\t\t!assume quit message seen\n\treturn 0\nfi\t\n\ncurrmess:=messagequeue[1]\n--nmessages\n\nxlatkeyboard()\n\nfor i:=1 to nmessages do\n\tmessagequeue[i]:=messagequeue[i+1]\nod\nreturn 1\nend\n\nproc xlatkeyboard=\n!expand any mm_key messages to special key messages\n!uses and modified currmess\nm:=currmess.message\n\nif m=mm_key then\n\n\tk:=currmess.a\n\tif k>=vkf1 and k<=vkf12 then\n\t\tnewmsg:=currmess\n\t\tcurrmess.message:=mm_functionkey\n\t\tcurrmess.a:=k-vkf1+1\n\telse\n\t\tkeymess:=vktomesstable{k,0}\n\t\tif keymess then\n\t\t\tcurrmess.message:=keymess\n\t\tfi\n\tfi\nfi\nend\n\nfunc getscreencoords(w,pos)=\npt::=pos\nif not w then\n\tPCERROR(\"GSC/W=0\")\nfi\n\nclienttoscreen(w.gdi.hwnd,&pt)\t\t!pos starts at 0,0\nreturn pt\nend\n\nexport func getwindow(hwnd)=\n!convert hwnd to window\n!return nil if any problem\nif hwnd=0 then\n\treturn nil\nfi\n\nindex:=wx_getw(hwnd)\nif index then\n\treturn allwindows[index]\nfi\nreturn nil\nend\n\nproc initmenuhandlers=\nltcolour:=getrgb(ltgrey)\ndkcolour:=getrgb(dkgrey)\nend\n\nproc gxhandler_fixups=\n!do some manual fixups for various shared handlers\n!(the automatic fixup routine allows multiple window classes per message, but not\n! multiple message per window class)\nmesshandlertable[mm_startdrag,scrollbar_class]:=mess_drag_scrollbar\nmesshandlertable[mm_enddrag,scrollbar_class]:=mess_drag_scrollbar\nmesshandlertable[mm_leftkey,scrollbar_class]:=mess_upkey_scrollbar\nend\n\nfunc mess_all_all(mess,w)=\ncase mess.message\nwhen mm_startdrag,mm_drag,mm_enddrag then\nwhen mm_command then\nwhen mm_ok,mm_cancel then\nwhen mm_click then\n\tcase w.windclass\n\twhen label_class, group_class then\n\t\treturn skipmess\n\tesac\nwhen mm_key then\nwhen mm_sethozpos,mm_setvertpos then\nwhen mm_pick,mm_lbchange then\nwhen mm_leftkey,mm_rightkey,mm_upkey,mm_downkey,mm_enterkey,mm_tabkey then\nwhen mm_pageupkey,mm_pagedownkey then\nwhen mm_homekey, mm_endkey then\nwhen mm_functionkey then\nwhen mm_wheel then\nelse\n\treturn skipmess\nesac\n\nreturn thismess\nend\n\nfunc mess_restore_all(mess,w)=\ngxrestore(W)\n\nreturn skipmess\nend\n\nfunc mess_killfocus_all(mess,w)=\n!note: can be called from mess_setfocus_all, with a different mess, but correct w\n!assume w is same as wfocus\n\ndrawcaret(0)\nwfocus:=nil\n\nreturn skipmess\nend\n\nfunc mess_setfocus_all(mess,w)=\nif wfocus then\n\tmess_killfocus_all(mess,wfocus)\nfi\n\nwfocus:=w\ndrawcaret(1)\nreturn skipmess\nend\n\nfunc mess_update_all(mess,w)=\ngxupdate(w)\nreturn skipmess\nend\n\nfunc mess_draw_all(mess,w)=\ngxdraw(w)\nreturn skipmess\nend\n\nfunc mess_click_select(mess,w)=\nif w.enable then\n\tif not w.style.noupdate then\n\t\tp:=w.linkvar\n\t\tp^:=w.attrs.onvalue\n\t\tfor wc in w.owner.childlist do\n\t\t\tif wc.windclass=select_class and wc.linkvar=p then\n\t\t\t\tgxdraw(wc)\n\t\t\tfi\n\t\tod\n\tfi\n\tif w.style.returnmess then\n\t\tpostmess(w,mm_command,w.id)\n\tfi\nfi\nreturn skipmess\nend\n\nfunc mess_click_toggle(mess,w)=\nif w.enable then\n\tif not w.style.noupdate then\n\t\tw.linkvar^:=not w.linkvar^\n\t\tgxdraw(w)\n\tfi\n\tif w.style.returnmess then\n\t\tpostmess(w,mm_command,w.id)\n\tfi\nfi\nreturn skipmess\nend\n\nfunc mess_click_button(mess,w)=\n\nif w.enable=0 then\n\tbeep1()\n\treturn skipmess\nfi\n\nif w.id in 0..199 then\t\t\t\t!speficies an actual message number (but no params)\n\tpostmess(w,w.id)\nelse\n\tpostmess(w,mm_command,w.id)\nfi\nreturn skipmess\nend\n\nfunc mess_click_editbox(mess,w)=\nif w.enable then\n\tif not w.style.noupdate then\n\t\tunless w==wfocus then\n\t\t\tgxfocus(w)\n\t\tend\n\tfi\n\tif w.style.returnmess then\n\t\tpostmess(w,mm_command,w.id)\n\tfi\nfi\n\nreturn skipmess\nend\n\nfunc mess_click_arrow(mess,w)=\n\ncase w.owner.windclass\nwhen scrollbar_class then\n\tpostmess(w.owner,dirtomess{w.style.dir},w.id,0,-1)\nelse\n\tmess.message:=dirtomess{w.style.dir}\n\tmess.a:=w.id\n\treturn thismess\nesac\nreturn skipmess\nend\n\nfunc mess_click_mark(mess,w)=\n\ncase w.owner.windclass\nwhen toggle_class,select_class then\n\tpostmess(w.owner,mess.message,w.id,0,-1)\nesac\nreturn skipmess\nend\n\nfunc mess_click_listbox(mess,w)=\ngxfocus(w)\n\ny:=max(w.attrs.offset,mess.y)\n\npos:=(y-w.attrs.offset)%w.attrs.pitch+w.attrs.pagepos\nif pos<=getlvbounds(w.linkvar).len then\n\tgxsetlbpos(w,pos)\n\tpostmess(w,mm_pick,pos)\nfi\n\nreturn skipmess\nend\n\nfunc mess_click_scrollbar(mess,w)=\nonthumb:=isonthumb(w,(w.style.dir='H'|mess.x|mess.y))\nstep:=w.attrs.span\na:=w.attrs.currpos\n\ncase w.owner.windclass\nwhen listbox_class then\n\tcase onthumb\n\twhen -1 then\n\t\tif a>w.attrs.limits.lwb then\n\t\t\ta:=max(a-step,w.attrs.limits.lwb)\n\t\t\tgxsetlbpage(w.owner,a)\n\t\tfi\n\twhen 1 then\n\t\tif a<w.attrs.limits.upb then\n\t\t\ta:=min(a+step,w.attrs.limits.upb)\n\t\t\tgxsetlbpage(w.owner,a)\n\t\tfi\n\tesac\nelse\n\tif not step then step:=10 fi\n\n\tcase onthumb\n\twhen -1 then\n\t\tif a>w.attrs.limits.lwb then\n\t\t\ta:=max(a-step,w.attrs.limits.lwb)\n\t\t\tgxscrollpos(w,a,1)\n\t\t\tpostmess(w,mm_sethozpos,a)\n\t\tfi\n\twhen 1 then\n\t\tif a<w.attrs.limits.upb then\n\t\t\ta:=min(a+step,w.attrs.limits.upb)\n\t\t\tgxscrollpos(w,a,1)\n\t\t\tpostmess(w,mm_sethozpos,a)\n\t\tfi\n\tesac\nesac\nreturn skipmess\nend\n\nfunc mess_wheel_scrollbar(mess,w)=\ndelta:=currmess.a\nn:=abs(currmess.a%120)\nto n do\n\tcase w.windclass\n\twhen scrollbar_class then\ndoscroll:\n\t\tpostmess(w,(delta>0|mm_up|mm_down))\n\twhen listbox_class then\n\t\tif w.childlist then\n\t\t\tw:=w.childlist[1]\n\t\t\tgoto doscroll\n\t\tfi\n\t\tpostmess(w,(delta>0|mm_upkey|mm_downkey))\n\tesac\nod\nreturn skipmess\nend\n\nfunc mess_up_scrollbar(mess,w)=\na:=w.attrs.currpos\nif a<=w.attrs.limits.lwb then\n\treturn skipmess\nfi\ncase w.owner.windclass\nwhen listbox_class then\n\tgxsetlbpage(w.owner,a-1)\n\treturn skipmess\nelse\n\t--a\n\tgxscrollpos(w,a,1)\n\tpostmess(w,mm_setvertpos,a)\nesac\nreturn skipmess\nend\n\nfunc mess_left_scrollbar(mess,w)=\n\ncase w.owner.windclass\nwhen listbox_class then\n\treturn skipmess\nelse\n\ta:=w.attrs.currpos\n\tif a>w.attrs.limits.lwb then\n\t\t--a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_sethozpos,a)\n\tfi\nesac\nreturn skipmess\nend\n\nfunc mess_right_scrollbar(mess,w)=\n\ncase w.owner.windclass\nwhen listbox_class then\n\treturn skipmess\nelse\n\ta:=w.attrs.currpos\n\tif a<w.attrs.limits.upb then\n\t\t++a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_sethozpos,a)\n\tfi\n\nesac\nreturn skipmess\nend\n\nfunc mess_down_scrollbar(mess,w)=\n\na:=w.attrs.currpos\nif a>=w.attrs.limits.upb then\n\treturn thismess\nfi\ncase w.owner.windclass\nwhen listbox_class then\n\tgxsetlbpage(w.owner,a+1)\n\treturn skipmess\nelse\n\t++a\n\tgxscrollpos(w,a,1)\n\tpostmess(w,mm_setvertpos,a)\n\nesac\nreturn skipmess\nend\n\nfunc mess_drag_scrollbar(mess,w)=\ncase mess.message\nwhen mm_startdrag then\n\tif isonthumb(w,(w.style.dir='H'|mess.x|mess.y))=0 then\n\t\tthumbdragmode:=1\t\t\t!then treat as mm_drag\n\t\tthumbstartpos:=w.attrs.thumbpos-arrowdim\t\t!use thumb pos at start of drag\n\telse\t\t\t\t\t\t\t!dragging other part of scrollbar\n\t\treturn skipmess\n\tfi\nwhen mm_enddrag then\n\tthumbdragmode:=0\n\treturn skipmess\nelsif not thumbdragmode then\n\treturn skipmess\nesac\n\noffset:=(w.style.dir='H'|mess.a|mess.b)\t\t!pixel offset from initial drag start pos\nnewpos:=thumbstartpos+offset\t\t\t\t\t\t!could outside thumb span range\n\npos:=int(round((newpos/w.attrs.thumbspan)*(w.attrs.limits.len-1)+w.attrs.limits.lwb))\npos:=clamp(pos,w.attrs.limits.lwb,w.attrs.limits.upb)\n\ncase w.owner.windclass\nwhen listbox_class then\n\tgxsetlbpage(w.owner,pos)\nelse\n\tgxscrollpos(w,pos,1)\n\tpostmess(w,(w.style.dir='H'|mm_sethozpos|mm_setvertpos),pos)\nesac\nreturn skipmess\nend\n\nfunc mess_move_button(mess,w)=\nreturn skipmess\nend\n\nfunc mess_move_all(mess,w)=\nreturn skipmess\nend\n\nfunc mess_char_editbox(mess,w)=\n\tif mess.a not in 32..255 then\n\t\tif wapplic then\n\t\t\tpostmess(wapplic,mm_key,mess.a,mess.b,mess.state)\n\t\tfi\n\t\treturn skipmess\n\tfi\n\tif not w.enable or w.style.noupdate then return skipmess fi\n\ts:=w.linkvar^\n\tn:=w.attrs.currpos\n\tc:=chr(mess.a)\n\n\tif n>s.len then\t\t\t\t!at end\n\t\ts+:=c\n\telsif n=1 then\t\t\t\t!at start\n\t\ts:=c+s\n\telse\t\t\t\t\t\t!in middle\n\t\ts:=leftstr(s,n-1)+c+rightstr(s,-(n-1))\n\tfi\n\n\tw.linkvar^:=s\n\t++w.attrs.currpos\n\tgxdraw(w)\n\n\treturn skipmess\nend\n\nfunc mess_key_editbox(mess,w)=\n!CPL \"KEY/EDITBOX\"\n\npostmess(wapplic,mm_key,mess.a,mess.b,mess.state)\n\nreturn skipmess\nend\n\nfunc mess_leftkey_editbox(mess,w)=\nif ctrlpressed() then\n\tpostmess(wapplic,mm_leftkey,mess.a,mess.b,mess.state)\n\treturn skipmess\nfi\n\nif w.attrs.currpos>1 then\n\tdrawcaret(0)\n\t--w.attrs.currpos\n\tdrawcaret(1)\nfi\nreturn skipmess\nend\n\nfunc mess_rightkey_editbox(mess,w)=\nif ctrlpressed() then\n\tpostmess(wapplic,mm_rightkey,mess.a,mess.b,mess.state)\n\treturn skipmess\nfi\n\nif w.attrs.currpos<=w.linkvar^.len then\n\tdrawcaret(0)\n\t++w.attrs.currpos\n\tdrawcaret(1)\nfi\nreturn skipmess\nend\n\nfunc mess_bskey_editbox(mess,w)=\ns:=w.linkvar^\nif not s then return skipmess fi\nn:=w.attrs.currpos\nif n=1 then return skipmess fi\n\nif n>s.len then\t\t\t\t!at end\n\ts:=leftstr(s,-1)\nelse\t\t\t\t\t\t!in middle\n\ts:=leftstr(s,n-2)+rightstr(s,-(n-1))\nfi\n\nw.linkvar^:=s\n--w.attrs.currpos\ngxdraw(w)\n\nreturn skipmess\nend\n\nfunc mess_deletekey_editbox(mess,w)=\ns:=w.linkvar^\nif not s then return skipmess fi\nn:=w.attrs.currpos\nif n>s.len then return skipmess fi\n\nif n=1 then\t\t\t\t!at start\n\ts:=rightstr(s,-1)\nelse\t\t\t\t\t\t!in middle\n\ts:=leftstr(s,n-1)+rightstr(s,-n)\nfi\nw.linkvar^:=s\ngxdraw(w)\n\nreturn skipmess\nend\n\nfunc mess_homekey_editbox(mess,w)=\nif ctrlpressed() then\n\tpostmess(wapplic,mm_homekey,mess.a,mess.b,mess.state)\n\treturn skipmess\nfi\n\ndrawcaret(0)\nw.attrs.currpos:=1\ndrawcaret(1)\n\nreturn skipmess\nend\n\nfunc mess_homekey_listbox(mess,w)=\nif w.attrs.currpos>1 then\n\tgxsetlbpos(w,1)\nfi\n\nreturn skipmess\nend\n\nfunc mess_endkey_editbox(mess,w)=\nif ctrlpressed() then\n\tpostmess(wapplic,mm_endkey,mess.a,mess.b,mess.state)\n\treturn skipmess\nfi\n\ndrawcaret(0)\nw.attrs.currpos:=w.linkvar^.len+1\ndrawcaret(1)\n\nreturn skipmess\nend\n\nfunc mess_endkey_listbox(mess,w)=\n!if w.attrs.currpos<w.linkvar^.len then\nif w.attrs.currpos<getlvbounds(w.linkvar).len then\n!\tgxsetlbpos(w,w.linkvar^.len)\n\tgxsetlbpos(w,getlvbounds(w.linkvar).len)\nfi\n\nreturn skipmess\nend\n\nfunc mess_upkey_listbox(mess,w)=\nif w.attrs.currpos>1 then\n\tgxsetlbpos(w,w.attrs.currpos-1)\nfi\n\nreturn skipmess\nend\n\nfunc mess_upkey_scrollbar(mess,w)=\n!assume that this is independent scrollbar\n!(linked scrollbar wouldn't get the focus)\n\na:=w.attrs.currpos\nif a>w.attrs.limits.lwb then\n\t--a\n\tgxscrollpos(w,a,1)\n\tpostmess(w,mm_setvertpos,a)\nfi\nreturn skipmess\nend\n\nfunc mess_downkey_listbox(mess,w)=\n!if w.attrs.currpos<w.linkvar^.len then\nif w.attrs.currpos<getlvbounds(w.linkvar).len then\n\tgxsetlbpos(w,w.attrs.currpos+1)\nfi\n\nreturn skipmess\nend\n\nfunc mess_pageupkey_listbox(mess,w)=\nif (a:=w.attrs.currpos)>1 then\n\ta:=max(a-w.attrs.rows,1)\n\tgxsetlbpos(w,a)\nfi\n\nreturn skipmess\nend\n\nfunc mess_pagedownkey_listbox(mess,w)=\nif (a:=w.attrs.currpos)<getlvbounds(w.linkvar).len then\n\ta:=min(a+w.attrs.rows,getlvbounds(w.linkvar).len)\n\tgxsetlbpos(w,a)\nfi\n\nreturn skipmess\nend\n\nfunc mess_enterkey_listbox(mess,w)=\nif w.attrs.currpos then\n\tpostmess(w,mm_pick,w.attrs.currpos)\nfi\n\nreturn skipmess\nend\n\nproc do_draw_all(w)=\ngxclear(w)\ndrawborder(w)\ndrawchildborders(w)\nend\n\nproc do_draw_button(w)=\ngxclear(w)\n\ngxtext_just(w,w.text,0,w.enable)\n\ndrawborder(w)\n\nend\n\nproc do_draw_label(w)=\ndo_draw_button(w)\nend\n\nproc do_draw_toggle(w)=\ngxclear(w)\n\nVALSTR:=\"\"\n\nturnedon:=istrue w.linkvar^\n\nif w.style.marktype then\n\tdrawmark(w.childlist[1],turnedon,w.enable)\n\n\tgxtext_just(w,w.text+valstr,markdim,w.enable)\nelse\n!\tcase w.style.hilitetype\n!\twhen invert_hilite then\n\t\tif turnedon then\n\t\t\tgxclear(w,getrgb(green))\n\t\tfi\n!\tesac\n\n\tgxtext_just(w,w.text+valstr)\nfi\nend\n\nproc do_draw_select(w)=\ngxclear(w)\n\nturnedon:=w.linkvar^=w.attrs.onvalue\n\nif w.style.marktype then\n\tdrawmark(w.childlist[1],turnedon,w.enable)\n\tgxtext_just(w,w.text,markdim,w.enable)\nelse\n\tcase w.style.hilitetype\n\twhen invert_hilite then\n\t\tif turnedon then\n\t\t\tgxclear(w,getrgb(white))\n\t\tfi\n\tesac\n\t\tgxtext_just(w,w.text)\nfi\nend\n\nproc do_draw_editbox(w)=\ngxclear(w)\n\ngxtext_just(w,w.linkvar^,enable:w.enable)\n\n!Now, have to draw the cursor\nunless wfocus==w then\t\t\t!only draw it when this window has the focus\n\treturn\nend\n\ncaretdrawn:=0\n\ndrawcaret(1)\nend\n\nproc do_draw_arrow(w)=\ngxclear(w)\n\ndrawborder(w)\ndrawarrow(w,w.enable)\nend\n\nproc do_draw_mark(w)=\n\ncase w.owner.windclass\nwhen toggle_class, select_class then\n\treturn\t\t\t\t\t!mark drawn by owner\nesac\n\ngxclear(w,getrgb(w.owner.style.windbgnd))\n\ndrawborder(w)\nend\n\nproc do_draw_scrollbar(w)=\ngxclear(w)\ndrawborder(w)\ngxdraw(w.childlist[1])\t\t\t!arrows\ngxdraw(w.childlist[2])\n\n!now draw the thumb\nif w.attrs.thumbsize then\n\tif w.style.dir='H' then\n\t\tx:=w.attrs.thumbpos\n\t\tdx:=w.attrs.thumbsize\n\t\tdrawthumb(w,x,0,dx,w.dimy)\n\telse\n\t\ty:=w.attrs.thumbpos\n\t\tdy:=w.attrs.thumbsize\n\t\tdrawthumb(w,0,y,w.dimx,dy)\n\tfi\nfi\nend\n\nproc do_draw_listbox(w)=\ngxclear(w)\ndrawborder(w)\nif w.childlist then\t\t\t!scrollbar\n\tgxdraw(w.childlist[1])\nfi\n\nfor i:=1 to w.attrs.rows do\n\tk:=i+w.attrs.pagepos-1\n\tif k<=getlvbounds(w.linkvar).len then\n\t\tdrawlbtext(w,i,getlvstritem(w.linkvar,k),0,k=w.attrs.currpos)\n\tfi\nod\nend\n\nproc do_update_all(w)=\ngxdraw(w)\nend\n\nproc do_update_listbox(w)=\ngxdraw(w)\nend\n\nproc drawcaret(x)=\n!x=1: draw caret in wfocus window at current position\n!x=0: delete caret in wsfocus window\n!returns x-pixel position of caret\n\nif wfocus=nil then\t\t!no window has focus\n\tcaretdrawn:=0\n\treturn\nfi\n\ncase wfocus.windclass\nwhen editbox_class then\n\tif x then\t\t\t!new caret\n\t\tif caretdrawn then return fi\t!already drawn\n\t\txpos:=getcaretpos(wfocus.linkvar^,wfocus.attrs.currpos,0)\n\t\twfocus.attrs.caretpos:=xpos\t\t\t!record position\n\telse\t\t\t!delete caret\n\t\tif not caretdrawn then return fi\t!already deleted\n\t\txpos:=wfocus.attrs.caretpos\t\t!use stored value\n\tfi\n\n\tcaretwidth:=2\n\n\tgxhighlight(wfocus,xpos+wfocus.attrs.textpos[1],wfocus.attrs.textpos[2]-chd,caretwidth,20)\n\n\tcaretdrawn:=x\nesac\nend\n\nfunc getcaretpos(s,pos,offset)=\n!return pixel position of in front of pos'th character in string s\n!offset is no. of chars not shown, to left of string\nif pos=1 then return 0 fi\n\nreturn wx_gettextwidth(wfocus.gdi.hdc, leftstr(s,pos-1))\nend\n\nproc drawborder(w)=\n!do own-drawn borders\n!other kinds of borders are windows-drawn, no-border, and the main bs- style\n!borders which exist in the owner's client area\n!for own-drawn borders, the window should have been cleared first\n\ncase bscat[w.style.border]\nwhen 0 then\t\t\t\t\t!no border\n\treturn\nwhen 'W' then\t\t\t\t!windows-drawn\n\treturn\nwhen 'X' then\t\t\t\t!external (drawn in owner's client space\n\tposx:=w.frameposx\n\tposy:=w.frameposy\n\tdimx:=w.framedimx\n\tdimy:=w.framedimy\n\tbs:=w.style.border\n\n\tbs:=w.style.border\n\two:=w.owner\n\tcase bs\n\twhen bs_simple then\t\t\t!USUALLY BS_SIMPLE converts to BS_WINDOWS; must be override\n\t\tgxcolour(wo,0)\n\t\tgxrect(wo,posx,posy,dimx,dimy)\n\twhen bs_thick then\n\twhen bs_panel then\n\t\tgxcolour(wo,ltcolour)\n\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\n\t\tgxline(wo,posx,posy+dimy-1)\n\t\tgxcolour(wo,dkcolour)\n\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\n\t\tgxline(wo,posx+dimx-1,posy)\n\twhen bs_inset then\n\t\tgxcolour(wo,dkcolour)\n\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\n\t\tgxline(wo,posx,posy+dimy-1)\n\t\tgxcolour(wo,ltcolour)\n\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\n\t\tgxline(wo,posx+dimx-1,posy)\n\twhen bs_testext then\n\t\tgxcolour(wo,0)\n\t\tgxrect(wo,posx,posy,dimx,dimy)\n\t\tgxrect(wo,posx+9,posy+9,dimx-18,dimy-18)\n\tesac\nwhen 'I' then\t\t\t\t!internal (drawn within window's client space\n\tposx:=w.frameposx\n\tposy:=w.frameposy\n\tdimx:=w.dimx\n\tdimy:=w.dimy\n\n\tcase w.style.border\n\twhen bs_ownpanel then\n\t\tgxcolour(w,ltcolour)\n\t\tgxline(w,w.framedimx-1,0,0,0)\n\t\tgxline(w,0,w.framedimy-1)\n\t\tgxcolour(w,dkcolour)\n\t\tgxline(w,w.framedimx-1,w.framedimy-1)\n\t\tgxline(w,w.framedimx-1,0)\n\n\twhen bs_owninset then\n\t\tgxcolour(w,dkcolour)\n\t\tgxline(w,w.framedimx-1,0,0,0)\n\t\tgxline(w,0,w.framedimy-1)\n\t\tgxcolour(w,ltcolour)\n\t\tgxline(w,w.framedimx-1,w.framedimy-1)\n\t\tgxline(w,w.framedimx-1,0)\n\twhen bs_ownsimple then\n\t\tgxcolour(w,0)\n\t\tgxrect(w,0,0,w.framedimx,w.framedimy)\n\twhen bs_testint then\n\t\tgxcolour(w,0)\n\t\tgxrect(w,0,0,dimx,dimy)\n\t\tgxrect(w,7,7,dimx-14,dimy-14)\n\tesac\nesac\nend\n\nproc drawchildborders(w)=\nif not w.childlist then\n\treturn\nfi\nfor wc in w.childlist do\n\tif wc.style.border in [bs_simple,bs_thick,bs_panel,bs_inset] then\n\t\tdrawborder(wc)\n\tfi\nod\nend\n\nproc drawarrow(w,enable)=\n!w has already been cleared\n!e=1/omitted to enable, 0 to disable (shown grey)\nconst factor=0.3\n\ngxsetpen(w,(enable|black|dkgrey))\n\nwidth:=w.dimx\nheight:=w.dimy\n\ncase w.style.dir\nwhen 'D' then\n\tx:=int(round(width/2)-1)\n\n\twd:=0\n\n\th:=int(round(min(height,width)*factor))\n\tif h<3 then h:=3 fi\n\ty:=int((height+h)*0.5)-1\n\n\tto h do\n\t\tgxline(w,x,y,x+wd,y)\n\t\tx-:=1\n\t\ty-:=1\n\t\twd+:=2\n\tod\n\nwhen 'U' then\n\tx:=int(round(width/2)-1)\n\twd:=0\n\n\th:=int(round(min(height,width)*factor))\n\tif h<3 then h:=3 fi\n\ty:=int(round((height-h)*0.5))\n\tto h do\n\t\tgxline(w,x,y,x+wd,y)\n\t\tx-:=1\n\t\ty+:=1\n\t\twd+:=2\n\tod\n\nwhen 'L' then\n\ty:=height%2\n\n\tht:=0\n\twd:=y\n\n\twd:=int(round(min(height,width)*factor))\n\tif wd<3 then wd:=3 fi\n\tx:=int(round((width-wd)*0.5)-1)\n\n\tto wd do\n\t\tgxline(w,x,y,x,y+ht)\n\t\ty-:=1\n\t\tx+:=1\n\t\tht+:=2\n\tod\n\nwhen 'R' then\n\ty:=height%2\n\tht:=0\n\n\twd:=int(round(min(height,width)*factor))\n\tif wd<3 then wd:=3 fi\n\tx:=int(round((width+wd)*0.5)-1)\n\n\tto wd do\n\t\tgxline(w,x,y,x,y+ht)\n\t\ty-:=1\n\t\tx-:=1\n\t\tht+:=2\n\tod\nesac\nend\n\nexport proc gxtext_just(w,s,offset=0,enable=1)=\n\tdimx:=w.dimx\n\tdimy:=w.dimy\n\twidth:=wx_gettextwidth(w.gdi.hdc, s)\n\theight:=chy\t\t\t\t!assume basic font\n\n\tcase w.style.justify\n\twhen 'L' then\tx:=smx\n\twhen 'R' then\tx:=dimx-width-smx\n\telse\n\t\t\t\tx:=(dimx-width)%2\n\tesac\n\n\tcase w.style.vjustify\n\twhen 'T' then\ty:=smy\n\twhen 'B' then\ty:=dimy-height-smy\n\telse\n\t\t\t\ty:=(dimy-height)%2!\t\t-smy%2\n\tesac\n\n\tif not enable then\n\t\toldtextfgnd:=w.style.textfgnd\n\t\tgxtextcolour(w,grey)\n\tfi\n\n\tgxtext(w,s,x+offset,y)\n\n\tif not enable then\n\t\tgxtextcolour(w,oldtextfgnd)\n\tfi\n\tif w.windclass=editbox_class then\n\t\tw.attrs.textpos:=(x+offset,y)\n\tfi\nend\n\nproc drawthumb(w,x,y,dx,dy)=\n!w is a scrollbar, vert or hoz\n!draw thumb within w, as a simple rectangle starting at x,y at top left of size dx,dy\n\ngxcolour(w,0)\ngxrect(w,x,y,dx,dy)\ngxfillrect(w,x+1,y+1,dx-2,dy-2,getrgb(grey))\nend\n\nfunc isonthumb(w,d)=\n!w is a scrollbar, d is a pixel position along it (0 being at left or top)\n!return:\n! -1\tis before the thumb\n!  0\tis on the thumb\n! +1\tif after the thumb\n!d can specify a spot off the thumbar if being dragged\n\na:=w.attrs.thumbpos\nb:=w.attrs.thumbsize\n\nif d<a then\n\treturn -1\nelsif d>(a+b) then\n\treturn 1\nelse\n\treturn 0\nfi\nend\n\nproc drawmark(w,turnedon,enable)=\n!!w has already been cleared\n!draw checked check mark, tick, or radio button, according to whether\n!turnedon is 1 or 0\n!e=1 to enable, 0 to disable (shown grey)\n\ngxclear(w,getrgb(w.owner.style.windbgnd))\ngxsetpen(w,(enable|black|red))\n\nwidth:=w.dimx\nheight:=w.dimy\nx:=y:=1\nwd:=width-2\nht:=height-2\ngxrect(w,x,y,wd,ht)\nif not turnedon then return fi\n\ncase w.style.marktype\nwhen radio_mark then\n\n\tgxfillrect(w,x+3,y+3,wd-6,ht-6,getrgb(red))\n\nwhen check_mark then\n\n\tgxline(w,x,y,x+wd-1,y+ht-1)\n\tgxline(w,x+wd-1,y,x,y+ht-1)\n\nwhen tick_mark then\n\n\tgxline(w,x+3,y+ht%2,x+wd%2,y+ht-4)\n\tgxline(w,x+wd-3,y+2)\n\nesac\nend\n\nproc drawlbtext(w,row,text,clr=0,hilite=0)=\n!draw text inside given row of listbox w\n!clr=1 to clear the background first (not needed when entired lb has been cleared)\n!hilite=1 to highlight this row\n\nx:=0\ny:=(row-1)*w.attrs.pitch+w.attrs.offset\n\nif clr or hilite then\n\tgxfillrect(w,x,y,w.dimx,w.attrs.pitch,(hilite|getrgb(grey)|getrgb(w.style.windbgnd)))\nfi\n\nif hilite then\n\toldtextcolour:=gxtextcolour(w)\n\tgxtextcolour(w,white)\nfi\n!RETURN\n\ngxtext(w,text,x+smx,y+smy)\nif hilite then\n\tgxtextcolour(w,oldtextcolour)\nfi\nend\n\nfunc readnextitem(a)=\n!return (level,value,labelx,options)\n!special values used for divider, new column, new menu\n!next line of file should already have been read\n\nif a=\"\" then return list(0,0,0,0) fi\n\nlevel:=1\ntabs:=0\noptions:=\"\"\n\nwhile asc(a) in [9,' '] do tabs+:=1; a:=rightstr(a,-1) od\n\nif a=\"\" then return list(0,0,0,0) fi\n\ncase asc(a)\nwhen '!' then\n\treturn list(0,0,0,0)\nesac\n\nif tabs then\n\tj:=0\n\tfor i:=1 to ntab do\n\t\tif tabs=tabstack[i] then j:=i; exit fi\n\tod\n\n\tif j=0 then\n\t\tif tabs>tabstack[ntab] then\n\t\t\tntab+:=1\n\t\t\ttabstack[ntab]:=tabs\n\t\tfi\n\t\tlevel:=ntab\n\telse\n\t\tlevel:=j\n\t\tif j<ntab then ntab:=j fi\n\tfi\nfi\n\nif asc(a) in ['0'..'9'] then\n\tvalue:=strtoval(a)\n\tn:=\" \" inx a\n\tif not n.isfound then\n\t\tn:=chr(9) in a\n\tfi\n\tif n.isfound then\n\t\tlabelx:=rightstr(a,-n)\n\telse\n\t\tlabelx:=\"?\"\n\tfi\n\nelse\t\t\t!no preceding number, maybe top-level menu\n\n\tif \"=\" in a then\t!command def for mpl\n\t\treturn (0,0,0,0)\n\tfi\n\n\tvalue:=k_menu\n\tlabelx:=a\n\tcase convlc(labelx)\n\twhen \"hozbreak\",\"divider\" then\n\t\tvalue:=kdivide\n\twhen \"vertbreak\" then\n\t\tvalue:=kcolumn\n\twhen \"filehistory\" then\n\t\tvalue:=kfilehistory\n\telse\n\t\tif leftstr(labelx)=\"-\" then value:=kdivide fi\n\tesac\nfi\n\nif labelx=\"\" then\t\t\t!maybe [cmd] only\n\treturn list(0,0,0,0)\nfi\n\nreturn (level,value,(labelx),options)\nend\n\nfunc readmenu(m,n,level)=\n!starting at index n in data, read all following items that are\n!at lower level (ie. higher level number) than given level\n!insert items into menu handle m\n!return index of next item in data, which is at <level> or higher\n!will stop at end of data, and return ndata+1\n\nrestartx:\nfor i:=n to ndata do\n\t(l,value,labelx,options):=data[i]\n\n\tif l<=level then\t\t!end of this submenu\n\t\treturn i\n\tfi\n\n\tflags:=breakflag\n\tenable:=1\n\tif rightstr(labelx)=\"?\" then\n\t\tenable:=0\n\t\tlabelx:=leftstr(labelx,-1)\n\tfi\n\n\tif options<>\"\" then\n\t\tif \"H\" in options then flags+:=\"h\" fi\n\t\tif \"C\" in options then flags+:=\"c\" fi\n\tfi\n\n\tcase value\n\twhen kdivide then\n\t\tgxaddmb(m,style:\"d\")\n\twhen kcolumn then\n\t\tbreakflag:=\"v\"\n\twhen k_menu then\t\t!submenu\n\t\tnewm:=gxcreatemb()\n\t\tn:=readmenu(newm,i+1,l)\n\t\tgxaddmb(m,labelx,newm,\"p\"+flags,enable)\n\t\tbreakflag:=\"\"\n\t\tgoto restartx\n\twhen kfilehistory then\n\t\tnfiles:=8\n\t\tgxaddmb(m,\"filehistory\",1060,breakflag)\n\telse\t\t\t\t!ordinary command\nnormalcmd:\n\t\tgxaddmb(m,labelx,value,flags,enable)\n\t\tbreakflag:=\"\"\n\tesac\n\nskip:\nod\n\nreturn ndata+1\t\t\t!eod reached\nend\n\nfunc mbreaddata(a)=\n!a is a list of tab-indented strings for a menu bar\n!a can also be a text file containing the strings\n\ntabstack::=(0,)\nntab:=1\ndata::=()\nndata:=0\nbreakflag:=\"\"\n\nif a.isstring then\t\t!read from file\n\ta:=readtextfile(a)\n\tif a=0 then\n\t\ta:=(\"CANTOPENFILE\",)\n\tfi\nfi\n\nfor i:=1 to a.upb do\n\tx:=readnextitem(a[i])\n\n\tif x[1] then\n\t\t++ndata\n\t\tdata[ndata]:=x\n\tfi\nod\n\nm:=gxcreatemb()\nreadmenu(m,1,0)\nreturn m\nend\n\nexport func gxmenubar(w,?a)=\n!called as:\n!\tgxmenubar(a):\tcreate standalone menu; return handle\n!\tgxmenubar(w,a):\tadd menu to windows w (returns 0)\n!a:\n!\tstring:\t\t\tassume this is a filename containing menubar tabbed layout\n!\tlist:\t\t\ta list of strings containing the data\n\nif a.defined then\t\t!w,m: read menu into window w\n\tm:=mbreaddata(a)\n\n\tif not w.ispointer then\n\t\twhile w.owner<>nil do\n\t\t\tw:=w.owner\n\t\tod\n\tfi\n\n\tgxsetmb(w,m)\n\treturn 0\nelse\t\t\t\t!create standalone menu, return handle\n\treturn mbreaddata(w)\nfi\nend\n\nfunc gxcreatemb(?s)=\nif s.defined and s in \"Pp\" then\n\treturn createpopupmenu()\nelse\n\treturn createmenu()\nfi\nend\n\nproc gxsetmb(w,m)=\n\nhwnd:=w.gdi.hwnd\na:=getmenu(hwnd)\ns:=setmenu(hwnd,m)\nif a then destroymenu(a) fi\nend\n\nfunc gxaddmb(wm,caption=\"X\",id=0,style=\"\",enable=0)=\n\nif wm.ispointer then\t\t\t\t!assume handle\n\thmenu:=wm\n\twm:=nil\nelse\n\thmenu:=getmenu(wm.gdi.hwnd)\nfi\n\nflags:=mf_string ior mf_unchecked\n\nif not enable then flags ior:=mf_greyed fi\n\nforeach c in convuc(style) do\n\tcase c\n\twhen 0 then exit\n\twhen 'P' then flags ior:=mf_popup\n\twhen 'D' then flags ior:=mf_separator\n\twhen 'B' then flags ior:=mf_menubreak\n\twhen 'V' then flags ior:=mf_menubarbreak\n\twhen 'H' then flags ior:=mf_help\n\twhen 'C' then flags ior:=mf_checked\n\tesac\nod\n\nif appendmenu(hmenu,flags,id,caption) then\n\tif wm<>nil then drawmenubar(wm.gdi.hwnd) fi\n\treturn hmenu\nfi\nreturn 0\nend\n\nproc gxshowmb(wm,w,x,y)=\n!update menu associated with window; call this func if it has been updated\n!when wm is a menu handle, draw the popup on the screen at x,y\n!if wm.isint then\nif wm.ispointer then\n\n\tif not y.defined then\n\t\tx:=w\n\t\ty:=x\n\t\tw:=nil\n\t\thwnd:=wapplic.gdi.hwnd\n\telse\n\t\thwnd:=w.gdi.hwnd\n\tfi\n\n\tpos:=ws_point(x,y)\n\n\tif w<>nil then\n\t\tclienttoscreen(w.gdi.hwnd,&pos)\n\tfi\n\n\ttrackpopupmenu(wm,0,pos.x,pos.y,0,hwnd,0)\nelse\n\tdrawmenubar(wm.gdi.hwnd)\nfi\nend\n\nfunc gxenablemb(wm,id,enable)=\n\nif wm.ispointer then\t\t\t\t!assume handle\n\thmenu:=wm\nelse\n\thmenu:=getmenu(wm.gdi.hwnd)\nfi\n\nif enable.defined then\n\treturn enablemenuitem(hmenu,id,(enable|0|mf_greyed)+mf_bycommand)\nelse\n\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_greyed|0|1)\nfi\nend\n\nfunc gxcheckmb(wm,id,check)=\nif wm.ispointer then\t\t\t\t!assume handle\n\thmenu:=wm\nelse\n\thmenu:=getmenu(wm.gdi.hwnd)\nfi\n\nif check.defined then\n\treturn checkmenuitem(hmenu,id,(check|mf_checked|mf_unchecked)+mf_bycommand)\nelse\n\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_checked|1|0)\nfi\nend\n\nproc gxclosemb(m)=\ndestroymenu(m)\nend\n\nexport func gxconfirm(m)=\nx:=gxmsgbox(m,\"Confirm\",\"byn\")\nreturn x=\"yes\"\nend\n\nfunc issubwindow(w,w2)=\nwhile w2 do\n\tif w2==w then return 1 fi\n\tw2:=w2.owner\nod\nreturn 0\nend\n\nexport proc flushmessages=\n\nend\n",
    
(byte*)"VAR DEBUG=0\n\nimportdll imglib =\n    func imgload_rgb\t\t(stringz, ref byte, ref byte, ref byte, int32)ref byte\n\n    func imgload_bgr\t\t(stringz, ref int32, ref int32, ref int32, int32)ref byte\n\n!    func nanoloadjpeg\t\t(stringz, ref int32, ref int32, ref int32)ref byte\n!    func loadjpegm\t\t\t(stringz, ref int64, ref int64, ref int64)ref byte\n\n    proc          imgload_free\t\t(ref byte)\n    func imgsave_jpeg_rgb\t(stringz, ref byte, int32, int32, int32)int32\n    func imgsave_jpeg_bgr\t(stringz, ref byte, int32, int32, int32)int32\nend\n\nimportdll jpeg =\n    func loadjpegm\t\t\t(stringz, ref int64, ref int64, ref int64)ref byte\nend\n\ntype bmpheader = struct\n\tws_bitmapfileheader fh\n\tws_bitmapinfoheader bh\nend\n\nvar\tshifts=[2:1, 4:2, 8:3, 16:4, 32:5, 64:6]\n\nproc main=\n\n!\tCPL \"TESTING BMMAIN NEW\"\n!\tFILE:=\"C:/JPEG/girl.jpg\"\n!\tFILE:=\"C:/JPEG/girl.png\"\n!\tFILE:=\"C:/JPEG/fifteen.png\"\n\tFILE:=\"C:/JPEG/CARD2.jpg\"\n!\tFILE:=\"C:/JPEG/MONA.jpg\"\n!\n\tBM:=BMLOAD(FILE)\n!\tCPL =BM.TYPE\n!\tCPL =BM\n!\tIF NOT BM THEN STOP FI\n!\n!\tBMSAVE(\"freddy.jpg\", BM)\n!\n\n!\tw:=640\n!\th:=480\n!\tw:=640\n!\th:=48\n!\n!\tbm:=bmcreate(8,w,h)\n!!\tgxclear(bm, 0xFF7FFF)\n!\n!\tgxtext(bm,\"Hello, World\")\n!\tfor y:=0 to h-1 do\n!\t\tfor x:=0 to w-1 do\n!\t\t\tc:=0x00'FF'00\n!!\t\t\tgxpixel(bm,x,y,c<<16+c<<8+c)\n!\t\t\tgxpixel(bm,x,y,c)\n!\t\tod\n!\tod\n!\t\n\n!\tbm2:=bmtopal(bm)\n!\tbm2:=bmrgb24torgb32(bm)\n!\tbm2:=bmtogrey(bm,8)\n!\tbm2:=bmtogrey(bm,24)\n!\tbm2:=bmdupl(bm)\n\n!BM2.PALTYPE:=COLOUR_PAL\n!BMRESETPALETTE(BM2)\n!CPL =BM2.PIXELBITS\n!\tBMSAVE(\"PALA.PPM\",BM2)\n!\tBMSAVE(\"FRED.bmp\",BM2)\n!\tBMSAVE(\"PALB.PPM\",BM2,1)\n\n\n!\tCPL \"LOADED\"\n!\tSTOP\n\n\tw:=GXCREATEWINDOW(DIM:(960,540),caption:\"HI THERE\")\n!\tgxcopy(w,bm,scalex:0.25)\n!\tgxcopy(w,bm,scalex:0.5)\n!\tgxcopy(w,bm,scalex:5.0, x:100)\n!\tgxcopy(w,bm,scalex:2.0, x:100)\n!\tgxcopy(w,bm)\n\tgxcopy(w,bm)\n\teventloop()\n\nend\n\nexport func bmcreate(pixelbits,width,height)=\n!create new bitmap with given specs, return handle to bitmap (=rwindow ref)\n!when maskptr<>nil, set up mask values\n\n\tbminfo:=new(ws_bitmapv5header)\n\tbminfo.size:=ws_bitmapv5header.bytes\n\tbminfo.width:=width\n\tbminfo.height:=-height\n\tbminfo.planes:=1\n\tbminfo.bitcount:=pixelbits\n\n\tpixelptr:=nil\n\n\tif pixelbits not in [8,24,32] then\n\t\tabort(\"bmcreate pixel size not supported:\"+tostr(pixelbits))\n\tfi\n\n!\thwnd:=createdibsection(screendc,&bminfo,0,&pixelptr,0,0)\n\n!CPL =BMINFO.BYTES\n!CPL =WS_BITMAPV5HEADER.BYTES\n!CPL =BMINFO.SIZE\n!CPL =BMINFO.WIDTH\n!CPL =BMINFO.HEIGHT\n!CPL =BMINFO.PLANES\n!CPL =BMINFO.BITCOUNT\n\n\thwnd:=createdibsection(nil,&bminfo,0,&pixelptr,nil,0)\n\n\tpixelptr:=makeref(pixelptr,byte)\n\n\tif hwnd=0 then\n\t\terror:=getlasterror()\n\t\tabort(\"bmcreate:CreateDIB failed:\"+tostr(error))\n\tfi\n\n!now create a bm record based around this handle\n\n\tbm:=new(rwindow,0)\n\tbm.windclass:=bitmap_class\n\n\tbm.dimx:=width\n\tbm.dimy:=abs(height)\t\t!neg height used for top-down bitmaps\n\n\tbm.style:=defstyle\n\n\tbm.pixelbits:=pixelbits\n\tbm.pixelptr:=pixelptr\n\n!set bytes per pixel\n\tbm.pixelbytes:=pixelbits%8\n\n!set bytes per scanline\n\tn:=bm.pixelbytes*width\n\n!n must be a multiple of 4 bytes\n\tif (n iand 3)<>0 then\t!make bytes a multiple of 4\n\t\tn:=(n+4) iand 0xfffc\n\tfi\n\tbm.linebytes:=n\n\tbm.framebytes:=bm.linebytes*bm.dimy\n\n!set palette colours, using winrgb order\n\tif pixelbits=8 then\n\t\tpalette:=new(array,int32,0..255)\n\t\tbm.paltype:=greyscale_pal\n\t\tcolour:=0\n\t\tfor i:=0 to 255 do\n\t\t\tpalette[i]:=colour\n\t\t\tcolour+:=0x10101\n\t\tod\n\tfi\n\n\tsetupgdi(bm,hwnd)\n\n\tbm.gdi.hdc:=createcompatibledc(nil)\n\tbm.gdi.drawmode:=dm_memory\n\tbm.gdi.oldbmobj:=selectobject(bm.gdi.hdc,hwnd)\t!should store original bitmap\n\tsetstretchbltmode(bm.gdi.hdc,4)\t\t\t!average pixels for best result\n\n\tbmputpalette(bm,palette)\n\n\treturn bm\nend\n\nexport func bmgetpalette(bm)=\n!extract entire palette to p, in bmrgb order\n\tif bm.paltype then\n\t\tpalette:=new(array,int32,0..256)\n\t\tgetdibcolortable(bm.gdi.hdc,0,256,&palette)\n\t\tpalette[256]:=bm.paltype\n\t\treversepalette(palette)\n\telse\n\t\tpalette:=()\n\tfi\n\treturn palette\nend\n\nexport proc bmputpalette(bm,p,reverse=1)=\n!update entire palette from p, in bmrgb order\n\tif bm.paltype then\n\t\tif reverse then reversepalette(p) fi\t\t!fix colours\n\t\tsetdibcolortable(bm.gdi.hdc,0,256,&p)\t!store\n\t\tif reverse then reversepalette(p) fi\t\t\t!restore orignal palette\n\t\tif p.upb=256 then\n\t\t\tbm.paltype:=p[256]\n\t\tfi\n\tfi\nend\n\nexport func bmcolour(bm,n,?colour)=\n!get/set palette info:\n!n=given:\n! colour given: update colour entry\n! colour omitted(-1): return colour value\n\n\tif colour.isdef then\t\t!set colour\n\t\tcolour:=revpixel(colour)\n\t\tsetdibcolortable(bm.gdi.hdc,n,1,&colour)\n\t\treturn colour\n\telse\t\t\t\t!get colour\n\t\tcolour:=0\n\t\tgetdibcolortable(bm.gdi.hdc,n,1,&colour)\n\t\treturn revpixel(colour)\n\tfi\nend\n\nexport proc reversepalette(&p)=\n!reverse values of 32-bit colour data at p\n\tfor i:=0 to 255 do\n\t\tp[i]:=revpixel(p[i])\n\tod\nend\n\nexport func revpixel(a)=\n!change rgb to bgr\n!windows colours use red in lsb, bitmaps use blue in lsb, in 24-bit pixels and palette colours\nreturn (a iand 0x00ff00) ior (a>>16 iand 255) ior ((a iand 255)<<16)\nend\n\nexport proc bmshow(bm)=\n\tgxcopy(bm)\nend\n\nexport proc bmfree(bm)=\n\treturn when bm=nil\n\tif not deletedc(bm.gdi.hdc) then\n\t\tpcerror(\"ERROR DELETING BM/HDC\")\n\tfi\n\n\tif not deleteobject(bm.gdi.hwnd) then\n\t\tpcerror(\"ERROR DELETING DIB\")\n\tfi\nend\n\nexport func bmdupl(bm)=\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\n\tmemcpy(newbm.pixelptr, bm.pixelptr, bm.linebytes*bm.dimy)\n\n\tbmduplpalette(newbm,bm)\n\n\treturn newbm\nend\n\nexport proc bmduplpalette(newbm,bm)=\n\tif bm.paltype then\n\t\tpal:=bmgetpalette(bm)\n\t\tbmputpalette(newbm,pal)\n\t\tnewbm.paltype:=bm.paltype\n\tfi\nend\n\nexport func bmduplz(bm)=\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\n\treturn newbm\nend\n\nexport func bmgetptr(bm,x,y)=\n!return byte pointer to given pixel\n\treturn bm.pixelptr+(bm.linebytes*y+x*bm.pixelbytes)\nend\n\nexport func bmgetrowptr(bm,y)=\n\treturn bm.pixelptr+y*bm.linebytes\nend\n\nfunc getcbbitmap(hwnd)=\n\n\tp:=globallock(hwnd)\n\thsize:=ws_bitmapinfoheader.bytes\n\tbm:=nil\n\n\tif p then\n\t\tp:=makeref(p,ws_bitmapinfoheader)\n\t\tpb:=makeref(p,byte)\n\n\t\tbm:=bmcreate(p^.bitcount,p^.width,p^.height)\n\t\toffset:=(bm.paltype|1024|0)\t\t!offset due to palette table\n\n\t\tif offset then\n\t\t\tsetdibcolortable(bm.gdi.hdc,0,256,pb+hsize)\n\t\tfi\n\n\t\tpb:=pb+hsize+offset\n\t\tfor y:=0 to bm.dimy-1 do\n\t\t\tq:=bmgetrowptr(bm,bm.dimy-y-1)\n\t\t\tmemcpy(q,pb,bm.linebytes)\n\t\t\tpb:=pb+bm.linebytes\n\t\tod\n\n\tfi\n\n\tglobalunlock(hwnd)\n\n\treturn bm\nend\n\nexport func bmgetclipboard=\n!get image from clipboard if one is there, otherwise return nil\n\tif openclipboard(nil)=0 then\n\t\treturn nil\n\tfi\n\n\thwnd:=getclipboarddata(cf_dib)\n\n\tbm:=nil\n\tif hwnd then\n\t\tbm:=getcbbitmap(hwnd)\n\tfi\n\n\tcloseclipboard()\n\n\treturn bm\nend\n\nexport func bmputclipboard(bm)=\n\tif openclipboard(0)=0 then\n\t\treturn nil\n\tfi\n\n\temptyclipboard()\n\n\thwnd:=putcbbitmap(bm)\n\tif hwnd then\n\t\tsetclipboarddata(cf_dib,hwnd)\n\tfi\n\n\tcloseclipboard()\n\treturn 1\nend\n\nfunc putcbbitmap(bm)=\n\thsize:=ws_bitmapinfoheader.bytes\n\tpsize:=(bm.paltype|1024|0)\n\tfsize:=bm.linebytes*bm.dimy\n\n\thmem:=globalalloc(0,hsize+psize+fsize)\n\tmem:=makeref(globallock(hmem),byte)\n\n\thdr:=new(ws_bitmapinfoheader)\n\thdr.size:=hsize\n\thdr.width:=bm.dimx\n\thdr.height:=bm.dimy\n\thdr.bitcount:=bm.pixelbits\n\thdr.planes:=1\n\thdr.xpelspermetre:=11811\n\thdr.ypelspermetre:=11811\n\thdr.clrused:=0\n\n\tmemcpy(mem,&hdr,hsize)\n\n\tif psize then\n\t\tpal:=bmgetpalette(bm)\n\t\tmemcpy(mem+hsize,&pal,psize)\n\tfi\n\n\tmem:=mem+hsize+psize\n\tfor y:=0 to bm.dimy-1 do\n\t\tp:=bmgetrowptr(bm,bm.dimy-1-y)\n\t\tmemcpy(mem, p, bm.linebytes)\n\t\tmem:=mem+bm.linebytes\n\tod\n!\tmemcpy(mem+hsize+psize,bm.pixelptr,fsize)\n\tglobalunlock(hmem)\n\n\treturn hmem\nend\n\nproc copy24to8(newbm,oldbm)=\n!both images are same size. Copy 1st plane of 24-bit oldbm to 8-bit newbm\n\tfor y:=0 to oldbm.dimy-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(oldbm,y)\n\t\tto oldbm.dimx do\n\t\t\tp++^:=q^\n\t\t\tq:=q+3\n\t\tod\n\tod\nend\n\n!proc copy8to24(newbm,oldbm)=\n!!both images are same size. Copy only plane of 8-bit oldbm to all planes of 24-bit newbm\n!\tfor y:=0 to oldbm.dimy-1 do\n!\t\tp:=bmgetrowptr(newbm,y)\n!\t\tq:=bmgetrowptr(oldbm,y)\n!\t\tto oldbm.dimx do\n!\t\t\tp++^:=q^\n!\t\t\tq:=q+3\n!\t\tod\n!\tod\n!end\n\nexport proc bmresetpalette(bm)=\n# set palette back to greyscale\n\tpal:=new(array,int32,0..256)\n\tcolour:=0\n\tfor i:=0 to 255 do\n\t\tpal[i]:=colour\n\t\tcolour+:=0x010101\n\tod\n\tbmputpalette(bm,pal)\n\tbm.paltype:=greyscale_pal\nend\n\nfunc makescalemap(x)=\n!x=0..1; create 256-element lookup table to multiply 0..255 by x\n\tmap:=new(list,0..255)\n\tfor i:=0 to 255 do\n\t\tmap[i]:=clamp(int(round(i*x)),0,255)\n\tod\n\treturn map\nend\n\nfunc bmunimpl(mess)=\n!ABORT(\"UNIMPLEMENTED: \"+MESS)\nPRINTLN \"UNIMPLEMENTED:\",MESS\nPRINTLN \"ABORTING\"\nSTOP\nreturn 0\nend\n\n!===========================================================================\n!========= HANDLERS\n!===========================================================================\n\nexport func bmload(filename)=\n!CPL \"BMLOAD:\",FILENAME\n\tcase e:=convlc(extractext(filename))\n\twhen \"jpg\",\"jpeg\" then\n\t\treturn bmloadjpg(filename)\n\twhen \"bmp\" then\n\t\treturn bmloadbmp(filename)\n!\twhen \"pgm\" then\n!\t\treturn bmloadpgm_p2p5(filename)\n\twhen \"ppm\",\"pgm\" then\n\t\treturn bmloadppm_p3p6(filename)\n\twhen \"png\" then\n\t\treturn bmloadpng(filename)\n\twhen \"\" then\t\t\t\t!try all\n\t\texts:=(\"jpg\",\"bmp\",\"pgm\",\"ppm\",\"png\")\n\t\tfor ext in exts do\n\t\t\tbm:=bmload(addext(filename,ext))\n\t\t\tif bm then\n\t\t\t\treturn bm\n\t\t\tfi\n\t\tod\n\t\treturn nil\n\telse\n\t\tprintln \"CAN'T LOAD\",E,\"IMAGE\"\n\t\treturn nil\n\tesac\n\treturn nil\nend\n\nfunc bmloadbmp(filename)=\n\tf:=openfile(filename)\n\tif not f then return nil fi\n\n\tfileheader:=new(bmpheader)\n\n\treadrandom(f,&fileheader,0,bmpheader.bytes)\n\tfiledimx:=fileheader.bh.width\n\tfiledimy:=fileheader.bh.height\n\tinvert:=1\n\tif filedimy<0 then\n\t\tfiledimy:=abs(filedimy)\n\t\tinvert:=0\n\tfi\n\n\tif fileheader.fh.typex<>'BM' then\n\t\tclosefile(f)\n\t\treturn nil\n\tfi\n\n\tif fileheader.bh.compression<>0 then\n\t\tclosefile(f)\n\t\treturn nil\n\tfi\n\n\tbm:=bmcreate(fileheader.bh.bitcount,filedimx,filedimy)\n\tframebytes:=bm.linebytes*filedimy\n\n\tif bm.paltype then\n\t\tpalette:=new(array,int32,0..255)\n\t\treadrandom(f,&palette,bmpheader.bytes,1024)\n\t\tbmputpalette(bm,palette,0)\n\t\tcolour:=0\n\t\tfor i:=0 to 255 do\n\t\t\tif palette[i]<>colour then\n\t\t\t\tbm.paltype:=colour_pal\n\t\t\t\texit\n\t\t\tfi\n\t\t\tcolour+:=0x010101\n\t\tod\n\n\tfi\n\n\treadrandom(f,bm.pixelptr,fileheader.fh.offbits,framebytes)\n\tclosefile(f)\n\n\n\tif invert then\n\t\tn:=bm.linebytes\n\t\tbuffer:=makeref(malloc(n),byte)\n\n\t\tfor y:=0 to filedimy%2 do\n\t\t\tp:=bmgetrowptr(bm,y)\n\t\t\tq:=bmgetrowptr(bm,filedimy-1-y)\n!\n\t\t\tmemcpy(buffer,p,n)\n\t\t\tmemcpy(p,q,n)\n\t\t\tmemcpy(q,buffer,n)\n\t\tod\n\t\tfree(buffer)\n\tfi\n\n\treturn bm\nend\n\nexport func bmloadjpg(filename)=\n\tw:=h:=n:=0\n\nCPL \"LOADJ1\"\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\tp:=loadjpegm(filename,&w,&h,&n);\n!\tp:=nanoloadjpeg(filename,&w,&h,&n)\n\n\n!\tp:=imgload_bgr(filename,&w,&h,&n)\nCPL \"LOADJ2\",=P, W,H,N\n\tIF P=NIL THEN PCERROR(\"CAN'T LOAD JPG\") FI\n\n\tpixelbits:=n*8\n\n\tif p=nil then\n\t\treturn nil\n\tfi\n\n\tq:=makeref(p,byte)\n\n\tbm:=bmcreate(pixelbits,w,h)\n\n\tnbytes:=w*h*n\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(dest,q,w*n)\n\t\tdest:=dest+bm.linebytes\n\t\tq:=q+w*n\n\tod\n\n!\timgload_free(p)\n\n\treturn bm\nend\n\nfunc bmloadpbm_p1p4(filename)=\nCPL \"CAN'T LOAD PBM\"\nRETURN NIL\n!return bmunimpl(\"bmloadpbm\")\nend\n\nfunc bmloadpgm_p2p5(filename)=\n\nCPL \"LOAD PGM P25\",FILENAME\n\tf:=openfile(filename,\"rb\")\n\tif f=0 then return nil fi\n\n\treadln @f, sig:\"s\"\n\n!CPL =SIG\n\tcase sig\n\twhen \"P5\" then\n\t\tbinary:=1\n\twhen \"P2\" then\n\t\tbinary:=0\n\telse\n\t\tabort(\"Can't read pgm\")\n\t\treturn nil\n\tesac\t\n\n\twidth:=readnextint(f)\n\theight:=readnextint(f)\n\tmaxpix:=readnextint(f)\n\n\tbm:=bmcreate(8,width,height)\n\n\tlinebytes:=width\n\tdest:=makeref(bm.pixelptr,byte)\n\nCPL =WIDTH,=HEIGHT, LINEBYTES,=BM\n\tto height do\n\t\tif binary then\n\t\t\treadbytes(f,dest,width)\t\t\t!will be bgr\n\t\telse\n\t\t\tp:=dest\n\t\t\tto linebytes do\n\t\t\t\tp++^:=readffint(f)\n\t\t\tod\n\t\tfi\n\n\t\tdest:=dest+bm.linebytes\n\tod\n\n\tclosefile(f)\n\n\treturn bm\nend\n\nfunc bmloadppm_p3p6(filename)=\n!read p6 ppm which is binary 24-bit, but will also recognise other formats\n\n!CPL \"P3P6\"\n\tf:=openfile(filename,\"rb\")\n\tif f=0 then return nil fi\n\n\treadln @f, sig:\"s\"\n\n!CPL =SIG\n\tcase sig\n\twhen \"P6\" then\n\t\tbinary:=1\n\twhen \"P3\" then\n\t\tbinary:=0\n\twhen \"P5\",\"P2\" then\n\t\tclosefile(f)\n\t\treturn bmloadpgm_p2p5(filename)\n!\twhen \"P4\",\"P1\" then\n!\t\tclosefile(f)\n!\t\treturn bmloadpbm_p1p4(filename)\n\telse\n\t\tabort(\"Can't read ppm:\"+sig)\n\t\treturn nil\n\tesac\t\n\n!CPL \"READING P6/P3 PPM\"\n\n\twidth:=readnextint(f)\n\theight:=readnextint(f)\n\tmaxpix:=readnextint(f)\n\n\tbm:=bmcreate(24,width,height)\n\n\tlinebytes:=width*3\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto height do\n\t\tif binary then\n\t\t\treadbytes(f,dest,linebytes)\t\t\t!will be bgr\n\t\telse\n\t\t\tp:=dest\n\t\t\tto linebytes do\n\t\t\t\tp++^:=readffint(f)\n\t\t\tod\n\t\tfi\n\n\t\tp:=dest\t\t\t\t\t\t\t\t!convert to rgb\n\t\tto width do\n\t\t\tswap(p^,(p+2)^)\n\t\t\tp:=p+3\n\t\tod\n\n\t\tdest:=dest+bm.linebytes\n\tod\n\n\tclosefile(f)\n\n\treturn bm\nend\n\nfunc readnextint(f)=\n\tread x\n\twhile not x.isint and not eof(f) do\n\t\treadln @f,x\n\tod\n\tif not x.isint then return 0 fi\n\treturn x\nend\n\nfunc readffint(f)=\n!read next free-format int from f\n\trepeat\n\t\tc:=inbyte(f)\n\tuntil c in '0'..'9'\n\n\ta:=c-'0'\n\tdo\n\t\tc:=inbyte(f)\n\t\tif c in '0'..'9' then\n\t\t\ta:=a*10+c-'0'\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\n\treturn a\nend\n\nfunc bmloadpng(filename)=\n\tw:=h:=n:=0\n\nCPL \"LOADP1\"\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\n\tp:=imgload_bgr(filename,&w,&h,&n,0)\n\n!\tp:=nanoloadjpeg(filename,&w,&h,&n)\n\n\n\n!\tp:=imgload_bgr(filename,&w,&h,&n)\nCPL \"LOADP2\",=P, W,H,N\n\n\tpixelbits:=n*8\n\n\tif p=nil then\n\t\treturn nil\n\tfi\n\n\tq:=makeref(p,byte)\n\n\tbm:=bmcreate(pixelbits,w,h)\n\n\tnbytes:=w*h*n\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(dest,q,w*n)\n\t\tdest:=dest+bm.linebytes\n\t\tq:=q+w*n\n\tod\n\n\timgload_free(p)\n\n\treturn bm\nend\n\nexport func bmsave(filename,bm,binary=0)=\n\tcase e:=convlc(extractext(filename))\n\twhen \"jpg\",\"jpeg\" then\n\t\treturn bmsavejpg(filename,bm)\n\twhen \"bmp\" then\n\t\treturn bmsavebmp(filename,bm)\n\twhen \"ppm\",\"pgm\" then\n\t\treturn bmsaveppm_p3p6(filename,bm,binary)\n\telse\n\t\tprintln \"CAN'T SAVE\",E,\"IMAGE\"\n\t\treturn nil\n\tesac\n\treturn nil\nend\n\nfunc bmsavebmp(filename,bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tpixelbytes:=bm.pixelbytes\n\tframebytes:=bm.linebytes*h\n\tpalettebytes:=(pixelbytes=1|1024|0)\n\n\tbmfile:=createfile(filename)\n\tif bmfile=nil then\n\t\treturn 0\n\tfi\n\n\tfileheader:=new(bmpheader)\n\n\tfileheader.fh.typex:='BM'\n\tfileheader.fh.offbits:=bmpheader.bytes+palettebytes\n\tfileheader.fh.size:=fileheader.fh.offbits+framebytes\n\tfileheader.bh.size:=ws_bitmapinfoheader.bytes\n\tfileheader.bh.width:=bm.dimx\n\tfileheader.bh.height:=-bm.dimy\n\tfileheader.bh.bitcount:=bm.pixelbits\n\tfileheader.bh.planes:=1\n\tfileheader.bh.xpelspermetre:=11811\t\t!300 dpi\n\tfileheader.bh.ypelspermetre:=11811\n\tfileheader.bh.clrused:=0\n\n\twriterandom(bmfile,&fileheader,0,bmpheader.bytes)\n\n\tif palettebytes then\n\t\tpalette:=bmgetpalette(bm)\n\t\treversepalette(palette)\n\t\twriterandom(bmfile,&palette,bmpheader.bytes,palettebytes)\n\tfi\n\n\twriterandom(bmfile,bm.pixelptr,fileheader.fh.offbits,framebytes)\n\n\treturn closefile(bmfile)\nend\n\nfunc bmsavejpg(filename,bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tpixelbytes:=bm.pixelbytes\n\tlinebytes:=bm.linebytes\n\n\tp:=q:=malloc(pixelbytes*w*h)\n\n\ts:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(q,s,w*pixelbytes)\n\t\tq:=q+bm.linebytes\n\t\ts:=s+w*pixelbytes\n\tod\n\n\tstatus:=imgsave_jpeg_bgr(filename,p,w,h,pixelbytes)\n\n\tfree(p)\n\n\treturn status\nend\n\nfunc bmsavepbm_p1p4(filename,bm,binary)=\nreturn bmunimpl(\"bmsaveppm-1bit\")\nend\n\nfunc bmsavepgm_p2p5(filename,bm,binary)=\n\twidth:=bm.dimx\n\theight:=bm.dimy\n\n\tf:=createfile(filename)\n\n\tCPL \"WRITEPGM\",filename\n\n\tif not f then return 0 fi\n\n\tprintln @f,(binary|\"P5\"|\"P2\")\n\tprintln @f,width,height\n\tprintln @f,\"255\"\n\n\tbuffer:=data\n\n\tbuffer:=malloc(bm.linebytes)\n\tif buffer=nil then return 0 fi\n\tbuffer:=makeref(buffer,byte)\n\n\tlinebytes:=width\t\t\t!also number of values per line when in text mode\n\n\tfor y:=0 to height-1 do\n\t\tmemcpy(buffer,bmgetrowptr(bm,y),linebytes)\n\t\tif binary then\n\t\t\twritebytes(f,buffer,linebytes)\n\t\telse\n\t\t\tp:=buffer\n\t\t\tto linebytes do\n\t\t\t\tprint @f,p++^,,\" \"\n\t\t\tod\n\t\t\tprintln @f\n\t\tfi\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nfunc bmsaveppm_p3p6(filename,bm,binary)=\n!\treturn bmunimpl(\"bmsaveppm\")\n\n\tcase bm.pixelbits\n\twhen 24 then\n\twhen 8 then\n\t\treturn bmsavepgm_p2p5(filename,bm,binary)\n\telse\n\t\treturn 0\n\tesac\n\n\twidth:=bm.dimx\n\theight:=bm.dimy\n\n\tf:=createfile(filename)\n\n\tCPL \"WRITEPPM\",filename\n\n\tif not f then return 0 fi\n\n\tprintln @f,(binary|\"P6\"|\"P3\")\n\tprintln @f,width\n\tprintln @f,height\n\tprintln @f,\"255\"\n\n\tbuffer:=data\n\n\tbuffer:=malloc(bm.linebytes)\n\tif buffer=nil then return 0 fi\n\tbuffer:=makeref(buffer,byte)\n\n\tlinebytes:=width*3\t\t\t!also number of values per line when in text mode\n\n\tfor y:=0 to height-1 do\n\t\tmemcpy(buffer,bmgetrowptr(bm,y),linebytes)\n\t\tp:=buffer\t\t\t\t\t!convert to bgr\n\t\tto width do\n\t\t\tswap(p^,(p+2)^)\n\t\t\tp:=p+3\n\t\tod\n\t\tif binary then\n\t\t\twritebytes(f,buffer,linebytes)\n\t\telse\n\t\t\tp:=buffer\n\t\t\tto linebytes do\n\t\t\t\tprint @f,p++^,,\" \"\n\t\t\tod\n\t\t\tprintln @f\n\t\tfi\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nexport func bmrotate(bm, angle)=\n\tcase angle\n\twhen 0 then return bmdupl(bm)\n\twhen -90 then return bmrotleft90(bm)\n\twhen +90 then return bmrotright90(bm)\n\twhen 180 then return rot180(bm)\n\tesac\n\treturn bmunimpl(\"bmrotate by \"+tostr(angle))\nend\n\nexport func bmrotleft90(bm)=\n\tcase bm.pixelbits\n\twhen 8 then return rotleft90_8(bm)\n\twhen 24 then return rotleft90_24(bm)\n\twhen 32 then return bmunimpl(\"ROTLEFT90/32\")\n\tesac\n\treturn nil\nend\n\nexport func bmrotright90(bm)=\n\tcase bm.pixelbits\n\twhen 8 then return rotright90_8(bm)\n\twhen 24 then return rotright90_24(bm)\n\twhen 32 then return bmunimpl(\"ROTRIGHT90/32\")\n\tesac\n\treturn nil\nend\n\nexport func rot180(bm)=\n\tnewbm1:=bmfliphoz(bm)\n\tnewbm2:=bmflipvert(newbm1)\n\tbmfree(newbm1)\n\treturn newbm2\nend\n\nfunc rotleft90_8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tlinebytes:=bm.linebytes\n\n\tnewbm:=bmcreate(8,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,w-y-1,0)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n!\t\t\tq:=q+w\n\t\t\tq:=q+linebytes\n\t\tod\n\tod\n\n\tbmduplpalette(newbm,bm)\n\treturn newbm\nend\n\nfunc rotright90_8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tlinebytes:=bm.linebytes\n\n\tnewbm:=bmcreate(8,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,y,h-1)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tq:=q-linebytes\n\t\tod\n\tod\n\n\tbmduplpalette(newbm,bm)\n\treturn newbm\nend\n\n!function rotleft90_24(bm)=\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\n!\n!\txform:=new(array,ws_point,3)\n!\txform[1].y:=bm.dimx\n!\txform[3].x:=bm.dimy\n!\txform[3].y:=bm.dimx\n!\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\n!\n!\treturn newbm\n!end\n\nfunc rotleft90_24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,w-y-1,0)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tp++^:=(q+1)^\n\t\t\tp++^:=(q+2)^\n\t\t\tq:=q+bm.linebytes\n\t\tod\n\tod\n\n\treturn newbm\nend\n\n!function rotright90_24(bm)=\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\n!\n!\txform:=new(array,ws_point,3)\n!\txform[1].X:=bm.dimy\n!\txform[2].x:=bm.dimy\n!\txform[2].y:=bm.dimx\n!\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\n!\n!\treturn newbm\n!end\n\nfunc rotright90_24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,y,h-1)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tp++^:=(q+1)^\n\t\t\tp++^:=(q+2)^\n\t\t\tq:=q-bm.linebytes\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc rotate8(bm,angle)=\nreturn bmunimpl(\"rotate8\")\nend\n\nexport func bmfliphoz(bm)=\n\tcase bm.pixelbytes\n    when 1 then return fliphoz8(bm)\n    when 3 then return fliphoz24(bm)\n    when 4 then return fliphoz32(bm)\n\tesac\n\treturn nil\nend\n\nfunc fliphoz8(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=p+w-1\n\t\tfor x:=0 to w%2 do\n\t\t\tt:=p^\n\t\t\tp^:=q^\n\t\t\tq^:=t\n\t\t\t++p; --q\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc fliphoz24(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tmemcpy(buffer,p,bm.linebytes)\n\t\tq:=buffer+(w-1)*3\n\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q^\n\n\t\t\tq:=q-5\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc fliphoz32(bm)=\nreturn bmunimpl(\"fliphoz_32\")\nend\n\nexport func bmflipvert(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tn:=bm.linebytes\n\tbuffer:=makeref(malloc(n),byte)\n\n\tfor y:=0 to h%2 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(newbm,h-1-y)\n!\n\t\tmemcpy(buffer,p,n)\n\t\tmemcpy(p,q,n)\n\t\tmemcpy(q,buffer,n)\n\tod\n\tfree(buffer)\n\n\treturn newbm\nend\n\nexport func bmrepeat(bm,cols,rows)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(bm.pixelbits, w*cols, h*rows)\n\tlinebytes:=bm.linebytes\n\n\tfor y:=0 to h-1 do\n\t\ts:=bmgetrowptr(bm,y)\n\t\tfor r:=0 to rows-1 do\n\t\t\tfor c:=0 to cols-1 do\n\t\t\t\tmemcpy(bmgetptr(newbm,c*w,r*h+y),s,linebytes)\n\t\t\tod\n\t\tod\n\tod\n\n\tif bm.pixelbits=8 then\n\t\tbmduplpalette(newbm,bm)\n\tfi\n\n\treturn newbm\nend\n\nexport func bmscale(bm, sx,?sy)=\n\tif sy.isvoid then sy:=sx fi\n\tcase bm.pixelbits\n\twhen 8 then return scalex8(bm,sx,sy)\n\twhen 24,32 then return scalex24(bm,sx,sy)\n\tesac\n\treturn nil\nend\n\nfunc scalex8(bm,sx,sy)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tneww:=int(round(w*sx))\n\tnewh:=int(round(h*sy))\n\n\tnewbm:=bmcreate(24, neww,newh)\n\treturn nil when not newbm\n\n\tbm24:=bmtorgb(bm,24)\n\n\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm24.gdi.hdc,0,0,w,h, srccopy)\n\n\tif bm.paltype=greyscale_pal then\n\t\tnewbm8:=bmgetplane(newbm,\"R\")\n\telse\n\t\tnewbm8:=bmtopal(newbm)\n\tfi\n\tbmfree(newbm)\n\n\treturn newbm8\nend\n\nfunc scalex24(bm,sx,sy)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tneww:=int(round(w*sx))\n\tnewh:=int(round(h*sy))\n\n\tif neww<8 or newh<8 then return nil fi\n\n\tnewbm:=bmcreate(bm.pixelbits, neww,newh)\n\tif newbm then\n\t\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm.gdi.hdc,0,0,w,h, srccopy)\n\tfi\n\n\treturn newbm\nend\n\nfunc bmscaleupi8(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi8\")\nend\n\nfunc bmscaleupi24(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi24\")\nend\n\nfunc bmscaleupi32(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi32\")\nend\n\nfunc bmscaledowni8(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni8\")\nend\n\nfunc bmscaledowni24(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni24\")\nend\n\nfunc bmscaledowni32(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni32\")\nend\n\nexport func bmneg(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tdx:=newbm.dimx-1\n\tdy:=newbm.dimy-1\n\tn:=newbm.linebytes\n\tdo32:=0\n\tif n rem 4=0 then\n\t\tdo32:=1\n\t\tn:=n%4\n\tfi\n\n\tfor y:=0 to dy do\n\t\tif do32 then\n\t\t\tp:=makeref(bmgetrowptr(newbm,y),int32)\n\t\t\tto n do\n\t\t\t\tp++^ := p^ ixor 0xFFFFFFFF\n\t\t\tod\n\t\telse\n\t\t\tp:= bmgetrowptr(newbm,y)\n\t\t\tto n do\n\t\t\t\tp++^ := p^ ixor 255\n\t\t\tod\n\t\tfi\n\tod\n\treturn newbm\nend\n\nexport func bmmap(bm,map, channels=\"RGB\")=\n\tif channels=\"\" then channels:=\"RGB\" fi\n\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn mapall(bm,map)\n\twhen 24 then\n\t\tif channels=\"RGB\" then\n\t\t\treturn mapall(bm,map)\n\t\tfi\n\t\treturn mapchan_24(bm,map,channels,0)\n\twhen 32 then\n\t\tif channels=\"RGBA\" then\n\t\t\treturn mapall(bm,map)\n\t\tfi\n\t\treturn mapchan_24(bm,map,channels,1)\n\tesac\n\n\treturn nil\nend\n\nfunc mapall(bm,map)=\n\tnewbm:=bmdupl(bm)\n\tp:=newbm.pixelptr\n\tto newbm.framebytes do\n\t\tp^:=map[p^]\n\t\t++p\n\tod\n\treturn newbm\nend\n\nfunc mapchan_24(bm,map,channels,alpha=0)=\n\tdored:=\"R\" in channels\n\tdogreen:=\"G\" in channels\n\tdoblue:=\"B\" in channels\n\tdoalpha:=\"A\" in channels\n\n\tnewbm:=bmdupl(bm)\n\n\tfor y:=0 to newbm.dimy-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto newbm.dimx do\n\t\t\tif doblue then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif dogreen then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif dored then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif alpha then\n\t\t\t\tif doalpha then p^:=map[p^] fi\n\t\t\t\t++p\n\t\t\tfi\n\t\tod\n\tod\n\n\treturn newbm\nend\n\n!function mapchan_32(bm,map,channels)=\n!return bmunimpl(\"mapchan_32\")\n!end\n\nexport func bmbright(bm,dx,channels=\"RGB\")=\n\treturn bmunimpl(\"bmbright\")\nend\n\nexport func bmcont(bm,x,channels=\"RGB\")=\n\treturn bmunimpl(\"bmcont\")\nend\n\nexport func bmgamma(bm,x,channels=\"RGB\")=\nreturn bmunimpl(\"bmgamma\")\nend\n\nexport func bmtogrey(bm,destbits=24)=\n\tif destbits=0 then destbits:=bm.pixelbits fi\n\tcase bm.pixelbits\n\twhen 8 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\treturn pal8togrey8(bm)\n\t\twhen 24 then\n\t\t\tcm:=pal8togrey8(bm)\n\t\t\tnewbm:=grey8torgb24(cm)\n\t\t\tbmfree(cm)\n\t\t\treturn newbm\n\t\tesac\n\twhen 24,32 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\treturn rgb24togrey8(bm)\n\t\twhen 24 then\n\t\t\tcm:=rgb24togrey8(bm)\n\t\t\tnewbm:=grey8torgb24(cm)\n\t\t\tbmfree(cm)\n\t\t\treturn newbm\n\t\tesac\n\tesac\nCPL =BM.PIXELBITS, =DESTBITS\n\treturn bmunimpl(\"bmtogrey bad combos\")\n\nend\n\nfunc pal8togrey8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\t(rmap, gmap, bmap):=getlumtables()\n\n\tnewbm:=bmcreate(8,w,h)\n\tpal:=bmgetpalette(bm)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tcolour:=pal[q++^]\n\t\t\tr:=colour.[0..7]\n\t\t\tg:=colour.[8..15]\n\t\t\tb:=colour.[16..23]\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc pal8togrey24(bm)=\nreturn bmunimpl(\"pal8togrey24\")\nend\n\nfunc rgb24togrey8(bm)=\n!does 24/32 bits\n\tqincr:=(bm.pixelbits=32|1|0)\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\t(rmap, gmap, bmap):=getlumtables()\n\n\tnewbm:=bmcreate(8,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tb:=q++^; g:=q++^; r:=q++^\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\n\t\t\tq:=q+qincr\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc rgb24togrey24(bm)=\nreturn bmunimpl(\"rgb24togrey24\")\nend\n\nexport func bmtorgb(bm,destbits=24)=\n\tif destbits=0 then destbits:=24 fi\n\tcase bm.pixelbits\n\twhen destbits then\n\t\treturn bmdupl(bm)\n\n\twhen 8 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\tbmunimpl(\"8 to 8 bits rgb\")\n\t\twhen 24 then\n\t\t\tif bm.paltype=greyscale_pal then\n\t\t\t\treturn grey8torgb24(bm)\n\t\t\telse\n\t\t\t\treturn paltorgb24(bm)\n\t\t\tfi\n\t\tesac\n\twhen 24 then\n\t\tif destbits=32 then\n\t\t\treturn bmrgb24torgb32(bm)\n\t\tfi\n\twhen 32 then\n\t\tif destbits=24 then\n\t\t\treturn bmrgb32torgb24(bm)\n\t\tfi\n\tesac\nCPL =BM.PIXELBITS, =DESTBITS\n\treturn bmunimpl(\"bmtorgb bad combos\")\nend\n\nfunc paltorgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,w,h)\n\tpal:=bmgetpalette(bm)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tcolour:=pal[q++^]\n\t\t\tr:=colour.[0..7]\n\t\t\tg:=colour.[8..15]\n\t\t\tb:=colour.[16..23]\n\n\t\t\tp++^:=b\n\t\t\tp++^:=g\n\t\t\tp++^:=r\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc grey8torgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tlum:=q++^\n\t\t\tp++^:=lum\n\t\t\tp++^:=lum\n\t\t\tp++^:=lum\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nexport func bmrgb24torgb32(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(32,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=128\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmrgb32torgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tq++\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmtopal(bm)=\n\tif bm.pixelbits=8 then return bmdupl(bm) fi\n\tqincr:=(bm.pixelbits=32)\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(8,w,h)\n\n\tpal:=new(array,int32,0..255)\n\n!create special palette mapping for rrrgggbb\n\tfor r:=0 to 7 do\n\t\tfor g:=0 to 7 do\n\t\t\tfor b:=0 to 3 do\n\t\t\t\tindex:=r<<5+g<<2+b\n!\t\t\t\tpal[index]:=r<<5+g<<13+b<<18\n\t\t\t\tpal[index]:=r<<5+g<<13+b<<22\n\t\t\tod\n\t\tod\n\tod\n\tbmputpalette(newbm,pal)\n\tbm.paltype:=colour_pal\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n!noise:=-16..16\n!noise:=-8..8\n\n\t\tto w do\n\t\t\tb:=q++^; g:=q++^; r:=q++^\n\n!\t\t\tr+:=clamp(random(noise),0,255)\n!\t\t\tg+:=clamp(random(noise),0,255)\n!\t\t\tb+:=clamp(random(noise),0,255)\n!\n\t\t\tp++^:=r>>5<<5 + g>>5<<2 + b>>6\n\t\t\tq:=q+qincr\n\t\tod\n\tod\n\n\treturn newbm\n\nend\n\nexport func bmsplittorgb(bm,greydest=1)=\n# split 24-bit bitmap into three separate 8-bit planes\n# return 3 new bitmaps in the order red, green, blue\n# return () on error\n# dogreyscale=1 for each image to have a greyscale palette. Otherwise\n# the red image will be shades of red, etc\n\n\tif bm.pixelbits<24 then\n\t\treturn ()\n\tfi\n\tchannels:=bm.pixelbytes\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tpal:=new(array,int32,0..255)\n\timages::=()\n\n\tfor offset:=channels-1 downto 0 do\n\n\t\tnewbm:=bmcreate(8,w,h)\n\n\t\tfor y:=0 to h-1 do\n\t\t\tq:=bmgetrowptr(bm,y)+offset\n\t\t\tp:=bmgetrowptr(newbm,y)\n\t\t\tto w do\n\t\t\t\tp++^:=q^\n\t\t\t\tq:=q+channels\n\t\t\tod\n\t\tod\n\n\t\tif not greydest then\n\t\t\tcolour:=0\n\t\t\tincr:=(3-offset|0x00'00'01,0x00'01'00,0x01'00'00|0x01'01'01)\n\t\t\tfor i:=0 to 255 do\n\t\t\t\tpal[i]:=colour\n\t\t\t\tcolour+:=incr\n\t\t\tod\n\t\t\tbmputpalette(newbm,pal)\n\t\t\tnewbm.paltype:=tinted_pal\n\t\tfi\n\n\t\timages append:=newbm\n\tod\n\n!image order is r,g,b, or a,r,g,b\n\tif images.len=4 then\n\t\treturn (images[2],images[3],images[4],images[1])\n\telse\n\t\treturn images\n\tfi\nend\n\nexport func bmsplittoyuv(bm)=\n# split 24-bit bitmap into three separate 8-bit planes\n# return 3 new bitmaps in the order y, u, v\n# return () on error\n\n\tneedfree:=0\n\tcase bm.pixelbits\n\twhen 24 then\n\twhen 32 then\n\t\tbm:=bmtorgb(bm,24)\n\t\tneedfree:=1\n\telse\n\t\treturn nil\n\tesac\n\n!get y plane first with existing routine\n\tgreybm:=bmtogrey(bm,8)\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n!equations used are:\n! u:=int(round(0.492*(b-y)+128)\n! v:=int(round(0.702*(r-y)+128)\n!b-y and r-y will be in range +/- 255\n\n\tumap:=new(list,-255..255)\n\tvmap:=new(list,-255..255)\n\tfor i:=-255 to 255 do\n\t\tumap[i]:=int(round(0.492*(i)+128))\n\t\tvmap[i]:=int(round(0.702*(i)+128))\n\tod\n\n\tubm:=bmcreate(8,w,h)\n\tvbm:=bmcreate(8,w,h)\n\tfor c:=1 to 2 do\n\t\tif c=1 then\n\t\t\toffset:=0\n\t\t\tmap:=umap\n\t\telse\n\t\t\toffset:=2\n\t\t\tmap:=vmap\n\t\tfi\n\n\t\tfor yy:=0 to h-1 do\n\t\t\tpy:=bmgetrowptr(greybm,yy)\n\t\t\tp:=bmgetrowptr(bm,yy)\t\t\t!point to bgr pixels in original\n\n\t\t\tpu:=bmgetrowptr(ubm,yy)\n\t\t\tpv:=bmgetrowptr(vbm,yy)\n\t\t\tto w do\n\t\t\t\ty:=py++^\n\t\t\t\tr:=(p+2)^\n\t\t\t\tb:=p^\n\t\t\t\tpu++^:=umap[b-y]\n!CPL =B,=Y,=PV,=VMAP.TYPE\n\t\t\t\tpv++^:=vmap[r-y]\n\n\t\t\t\tp:=p+3\n\t\t\tod\n\t\tod\n\tod\n\n!create special greyscale for u/v images, since point of zero colour\n!info has been offset to +128\n\tpal:=new(array,int32,0..256)\n\tcolour:=0\n\tpal[128]:=0\n\tfor i:=1 to 127 do\n\t\tcolour+:=0x020202\n\t\tpal [i+128]:=colour\n\t\tpal [128-i]:=colour\n\tod\n\tpal[256]:=uv_pal\n\tbmputpalette(ubm,pal)\n\tbmputpalette(vbm,pal)\n\n\tif needfree then\n\t\tbmfree(bm)\n\tfi\n\n\treturn (greybm,ubm,vbm)\nend\n\nexport func bmgetplane(bm,plane)=\n# plane is one of \"R\",\"G\",\"B\"\n# extract given plane of a 24-bit bitmaps into a single 8-bit greyscale image\n# Return new image\n\n\tincr:=bm.pixelbytes\n\tif plane.len<>1 or bm.pixelbytes<3 then\n\t\treturn nil\n\tfi\n\n\tcase asc(plane)\n\twhen 'R' then offset:=2\n\twhen 'G' then offset:=1\n\twhen 'B' then offset:=0\n\twhen 'A' then offset:=3\n\telse return nil\n\tesac\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(8,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)+offset\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q^\n\t\t\tq:=q+incr\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nexport func bmjoinrgb(redbm,greenbm,bluebm,alphabm=nil)=\n\n\tw:=redbm.dimx\n\th:=redbm.dimy\n\n\tnewbm:=bmcreate((alphabm|32|24),w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tr:=bmgetrowptr(redbm,y)\n\t\tg:=bmgetrowptr(greenbm,y)\n\t\tb:=bmgetrowptr(bluebm,y)\n\n\t\tif alphabm then\n\t\t\ta:=bmgetrowptr(alphabm,y)\n\t\t\tto w do\n\t\t\t\tp++^:=b++^\n\t\t\t\tp++^:=g++^\n\t\t\t\tp++^:=r++^\n\t\t\t\tp++^:=a++^\n\t\t\tod\n\t\telse\n\t\t\tto w do\n\t\t\t\tp++^:=b++^\n\t\t\t\tp++^:=g++^\n\t\t\t\tp++^:=r++^\n\t\t\tod\n\t\tfi\n\tod\n\n\treturn newbm\nend\n\nexport func bmjoinyuv(ybm,ubm,vbm)=\n# combine y, u, v separations into a single rgb image\n# return new bitmap, or nil\n\n\tif ybm.pixelbits<>8 then\n\t\treturn nil\n\tfi\n\n\tw:=ybm.dimx\n\th:=ybm.dimy\n\n\tv1425map:=new(list,0..255)\n\tv726map:=new(list,0..255)\n\tu395map:=new(list,0..255)\n\tu2032map:=new(list,0..255)\n\n\tfor i:=0 to 255 do\n\t\tv1425map[i]:=int(round(1.425*(i-128)))\n\t\tv726map[i]:=int(round(0.726*(i-128)))\n\t\tu395map[i]:=int(round(0.395*(i-128)))\n\t\tu2032map[i]:=int(round(2.032*(i-128)))\n\tod\n\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor yy:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,yy)\n\t\tqy:=bmgetrowptr(ybm,yy)\n\t\tqu:=bmgetrowptr(ubm,yy)\n\t\tqv:=bmgetrowptr(vbm,yy)\n\n!\t\tto w do\n\t\tFOR X:=0 TO W-1 DO\n\t\t\ty:=qy++^\n\t\t\tr:=y+v1425map[qv^]\n\t\t\tg:=y-u395map[qu^]-v726map[qv^]\n\t\t\tb:=y+u2032map[qu^]\n\t\t\t++qu\n\t\t\t++qv\n\t\t\tp++^:=clamp(b,0,255)\n\t\t\tp++^:=clamp(g,0,255)\n\t\t\tp++^:=clamp(r,0,255)\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmblur(bm,n)=\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn blur8(bm,n)\n\twhen 24 then\n\t\treturn blur24(bm,n)\n\twhen 32 then\n\t\treturn blur32(bm,n)\n\tesac\n\treturn nil\nend\n\nfunc blur8(bm,n)=\n\tshift:=shifts{n,1}\n\n\tnewbm:=bmdupl(bm)\n\tiblurhoz8(newbm,n)\n\n\tnewbm2:=rotleft90_8(newbm)\n\tiblurhoz8(newbm2,n)\n\n\tnewbm3:=rotright90_8(newbm2)\n\tbmfree(newbm)\n\tbmfree(newbm2)\n\n\tbmduplpalette(newbm3,bm)\n\treturn newbm3\nend\n\nfunc blur24(bm,n)=\n\t(r,g,b):=bmsplittorgb(bm)\n\n\tr2:=bmblur(r,n)\n\tg2:=bmblur(g,n)\n\tb2:=bmblur(b,n)\n\n\tnewbm:=bmjoinrgb(r2,g2,b2)\n\tbmfree(r2)\n\tbmfree(g2)\n\tbmfree(b2)\n\n\treturn newbm\nend\n\nfunc blur32(bm,n)=\nreturn bmunimpl(\"blur32\")\nend\n\nproc iblurhoz8(bm,n)=\n\tshift:=shifts{n,1}\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(bm,y)\n\t\tblurhelper(w-n-1, n, shift, p)\n\n!\t\tto w-n-1 do\n!\t\t\tsum:=0\n!\t\t\tq:=p\n!\t\t\tto n do\n!\t\t\t\tsum+:=q++^\n!\t\t\tod\n!\t\t\tp++^:=sum>>shift\n!\t\tod\n\tod\nend\n\nproc blurhelper(m, n, shift, p)=\n\tvar sum\n\tvar q\n\n\tto m do\n\t\tsum:=0\n\t\tq:=p\n\t\tto n do\n\t\t\tsum+:=q++^\n\t\tod\n\t\tp++^:=sum>>shift\n\tod\nend\n\nfunc blurhoz24(bm,n)=\nreturn bmunimpl(\"blurhoz24\")\nend\n\nfunc blurhoz32(bm,n)=\nreturn bmunimpl(\"blurhoz32\")\nend\n\nexport func bmsharpen(bm,n=0)=\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn sharpen8(bm,n)\n\twhen 24 then\n\t\treturn sharpen24(bm,n)\n\twhen 32 then\n\t\treturn sharpen32(bm,n)\n\tesac\n\treturn nil\nend\n\nexport func sharpen8(bm,n)=\n!blur in-place horizontally by averaging each set of n pixels\n!n must be multiple of 2 from 2 to 64\n!return new modified image\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmdupl(bm)\n\n\tfor y:=1 to h-2 do\n\t\tp:=bmgetptr(newbm,1,y)\n\n\t\tq:=bmgetptr(bm,1,y-1)\n\t\tr:=bmgetptr(bm,1,y)\n\t\ts:=bmgetptr(bm,1,y+1)\n\n\t\tto w-2 do\n!\t\t\tabcdefghij\n\t\t\ta:=(q-1)^\n\t\t\tb:=q^\n\t\t\tc:=(q+1)^\n\t\t\td:=(r-1)^\n\t\t\te:=r^\n\t\t\tf:=(r+1)^\n\t\t\tg:=(s-1)^\n\t\t\th:=s^\n\t\t\ti:=(s+1)^\n\n! a b c\n! d e f\n! g h i\n!\t\t\tsum:=e*4-b-d-f-h\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\n\n\t\t\tsum:=e*8-a-b-c-d-f-g-h-i\n\t\t\tp^:=clamp(p^+sum%8,0,255)\n\n!\t\t\tsum:=e*4+c+g+i-2*(b+d+f+h)\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\n\n\t\t\t++p\n\t\t\t++q\n\t\t\t++r\n\t\t\t++s\n\t\tod\n\tod\n\n\treturn newbm\n\nend\n\nexport func sharpen24(bm,n)=\n\t(r,g,b):=bmsplittorgb(bm)\n\n\tr2:=bmsharpen(r,n)\n\tg2:=bmsharpen(g,n)\n\tb2:=bmsharpen(b,n)\n\n\tnewbm:=bmjoinrgb(r2,g2,b2)\n\tbmfree(r2)\n\tbmfree(g2)\n\tbmfree(b2)\n\n\treturn newbm\nend\n\nexport func sharpen32(bm,n)=\nreturn bmunimpl(\"bmsharpen32\")\nend\n\nfunc getlumtables=\n\trmap:=makescalemap(0.299)\n\tgmap:=makescalemap(0.587)\n\tbmap:=makescalemap(0.111)\n\treturn (rmap, gmap, bmap)\nend\n",
    
(byte*)"import sys\nimport clib\n\nimport winconsts\nimport winapi\n\n!!Virtual keycodes\nexport const vklbutton=1\t\t!note these are physical not logical buttons\nexport const vkrbutton=2\nexport const vkmbutton=4\t\t!middle button is correct\nexport const vkbackspace=8\nexport const vktab=9\nexport const vkclear=12\nexport const vkenter=13\nexport const vkshift=16\nexport const vkctrl=17\nexport const vkalt=18\nexport const vkbreak=19\nexport const vkcapslock=20\n!export const vkrshift=21\nexport const vkrctrl=22\n!export const vkralt=23\nexport const vkinslock=24\nexport const vkescape=27\nexport const vkspace=32\nexport const vkpageup=33\nexport const vkpagedown=34\nexport const vkend=35\nexport const vkhome=36\nexport const vkleft=37\nexport const vkup=38\nexport const vkright=39\nexport const vkdown=40\nexport const vkinsert=45\nexport const vkdelete=46\nexport const vkhelp=47\nexport const vk0='0'\nexport const vka='A'\nexport const vkwindows=91\nexport const vkrightbutton=93\nexport const vknumpad0=96\t\t!96..105 = '0'..'9'\nexport const vkmul=106\nexport const vkadd=107\nexport const vksub=109\nexport const vkdecimal=110\nexport const vkdiv=111\nexport const vkf1=112\nexport const vkf2=113\nexport const vkf3=114\nexport const vkf4=115\nexport const vkf5=116\nexport const vkf6=117\nexport const vkf7=118\nexport const vkf8=119\nexport const vkf9=120\nexport const vkf10=121\nexport const vkf11=122\nexport const vkf12=123\n!export const vklsq=128\n!export const vkrsq=129\n!export const vksemi=130\n!export const vkquote=131\n!export const vkstroke=132\n!export const vkdot=133\n!export const vkcomma=134\n!export const vkbackslash=135\n!export const vkquote2=136\n!export const vkequals=137\n!export const vkminus=138\n!export const vkhash=139\nexport const vklshift=160\nexport const vkrshift=161\nexport const vklcontrol=162\nexport const vkrcontrol=163\nexport const vklalt=164\nexport const vkralt=165\n\n!oem codes\nexport const vkminus=189\nexport const vkequals=187\nexport const vklsq=219\nexport const vkrsq=221\nexport const vksemi=186\nexport const vkquote=192\nexport const vkhash=222\nexport const vkcomma=188\nexport const vkperiod=190\nexport const vkslash=191\nexport const vkbackslash=220\nexport const vkbackquote=223\n\nexport const con_black=0\nexport const con_dkblue=1\nexport const con_dkred=2\nexport const con_dkmagenta=3\nexport const con_dkgreen=4\nexport const con_dkcyan=5\nexport const con_dkyellow=6\nexport const con_dkgrey=7\nexport const con_grey=8\nexport const con_blue=9\nexport const con_red=10\nexport const con_magenta=11\nexport const con_green=12\nexport const con_cyan=13\nexport const con_yellow=14\nexport const con_white=15\n\n\nexport record winrec =\n\tvar posx,posy\n\tvar cols,rows\n\tvar fgnd,bgnd\t\t\t!default text/background colour\n\n\tvar columns\t\t\t!used when divided into columns\n\tvar itemcols\t\t\t!width of each column\n\tvar pagesize\t\t\t!columns*rows\n\n\tvar name\n\n\tvar hdata\t\t\t!pointer to data record, or is nil\nend\n\nexport var wconscreen\nexport var screencols,screenrows\n\nexport var chardata\t\t\t!string these two represent row of the console\nexport var attrdata\t\t\t!string\n\nexport var defscreenfgnd=con_black\nexport var defscreenbgnd=con_grey\nexport var rlkey=0\t\t!set by readline, when special key has been input\nexport var rlbuffer\t\t\t!contents of readline buffer when special key pressed\n\nvar cmdindex,ncmds\nvar cmdhistory\n\nexport const capsmask  = 0x8\t\t!shift states as they are in .keyshift\nexport const altmask   = 0x4\nexport const ctrlmask  = 0x2\nexport const shiftmask = 0x1\n\nexport const capsbit=3\nexport const altbit=2\nexport const ctrlbit=1\nexport const shiftbit=0\n\nvar keypending=0\nvar lastkey\nvar pendkey\nexport var hconsole, hconsolein\nvar colourpalette\n\n!export var wscreencols,wscreenrows\nexport var currbgnd=-1,currfgnd=-1\n\n!export var screencolour=con_dkred..con_grey\n\n!export var colourmap\nexport VAR SUPPRESS=0\n\nVAR ALLCHARS\n\nproc START=\n!if iswindows() then\n!\tCPL \"WINCON INIT\"\n\t\tinit()\n!fi\n\tend\n\nproc main=\n\tinit()\n\tsettitle(\"New Title\")\n\n!keyscreentest()\n\n!W:=MAKEWIN((1,20),(20,20))\n!CLEARWIN(W)\n\n!SHOWTEXT(\"^^^^^^^^^^^^^^^^^\")\n\na:=rkey(10,20,30)\n!\tsetpos(12, 10)\n!\tprint \"***********hello\"\n!\twaitkey()\nend\n\nproc keyscreentest=\n\t(cols,rows):=(screencols, screenrows)\n\tCPL =COLS,=ROWS\n\n\trow:=rows%2\n\tcol:=cols%2\n\tch:=\"X\"\n\n\tsetcolour(6,1)\n\n\tdo\n\t\tsetpos(col,row)\n\t\tcp ch\n\t\tsetpos(col,row)\n\t\tk:=getkey().keycode\n\t\tcase k\n\t\twhen 27 then\n\t\t\texit\n\t\twhen vkleft then col:=max(1,col-1)\n\t\twhen vkright then col:=min(cols,col+1)\n\t\twhen vkup then row:=max(1,row-1)\n\t\twhen vkdown then row:=min(rows,row+1)\n\t\tesac\n\tod\n\n!waitkey()\n\nend\n\nexport func makerspoint(x,y)=\n!combine x,y into 32-bit value (rspoint)\n\treturn y<<16 ior x\nend\n\nexport proc setpos(col,row)=\n\n!!ROW+:=10\n!fprint \"\\s[{#};{#}H\",row,col\n\n\tsetconsolecursorposition(hconsole,makerspoint(col-1,row-1))\nend\n\nexport func getpos=\n\tinfo:=new(ws_console)\n\tgetconsolescreenbufferinfo(hconsole,&info)\n\treturn (info.pos.x+1,info.pos.y+1)\nend\n\nexport proc init(cols=100)=\n!static var setdimdone=0\n\n!CPL \"CONSOLE INIT-----------\"\n\n\n!\tconsolesw.init(cols)\n\tcmdhistory::=()\t!\"one\",\"two\",\"three\",\"four\")\n\tncmds:=cmdhistory.upb\n\tcmdindex:=0\n\n!screencols:=consolesw.wscreencols\n!screenrows:=consolesw.wscreenrows\n!\n\n\thconsole:=getstdhandle(-11)\n\thconsolein:=getstdhandle(-10)\n\tlastkey:=new(ws_keyevent)\n\tlastkey.repeatcount:=0\n\tpendkey:=new(ws_keyevent)\n\n\tsetdims(cols,60)\n!\tsetdims(50,20)\n\n\tgetdims()\n\n!CPL =SCREENCOLS\n\n\twconscreen:=makewin((1,1),(screencols,screenrows),defscreencolour)\n\n\tcolourpalette:=new(ws_palette16)\n\n\tsetstdpalette()\nend\n\nexport func setcursor(?visible)=\n\tcursor:=new(ws_cursor)\n\tgetconsolecursorinfo(hconsole,&cursor)\n\n\tif visible.defined then\n\t\tcursor.visible:=visible\n\t\tsetconsolecursorinfo(hconsole,&cursor)\n\tfi\n\treturn cursor.visible\nend\n\nexport proc setcolour(fgnd,bgnd)=\n!call with as (fgnd,bgnd) or as (fgnd..bgnd)\n\n\tif fgnd=currfgnd and bgnd=currbgnd then\n\t\treturn\n\tfi\n\n\tcurrfgnd:=fgnd\n\tcurrbgnd:=bgnd\n\n!setconsoletextattribute(hconsole,(colourmap[bgnd]*16 + colourmap[fgnd]))\n\tsetconsoletextattribute(hconsole,(bgnd*16+fgnd))\nend\n\nexport proc settitle(caption)=\n\tsetconsoletitle(caption)\nend\n\nexport func getkeychar=\n!wait for any key, return single char code; as returned by C's getch()\n\treturn waitkey()\nend\n\nexport func getkey2=\n!wait for any key, return keyrec\n!includes shift key presses as discrete keys\n!use getkey() to ignore these\n\n\treturn getchx()\n\n\tk:=getchx()\t\t\t!get keyrec, encoded as int\n\n\tkey:=new(rkey)\t\t\t!convert to proper keyrec\n\tkey.charcode:=k iand 65535\n\tkey.shift:=k>>24\n\tkey.keycode:=k.[23..16]\n!CPL \"GK2:\",KEY\n\n\treturn key\nend\n\nexport func getkey=\n!calls igetkey but doesn't return shift keys as discrete key presses\n\tdo\n\t\tk:=getkey2()\n\t\tcase k.keycode\n\t\twhen vkshift,vkctrl,vkalt,vkcapslock then\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\treturn k\nend\n\nexport func keyready=\n\treturn testkey()\nend\n\nexport proc wshowtext(w,s,?col,?row)=\n\tif col.defined then\n\t\tshowtext(s,w.posx+col-1,w.posy+row-1)\n\telse\n\t\tshowtext(s)\n\tfi\nend\n\nexport proc showtext(s,?x,?y)=\n\n\tif x.defined then\n\t\tsetpos(x,y)\n\tfi\n\n\tcount:=0\n\tif s then\n\t\tif not suppress then\n\t\t\twriteconsole(hconsole,s,s.len,&count,nil)\n\t\tfi\n\tfi\nend\n\nproc setwindowsize(cols,rows)=\n\tr:=new(ws_srect)\n\tr.leftx:=0\n\tr.rightx:=cols-1\n\tr.top:=0\n\tr.bottom:=rows-1\n\tif not setconsolewindowinfo(hconsole,1,&r) then\n!\tCPL \"WINDOW ERROR 1\"\n!\tabort(\"Window error 1\")\n\tfi\nend\n\nexport proc setdims(cols,rows)=\n!set new size for console, by reinitialising\n\n\tmaxcol:=cols\n\tmaxrow:=rows\n\n\tinfo:=new(ws_console)\n\toldscreenattributes:=info.attributes\n\toldscreensize:=info.size\n\n\toldcols:=info.window.rightx-info.window.leftx+1\n\toldrows:=info.window.bottom-info.window.top+1\n\n\tIF OLDSCREENSIZE.X>COLS OR OLDSCREENSIZE.Y>ROWS THEN\t!need to reduce window size first\n\t\tsetwindowsize(oldscreensize.x min cols, oldscreensize.y min rows)\n\tfi\n\n!Set the new size of the entire (virtual) console window\n\tif setconsolescreenbuffersize(hconsole,rows<<16+cols)=0 then\n!\tabort(\"Buffer size error\")\n\tfi\n\n!now set the size of the displayed portion of it; in this case exactly the same\n!size as the buffer, with no scrollbars\n\tsetwindowsize(cols,rows)\n\n\twscreencols:=cols\n\twscreenrows:=rows\n\n!hide blinking cursor\n\tcursor:=new(ws_cursor)\n\tcursor.size:=10\n\tcursor.visible:=1\nend\n\nexport proc setpalette(index,colour)=\n!index is 0..15; colour is an rgb value bbggrr\n!updates local palette array\n!to update actual console, use writepalette\n\tcolourpalette[index]:=colour\nend\n\nexport proc writepalette=\n\tr:=new(ws_consoleex)\n\tr.recsize:=ws_consoleex.bytes\n\tX:=getconsolescreenbufferinfoex(hconsole,&r)\n\n\tr.palette:=colourpalette\n\n\tR.WINDOW.RIGHTX:=R.WINDOW.RIGHTX+1\t\t!workaround off-by-one bug\n\tR.WINDOW.BOTTOM:=R.WINDOW.BOTTOM+1\n\n\tX:=setconsolescreenbufferinfoex(hconsole,&r)\n\n!export proc READPALETTE=\n!r:=new(rconsoleex)\n!r.recsize:=rconsoleex.bytes\n!x:=getconsolescreenbufferinfoex(hconsole,&r)\n!\n!CPL \"GCSBI X=\",X\n!FOR I:=0 TO 15 DO\n! CPL I,\":\",R.PALETTE[I]:\"H\"\n!OD\n!\nend\n\nproc setstdpalette=\n!export const con_black=0\n!export const con_dkblue=1\n!export const con_dkred=2\n!export const con_dkmagenta=3\n!export const con_dkgreen=4\n!export const con_dkcyan=5\n!export const con_dkyellow=6\n!export const con_grey=7\n!export const con_dkgrey=8\n!export const con_blue=9\n!export const con_red=10\n!export const con_magenta=11\n!export const con_green=12\n!export const con_cyan=13\n!export const con_yellow=14\n!export const con_white=15\n\n!R G B\n\tcols:=(\n\t(0,\t\t0,\t\t0),\t\t\t!black\n\t(0,\t\t0,\t\t128),\t\t!dk blue\n\t(128,\t0,\t\t0),\t\t\t!dk red\n\t(128,\t0,\t\t128),\t\t!dk magenta\n\t(0,\t\t128,\t0),\t\t\t!dk green\n\t(0,\t\t128,\t128),\t\t!dk cyan\n\t(128,\t128,\t0),\t\t\t!dk yellow\n\t(128,\t128,\t128),\t\t!dk grey\n\t(192,\t192,\t192),\t\t!grey\n\t(0,\t\t0,\t\t192),\t\t!blue\n\t(192,\t0,\t\t0),\t\t\t!red\n\t(192,\t0,\t\t192),\t\t!magenta\n\t(0,\t\t192,\t0),\t\t\t!green\n\t(0,\t\t192,\t192),\t\t!cyan\n\t(192,\t192,\t0),\t\t\t!yellow\n\t(255,\t255,\t255))\t\t!white\n\n\tfor i,c in cols do\n\t\tsetpalette(i-1,c[3]<<16+c[2]<<8+c[1])\n\tod\n!CPL \"WRITEPAL\"; WAITKEY()\n\twritepalette()\nend\n\nproc getdims=\n\tinfo:=new(ws_console)\n\tgetconsolescreenbufferinfo(hconsole,&info)\n\n\tscreencols:=info.window.rightx-info.window.leftx+1\n\tscreenrows:=info.window.bottom-info.window.top+1\nend\n\nexport func getchx=\n\tconst rightaltmask\t= 1\t\t\t\t!masks used by .controlkeystate\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\n\tconst leftctrlbit\t= 3\t\t!for c.l.p\n\tconst rightctrlbit\t= 2\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\treadconsoleinput(hconsolein,&lastkey,1,&count)\n\t\t\tuntil lastkey.eventtype=1 and lastkey.keydown=1\n\t\tfi\n\tfi\n\n\taltdown\t\t:= (lastkey.controlkeystate iand (leftaltmask ior rightaltmask)|1|0)\n\tctrldown\t:= (lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask)|1|0)\n\tshiftdown\t:= (lastkey.controlkeystate iand shiftmask|1|0)\n\tcapslock\t:= (lastkey.controlkeystate iand capsmask|1|0)\n\n\tlastkey.repeatcount:=lastkey.repeatcount-1\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0;\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0;\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\tkeyshift.[4]:=lastkey.controlkeystate.[leftctrlbit]\t\t!for c.l.p\n\tkeyshift.[5]:=lastkey.controlkeystate.[rightctrlbit]\n\n!need to be more ruthless with how keycoded and charcodes are combined.\n!More combinations need to have only charcode or keycode set, and the other zero\n\n\tswitch charcode\n\twhen 'A'..'Z','a'..'z','0'..'9' then\n\twhen 8,9,13,27,' ','`' then\n\twhen 0 then\t\t\t\t!already key-only event\n\telse\n\t\tkeycode:=0\n\tend switch\n\n\treturn rkey(charcode,keycode,keyshift)\n\nend\n\nexport proc flushkeyboard=\n\tflushconsoleinputbuffer(hconsolein)\nend\n\nexport proc w_writeconsolerow(text, attributes, length, row)=\n\tbuffersize:=1<<16+length\n\tcoord:=0\n\n\tbox:=ws_srect(0,row-1,length-1,row-1)\n\n\tbuffer:=new(array,ws_charinfo,length)\n\n\tfor i:=1 to length do\n\t\tx:=new(ws_charinfo)\n\t\tx.asciichar  := text.[i]\n\t\tx.attributes := attributes.[i]\n!\tx.attributes := attributes.[1]\n\t\tbuffer[i]:=x\n\tod\n!CPL \"HELLO\",text; WAITKEY()\n\n\twriteconsoleoutputa(hconsole, &buffer,buffersize,coord,&box)\nend\n\nexport func setclipboard(s)=\n!copy text to the Windows clipboard\n!return status 0 if no clipboard o/p was possible\n\tconst ghnd=2 + 0x40\n\n\tif openclipboard(nil)=0 then\n\t\treturn 0\n\tfi\n\n\temptyclipboard()\n\n\tif s<>\"\" then\n\t\th:=globalalloc(ghnd,s.len+1)\n\t\tp:=globallock(h)\n\n\t\tmemcpy(p,&s,s.len+1)\n\tglobalunlock(h)\n\t\tsetclipboarddata(cf_text,h)\n\tfi\n\n\tcloseclipboard()\n\n\treturn 1\nend\n\nexport func getclipboard=\n!copy text from Windows clipboard\n!return clipboard text, or \"\" when error or not text data available\n\n\tif openclipboard(nil)=0 then\n\t\treturn \"\"\n\tfi\n\n\thtext:=getclipboarddata(cf_text)\n\n\tif not htext then\n\t\treturn \"\"\n\tfi\n\n\tsize:=globalsize(htext)\t\t!should include zero terminator\n\n\tp:=globallock(htext)\n\ts:=makestr(p,size-1)\t\t!assignment should copy the string data\n\n\tglobalunlock(htext)\n\n\tcloseclipboard()\n\treturn s\nend\n\nexport func makewin(pos, dims, fgnd=con_black,bgnd=con_grey,name=\"Anon\")=\n!export func makewin(pos, dims, ?colour)=\n\n\tw:=new(winrec)\n\tw.posx:=pos[1]\n\tw.posy:=pos[2]\n\tw.cols:=dims[1]\n\tw.rows:=dims[2]\n\tw.columns:=1\n\tif dims.len>=3 then\n\t\tw.columns:=dims[3]\n\tfi\n\n!CPL =POS,=DIMS,=W.COLUMNS\n\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\n\tw.hdata:=nil\n\n\tw.fgnd:=fgnd\n\tw.bgnd:=bgnd\n\tw.name:=name\n\n\treturn w\nend\n\nexport proc clearwin(w)=\n!clear region used by listbox\n!can clear multi-columns at once\n\tspaces:=\" \"*w.cols\n\n\tsetcolour(w.fgnd,w.bgnd)\n\tfor i:=1 to w.rows do\n\t\tshowtext(spaces,w.posx,w.posy+i-1)\n\tod\n\tsetpos(w.posx,w.posy)\nend\n\nexport proc wsetpos(w,col,row)=\n\tsetpos(w.posx+col-1,w.posy+row-1)\nend\n\nexport proc wshowtext_b(w,s,col,fgnd,bgnd)=\n!version of wshowtext that dumps into char/attr buffer.\n!w is used for absolute column number\n\n\tlength:=s.len\n\toffset:=w.posx-1\t!hoz offset\n\n\tchardata.[(col+offset)..(col-1+length+offset)]:=s\n\n!\tattr:=consolesw.colourmap[bgnd]<<4+consolesw.colourmap[fgnd]\n\tattr:=bgnd<<4+fgnd\n\n\tattrdata.[(col+offset)..(col-1+length+offset)]:=chr(attr)*length\nend\n\nexport proc updateconsolerow(row)=\n!write out latest contents to chardata/attrdata to console\n!this represents an entire composite wlineno+wvgap+wedit row, for given row within wedit\n!etc\n\tw_writeconsolerow(chardata,attrdata,screencols,row)\nend\n\nexport func getkeyname(key)=\n\tcase key.keycode\n\twhen vkleft then name:=\"left\"\n\twhen vkright then name:=\"right\"\n\twhen vkup then name:=\"up\"\n\twhen vkdown then name:=\"down\"\n\twhen vkpageup then name:=\"pageup\"\n\twhen vkpagedown then name:=\"pagedown\"\n\twhen vkhome then name:=\"home\"\n\twhen vkend then name:=\"end\"\n\twhen vkinsert then name:=\"insert\"\n\twhen vkdelete then name:=\"delete\"\n\twhen vktab then name:=\"tab\"\n\twhen vkescape then name:=\"escape\"\n\twhen vkbackspace then name:=\"backspace\"\n\twhen vkenter then name:=\"enter\"\n\twhen vkf1..vkf12 then name:=\"f\"+tostr(key.keycode-vkf1+1)\n\twhen vkspace then name:=\"space\"\n\telse\n\t\tif key.charcode in [1..26] then\t!ctrl code\n\t\t\tname:=chr(key.charcode+'a'-1)\n\t\telsif key.charcode in ['!','\"','','$','%','^','&','*','(',')','-','_','+','=','[',']',\n\t\t'{','}',':',';','\\'','@','~','#','<','>',',','.','/','','','|','\\\\','?'] then\n\t\t\tname:=chr(key.charcode)\n\t\t\tkey.shift iand:=inot shiftmask\t\t!ignore any shift press needed to get char\n\n\t\telsif key.keycode in ['A'..'Z','0'..'9'] then\n\t\t\tif (key.shift iand (ctrlmask ior altmask))=0 then\n\t\t\t\tname:=chr(key.charcode)\n\t\t\t\tkey.shift iand:=inot shiftmask\n\t\t\telse\n\t\t\t\tname:=convlc(chr(key.keycode))\n\t\t\tfi\n\t\telsif key.keycode in (186..223) then\n\t\t\tcase key.keycode\n\t\t\twhen vkminus then name:=\"-\"\n\t\t\twhen vkequals then name:=\"=\"\n\t\t\twhen vklsq then name:=\"[\"\n\t\t\twhen vkrsq then name:=\"]\"\n\t\t\twhen vksemi then name:=\";\"\n\t\t\twhen vkquote then name:=\"'\"\n\t\t\twhen vkhash then name:=\"#\"\n\t\t\twhen vkcomma then name:=\",\"\n\t\t\twhen vkperiod then name:=\".\"\n\t\t\twhen vkslash then name:=\"/\"\n\t\t\twhen vkbackslash then name:=\"\\\\\"\n\t\t\twhen vkbackquote then name:=\"`\"\n\t\t\telse\n\t\t\t\treturn \"?\"\n\t\t\tesac\n\t\telse\n\t\t\treturn \"?\"\n\t\tfi\n\tesac\n\n\tprefix::=\"*\"\n\tif key.shift iand shiftmask then prefix+:=\"s\" fi\n\tif key.shift iand ctrlmask then prefix+:=\"c\" fi\n\tif key.shift iand altmask then prefix+:=\"a\" fi\n\treturn prefix+name\n\nend\n\nexport func keynametokey(name)=\n!given a key name in the format \"*...\", reconstruct an rkey record, and return that\n\tcharcode:=shift:=keycode:=0\n\n\tname:=rightstr(name,-1)\t\t!get rid of \"*\"\n\n\tif name.len=1 then\t\t!simple printable key, no shifts\n\t\tcharcode:=asc(name)\n\t\tgoto simplekey\n\n\telse\t\t\t\t!any letters s,c,a on left indicate a modifier\n\t\twhile name.len>1 do\n\t\t\tcase leftstr(name)\n\t\t\twhen \"s\" then\n\t\t\t\tshift ior:=shiftmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\twhen \"c\" then\n\t\t\t\tshift ior:=ctrlmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\twhen \"a\" then\n\t\t\t\tshift ior:=altmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\telse\n\t\t\t\texit\n\t\t\tesac\n\t\tod\n\n\t\tcase name\n\t\twhen \"left\" then keycode:=vkleft\n\t\twhen \"right\" then keycode:=vkright\n\t\twhen \"up\" then keycode:=vkup\n\t\twhen \"down\" then keycode:=vkdown\n\t\twhen \"pageup\" then keycode:=vkpageup\n\t\twhen \"pagedown\" then keycode:=vkpagedown\n\t\twhen \"home\" then keycode:=vkhome\n\t\twhen \"end\" then keycode:=vkend\n\t\twhen \"insert\" then keycode:=vkinsert\n\t\twhen \"delete\" then keycode:=vkdelete\n\t\twhen \"tab\" then keycode:=charcode:=vktab\n\t\twhen \"escape\" then keycode:=vkescape\n\t\twhen \"backspace\" then keycode:=charcode:=vkbackspace\n\t\twhen \"enter\" then keycode:=charcode:=vkenter\n\t\twhen \"space\" then keycode:=charcode:=vkspace\n\t\telse\n\t\t\tif name.len>=2 and leftstr(name)=\"f\" then\t!function key\n\t\t\t\tkeycode:=vkf1+strtoval(rightstr(name,-1))-1\n\t\t\telsif name.len=1 then\t\t\t\t!ordinary key, but with shifts\n\tsimplekey:\n\t\t\t\tc:=asc(name)\n\t\t\t\tcase c\n\t\t\t\twhen ['A'..'Z'] then\n\t\t\t\t\tkeycode:=c\n\t\t\t\twhen ['a'..'z'] then\n\t\t\t\t\tkeycode:=c-' '\n\t\t\t\twhen ['0'..'9'] then\n\t\t\t\t\tkeycode:=c\n\t\t\t\twhen '-','_' then keycode:=vkminus\n\t\t\t\twhen '=','+' then keycode:=vkequals\n\t\t\t\twhen '[','{' then keycode:=vklsq\n\t\t\t\twhen ']','}' then keycode:=vkrsq\n\t\t\t\twhen ';',':' then keycode:=vksemi\n\t\t\t\twhen '\\'','@' then keycode:=vkquote\n\t\t\t\twhen ',','<' then keycode:=vkcomma\n\t\t\t\twhen '.','>' then keycode:=vkperiod\n\t\t\t\twhen '/','?' then keycode:=vkslash\n\t\t\t\twhen '\\\\','|' then keycode:=vkbackslash\n\t\t\t\twhen '`','' then keycode:=vkbackquote\n\t\t\t\twhen '#','~' then keycode:=vkhash\n\t\t\t\twhen '!' then keycode:='1'\n\t\t\t\twhen '\"' then keycode:='2'\n\t\t\t\twhen '' then keycode:='3'\n\t\t\t\twhen '$' then keycode:='4'\n\t\t\t\twhen '%' then keycode:='5'\n\t\t\t\twhen '^' then keycode:='6'\n\t\t\t\twhen '&' then keycode:='7'\n\t\t\t\twhen '*' then keycode:='8'\n\t\t\t\twhen '(' then keycode:='9'\n\t\t\t\twhen ')' then keycode:='0'\n\t\t\t\telse\n\t\t\t\t\tpcerror(\"keynametokey\")\n\t\t\t\tend\n\t\t\tfi\n\t\tesac\n\tfi\n\n\tif shift iand (altmask ior ctrlmask) then\n\t\tcharcode:=0\n\t\tif keycode in 'A'..'Z' then\n\t\t\tcharcode:=keycode-'@'\n\t\tfi\n\tfi\n\n\tkey:=new(rkey)\t\t\t!convert to proper keyrec\n\tkey.charcode:=charcode\n\tkey.shift:=shift\n\tkey.keycode:=keycode\n\treturn key\nend\n\nexport proc clearscreen(?bgnd,?fgnd)=\n\nif bgnd.isvoid then bgnd:=defscreenbgnd fi\nif fgnd.isvoid then fgnd:=defscreenfgnd fi\nsetcolour(fgnd,bgnd)\n\nfor i:=1 to screenrows do\n\tsetpos(1,i)\n\tshowtext(\" \"*screencols)\n!\tshowtext(\"*\"*screencols)\nod\nsetpos(1,1)\nend\n\nexport func readline(?cmdline,donewline=1)=\n!this func doesn't handle tabs properly\n!would need to maintain 2 buffers, one with tabs translated to spaces\n!or convert tabs to another char which is translated back to tabs on exit\n!return with input buffer set to the line, but also returns the complete line\n!newline=1 to end with a newline, 0 to leave it\n\n!readln\n!return\n\n\tbuffer:=\"\"\n\tnchars:=0\n!congetpos()\n\n!NOTE: getpos is dodgy using TERMCON; MAY NEED CALLER TO SPECIFY START POINT\n\t(startx,starty):=(getpos())\n\n\tpos:=0\t\t!with nchars shown, pos can be 0 to nchars\n\n\treenter:\n\tif cmdline.defined and cmdline<>\"\" then\n\t\tbuffer:=cmdline\n\treenter2:\n\t\tpos:=nchars:=buffer.len\n\tfi\n\n\tdo\n! print \"_\"\n\t\trlkey:=0\t\t\t!normal input starts with \"*\" will expect rlkey to be a keyrec\n\t\tsetpos(startx,starty)\n\t\tprint buffer\n\t\tsetpos(startx+pos,starty)\n\n\t\tkey:=getkey()\n\t\tkeycode:=key.keycode\n\t\tkeyshift:=key.shift\n\n\t\tcase keycode\n\t\twhen vkpageup,vkpagedown,vkup,vkdown,vkinsert,vkf1..vkf12 then\n\n\tdospecial:\n\t\trlbuffer:=buffer\n\t\t\toldbufferlen:=buffer.len\t\t!to help erase old buffer\n\t\t\tbuffer:=getkeyname(key)\n\t\t\trlkey:=key\t\t\t\t!allow caller to use key code rather than name\n\t\t\texit\n\n\t\twhen vkleft then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\n\t\t\tif pos>0 then\n\t\t\t\t--pos\n\t\t\tfi\n\n\t\twhen vkhome then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=0\n\n\t\twhen vkend then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=nchars\n\n\t\twhen vkright then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif pos<nchars then\n\t\t\t\t++pos\n\t\t\tfi\n\n\t\twhen vkenter then\n\n!  println\n\t\t\texit\n\n\t\twhen vkbackspace then\n\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars then\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen 0 then\t\t\t!not allowed\n\t\t\t\twhen nchars then\t\t!at end\n\t\t\t\t\tbuffer:=leftstr(buffer,-1)\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos-1)+rightstr(buffer,-(pos))\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkdelete then\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars and nchars=pos then\n\t\t\t\tgoto delline\n\t\t\tfi\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n\t\t\tfi\n\t\t\tif nchars then\n!CPL \"\\NNCHARS\",=NCHARS,++CCC,=POS,\"\\N\"\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen nchars then\t\t!not allowed\n!\t\t\twhen 0 then\t\t\t!at start\n!\t\t\t\tbuffer:=leftstr(buffer,-1)\n!\t\t\t\t--nchars\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+rightstr(buffer,-(pos+1))\n\t\t\t\t\t--nchars\n!    --pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkescape then\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n!   oldbufferlen:=buffer.len\n!   buffer:=\"*esc\"\n!   exit\n\t\t\tfi\n\tdelline:\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*buffer.len\n\n\t\t\tbuffer:=\"\"\n\t\t\tnchars:=pos:=0\n\n\t\twhen vktab then\n\t\t\tgoto normalkey\n\n\t\telse\n\tnormalkey:\n\t\t\tif (key.charcode>=' ' or key.charcode=9) then\n\t\t\t\tif pos=0 then\n\t\t\t\t\tbuffer:=chr(key.charcode)+buffer\n\t\t\t\telsif pos=nchars then\n\t\t\t\t\tbuffer:=buffer+chr(key.charcode)\n\t\t\t\telse\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+chr(key.charcode)+rightstr(buffer,-(pos))\n\t\t\t\tfi\n\t\t\t\t++nchars\n\t\t\t\t++pos\n\t\t\telse\n\t\t\t\tGOTO DOSPECIAL\n\t\t\t\tprint \"<\",keycode,key.charcode,\">\"\n\t\t\tfi\n\n\t\tesac\n\tod\n\n\tcase buffer\n\twhen \"*cup\",\"*cdown\" then\n\t\tif ncmds then\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*oldbufferlen\n\n\t\t\tif cmdindex=0 then\t\t!get started on last\n\t\t\t\tcmdline:=cmdhistory[ncmds]\n\t\t\t\tcmdindex:=ncmds\n\t\t\t\tgoto reenter\n\t\t\tfi\n\n\t\t\tif buffer=\"*cup\" and cmdindex>1 then\n\t\t\t\t--cmdindex\n\t\t\telsif buffer=\"*cdown\" and cmdindex<ncmds then\n\t\t\t\t++cmdindex\n\t\t\tfi\n\t\t\tcmdline:=cmdhistory[cmdindex]\n\t\t\tgoto reenter\n\t\tfi\n\t\tbuffer:=\"\"\n\t\tgoto reenter2\n\tesac\n\n\tif buffer.len>1 and leftstr(buffer)<>\"*\" then\n\t\tif ncmds=0 or cmdhistory[ncmds]<>buffer then\n\t\t\tcmdhistory[++ncmds]:=buffer\n\t\tfi\n\t\tcmdindex:=0\n\tfi\n\n\tif donewline then println fi\n\n\treturn sreadln(buffer)\nend\n\nexport proc wsetcolumns(w,columns)=\n\tw.columns:=columns\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\nend\n\n",
    
(byte*)"!Windows win32 constants\n\nglobal const driverversion =  0\nglobal const technology =  2\nglobal const horzsize =  4\nglobal const vertsize =  6\nglobal const horzres =  8\nglobal const vertres =  10\nglobal const bitspixel =  12\nglobal const bitplanes =  14\nglobal const numbrushes =  16\nglobal const numpens =  18\nglobal const nummarkers =  20\nglobal const numfonts =  22\nglobal const numcolours =  24\nglobal const pdevicesize =  26\nglobal const curvecaps =  28\nglobal const linecaps =  30\nglobal const polygonalcaps =  32\nglobal const textcaps =  34\nglobal const clipcaps =  36\nglobal const rastercaps =  38\nglobal const aspectx =  40\nglobal const aspecty =  42\nglobal const aspectxy =  44\nglobal const logpixelsx =  88\nglobal const logpixelsy =  90\nglobal const sizepalette =  104\nglobal const numreserved =  106\nglobal const colourres =  108\nglobal const physicalwidth =  110\nglobal const physicalheight =  111\nglobal const physicaloffsetx =  112\nglobal const physicaloffsety =  113\nglobal const scalingfactorx =  114\nglobal const scalingfactory =  115\nglobal const fw_dontcare =  0\nglobal const fw_thin =  100\nglobal const fw_extralight =  200\nglobal const fw_ultralight =  200\nglobal const fw_light =  300\nglobal const fw_normal =  400\nglobal const fw_regular =  400\nglobal const fw_medium =  500\nglobal const fw_semibold =  600\nglobal const fw_demibold =  600\nglobal const fw_bold =  700\nglobal const fw_extrabold =  800\nglobal const fw_ultrabold =  800\nglobal const fw_heavy =  900\nglobal const fw_black =  900\nglobal const cs_vredraw =  1\nglobal const cs_hredraw =  2\nglobal const cs_keycvtwindow =  4\nglobal const cs_dblclks =  8\nglobal const cs_owndc =  32\nglobal const cs_classdc =  64\nglobal const cs_parentdc =  128\nglobal const cs_nokeycvt =  256\nglobal const cs_noclose =  512\nglobal const cs_savebits =  2048\nglobal const cs_bytealignclient =  4096\nglobal const cs_bytealignwindow =  8192\nglobal const cs_publicclass =  16384\nglobal const sw_hide =  0\nglobal const sw_shownormal =  1\nglobal const sw_normal =  1\nglobal const sw_showminimized =  2\nglobal const sw_showmaximized =  3\nglobal const sw_maximize =  3\nglobal const sw_shownoactivate =  4\nglobal const sw_show =  5\nglobal const sw_minimize =  6\nglobal const sw_showminnoactive =  7\nglobal const sw_showna =  8\nglobal const sw_restore =  9\nglobal const sw_showdefault =  10\nglobal const sw_max =  10\nglobal const pm_noremove =  0\nglobal const pm_remove =  1\nglobal const pm_noyield =  2\nglobal const wm_null =  0\nglobal const wm_create =  1\nglobal const wm_destroy =  2\nglobal const wm_move =  3\nglobal const wm_size =  5\nglobal const wm_activate =  6\nglobal const wa_inactive =  0\nglobal const wa_active =  1\nglobal const wa_clickactive =  2\nglobal const wm_setfocus =  7\nglobal const wm_killfocus =  8\nglobal const wm_enable =  10\nglobal const wm_setredraw =  11\nglobal const wm_settext =  12\nglobal const wm_gettext =  13\nglobal const wm_gettextlength =  14\nglobal const wm_paint =  15\nglobal const wm_close =  16\nglobal const wm_queryendsession =  17\nglobal const wm_quit =  18\nglobal const wm_queryopen =  19\nglobal const wm_erasebkgnd =  20\nglobal const wm_syscolourchange =  21\nglobal const wm_endsession =  22\nglobal const wm_showwindow =  24\nglobal const wm_wininichange =  26\nglobal const wm_devmodechange =  27\nglobal const wm_activateapp =  28\nglobal const wm_fontchange =  29\nglobal const wm_timechange =  30\nglobal const wm_cancelmode =  31\nglobal const wm_setcursor =  32\nglobal const wm_mouseactivate =  33\nglobal const wm_childactivate =  34\nglobal const wm_queuesync =  35\nglobal const wm_getminmaxinfo =  36\nglobal const wm_drawitem =  43\nglobal const wm_notify =  78\nglobal const wm_contextmenu =  123\nglobal const wm_geticon =  127\nglobal const wm_seticon =  128\nglobal const wm_nchittest =  132\n\nglobal const wm_nclbuttondown\t= 161\nglobal const wm_nclbuttonup\t= 162\nglobal const wm_nclbuttondblclick\t= 163\n\nglobal const wm_menurbuttonup\t= 290\n\nglobal const wm_parentnotify =  528\nglobal const wm_dropfiles =  563\nglobal const wm_enteridle =  289\nglobal const wm_user =  1024\nglobal const wm_mdicreate =  544\nglobal const wm_mdidestroy =  545\nglobal const wm_mdiactivate =  546\nglobal const wm_mdirestore =  547\nglobal const wm_mdinext =  548\nglobal const wm_mdimaximize =  549\nglobal const wm_mditile =  550\nglobal const wm_mdicascade =  551\nglobal const wm_mdiiconarange =  552\nglobal const wm_mdigetactive =  553\nglobal const wm_mdisetmenu =  560\nglobal const wm_entersizemove =  561\nglobal const wm_exitsizemove =  562\nglobal const wm_mdirefrshmenu =  564\nglobal const wm_lbuttondblclk =  515\nglobal const wm_rbuttondblclk =  518\nglobal const wm_lbuttondown =  513\nglobal const wm_rbuttondown =  516\nglobal const wm_mbuttondown =  519\nglobal const wm_mousemove =  512\nglobal const wm_lbuttonup =  514\nglobal const wm_rbuttonup =  517\nglobal const wm_mbuttonup =  520\nglobal const wm_mbuttondblclk =  521\nglobal const wm_mousewheel =  522\nglobal const snd_filename =  131072\nglobal const snd_async =  1\nglobal const dt_singleline =  32\nglobal const dt_centre =  1\nglobal const dt_vcentre =  4\nglobal const ws_overlapped =  0\nglobal const ws_popup =  2147483648\nglobal const ws_child =  1073741824\nglobal const ws_minimize =  536870912\nglobal const ws_visible =  268435456\nglobal const ws_disabled =  134217728\nglobal const ws_clipsiblings =  67108864\nglobal const ws_clipchildren =  33554432\nglobal const ws_maximize =  16777216\nglobal const ws_caption =  12582912\nglobal const ws_border =  8388608\nglobal const ws_dlgframe =  4194304\nglobal const ws_hscroll =  1048576\nglobal const ws_vscroll =  2097152\nglobal const ws_sysmenu =  524288\nglobal const ws_thickframe =  262144\nglobal const ws_group =  131072\nglobal const ws_tabstop =  0\nglobal const ws_scrollbars =  3145728\nglobal const ws_minimizebox =  131072\nglobal const ws_maximizebox =  65536\nglobal const ws_tiled =  0\nglobal const ws_iconic =  536870912\nglobal const ws_sizebox =  262144\nglobal const ws_overlappedwindow =  13565952\nglobal const ws_tiledwindow =  13565952\nglobal const ws_popupwindow =  -2138570752\nglobal const ws_childwindow =  1073741824\nglobal const ws_ex_acceptfiles =  16\nglobal const ws_ex_appwindow =  262144\nglobal const ws_ex_clientedge =  512\nglobal const ws_ex_contexthelp =  1024\nglobal const ws_ex_controlparent =  65536\nglobal const ws_ex_dlgmodalframe =  1\nglobal const ws_ex_left =  0\nglobal const ws_ex_leftscrollbar =  16384\nglobal const ws_ex_ltrreading =  0\nglobal const ws_ex_mdichild =  64\nglobal const ws_ex_noparentnotify =  4\nglobal const ws_ex_overlappedwindow =  768\nglobal const ws_ex_palettewindow =  392\nglobal const ws_ex_right =  4096\nglobal const ws_ex_rightscrollbar =  0\nglobal const ws_ex_rtlreading =  8192\nglobal const ws_ex_staticedge =  131072\nglobal const ws_ex_toolwindow =  128\nglobal const ws_ex_topmost =  8\nglobal const ws_ex_transparent =  32\nglobal const ws_ex_windowedge =  256\n\nglobal const gw_hwndfirst =  0\nglobal const gw_hwndlast =  1\nglobal const gw_hwndnext =  2\nglobal const gw_hwndprev =  3\nglobal const gw_owner =  4\nglobal const gw_child =  5\nglobal const gw_enabledpopup =  6\nglobal const cb_geteditsel =  320\nglobal const cb_limittext =  321\nglobal const cb_seteditsel =  322\nglobal const cb_addstring =  323\nglobal const cb_deletestring =  324\nglobal const cb_dir =  325\nglobal const cb_getcount =  326\nglobal const cb_getcursel =  327\nglobal const cb_getlbtext =  328\nglobal const cb_getlbtextlen =  329\nglobal const cb_insertstring =  330\nglobal const cb_resetcontent =  331\nglobal const cb_findstring =  332\nglobal const cb_findstringexact =  344\nglobal const cb_selectstring =  333\nglobal const cb_setcursel =  334\nglobal const cb_showdropdown =  335\nglobal const cb_getitemdata =  336\nglobal const cb_setitemdata =  337\nglobal const cb_getdroppedcontrolrect =  338\nglobal const cb_setitemheight =  339\nglobal const cb_getitemheight =  340\nglobal const cb_setextendedui =  341\nglobal const cb_getextendedui =  342\nglobal const cb_getdroppedstate =  343\nglobal const cb_setlocale =  345\nglobal const cb_getlocale =  346\nglobal const cb_gettopindex =  347\nglobal const cb_settopindex =  348\nglobal const cb_gethorizontalextent =  349\nglobal const cb_sethorizontalextent =  350\nglobal const cb_getdroppedwidth =  351\nglobal const cb_setdroppedwidth =  352\nglobal const cb_initstorage =  353\nglobal const cb_multipleaddstring =  355\nglobal const bm_click =  245\nglobal const bm_getcheck =  240\nglobal const bm_getimage =  246\nglobal const bm_getstate =  242\nglobal const bm_setcheck =  241\nglobal const bm_setimage =  247\nglobal const bm_setstate =  243\nglobal const bm_setstyle =  244\nglobal const cf_bitmap =  2\nglobal const cf_dib =  8\nglobal const cf_palette =  9\nglobal const cf_enhmetafile =  14\nglobal const cf_metafilepict =  3\nglobal const cf_oemtext =  7\nglobal const cf_text =  1\t\t\t!used in sys\nglobal const cf_unicodetext =  13\nglobal const cf_dif =  5\nglobal const cf_dspbitmap =  130\nglobal const cf_dspenhmetafile =  142\nglobal const cf_dspmetafilepict =  131\nglobal const cf_dsptext =  129\nglobal const cf_gdiobjfirst =  768\nglobal const cf_gdiobjlast =  1023\nglobal const cf_hdrop =  15\nglobal const cf_locale =  16\nglobal const cf_ownerdisplay =  128\nglobal const cf_pendata =  10\nglobal const cf_privatefirst =  512\nglobal const cf_privatelast =  767\nglobal const cf_riff =  11\nglobal const cf_sylk =  4\nglobal const cf_wave =  12\nglobal const cf_tiff =  6\n\nglobal const tcif_text =  1\nglobal const tcif_image =  2\nglobal const tcif_param =  8\nglobal const tcif_rtlreading =  4\n\nglobal const wm_keydown =  256\nglobal const wm_keyup =  257\nglobal const wm_char =  258\nglobal const wm_syschar =  262\nglobal const wm_sysdeadchar =  263\nglobal const wm_syskeydown =  260\nglobal const wm_syskeyup =  261\nglobal const mf_insert =  0\nglobal const mf_change =  128\nglobal const mf_append =  256\nglobal const mf_delete =  512\nglobal const mf_remove =  4096\nglobal const mf_bycommand =  0\nglobal const mf_byposition =  1024\nglobal const mf_separator =  2048\nglobal const mf_enabled =  0\nglobal const mf_grayed =  1\nglobal const mf_greyed =  1\nglobal const mf_disabled =  2\nglobal const mf_unchecked =  0\nglobal const mf_checked =  8\nglobal const mf_usecheckbitmaps =  512\nglobal const mf_string =  0\nglobal const mf_bitmap =  4\nglobal const mf_ownerdraw =  256\nglobal const mf_popup =  16\nglobal const mf_menubarbreak =  32\nglobal const mf_menubreak =  64\nglobal const mf_unhilite =  0\nglobal const mf_hilite =  128\nglobal const mf_sysmenu =  8192\nglobal const mf_help =  16384\nglobal const mf_mouseselect =  32768\n\n!global const bn_clicked =  0\n!global const bn_dblclk =  5\n!global const bn_disable =  4\n!global const bn_doubleclicked =  5\n!global const bn_hilite =  2\n!global const bn_killfocus =  7\n!global const bn_paint =  1\n!global const bn_pushed =  2\n!global const bn_setfocus =  6\n!global const bn_unhilite =  3\n!global const bn_unpushed =  3\n!global const en_setfocus =  256\n!global const en_killfocus =  512\n!global const en_change =  768\n!global const en_update =  1024\n!global const en_errspace =  1280\n!global const en_maxtext =  1281\n!global const en_hscroll =  1537\n!global const en_vscroll =  1538\n!global const lbn_errspace =  -2\n!global const lbn_selchange =  1\n!global const lbn_dblclk =  2\n!global const lbn_selcancel =  3\n!global const lbn_setfocus =  4\n!global const lbn_killfocus =  5\n!global const cbn_errspace =  -1\n!global const cbn_selchange =  1\n!global const cbn_dblclk =  2\n!global const cbn_setfocus =  3\n!global const cbn_killfocus =  4\n!global const cbn_editchange =  5\n!global const cbn_editupdate =  6\n!global const cbn_dropdown =  7\n!global const cbn_closeup =  8\n!global const cbn_selendok =  9\n!global const cbn_selendcancel =  10\n!\n!global const cbs_autohscroll =  64\n!global const cbs_disablenoscroll =  2048\n!global const cbs_dropdown =  2\n!global const cbs_dropdownlist =  3\n!global const cbs_hasstrings =  512\n!global const cbs_lowercase =  16384\n!global const cbs_nointegralheight =  1024\n!global const cbs_oemconvert =  128\n!global const cbs_ownerdrawfixed =  16\n!global const cbs_ownerdrawvariable =  32\n!global const cbs_simple =  1\n!global const cbs_sort =  256\n!global const cbs_uppercase =  8192\n\nglobal const wm_command =  273\nglobal const wm_menuselect =  287\nglobal const wm_cut =  768\nglobal const wm_copy =  769\nglobal const wm_paste =  770\nglobal const wm_clear =  771\nglobal const wm_undo =  772\nglobal const em_getsel =  176\nglobal const em_setsel =  177\nglobal const em_scroll =  181\nglobal const em_linescroll =  182\nglobal const em_scrollcaret =  183\nglobal const em_getmodify =  184\nglobal const em_setmodify =  185\nglobal const em_getlinecount =  186\nglobal const em_lineindex =  187\nglobal const em_sethandle =  188\nglobal const em_gethandle =  189\nglobal const em_getthumb =  190\nglobal const em_linelength =  193\nglobal const em_replacesel =  194\nglobal const em_getline =  196\nglobal const em_limittext =  197\nglobal const em_canundo =  198\nglobal const em_undo =  199\nglobal const em_fmtlines =  200\nglobal const em_linefromchar =  201\nglobal const em_settabstops =  203\nglobal const em_setpasswordchar =  204\nglobal const em_emptyundobuffer =  205\nglobal const em_getfirstvisibleline =  206\nglobal const em_setreadonly =  207\nglobal const em_setwordbreakproc =  208\nglobal const em_getwordbreakproc =  209\nglobal const em_getpasswordchar =  210\nglobal const em_setlimittext =  197\nglobal const em_getseltext =  1086\nglobal const em_setcharformat =  1092\nglobal const em_getcharformat =  1082\nglobal const em_settextmode =  1113\nglobal const em_gettextmode =  1114\nglobal const em_gettextex =  1118\nglobal const em_gettextlengthex =  1119\nglobal const tm_plaintext =  1\nglobal const tm_richtext =  2\nglobal const tm_singlelevelundo =  4\nglobal const tm_multilevelundo =  8\nglobal const tm_singlecodepage =  16\nglobal const tm_multicodepage =  32\nglobal const scf_word =  2\nglobal const scf_selection =  1\nglobal const sb_getborders =  1031\nglobal const sb_getparts =  1030\nglobal const sb_getrect =  1034\nglobal const sb_gettextw =  1037\nglobal const sb_gettextlengthw =  1036\nglobal const sb_settextw =  1035\nglobal const sb_gettexta =  1026\nglobal const sb_gettextlengtha =  1027\nglobal const sb_settexta =  1025\nglobal const sb_gettext =  1026\nglobal const sb_gettextlength =  1027\nglobal const sb_settext =  1025\nglobal const sb_setminheight =  1032\nglobal const sb_setparts =  1028\nglobal const sb_simple =  1033\nglobal const wm_setfont =  48\nglobal const wm_getfont =  49\nglobal const gm_advanced =  2\nglobal const transparent =  1\nglobal const opaque =  2\nglobal const mwt_identity =  1\nglobal const cw_usedefault =  0x8000'0000\nglobal const idc_arrow =  32512\nglobal const idc_ibeam =  32513\nglobal const idc_wait =  32514\nglobal const idc_cross =  32515\nglobal const idc_uparrow =  32516\nglobal const idc_sizenwse =  32642\nglobal const idc_sizenesw =  32643\nglobal const idc_sizewe =  32644\nglobal const idc_sizens =  32645\nglobal const idc_sizeall =  32646\nglobal const idc_no =  32648\nglobal const idc_appstarting =  32650\nglobal const idc_help =  32651\nglobal const idi_application =  32512\nglobal const idi_hand =  32513\nglobal const idi_question =  32514\nglobal const idi_exclamation =  32515\nglobal const idi_asterisk =  32516\nglobal const idi_winlogo =  32517\nglobal const idc_size =  32640\nglobal const idc_icon =  32641\nglobal const arrowpointer =  32512\nglobal const ibeampointer =  32513\nglobal const waitpointer =  32514\nglobal const crosspointer =  32515\nglobal const uparrowpointer =  32516\nglobal const sizenwsepointer =  32642\nglobal const sizeneswpointer =  32643\nglobal const sizewepointer =  32644\nglobal const sizenspointer =  32645\nglobal const sizeallpointer =  32646\nglobal const nopointer =  32648\nglobal const appstartingpointer =  32650\nglobal const helpicon =  32651\nglobal const applicationicon =  32512\nglobal const handicon =  32513\nglobal const questionicon =  32514\nglobal const exclamationicon =  32515\nglobal const asteriskicon =  32516\nglobal const winlogoicon =  32517\nglobal const sizepointer =  32640\nglobal const iconicon =  32641\nglobal const sm_cymin =  29\nglobal const sm_cxmin =  28\nglobal const sm_arrange =  56\nglobal const sm_cleanboot =  67\nglobal const sm_cmetrics =  76\nglobal const sm_cmousebuttons =  43\nglobal const sm_cxborder =  5\nglobal const sm_cyborder =  6\nglobal const sm_cxcursor =  13\nglobal const sm_cycursor =  14\nglobal const sm_cxdlgframe =  7\nglobal const sm_cydlgframe =  8\nglobal const sm_cxdoubleclk =  36\nglobal const sm_cydoubleclk =  37\nglobal const sm_cxdrag =  68\nglobal const sm_cydrag =  69\nglobal const sm_cxedge =  45\nglobal const sm_cyedge =  46\nglobal const sm_cxfixedframe =  7\nglobal const sm_cyfixedframe =  8\nglobal const sm_cxframe =  32\nglobal const sm_cyframe =  33\nglobal const sm_cxfullscreen =  16\nglobal const sm_cyfullscreen =  17\nglobal const sm_cxhscroll =  21\nglobal const sm_cyhscroll =  3\nglobal const sm_cxhthumb =  10\nglobal const sm_cxicon =  11\nglobal const sm_cyicon =  12\nglobal const sm_cxiconspacing =  38\nglobal const sm_cyiconspacing =  39\nglobal const sm_cxmaximized =  61\nglobal const sm_cymaximized =  62\nglobal const sm_cxmaxtrack =  59\nglobal const sm_cymaxtrack =  60\nglobal const sm_cxmenucheck =  71\nglobal const sm_cymenucheck =  72\nglobal const sm_cxmenusize =  54\nglobal const sm_cymenusize =  55\nglobal const sm_cxminimized =  57\nglobal const sm_cyminimized =  58\nglobal const sm_cxminspacing =  47\nglobal const sm_cyminspacing =  48\nglobal const sm_cxmintrack =  34\nglobal const sm_cymintrack =  35\nglobal const sm_cxscreen =  0\nglobal const sm_cyscreen =  1\nglobal const sm_cxsize =  30\nglobal const sm_cysize =  31\nglobal const sm_cxsizeframe =  32\nglobal const sm_cysizeframe =  33\nglobal const sm_cxsmicon =  49\nglobal const sm_cysmicon =  50\nglobal const sm_cxsmsize =  52\nglobal const sm_cysmsize =  53\nglobal const sm_cxvscroll =  2\nglobal const sm_cyvscroll =  20\nglobal const sm_cyvthumb =  9\nglobal const sm_cycaption =  4\nglobal const sm_cykanjiwindow =  18\nglobal const sm_cymenu =  15\nglobal const sm_cysmcaption =  51\nglobal const sm_dbcsenabled =  42\nglobal const sm_debug =  22\nglobal const sm_menudropalignment =  40\nglobal const sm_mideastenabled =  74\nglobal const sm_mousepresent =  19\nglobal const sm_mousewheelpresent =  75\nglobal const sm_network =  63\nglobal const sm_penwindows =  41\nglobal const sm_reserved1 =  24\nglobal const sm_reserved2 =  25\nglobal const sm_reserved3 =  26\nglobal const sm_reserved4 =  27\nglobal const sm_secure =  44\nglobal const sm_showsounds =  70\nglobal const sm_slowmachine =  73\nglobal const sm_swapbutton =  23\nglobal const arw_bottomleft =  0\nglobal const arw_bottomright =  1\nglobal const arw_hide =  8\nglobal const arw_topleft =  2\nglobal const arw_topright =  3\nglobal const arw_down =  4\nglobal const arw_left =  0\nglobal const arw_right =  0\nglobal const arw_up =  4\nglobal const white_brush =  0\nglobal const ltgray_brush =  1\nglobal const gray_brush =  2\nglobal const dkgray_brush =  3\nglobal const black_brush =  4\nglobal const null_brush =  5\nglobal const hollow_brush =  5\nglobal const white_pen =  6\nglobal const black_pen =  7\nglobal const null_pen =  8\nglobal const oem_fixed_font =  10\nglobal const ansi_fixed_font =  11\nglobal const ansi_var_font =  12\nglobal const system_font =  13\nglobal const device_default_font =  14\nglobal const default_palette =  15\nglobal const system_fixed_font =  16\nglobal const stock_last =  16\n\n!global const sbm_setpos =  224\n!global const sbm_getpos =  225\n!global const sbm_setrange =  226\n!global const sbm_setrangeredraw =  230\n!global const sbm_getrange =  227\n!global const sbm_enable_arrows =  228\n!global const sbs_horz =  0\n!global const sbs_vert =  1\n!global const sbs_topalign =  2\n!global const sbs_leftalign =  2\n!global const sbs_bottomalign =  4\n!global const sbs_rightalign =  4\n!global const sbs_sizeboxtopleftalign =  2\n!global const sbs_sizeboxbottomrightalign =  4\n!global const sbs_sizebox =  8\n\nglobal const wm_hscroll =  276\nglobal const wm_vscroll =  277\n\n!global const sb_horz =  0\n!global const sb_hoz =  0\n!global const sb_vert =  1\n!global const sb_ctl =  2\n!global const sb_both =  3\n!global const sb_lineup =  0\n!global const sb_lineleft =  0\n!global const sb_linedown =  1\n!global const sb_lineright =  1\n!global const sb_pageup =  2\n!global const sb_pageleft =  2\n!global const sb_pagedown =  3\n!global const sb_pageright =  3\n!global const sb_thumbposition =  4\n!global const sb_thumbtrack =  5\n!global const sb_top =  6\n!global const sb_left =  6\n!global const sb_bottom =  7\n!global const sb_right =  7\n!global const sb_endscroll =  8\n!global const sif_disablenoscroll =  8\n!global const sif_page =  2\n!global const sif_pos =  4\n!global const sif_range =  1\n!global const sif_trackpos =  16\n!global const sif_all =  23\n\nglobal const wm_ctlcolourmsgbox =  306\nglobal const wm_ctlcolouredit =  307\nglobal const wm_ctlcolourlistbox =  308\nglobal const wm_ctlcolourbtn =  309\nglobal const wm_ctlcolourdlg =  310\nglobal const wm_ctlcolourscrollbar =  311\nglobal const wm_ctlcolourstatic =  312\nglobal const wm_timer =  275\n\nglobal const srccopy =  13369376\nglobal const srcpaint =  15597702\nglobal const srcand =  8913094\nglobal const srcinvert =  6684742\nglobal const srcerase =  4457256\n\nglobal const notsrccopy =  3342344\nglobal const notsrcerase =  1114278\nglobal const mergecopy =  12583114\nglobal const mergepaint =  12255782\nglobal const patcopy =  15728673\nglobal const patpaint =  16452105\nglobal const patinvert =  5898313\nglobal const dstinvert =  5570569\nglobal const blackness =  66\nglobal const whiteness =  16711778\n\nglobal const r2_black =  1\nglobal const r2_notmergepen =  2\nglobal const r2_masknotpen =  3\nglobal const r2_notcopypen =  4\nglobal const r2_maskpennot =  5\nglobal const r2_not =  6\nglobal const r2_xorpen =  7\nglobal const r2_notmaskpen =  8\nglobal const r2_maskpen =  9\nglobal const r2_notxorpen =  10\nglobal const r2_nop =  11\nglobal const r2_mergenotpen =  12\nglobal const r2_copypen =  13\nglobal const r2_mergepennot =  14\nglobal const r2_mergepen =  15\nglobal const r2_white =  16\nglobal const r2_last =  16\n\nglobal const gdi_error =  4294967295\nglobal const hgdi_error =  4294967295\nglobal const clr_invalid =  4278190080\nglobal const clr_default =  4278190080\nglobal const clr_none =  4294967295\nglobal const ofn_readonly =  1\nglobal const ofn_overwriteprompt =  2\nglobal const ofn_hidereadonly =  4\nglobal const ofn_nochangedir =  8\nglobal const ofn_showhelp =  16\nglobal const ofn_enablehook =  32\nglobal const ofn_enabletemplate =  64\nglobal const ofn_enabletemplatehandle =  128\nglobal const ofn_novalidate =  256\nglobal const ofn_allowmultiselect =  512\nglobal const ofn_extensiondifferent =  1024\nglobal const ofn_pathmustexist =  2048\nglobal const ofn_filemustexist =  4096\nglobal const ofn_createprompt =  8192\nglobal const ofn_shareaware =  16384\nglobal const ofn_noreadonlyreturn =  32768\nglobal const ofn_notestfilecreate =  65536\nglobal const ofn_nonetworkbutton =  131072\nglobal const ofn_nolongnames =  262144\nglobal const ofn_explorer =  524288\nglobal const ofn_nodereferencelinks =  1048576\nglobal const ofn_longnames =  2097152\nglobal const ofn_sharefallthrough =  2\nglobal const ofn_sharenowarn =  1\nglobal const ofn_sharewarn =  0\n!global const gmem_fixed =  0\n!global const gmem_moveable =  2\n!global const gmem_nocompact =  16\n!global const gmem_nodiscard =  32\n!global const gmem_zeroinit =  64\n!global const gmem_modify =  128\n!global const gmem_discardable =  256\n!global const gmem_not_banked =  4096\n!global const gmem_share =  8192\n!global const gmem_ddeshare =  8192\n!global const gmem_notify =  16384\n!global const gmem_lower =  4096\n!global const gmem_valid_flags =  32626\n!global const gmem_invalid_handle =  32768\n!global const gmem_clipboard =  8194\n!global const ghnd =  66\n!global const gptr =  64\n!global const pd_allpages =  0\n!global const pd_collate =  16\n!global const pd_disableprinttofile =  524288\n!global const pd_enableprinthook =  4096\n!global const pd_enableprinttemplate =  16384\n!global const pd_enableprinttemplatehandle =  65536\n!global const pd_enablesetuphook =  8192\n!global const pd_enablesetuptemplate =  32768\n!global const pd_enablesetuptemplatehandle =  131072\n!global const pd_hideprinttofile =  1048576\n!global const pd_nopagenums =  8\n!global const pd_noselection =  4\n!global const pd_nowarning =  128\n!global const pd_pagenums =  2\n!global const pd_printsetup =  64\n!global const pd_printtofile =  32\n!global const pd_returndc =  256\n!global const pd_returndefault =  1024\n!global const pd_returnic =  512\n!global const pd_selection =  1\n!global const pd_showhelp =  2048\n!global const pd_usedevmodecopies =  262144\n!global const pd_usedevmodecopiesandcollate =  262144\nglobal const dib_rgb_colours =  0\nglobal const dib_pal_colours =  1\nglobal const dib_pal_indices =  2\nglobal const dib_pal_physindices =  2\nglobal const dib_pal_logindices =  4\nglobal const stm_seticon =  368\nglobal const stm_setimage =  370\nglobal const lr_loadfromfile =  16\nglobal const image_bitmap =  0\nglobal const image_icon =  1\nglobal const lr_copydeleteorg =  8\nglobal const lr_copyreturnorg =  4\nglobal const lr_monochrome =  1\nglobal const lr_createdibsection =  8192\nglobal const lr_defaultsize =  64\nglobal const ss_icon =  3\nglobal const ss_bitmap =  14\nglobal const gcl_menuname =  -8\nglobal const gcl_hbrbackground =  -10\nglobal const gcl_hcursor =  -12\nglobal const gcl_hicon =  -14\nglobal const gcl_hmodule =  -16\nglobal const gcl_cbwndextra =  -18\nglobal const gcl_cbclsextra =  -20\nglobal const gcl_wndproc =  -24\nglobal const gcl_style =  -26\nglobal const gcw_atom =  -32\nglobal const colour_scrollbar =  0\nglobal const colour_background =  1\nglobal const colour_desktop =  1\nglobal const colour_activecaption =  2\nglobal const colour_inactivecaption =  3\nglobal const colour_menu =  4\nglobal const colour_window =  5\nglobal const colour_windowframe =  6\nglobal const colour_menutext =  7\nglobal const colour_windowtext =  8\nglobal const colour_captiontext =  9\nglobal const colour_activeborder =  10\nglobal const colour_inactiveborder =  11\nglobal const colour_appworkspace =  12\nglobal const colour_highlight =  13\nglobal const colour_highlighttext =  14\nglobal const colour_btnface =  15\nglobal const colour_3dface =  15\nglobal const colour_btnshadow =  16\nglobal const colour_3dshadow =  16\nglobal const colour_graytext =  17\nglobal const colour_btntext =  18\nglobal const colour_inactivecaptiontext =  19\nglobal const colour_btnhighlight =  20\nglobal const colour_3dhilight =  20\nglobal const colour_3ddkshadow =  21\nglobal const colour_3dlight =  22\nglobal const colour_infotext =  23\nglobal const colour_infobk =  24\nglobal const colour_tooltipbk =  24\nglobal const mk_lbutton =  1\nglobal const mk_rbutton =  2\nglobal const mk_shift =  4\nglobal const mk_control =  8\nglobal const mk_mbutton =  16\nglobal const cbm_createdib =  2\nglobal const cbm_init =  4\nglobal const cc_enablehook =  16\nglobal const cc_enabletemplate =  32\nglobal const cc_enabletemplatehandle =  64\nglobal const cc_fullopen =  2\nglobal const cc_preventfullopen =  4\nglobal const cc_rgbinit =  1\nglobal const cc_showhelp =  8\nglobal const cc_solidcolour =  128\nglobal const cf_screenfonts =  1\nglobal const cf_printerfonts =  2\nglobal const cf_effects =  256\nglobal const size_restored =  0\nglobal const size_minimized =  1\nglobal const size_maximized =  2\nglobal const size_maxshow =  3\nglobal const size_maxhide =  4\n!global const gwl_wndproc =  -4\n!global const gwl_hinstance =  -6\n!global const gwl_hwndparent =  -8\n!global const gwl_style =  -16\n!global const gwl_exstyle =  -20\nglobal const gwl_userdata =  -21\nglobal const gwl_id =  -12\nglobal const ta_top =  0\nglobal const ta_left =  0\nglobal const ta_noupdatecp =  0\nglobal const ta_updatecp =  1\nglobal const ta_right =  2\nglobal const ta_centre =  6\nglobal const vta_centre =  6\nglobal const ta_bottom =  8\nglobal const ta_baseline =  24\nglobal const vta_baseline =  24\nglobal const ta_rtlreading =  256\nglobal const aligntop =  0\nglobal const alignbottom =  8\nglobal const alignbaseline =  24\nglobal const aligncentre =  6\nglobal const alignleft =  0\nglobal const alignright =  2\n\nglobal const em_exgetsel =  1076\nglobal const em_exlimittext =  1077\nglobal const em_exlinefromchar =  1078\nglobal const em_exsetsel =  1079\nglobal const em_getparaformat =  1085\nglobal const em_setparaformat =  1095\nglobal const em_streamin =  1097\nglobal const em_streamout =  1098\nglobal const em_gettextrange =  1099\nglobal const em_findtext =  1080\nglobal const em_findtextex =  1103\n\n!global const ttf_idishwnd =  1\n!global const ttf_centretip =  2\n!global const ttf_rtlreading =  4\n!global const ttf_subclass =  16\n!global const ttf_track =  32\n!global const ttf_absolute =  128\n!global const ttf_transparent =  256\n!global const ttf_di_setitem =  32768\n\nglobal const hwnd_top =  0\nglobal const hwnd_bottom =  1\nglobal const hwnd_topmost =  -1\nglobal const hwnd_notopmost =  -2\n\nglobal const normalwind =  0\nglobal const modalwind =  -1\nglobal const dialogwind =  -2\nglobal const minimize =  2\nglobal const maximize =  3\nglobal const shiftmask =  1\nglobal const controlmask =  2\nglobal const altmask =  4\nglobal const windowcolour =  15\nglobal const ps_geometric =  65536\nglobal const ps_cosmetic =  0\nglobal const ps_alternate =  8\nglobal const ps_solid =  0\nglobal const ps_dash =  1\nglobal const ps_dot =  2\nglobal const ps_dashdot =  3\nglobal const ps_dashdotdot =  4\nglobal const ps_null =  5\nglobal const ps_insideframe =  6\nglobal const ps_userstyle =  7\nglobal const ps_endcap_round =  0\nglobal const ps_endcap_square =  256\nglobal const ps_endcap_flat =  512\nglobal const ps_join_bevel =  4096\nglobal const ps_join_miter =  8192\nglobal const ps_join_round =  0\nglobal const ps_style_mask =  15\nglobal const ps_endcap_mask =  3840\nglobal const ps_type_mask =  983040\nglobal const bs_solid =  0\nglobal const bs_hollow =  1\nglobal const bs_null =  1\nglobal const bs_hatched =  2\nglobal const bs_pattern =  3\nglobal const bs_dibpattern =  5\nglobal const bs_dibpatternpt =  6\nglobal const bs_pattern8x8 =  7\nglobal const bs_dibpattern8x8 =  8\nglobal const hs_horizontal =  0\nglobal const hs_vertical =  1\nglobal const hs_fdiagonal =  2\nglobal const hs_bdiagonal =  3\nglobal const hs_cross =  4\nglobal const hs_diagcross =  5\n\n!global const gl_points =  0\n!global const gl_lines =  1\n!global const gl_line_loop =  2\n!global const gl_line_strip =  3\n!global const gl_triangles =  4\n!global const gl_triangle_strip =  5\n!global const gl_triangle_fan =  6\n!global const gl_quads =  7\n!global const gl_quad_strip =  8\n!global const gl_polygon =  9\n\nglobal const spi_getworkarea =  48\n\nproc start=\nend\n\n",
    
(byte*)"!import winmessages\n!import winconsts\n!import gxmisc\n!import winapi\n\n!module winapi\n\nexport var hwapplic=nil\nexport var hwchild=nil\nexport var iswin32\nexport var screendc\n\nexport var nglobalfonts=0\nexport var fonttable::=()\t\t\t![]font handles\nexport var fontdimtable::=()\t\t![]rpoint (width,total line height)\nexport var fontvdimtable::=()\t\t![]rpoint (ascenders, descenders) \n\nproc start\t=\n\tinitdata()\nend\n\nproc initdata=\n!CPL \"---------WINGXLIB\"\n\tiswin32:=(getos()=\"W32\")\n\tscreendc:=getdc(nil)\n\n\tfonttable:=(0,)*20\n\tfontdimtable:=(0,)*20\n\tfontvdimtable:=(0,)*20\n\n\tfonttable[1]:=getstockobject(17)\t!default gui\n\tfonttable[2]:=getstockobject(13)\t!system font\n\tfonttable[3]:=getstockobject(16)\t!system fixed\n\tfonttable[4]:=getstockobject(10)\t!oem fixed\n\tfor i:=1 to 4 do\n\t\tfontdimtable[i]::=ws_point(0,0)\n\t\tfontvdimtable[i]::=ws_point(0,0)\n\tod\n\tnglobalfonts:=4\nend\n\nfunc checkoption(optionnames,optionvalues,name,default=-1)=\n!search for option with given name\n!return value of option, or -1 if not present\n!options (which can be void) will be a list of (name,value) list pairs\n\n\tn:=name in optionnames\n\tif not n then return default fi\n\treturn optionvalues[n]\nend\n\nglobal proc wx_waitmess=\n\twindmsg:=new((iswin32|ws_msg32|ws_msg64))\n\n\tdo\n\t\tif getmessage(&windmsg,nil,0,0)<>0 then\n\t\t\tw:=windmsg.hwnd\n\t\t\tif windmsg.message=wm_keydown and windmsg.wparam=27 then exit fi\n\t\t\tif windmsg.message=wm_timer then CPL \"TIMER!!\" fi\n\t\t\ttranslatemessage(&windmsg)\n\t\t\tdispatchmessage(&windmsg)\n\t\t\tif windmsg.message=wm_close then exit fi\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\nend\n\nglobal func wx_getw(hwnd)=\n!return allwindow-index of window that has been stored into it\n\tn:=getwindowlongptr(hwnd, gwl_userdata)\n\treturn n\nend\n\nglobal proc wx_setw(hwnd,index)=\n!store mm window handle into win32 window\n!index is .gindex (index into allwindows)\n\tsetwindowlongptr(hwnd, gwl_userdata, index)\nend\n\nglobal func wx_gettextwidth(hdc,s)=\n\tsize:=new(ws_point)\n\tgettextextentpoint32(hdc,s,s.len,&size)\n\treturn size.x\nend\n\nglobal func wx_createpopup(?caption,?pos,?dim,?options,owner=nil)=\n!wrapper around win32 createwindow\n!return win32 handle to newly created window\n\tconst gap=40\n\tconst smallestwidth=150\n\n\tif options.isvoid then\n options:=[wf_caption:1,wf_border:wbs_resize]\n\tfi\n\n\tposx:=posy:=-1\n\tdimx:=640\n\tdimy:=480\n\tfcentre:=0\n\tfautopos:=0\n\tfmax:=fdesktop:=0\n\n\tif caption.isvoid then caption:=\"<No Caption>\" fi\n\n\tif dim.defined then\n\t\tif dim.isstring and dim=\"max\" then\n\t\t\tfmax:=1\n\t\telsif dim.isstring and dim=\"desktop\" then\n\t\t\tfdesktop:=1\n\t\telse\n\t\t\tdimx:=dim[1]\n\t\t\tdimy:=dim[2]\n\t\tfi\n\tfi\n\n\tif pos.isvoid or pos=\"cent\" then\n\t\tfcentre:=1\n\telsif pos=\"auto\" then\n\t\tfautopos:=1\n\telsif pos.defined and not pos.isstring then\n\t\tposx:=pos[1]\n\t\tposy:=pos[2]\n\telse\t\t\t\t!check options?\n\t\tabort(\"gxcw bad pos\")\n\tfi\n\n\tbstyle:=bxstyle:=0\n\tnocap:=0\t\t\t!whether to suppress caption\n\n\tframex:=framey:=0\n\n\tcase options{wf_border,wbs_resize}\n\twhen wbs_none then\t\t!no border\n\t\tnocap:=1\n\t\tframex:=0\n\t\tframey:=0\n\twhen wbs_simple then\t\t!single line\n\t\tnocap:=1\n\t\tbstyle:=ws_border\n\t\tframex:=1\n\t\tframey:=1\n\twhen wbs_thick then\t\t!thick line\n\t\tbstyle:=ws_dlgframe\n\t\tfixedframe:=0\n\t\tframex:=getsystemmetrics(sm_cxfixedframe)\n\t\tframey:=getsystemmetrics(sm_cyfixedframe)\n\twhen wbs_resize then\n\t\tbstyle:=ws_sizebox\n\t\tframex:=getsystemmetrics(sm_cxsizeframe)\n\t\tframey:=getsystemmetrics(sm_cysizeframe)\n\twhen wbs_sunken,wbs_sunken2 then\t\t!sunken\n\t\tbstyle:=ws_dlgframe\n\t\tbxstyle:=ws_ex_clientedge\n\t\tframex:=5\n\t\tframey:=5\n\twhen wbs_sunkenrs then\n\t\tbstyle:=ws_sizebox\n\t\tbxstyle:=ws_ex_clientedge\n\t\tframex:=6\n\t\tframey:=6\n\tesac\n\n\tcapheight:=getsystemmetrics(sm_cycaption)\n\tmbheight:=getsystemmetrics(sm_cymenu)\n\n\tstyle:=0\n\texstyle:=0\n\n\tif options{wf_show,1} then\n\t\tstyle ior:=ws_visible\n\tfi\n\n\tmxleft:=framex\n\tmxright:=framey\n\tmytop:=framey+capheight\n\tmybottom:=framey\n\tshowstyle:=sw_shownormal\n\n\thcwmenu:=nil\n\tif options{wf_menu,0}=1 then\n\t\tmytop+:=mbheight\n\t\thcwmenu:=createmenu()\n\t\tappendmenu(hcwmenu,0,998,\"fred\")\n\tfi\n\n\tstyle ior:=ws_clipchildren\n\n\tif nocap or options{wf_caption,1}=0 then\n\t\tmytop-:=capheight\n\t\tstyle ior:=ws_popup\n\tfi\n\n\tif options{wf_iframe,0}=0 then\n\t\tif not fautopos then\n\t\t\tposx-:=mxleft\n\t\t\tposy-:=mytop\n\t\tfi\n\t\tdimx+:=mxleft+mxright\n\t\tdimy+:=mytop+mybottom\n\tfi\n\n\tif fcentre or options{wf_cent,0}=1 then\n\t\tfautopos:=0\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\t\tposx:=box.rightx%2-dimx%2\n\t\tposy:=(box.bottom-box.top)%2-dimy%2+box.top\n\tfi\n\n\tif fmax or options{wf_max,0} then\n\t\tshowstyle:=sw_maximize\n\t\tstyle ior:=ws_maximize\n\tfi\n\n\n\tif options{wf_minmax,1}=1 then\n\t\tstyle ior:=(ws_maximizebox ior ws_minimizebox)\n\n\tfi\n\n\tif options{wf_sysmenu,1}=1 then\n\t\tstyle ior:=ws_sysmenu\n\tfi\n\n\tif fautopos=0 and options{wf_clip,0}=1 then\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\n\t\tif posx<box.leftx+gap then posx:=box.leftx+gap fi\n\n\t\tif posy<box.top+gap then posy:=box.top+gap fi\n\t\tdimxmin:=dimx max smallestwidth\n\t\tif posx+dimxmin>=box.rightx+gap then posx:=box.rightx-gap-dimxmin fi\n\t\tif posy+dimy>=box.bottom+gap then posy:=box.bottom-gap-dimy fi\n\telsif fautopos then\n\t\tposx:=posy:=cw_usedefault\n\tfi\n\n\tif fdesktop or options{wf_desktop,0}=1 then\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\t\tposx:=box.leftx\n\t\tposy:=box.top\n\t\tdimx:=box.rightx-box.leftx\n\t\tdimy:=box.bottom-box.top\n\tfi\n\n\tif options{wf_toolwind,0}=1 then\n\t\texstyle ior:=ws_ex_toolwindow\n\tfi\n\n\tclassname:=\"pcc001\"\n\n\tSTYLE IOR:=WS_VISIBLE\n\n\tstyle ior:=bstyle\n\texstyle ior:=bxstyle\n\n\thwnd:=createwindowex(\n\t\texstyle,\n\t\tclassname,\n\t\tcaption,\n\t\tstyle,\n\t\tposx,posy,\t\t\t!initial position and size\n\t\tdimx,dimy,\n\t\towner,\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\n\t\thcwmenu,\t\t\t!menu handle\n\t\tnil,\t!proginstance,\t\t!instance handle\n\t\tnil)\t\t\t!creation params\n\n\tif hwnd=nil then\n\t\te:=getlasterror()\n\t\tabort(\"wx:Can't create popup window \"+tostr(e))\n\tfi\n\treturn hwnd\nend\n\nglobal func wx_createcontrol(?pos,?dim,border=wbs_simple,owner)=\n!wrapper around win32 createwindow\n!return win32 handle to newly created window\n\tconst gap=40\n\tconst smallestwidth=150\n\n\tposx:=posy:=0\n\tdimx:=160\n\tdimy:=120\n\n\tif dim.defined then\n\t\tdimx:=dim[1]\n\t\tdimy:=dim[2]\n\tfi\n\n\tif pos.defined then\n\t\tposx:=pos[1]\n\t\tposy:=pos[2]\n\tfi\n\n\tbstyle:=bxstyle:=0\n\n\tcase border\n\twhen wbs_none then\t\t\t!no border\n\twhen wbs_simple then\t\t!single line\n\t\tbstyle:=ws_border\n\telse\n\t\tpcerror(\"createcontrol/bad border \"+wbsnames[border])\n\tesac\n\n\tstyle:=0\n\texstyle:=0\n\n\tstyle ior:=ws_clipchildren\n\n\tclassname:=\"pcc001\"\n\n\tstyle ior:=ws_child\n\tstyle ior:=ws_visible\n\n\tstyle ior:=bstyle\n\texstyle ior:=bxstyle\n\n\thwnd:=createwindowex(\n\t\texstyle,\n\t\tclassname,\n\t\tnil,\n\t\tstyle,\n\t\tposx,posy,\t\t\t!initial position and size\n\t\tdimx,dimy,\n\t\towner,\t\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\n\t\tnil,\t\t\t\t!menu handle\n\t\tnil,\n\t\tnil)\t\t\t\t!creation params\n\n\tif hwnd=0 then\n\t\te:=getlasterror()\n\t\tabort(\"wx:Can't create child window \"+tostr(e))\n\tfi\n\n\treturn hwnd\nend\n\n",
    
(byte*)"export var winmessagenames=[\n\t(0:\"wm_null\"),\n\t(1:\"wm_create\"),\n\t(2:\"wm_destroy\"),\n\t(3:\"wm_move\"),\n\t(4:\"pgk_menu\"),\n\t(5:\"wm_size\"),\n\t(6:\"wm_activate\"),\n\t(7:\"wm_setfocus\"),\n\t(8:\"wm_killfocus\"),\n\t(9:\"cbn_selendok\"),\n\t(10:\"wm_enable\"),\n\t(11:\"wm_setredraw\"),\n\t(12:\"wm_settext\"),\n\t(13:\"wm_gettext\"),\n\t(14:\"wm_gettextlength\"),\n\t(15:\"wm_paint\"),\n\t(16:\"wm_close\"),\n\t(17:\"wm_queryendsession\"),\n\t(18:\"wm_quit\"),\n\t(19:\"wm_queryopen\"),\n\t(20:\"wm_erasebkgnd\"),\n\t(21:\"wm_syscolorchange\"),\n\t(22:\"wm_endsession\"),\n\t(24:\"wm_showwindow\"),\n\t(26:\"wm_wininichange\"),\n\t(27:\"wm_devmodechange\"),\n\t(28:\"wm_activateapp\"),\n\t(29:\"wm_fontchange\"),\n\t(30:\"wm_timechange\"),\n\t(31:\"wm_cancelmode\"),\n\t(32:\"wm_setcursor\"),\n\t(33:\"wm_mouseactivate\"),\n\t(34:\"wm_childactivate\"),\n\t(35:\"wm_queuesync\"),\n\t(36:\"wm_getminmaxinfo\"),\n\t(38:\"wm_painticon\"),\n\t(39:\"wm_iconerasebkgnd\"),\n\t(40:\"wm_nextdlgctl\"),\n\t(42:\"wm_spoolerstatus\"),\n\t(43:\"wm_drawitem\"),\n\t(44:\"wm_measureitem\"),\n\t(45:\"wm_deleteitem\"),\n\t(46:\"wm_vkeytoitem\"),\n\t(47:\"wm_chartoitem\"),\n\t(48:\"wm_setfont\"),\n\t(49:\"wm_getfont\"),\n\t(50:\"wm_sethotkey\"),\n\t(51:\"wm_gethotkey\"),\n\t(55:\"wm_querydragicon\"),\n\t(57:\"wm_compareitem\"),\n\t(64:\"tbif_size\"),\n\t(65:\"wm_compacting\"),\n\t(70:\"wm_windowposchanging\"),\n\t(71:\"wm_windowposchanged\"),\n\t(72:\"wm_power\"),\n\t(74:\"wm_copydata\"),\n\t(75:\"wm_canceljournal\"),\n\t(78:\"wm_notify\"),\n\t(80:\"wm_inputlangchangerequest\"),\n\t(81:\"wm_inputlangchange\"),\n\t(82:\"wm_tcard\"),\n\t(83:\"wm_help\"),\n\t(84:\"wm_userchanged\"),\n\t(85:\"wm_notifyformat\"),\n\t(123:\"wm_contextmenu\"),\n\t(124:\"wm_stylechanging\"),\n\t(125:\"wm_stylechanged\"),\n\t(126:\"wm_displaychange\"),\n\t(127:\"wm_geticon\"),\n\t(128:\"wm_seticon\"),\n\t(129:\"wm_nccreate\"),\n\t(130:\"wm_ncdestroy\"),\n\t(131:\"wm_nccalcsize\"),\n\t(132:\"wm_nchittest\"),\n\t(133:\"wm_ncpaint\"),\n\t(134:\"wm_ncactivate\"),\n\t(135:\"wm_getdlgcode\"),\n\t(160:\"wm_ncmousemove\"),\n\t(161:\"wm_nclbuttondown\"),\n\t(162:\"wm_nclbuttonup\"),\n\t(163:\"wm_nclbuttondblclk\"),\n\t(164:\"wm_ncrbuttondown\"),\n\t(165:\"wm_ncrbuttonup\"),\n\t(166:\"wm_ncrbuttondblclk\"),\n\t(167:\"wm_ncmbuttondown\"),\n\t(168:\"wm_ncmbuttonup\"),\n\t(169:\"wm_ncmbuttondblclk\"),\n\t(176:\"em_getsel\"),\n\t(177:\"em_setsel\"),\n\t(178:\"em_getrect\"),\n\t(179:\"em_setrect\"),\n\t(180:\"em_setrectnp\"),\n\t(181:\"em_scroll\"),\n\t(182:\"em_linescroll\"),\n\t(183:\"em_scrollcaret\"),\n\t(184:\"em_getmodify\"),\n\t(185:\"em_setmodify\"),\n\t(186:\"em_getlinecount\"),\n\t(187:\"em_lineindex\"),\n\t(188:\"em_sethandle\"),\n\t(189:\"em_gethandle\"),\n\t(190:\"em_getthumb\"),\n\t(193:\"em_linelength\"),\n\t(194:\"em_replacesel\"),\n\t(196:\"em_getline\"),\n\t(197:\"em_setlimittext\"),\n\t(198:\"em_canundo\"),\n\t(199:\"em_undo\"),\n\t(200:\"em_fmtlines\"),\n\t(201:\"em_linefromchar\"),\n\t(203:\"em_settabstops\"),\n\t(204:\"em_setpasswordchar\"),\n\t(205:\"em_emptyundobuffer\"),\n\t(206:\"em_getfirstvisibleline\"),\n\t(207:\"em_setreadonly\"),\n\t(208:\"em_setwordbreakproc\"),\n\t(209:\"em_getwordbreakproc\"),\n\t(210:\"em_getpasswordchar\"),\n\t(211:\"em_setmargins\"),\n\t(212:\"em_getmargins\"),\n\t(213:\"em_getlimittext\"),\n\t(214:\"em_posfromchar\"),\n\t(215:\"em_charfrompos\"),\n\t(224:\"sbm_setpos\"),\n\t(225:\"sbm_getpos\"),\n\t(226:\"sbm_setrange\"),\n\t(227:\"sbm_getrange\"),\n\t(228:\"sbm_enable_arrows\"),\n\t(230:\"sbm_setrangeredraw\"),\n\t(233:\"sbm_setscrollinfo\"),\n\t(234:\"sbm_getscrollinfo\"),\n\t(240:\"bm_getcheck\"),\n\t(241:\"bm_setcheck\"),\n\t(242:\"bm_getstate\"),\n\t(243:\"bm_setstate\"),\n\t(244:\"bm_setstyle\"),\n\t(245:\"bm_click\"),\n\t(246:\"bm_getimage\"),\n\t(247:\"bm_setimage\"),\n\t(255:\"wm_input\"),\n\t(256:\"wm_keydown\"),\n\t(257:\"wm_keyup\"),\n\t(258:\"wm_char\"),\n\t(259:\"wm_deadchar\"),\n\t(260:\"wm_syskeydown\"),\n\t(261:\"wm_syskeyup\"),\n\t(262:\"wm_syschar\"),\n\t(263:\"wm_sysdeadchar\"),\n\t(269:\"wm_ime_startcomposition\"),\n\t(270:\"wm_ime_endcomposition\"),\n\t(271:\"wm_ime_composition\"),\n\t(272:\"wm_initdialog\"),\n\t(273:\"wm_command\"),\n\t(274:\"wm_syscommand\"),\n\t(275:\"wm_timer\"),\n\t(276:\"wm_hscroll\"),\n\t(277:\"wm_vscroll\"),\n\t(278:\"wm_initmenu\"),\n\t(279:\"wm_initmenupopup\"),\n\t(287:\"wm_menuselect\"),\n\t(288:\"wm_menuchar\"),\n\t(289:\"wm_enteridle\"),\n\t(290:\"wm_menurbuttonup\"),\n\t(295:\"wm_changeuistate\"),\n\t(296:\"wm_updateuistate\"),\n\t(297:\"wm_queryuistate\"),\n\t(306:\"wm_ctlcolormsgbox\"),\n\t(307:\"wm_ctlcoloredit\"),\n\t(308:\"wm_ctlcolorlistbox\"),\n\t(309:\"wm_ctlcolorbtn\"),\n\t(310:\"wm_ctlcolordlg\"),\n\t(311:\"wm_ctlcolorscrollbar\"),\n\t(312:\"wm_ctlcolorstatic\"),\n\t(320:\"cb_geteditsel\"),\n\t(321:\"cb_limittext\"),\n\t(322:\"cb_seteditsel\"),\n\t(323:\"cb_addstring\"),\n\t(324:\"cbem_deleteitem\"),\n\t(325:\"cb_dir\"),\n\t(326:\"cb_getcount\"),\n\t(327:\"cb_getcursel\"),\n\t(328:\"cb_getlbtext\"),\n\t(329:\"cb_getlbtextlen\"),\n\t(330:\"cb_insertstring\"),\n\t(331:\"cb_resetcontent\"),\n\t(332:\"cb_findstring\"),\n\t(333:\"cb_selectstring\"),\n\t(334:\"cb_setcursel\"),\n\t(335:\"cb_showdropdown\"),\n\t(336:\"cb_getitemdata\"),\n\t(337:\"cb_setitemdata\"),\n\t(338:\"cb_getdroppedcontrolrect\"),\n\t(339:\"cb_setitemheight\"),\n\t(340:\"cb_getitemheight\"),\n\t(341:\"cb_setextendedui\"),\n\t(342:\"cb_getextendedui\"),\n\t(343:\"cb_getdroppedstate\"),\n\t(344:\"cb_findstringexact\"),\n\t(345:\"cb_setlocale\"),\n\t(346:\"cb_getlocale\"),\n\t(347:\"cb_gettopindex\"),\n\t(348:\"cb_settopindex\"),\n\t(349:\"cb_gethorizontalextent\"),\n\t(350:\"cb_sethorizontalextent\"),\n\t(351:\"cb_getdroppedwidth\"),\n\t(352:\"cb_setdroppedwidth\"),\n\t(353:\"cb_initstorage\"),\n\t(368:\"stm_seticon\"),\n\t(369:\"stm_geticon\"),\n\t(370:\"stm_setimage\"),\n\t(371:\"stm_getimage\"),\n\t(384:\"lb_addstring\"),\n\t(385:\"lb_insertstring\"),\n\t(386:\"lb_deletestring\"),\n\t(387:\"lb_selitemrangeex\"),\n\t(388:\"lb_resetcontent\"),\n\t(389:\"lb_setsel\"),\n\t(390:\"lb_setcursel\"),\n\t(391:\"lb_getsel\"),\n\t(392:\"lb_getcursel\"),\n\t(393:\"lb_gettext\"),\n\t(394:\"lb_gettextlen\"),\n\t(395:\"lb_getcount\"),\n\t(396:\"lb_selectstring\"),\n\t(397:\"lb_dir\"),\n\t(398:\"lb_gettopindex\"),\n\t(399:\"lb_findstring\"),\n\t(400:\"lb_getselcount\"),\n\t(401:\"lb_getselitems\"),\n\t(402:\"lb_settabstops\"),\n\t(403:\"lb_gethorizontalextent\"),\n\t(404:\"lb_sethorizontalextent\"),\n\t(405:\"lb_setcolumnwidth\"),\n\t(406:\"lb_addfile\"),\n\t(407:\"lb_settopindex\"),\n\t(408:\"lb_getitemrect\"),\n\t(409:\"lb_getitemdata\"),\n\t(410:\"lb_setitemdata\"),\n\t(411:\"lb_selitemrange\"),\n\t(412:\"lb_setanchorindex\"),\n\t(413:\"lb_getanchorindex\"),\n\t(414:\"lb_setcaretindex\"),\n\t(415:\"lb_getcaretindex\"),\n\t(416:\"lb_setitemheight\"),\n\t(417:\"lb_getitemheight\"),\n\t(418:\"lb_findstringexact\"),\n\t(421:\"lb_setlocale\"),\n\t(422:\"lb_getlocale\"),\n\t(423:\"lb_setcount\"),\n\t(424:\"lb_initstorage\"),\n\t(425:\"lb_itemfrompoint\"),\n\t(512:\"wm_mousemove\"),\n\t(513:\"wm_lbuttondown\"),\n\t(514:\"wm_lbuttonup\"),\n\t(515:\"wm_lbuttondblclk\"),\n\t(516:\"wm_rbuttondown\"),\n\t(517:\"wm_rbuttonup\"),\n\t(518:\"wm_rbuttondblclk\"),\n\t(519:\"wm_mbuttondown\"),\n\t(520:\"wm_mbuttonup\"),\n\t(521:\"wm_mbuttondblclk\"),\n\t(522:\"wm_mousewheel\"),\n\t(523:\"wm_xbuttondown\"),\n\t(524:\"wm_xbuttonup\"),\n\t(525:\"wm_xbuttondblclk\"),\n\t(528:\"wm_parentnotify\"),\n\t(529:\"wm_entermenuloop\"),\n\t(530:\"wm_exitmenuloop\"),\n\t(531:\"wm_nextmenu\"),\n\t(532:\"wm_sizing\"),\n\t(533:\"wm_capturechanged\"),\n\t(534:\"wm_moving\"),\n\t(536:\"wm_powerbroadcast\"),\n\t(537:\"wm_devicechange\"),\n\t(544:\"wm_mdicreate\"),\n\t(545:\"wm_mdidestroy\"),\n\t(546:\"wm_mdiactivate\"),\n\t(547:\"wm_mdirestore\"),\n\t(548:\"wm_mdinext\"),\n\t(549:\"wm_mdimaximize\"),\n\t(550:\"wm_mditile\"),\n\t(551:\"wm_mdicascade\"),\n\t(552:\"wm_mdiiconarrange\"),\n\t(553:\"wm_mdigetactive\"),\n\t(560:\"wm_mdisetmenu\"),\n\t(561:\"wm_entersizemove\"),\n\t(562:\"wm_exitsizemove\"),\n\t(563:\"wm_dropfiles\"),\n\t(564:\"wm_mdirefreshmenu\"),\n\t(641:\"wm_ime_setcontext\"),\n\t(642:\"wm_ime_notify\"),\n\t(643:\"wm_ime_control\"),\n\t(644:\"wm_ime_compositionfull\"),\n\t(645:\"wm_ime_select\"),\n\t(646:\"wm_ime_char\"),\n\t(656:\"wm_ime_keydown\"),\n\t(657:\"wm_ime_keyup\"),\n\t(673:\"wm_mousehover\"),\n\t(675:\"wm_mouseleave\"),\n\t(689:\"wm_wtssession_change\"),\n\t(768:\"wm_cut\"),\n\t(769:\"wm_copy\"),\n\t(770:\"wm_paste\"),\n\t(771:\"wm_clear\"),\n\t(772:\"wm_undo\"),\n\t(773:\"wm_renderformat\"),\n\t(774:\"wm_renderallformats\"),\n\t(775:\"wm_destroyclipboard\"),\n\t(776:\"wm_drawclipboard\"),\n\t(777:\"wm_paintclipboard\"),\n\t(778:\"wm_vscrollclipboard\"),\n\t(779:\"wm_sizeclipboard\"),\n\t(780:\"wm_askcbformatname\"),\n\t(781:\"wm_changecbchain\"),\n\t(782:\"wm_hscrollclipboard\"),\n\t(783:\"wm_querynewpalette\"),\n\t(784:\"wm_paletteischanging\"),\n\t(785:\"wm_palettechanged\"),\n\t(786:\"wm_hotkey\"),\n\t(791:\"wm_print\"),\n\t(792:\"wm_printclient\"),\n\t(896:\"wm_penwinirst\"),\n\t(911:\"wm_penwinlast\"),\n\t(1024:\"infotipsize\"),\n\t(1025:\"cbem_insertitema\"),\n\t(1026:\"cbem_setimagelist\"),\n\t(1027:\"cbem_getimagelist\"),\n\t(1028:\"cbem_getitema\"),\n\t(1029:\"cbem_setitema\"),\n\t(1030:\"cbem_getcombocontrol\"),\n\t(1031:\"cbem_geteditcontrol\"),\n\t(1032:\"cbem_setexstyle\"),\n\t(1033:\"cbem_getextendedstyle\"),\n\t(1034:\"cbem_haseditchanged\"),\n\t(1035:\"cbem_insertitemw\"),\n\t(1036:\"cbem_setitemw\"),\n\t(1037:\"cbem_getitemw\"),\n\t(1038:\"cbem_setextendedstyle\"),\n\t(1039:\"ttm_getcurrenttoola\"),\n\t(1040:\"ttm_windowfrompoint\"),\n\t(1041:\"ttm_trackactivate\"),\n\t(1042:\"ttm_trackposition\"),\n\t(1043:\"ttm_settipbkcolor\"),\n\t(1044:\"ttm_settiptextcolor\"),\n\t(1045:\"ttm_getdelaytime\"),\n\t(1046:\"ttm_gettipbkcolor\"),\n\t(1047:\"ttm_gettiptextcolor\"),\n\t(1048:\"ttm_setmaxtipwidth\"),\n\t(1049:\"ttm_getmaxtipwidth\"),\n\t(1050:\"ttm_setmargin\"),\n\t(1051:\"ttm_getmargin\"),\n\t(1052:\"ttm_pop\"),\n\t(1053:\"tb_getitemrect\"),\n\t(1054:\"tb_buttonstructsize\"),\n\t(1055:\"tb_setbuttonsize\"),\n\t(1056:\"tb_setbitmapsize\"),\n\t(1057:\"tb_autosize\"),\n\t(1059:\"tb_gettooltips\"),\n\t(1060:\"tb_settooltips\"),\n\t(1061:\"tb_setparent\"),\n\t(1063:\"tb_setrows\"),\n\t(1064:\"tb_getrows\"),\n\t(1065:\"tb_getbitmapflags\"),\n\t(1066:\"tb_setcmdid\"),\n\t(1067:\"tb_changebitmap\"),\n\t(1068:\"tb_getbitmap\"),\n\t(1069:\"tb_getbuttontexta\"),\n\t(1070:\"tb_replacebitmap\"),\n\t(1071:\"tb_setindent\"),\n\t(1072:\"tb_setimagelist\"),\n\t(1073:\"tb_getimagelist\"),\n\t(1074:\"ttm_addtoolw\"),\n\t(1075:\"ttm_deltoolw\"),\n\t(1076:\"ttm_newtoolrectw\"),\n\t(1077:\"ttm_gettoolinfow\"),\n\t(1078:\"ttm_settoolinfow\"),\n\t(1079:\"ttm_hittestw\"),\n\t(1080:\"ttm_gettextw\"),\n\t(1081:\"ttm_updatetiptextw\"),\n\t(1082:\"ttm_enumtoolsw\"),\n\t(1083:\"ttm_getcurrenttoolw\"),\n\t(1084:\"tb_setmaxtextrows\"),\n\t(1085:\"tb_gettextrows\"),\n\t(1086:\"em_getseltext\"),\n\t(1087:\"em_hideselection\"),\n\t(1088:\"em_pastespecial\"),\n\t(1089:\"em_requestresize\"),\n\t(1090:\"em_selectiontype\"),\n\t(1091:\"tb_insertbuttonw\"),\n\t(1092:\"tb_addbuttonsw\"),\n\t(1093:\"tb_hittest\"),\n\t(1094:\"em_setolecallback\"),\n\t(1095:\"em_setparaformat\"),\n\t(1096:\"em_settargetdevice\"),\n\t(1097:\"em_streamin\"),\n\t(1098:\"em_streamout\"),\n\t(1099:\"tb_getbuttontextw\"),\n\t(1100:\"tb_saverestorew\"),\n\t(1101:\"tb_addstringw\"),\n\t(1102:\"em_getoptions\"),\n\t(1103:\"tb_getinsertmark\"),\n\t(1104:\"tb_setinsertmark\"),\n\t(1105:\"tb_insertmarkhittest\"),\n\t(1106:\"tb_movebutton\"),\n\t(1107:\"tb_getmaxsize\"),\n\t(1108:\"tb_setextendedstyle\"),\n\t(1109:\"tb_getextendedstyle\"),\n\t(1110:\"tb_getpadding\"),\n\t(1111:\"tb_setpadding\"),\n\t(1112:\"tb_setinsertmarkcolor\"),\n\t(1113:\"tb_getinsertmarkcolor\"),\n\t(1114:\"tb_mapacceleratorw\"),\n\t(1124:\"em_setpunctuation\"),\n\t(1125:\"wm_choosefont_setlogfont\"),\n\t(1126:\"wm_choosefont_setflags\"),\n\t(1127:\"udm_setpos\"),\n\t(1128:\"udm_getpos\"),\n\t(1129:\"udm_setbuddy\"),\n\t(1130:\"udm_getbuddy\"),\n\t(1131:\"udm_setaccel\"),\n\t(1132:\"udm_getaccel\"),\n\t(1133:\"udm_setbase\"),\n\t(1134:\"udm_getbase\"),\n\t(1135:\"psm_settitlea\"),\n\t(1136:\"psm_setwizbuttons\"),\n\t(1137:\"psm_pressbutton\"),\n\t(1138:\"psm_setcurselid\"),\n\t(1139:\"psm_setfinishtexta\"),\n\t(1140:\"psm_gettabcontrol\"),\n\t(1141:\"psm_isdialogmessage\"),\n\t(1142:\"psm_getcurrentpagehwnd\"),\n\t(1144:\"psm_settitlew\"),\n\t(1145:\"psm_setfinishtextw\"),\n\t(1157:\"dl_begindrag\"),\n\t(1158:\"dl_dragging\"),\n\t(1159:\"dl_dropped\"),\n\t(1160:\"dl_canceldrag\"),\n\t(1280:\"en_errspace\"),\n\t(1281:\"en_maxtext\"),\n\t(1537:\"en_hscroll\"),\n\t(1538:\"en_vscroll\"),\n\t(1792:\"en_msgfilter\"),\n\t(1793:\"en_requestresize\"),\n\t(1794:\"en_selchange\"),\n\t(1795:\"en_dropfiles\"),\n\t(1796:\"en_protected\"),\n\t(1797:\"en_correcttext\"),\n\t(1798:\"en_stopnoundo\"),\n\t(1799:\"en_imechange\"),\n\t(1800:\"en_saveclipboard\"),\n\t(1801:\"en_oleopfailed\"),\n\t(4096:\"lvm_getbkcolor\"),\n\t(4097:\"lvm_setbkcolor\"),\n\t(4098:\"lvm_getimagelist\"),\n\t(4099:\"lvm_setimagelist\"),\n\t(4100:\"lvm_getitemcount\"),\n\t(4101:\"lvm_getitema\"),\n\t(4102:\"lvm_setitema\"),\n\t(4103:\"lvm_insertitema\"),\n\t(4104:\"lvm_deleteitem\"),\n\t(4105:\"lvm_deleteallitems\"),\n\t(4106:\"lvm_getcallbackmask\"),\n\t(4107:\"lvm_setcallbackmask\"),\n\t(4108:\"lvm_getnextitem\"),\n\t(4109:\"lvm_finditema\"),\n\t(4110:\"lvm_getitemrect\"),\n\t(4111:\"lvm_setitemposition\"),\n\t(4112:\"lvm_getitemposition\"),\n\t(4113:\"lvm_getstringwidtha\"),\n\t(4114:\"lvm_hittest\"),\n\t(4115:\"lvm_ensurevisible\"),\n\t(4116:\"lvm_scroll\"),\n\t(4117:\"lvm_redrawitems\"),\n\t(4118:\"lvm_arrange\"),\n\t(4119:\"lvm_editlabela\"),\n\t(4120:\"lvm_geteditcontrol\"),\n\t(4121:\"lvm_getcolumna\"),\n\t(4122:\"lvm_setcolumna\"),\n\t(4123:\"lvm_insertcolumna\"),\n\t(4124:\"lvm_deletecolumn\"),\n\t(4125:\"lvm_getcolumnwidth\"),\n\t(4126:\"lvm_setcolumnwidth\"),\n\t(4129:\"lvm_createdragimage\"),\n\t(4130:\"lvm_getviewrect\"),\n\t(4131:\"lvm_gettextcolor\"),\n\t(4132:\"lvm_settextcolor\"),\n\t(4133:\"lvm_gettextbkcolor\"),\n\t(4134:\"lvm_settextbkcolor\"),\n\t(4135:\"lvm_gettopindex\"),\n\t(4136:\"lvm_getcountperpage\"),\n\t(4137:\"lvm_getorigin\"),\n\t(4138:\"lvm_update\"),\n\t(4139:\"lvm_setitemstate\"),\n\t(4140:\"lvm_getitemstate\"),\n\t(4141:\"lvm_getitemtexta\"),\n\t(4142:\"lvm_setitemtexta\"),\n\t(4143:\"lvm_setitemcount\"),\n\t(4144:\"lvm_sortitems\"),\n\t(4145:\"lvm_setitemposition32\"),\n\t(4146:\"lvm_getselectedcount\"),\n\t(4147:\"lvm_getitemspacing\"),\n\t(4148:\"lvm_getisearchstringa\"),\n\t(4171:\"lvm_getitemw\"),\n\t(4172:\"lvm_setitemw\"),\n\t(4173:\"lvm_insertitemw\"),\n\t(4179:\"lvm_finditemw\"),\n\t(4183:\"lvm_getstringwidthw\"),\n\t(4191:\"lvm_getcolumnw\"),\n\t(4192:\"lvm_setcolumnw\"),\n\t(4193:\"lvm_insertcolumnw\"),\n\t(4211:\"lvm_getitemtextw\"),\n\t(4212:\"lvm_setitemtextw\"),\n\t(4213:\"lvm_getisearchstringw\"),\n\t(4214:\"lvm_editlabelw\"),\n\t(4352:\"tvm_insertitema\"),\n\t(4353:\"tvm_deleteitem\"),\n\t(4354:\"tvm_expand\"),\n\t(4356:\"tvm_getitemrect\"),\n\t(4357:\"tvm_getcount\"),\n\t(4358:\"tvm_getindent\"),\n\t(4359:\"tvm_setindent\"),\n\t(4360:\"tvm_getimagelist\"),\n\t(4361:\"tvm_setimagelist\"),\n\t(4362:\"tvm_getnextitem\"),\n\t(4363:\"tvm_selectitem\"),\n\t(4364:\"tvm_getitema\"),\n\t(4365:\"tvm_setitema\"),\n\t(4366:\"tvm_editlabela\"),\n\t(4367:\"tvm_geteditcontrol\"),\n\t(4368:\"tvm_getvisiblecount\"),\n\t(4369:\"tvm_hittest\"),\n\t(4370:\"tvm_createdragimage\"),\n\t(4371:\"tvm_sortchildren\"),\n\t(4372:\"tvm_ensurevisible\"),\n\t(4373:\"tvm_sortchildrencb\"),\n\t(4374:\"tvm_endeditlabelnow\"),\n\t(4375:\"tvm_getisearchstringa\"),\n\t(4402:\"tvm_insertitemw\"),\n\t(4414:\"tvm_getitemw\"),\n\t(4415:\"tvm_setitemw\"),\n\t(4416:\"tvm_getisearchstringw\"),\n\t(4417:\"tvm_editlabelw\"),\n\t(4608:\"hdm_getitemcount\"),\n\t(4609:\"hdm_insertitema\"),\n\t(4610:\"hdm_deleteitem\"),\n\t(4611:\"hdm_getitema\"),\n\t(4612:\"hdm_setitema\"),\n\t(4613:\"hdm_layout\"),\n\t(4614:\"hdm_hittest\"),\n\t(4618:\"hdm_insertitemw\"),\n\t(4619:\"hdm_getitemw\"),\n\t(4620:\"hdm_setitemw\"),\n\t(4864:\"tcm_first\"),\n\t(4866:\"tcm_getimagelist\"),\n\t(4867:\"tcm_setimagelist\"),\n\t(4868:\"tcm_getitemcount\"),\n\t(4869:\"tcm_getitema\"),\n\t(4870:\"tcm_setitema\"),\n\t(4871:\"tcm_insertitema\"),\n\t(4872:\"tcm_deleteitem\"),\n\t(4873:\"tcm_deleteallitems\"),\n\t(4874:\"tcm_getitemrect\"),\n\t(4875:\"tcm_getcursel\"),\n\t(4876:\"tcm_setcursel\"),\n\t(4877:\"tcm_hittest\"),\n\t(4878:\"tcm_setitemextra\"),\n\t(4904:\"tcm_adjustrect\"),\n\t(4905:\"tcm_setitemsize\"),\n\t(4906:\"tcm_removeimage\"),\n\t(4907:\"tcm_setpadding\"),\n\t(4908:\"tcm_getrowcount\"),\n\t(4909:\"tcm_gettooltips\"),\n\t(4910:\"tcm_settooltips\"),\n\t(4911:\"tcm_getcurfocus\"),\n\t(4912:\"tcm_setcurfocus\"),\n\t(4924:\"tcm_getitemw\"),\n\t(4925:\"tcm_setitemw\"),\n\t(4926:\"tcm_insertitemw\"),\n\t(5120:\"pgm_first\"),\n\t(8192:\"ccm_first\")]\n\nproc start=\nend\n",
    (byte*)"export enumdata optionnames =\n\t(wf_border,\t\t$),\t\t! wbs_simple\n\t(wf_resize,\t\t$),\t\t! 0\n\t(wf_hscroll,\t$),\t\t! 0\n\t(wf_vscroll,\t$),\t\t! 0\n\t(wf_menu,\t\t$),\t\t! 0\n\t(wf_caption,\t$),\t\t! 1\n\t(wf_max,\t\t$),\t\t! 0\n\t(wf_minmax,\t\t$),\t\t! 1\n\t(wf_sysmenu,\t$),\t\t! 1\n\t(wf_desktop,\t$),\t\t! 0\n\t(wf_clip,\t\t$),\t\t! 0\n\t(wf_show,\t\t$),\t\t!\n\t(wf_iframe,\t\t$),\t\t! 1\n\t(wf_cent,\t\t$),\t\t!\n\t(wf_toolwind,\t$)\t\t!\nend\n\n!Windows border styles, used for pop-up windows. Could also be used for\n!some child windows\nexport enumdata wbsnames=\n\t(wbs_none=0,$),\n\t(wbs_simple,$),\n\t(wbs_thick,$),\n\t(wbs_resize,$),\n\t(wbs_sunken,$),\n\t(wbs_sunken2,$),\n\t(wbs_sunkenrs,$),\n\t(wbs_dummy,$)\nend\n",
    
(byte*)"\nexport var daynames=(\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\n\nexport var Monthnames=(\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\n\t\t\"August\",\"September\",\"October\",\"November\",\"December\")\n\nexport var days=(31,28,31, 30,31,30, 31,31,30, 31,30,31)\n\nexport record rdate=\n\tvar day,month,year\nend\n\nexport record rdatetime = \n\tvar\tday\n\tvar\tmonth\n\tvar\tyear\n\tvar\thour\n\tvar\tminute\n\tvar\tsecond\n\tvar\tmilliseconds\n\tvar\tdayofweek\nend\n\n!proc start=\n!end\n!\n!proc main=\n!end\n\nexport func makedatetime(d,m,y, h=0, minute=0, s=0)=\n\n\td:=rdatetime(d,m,y, h,minute,s,0,0)\n\td.dayofweek:=getdow(d)\n\treturn d\nend\n\nexport proc setdow(&d)=\n\td.dayofweek:=getdow(d)\nend\n\nexport func strdate(d,sep=\"-\")=\n!return leftstr(daynames[d.dayofweek],3)+\" \"+tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\n\treturn tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\nend\n\nexport func strtime(d,sep=\":\")=\n\treturn tostr(d.hour)+sep+tostr(d.minute,\"z2\")+sep+tostr(d.second,\"z2\")\nend\n\nexport func strdow(d,n=0)=\n\tif n then\n\t\treturn leftstr(daynames[d.dayofweek],n)\n\telse\n\t\treturn daynames[d.dayofweek]\n\tfi\nend\n\nexport func strdatetime(d,dsep=\"-\",tsep=\":\")=\n\treturn strdate(d,dsep)+\" \"+strtime(d,tsep)\nend\n\nexport func parsedate(s,defdate)=\n!parse string s into a new date record\n!def = default date to work from, eg. for missing year\n!return date record obtained, or 0 if error\n\n\tday:=defdate.day\n\tmonth:=defdate.month\n\tyear:=defdate.year\n\tif s.[1]=\" \" then s:=rightstr(s,-1) fi\n\n\tsepset:=[' ', '-', '/', '.']\n\n\tseppos:=0\n\tfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\n\n\tif not seppos then\t\t!day only\n\t\tday:=strtoval(s)\n\t\tgoto gotday\n\tfi\n\tday:=strtoval(leftstr(s,seppos-1))\n\n\ts:=rightstr(s,-seppos)\t\t!month and possible year\n\tseppos:=0\n\tfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\n\n\tif seppos then\n\t\tmonthstr:=leftstr(s,seppos-1)\n\t\tyearstr:=rightstr(s,s.len-seppos)\n\telse\n\t\tmonthstr:=s\n\t\tyearstr:=\"\"\n\tfi\n\n\tif asc(leftstr(monthstr)) in ['0'..'9'] then\t!numeric month\n\t\tmonth:=strtoval(monthstr)\n\t\tif month<1 or month>12 then\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\tmonth:=0\n\t\tfor i:=1 to 12 do\n\t\t\tif convlc(leftstr(monthnames[i],3))=convlc(leftstr(monthstr,3)) then\n\t\t\t\tmonth:=i\n\t\t\t\texit\n\t\t\tfi\n\t\tod\n\t\tif not month then\n\t\t\treturn 0\n\t\tfi\n\tfi\n\n\tif yearstr<>\"\" then\n\t\tyear:=strtoval(yearstr)\n\t\tif year<200 then\n\t\t\tif year in [00..89] then\n\t\t\t\tyear+:=2000\n\t\t\telse\n\t\t\t\tyear+:=1900\n\t\t\tfi\n\t\tfi\n\tfi\n\ngotday:\n!check the date, rather than correct using addday(d,0)\n\tdd:=days[month] \n\tif leapyear(year) and month=2 then dd+:=1 fi\n\tif day<1 or day>dd then return 0 fi\n\tif year<1990 or year>2089 then return 0 fi\n\treturn makedatetime(day,month,year)\nend\n\nexport func leapyear(y)=\n!return true if y (eg. 1994) is a leap year\n\treturn (y-1900) rem 4=0\nend\n\nexport func getdow(d)=\n!return day of week for given date, returning 1..7 (monday..sunday)\n\treturn ((getday(d)-1) rem 7)+1\nend\n\nexport func getday(d)=\n!return day number for date d, measured from 1.1.90\n\tday:=0\n\tfor i:=1990 to d.year-1 do\n\t\tday+:=(leapyear(i)|366|365)\n\tod\n\n\tfor i:=1 to d.month-1 do\n\t\tday+:=(i=2|(leapyear(d.year)|29|28)|days[i])\n\tod\n\tday+:=d.day\n\treturn day\nend\n\nexport func getdays(m,y)=\n!return no. of days in month m, for year y\n\tif leapyear(y) and m=2 then return 29 fi\n\treturn days[m]\nend\n\nexport func getmonthname(m,?n)=\n\tif not m.isint then\n\t\tm:=m.month\n\tfi\n\tm:=monthnames[m]\n\tif n.defined then m:=leftstr(m,n) fi\n\treturn m\nend\n\nexport func getdayname(d,?n)=\n\tif not d.isint then\n\t\td:=getdow(d)\n\tfi\n\td:=daynames[d]\n\tif n.defined then d:=leftstr(d,n) fi\n\treturn d\nend\n\nexport func addday(d0,i)=\n\td:=d0\n\tif i>0 then\n\t\tto i do\n\t\t\t++d.day\n\t\t\tif d.day>getdays(d.month,d.year) then\n\t\t\t\td.day:=1\n\t\t\t\t++d.month\n\t\t\t\tif d.month>12 then\n\t\t\t\t\td.month:=1\n\t\t\t\t\t++d.year\n\t\t\t\tfi\n\t\t\tfi\n\t\tod\n\telse\n\t\tto -i do\n\t\t\t--d.day\n\t\t\tif d.day<1 then\n\t\t\t\t--d.month\n\t\t\t\tif d.month<1 then\n\t\t\t\t\td.month:=12\n\t\t\t\t\t--d.year\n\t\t\t\tfi\n\t\t\t\td.day:=getdays(d.month,d.year)\n\t\t\tfi\n\t\tod\n\tfi\n\n!do checking\n\tif d.year<1990 then d:=makedatetime(1,1,1990) fi\n\tif d.year>2089 then d:=makedatetime(31,12,2089) fi\n\n\tdd:=getdays(d.month,d.year)\n\tif leapyear(d.year) and d.month=2 then dd+:=1 fi\n\tif d.day<1 then d.day:=1 fi\n\tif d.day>dd then d.day:=dd fi\n\tsetdow(d)\n\treturn d\nend\n\nexport func getdatetime=\n\ttm:=getsystime()\n\n\treturn rdatetime(tm.day,tm.month,tm.year,\n\t\t\ttm.hour, tm.minute, tm.second, tm.milliseconds,tm.dayofweek)\nend\n\nexport func getsystime=\n\ttm:=new(ws_systemtime)\n\tgetsystemtime(&tm)\n\n\tif tm.dayofweek=0 then\n\t\ttm.dayofweek:=7\n\tfi\n\n\treturn tm\nend\n"
};
static u8 *  qq_tables$stdtypenames[40] = {
    (byte*)"void",
    (byte*)"int",
    (byte*)"real",
    (byte*)"decimal",
    (byte*)"range",
    (byte*)"set",
    (byte*)"dict",
    (byte*)"vector",
    (byte*)"bits",
    (byte*)"string",
    (byte*)"list",
    (byte*)"array",
    (byte*)"record",
    (byte*)"struct",
    (byte*)"refvar",
    (byte*)"refbit",
    (byte*)"refpack",
    (byte*)"symbol",
    (byte*)"type",
    (byte*)"operator",
    (byte*)"retaddr",
    (byte*)"except",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"i64",
    (byte*)"u8",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"u64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"u1",
    (byte*)"u2",
    (byte*)"u4",
    (byte*)"packstrc",
    (byte*)"packstrz",
    (byte*)"stringz",
    (byte*)"refproc",
    (byte*)"slice"
};
static byte qq_tables$stdtypewidths[40] = {
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)128u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)32u,
    (u8)64u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)0u
};
static u8 *  qq_tables$jtagnames[197] = {
    (byte*)"jnone",
    (byte*)"jlabeldef",
    (byte*)"jassign",
    (byte*)"jdeepcopy",
    (byte*)"jkeyword",
    (byte*)"jkeyvalue",
    (byte*)"joperator",
    (byte*)"jblock",
    (byte*)"jif",
    (byte*)"jselect",
    (byte*)"jwhenthen",
    (byte*)"jcase",
    (byte*)"jdocase",
    (byte*)"jswitch",
    (byte*)"jdoswitch",
    (byte*)"jrecase",
    (byte*)"jforup",
    (byte*)"jforupx",
    (byte*)"jfordown",
    (byte*)"jfordownx",
    (byte*)"jforall",
    (byte*)"jforallrev",
    (byte*)"jforeach",
    (byte*)"jdo",
    (byte*)"jto",
    (byte*)"jwhile",
    (byte*)"jrepeat",
    (byte*)"jtry",
    (byte*)"jexcept",
    (byte*)"jraise",
    (byte*)"jcall",
    (byte*)"jcallhost",
    (byte*)"jnil",
    (byte*)"jswap",
    (byte*)"jgoto",
    (byte*)"jstop",
    (byte*)"jreturn",
    (byte*)"jtypeconst",
    (byte*)"jeval",
    (byte*)"jconvert",
    (byte*)"jtypepun",
    (byte*)"jmap",
    (byte*)"jcmpchain",
    (byte*)"jname",
    (byte*)"jsymbol",
    (byte*)"jintconst",
    (byte*)"jrealconst",
    (byte*)"jstringconst",
    (byte*)"jstrinclude",
    (byte*)"jdot",
    (byte*)"jindex",
    (byte*)"jdotindex",
    (byte*)"jkeyindex",
    (byte*)"jredo",
    (byte*)"jnext",
    (byte*)"jexit",
    (byte*)"jptr",
    (byte*)"jaddrof",
    (byte*)"jptrto",
    (byte*)"jnull",
    (byte*)"jprint",
    (byte*)"jprintln",
    (byte*)"jfprint",
    (byte*)"jfprintln",
    (byte*)"jsprint",
    (byte*)"jsfprint",
    (byte*)"jnogap",
    (byte*)"jspace",
    (byte*)"jfmtitem",
    (byte*)"jread",
    (byte*)"jreadln",
    (byte*)"jdecimal",
    (byte*)"jincr",
    (byte*)"jdecr",
    (byte*)"jincrload",
    (byte*)"jdecrload",
    (byte*)"jloadincr",
    (byte*)"jloaddecr",
    (byte*)"jneg",
    (byte*)"jabs",
    (byte*)"jnotl",
    (byte*)"jinot",
    (byte*)"jistruel",
    (byte*)"jasc",
    (byte*)"jchr",
    (byte*)"jsqrt",
    (byte*)"jsqr",
    (byte*)"jsin",
    (byte*)"jcos",
    (byte*)"jtan",
    (byte*)"jasin",
    (byte*)"jacos",
    (byte*)"jatan",
    (byte*)"jlog",
    (byte*)"jlog10",
    (byte*)"jexp",
    (byte*)"jround",
    (byte*)"jfloor",
    (byte*)"jceil",
    (byte*)"jfract",
    (byte*)"jfmod",
    (byte*)"jsign",
    (byte*)"jnegto",
    (byte*)"jabsto",
    (byte*)"jnotlto",
    (byte*)"jinotto",
    (byte*)"jlen",
    (byte*)"jlwb",
    (byte*)"jupb",
    (byte*)"jbounds",
    (byte*)"jboundsx",
    (byte*)"jbitwidth",
    (byte*)"jbytesize",
    (byte*)"jtype",
    (byte*)"jelemtype",
    (byte*)"jbasetype",
    (byte*)"jusertype",
    (byte*)"jdictitems",
    (byte*)"jisfound",
    (byte*)"jminvalue",
    (byte*)"jmaxvalue",
    (byte*)"jisint",
    (byte*)"jisreal",
    (byte*)"jisstring",
    (byte*)"jisrange",
    (byte*)"jisnumber",
    (byte*)"jislist",
    (byte*)"jisrecord",
    (byte*)"jispointer",
    (byte*)"jisarray",
    (byte*)"jismutable",
    (byte*)"jisset",
    (byte*)"jisvoid",
    (byte*)"jisdef",
    (byte*)"jisequal",
    (byte*)"jodd",
    (byte*)"jeven",
    (byte*)"jadd",
    (byte*)"jsub",
    (byte*)"jmul",
    (byte*)"jdiv",
    (byte*)"jidiv",
    (byte*)"jirem",
    (byte*)"jidivrem",
    (byte*)"jiand",
    (byte*)"jior",
    (byte*)"jixor",
    (byte*)"jshl",
    (byte*)"jshr",
    (byte*)"jin",
    (byte*)"jnotin",
    (byte*)"jinx",
    (byte*)"jinrev",
    (byte*)"jandl",
    (byte*)"jorl",
    (byte*)"jeq",
    (byte*)"jne",
    (byte*)"jlt",
    (byte*)"jle",
    (byte*)"jge",
    (byte*)"jgt",
    (byte*)"jmin",
    (byte*)"jmax",
    (byte*)"jconcat",
    (byte*)"jappend",
    (byte*)"jpower",
    (byte*)"jatan2",
    (byte*)"jaddto",
    (byte*)"jsubto",
    (byte*)"jmulto",
    (byte*)"jdivto",
    (byte*)"jidivto",
    (byte*)"jandlto",
    (byte*)"jorlto",
    (byte*)"jiandto",
    (byte*)"jiorto",
    (byte*)"jixorto",
    (byte*)"jshlto",
    (byte*)"jshrto",
    (byte*)"jminto",
    (byte*)"jmaxto",
    (byte*)"jconcatto",
    (byte*)"jappendto",
    (byte*)"jmakerange",
    (byte*)"jmakerangelen",
    (byte*)"jmakelist",
    (byte*)"jmakeset",
    (byte*)"jmakedict",
    (byte*)"jcvlineno",
    (byte*)"jcvstrlineno",
    (byte*)"jcvmodulename",
    (byte*)"jcvfilename",
    (byte*)"jcvfunction",
    (byte*)"jcvdate",
    (byte*)"jcvtime",
    (byte*)"jcvversion",
    (byte*)"jcvpclversion"
};
static u32 qq_tables$jshortnames[197] = {
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(u64)11051u,
    (u32)(u64)11565u,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)'-',
    (u32)(u64)7561825u,
    (u32)(u64)7630702u,
    (u32)(u64)1953459817u,
    (u32)(u64)5534569u,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)'+',
    (u32)'-',
    (u32)'*',
    (u32)'/',
    (u32)'%',
    (u32)(u64)7169394u,
    (u32)(i64)0,
    (u32)(u64)1684955497u,
    (u32)(u64)7499625u,
    (u32)(u64)1919907945u,
    (u32)(u64)15420u,
    (u32)(u64)15934u,
    (u32)(u64)28265u,
    (u32)(u64)7235966u,
    (u32)(u64)7892585u,
    (u32)(i64)0,
    (u32)(u64)6581857u,
    (u32)(u64)29295u,
    (u32)'=',
    (u32)(u64)15932u,
    (u32)'<',
    (u32)(u64)15676u,
    (u32)(u64)15678u,
    (u32)'>',
    (u32)(u64)7235949u,
    (u32)(u64)7889261u,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(u64)10794u,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0,
    (u32)(i64)0
};
static byte qq_tables$jflags[197] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static i16 qq_tables$jpclcodes[197] = {
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)214,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)87,
    (i16)92,
    (i16)86,
    (i16)91,
    (i16)95,
    (i16)96,
    (i16)97,
    (i16)98,
    (i16)99,
    (i16)100,
    (i16)101,
    (i16)102,
    (i16)103,
    (i16)104,
    (i16)105,
    (i16)106,
    (i16)107,
    (i16)108,
    (i16)109,
    (i16)111,
    (i16)112,
    (i16)113,
    (i16)114,
    (i16)115,
    (i16)116,
    (i16)117,
    (i16)118,
    (i16)110,
    (i16)119,
    (i16)120,
    (i16)122,
    (i16)121,
    (i16)123,
    (i16)124,
    (i16)125,
    (i16)126,
    (i16)127,
    (i16)128,
    (i16)129,
    (i16)130,
    (i16)131,
    (i16)132,
    (i16)133,
    (i16)134,
    (i16)135,
    (i16)136,
    (i16)137,
    (i16)138,
    (i16)139,
    (i16)140,
    (i16)141,
    (i16)142,
    (i16)143,
    (i16)144,
    (i16)145,
    (i16)146,
    (i16)147,
    (i16)148,
    (i16)149,
    (i16)150,
    (i16)151,
    (i16)154,
    (i16)155,
    (i16)156,
    (i16)157,
    (i16)158,
    (i16)159,
    (i16)160,
    (i16)161,
    (i16)162,
    (i16)163,
    (i16)164,
    (i16)165,
    (i16)166,
    (i16)167,
    (i16)168,
    (i16)169,
    (i16)170,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)171,
    (i16)172,
    (i16)173,
    (i16)174,
    (i16)175,
    (i16)176,
    (i16)177,
    (i16)178,
    (i16)179,
    (i16)180,
    (i16)181,
    (i16)182,
    (i16)183,
    (i16)184,
    (i16)185,
    (i16)186,
    (i16)187,
    (i16)188,
    (i16)189,
    (i16)190,
    (i16)191,
    (i16)192,
    (i16)193,
    (i16)194,
    (i16)195,
    (i16)196,
    (i16)197,
    (i16)198,
    (i16)79,
    (i16)80,
    (i16)73,
    (i16)78,
    (i16)81,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0
};
static byte qq_tables$jtocodes[197] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)102u,
    (u8)103u,
    (u8)104u,
    (u8)105u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)167u,
    (u8)168u,
    (u8)169u,
    (u8)170u,
    (u8)171u,
    (u8)0u,
    (u8)0u,
    (u8)174u,
    (u8)175u,
    (u8)176u,
    (u8)177u,
    (u8)178u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)172u,
    (u8)173u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)179u,
    (u8)180u,
    (u8)181u,
    (u8)182u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte qq_tables$jhasvalue[197] = {
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)2u,
    (u8)0u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u
};
static u8 *  qq_tables$opndnames[17] = {
    (byte*)"cnone",
    (byte*)"cmemory",
    (byte*)"cframe",
    (byte*)"cproc",
    (byte*)"cdllproc",
    (byte*)"cgenfield",
    (byte*)"clabel",
    (byte*)"cint",
    (byte*)"cword",
    (byte*)"creal",
    (byte*)"crange",
    (byte*)"cstring",
    (byte*)"cstringz",
    (byte*)"ctype",
    (byte*)"csymbol",
    (byte*)"coperator",
    (byte*)"?"
};
static u8 *  qq_tables$pclnames[263] = {
    (byte*)"kzero",
    (byte*)"knop",
    (byte*)"kskip",
    (byte*)"kprocdef",
    (byte*)"kprocentry",
    (byte*)"kprocend",
    (byte*)"kendmodule",
    (byte*)"kcomment",
    (byte*)"",
    (byte*)"kpushm",
    (byte*)"kpushf",
    (byte*)"kpushmref",
    (byte*)"kpushfref",
    (byte*)"kpopm",
    (byte*)"kpopf",
    (byte*)"kstorem",
    (byte*)"kstoref",
    (byte*)"kpushx",
    (byte*)"kpopx",
    (byte*)"kpushci",
    (byte*)"kpushvoid",
    (byte*)"kpushnil",
    (byte*)"kpushcr",
    (byte*)"kpushcn",
    (byte*)"kpushcs",
    (byte*)"kpusht",
    (byte*)"kpushsymbol",
    (byte*)"kpushoperator",
    (byte*)"kpushptr",
    (byte*)"kpopptr",
    (byte*)"kzpopm",
    (byte*)"kzpopf",
    (byte*)"kdupl",
    (byte*)"kcopy",
    (byte*)"kswap",
    (byte*)"kconvrefpack",
    (byte*)"kjump",
    (byte*)"kjumpptr",
    (byte*)"kjumptrue",
    (byte*)"kjumpfalse",
    (byte*)"kjumpeq",
    (byte*)"kjumpne",
    (byte*)"kjumplt",
    (byte*)"kjumple",
    (byte*)"kjumpge",
    (byte*)"kjumpgt",
    (byte*)"kjumptesteq",
    (byte*)"kjumptestne",
    (byte*)"kjumplabel",
    (byte*)"kswitch",
    (byte*)"ktom",
    (byte*)"ktof",
    (byte*)"kformci",
    (byte*)"kforfci",
    (byte*)"kformm",
    (byte*)"kforff",
    (byte*)"kfordmci",
    (byte*)"kfordfci",
    (byte*)"kfordmm",
    (byte*)"kfordff",
    (byte*)"kcallproc",
    (byte*)"kcallptr",
    (byte*)"kreturn0",
    (byte*)"kreturn",
    (byte*)"kpopretval",
    (byte*)"kmodulecall",
    (byte*)"kmodulereturn",
    (byte*)"kcalldll",
    (byte*)"kcallhost",
    (byte*)"kunshare",
    (byte*)"kaddsp",
    (byte*)"kstop",
    (byte*)"kstoprunproc",
    (byte*)"kmakelist",
    (byte*)"kmakerecord",
    (byte*)"kmakearray",
    (byte*)"kmakebits",
    (byte*)"kmakestruct",
    (byte*)"kmakeset",
    (byte*)"kmakerange",
    (byte*)"kmakerangelen",
    (byte*)"kmakedict",
    (byte*)"kmakedecimal",
    (byte*)"kincrptr",
    (byte*)"kincrtom",
    (byte*)"kincrtof",
    (byte*)"kloadincr",
    (byte*)"kincrload",
    (byte*)"kdecrptr",
    (byte*)"kdecrtom",
    (byte*)"kdecrtof",
    (byte*)"kloaddecr",
    (byte*)"kdecrload",
    (byte*)"kincr",
    (byte*)"kdecr",
    (byte*)"kneg",
    (byte*)"kabs",
    (byte*)"knotl",
    (byte*)"kinot",
    (byte*)"kistruel",
    (byte*)"kasc",
    (byte*)"kchr",
    (byte*)"ksqrt",
    (byte*)"ksqr",
    (byte*)"ksin",
    (byte*)"kcos",
    (byte*)"ktan",
    (byte*)"kasin",
    (byte*)"kacos",
    (byte*)"katan",
    (byte*)"ksign",
    (byte*)"klog",
    (byte*)"klog10",
    (byte*)"kexp",
    (byte*)"kround",
    (byte*)"kfloor",
    (byte*)"kceil",
    (byte*)"kfract",
    (byte*)"kfmod",
    (byte*)"knegto",
    (byte*)"kabsto",
    (byte*)"kinotto",
    (byte*)"knotlto",
    (byte*)"klen",
    (byte*)"klwb",
    (byte*)"kupb",
    (byte*)"kbounds",
    (byte*)"kboundsx",
    (byte*)"kbitwidth",
    (byte*)"kbytesize",
    (byte*)"ktype",
    (byte*)"kelemtype",
    (byte*)"kbasetype",
    (byte*)"kusertype",
    (byte*)"kdictitems",
    (byte*)"kisfound",
    (byte*)"kminvalue",
    (byte*)"kmaxvalue",
    (byte*)"kisint",
    (byte*)"kisreal",
    (byte*)"kisstring",
    (byte*)"kisrange",
    (byte*)"kisnumber",
    (byte*)"kislist",
    (byte*)"kisrecord",
    (byte*)"kispointer",
    (byte*)"kisarray",
    (byte*)"kismutable",
    (byte*)"kisset",
    (byte*)"kisvoid",
    (byte*)"kisdef",
    (byte*)"kisequal",
    (byte*)"kconvert",
    (byte*)"ktypepun",
    (byte*)"kodd",
    (byte*)"keven",
    (byte*)"kadd",
    (byte*)"ksub",
    (byte*)"kmul",
    (byte*)"kdiv",
    (byte*)"kidiv",
    (byte*)"kirem",
    (byte*)"kidivrem",
    (byte*)"kiand",
    (byte*)"kior",
    (byte*)"kixor",
    (byte*)"kshl",
    (byte*)"kshr",
    (byte*)"kin",
    (byte*)"knotin",
    (byte*)"kinx",
    (byte*)"keq",
    (byte*)"kne",
    (byte*)"klt",
    (byte*)"kle",
    (byte*)"kge",
    (byte*)"kgt",
    (byte*)"kmin",
    (byte*)"kmax",
    (byte*)"kconcat",
    (byte*)"kappend",
    (byte*)"kpower",
    (byte*)"katan2",
    (byte*)"kaddto",
    (byte*)"ksubto",
    (byte*)"kmulto",
    (byte*)"kdivto",
    (byte*)"kidivto",
    (byte*)"kandlto",
    (byte*)"korlto",
    (byte*)"kiandto",
    (byte*)"kiorto",
    (byte*)"kixorto",
    (byte*)"kshlto",
    (byte*)"kshrto",
    (byte*)"kminto",
    (byte*)"kmaxto",
    (byte*)"kconcatto",
    (byte*)"kappendto",
    (byte*)"kdot",
    (byte*)"kindex",
    (byte*)"kdotindex",
    (byte*)"kkeyindex",
    (byte*)"kdotref",
    (byte*)"kindexref",
    (byte*)"kdotindexref",
    (byte*)"kkeyindexref",
    (byte*)"kpopdot",
    (byte*)"kpopindex",
    (byte*)"kpopdotindex",
    (byte*)"kpopkeyindex",
    (byte*)"kexpand",
    (byte*)"kpushtry",
    (byte*)"kraise",
    (byte*)"kmaps",
    (byte*)"kmapss",
    (byte*)"kpushff",
    (byte*)"kpushmm",
    (byte*)"kpushfm",
    (byte*)"kpushmf",
    (byte*)"kmoveff",
    (byte*)"kzmoveff",
    (byte*)"kmovefm",
    (byte*)"kmovemf",
    (byte*)"kmovemm",
    (byte*)"kmovefci",
    (byte*)"kzmovefci",
    (byte*)"kmovemci",
    (byte*)"kpushfff",
    (byte*)"knop2",
    (byte*)"kpushci0",
    (byte*)"kpushvoid2",
    (byte*)"kpushvoid3",
    (byte*)"kunshare1",
    (byte*)"kunshare2",
    (byte*)"kunshare3",
    (byte*)"kprocentry1",
    (byte*)"kprocentry2",
    (byte*)"kjumpeqfci",
    (byte*)"kjumpnefci",
    (byte*)"kjumpltfci",
    (byte*)"kjumplefci",
    (byte*)"kjumpgefci",
    (byte*)"kjumpgtfci",
    (byte*)"kjumpeqff",
    (byte*)"kjumpneff",
    (byte*)"kjumpltff",
    (byte*)"kjumpleff",
    (byte*)"kjumpgeff",
    (byte*)"kjumpgtff",
    (byte*)"kaddfci",
    (byte*)"ksubfci",
    (byte*)"kaddff",
    (byte*)"ksubff",
    (byte*)"kindexff",
    (byte*)"kpushincrptrm",
    (byte*)"kpushincrptrf",
    (byte*)"kpopincrptrm",
    (byte*)"kpopincrptrf",
    (byte*)"kswitchf",
    (byte*)"klenf",
    (byte*)"kpushptrf",
    (byte*)"klastpcl"
};
static byte qq_tables$pclfmt[263][4] = {
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)12u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)9u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)10u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)11u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)13u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)15u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)1u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)1u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)3u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)4u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)13u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)13u,(u8)13u},
    {(u8)7u,(u8)7u,(u8)13u,(u8)13u},
    {(u8)7u,(u8)13u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)13u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)13u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)5u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)5u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)5u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)7u,(u8)7u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)7u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u}
};
static void (*qq_tables$pclhandlers[263])(void) = {
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$k_nop,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$k_procentry,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$k_comment,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$k_pushm,
    (void (*)(void))qq_khandlers$k_pushf,
    (void (*)(void))qq_khandlers$k_pushmref,
    (void (*)(void))qq_khandlers$k_pushfref,
    (void (*)(void))qq_khandlers$k_popm,
    (void (*)(void))qq_khandlers$k_popf,
    (void (*)(void))qq_khandlers$k_storem,
    (void (*)(void))qq_khandlers$k_storef,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$k_pushci,
    (void (*)(void))qq_khandlers$k_pushvoid,
    (void (*)(void))qq_khandlers$k_pushnil,
    (void (*)(void))qq_khandlers$k_pushcr,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$k_pushcs,
    (void (*)(void))qq_khandlers$k_pusht,
    (void (*)(void))qq_khandlers$k_pushsymbol,
    (void (*)(void))qq_khandlers$k_pushoperator,
    (void (*)(void))qq_khandlers$k_pushptr,
    (void (*)(void))qq_khandlers$k_popptr,
    (void (*)(void))qq_khandlers$k_zpopm,
    (void (*)(void))qq_khandlers$k_zpopf,
    (void (*)(void))qq_khandlers$k_dupl,
    (void (*)(void))qq_khandlers$k_copy,
    (void (*)(void))qq_khandlers$k_swap,
    (void (*)(void))qq_khandlers$k_convrefpack,
    (void (*)(void))qq_khandlers$k_jump,
    (void (*)(void))qq_khandlers$k_jumpptr,
    (void (*)(void))qq_khandlers$k_jumptrue,
    (void (*)(void))qq_khandlers$k_jumpfalse,
    (void (*)(void))qq_khandlers$k_jumpeq,
    (void (*)(void))qq_khandlers$k_jumpne,
    (void (*)(void))qq_khandlers$k_jumplt,
    (void (*)(void))qq_khandlers$k_jumple,
    (void (*)(void))qq_khandlers$k_jumpge,
    (void (*)(void))qq_khandlers$k_jumpgt,
    (void (*)(void))qq_khandlers$k_jumptesteq,
    (void (*)(void))qq_khandlers$k_jumptestne,
    (void (*)(void))qq_khandlers$kunimpl,
    (void (*)(void))qq_khandlers$k_switch,
    (void (*)(void))qq_khandlers$k_tom,
    (void (*)(void))qq_khandlers$k_tof,
    (void (*)(void))qq_khandlers$k_formci,
    (void (*)(void))qq_khandlers$k_forfci,
    (void (*)(void))qq_khandlers$k_formm,
    (void (*)(void))qq_khandlers$k_forff,
    (void (*)(void))qq_khandlers$k_fordmci,
    (void (*)(void))qq_khandlers$k_fordfci,
    (void (*)(void))qq_khandlers$k_fordmm,
    (void (*)(void))qq_khandlers$k_fordff,
    (void (*)(void))qq_khandlers$k_callproc,
    (void (*)(void))qq_khandlers$k_callptr,
    (void (*)(void))qq_khandlers$k_return0,
    (void (*)(void))qq_khandlers$k_return,
    (void (*)(void))qq_khandlers$k_popretval,
    (void (*)(void))qq_khandlers$k_modulecall,
    (void (*)(void))qq_khandlers$k_modulereturn,
    (void (*)(void))qq_khandlers$k_calldll,
    (void (*)(void))qq_khandlers$k_callhost,
    (void (*)(void))qq_khandlers$k_unshare,
    (void (*)(void))qq_khandlers$k_addsp,
    (void (*)(void))qq_khandlers$k_stop,
    (void (*)(void))qq_khandlers$k_stoprunproc,
    (void (*)(void))qq_khandlers$k_makelist,
    (void (*)(void))qq_khandlers$k_makerecord,
    (void (*)(void))qq_khandlers$k_makearray,
    (void (*)(void))qq_khandlers$k_makebits,
    (void (*)(void))qq_khandlers$k_makestruct,
    (void (*)(void))qq_khandlers$k_makeset,
    (void (*)(void))qq_khandlers$k_makerange,
    (void (*)(void))qq_khandlers$k_makerangelen,
    (void (*)(void))qq_khandlers$k_makedict,
    (void (*)(void))qq_khandlers$k_makedecimal,
    (void (*)(void))qq_khandlers$k_incrptr,
    (void (*)(void))qq_khandlers$k_incrtom,
    (void (*)(void))qq_khandlers$k_incrtof,
    (void (*)(void))qq_khandlers$k_loadincr,
    (void (*)(void))qq_khandlers$k_incrload,
    (void (*)(void))qq_khandlers$k_decrptr,
    (void (*)(void))qq_khandlers$k_decrtom,
    (void (*)(void))qq_khandlers$k_decrtof,
    (void (*)(void))qq_khandlers$k_loaddecr,
    (void (*)(void))qq_khandlers$k_decrload,
    (void (*)(void))qq_khandlers$k_incr,
    (void (*)(void))qq_khandlers$k_decr,
    (void (*)(void))qq_khandlers$k_neg,
    (void (*)(void))qq_khandlers$k_abs,
    (void (*)(void))qq_khandlers$k_notl,
    (void (*)(void))qq_khandlers$k_inot,
    (void (*)(void))qq_khandlers$k_istruel,
    (void (*)(void))qq_khandlers$k_asc,
    (void (*)(void))qq_khandlers$k_chr,
    (void (*)(void))qq_khandlers$k_sqrt,
    (void (*)(void))qq_khandlers$k_sqr,
    (void (*)(void))qq_khandlers$k_sin,
    (void (*)(void))qq_khandlers$k_cos,
    (void (*)(void))qq_khandlers$k_tan,
    (void (*)(void))qq_khandlers$k_asin,
    (void (*)(void))qq_khandlers$k_acos,
    (void (*)(void))qq_khandlers$k_atan,
    (void (*)(void))qq_khandlers$k_sign,
    (void (*)(void))qq_khandlers$k_log,
    (void (*)(void))qq_khandlers$k_log10,
    (void (*)(void))qq_khandlers$k_exp,
    (void (*)(void))qq_khandlers$k_round,
    (void (*)(void))qq_khandlers$k_floor,
    (void (*)(void))qq_khandlers$k_ceil,
    (void (*)(void))qq_khandlers$k_fract,
    (void (*)(void))qq_khandlers$k_fmod,
    (void (*)(void))qq_khandlers$k_negto,
    (void (*)(void))qq_khandlers$k_absto,
    (void (*)(void))qq_khandlers$k_inotto,
    (void (*)(void))qq_khandlers$k_notlto,
    (void (*)(void))qq_khandlers$k_len,
    (void (*)(void))qq_khandlers$k_lwb,
    (void (*)(void))qq_khandlers$k_upb,
    (void (*)(void))qq_khandlers$k_bounds,
    (void (*)(void))qq_khandlers$k_boundsx,
    (void (*)(void))qq_khandlers$k_bitwidth,
    (void (*)(void))qq_khandlers$k_bytesize,
    (void (*)(void))qq_khandlers$k_type,
    (void (*)(void))qq_khandlers$k_elemtype,
    (void (*)(void))qq_khandlers$k_basetype,
    (void (*)(void))qq_khandlers$k_usertype,
    (void (*)(void))qq_khandlers$k_dictitems,
    (void (*)(void))qq_khandlers$k_isfound,
    (void (*)(void))qq_khandlers$k_minvalue,
    (void (*)(void))qq_khandlers$k_maxvalue,
    (void (*)(void))qq_khandlers$k_isint,
    (void (*)(void))qq_khandlers$k_isreal,
    (void (*)(void))qq_khandlers$k_isstring,
    (void (*)(void))qq_khandlers$k_isrange,
    (void (*)(void))qq_khandlers$k_isnumber,
    (void (*)(void))qq_khandlers$k_islist,
    (void (*)(void))qq_khandlers$k_isrecord,
    (void (*)(void))qq_khandlers$k_ispointer,
    (void (*)(void))qq_khandlers$k_isarray,
    (void (*)(void))qq_khandlers$k_ismutable,
    (void (*)(void))qq_khandlers$k_isset,
    (void (*)(void))qq_khandlers$k_isvoid,
    (void (*)(void))qq_khandlers$k_isdef,
    (void (*)(void))qq_khandlers$k_isequal,
    (void (*)(void))qq_khandlers$k_convert,
    (void (*)(void))qq_khandlers$k_typepun,
    (void (*)(void))qq_khandlers$k_odd,
    (void (*)(void))qq_khandlers$k_even,
    (void (*)(void))qq_khandlers$k_add,
    (void (*)(void))qq_khandlers$k_sub,
    (void (*)(void))qq_khandlers$k_mul,
    (void (*)(void))qq_khandlers$k_div,
    (void (*)(void))qq_khandlers$k_idiv,
    (void (*)(void))qq_khandlers$k_irem,
    (void (*)(void))qq_khandlers$k_idivrem,
    (void (*)(void))qq_khandlers$k_iand,
    (void (*)(void))qq_khandlers$k_ior,
    (void (*)(void))qq_khandlers$k_ixor,
    (void (*)(void))qq_khandlers$k_shl,
    (void (*)(void))qq_khandlers$k_shr,
    (void (*)(void))qq_khandlers$k_in,
    (void (*)(void))qq_khandlers$k_notin,
    (void (*)(void))qq_khandlers$k_inx,
    (void (*)(void))qq_khandlers$k_eq,
    (void (*)(void))qq_khandlers$k_ne,
    (void (*)(void))qq_khandlers$k_lt,
    (void (*)(void))qq_khandlers$k_le,
    (void (*)(void))qq_khandlers$k_ge,
    (void (*)(void))qq_khandlers$k_gt,
    (void (*)(void))qq_khandlers$k_min,
    (void (*)(void))qq_khandlers$k_max,
    (void (*)(void))qq_khandlers$k_concat,
    (void (*)(void))qq_khandlers$k_append,
    (void (*)(void))qq_khandlers$k_power,
    (void (*)(void))qq_khandlers$k_atan2,
    (void (*)(void))qq_khandlers$k_addto,
    (void (*)(void))qq_khandlers$k_subto,
    (void (*)(void))qq_khandlers$k_multo,
    (void (*)(void))qq_khandlers$k_divto,
    (void (*)(void))qq_khandlers$k_idivto,
    (void (*)(void))qq_khandlers$k_andlto,
    (void (*)(void))qq_khandlers$k_orlto,
    (void (*)(void))qq_khandlers$k_iandto,
    (void (*)(void))qq_khandlers$k_iorto,
    (void (*)(void))qq_khandlers$k_ixorto,
    (void (*)(void))qq_khandlers$k_shlto,
    (void (*)(void))qq_khandlers$k_shrto,
    (void (*)(void))qq_khandlers$k_minto,
    (void (*)(void))qq_khandlers$k_maxto,
    (void (*)(void))qq_khandlers$k_concatto,
    (void (*)(void))qq_khandlers$k_appendto,
    (void (*)(void))qq_khandlers$k_dot,
    (void (*)(void))qq_khandlers$k_index,
    (void (*)(void))qq_khandlers$k_dotindex,
    (void (*)(void))qq_khandlers$k_keyindex,
    (void (*)(void))qq_khandlers$k_dotref,
    (void (*)(void))qq_khandlers$k_indexref,
    (void (*)(void))qq_khandlers$k_dotindexref,
    (void (*)(void))qq_khandlers$k_keyindexref,
    (void (*)(void))qq_khandlers$k_popdot,
    (void (*)(void))qq_khandlers$k_popindex,
    (void (*)(void))qq_khandlers$k_popdotindex,
    (void (*)(void))qq_khandlers$k_popkeyindex,
    (void (*)(void))qq_khandlers$k_expand,
    (void (*)(void))qq_khandlers$k_pushtry,
    (void (*)(void))qq_khandlers$k_raise,
    (void (*)(void))qq_khandlers$k_maps,
    (void (*)(void))qq_khandlers$k_mapss,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
static void *  qq_tables$cmdmap[263];
static u64 qq_tables$symbolnames[152] = {
    (u64)491496043109u,
    (u64)7630692u,
    (u64)128021775803756u,
    (u64)418447716195u,
    (u64)1768777075u,
    (u64)474315779939u,
    (u64)121424839664484u,
    (u64)121390429860705u,
    (u64)8750616548859012452u,
    (u64)122545691846003u,
    (u64)1701865840u,
    (u64)118074580820588u,
    (u64)118074580820594u,
    (u64)7435116u,
    (u64)7435122u,
    (u64)133506683724652u,
    (u64)133506683724658u,
    (u64)7500912u,
    (u64)7496034u,
    (u64)29793u,
    (u64)7957695015460107633u,
    (u64)1919181921u,
    (u64)491310571876u,
    (u64)435526984050u,
    (u64)8316305113558576229u,
    (u64)1752392040u,
    (u64)6579297u,
    (u64)6452595u,
    (u64)7107949u,
    (u64)7760228u,
    (u64)1986618473u,
    (u64)1835364969u,
    (u64)30792314748757097u,
    (u64)1818521185u,
    (u64)7107183u,
    (u64)1684955497u,
    (u64)7499625u,
    (u64)1919907945u,
    (u64)7104627u,
    (u64)7497843u,
    (u64)7235949u,
    (u64)7889261u,
    (u64)110425311047777u,
    (u64)127961628831587u,
    (u64)28265u,
    (u64)474215640942u,
    (u64)7892585u,
    (u64)508508139113u,
    (u64)491328597872u,
    (u64)29029u,
    (u64)25966u,
    (u64)29804u,
    (u64)25964u,
    (u64)25959u,
    (u64)29799u,
    (u64)30506454526292841u,
    (u64)1819570030u,
    (u64)1953459817u,
    (u64)30510852590564201u,
    (u64)7561825u,
    (u64)7500147u,
    (u64)1852270963u,
    (u64)6517601u,
    (u64)7497827u,
    (u64)495673696621u,
    (u64)55471255085421u,
    (u64)1886351984u,
    (u64)1919118953u,
    (u64)1919116644u,
    (u64)7106405u,
    (u64)6713189u,
    (u64)28549237880349042u,
    (u64)8391171955410366057u,
    (u64)8391171955409249636u,
    (u64)32778015450820710u,
    (u64)8391171955410233443u,
    (u64)8391171955410236531u,
    (u64)7308604897319546485u,
    (u64)1701667182u,
    (u64)28552639593870451u,
    (u64)491260502889u,
    (u64)26217u,
    (u64)1852139636u,
    (u64)439855836261u,
    (u64)1702063205u,
    (u64)7310293699684166757u,
    (u64)131337507007589u,
    (u64)30510843782458469u,
    (u64)6581861u,
    (u64)126939460038261u,
    (u64)1702060387u,
    (u64)111546229550948u,
    (u64)111546229548402u,
    (u64)1852139639u,
    (u64)7499622u,
    (u64)28532u,
    (u64)31074u,
    (u64)28516u,
    (u64)435610544247u,
    (u64)127961662514546u,
    (u64)465625706101u,
    (u64)121437875889522u,
    (u64)1886352499u,
    (u64)1886351212u,
    (u64)1869901671u,
    (u64)114776364119923u,
    (u64)7521983798963302244u,
    (u64)500068610672u,
    (u64)128017564332147u,
    (u64)1684104562u,
    (u64)431130767987u,
    (u64)31081425824739955u,
    (u64)1668248176u,
    (u64)1668183398u,
    (u64)465557414252u,
    (u64)110442657834354u,
    (u64)127970521019507u,
    (u64)474315583093u,
    (u64)111516500389741u,
    (u64)128034844732777u,
    (u64)28275532515798377u,
    (u64)1701869940u,
    (u64)6710642u,
    (u64)7496054u,
    (u64)435459550323u,
    (u64)478660485485u,
    (u64)28783u,
    (u64)500152823651u,
    (u64)113723778557542u,
    (u64)119165519096935u,
    (u64)109304575259763u,
    (u64)121390429397347u,
    (u64)7959156u,
    (u64)128026086176869u,
    (u64)435727982962u,
    (u64)110425311311973u,
    (u64)461229747298u,
    (u64)1953718627u,
    (u64)32195308665270115u,
    (u64)125762756439908u,
    (u64)1818326629u,
    (u64)27431034385752436u,
    (u64)7364973u,
    (u64)482871438435u,
    (u64)1885435763u,
    (u64)8391171955410303347u,
    (u64)121386319441768u,
    (u64)1953722216u,
    (u64)7104878u,
    (u64)30508623351411827u,
    (u64)123623711273075u,
    (u64)521526932836u
};
static u8 *  qq_tables$namenames[27] = {
    (byte*)"genericid",
    (byte*)"programid",
    (byte*)"subprogid",
    (byte*)"moduleid",
    (byte*)"dllmoduleid",
    (byte*)"procid",
    (byte*)"anonprocid",
    (byte*)"dllprocid",
    (byte*)"dllvarid",
    (byte*)"recordid",
    (byte*)"typeid",
    (byte*)"fieldid",
    (byte*)"structfieldid",
    (byte*)"staticid",
    (byte*)"frameid",
    (byte*)"paramid",
    (byte*)"dllparamid",
    (byte*)"labelid",
    (byte*)"constid",
    (byte*)"enumid",
    (byte*)"aliasid",
    (byte*)"linkid",
    (byte*)"macroid",
    (byte*)"macroparamid",
    (byte*)"structblockid",
    (byte*)"unionblockid",
    (byte*)"endblockid"
};
static u8 *  qq_tables$objtypenames[3] = {(byte*)"normal_obj",(byte*)"slice_obj",(byte*)"extslice_obj"};
static u8 *  qq_tables$scopenames[3] = {(byte*)"local_scope",(byte*)"global_scope",(byte*)"export_scope"};
static u8 *  qq_tables$stnames[212] = {
    (byte*)"if",
    (byte*)"then",
    (byte*)"elsif",
    (byte*)"else",
    (byte*)"elsecase",
    (byte*)"elseswitch",
    (byte*)"case",
    (byte*)"docase",
    (byte*)"recase",
    (byte*)"when",
    (byte*)"for",
    (byte*)"foreach",
    (byte*)"to",
    (byte*)"downto",
    (byte*)"by",
    (byte*)"do",
    (byte*)"end",
    (byte*)"while",
    (byte*)"repeat",
    (byte*)"until",
    (byte*)"always",
    (byte*)"return",
    (byte*)"stop",
    (byte*)"redoloop",
    (byte*)"nextloop",
    (byte*)"exit",
    (byte*)"exitloop",
    (byte*)"goto",
    (byte*)"switch",
    (byte*)"doswitch",
    (byte*)"tabledata",
    (byte*)"enumdata",
    (byte*)"clamp",
    (byte*)"maps",
    (byte*)"mapss",
    (byte*)"eval",
    (byte*)"print",
    (byte*)"println",
    (byte*)"fprint",
    (byte*)"fprintln",
    (byte*)"sprint",
    (byte*)"sfprint",
    (byte*)"cp",
    (byte*)"cpl",
    (byte*)"read",
    (byte*)"readln",
    (byte*)"cast",
    (byte*)"proc",
    (byte*)"sub",
    (byte*)"function",
    (byte*)"func",
    (byte*)"fun",
    (byte*)"method",
    (byte*)"type",
    (byte*)"record",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"ref",
    (byte*)"var",
    (byte*)"slice",
    (byte*)"macro",
    (byte*)"static",
    (byte*)"$caligned",
    (byte*)"const",
    (byte*)"module",
    (byte*)"import",
    (byte*)"importdll",
    (byte*)"strinclude",
    (byte*)"unless",
    (byte*)"try",
    (byte*)"except",
    (byte*)"raise",
    (byte*)"global",
    (byte*)"export",
    (byte*)"clang",
    (byte*)"windows",
    (byte*)"swap",
    (byte*)"void",
    (byte*)"int",
    (byte*)"real",
    (byte*)"string",
    (byte*)"list",
    (byte*)"array",
    (byte*)"vector",
    (byte*)"bits",
    (byte*)"set",
    (byte*)"dict",
    (byte*)"decimal",
    (byte*)"longint",
    (byte*)"typetype",
    (byte*)"range",
    (byte*)"recordtype",
    (byte*)"cvoid",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"i64",
    (byte*)"bit",
    (byte*)"u1",
    (byte*)"u2",
    (byte*)"u4",
    (byte*)"byte",
    (byte*)"u8",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"u64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"int8",
    (byte*)"int16",
    (byte*)"int32",
    (byte*)"int64",
    (byte*)"word8",
    (byte*)"word16",
    (byte*)"word32",
    (byte*)"word64",
    (byte*)"real32",
    (byte*)"real64",
    (byte*)"stringc",
    (byte*)"stringz",
    (byte*)"cstring",
    (byte*)"ichar",
    (byte*)"million",
    (byte*)"billion",
    (byte*)"as",
    (byte*)"$lineno",
    (byte*)"$strlineno",
    (byte*)"$filename",
    (byte*)"$modulename",
    (byte*)"$function",
    (byte*)"$date",
    (byte*)"$time",
    (byte*)"$",
    (byte*)"and",
    (byte*)"or",
    (byte*)"iand",
    (byte*)"ior",
    (byte*)"ixor",
    (byte*)"in",
    (byte*)"notin",
    (byte*)"inx",
    (byte*)"inrev",
    (byte*)"rem",
    (byte*)"divrem",
    (byte*)"min",
    (byte*)"max",
    (byte*)"not",
    (byte*)"inot",
    (byte*)"istrue",
    (byte*)"abs",
    (byte*)"asc",
    (byte*)"chr",
    (byte*)"sqrt",
    (byte*)"sqr",
    (byte*)"cos",
    (byte*)"sin",
    (byte*)"tan",
    (byte*)"asin",
    (byte*)"acos",
    (byte*)"atan",
    (byte*)"atan2",
    (byte*)"sign",
    (byte*)"log",
    (byte*)"log10",
    (byte*)"exp",
    (byte*)"round",
    (byte*)"floor",
    (byte*)"ceil",
    (byte*)"fract",
    (byte*)"fmod",
    (byte*)"append",
    (byte*)"concat",
    (byte*)"len",
    (byte*)"lwb",
    (byte*)"upb",
    (byte*)"bounds",
    (byte*)"bitwidth",
    (byte*)"bytes",
    (byte*)"minvalue",
    (byte*)"maxvalue",
    (byte*)"basetype",
    (byte*)"usertype",
    (byte*)"elemtype",
    (byte*)"dictitems",
    (byte*)"isfound",
    (byte*)"isvoid",
    (byte*)"isdef",
    (byte*)"defined",
    (byte*)"isint",
    (byte*)"isreal",
    (byte*)"islist",
    (byte*)"isstring",
    (byte*)"isrange",
    (byte*)"ispointer",
    (byte*)"isarray",
    (byte*)"isrecord",
    (byte*)"isset",
    (byte*)"isnumber",
    (byte*)"ismutable",
    (byte*)"odd",
    (byte*)"even",
    (byte*)"fi",
    (byte*)"esac",
    (byte*)"od",
    (byte*)"nil",
    (byte*)"con",
    (byte*)"pi",
    (byte*)"true",
    (byte*)"false",
    (byte*)"$neg",
    (byte*)"$index",
    (byte*)"$$dummy"
};
static byte qq_tables$stsymbols[212] = {
    (u8)82u,
    (u8)83u,
    (u8)84u,
    (u8)85u,
    (u8)86u,
    (u8)87u,
    (u8)91u,
    (u8)92u,
    (u8)93u,
    (u8)94u,
    (u8)95u,
    (u8)95u,
    (u8)96u,
    (u8)96u,
    (u8)97u,
    (u8)98u,
    (u8)89u,
    (u8)99u,
    (u8)100u,
    (u8)101u,
    (u8)101u,
    (u8)102u,
    (u8)103u,
    (u8)104u,
    (u8)104u,
    (u8)104u,
    (u8)104u,
    (u8)105u,
    (u8)106u,
    (u8)107u,
    (u8)142u,
    (u8)142u,
    (u8)144u,
    (u8)143u,
    (u8)143u,
    (u8)141u,
    (u8)108u,
    (u8)108u,
    (u8)108u,
    (u8)108u,
    (u8)109u,
    (u8)109u,
    (u8)108u,
    (u8)108u,
    (u8)110u,
    (u8)110u,
    (u8)138u,
    (u8)113u,
    (u8)113u,
    (u8)114u,
    (u8)114u,
    (u8)114u,
    (u8)114u,
    (u8)122u,
    (u8)116u,
    (u8)117u,
    (u8)118u,
    (u8)123u,
    (u8)124u,
    (u8)125u,
    (u8)126u,
    (u8)131u,
    (u8)132u,
    (u8)128u,
    (u8)119u,
    (u8)120u,
    (u8)121u,
    (u8)150u,
    (u8)90u,
    (u8)133u,
    (u8)134u,
    (u8)135u,
    (u8)130u,
    (u8)130u,
    (u8)129u,
    (u8)129u,
    (u8)145u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)80u,
    (u8)78u,
    (u8)78u,
    (u8)78u,
    (u8)139u,
    (u8)139u,
    (u8)139u,
    (u8)139u,
    (u8)139u,
    (u8)139u,
    (u8)139u,
    (u8)140u,
    (u8)34u,
    (u8)35u,
    (u8)36u,
    (u8)37u,
    (u8)38u,
    (u8)45u,
    (u8)46u,
    (u8)47u,
    (u8)48u,
    (u8)32u,
    (u8)33u,
    (u8)41u,
    (u8)42u,
    (u8)57u,
    (u8)58u,
    (u8)59u,
    (u8)60u,
    (u8)63u,
    (u8)64u,
    (u8)65u,
    (u8)61u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)66u,
    (u8)62u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)65u,
    (u8)66u,
    (u8)43u,
    (u8)44u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)67u,
    (u8)89u,
    (u8)89u,
    (u8)89u,
    (u8)149u,
    (u8)146u,
    (u8)146u,
    (u8)146u,
    (u8)146u,
    (u8)151u,
    (u8)151u,
    (u8)0u
};
static byte qq_tables$stsubcodes[212] = {
    (u8)0u,
    (u8)0u,
    (u8)8u,
    (u8)0u,
    (u8)11u,
    (u8)13u,
    (u8)11u,
    (u8)12u,
    (u8)15u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)53u,
    (u8)54u,
    (u8)55u,
    (u8)55u,
    (u8)0u,
    (u8)13u,
    (u8)14u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)60u,
    (u8)61u,
    (u8)62u,
    (u8)63u,
    (u8)64u,
    (u8)65u,
    (u8)60u,
    (u8)61u,
    (u8)69u,
    (u8)70u,
    (u8)13u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (byte)'D',
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)7u,
    (u8)8u,
    (u8)5u,
    (u8)6u,
    (u8)3u,
    (u8)3u,
    (u8)18u,
    (u8)4u,
    (u8)12u,
    (u8)0u,
    (u8)22u,
    (u8)23u,
    (u8)24u,
    (u8)25u,
    (u8)32u,
    (u8)32u,
    (u8)33u,
    (u8)34u,
    (u8)26u,
    (u8)26u,
    (u8)27u,
    (u8)28u,
    (u8)29u,
    (u8)30u,
    (u8)31u,
    (u8)22u,
    (u8)23u,
    (u8)24u,
    (u8)25u,
    (u8)26u,
    (u8)27u,
    (u8)28u,
    (u8)29u,
    (u8)30u,
    (u8)31u,
    (u8)35u,
    (u8)36u,
    (u8)36u,
    (u8)37u,
    (u8)2u,
    (u8)3u,
    (u8)0u,
    (u8)188u,
    (u8)189u,
    (u8)191u,
    (u8)190u,
    (u8)192u,
    (u8)193u,
    (u8)194u,
    (u8)0u,
    (u8)153u,
    (u8)154u,
    (u8)144u,
    (u8)145u,
    (u8)146u,
    (u8)149u,
    (u8)150u,
    (u8)151u,
    (u8)152u,
    (u8)142u,
    (u8)143u,
    (u8)161u,
    (u8)162u,
    (u8)80u,
    (u8)81u,
    (u8)82u,
    (u8)79u,
    (u8)83u,
    (u8)84u,
    (u8)85u,
    (u8)86u,
    (u8)88u,
    (u8)87u,
    (u8)89u,
    (u8)90u,
    (u8)91u,
    (u8)92u,
    (u8)166u,
    (u8)101u,
    (u8)93u,
    (u8)94u,
    (u8)95u,
    (u8)96u,
    (u8)97u,
    (u8)98u,
    (u8)99u,
    (u8)100u,
    (u8)164u,
    (u8)163u,
    (u8)106u,
    (u8)107u,
    (u8)108u,
    (u8)109u,
    (u8)111u,
    (u8)112u,
    (u8)119u,
    (u8)120u,
    (u8)115u,
    (u8)116u,
    (u8)114u,
    (u8)117u,
    (u8)118u,
    (u8)132u,
    (u8)133u,
    (u8)133u,
    (u8)121u,
    (u8)122u,
    (u8)126u,
    (u8)123u,
    (u8)124u,
    (u8)128u,
    (u8)129u,
    (u8)127u,
    (u8)131u,
    (u8)125u,
    (u8)130u,
    (u8)135u,
    (u8)136u,
    (u8)82u,
    (u8)91u,
    (u8)98u,
    (u8)0u,
    (u8)3u,
    (u8)1u,
    (u8)4u,
    (u8)5u,
    (byte)'-',
    (byte)(u64)23899u,
    (u8)0u
};
static u8 *  qq_tables$hostfnnames[60] = {
    (byte*)"h_dummy",
    (byte*)"h_startprint",
    (byte*)"h_startprintcon",
    (byte*)"h_strstartprint",
    (byte*)"h_setformat",
    (byte*)"h_endprint",
    (byte*)"h_strendprint",
    (byte*)"h_print",
    (byte*)"h_print_nf",
    (byte*)"h_println",
    (byte*)"h_printnogap",
    (byte*)"h_printspace",
    (byte*)"h_readln",
    (byte*)"h_sreadln",
    (byte*)"h_sread",
    (byte*)"h_rereadln",
    (byte*)"h_reread",
    (byte*)"h_strtoval",
    (byte*)"h_tostr",
    (byte*)"h_leftstr",
    (byte*)"h_rightstr",
    (byte*)"h_convlc",
    (byte*)"h_convuc",
    (byte*)"h_waitkey",
    (byte*)"h_testkey",
    (byte*)"h_execwait",
    (byte*)"h_execcmd",
    (byte*)"h_system",
    (byte*)"h_makestr",
    (byte*)"h_makeref",
    (byte*)"h_new",
    (byte*)"h_getcmdparam",
    (byte*)"h_gethostname",
    (byte*)"h_getprogname",
    (byte*)"h_$setdebug",
    (byte*)"h_$test2",
    (byte*)"h_$test",
    (byte*)"h_$refcount",
    (byte*)"h_ticks",
    (byte*)"h_clock",
    (byte*)"h_sleep",
    (byte*)"h_random",
    (byte*)"h_gethash",
    (byte*)"h_getos",
    (byte*)"h_iswindows",
    (byte*)"h_setmesshandler",
    (byte*)"h_$getparam",
    (byte*)"h_makeempty",
    (byte*)"h_$smallmemtotal",
    (byte*)"h_$id",
    (byte*)"h_copy",
    (byte*)"h_$nan",
    (byte*)"h_$infinity",
    (byte*)"h_$nprocs",
    (byte*)"h_$procname",
    (byte*)"h_$procref",
    (byte*)"h_allocexec",
    (byte*)"h_runnative",
    (byte*)"h_setlwb",
    (byte*)"h_last"
};
static byte qq_tables$hostnparams[60] = {
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)3u,
    (u8)3u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)4u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)0u
};
static byte qq_tables$hostisfn[60] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u
};
static byte qq_tables$hostinternal[60] = {
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u
};
static void (*qq_tables$hosthandlers[60])(void) = {
    0,
    (void (*)(void))qq_print$pch_startprint,
    (void (*)(void))qq_print$pch_startprintcon,
    (void (*)(void))qq_print$pch_strstartprint,
    (void (*)(void))qq_print$pch_setformat,
    (void (*)(void))qq_print$pch_endprint,
    (void (*)(void))qq_print$pch_strendprint,
    (void (*)(void))qq_print$pch_print,
    (void (*)(void))qq_print$pch_print_nf,
    (void (*)(void))qq_print$pch_println,
    (void (*)(void))qq_print$pch_printnogap,
    (void (*)(void))qq_print$pch_printspace,
    (void (*)(void))qq_print$pch_readln,
    (void (*)(void))qq_print$pch_sreadln,
    (void (*)(void))qq_print$pch_sread,
    (void (*)(void))qq_print$pch_rereadln,
    (void (*)(void))qq_print$pch_reread,
    (void (*)(void))qq_print$pch_strtoval,
    (void (*)(void))qq_print$pch_tostr,
    (void (*)(void))qq_host$pch_leftstr,
    (void (*)(void))qq_host$pch_rightstr,
    (void (*)(void))qq_host$pch_convlc,
    (void (*)(void))qq_host$pch_convuc,
    (void (*)(void))qq_host$pch_waitkey,
    (void (*)(void))qq_host$pch_testkey,
    (void (*)(void))qq_host$pch_execwait,
    (void (*)(void))qq_host$pch_execcmd,
    (void (*)(void))qq_host$pch_system,
    (void (*)(void))qq_host$pch_makestr,
    (void (*)(void))qq_host$pch_makeref,
    (void (*)(void))qq_host$pch_new,
    (void (*)(void))qq_host$pch_getcmdparam,
    (void (*)(void))qq_host$pch_gethostname,
    (void (*)(void))qq_host$pch_getprogname,
    (void (*)(void))qq_host$pch_$setdebug,
    (void (*)(void))qq_host$pch_$test2,
    (void (*)(void))qq_host$pch_$test,
    (void (*)(void))qq_host$pch_$refcount,
    (void (*)(void))qq_host$pch_ticks,
    (void (*)(void))qq_host$pch_clock,
    (void (*)(void))qq_host$pch_sleep,
    (void (*)(void))qq_host$pch_random,
    (void (*)(void))qq_host$pch_gethash,
    (void (*)(void))qq_host$pch_getos,
    (void (*)(void))qq_host$pch_iswindows,
    (void (*)(void))qq_host$pch_setmesshandler,
    (void (*)(void))qq_host$pch_$getparam,
    (void (*)(void))qq_host$pch_makeempty,
    (void (*)(void))qq_host$pch_$smallmemtotal,
    (void (*)(void))qq_host$pch_$id,
    (void (*)(void))qq_host$pch_copy,
    (void (*)(void))qq_host$pch_$nan,
    (void (*)(void))qq_host$pch_$infinity,
    (void (*)(void))qq_host$pch_$nprocs,
    (void (*)(void))qq_host$pch_$procname,
    (void (*)(void))qq_host$pch_$procref,
    (void (*)(void))qq_host$pch_allocexec,
    (void (*)(void))qq_host$pch_runnative,
    (void (*)(void))qq_host$pch_setlwb,
    0
};
static byte qq_tables$d_binopset[28] = {
    (u8)34u,
    (u8)35u,
    (u8)50u,
    (u8)51u,
    (u8)52u,
    (u8)53u,
    (u8)55u,
    (u8)54u,
    (u8)27u,
    (u8)28u,
    (u8)29u,
    (u8)30u,
    (u8)31u,
    (u8)32u,
    (u8)36u,
    (u8)37u,
    (u8)38u,
    (u8)39u,
    (u8)40u,
    (u8)41u,
    (u8)42u,
    (u8)44u,
    (u8)49u,
    (u8)56u,
    (u8)33u,
    (u8)66u,
    (u8)43u,
    (u8)22u
};
static byte qq_tables$binopset[153];
static byte qq_tables$d_unaryopset[9] = {(u8)57u,(u8)58u,(u8)60u,(u8)59u,(u8)61u,(u8)62u,(u8)63u,(u8)64u,(u8)65u};
static byte qq_tables$unaryopset[153];
static byte qq_tables$d_addopset[11] = {
    (u8)27u,
    (u8)28u,
    (u8)36u,
    (u8)37u,
    (u8)38u,
    (u8)44u,
    (u8)43u,
    (u8)41u,
    (u8)42u,
    (u8)22u,
    (u8)23u
};
static byte qq_tables$d_cmpopset[7] = {(u8)50u,(u8)51u,(u8)52u,(u8)53u,(u8)54u,(u8)55u,(u8)56u};
static byte qq_tables$d_mulopset[6] = {(u8)29u,(u8)30u,(u8)31u,(u8)32u,(u8)39u,(u8)40u};
static byte qq_tables$addopset[153];
static byte qq_tables$cmpopset[153];
static byte qq_tables$mulopset[153];
static byte qq_tables$exprendset[153];
static i64 qq_tables$d_exprstarterset[29] = {
    (i64)12,
    (i64)14,
    (i64)18,
    (i64)22,
    (i64)79,
    (i64)68,
    (i64)69,
    (i64)73,
    (i64)74,
    (i64)75,
    (i64)76,
    (i64)77,
    (i64)80,
    (i64)143,
    (i64)16,
    (i64)109,
    (i64)111,
    (i64)112,
    (i64)140,
    (i64)139,
    (i64)144,
    (i64)123,
    (i64)138,
    (i64)25,
    (i64)149,
    (i64)147,
    (i64)82,
    (i64)116,
    (i64)117
};
static byte qq_tables$exprstarterset[152];
static u8 *  qq_tables$ttname[251];
static struct qq_decls$strec *  qq_tables$ttnamedef[251];
static i16 qq_tables$ttbasetype[251];
static i16 qq_tables$tttarget[251];
static i64 qq_tables$ttlower[251];
static i64 qq_tables$ttlength[251];
static struct qq_decls$unitrec *  qq_tables$ttlowerexpr[251];
static struct qq_decls$unitrec *  qq_tables$ttlengthexpr[251];
static i64 qq_tables$ttsize[251];
static byte qq_tables$ttbitwidth[251];
static struct qq_decls$strec *  qq_tables$ttfields[251];
static byte qq_tables$ttcaligned[251];
static struct qq_decls$strec *  qq_tables$ttowner[251];
static i64 qq_tables$ntypes;
static i64 qq_tables$firstusertype;
static i64 qq_tables$nuserxtypes;
static i64 qq_tables$userxtypebase;
static struct qq_decls$userxrec *  qq_tables$userxmodelist;
static struct qq_decls$strec *  qq_tables$ttnamedefx[5000];
static i64 qq_tables$ttxmap[5000];
static byte qq_tables$ttxmoduleno[5000];
static byte qq_tables$hostlvset[60];
static i64 (*qq_show$labelmap)[];
static i64 qq_show$currlineno;
static struct qq_decls$strec *  qq_show$currpclproc;
static struct mlib$strbuffer qq_show$pclv;
static struct mlib$strbuffer *  qq_show$pcldest = (struct mlib$strbuffer *)&qq_show$pclv;
static struct qq_decls$objrec qq_vars$zeroobj;
static void *  msysc$_fnaddresses[]= {
    &main,
    &qq_cli$getinputoptions,
    &qq_cli$do_option,
    &qq_cli$start,
    &qq_api$compile_sp,
    &qq_api$setcli,
    &qq_api$fixup_sp,
    &qq_api$writeqafile,
    &qq_api$initdata,
    &qq_api$fixproc,
    &qq_api$fixupmodule,
    &qq_api$runqprogram,
    &qq_api$disploop,
    &qq_api$disploop_fn,
    &qq_api$disploop_deb,
    &qq_api$setcmdmap,
    &qq_api$runproc_m,
    &qq_api$runproc,
    &qq_api$resetcompiler,
    &qq_api$loadsyslib,
    &qq_api$start,
    &qq_arrays$var_empty_array,
    &qq_arrays$obj_free_array,
    &qq_arrays$obj_free_vector,
    &qq_arrays$var_make_array,
    &qq_arrays$obj_newarray,
    &qq_arrays$obj_newarray_u,
    &qq_arrays$var_getix_array,
    &qq_arrays$var_putix_array,
    &qq_arrays$var_getixref_array,
    &qq_arrays$obj_append_array,
    &qq_arrays$var_appendto_array,
    &qq_arrays$obj_resize_array,
    &qq_arrays$var_dupl_array,
    &qq_arrays$var_dupl_vector,
    &qq_arrays$var_equal_array,
    &qq_arrays$var_concatto_array,
    &qq_arrays$var_getslice_array,
    &qq_arrays$u8inarray,
    &qq_arrays$u16inarray,
    &qq_arrays$u32inarray,
    &qq_arrays$u64inarray,
    &qq_arrays$var_inx_array,
    &qq_arrays$var_expand_array,
    &qq_arrays$start,
    &qq_bits$obj_free_bits,
    &qq_bits$var_make_bits,
    &qq_bits$obj_newbits,
    &qq_bits$var_getix_bits,
    &qq_bits$var_putix_bits,
    &qq_bits$var_getixref_bits,
    &qq_bits$getindexoffset,
    &qq_bits$obj_append_bits,
    &qq_bits$var_appendto_bits,
    &qq_bits$obj_resize_bits,
    &qq_bits$var_dupl_bits,
    &qq_bits$var_equal_bits,
    &qq_bits$var_concatto_bits,
    &qq_bits$var_getslice_bits,
    &qq_bits$bits_bytesize,
    &qq_bits$getbitssize,
    &qq_bits$start,
    &qq_calldll$calldll,
    &qq_calldll$getlibprocaddr,
    &qq_calldll$vartopacked,
    &qq_calldll$packedtovar,
    &qq_calldll$loaddllfunction,
    &qq_calldll$start,
    &qq_decimal$obj_free_dec,
    &qq_decimal$var_dupl_dec,
    &qq_decimal$var_empty_dec,
    &qq_decimal$var_make_dec_str,
    &qq_decimal$var_make_dec_int,
    &qq_decimal$badnumber,
    &qq_decimal$bn_makestr,
    &qq_decimal$readexpon,
    &qq_decimal$bn_makeint,
    &qq_decimal$var_tostr_dec,
    &qq_decimal$obj_tostr_dec,
    &qq_decimal$tostring_scient,
    &qq_decimal$tostring_float,
    &qq_decimal$strvaln,
    &qq_decimal$bn_isint,
    &qq_decimal$obj_len_dec,
    &qq_decimal$bn_iszero,
    &qq_decimal$var_equal_dec,
    &qq_decimal$var_add_dec,
    &qq_decimal$var_sub_dec,
    &qq_decimal$var_mul_dec,
    &qq_decimal$var_div_dec,
    &qq_decimal$var_idiv_dec,
    &qq_decimal$var_irem_dec,
    &qq_decimal$var_neg_dec,
    &qq_decimal$var_abs_dec,
    &qq_decimal$var_compare_dec,
    &qq_decimal$bn_cmp,
    &qq_decimal$bn_equal,
    &qq_decimal$bn_add,
    &qq_decimal$bn_sub,
    &qq_decimal$bn_addu,
    &qq_decimal$bn_subu,
    &qq_decimal$makebignum,
    &qq_decimal$makesmallnum,
    &qq_decimal$smalltobig,
    &qq_decimal$freesmall,
    &qq_decimal$bn_init,
    &qq_decimal$bn_setzero,
    &qq_decimal$bn_move,
    &qq_decimal$bn_dupl,
    &qq_decimal$bn_setinf,
    &qq_decimal$bn_setnan,
    &qq_decimal$var_setnan,
    &qq_decimal$var_setinf,
    &qq_decimal$getbintype,
    &qq_decimal$bn_negto,
    &qq_decimal$bn_absto,
    &qq_decimal$bn_mul,
    &qq_decimal$bn_mulp,
    &qq_decimal$bn_mulu,
    &qq_decimal$smallmulto,
    &qq_decimal$bn_div,
    &qq_decimal$bn_idiv,
    &qq_decimal$bn_idivrem,
    &qq_decimal$bn_irem,
    &qq_decimal$bn_idivu,
    &qq_decimal$bn_fdivu,
    &qq_decimal$smalldiv,
    &qq_decimal$smallsubto,
    &qq_decimal$bn_getprec,
    &qq_decimal$bn_setprec,
    &qq_decimal$bn_getglobalprec,
    &qq_decimal$bn_setglobalprec,
    &qq_decimal$bn_makefloat,
    &qq_decimal$dectemp,
    &qq_decimal$freedectemp,
    &qq_decimal$bn_ipower,
    &qq_decimal$var_power_dec,
    &qq_decimal$var_convert_dec_int,
    &qq_decimal$bn_toint,
    &qq_decimal$start,
    &qq_decls$start,
    &qq_dicts$var_make_dict,
    &qq_dicts$obj_new_dict,
    &qq_dicts$obj_free_dict,
    &qq_dicts$var_dupl_dict,
    &qq_dicts$var_equal_dict,
    &qq_dicts$var_finddictitem,
    &qq_dicts$expanddict,
    &qq_dicts$adddictitem,
    &qq_dicts$start,
    &qq_jhandlers_hll$asmavailable,
    &qq_jhandlers_hll$disploop_asm,
    &qq_jhandlers_hll$initjhandlers,
    &qq_jhandlers_hll$start,
    &qq_khandlers$kunimpl,
    &qq_khandlers$k_pushci,
    &qq_khandlers$k_pushnil,
    &qq_khandlers$k_pushcs,
    &qq_khandlers$k_pushcr,
    &qq_khandlers$k_stop,
    &qq_khandlers$k_stoprunproc,
    &qq_khandlers$k_pushm,
    &qq_khandlers$k_pushf,
    &qq_khandlers$k_pushff,
    &qq_khandlers$k_pushmref,
    &qq_khandlers$k_pushfref,
    &qq_khandlers$k_popm,
    &qq_khandlers$k_storem,
    &qq_khandlers$k_zpopm,
    &qq_khandlers$k_popf,
    &qq_khandlers$k_storef,
    &qq_khandlers$k_zpopf,
    &qq_khandlers$k_popretval,
    &qq_khandlers$k_tom,
    &qq_khandlers$k_tof,
    &qq_khandlers$k_add,
    &qq_khandlers$k_sub,
    &qq_khandlers$k_mul,
    &qq_khandlers$k_div,
    &qq_khandlers$k_idiv,
    &qq_khandlers$k_irem,
    &qq_khandlers$k_iand,
    &qq_khandlers$k_ior,
    &qq_khandlers$k_ixor,
    &qq_khandlers$k_shl,
    &qq_khandlers$k_shr,
    &qq_khandlers$k_sqr,
    &qq_khandlers$k_sign,
    &qq_khandlers$k_sqrt,
    &qq_khandlers$k_sin,
    &qq_khandlers$k_cos,
    &qq_khandlers$k_tan,
    &qq_khandlers$k_asin,
    &qq_khandlers$k_acos,
    &qq_khandlers$k_atan,
    &qq_khandlers$k_log,
    &qq_khandlers$k_log10,
    &qq_khandlers$k_exp,
    &qq_khandlers$k_round,
    &qq_khandlers$k_floor,
    &qq_khandlers$k_ceil,
    &qq_khandlers$k_fract,
    &qq_khandlers$k_neg,
    &qq_khandlers$k_negto,
    &qq_khandlers$k_absto,
    &qq_khandlers$k_inotto,
    &qq_khandlers$k_atan2,
    &qq_khandlers$k_fmod,
    &qq_khandlers$k_abs,
    &qq_khandlers$k_inot,
    &qq_khandlers$k_istruel,
    &qq_khandlers$k_notl,
    &qq_khandlers$k_jumpeq,
    &qq_khandlers$k_jumpne,
    &qq_khandlers$k_jumplt,
    &qq_khandlers$k_jumple,
    &qq_khandlers$k_jumpge,
    &qq_khandlers$k_jumpgt,
    &qq_khandlers$k_jumpfalse,
    &qq_khandlers$k_jumptrue,
    &qq_khandlers$k_incrtom,
    &qq_khandlers$k_incrtof,
    &qq_khandlers$k_decrtom,
    &qq_khandlers$k_decrtof,
    &qq_khandlers$k_incrload,
    &qq_khandlers$k_loadincr,
    &qq_khandlers$k_decrload,
    &qq_khandlers$k_loaddecr,
    &qq_khandlers$k_incrptr,
    &qq_khandlers$k_decrptr,
    &qq_khandlers$k_pushvoid,
    &qq_khandlers$k_callproc,
    &qq_khandlers$k_callptr,
    &qq_khandlers$k_procentry,
    &qq_khandlers$k_return,
    &qq_khandlers$k_return0,
    &qq_khandlers$k_unshare,
    &qq_khandlers$k_unshare1,
    &qq_khandlers$k_formci,
    &qq_khandlers$k_forfci,
    &qq_khandlers$k_fordmci,
    &qq_khandlers$k_fordfci,
    &qq_khandlers$k_formm,
    &qq_khandlers$k_fordmm,
    &qq_khandlers$k_forff,
    &qq_khandlers$k_fordff,
    &qq_khandlers$k_comment,
    &qq_khandlers$k_makelist,
    &qq_khandlers$k_makedict,
    &qq_khandlers$k_makeset,
    &qq_khandlers$k_makerecord,
    &qq_khandlers$k_makestruct,
    &qq_khandlers$k_makearray,
    &qq_khandlers$k_makebits,
    &qq_khandlers$k_index,
    &qq_khandlers$k_popindex,
    &qq_khandlers$k_indexref,
    &qq_khandlers$k_keyindex,
    &qq_khandlers$k_popkeyindex,
    &qq_khandlers$k_keyindexref,
    &qq_khandlers$k_dot,
    &qq_khandlers$k_dotref,
    &qq_khandlers$k_popdot,
    &qq_khandlers$k_dotindex,
    &qq_khandlers$k_dotindexref,
    &qq_khandlers$k_popdotindex,
    &qq_khandlers$k_len,
    &qq_khandlers$k_upb,
    &qq_khandlers$k_lwb,
    &qq_khandlers$k_bounds,
    &qq_khandlers$k_boundsx,
    &qq_khandlers$do_bounds,
    &qq_khandlers$k_dictitems,
    &qq_khandlers$k_isfound,
    &qq_khandlers$k_append,
    &qq_khandlers$k_concat,
    &qq_khandlers$k_appendto,
    &qq_khandlers$k_concatto,
    &qq_khandlers$k_addto,
    &qq_khandlers$k_subto,
    &qq_khandlers$k_multo,
    &qq_khandlers$k_divto,
    &qq_khandlers$k_idivto,
    &qq_khandlers$k_iandto,
    &qq_khandlers$k_iorto,
    &qq_khandlers$k_ixorto,
    &qq_khandlers$k_shlto,
    &qq_khandlers$k_shrto,
    &qq_khandlers$k_copy,
    &qq_khandlers$k_dupl,
    &qq_khandlers$k_makerange,
    &qq_khandlers$k_makerangelen,
    &qq_khandlers$k_makedecimal,
    &qq_khandlers$k_makeclosure,
    &qq_khandlers$resolvefield,
    &qq_khandlers$k_pushptr,
    &qq_khandlers$k_popptr,
    &qq_khandlers$k_islist,
    &qq_khandlers$k_isarray,
    &qq_khandlers$k_isstring,
    &qq_khandlers$k_isrecord,
    &qq_khandlers$k_swap,
    &qq_khandlers$k_jumptesteq,
    &qq_khandlers$k_jumptestne,
    &qq_khandlers$k_jump,
    &qq_khandlers$k_jumpptr,
    &qq_khandlers$k_incr,
    &qq_khandlers$k_decr,
    &qq_khandlers$k_chr,
    &qq_khandlers$k_asc,
    &qq_khandlers$k_pusht,
    &qq_khandlers$k_type,
    &qq_khandlers$k_basetype,
    &qq_khandlers$k_usertype,
    &qq_khandlers$k_elemtype,
    &qq_khandlers$k_nop,
    &qq_khandlers$k_modulecall,
    &qq_khandlers$k_modulereturn,
    &qq_khandlers$k_maxvalue,
    &qq_khandlers$k_minvalue,
    &qq_khandlers$k_callhost,
    &qq_khandlers$k_expand,
    &qq_khandlers$k_pushsymbol,
    &qq_khandlers$k_eq,
    &qq_khandlers$k_ne,
    &qq_khandlers$k_lt,
    &qq_khandlers$k_le,
    &qq_khandlers$k_ge,
    &qq_khandlers$k_gt,
    &qq_khandlers$do_cmp,
    &qq_khandlers$k_calldll,
    &qq_khandlers$k_in,
    &qq_khandlers$k_notin,
    &qq_khandlers$k_inx,
    &qq_khandlers$k_convrefpack,
    &qq_khandlers$k_isdef,
    &qq_khandlers$k_isvoid,
    &qq_khandlers$k_isint,
    &qq_khandlers$k_isnumber,
    &qq_khandlers$k_ismutable,
    &qq_khandlers$k_isreal,
    &qq_khandlers$k_isrange,
    &qq_khandlers$k_isset,
    &qq_khandlers$k_ispointer,
    &qq_khandlers$istype,
    &qq_khandlers$k_convert,
    &qq_khandlers$k_switch,
    &qq_khandlers$k_bytesize,
    &qq_khandlers$k_bitwidth,
    &qq_khandlers$k_min,
    &qq_khandlers$k_max,
    &qq_khandlers$k_addsp,
    &qq_khandlers$k_pushtry,
    &qq_khandlers$k_raise,
    &qq_khandlers$k_isequal,
    &qq_khandlers$k_minto,
    &qq_khandlers$k_maxto,
    &qq_khandlers$k_power,
    &qq_khandlers$domaths,
    &qq_khandlers$getmaths,
    &qq_khandlers$k_typepun,
    &qq_khandlers$k_andlto,
    &qq_khandlers$k_orlto,
    &qq_khandlers$k_notlto,
    &qq_khandlers$k_pushoperator,
    &qq_khandlers$k_maps,
    &qq_khandlers$k_mapss,
    &qq_khandlers$k_idivrem,
    &qq_khandlers$k_odd,
    &qq_khandlers$k_even,
    &qq_khandlers$start,
    &qq_host$callhostfunction,
    &qq_host$pch_leftstr,
    &qq_host$pch_rightstr,
    &qq_host$pch_convlc,
    &qq_host$pch_convuc,
    &qq_host$pch_waitkey,
    &qq_host$pch_execwait,
    &qq_host$pch_execcmd,
    &qq_host$pch_makestr,
    &qq_host$pch_makeref,
    &qq_host$pch_getcmdparam,
    &qq_host$pch_clock,
    &qq_host$pch_allocexec,
    &qq_host$pch_runnative,
    &qq_host$pch_setlwb,
    &qq_host$pch_ticks,
    &qq_host$pch_sleep,
    &qq_host$pch_random,
    &qq_host$pch_system,
    &qq_host$pch_$getparam,
    &qq_host$checkparam,
    &qq_host$leftstring,
    &qq_host$rightstring,
    &qq_host$padstring_right,
    &qq_host$padstring_left,
    &qq_host$getbounds,
    &qq_host$pch_new,
    &qq_host$pch_gethostname,
    &qq_host$pch_getprogname,
    &qq_host$pch_$test,
    &qq_host$pch_$test2,
    &qq_host$pch_$refcount,
    &qq_host$pch_testkey,
    &qq_host$pch_getos,
    &qq_host$pch_setmesshandler,
    &qq_host$pch_$smallmemtotal,
    &qq_host$pch_$id,
    &qq_host$pch_iswindows,
    &qq_host$pch_$setdebug,
    &qq_host$pch_copy,
    &qq_host$pch_gethash,
    &qq_host$pch_makeempty,
    &qq_host$pch_$infinity,
    &qq_host$pch_$nan,
    &qq_host$setcmdparam,
    &qq_host$pch_$nprocs,
    &qq_host$initprocrefs,
    &qq_host$pch_$procname,
    &qq_host$pch_$procref,
    &qq_host$start,
    &qq_lex$lexreadtoken,
    &qq_lex$lxreadstring,
    &qq_lex$lexinit,
    &qq_lex$readrawstring,
    &qq_lex$lookup,
    &qq_lex$gethashvaluez,
    &qq_lex$start,
    &qq_lex$inithashtable,
    &qq_lex$addstname,
    &qq_lex$startlex,
    &qq_lex$addnamestr,
    &qq_lex$ps,
    &qq_lex$psnext,
    &qq_lex$lex,
    &qq_lex$lxerror_s,
    &qq_lex$makedecimal,
    &qq_lex$readdec,
    &qq_lex$readhex,
    &qq_lex$readbin,
    &qq_lex$readreal,
    &qq_lex$readrawxname,
    &qq_lib$reportcterror,
    &qq_lib$geterrorinfo,
    &qq_lib$setlineno,
    &qq_lib$showerrorsource,
    &qq_lib$stopcompiler,
    &qq_lib$gerror,
    &qq_lib$gerror_s,
    &qq_lib$serror,
    &qq_lib$serror_s,
    &qq_lib$rxerror,
    &qq_lib$rxerror_s,
    &qq_lib$lxerror,
    &qq_lib$pcnotmut,
    &qq_lib$pcerror,
    &qq_lib$pcerror_s,
    &qq_lib$reportpcerror,
    &qq_lib$getpcerrorpos,
    &qq_lib$loaderror,
    &qq_lib$findmodulefrompc,
    &qq_lib$prterror,
    &qq_lib$pcustype,
    &qq_lib$pcustype_t,
    &qq_lib$pcmxtypes,
    &qq_lib$pcmxtypestt,
    &qq_lib$allocunitrec,
    &qq_lib$createintunit,
    &qq_lib$createrealunit,
    &qq_lib$createstringunit,
    &qq_lib$createunit0,
    &qq_lib$createunit1,
    &qq_lib$createunit2,
    &qq_lib$createname,
    &qq_lib$addlistunit,
    &qq_lib$createavname,
    &qq_lib$convtostringz,
    &qq_lib$findprocname,
    &qq_lib$strexpr,
    &qq_lib$strexpr_s,
    &qq_lib$jeval,
    &qq_lib$jevallist,
    &qq_lib$additem,
    &qq_lib$isalphanum,
    &qq_lib$getopcname,
    &qq_lib$convertstring,
    &qq_lib$createavnamex,
    &qq_lib$storemode,
    &qq_lib$nextpoweroftwo,
    &qq_lib$raiseexception,
    &qq_lib$raise_error,
    &qq_lib$testelem,
    &qq_lib$setelem,
    &qq_lib$setelemblock,
    &qq_lib$ispoweroftwo,
    &qq_lib$deleteunit,
    &qq_lib$skipsemi,
    &qq_lib$checksymbol,
    &qq_lib$skipsymbol,
    &qq_lib$start,
    &qq_lists$start,
    &qq_lists$var_empty_list,
    &qq_lists$var_make_list,
    &qq_lists$obj_newlist,
    &qq_lists$obj_free_list,
    &qq_lists$var_getix_list,
    &qq_lists$var_getslice_list,
    &qq_lists$var_getixref_list,
    &qq_lists$var_putix_list,
    &qq_lists$var_putslice_list,
    &qq_lists$obj_append_list,
    &qq_lists$obj_resize_list,
    &qq_lists$var_appendto_list,
    &qq_lists$var_dupl_list,
    &qq_lists$var_mul_list,
    &qq_lists$var_equal_list,
    &qq_lists$var_concatto_list,
    &qq_lists$var_inx_list,
    &qq_modules$loadsp,
    &qq_modules$getmodulefilename,
    &qq_modules$loadsourcefile,
    &qq_modules$loadstring,
    &qq_modules$readfileline,
    &qq_modules$findnextlineheader,
    &qq_modules$loadqafile,
    &qq_modules$readqabundle,
    &qq_modules$start,
    &qq_names$addglobalname,
    &qq_names$newstrec,
    &qq_names$addsymbol,
    &qq_names$addproc,
    &qq_names$newusertypex,
    &qq_names$resolvedottedname,
    &qq_names$addgenfield,
    &qq_names$makereftype,
    &qq_names$makeaxtype,
    &qq_names$makeslicetype,
    &qq_names$makestrtype,
    &qq_names$addanontype,
    &qq_names$createusertype,
    &qq_names$getalignment,
    &qq_names$duplfield,
    &qq_names$writesig,
    &qq_names$createdupldef,
    &qq_names$start,
    &qq_optimdummy$optimise_module,
    &qq_optimdummy$start,
    &qq_packed$var_loadpacked,
    &qq_packed$var_storepacked,
    &qq_packed$setfslength,
    &qq_packed$getfslength,
    &qq_packed$var_make_struct,
    &qq_packed$obj_new_struct,
    &qq_packed$var_dupl_struct,
    &qq_packed$obj_free_struct,
    &qq_packed$var_equal_struct,
    &qq_packed$var_getix_struct,
    &qq_packed$start,
    &qq_parse$parsemodule,
    &qq_parse$readexpression,
    &qq_parse$readassignment,
    &qq_parse$readorterms,
    &qq_parse$readandterms,
    &qq_parse$readcmpterms,
    &qq_parse$readinterms,
    &qq_parse$readrangeterm,
    &qq_parse$readaddterms,
    &qq_parse$readmulterms,
    &qq_parse$readpowerterms,
    &qq_parse$readterm2,
    &qq_parse$readtermsuffix,
    &qq_parse$readterm,
    &qq_parse$readsunit,
    &qq_parse$checkequals,
    &qq_parse$readindex,
    &qq_parse$readdotsuffix,
    &qq_parse$readslist,
    &qq_parse$readcondsuffix,
    &qq_parse$readkeyindex,
    &qq_parse$readlbrack,
    &qq_parse$readif,
    &qq_parse$checkend,
    &qq_parse$readunless,
    &qq_parse$readwhile,
    &qq_parse$readrepeat,
    &qq_parse$readfor,
    &qq_parse$readdo,
    &qq_parse$readto,
    &qq_parse$makeblock,
    &qq_parse$readvardef,
    &qq_parse$readconstdef,
    &qq_parse$readreturn,
    &qq_parse$readprint,
    &qq_parse$readread,
    &qq_parse$readloopcontrol,
    &qq_parse$readintunit,
    &qq_parse$readswitchcase,
    &qq_parse$readgoto,
    &qq_parse$readstop,
    &qq_parse$readcast,
    &qq_parse$readset,
    &qq_parse$readtabledef,
    &qq_parse$readtry,
    &qq_parse$readsprint,
    &qq_parse$readsread,
    &qq_parse$readimportdll,
    &qq_parse$readffiparams,
    &qq_parse$readtypeparams,
    &qq_parse$readtypenameparams,
    &qq_parse$readrecorddef,
    &qq_parse$readrecordbody,
    &qq_parse$readrecordfields,
    &qq_parse$readstructbody,
    &qq_parse$addstructflag,
    &qq_parse$readprocdef,
    &qq_parse$readatfield,
    &qq_parse$istypestarter,
    &qq_parse$readmacrodef,
    &qq_parse$readhostparams,
    &qq_parse$pushlisttype,
    &qq_parse$poplisttype,
    &qq_parse$readcompilervar,
    &qq_parse$readpair,
    &qq_parse$lexchecksymbol,
    &qq_parse$readtypedef,
    &qq_parse$readtypespec,
    &qq_parse$readparams,
    &qq_parse$checkoperator,
    &qq_parse$readlambda,
    &qq_parse$readpackvars,
    &qq_parse$start,
    &qq_print$pch_print,
    &qq_print$pch_print_nf,
    &qq_print$pch_printnogap,
    &qq_print$pch_println,
    &qq_print$pch_reread,
    &qq_print$pch_rereadln,
    &qq_print$pch_startprint,
    &qq_print$pch_startprintcon,
    &qq_print$pch_endprint,
    &qq_print$pch_strstartprint,
    &qq_print$pch_strendprint,
    &qq_print$pch_printspace,
    &qq_print$pch_readln,
    &qq_print$pch_sread,
    &qq_print$pch_sreadln,
    &qq_print$readname,
    &qq_print$readstring,
    &qq_print$readint,
    &qq_print$readhex,
    &qq_print$readbin,
    &qq_print$readreal,
    &qq_print$getreadfmtcode,
    &qq_print$stepkbpos,
    &qq_print$readany,
    &qq_print$readitem,
    &qq_print$strtoreal,
    &qq_print$strtoint,
    &qq_print$printnextfmtchars,
    &qq_print$pch_setformat,
    &qq_print$pc_getfmt,
    &qq_print$addstring,
    &qq_print$domultichar,
    &qq_print$printstr_n,
    &qq_print$pch_strtoval,
    &qq_print$tostr_int,
    &qq_print$tostr_real,
    &qq_print$tostr_str,
    &qq_print$pch_tostr,
    &qq_print$tostr_range,
    &qq_print$tostr_array,
    &qq_print$tostr_bits,
    &qq_print$tostr_struct,
    &qq_print$tostr_set,
    &qq_print$tostr_dict,
    &qq_print$tostr_decimal,
    &qq_print$tostr,
    &qq_print$tostr_list,
    &qq_print$start,
    &qq_pclgen$evalunit,
    &qq_pclgen$gencodemodule,
    &qq_pclgen$do_procdef,
    &qq_pclgen$genprocentry,
    &qq_pclgen$genprocexit,
    &qq_pclgen$evalref,
    &qq_pclgen$genjumpcond,
    &qq_pclgen$gcomparejump,
    &qq_pclgen$genjumpl,
    &qq_pclgen$reversecond,
    &qq_pclgen$stacklooplabels,
    &qq_pclgen$unstacklooplabels,
    &qq_pclgen$findlooplabel,
    &qq_pclgen$do_assign,
    &qq_pclgen$do_bin,
    &qq_pclgen$do_binref,
    &qq_pclgen$do_unary,
    &qq_pclgen$do_unaryref,
    &qq_pclgen$do_pushlist,
    &qq_pclgen$do_makedict,
    &qq_pclgen$do_call,
    &qq_pclgen$pushparams,
    &qq_pclgen$evalparam,
    &qq_pclgen$pushkwdparams,
    &qq_pclgen$do_if,
    &qq_pclgen$do_do,
    &qq_pclgen$do_exit,
    &qq_pclgen$do_to,
    &qq_pclgen$do_while,
    &qq_pclgen$do_repeat,
    &qq_pclgen$do_for,
    &qq_pclgen$do_forx,
    &qq_pclgen$do_print,
    &qq_pclgen$do_fprint,
    &qq_pclgen$do_read,
    &qq_pclgen$do_forall,
    &qq_pclgen$do_case,
    &qq_pclgen$do_case_nc,
    &qq_pclgen$do_try,
    &qq_pclgen$unitstoarray,
    &qq_pclgen$do_select,
    &qq_pclgen$do_andl,
    &qq_pclgen$do_orl,
    &qq_pclgen$do_incr,
    &qq_pclgen$do_new,
    &qq_pclgen$checkblockreturn,
    &qq_pclgen$do_callhost,
    &qq_pclgen$callhostfn,
    &qq_pclgen$genfree,
    &qq_pclgen$do_return,
    &qq_pclgen$do_multassign,
    &qq_pclgen$do_store,
    &qq_pclgen$getconstvalue,
    &qq_pclgen$do_convert,
    &qq_pclgen$checkelems,
    &qq_pclgen$do_switch,
    &qq_pclgen$do_simpleswitch,
    &qq_pclgen$do_makerecordkv,
    &qq_pclgen$do_idiv,
    &qq_pclgen$do_irem,
    &qq_pclgen$do_map,
    &qq_pclgen$pushstring,
    &qq_pclgen$start,
    &qq_pcllib$start,
    &qq_pcllib$resetpcl,
    &qq_pcllib$genpc,
    &qq_pcllib$genopnd_int,
    &qq_pcllib$genopnd_name,
    &qq_pcllib$genpc_int,
    &qq_pcllib$genpc_int2,
    &qq_pcllib$genpc_int4,
    &qq_pcllib$genpc_name,
    &qq_pcllib$genopnd_strz,
    &qq_pcllib$genopnd_str,
    &qq_pcllib$genopnd_obj,
    &qq_pcllib$genpc_real,
    &qq_pcllib$genpc_lab,
    &qq_pcllib$genopnd_lab,
    &qq_pcllib$gencomment,
    &qq_pcllib$extendpcldata,
    &qq_pcllib$extendlabeltable,
    &qq_pcllib$definelabel,
    &qq_pcllib$createfwdlabel,
    &qq_pcllib$definefwdlabel,
    &qq_records$var_make_record,
    &qq_records$obj_new_record,
    &qq_records$obj_free_record,
    &qq_records$var_dupl_record,
    &qq_records$var_equal_record,
    &qq_records$var_getix_record,
    &qq_records$var_putix_record,
    &qq_records$var_getixref_record,
    &qq_records$start,
    &qq_resolve$rx_module,
    &qq_resolve$rx_passdef,
    &qq_resolve$rx_deflist,
    &qq_resolve$rx_unit,
    &qq_resolve$rx_unitlist,
    &qq_resolve$evalmonop,
    &qq_resolve$evalbinop,
    &qq_resolve$makeintconst,
    &qq_resolve$makerealconst,
    &qq_resolve$resolvename,
    &qq_resolve$resolvetopname,
    &qq_resolve$resolvedot,
    &qq_resolve$resolvedot_sym,
    &qq_resolve$finddupl,
    &qq_resolve$expandmacro,
    &qq_resolve$copylistunit,
    &qq_resolve$copyunit,
    &qq_resolve$replaceunit,
    &qq_resolve$fixmode,
    &qq_resolve$fixmode2,
    &qq_resolve$fixusertypes,
    &qq_resolve$tx_typetable,
    &qq_resolve$getconstint,
    &qq_resolve$converttype,
    &qq_resolve$scanstruct,
    &qq_resolve$dobaseclass,
    &qq_resolve$start,
    &qq_sets$obj_free_set,
    &qq_sets$var_dupl_set,
    &qq_sets$var_equal_set,
    &qq_sets$getsetbytes,
    &qq_sets$var_make_set,
    &qq_sets$obj_newset,
    &qq_sets$var_emptyset,
    &qq_sets$var_getix_set,
    &qq_sets$var_putix_set,
    &qq_sets$var_getixref_set,
    &qq_sets$getoffset,
    &qq_sets$var_in_set,
    &qq_sets$iresizeset,
    &qq_sets$obj_resize_set,
    &qq_sets$iorsetbits,
    &qq_sets$ixorsetbits,
    &qq_sets$iandsetbits,
    &qq_sets$inotsetbits,
    &qq_sets$var_iorto_set,
    &qq_sets$var_iandto_set,
    &qq_sets$var_ixorto_set,
    &qq_sets$var_inotto_set,
    &qq_sets$start,
    &qq_strings$start,
    &qq_strings$var_empty_string,
    &qq_strings$var_make_string,
    &qq_strings$var_make_stringn,
    &qq_strings$obj_new_string,
    &qq_strings$obj_make_string,
    &qq_strings$obj_make_stringn,
    &qq_strings$obj_free_string,
    &qq_strings$var_dupl_string,
    &qq_strings$var_getix_string,
    &qq_strings$var_getixref_string,
    &qq_strings$var_getdotix_string,
    &qq_strings$var_getdotixref_string,
    &qq_strings$var_getslice_string,
    &qq_strings$stringslice,
    &qq_strings$var_putix_string,
    &qq_strings$var_putslice_string,
    &qq_strings$var_putdotix_string,
    &qq_strings$obj_resize_string,
    &qq_strings$var_add_string,
    &qq_strings$var_addto_string,
    &qq_strings$var_addto_string_ch,
    &qq_strings$var_equal_string,
    &qq_strings$var_compare_string,
    &qq_strings$cmpstring_len,
    &qq_strings$var_inx_string,
    &qq_strings$var_iconvcase,
    &qq_strings$var_makestrslicexobj,
    &qq_strings$obj_make_strslicexobj,
    &qq_strings$var_asc,
    &qq_strings$var_new_string,
    &qq_strings$var_new_stringn,
    &qq_strings$var_mul_string,
    &qq_strings$var_convert_string_list,
    &qq_strings$var_expand_string,
    &qq_strings$var_makechar,
    &qq_syslibs$findsyslib,
    &qq_syslibs$loadsysmodule,
    &qq_syslibs$start,
    &qq_tables$start,
    &qq_show$printunit,
    &qq_show$printunitlist,
    &qq_show$getprefix,
    &qq_show$getlineinfok,
    &qq_show$gstr,
    &qq_show$gstrln,
    &qq_show$gline,
    &qq_show$gstrint,
    &qq_show$glabeldef,
    &qq_show$printglobalsymbols,
    &qq_show$printst,
    &qq_show$printstrec,
    &qq_show$printtypetables,
    &qq_show$showsttree,
    &qq_show$showtypes,
    &qq_show$showpcl,
    &qq_show$showpcl2,
    &qq_show$showast,
    &qq_show$showast2,
    &qq_show$showlogfile,
    &qq_show$addtolog,
    &qq_show$showstflat,
    &qq_show$showmoduleinfo,
    &qq_show$printsymbol,
    &qq_show$strmode,
    &qq_show$istrmode,
    &qq_show$writepcl,
    &qq_show$writepclopnd,
    &qq_show$writeallpcl,
    &qq_show$deletetempfiles,
    &qq_show$start,
    &qq_vars$var_unshareu,
    &qq_vars$obj_shareu,
    &qq_vars$void_new,
    &qq_vars$obj_new,
    &qq_vars$var_getintvalue,
    &qq_vars$var_fromobj,
    &qq_vars$var_free,
    &qq_vars$var_duplu,
    &qq_vars$var_neg,
    &qq_vars$var_abs,
    &qq_vars$var_inot,
    &qq_vars$var_istruel,
    &qq_vars$var_add,
    &qq_vars$var_addmixed,
    &qq_vars$var_addto,
    &qq_vars$var_sub,
    &qq_vars$var_submixed,
    &qq_vars$var_mul,
    &qq_vars$var_mulmixed,
    &qq_vars$var_div,
    &qq_vars$var_divmixed,
    &qq_vars$var_idiv,
    &qq_vars$var_irem,
    &qq_vars$var_iand,
    &qq_vars$var_ior,
    &qq_vars$var_ixor,
    &qq_vars$var_shl,
    &qq_vars$var_shr,
    &qq_vars$var_in,
    &qq_vars$var_inx,
    &qq_vars$var_equal,
    &qq_vars$var_equalmixed,
    &qq_vars$var_compare,
    &qq_vars$var_comparemixed,
    &qq_vars$var_concat,
    &qq_vars$var_append,
    &qq_vars$var_min,
    &qq_vars$var_max,
    &qq_vars$var_concatto,
    &qq_vars$var_appendto,
    &qq_vars$var_getix,
    &qq_vars$var_putix,
    &qq_vars$var_getixref,
    &qq_vars$var_getslice,
    &qq_vars$var_putslice,
    &qq_vars$var_getdotix,
    &qq_vars$var_putdotix,
    &qq_vars$var_getdotixref,
    &qq_vars$var_getdotslice,
    &qq_vars$var_putdotslice,
    &qq_vars$var_getdotsliceref,
    &qq_vars$var_expand,
    &qq_vars$var_inplace,
    &qq_vars$var_inplace_unary,
    &qq_vars$var_loadptr,
    &qq_vars$var_storeptr,
    &qq_vars$var_loadbit,
    &qq_vars$var_storebit,
    &qq_vars$var_convert,
    &qq_vars$var_gethashvalue,
    &qq_vars$var_objtovar,
    &qq_vars$var_putdotix_intint,
    &qq_vars$var_power,
    &qq_vars$var_powermixed,
    &qq_vars$start,
    &msysc$m_init,
    &msysc$m_getdotindex,
    &msysc$m_setdotindex,
    &msysc$m_getdotslice,
    &msysc$m_setdotslice,
    &msysc$m_get_nprocs,
    &msysc$m_get_nexports,
    &msysc$m_get_procname,
    &msysc$m_get_procaddr,
    &msysc$m_get_procexport,
    &msysc$pushio,
    &msysc$m_print_startfile,
    &msysc$m_print_startstr,
    &msysc$m_print_startptr,
    &msysc$m_print_startcon,
    &msysc$m_print_setfmt,
    &msysc$m_print_end,
    &msysc$m_print_ptr,
    &msysc$m_print_i64,
    &msysc$m_print_u64,
    &msysc$m_print_r64,
    &msysc$m_print_r32,
    &msysc$m_print_c8,
    &msysc$m_print_str,
    &msysc$m_print_newline,
    &msysc$m_print_nogap,
    &msysc$m_print_space,
    &msysc$printstr,
    &msysc$printstr_n,
    &msysc$printstrn_app,
    &msysc$makezstring,
    &msysc$freezstring,
    &msysc$printchar,
    &msysc$nextfmtchars,
    &msysc$strtofmt,
    &msysc$domultichar,
    &msysc$expandstr,
    &msysc$u64tostr,
    &msysc$i64tostrfmt,
    &msysc$u64tostrfmt,
    &msysc$i64mintostr,
    &msysc$strtostrfmt,
    &msysc$tostr_i64,
    &msysc$tostr_u64,
    &msysc$tostr_r64,
    &msysc$tostr_str,
    &msysc$getfmt,
    &msysc$strint,
    &msysc$getstrint,
    &msysc$strword,
    &msysc$strreal,
    &msysc$getstr,
    &msysc$initreadbuffer,
    &msysc$m_read_conline,
    &msysc$m_read_fileline,
    &msysc$m_read_strline,
    &msysc$readitem,
    &msysc$strtoint,
    &msysc$m_read_i64,
    &msysc$m_read_r64,
    &msysc$m_read_str,
    &msysc$readstr,
    &msysc$rereadln,
    &msysc$reread,
    &msysc$valint,
    &msysc$valreal,
    &msysc$iconvlcn,
    &msysc$iconvucn,
    &msysc$convlcstring,
    &msysc$convucstring,
    &msysc$m_power_i64,
    &msysc$m_intoverflow,
    &msysc$m_dotindex,
    &msysc$m_dotslice,
    &msysc$m_popdotindex,
    &msysc$m_popdotslice,
    &msysc$m_imin,
    &msysc$m_imax,
    &msysc$m_sign,
    &msysc$m_tp_i64tor64,
    &msysc$m_tp_r64toi64,
    &msysc$m_tp_reftoi64,
    &msysc$m_tp_i64toref,
    &msysc$start,
    &mlib$pcm_alloc,
    &mlib$pcm_free,
    &mlib$pcm_freeac,
    &mlib$pcm_clearmem,
    &mlib$pcm_init,
    &mlib$pcm_getac,
    &mlib$pcm_newblock,
    &mlib$pcm_round,
    &mlib$pcm_allocz,
    &mlib$pcm_copyheapstring,
    &mlib$pcm_copyheapstringn,
    &mlib$pcm_copyheapblock,
    &mlib$allocmem,
    &mlib$reallocmem,
    &mlib$abortprogram,
    &mlib$getfilesize,
    &mlib$readrandom,
    &mlib$writerandom,
    &mlib$setfilepos,
    &mlib$getfilepos,
    &mlib$readfile,
    &mlib$writefile,
    &mlib$checkfile,
    &mlib$readlinen,
    &mlib$iconvlcn,
    &mlib$iconvucn,
    &mlib$convlcstring,
    &mlib$convucstring,
    &mlib$changeext,
    &mlib$extractext,
    &mlib$extractpath,
    &mlib$extractfile,
    &mlib$extractbasefile,
    &mlib$addext,
    &mlib$pcm_alloc32,
    &mlib$pcm_free32,
    &mlib$outbyte,
    &mlib$outword16,
    &mlib$outword32,
    &mlib$outword64,
    &mlib$outstring,
    &mlib$outblock,
    &mlib$myeof,
    &mlib$strbuffer_add,
    &mlib$gs_init,
    &mlib$gs_free,
    &mlib$gs_str,
    &mlib$gs_char,
    &mlib$gs_strn,
    &mlib$gs_strvar,
    &mlib$gs_strint,
    &mlib$gs_strln,
    &mlib$gs_strsp,
    &mlib$gs_line,
    &mlib$gs_getcol,
    &mlib$gs_leftstr,
    &mlib$gs_leftint,
    &mlib$gs_padto,
    &mlib$gs_println,
    &mlib$nextcmdparamnew,
    &mlib$readnextfileitem,
    &mlib$ipadstr,
    &mlib$padstr,
    &mlib$chr,
    &mlib$cmpstring,
    &mlib$cmpstringn,
    &mlib$eqstring,
    &mlib$cmpbytes,
    &mlib$eqbytes,
    &mlib$mseed,
    &mlib$mrandom,
    &mlib$mrandomp,
    &mlib$mrandomint,
    &mlib$mrandomrange,
    &mlib$mrandomreal,
    &mlib$mrandomreal1,
    &mlib$readline,
    &mlib$findfunction,
    &mlib$roundtoblock,
    &mlib$pcm_allocnfz,
    &mlib$start,
    &mclib$start,
    &mlinux$os_init,
    &mlinux$os_execwait,
    &mlinux$os_execcmd,
    &mlinux$os_getch,
    &mlinux$os_kbhit,
    &mlinux$os_flushkeys,
    &mlinux$os_getconsolein,
    &mlinux$os_getconsoleout,
    &mlinux$os_proginstance,
    &mlinux$os_getdllinst,
    &mlinux$os_getdllprocaddr,
    &mlinux$os_initwindows,
    &mlinux$os_getchx,
    &mlinux$os_getos,
    &mlinux$os_gethostsize,
    &mlinux$os_iswindows,
    &mlinux$os_shellexec,
    &mlinux$os_sleep,
    &mlinux$os_getstdin,
    &mlinux$os_getstdout,
    &mlinux$os_gethostname,
    &mlinux$os_getmpath,
    &mlinux$os_exitprocess,
    &mlinux$os_clock,
    &mlinux$os_ticks,
    &mlinux$os_getclockspersec,
    &mlinux$os_setmesshandler,
    &mlinux$os_hpcounter,
    &mlinux$os_hpfrequency,
    &mlinux$os_filelastwritetime,
    &mlinux$os_getsystime,
    &mlinux$os_peek,
    &mlinux$os_allocexecmem,
    &mlinux$dirlist,
    &mlinux$start,
    &mwindllc$os_calldllfunction,
    &mwindllc$os_pushargs,
    &mwindllc$calldll_cint,
    &mwindllc$calldll_creal,
    &mwindllc$os_dummycall,
    &mwindllc$start,
0};
static u8 *  msysc$_fnnames[]= {
    (byte*)"main",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"start",
    (byte*)"compile_sp",
    (byte*)"setcli",
    (byte*)"fixup_sp",
    (byte*)"writeqafile",
    (byte*)"initdata",
    (byte*)"fixproc",
    (byte*)"fixupmodule",
    (byte*)"runqprogram",
    (byte*)"disploop",
    (byte*)"disploop_fn",
    (byte*)"disploop_deb",
    (byte*)"setcmdmap",
    (byte*)"runproc_m",
    (byte*)"runproc",
    (byte*)"resetcompiler",
    (byte*)"loadsyslib",
    (byte*)"start",
    (byte*)"var_empty_array",
    (byte*)"obj_free_array",
    (byte*)"obj_free_vector",
    (byte*)"var_make_array",
    (byte*)"obj_newarray",
    (byte*)"obj_newarray_u",
    (byte*)"var_getix_array",
    (byte*)"var_putix_array",
    (byte*)"var_getixref_array",
    (byte*)"obj_append_array",
    (byte*)"var_appendto_array",
    (byte*)"obj_resize_array",
    (byte*)"var_dupl_array",
    (byte*)"var_dupl_vector",
    (byte*)"var_equal_array",
    (byte*)"var_concatto_array",
    (byte*)"var_getslice_array",
    (byte*)"u8inarray",
    (byte*)"u16inarray",
    (byte*)"u32inarray",
    (byte*)"u64inarray",
    (byte*)"var_inx_array",
    (byte*)"var_expand_array",
    (byte*)"start",
    (byte*)"obj_free_bits",
    (byte*)"var_make_bits",
    (byte*)"obj_newbits",
    (byte*)"var_getix_bits",
    (byte*)"var_putix_bits",
    (byte*)"var_getixref_bits",
    (byte*)"getindexoffset",
    (byte*)"obj_append_bits",
    (byte*)"var_appendto_bits",
    (byte*)"obj_resize_bits",
    (byte*)"var_dupl_bits",
    (byte*)"var_equal_bits",
    (byte*)"var_concatto_bits",
    (byte*)"var_getslice_bits",
    (byte*)"bits_bytesize",
    (byte*)"getbitssize",
    (byte*)"start",
    (byte*)"calldll",
    (byte*)"getlibprocaddr",
    (byte*)"vartopacked",
    (byte*)"packedtovar",
    (byte*)"loaddllfunction",
    (byte*)"start",
    (byte*)"obj_free_dec",
    (byte*)"var_dupl_dec",
    (byte*)"var_empty_dec",
    (byte*)"var_make_dec_str",
    (byte*)"var_make_dec_int",
    (byte*)"badnumber",
    (byte*)"bn_makestr",
    (byte*)"readexpon",
    (byte*)"bn_makeint",
    (byte*)"var_tostr_dec",
    (byte*)"obj_tostr_dec",
    (byte*)"tostring_scient",
    (byte*)"tostring_float",
    (byte*)"strvaln",
    (byte*)"bn_isint",
    (byte*)"obj_len_dec",
    (byte*)"bn_iszero",
    (byte*)"var_equal_dec",
    (byte*)"var_add_dec",
    (byte*)"var_sub_dec",
    (byte*)"var_mul_dec",
    (byte*)"var_div_dec",
    (byte*)"var_idiv_dec",
    (byte*)"var_irem_dec",
    (byte*)"var_neg_dec",
    (byte*)"var_abs_dec",
    (byte*)"var_compare_dec",
    (byte*)"bn_cmp",
    (byte*)"bn_equal",
    (byte*)"bn_add",
    (byte*)"bn_sub",
    (byte*)"bn_addu",
    (byte*)"bn_subu",
    (byte*)"makebignum",
    (byte*)"makesmallnum",
    (byte*)"smalltobig",
    (byte*)"freesmall",
    (byte*)"bn_init",
    (byte*)"bn_setzero",
    (byte*)"bn_move",
    (byte*)"bn_dupl",
    (byte*)"bn_setinf",
    (byte*)"bn_setnan",
    (byte*)"var_setnan",
    (byte*)"var_setinf",
    (byte*)"getbintype",
    (byte*)"bn_negto",
    (byte*)"bn_absto",
    (byte*)"bn_mul",
    (byte*)"bn_mulp",
    (byte*)"bn_mulu",
    (byte*)"smallmulto",
    (byte*)"bn_div",
    (byte*)"bn_idiv",
    (byte*)"bn_idivrem",
    (byte*)"bn_irem",
    (byte*)"bn_idivu",
    (byte*)"bn_fdivu",
    (byte*)"smalldiv",
    (byte*)"smallsubto",
    (byte*)"bn_getprec",
    (byte*)"bn_setprec",
    (byte*)"bn_getglobalprec",
    (byte*)"bn_setglobalprec",
    (byte*)"bn_makefloat",
    (byte*)"dectemp",
    (byte*)"freedectemp",
    (byte*)"bn_ipower",
    (byte*)"var_power_dec",
    (byte*)"var_convert_dec_int",
    (byte*)"bn_toint",
    (byte*)"start",
    (byte*)"start",
    (byte*)"var_make_dict",
    (byte*)"obj_new_dict",
    (byte*)"obj_free_dict",
    (byte*)"var_dupl_dict",
    (byte*)"var_equal_dict",
    (byte*)"var_finddictitem",
    (byte*)"expanddict",
    (byte*)"adddictitem",
    (byte*)"start",
    (byte*)"asmavailable",
    (byte*)"disploop_asm",
    (byte*)"initjhandlers",
    (byte*)"start",
    (byte*)"kunimpl",
    (byte*)"k_pushci",
    (byte*)"k_pushnil",
    (byte*)"k_pushcs",
    (byte*)"k_pushcr",
    (byte*)"k_stop",
    (byte*)"k_stoprunproc",
    (byte*)"k_pushm",
    (byte*)"k_pushf",
    (byte*)"k_pushff",
    (byte*)"k_pushmref",
    (byte*)"k_pushfref",
    (byte*)"k_popm",
    (byte*)"k_storem",
    (byte*)"k_zpopm",
    (byte*)"k_popf",
    (byte*)"k_storef",
    (byte*)"k_zpopf",
    (byte*)"k_popretval",
    (byte*)"k_tom",
    (byte*)"k_tof",
    (byte*)"k_add",
    (byte*)"k_sub",
    (byte*)"k_mul",
    (byte*)"k_div",
    (byte*)"k_idiv",
    (byte*)"k_irem",
    (byte*)"k_iand",
    (byte*)"k_ior",
    (byte*)"k_ixor",
    (byte*)"k_shl",
    (byte*)"k_shr",
    (byte*)"k_sqr",
    (byte*)"k_sign",
    (byte*)"k_sqrt",
    (byte*)"k_sin",
    (byte*)"k_cos",
    (byte*)"k_tan",
    (byte*)"k_asin",
    (byte*)"k_acos",
    (byte*)"k_atan",
    (byte*)"k_log",
    (byte*)"k_log10",
    (byte*)"k_exp",
    (byte*)"k_round",
    (byte*)"k_floor",
    (byte*)"k_ceil",
    (byte*)"k_fract",
    (byte*)"k_neg",
    (byte*)"k_negto",
    (byte*)"k_absto",
    (byte*)"k_inotto",
    (byte*)"k_atan2",
    (byte*)"k_fmod",
    (byte*)"k_abs",
    (byte*)"k_inot",
    (byte*)"k_istruel",
    (byte*)"k_notl",
    (byte*)"k_jumpeq",
    (byte*)"k_jumpne",
    (byte*)"k_jumplt",
    (byte*)"k_jumple",
    (byte*)"k_jumpge",
    (byte*)"k_jumpgt",
    (byte*)"k_jumpfalse",
    (byte*)"k_jumptrue",
    (byte*)"k_incrtom",
    (byte*)"k_incrtof",
    (byte*)"k_decrtom",
    (byte*)"k_decrtof",
    (byte*)"k_incrload",
    (byte*)"k_loadincr",
    (byte*)"k_decrload",
    (byte*)"k_loaddecr",
    (byte*)"k_incrptr",
    (byte*)"k_decrptr",
    (byte*)"k_pushvoid",
    (byte*)"k_callproc",
    (byte*)"k_callptr",
    (byte*)"k_procentry",
    (byte*)"k_return",
    (byte*)"k_return0",
    (byte*)"k_unshare",
    (byte*)"k_unshare1",
    (byte*)"k_formci",
    (byte*)"k_forfci",
    (byte*)"k_fordmci",
    (byte*)"k_fordfci",
    (byte*)"k_formm",
    (byte*)"k_fordmm",
    (byte*)"k_forff",
    (byte*)"k_fordff",
    (byte*)"k_comment",
    (byte*)"k_makelist",
    (byte*)"k_makedict",
    (byte*)"k_makeset",
    (byte*)"k_makerecord",
    (byte*)"k_makestruct",
    (byte*)"k_makearray",
    (byte*)"k_makebits",
    (byte*)"k_index",
    (byte*)"k_popindex",
    (byte*)"k_indexref",
    (byte*)"k_keyindex",
    (byte*)"k_popkeyindex",
    (byte*)"k_keyindexref",
    (byte*)"k_dot",
    (byte*)"k_dotref",
    (byte*)"k_popdot",
    (byte*)"k_dotindex",
    (byte*)"k_dotindexref",
    (byte*)"k_popdotindex",
    (byte*)"k_len",
    (byte*)"k_upb",
    (byte*)"k_lwb",
    (byte*)"k_bounds",
    (byte*)"k_boundsx",
    (byte*)"do_bounds",
    (byte*)"k_dictitems",
    (byte*)"k_isfound",
    (byte*)"k_append",
    (byte*)"k_concat",
    (byte*)"k_appendto",
    (byte*)"k_concatto",
    (byte*)"k_addto",
    (byte*)"k_subto",
    (byte*)"k_multo",
    (byte*)"k_divto",
    (byte*)"k_idivto",
    (byte*)"k_iandto",
    (byte*)"k_iorto",
    (byte*)"k_ixorto",
    (byte*)"k_shlto",
    (byte*)"k_shrto",
    (byte*)"k_copy",
    (byte*)"k_dupl",
    (byte*)"k_makerange",
    (byte*)"k_makerangelen",
    (byte*)"k_makedecimal",
    (byte*)"k_makeclosure",
    (byte*)"resolvefield",
    (byte*)"k_pushptr",
    (byte*)"k_popptr",
    (byte*)"k_islist",
    (byte*)"k_isarray",
    (byte*)"k_isstring",
    (byte*)"k_isrecord",
    (byte*)"k_swap",
    (byte*)"k_jumptesteq",
    (byte*)"k_jumptestne",
    (byte*)"k_jump",
    (byte*)"k_jumpptr",
    (byte*)"k_incr",
    (byte*)"k_decr",
    (byte*)"k_chr",
    (byte*)"k_asc",
    (byte*)"k_pusht",
    (byte*)"k_type",
    (byte*)"k_basetype",
    (byte*)"k_usertype",
    (byte*)"k_elemtype",
    (byte*)"k_nop",
    (byte*)"k_modulecall",
    (byte*)"k_modulereturn",
    (byte*)"k_maxvalue",
    (byte*)"k_minvalue",
    (byte*)"k_callhost",
    (byte*)"k_expand",
    (byte*)"k_pushsymbol",
    (byte*)"k_eq",
    (byte*)"k_ne",
    (byte*)"k_lt",
    (byte*)"k_le",
    (byte*)"k_ge",
    (byte*)"k_gt",
    (byte*)"do_cmp",
    (byte*)"k_calldll",
    (byte*)"k_in",
    (byte*)"k_notin",
    (byte*)"k_inx",
    (byte*)"k_convrefpack",
    (byte*)"k_isdef",
    (byte*)"k_isvoid",
    (byte*)"k_isint",
    (byte*)"k_isnumber",
    (byte*)"k_ismutable",
    (byte*)"k_isreal",
    (byte*)"k_isrange",
    (byte*)"k_isset",
    (byte*)"k_ispointer",
    (byte*)"istype",
    (byte*)"k_convert",
    (byte*)"k_switch",
    (byte*)"k_bytesize",
    (byte*)"k_bitwidth",
    (byte*)"k_min",
    (byte*)"k_max",
    (byte*)"k_addsp",
    (byte*)"k_pushtry",
    (byte*)"k_raise",
    (byte*)"k_isequal",
    (byte*)"k_minto",
    (byte*)"k_maxto",
    (byte*)"k_power",
    (byte*)"domaths",
    (byte*)"getmaths",
    (byte*)"k_typepun",
    (byte*)"k_andlto",
    (byte*)"k_orlto",
    (byte*)"k_notlto",
    (byte*)"k_pushoperator",
    (byte*)"k_maps",
    (byte*)"k_mapss",
    (byte*)"k_idivrem",
    (byte*)"k_odd",
    (byte*)"k_even",
    (byte*)"start",
    (byte*)"callhostfunction",
    (byte*)"pch_leftstr",
    (byte*)"pch_rightstr",
    (byte*)"pch_convlc",
    (byte*)"pch_convuc",
    (byte*)"pch_waitkey",
    (byte*)"pch_execwait",
    (byte*)"pch_execcmd",
    (byte*)"pch_makestr",
    (byte*)"pch_makeref",
    (byte*)"pch_getcmdparam",
    (byte*)"pch_clock",
    (byte*)"pch_allocexec",
    (byte*)"pch_runnative",
    (byte*)"pch_setlwb",
    (byte*)"pch_ticks",
    (byte*)"pch_sleep",
    (byte*)"pch_random",
    (byte*)"pch_system",
    (byte*)"pch_$getparam",
    (byte*)"checkparam",
    (byte*)"leftstring",
    (byte*)"rightstring",
    (byte*)"padstring_right",
    (byte*)"padstring_left",
    (byte*)"getbounds",
    (byte*)"pch_new",
    (byte*)"pch_gethostname",
    (byte*)"pch_getprogname",
    (byte*)"pch_$test",
    (byte*)"pch_$test2",
    (byte*)"pch_$refcount",
    (byte*)"pch_testkey",
    (byte*)"pch_getos",
    (byte*)"pch_setmesshandler",
    (byte*)"pch_$smallmemtotal",
    (byte*)"pch_$id",
    (byte*)"pch_iswindows",
    (byte*)"pch_$setdebug",
    (byte*)"pch_copy",
    (byte*)"pch_gethash",
    (byte*)"pch_makeempty",
    (byte*)"pch_$infinity",
    (byte*)"pch_$nan",
    (byte*)"setcmdparam",
    (byte*)"pch_$nprocs",
    (byte*)"initprocrefs",
    (byte*)"pch_$procname",
    (byte*)"pch_$procref",
    (byte*)"start",
    (byte*)"lexreadtoken",
    (byte*)"lxreadstring",
    (byte*)"lexinit",
    (byte*)"readrawstring",
    (byte*)"lookup",
    (byte*)"gethashvaluez",
    (byte*)"start",
    (byte*)"inithashtable",
    (byte*)"addstname",
    (byte*)"startlex",
    (byte*)"addnamestr",
    (byte*)"ps",
    (byte*)"psnext",
    (byte*)"lex",
    (byte*)"lxerror_s",
    (byte*)"makedecimal",
    (byte*)"readdec",
    (byte*)"readhex",
    (byte*)"readbin",
    (byte*)"readreal",
    (byte*)"readrawxname",
    (byte*)"reportcterror",
    (byte*)"geterrorinfo",
    (byte*)"setlineno",
    (byte*)"showerrorsource",
    (byte*)"stopcompiler",
    (byte*)"gerror",
    (byte*)"gerror_s",
    (byte*)"serror",
    (byte*)"serror_s",
    (byte*)"rxerror",
    (byte*)"rxerror_s",
    (byte*)"lxerror",
    (byte*)"pcnotmut",
    (byte*)"pcerror",
    (byte*)"pcerror_s",
    (byte*)"reportpcerror",
    (byte*)"getpcerrorpos",
    (byte*)"loaderror",
    (byte*)"findmodulefrompc",
    (byte*)"prterror",
    (byte*)"pcustype",
    (byte*)"pcustype_t",
    (byte*)"pcmxtypes",
    (byte*)"pcmxtypestt",
    (byte*)"allocunitrec",
    (byte*)"createintunit",
    (byte*)"createrealunit",
    (byte*)"createstringunit",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createname",
    (byte*)"addlistunit",
    (byte*)"createavname",
    (byte*)"convtostringz",
    (byte*)"findprocname",
    (byte*)"strexpr",
    (byte*)"strexpr_s",
    (byte*)"jeval",
    (byte*)"jevallist",
    (byte*)"additem",
    (byte*)"isalphanum",
    (byte*)"getopcname",
    (byte*)"convertstring",
    (byte*)"createavnamex",
    (byte*)"storemode",
    (byte*)"nextpoweroftwo",
    (byte*)"raiseexception",
    (byte*)"raise_error",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"setelemblock",
    (byte*)"ispoweroftwo",
    (byte*)"deleteunit",
    (byte*)"skipsemi",
    (byte*)"checksymbol",
    (byte*)"skipsymbol",
    (byte*)"start",
    (byte*)"start",
    (byte*)"var_empty_list",
    (byte*)"var_make_list",
    (byte*)"obj_newlist",
    (byte*)"obj_free_list",
    (byte*)"var_getix_list",
    (byte*)"var_getslice_list",
    (byte*)"var_getixref_list",
    (byte*)"var_putix_list",
    (byte*)"var_putslice_list",
    (byte*)"obj_append_list",
    (byte*)"obj_resize_list",
    (byte*)"var_appendto_list",
    (byte*)"var_dupl_list",
    (byte*)"var_mul_list",
    (byte*)"var_equal_list",
    (byte*)"var_concatto_list",
    (byte*)"var_inx_list",
    (byte*)"loadsp",
    (byte*)"getmodulefilename",
    (byte*)"loadsourcefile",
    (byte*)"loadstring",
    (byte*)"readfileline",
    (byte*)"findnextlineheader",
    (byte*)"loadqafile",
    (byte*)"readqabundle",
    (byte*)"start",
    (byte*)"addglobalname",
    (byte*)"newstrec",
    (byte*)"addsymbol",
    (byte*)"addproc",
    (byte*)"newusertypex",
    (byte*)"resolvedottedname",
    (byte*)"addgenfield",
    (byte*)"makereftype",
    (byte*)"makeaxtype",
    (byte*)"makeslicetype",
    (byte*)"makestrtype",
    (byte*)"addanontype",
    (byte*)"createusertype",
    (byte*)"getalignment",
    (byte*)"duplfield",
    (byte*)"writesig",
    (byte*)"createdupldef",
    (byte*)"start",
    (byte*)"optimise_module",
    (byte*)"start",
    (byte*)"var_loadpacked",
    (byte*)"var_storepacked",
    (byte*)"setfslength",
    (byte*)"getfslength",
    (byte*)"var_make_struct",
    (byte*)"obj_new_struct",
    (byte*)"var_dupl_struct",
    (byte*)"obj_free_struct",
    (byte*)"var_equal_struct",
    (byte*)"var_getix_struct",
    (byte*)"start",
    (byte*)"parsemodule",
    (byte*)"readexpression",
    (byte*)"readassignment",
    (byte*)"readorterms",
    (byte*)"readandterms",
    (byte*)"readcmpterms",
    (byte*)"readinterms",
    (byte*)"readrangeterm",
    (byte*)"readaddterms",
    (byte*)"readmulterms",
    (byte*)"readpowerterms",
    (byte*)"readterm2",
    (byte*)"readtermsuffix",
    (byte*)"readterm",
    (byte*)"readsunit",
    (byte*)"checkequals",
    (byte*)"readindex",
    (byte*)"readdotsuffix",
    (byte*)"readslist",
    (byte*)"readcondsuffix",
    (byte*)"readkeyindex",
    (byte*)"readlbrack",
    (byte*)"readif",
    (byte*)"checkend",
    (byte*)"readunless",
    (byte*)"readwhile",
    (byte*)"readrepeat",
    (byte*)"readfor",
    (byte*)"readdo",
    (byte*)"readto",
    (byte*)"makeblock",
    (byte*)"readvardef",
    (byte*)"readconstdef",
    (byte*)"readreturn",
    (byte*)"readprint",
    (byte*)"readread",
    (byte*)"readloopcontrol",
    (byte*)"readintunit",
    (byte*)"readswitchcase",
    (byte*)"readgoto",
    (byte*)"readstop",
    (byte*)"readcast",
    (byte*)"readset",
    (byte*)"readtabledef",
    (byte*)"readtry",
    (byte*)"readsprint",
    (byte*)"readsread",
    (byte*)"readimportdll",
    (byte*)"readffiparams",
    (byte*)"readtypeparams",
    (byte*)"readtypenameparams",
    (byte*)"readrecorddef",
    (byte*)"readrecordbody",
    (byte*)"readrecordfields",
    (byte*)"readstructbody",
    (byte*)"addstructflag",
    (byte*)"readprocdef",
    (byte*)"readatfield",
    (byte*)"istypestarter",
    (byte*)"readmacrodef",
    (byte*)"readhostparams",
    (byte*)"pushlisttype",
    (byte*)"poplisttype",
    (byte*)"readcompilervar",
    (byte*)"readpair",
    (byte*)"lexchecksymbol",
    (byte*)"readtypedef",
    (byte*)"readtypespec",
    (byte*)"readparams",
    (byte*)"checkoperator",
    (byte*)"readlambda",
    (byte*)"readpackvars",
    (byte*)"start",
    (byte*)"pch_print",
    (byte*)"pch_print_nf",
    (byte*)"pch_printnogap",
    (byte*)"pch_println",
    (byte*)"pch_reread",
    (byte*)"pch_rereadln",
    (byte*)"pch_startprint",
    (byte*)"pch_startprintcon",
    (byte*)"pch_endprint",
    (byte*)"pch_strstartprint",
    (byte*)"pch_strendprint",
    (byte*)"pch_printspace",
    (byte*)"pch_readln",
    (byte*)"pch_sread",
    (byte*)"pch_sreadln",
    (byte*)"readname",
    (byte*)"readstring",
    (byte*)"readint",
    (byte*)"readhex",
    (byte*)"readbin",
    (byte*)"readreal",
    (byte*)"getreadfmtcode",
    (byte*)"stepkbpos",
    (byte*)"readany",
    (byte*)"readitem",
    (byte*)"strtoreal",
    (byte*)"strtoint",
    (byte*)"printnextfmtchars",
    (byte*)"pch_setformat",
    (byte*)"pc_getfmt",
    (byte*)"addstring",
    (byte*)"domultichar",
    (byte*)"printstr_n",
    (byte*)"pch_strtoval",
    (byte*)"tostr_int",
    (byte*)"tostr_real",
    (byte*)"tostr_str",
    (byte*)"pch_tostr",
    (byte*)"tostr_range",
    (byte*)"tostr_array",
    (byte*)"tostr_bits",
    (byte*)"tostr_struct",
    (byte*)"tostr_set",
    (byte*)"tostr_dict",
    (byte*)"tostr_decimal",
    (byte*)"tostr",
    (byte*)"tostr_list",
    (byte*)"start",
    (byte*)"evalunit",
    (byte*)"gencodemodule",
    (byte*)"do_procdef",
    (byte*)"genprocentry",
    (byte*)"genprocexit",
    (byte*)"evalref",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"genjumpl",
    (byte*)"reversecond",
    (byte*)"stacklooplabels",
    (byte*)"unstacklooplabels",
    (byte*)"findlooplabel",
    (byte*)"do_assign",
    (byte*)"do_bin",
    (byte*)"do_binref",
    (byte*)"do_unary",
    (byte*)"do_unaryref",
    (byte*)"do_pushlist",
    (byte*)"do_makedict",
    (byte*)"do_call",
    (byte*)"pushparams",
    (byte*)"evalparam",
    (byte*)"pushkwdparams",
    (byte*)"do_if",
    (byte*)"do_do",
    (byte*)"do_exit",
    (byte*)"do_to",
    (byte*)"do_while",
    (byte*)"do_repeat",
    (byte*)"do_for",
    (byte*)"do_forx",
    (byte*)"do_print",
    (byte*)"do_fprint",
    (byte*)"do_read",
    (byte*)"do_forall",
    (byte*)"do_case",
    (byte*)"do_case_nc",
    (byte*)"do_try",
    (byte*)"unitstoarray",
    (byte*)"do_select",
    (byte*)"do_andl",
    (byte*)"do_orl",
    (byte*)"do_incr",
    (byte*)"do_new",
    (byte*)"checkblockreturn",
    (byte*)"do_callhost",
    (byte*)"callhostfn",
    (byte*)"genfree",
    (byte*)"do_return",
    (byte*)"do_multassign",
    (byte*)"do_store",
    (byte*)"getconstvalue",
    (byte*)"do_convert",
    (byte*)"checkelems",
    (byte*)"do_switch",
    (byte*)"do_simpleswitch",
    (byte*)"do_makerecordkv",
    (byte*)"do_idiv",
    (byte*)"do_irem",
    (byte*)"do_map",
    (byte*)"pushstring",
    (byte*)"start",
    (byte*)"start",
    (byte*)"resetpcl",
    (byte*)"genpc",
    (byte*)"genopnd_int",
    (byte*)"genopnd_name",
    (byte*)"genpc_int",
    (byte*)"genpc_int2",
    (byte*)"genpc_int4",
    (byte*)"genpc_name",
    (byte*)"genopnd_strz",
    (byte*)"genopnd_str",
    (byte*)"genopnd_obj",
    (byte*)"genpc_real",
    (byte*)"genpc_lab",
    (byte*)"genopnd_lab",
    (byte*)"gencomment",
    (byte*)"extendpcldata",
    (byte*)"extendlabeltable",
    (byte*)"definelabel",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"var_make_record",
    (byte*)"obj_new_record",
    (byte*)"obj_free_record",
    (byte*)"var_dupl_record",
    (byte*)"var_equal_record",
    (byte*)"var_getix_record",
    (byte*)"var_putix_record",
    (byte*)"var_getixref_record",
    (byte*)"start",
    (byte*)"rx_module",
    (byte*)"rx_passdef",
    (byte*)"rx_deflist",
    (byte*)"rx_unit",
    (byte*)"rx_unitlist",
    (byte*)"evalmonop",
    (byte*)"evalbinop",
    (byte*)"makeintconst",
    (byte*)"makerealconst",
    (byte*)"resolvename",
    (byte*)"resolvetopname",
    (byte*)"resolvedot",
    (byte*)"resolvedot_sym",
    (byte*)"finddupl",
    (byte*)"expandmacro",
    (byte*)"copylistunit",
    (byte*)"copyunit",
    (byte*)"replaceunit",
    (byte*)"fixmode",
    (byte*)"fixmode2",
    (byte*)"fixusertypes",
    (byte*)"tx_typetable",
    (byte*)"getconstint",
    (byte*)"converttype",
    (byte*)"scanstruct",
    (byte*)"dobaseclass",
    (byte*)"start",
    (byte*)"obj_free_set",
    (byte*)"var_dupl_set",
    (byte*)"var_equal_set",
    (byte*)"getsetbytes",
    (byte*)"var_make_set",
    (byte*)"obj_newset",
    (byte*)"var_emptyset",
    (byte*)"var_getix_set",
    (byte*)"var_putix_set",
    (byte*)"var_getixref_set",
    (byte*)"getoffset",
    (byte*)"var_in_set",
    (byte*)"iresizeset",
    (byte*)"obj_resize_set",
    (byte*)"iorsetbits",
    (byte*)"ixorsetbits",
    (byte*)"iandsetbits",
    (byte*)"inotsetbits",
    (byte*)"var_iorto_set",
    (byte*)"var_iandto_set",
    (byte*)"var_ixorto_set",
    (byte*)"var_inotto_set",
    (byte*)"start",
    (byte*)"start",
    (byte*)"var_empty_string",
    (byte*)"var_make_string",
    (byte*)"var_make_stringn",
    (byte*)"obj_new_string",
    (byte*)"obj_make_string",
    (byte*)"obj_make_stringn",
    (byte*)"obj_free_string",
    (byte*)"var_dupl_string",
    (byte*)"var_getix_string",
    (byte*)"var_getixref_string",
    (byte*)"var_getdotix_string",
    (byte*)"var_getdotixref_string",
    (byte*)"var_getslice_string",
    (byte*)"stringslice",
    (byte*)"var_putix_string",
    (byte*)"var_putslice_string",
    (byte*)"var_putdotix_string",
    (byte*)"obj_resize_string",
    (byte*)"var_add_string",
    (byte*)"var_addto_string",
    (byte*)"var_addto_string_ch",
    (byte*)"var_equal_string",
    (byte*)"var_compare_string",
    (byte*)"cmpstring_len",
    (byte*)"var_inx_string",
    (byte*)"var_iconvcase",
    (byte*)"var_makestrslicexobj",
    (byte*)"obj_make_strslicexobj",
    (byte*)"var_asc",
    (byte*)"var_new_string",
    (byte*)"var_new_stringn",
    (byte*)"var_mul_string",
    (byte*)"var_convert_string_list",
    (byte*)"var_expand_string",
    (byte*)"var_makechar",
    (byte*)"findsyslib",
    (byte*)"loadsysmodule",
    (byte*)"start",
    (byte*)"start",
    (byte*)"printunit",
    (byte*)"printunitlist",
    (byte*)"getprefix",
    (byte*)"getlineinfok",
    (byte*)"gstr",
    (byte*)"gstrln",
    (byte*)"gline",
    (byte*)"gstrint",
    (byte*)"glabeldef",
    (byte*)"printglobalsymbols",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"printtypetables",
    (byte*)"showsttree",
    (byte*)"showtypes",
    (byte*)"showpcl",
    (byte*)"showpcl2",
    (byte*)"showast",
    (byte*)"showast2",
    (byte*)"showlogfile",
    (byte*)"addtolog",
    (byte*)"showstflat",
    (byte*)"showmoduleinfo",
    (byte*)"printsymbol",
    (byte*)"strmode",
    (byte*)"istrmode",
    (byte*)"writepcl",
    (byte*)"writepclopnd",
    (byte*)"writeallpcl",
    (byte*)"deletetempfiles",
    (byte*)"start",
    (byte*)"var_unshareu",
    (byte*)"obj_shareu",
    (byte*)"void_new",
    (byte*)"obj_new",
    (byte*)"var_getintvalue",
    (byte*)"var_fromobj",
    (byte*)"var_free",
    (byte*)"var_duplu",
    (byte*)"var_neg",
    (byte*)"var_abs",
    (byte*)"var_inot",
    (byte*)"var_istruel",
    (byte*)"var_add",
    (byte*)"var_addmixed",
    (byte*)"var_addto",
    (byte*)"var_sub",
    (byte*)"var_submixed",
    (byte*)"var_mul",
    (byte*)"var_mulmixed",
    (byte*)"var_div",
    (byte*)"var_divmixed",
    (byte*)"var_idiv",
    (byte*)"var_irem",
    (byte*)"var_iand",
    (byte*)"var_ior",
    (byte*)"var_ixor",
    (byte*)"var_shl",
    (byte*)"var_shr",
    (byte*)"var_in",
    (byte*)"var_inx",
    (byte*)"var_equal",
    (byte*)"var_equalmixed",
    (byte*)"var_compare",
    (byte*)"var_comparemixed",
    (byte*)"var_concat",
    (byte*)"var_append",
    (byte*)"var_min",
    (byte*)"var_max",
    (byte*)"var_concatto",
    (byte*)"var_appendto",
    (byte*)"var_getix",
    (byte*)"var_putix",
    (byte*)"var_getixref",
    (byte*)"var_getslice",
    (byte*)"var_putslice",
    (byte*)"var_getdotix",
    (byte*)"var_putdotix",
    (byte*)"var_getdotixref",
    (byte*)"var_getdotslice",
    (byte*)"var_putdotslice",
    (byte*)"var_getdotsliceref",
    (byte*)"var_expand",
    (byte*)"var_inplace",
    (byte*)"var_inplace_unary",
    (byte*)"var_loadptr",
    (byte*)"var_storeptr",
    (byte*)"var_loadbit",
    (byte*)"var_storebit",
    (byte*)"var_convert",
    (byte*)"var_gethashvalue",
    (byte*)"var_objtovar",
    (byte*)"var_putdotix_intint",
    (byte*)"var_power",
    (byte*)"var_powermixed",
    (byte*)"start",
    (byte*)"m_init",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_get_nprocs",
    (byte*)"m_get_nexports",
    (byte*)"m_get_procname",
    (byte*)"m_get_procaddr",
    (byte*)"m_get_procexport",
    (byte*)"pushio",
    (byte*)"m_print_startfile",
    (byte*)"m_print_startstr",
    (byte*)"m_print_startptr",
    (byte*)"m_print_startcon",
    (byte*)"m_print_setfmt",
    (byte*)"m_print_end",
    (byte*)"m_print_ptr",
    (byte*)"m_print_i64",
    (byte*)"m_print_u64",
    (byte*)"m_print_r64",
    (byte*)"m_print_r32",
    (byte*)"m_print_c8",
    (byte*)"m_print_str",
    (byte*)"m_print_newline",
    (byte*)"m_print_nogap",
    (byte*)"m_print_space",
    (byte*)"printstr",
    (byte*)"printstr_n",
    (byte*)"printstrn_app",
    (byte*)"makezstring",
    (byte*)"freezstring",
    (byte*)"printchar",
    (byte*)"nextfmtchars",
    (byte*)"strtofmt",
    (byte*)"domultichar",
    (byte*)"expandstr",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"i64mintostr",
    (byte*)"strtostrfmt",
    (byte*)"tostr_i64",
    (byte*)"tostr_u64",
    (byte*)"tostr_r64",
    (byte*)"tostr_str",
    (byte*)"getfmt",
    (byte*)"strint",
    (byte*)"getstrint",
    (byte*)"strword",
    (byte*)"strreal",
    (byte*)"getstr",
    (byte*)"initreadbuffer",
    (byte*)"m_read_conline",
    (byte*)"m_read_fileline",
    (byte*)"m_read_strline",
    (byte*)"readitem",
    (byte*)"strtoint",
    (byte*)"m_read_i64",
    (byte*)"m_read_r64",
    (byte*)"m_read_str",
    (byte*)"readstr",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"valint",
    (byte*)"valreal",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"m_power_i64",
    (byte*)"m_intoverflow",
    (byte*)"m_dotindex",
    (byte*)"m_dotslice",
    (byte*)"m_popdotindex",
    (byte*)"m_popdotslice",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"m_sign",
    (byte*)"m_tp_i64tor64",
    (byte*)"m_tp_r64toi64",
    (byte*)"m_tp_reftoi64",
    (byte*)"m_tp_i64toref",
    (byte*)"start",
    (byte*)"pcm_alloc",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"pcm_copyheapstringn",
    (byte*)"pcm_copyheapblock",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"setfilepos",
    (byte*)"getfilepos",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword32",
    (byte*)"outword64",
    (byte*)"outstring",
    (byte*)"outblock",
    (byte*)"myeof",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparamnew",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"mseed",
    (byte*)"mrandom",
    (byte*)"mrandomp",
    (byte*)"mrandomint",
    (byte*)"mrandomrange",
    (byte*)"mrandomreal",
    (byte*)"mrandomreal1",
    (byte*)"readline",
    (byte*)"findfunction",
    (byte*)"roundtoblock",
    (byte*)"pcm_allocnfz",
    (byte*)"start",
    (byte*)"start",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_flushkeys",
    (byte*)"os_getconsolein",
    (byte*)"os_getconsoleout",
    (byte*)"os_proginstance",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_gethostsize",
    (byte*)"os_iswindows",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_getmpath",
    (byte*)"os_exitprocess",
    (byte*)"os_clock",
    (byte*)"os_ticks",
    (byte*)"os_getclockspersec",
    (byte*)"os_setmesshandler",
    (byte*)"os_hpcounter",
    (byte*)"os_hpfrequency",
    (byte*)"os_filelastwritetime",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"os_allocexecmem",
    (byte*)"dirlist",
    (byte*)"start",
    (byte*)"os_calldllfunction",
    (byte*)"os_pushargs",
    (byte*)"calldll_cint",
    (byte*)"calldll_creal",
    (byte*)"os_dummycall",
    (byte*)"start",
(byte*)""};
static i64 msysc$_fnnprocs=1165;
static i64 msysc$_fnnexports;
static i64 msysc$fmtparam;
static i64 msysc$needgap = (i64)0;
static i64 msysc$outdev = (i64)1;
static void *  msysc$outchan = 0;
static u8 *  msysc$fmtstr = 0;
static void *  msysc$outchan_stack[10];
static i64 msysc$outdev_stack[10];
static u8 *  msysc$fmtstr_stack[10];
static byte msysc$needgap_stack[10];
static u8 *  msysc$ptr_stack[10];
static i64 msysc$niostack = (i64)0;
static u8 msysc$digits[16] = {
    (u8)(i64)48,
    (u8)(i64)49,
    (u8)(i64)50,
    (u8)(i64)51,
    (u8)(i64)52,
    (u8)(i64)53,
    (u8)(i64)54,
    (u8)(i64)55,
    (u8)(i64)56,
    (u8)(i64)57,
    (u8)(i64)65,
    (u8)(i64)66,
    (u8)(i64)67,
    (u8)(i64)68,
    (u8)(i64)69,
    (u8)(i64)70
};
static struct msysc$fmtrec msysc$defaultfmt = {
    (u8)0u,
    (i8)(i64)0,
    (u8)10u,
    (u8)(i64)0,
    (u8)' ',
    (u8)'f',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)'R',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)0u
};
static u8 *  msysc$rd_buffer;
static i64 msysc$rd_length;
static u8 *  msysc$rd_pos;
static u8 *  msysc$rd_lastpos;
static i64 msysc$termchar;
static i64 msysc$itemerror;
static i64 msysc$$cmdskip;
static i64 msysc$nsysparams;
static i64 msysc$ncmdparams;
static i64 msysc$nenvstrings;
static u8 *  msysc$sysparams[128];
static u8 *(*msysc$cmdparams)[];
static u8 *(*msysc$envstrings)[];
static u64 msysc$mask63 = (u64)9223372036854775807u;
static r64 msysc$offset64 = (double)9223372036854775800.;
static r64 msysc$offset32 = (double)9223372036854775800.;
static u64 mlib$allocupper[301];
static i64 mlib$alloccode;
static i64 mlib$allocbytes;
static i64 mlib$fdebug = (i64)0;
static i64 mlib$rfsize;
static u64 mlib$maxmemory;
static i64 mlib$maxalloccode;
static void *  mlib$allocbase;
static byte mlib$pcm_setup = (byte)(i64)0;
static i64 mlib$show = (i64)0;
static i64 mlib$memtotal = (i64)0;
static i64 mlib$smallmemtotal = (i64)0;
static i64 mlib$smallmemobjs = (i64)0;
static i64 mlib$maxmemtotal = (i64)0;
static i32 *  mlib$memalloctable[3];
static i32 mlib$memallocsize[3];
static byte *  mlib$pcheapstart;
static byte *  mlib$pcheapend;
static byte *  mlib$pcheapptr;
static byte mlib$sizeindextable[2049];
static u64 *  mlib$freelist[9];
static u8 *  mlib$pmnames[6] = {(byte*)"pm_end",(byte*)"pm_option",(byte*)"pm_sourcefile",(byte*)"pm_libfile",(byte*)"pm_colon",(byte*)"pm_extra"};
static u64 mlib$seed[2] = {(u64)2993073034246558322u,(u64)1617678968452121188u};
static i64 mlinux$init_flag = (i64)0;

/* PROCDEFS */
int main(int _nargs, char** _args) {
    msysc$m_init(_nargs, (void*)_args);

// call main-start() routines...
    msysc$start();
    qq_cli$start();

        i64 stopcode;
    qq_api$initdata();
    qq_cli$getinputoptions();
    qq_modules$readqabundle();
    qq_api$loadsyslib();
    qq_api$compile_sp(qq_api$inputfile,0);
    if (!!((i64)qq_api$fallsp)) {
        if ((!!((i64)qq_api$fshowast1) && ((i64)qq_api$runcode == (i64)2))) {
            qq_show$showast(0,(byte*)"AST1");
        }
;
        if ((!!((i64)qq_api$fshowast2) && ((i64)qq_api$runcode > (i64)2))) {
            qq_show$showast(0,(byte*)"AST2");
        }
;
        if (((!!((i64)qq_api$fshowpcl1) || !!((i64)qq_api$fshowpcl2)) && ((i64)qq_api$runcode == (i64)4))) {
            qq_show$showpcl(0,(i64)1);
        }
;
        if ((!!((i64)qq_api$fshowpcl3) && ((i64)qq_api$runcode == (i64)5))) {
            qq_show$showpcl(0,(i64)3);
        }
;
    }
;
    qq_api$writeqafile();
    stopcode = qq_api$runqprogram(qq_decls$subprogs[(qq_decls$nsubprogs)-1]);
    qq_show$showlogfile();
    exit(stopcode);
    return 0;
}

static void qq_cli$getinputoptions(void) {
        i64 paramno;
        i64 pmtype;
        u8 *  name;
        u8 *  value;
        u8 *  appstr;
        u8 *(*fnaddr)(void);
        i64 sw;
    fnaddr = (u8 *(*)(void))mlib$findfunction((byte*)"getbuiltin_app");
    paramno = (i64)1;
    L1 :;
    while (!!((pmtype = mlib$nextcmdparamnew(&paramno,&name,&value,(byte*)"q")))) {
        if ((pmtype==(i64)1)) {
            mlib$convlcstring(name);
            for (sw=(i64)1;sw<=(i64)28;++sw) {
L4 :;
                if (!!(mlib$eqstring(name,qq_decls$optionnames[(sw)-1]))) {
                    qq_cli$do_option(sw,value);
                    goto L6 ;
                }
;
L5 :;
            }
            {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Unknown option:",NULL);
                msysc$m_print_str(name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)99);
            }
L6 :;
            ;
        }
        else if ((pmtype==(i64)2)) {
            if (!!(fnaddr)) {
                --(paramno);
                goto L3 ;
            }
;
            qq_api$inputfile = mlib$pcm_copyheapstring(name);
            goto L3 ;
        }
;
L2 :;
    }
L3 :;
    ;
    if (!!(fnaddr)) {
        appstr = ((*fnaddr))();
        qq_lib$loaderror((byte*)"DO BUILT-IN",(byte*)"");
    }
    else if (!(!!(qq_api$inputfile))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Q5.2 Interpreter",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Usage:",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(msysc$sysparams[((i64)1)-1],NULL);
        msysc$m_print_str((byte*)"filename[.q]",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit(0);
    }
;
    if (((i64)qq_decls$dispatchtype == (i64)4 || (i64)qq_decls$dispatchtype == (i64)5)) {
        qq_decls$hasbytecodes = (i64)1;
    }
    else {
        qq_decls$hasbytecodes = (i64)0;
    }
;
    qq_cli$cmdstartindex = paramno;
    qq_api$setcli((u8 *(*)[])&(*msysc$cmdparams)[(qq_cli$cmdstartindex)],((msysc$ncmdparams - qq_cli$cmdstartindex) + (i64)1));
}

static void qq_cli$do_option(i64 sw,u8 *value) {
        byte *  p;
    p = qq_decls$optionvars[(sw)-1];
    if (!!(p)) {
        (*p) = (i64)qq_decls$optionvalues[(sw)-1];
        return;
    }
;
    if ((sw==(i64)23)) {
        qq_api$foptimise = (i64)1;
        qq_decls$dispatchtype = (i64)6;
    }
;
}

// START
void qq_cli$start(void) {
    qq_api$start();
    qq_arrays$start();
    qq_bits$start();
    qq_calldll$start();
    qq_decimal$start();
    qq_decls$start();
    qq_dicts$start();
    qq_jhandlers_hll$start();
    qq_khandlers$start();
    qq_host$start();
    qq_lex$start();
    qq_lib$start();
    qq_lists$start();
    qq_modules$start();
    qq_names$start();
    qq_optimdummy$start();
    qq_packed$start();
    qq_parse$start();
    qq_print$start();
    qq_pclgen$start();
    qq_pcllib$start();
    qq_records$start();
    qq_resolve$start();
    qq_sets$start();
    qq_strings$start();
    qq_syslibs$start();
    qq_tables$start();
    qq_show$start();
    qq_vars$start();

}

void qq_api$compile_sp(u8 *filename,u8 *source) {
        struct qq_decls$subprogrec *  sp;
        i64 a;
        i64 b;
        i64 m;
    sp = qq_modules$loadsp(filename,source);
    if (((i64)qq_api$runcode < (i64)2)) {
        return;
    }
;
    a = (i64)(*sp).firstmodule;
    b = (i64)(*sp).lastmodule;
    for (m=a;m<=b;++m) {
L7 :;
        qq_parse$parsemodule(qq_decls$modules[(m)]);
L8 :;
    }
L9 :;
    ;
    qq_resolve$fixusertypes();
    if ((!!((i64)qq_api$fshowast1) && !(!!((i64)qq_api$fallsp)))) {
        qq_show$showast(sp,(byte*)"AST1");
    }
;
    if (((i64)qq_api$runcode < (i64)3)) {
        return;
    }
;
    qq_resolve$tx_typetable();
    for (m=a;m<=b;++m) {
L10 :;
        qq_resolve$rx_module(qq_decls$modules[(m)]);
L11 :;
    }
L12 :;
    ;
    if ((!!((i64)qq_api$fshowast2) && !(!!((i64)qq_api$fallsp)))) {
        qq_show$showast(sp,(byte*)"AST2");
    }
;
    if (((i64)qq_api$runcode < (i64)4)) {
        return;
    }
;
    for (m=a;m<=b;++m) {
L13 :;
        qq_pclgen$gencodemodule(sp,m);
L14 :;
    }
L15 :;
    ;
    if ((!!((i64)qq_api$fshowpcl1) && !(!!((i64)qq_api$fallsp)))) {
        qq_show$showpcl(sp,(i64)1);
    }
;
    if ((!!((i64)qq_api$foptimise) && ((i64)qq_decls$dispatchtype == (i64)6))) {
        for (m=a;m<=b;++m) {
L16 :;
            qq_optimdummy$optimise_module(m);
L17 :;
        }
L18 :;
        ;
        if ((!!((i64)qq_api$fshowpcl2) && !(!!((i64)qq_api$fallsp)))) {
            qq_show$showpcl(sp,(i64)2);
        }
;
    }
;
    qq_api$fixup_sp(sp);
    qq_api$resetcompiler();
}

void qq_api$setcli(u8 *(*cmds)[],i64 ncmds) {
        i64 i;
    for (i=(i64)1;i<=ncmds;++i) {
L19 :;
        qq_host$setcmdparam(i,(*cmds)[(i)-1]);
L20 :;
    }
L21 :;
    ;
}

static void qq_api$fixup_sp(struct qq_decls$subprogrec *sp) {
        i64 $av_1;
        i64 i;
    if (((i64)qq_api$runcode < (i64)5)) {
        return;
    }
;
        ($av_1 = (i64)(*sp).lastmodule);
    for (i=(i64)(*sp).firstmodule;i<=$av_1;++i) {
L22 :;
        qq_api$fixupmodule(qq_decls$modules[(i)]);
L23 :;
    }
L24 :;
    ;
}

void qq_api$writeqafile(void) {
        u8 filename[300];
        struct qq_decls$filerec *  sflist[200];
        void *  f;
        i64 offset;
        i64 nfiles;
        struct qq_decls$filerec *  pm;
        i64 leadmod;
        i64 i;
    if (!(!!((i64)qq_api$fwriteqa))) {
        return;
    }
;
    strcpy(filename,mlib$changeext(qq_api$inputfile,(byte*)"qa"));
    nfiles = (i64)0;
    leadmod = (i64)(*qq_decls$subprogs[(qq_decls$nsubprogs)-1]).firstmodule;
    sflist[(++(nfiles))-1] = qq_decls$modules[(leadmod)];
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L25 :;
        if ((i != leadmod)) {
            pm = qq_decls$modules[(i)];
            if ((!!((i64)(*pm).issyslib) && ((i64)qq_api$fwriteqa == (i64)1))) {
                goto L26 ;
            }
;
            sflist[(++(nfiles))-1] = pm;
        }
;
L26 :;
    }
L27 :;
    ;
    if ((nfiles == (i64)0)) {
        qq_lib$loaderror((byte*)"QA:no files",(byte*)"");
    }
;
    f = fopen(filename,(byte*)"wb");
    if (!(!!(f))) {
        qq_lib$loaderror((byte*)"Can't create qa file #",filename);
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Writing ",NULL);
    msysc$m_print_str(filename,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_setfmt((byte*)"=== QA # ===");
    msysc$m_print_i64(nfiles,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=nfiles;++i) {
L28 :;
        pm = sflist[(i)-1];
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"=== #.q # # #/# ===");
        msysc$m_print_str((*pm).name,NULL);
        msysc$m_print_i64((i64)(*pm).issyslib,NULL);
        msysc$m_print_i64((i64)(*pm).issupport,NULL);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_i64(nfiles,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        offset = mlib$getfilepos(f);
        mlib$writerandom(f,(byte *)(*pm).text,offset,(*pm).size);
L29 :;
    }
L30 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"=== END ===",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=nfiles;++i) {
L31 :;
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"# #.q");
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((*sflist[(i)-1]).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L32 :;
    }
L33 :;
    ;
    fclose(f);
    exit(0);
}

void qq_api$initdata(void) {
    qq_lex$lexinit();
    qq_decls$stprogram = qq_names$createdupldef(0,qq_lex$addnamestr((byte*)"$prog"),(i64)1);
    mlinux$os_initwindows();
    if (((i64)qq_decls$dispatchtype == (i64)6)) {
        qq_jhandlers_hll$initjhandlers();
    }
;
    qq_tables$firstusertype = (i64)40;
    qq_show$deletetempfiles();
}

static void qq_api$fixproc(struct qq_decls$strec *d) {
        i64 *  z;
        struct qq_decls$varrec *  p;
    if (!(!!((i64)(*d).procfixed))) {
        if ((qq_api$nprocs >= (i64)11000)) {
            qq_lib$gerror((byte*)"Too many procs",0);
        }
;
        z = ((*qq_decls$modules[((i64)(*d).moduleno)]).pcstart + (*d).labelno);
        p = (struct qq_decls$varrec *)mlib$pcm_alloc((i64)16);
        qq_api$proctable[(++(qq_api$nprocs))-1] = z;
        qq_api$procdefs[(qq_api$nprocs)-1] = d;
        (*d).pcaddress = z;
        (*d).procfixed = (i64)1;
    }
;
}

static void qq_api$fixupmodule(struct qq_decls$filerec *pm) {
        i64 *  pc;
        i64 *  pcstart;
        i64 cmd;
        i64 y;
        struct qq_decls$strec *  d;
        struct qq_decls$varrec *  p;
        struct qq_decls$stringrec *  ps;
        i64 $av_1;
        i64 i;
    pc = (pcstart = (*pm).pcstart);
    L34 :;
    do {
        cmd = (*pc);
        (*pc) = (i64)qq_tables$cmdmap[(cmd)];
        ++(pc);
        if ((cmd==(i64)3)) {
            qq_api$fixproc((struct qq_decls$strec *)(*pc));
        }
;
                ($av_1 = (i64)qq_pcllib$pclnopnds[(cmd)]);
        for (i=(i64)1;i<=$av_1;++i) {
L37 :;
                        {i64 $temp = (i64)qq_tables$pclfmt[(cmd)][(i)-1];
if (($temp==(i64)3)) {
                d = (struct qq_decls$strec *)(*pc);
                qq_api$fixproc(d);
                (*pc) = (i64)(*d).pcaddress;
            }
            else if (($temp==(i64)1)) {
                d = (struct qq_decls$strec *)(*pc);
                if (((*d).varptr == 0)) {
                    if ((qq_api$nstatics >= (i64)11000)) {
                        qq_lib$gerror((byte*)"Too many statics",0);
                    }
;
                    p = (struct qq_decls$varrec *)mlib$pcm_alloc((i64)16);
                    qq_api$statictable[(++(qq_api$nstatics))-1] = p;
                    qq_api$staticdefs[(qq_api$nstatics)-1] = d;
                    (*d).varptr = p;
                }
;
                (*pc) = (i64)(*d).varptr;
            }
            else if (($temp==(i64)2)) {
                d = (struct qq_decls$strec *)(*pc);
                (*pc) = ((i64)(*d).index * (i64)16);
            }
            else if (($temp==(i64)5)) {
                (*pc) = (*(struct qq_decls$strec *)(*pc)).genfieldindex;
            }
            else if (($temp==(i64)11)) {
                ps = (struct qq_decls$stringrec *)(*pc);
                (*pc) = (i64)qq_strings$obj_make_stringn((*ps).svalue,(*ps).length,(i64)0);
            }
            else if (($temp==(i64)6)) {
                y = (i64)(pcstart + (*pc));
                (*pc) = y;
            }
            };
            ++(pc);
L38 :;
        }
L39 :;
        ;
L35 :;
    }
    while (!(cmd == (i64)6));
L36 :;
    ;
}

i64 qq_api$runqprogram(struct qq_decls$subprogrec *sp) {
        i64 *  pcstart;
    if (((i64)qq_api$runcode < (i64)6)) {
        return (i64)0;
    }
;
    if (!!((i64)qq_decls$fverbose)) {
        msysc$m_print_startcon();
        msysc$m_print_str(qq_decls$dispatchnames[((i64)qq_decls$dispatchtype)-1],NULL);
        msysc$m_print_str((byte*)"Opt:",NULL);
        msysc$m_print_i64((i64)qq_api$foptimise,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    qq_decls$sptr = &qq_decls$varstack[((i64)1)-1];
    qq_decls$stacklimit = &qq_decls$varstack[((i64)69900)-1];
    pcstart = (qq_decls$pcptr = (*qq_decls$modules[((i64)(*sp).firstmodule)]).pcstart);
    qq_decls$pcerrorpos = (i64)0;
    qq_decls$stopped = (i64)0;
    qq_api$disploop();
    return (*qq_decls$sptr).value;
}

static void qq_api$disploop(void) {
    if (((i64)qq_decls$dispatchtype==(i64)3)) {
        qq_api$disploop_fn();
    }
    else if (((i64)qq_decls$dispatchtype==(i64)4)) {
        qq_api$disploop_deb((i64)0);
    }
    else if (((i64)qq_decls$dispatchtype==(i64)5)) {
        qq_api$disploop_deb((i64)1);
    }
    else if (((i64)qq_decls$dispatchtype==(i64)6)) {
        qq_jhandlers_hll$disploop_asm();
    }
    else {
        qq_lib$loaderror((byte*)"Dispatch not supported: ##",qq_decls$dispatchnames[((i64)qq_decls$dispatchtype)-1]);
    }
;
}

static void qq_api$disploop_fn(void) {
    L40 :;
    do {
        ((*(void (*)(void))(*qq_decls$pcptr)))();
L41 :;
    }
    while (!!!(qq_decls$stopped));
L42 :;
    ;
}

static void qq_api$disploop_deb(i64 fdeb) {
        struct qq_decls$locrec loc;
    mlib$fdebug = fdeb;
    L43 :;
    do {
        if (!!(mlib$fdebug)) {
            loc = qq_lib$getpcerrorpos(qq_decls$pcptr);
            msysc$m_print_startcon();
            msysc$m_print_str((*loc.pm).name,(byte*)"13jl");
            msysc$m_print_i64(loc.lineno,(byte*)"6");
            msysc$m_print_space();
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_str(qq_tables$pclnames[((*qq_decls$pcptr))],NULL);
            msysc$m_print_str((byte*)"PCPTR=",NULL);
            msysc$m_print_ptr(qq_decls$pcptr,NULL);
            msysc$m_print_str((byte*)"SPTR=",NULL);
            msysc$m_print_ptr(qq_decls$sptr,NULL);
            msysc$m_print_str(qq_tables$ttname[((i64)(*qq_decls$sptr).tag)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        ++(qq_decls$pclcounts[((*qq_decls$pcptr))]);
        ((*qq_tables$pclhandlers[((*qq_decls$pcptr))]))();
L44 :;
    }
    while (!!!(qq_decls$stopped));
L45 :;
    ;
}

void qq_api$setcmdmap(void) {
        i64 i;
    if ((((i64)qq_decls$dispatchtype == (i64)6) && !(!!(qq_jhandlers_hll$asmavailable())))) {
        qq_decls$dispatchtype = (i64)3;
    }
;
    for (i=(i64)1;i<=(i64)262;++i) {
L46 :;
        if (((i64)qq_decls$dispatchtype==(i64)3)) {
            qq_tables$cmdmap[(i)] = qq_tables$pclhandlers[(i)];
        }
        else if (((i64)qq_decls$dispatchtype==(i64)4) || ((i64)qq_decls$dispatchtype==(i64)5) || ((i64)qq_decls$dispatchtype==(i64)2)) {
            qq_tables$cmdmap[(i)] = (void *)i;
        }
        else if (((i64)qq_decls$dispatchtype==(i64)6)) {
            qq_tables$cmdmap[(i)] = qq_jhandlers_hll$jhandlertable[(i)];
        }
;
L47 :;
    }
L48 :;
    ;
}

i64 qq_api$runproc_m(void *amsg) {
        struct qq_decls$varrec a;
        struct qq_decls$varrec dest;
        static i64 rmsg_typeno;
        i64 i;
        i64 result;
        struct qq_decls$objrec obj;
    if ((rmsg_typeno == (i64)0)) {
        for (i=(i64)1;i<=qq_tables$ntypes;++i) {
L49 :;
            if (!!(mlib$eqstring(qq_tables$ttname[(i)],(byte*)"ws_msg64"))) {
                rmsg_typeno = i;
                goto L51 ;
            }
;
L50 :;
        }
L51 :;
        ;
    }
;
    if ((rmsg_typeno == (i64)0)) {
        mlib$abortprogram((byte*)"mainwndproc: can't find rmsg");
    }
;
    memset(&obj,(i32)(i64)0,(u64)32u);
    obj.refcount = (i64)99;
    obj.ptr = (byte *)amsg;
    obj.usertag = rmsg_typeno;
    a.tagx = (i64)269;
    a.objptr = &obj;
    qq_api$runproc(qq_decls$pcl_callbackfn,&a,0,&dest);
    result = dest.value;
    result = (i64)0;
    return result;
}

void qq_api$runproc(void *fnptr,struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *dest) {
        struct qq_decls$varrec *  oldsptr;
        byte *  oldframeptr;
        i64 *  oldpcptr;
        byte oldstopped;
        i64 nparams;
    (*dest).tagx = (i64)1;
    (*dest).value = (i64)0;
    oldstopped = qq_decls$stopped;
    oldpcptr = qq_decls$pcptr;
    oldsptr = qq_decls$sptr;
    oldframeptr = qq_decls$frameptr;
    (*++(qq_decls$sptr)).tagx = (i64)999;
    if ((!!(b) && !!((i64)(*b).tag))) {
        nparams = (i64)2;
        (*++(qq_decls$sptr)) = (*a);
        (*++(qq_decls$sptr)) = (*b);
    }
    else if ((!!(a) && !!((i64)(*a).tag))) {
        nparams = (i64)1;
        (*++(qq_decls$sptr)) = (*a);
    }
    else {
        nparams = (i64)0;
    }
;
    (*++(qq_decls$sptr)).tagx = (i64)20;
    (*qq_decls$sptr).retaddr = qq_decls$stopseq;
    (*qq_decls$sptr).frameptr_low = (i64)qq_decls$frameptr;
    qq_decls$frameptr = (byte *)qq_decls$sptr;
    qq_decls$pcptr = (i64 *)fnptr;
    qq_api$disploop();
    if (((i64)(*(qq_decls$sptr - (i64)11)).tag == (i64)20)) {
        (*dest) = (*qq_decls$sptr);
    }
    else {
        --(qq_decls$sptr);
        (*dest) = (*qq_decls$sptr);
        if (((i64)(*dest).tag == (i64)0)) {
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)0;
        }
;
    }
;
    qq_decls$pcptr = oldpcptr;
    qq_decls$stopped = (i64)oldstopped;
    qq_decls$sptr = oldsptr;
    qq_decls$frameptr = oldframeptr;
    qq_decls$stopped = (i64)oldstopped;
}

static void qq_api$resetcompiler(void) {
        struct qq_decls$userxrec *  userxmodelist;
    qq_tables$nuserxtypes = (i64)0;
    qq_tables$userxtypebase = (i64)0;
    userxmodelist = 0;
    memset(&(qq_tables$ttxmap),0,40000);
    qq_tables$firstusertype = (qq_tables$ntypes + (i64)1);
}

void qq_api$loadsyslib(void) {
        u8 str[300];
    qq_api$setcmdmap();
    if (!!((i64)qq_decls$fnosys)) {
        return;
    }
;
    if ((u64)0u) {
        qq_decls$usebundled = (i64)0;
    }
;
    if (!!((i64)qq_decls$usebundled)) {
        qq_api$compile_sp((byte*)"sysp.q",0);
    }
    else {
        strcpy(str,(byte*)"c:/qx52/");
        strcat(str,(byte*)"sysp.q");
        qq_api$compile_sp(str,0);
    }
;
    if ((((i64)qq_api$runcode == (i64)6) && !(!!((i64)qq_api$fwriteqa)))) {
        qq_api$runqprogram(qq_decls$subprogs[((i64)1)-1]);
    }
;
}

// START
void qq_api$start(void) {

}

void qq_arrays$var_empty_array(i64 tag,i64 elemtype,i64 lower,struct qq_decls$varrec *dest) {
    (*dest).objptr = qq_arrays$obj_newarray(elemtype,lower,(i64)0);
    (*dest).tagx = (tag | (i64)256);
}

void qq_arrays$obj_free_array(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).ptr,((*p).alloc64 * qq_tables$ttsize[((i64)(*p).elemtag)]));
    }
;
    mlib$pcm_free32(p);
}

void qq_arrays$obj_free_vector(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).ptr,qq_tables$ttsize[((i64)(*p).usertag)]);
    }
;
    mlib$pcm_free32(p);
}

void qq_arrays$var_make_array(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 lower,i64 n,i64 axtype,i64 elemtype) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 m;
        i64 $av_1;
    if ((axtype != (i64)11)) {
        m = qq_tables$ttlength[(axtype)];
        if ((n != m)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"N=",NULL);
            msysc$m_print_i64(n,NULL);
            msysc$m_print_str((byte*)"M=",NULL);
            msysc$m_print_i64(m,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$pcerror((byte*)"Too few/too many elements");
        }
;
    }
    else if (!!(n)) {
        if ((elemtype == (i64)0)) {
                        {i64 $temp = (i64)(*((a + n) - (i64)1)).tag;
if (($temp==(i64)1)) {
                elemtype = (i64)25;
            }
            else if (($temp==(i64)2)) {
                elemtype = (i64)31;
            }
            else {
                elemtype = (i64)25;
            }
            };
        }
;
    }
    else if ((elemtype == (i64)0)) {
        elemtype = (i64)25;
    }
;
    p = qq_arrays$obj_newarray(elemtype,lower,n);
    q = (*p).ptr;
    $av_1 = n;
    while ($av_1-- > 0) {
L52 :;
        qq_packed$var_storepacked(q,a,elemtype);
        q += qq_tables$ttsize[(elemtype)];
        ++(a);
L53 :;
    }
L54 :;
    ;
    if ((axtype == (i64)11)) {
        (*dest).tagx = (i64)267;
    }
    else {
        (*dest).tagx = (i64)263;
        (*p).usertag = axtype;
    }
;
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_arrays$obj_newarray(i64 elemtype,i64 lower,i64 length) {
        struct qq_decls$objrec *  p;
        i64 elemsize;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    if ((($rtemp=lower, $rtemp >= (i64)0 && $rtemp <= (i64)1))) {
        (*p).flags = msysc$m_setdotindex((*p).flags,(i64)0,(u64)lower);
    }
    else {
        qq_lib$pcerror((byte*)"Lwb not 0/1");
    }
;
    (*p).length = length;
    (*p).objtype = (i64)0;
    (*p).elemtag = elemtype;
    elemsize = qq_tables$ttsize[(elemtype)];
    if (!!(length)) {
        (*p).ptr = (byte *)mlib$pcm_allocz((length * elemsize));
        (*p).alloc64 = (mlib$allocbytes / elemsize);
    }
;
    return p;
}

struct qq_decls$objrec *qq_arrays$obj_newarray_u(i64 usertag) {
        struct qq_decls$objrec *  p;
        i64 elemsize;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).objtype = (i64)0;
    (*p).usertag = usertag;
    elemsize = qq_tables$ttsize[((i64)qq_tables$tttarget[(usertag)])];
    if (!!(qq_tables$ttlength[(usertag)])) {
        (*p).ptr = (byte *)mlib$pcm_allocz(qq_tables$ttsize[(usertag)]);
        (*p).alloc64 = (mlib$allocbytes / elemsize);
    }
;
    return p;
}

void qq_arrays$var_getix_array(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  p;
        i64 elemtype;
        i64 length;
    v = (*a);
    p = (*a).objptr;
    if (((i64)v.tag == (i64)7)) {
        length = qq_tables$ttlength[((i64)(*p).usertag)];
        index -= qq_tables$ttlower[((i64)(*p).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*p).usertag)];
    }
    else {
        length = (*p).length;
        elemtype = (i64)(*p).elemtag;
        index -= (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    }
;
    if (((u64)index >= (u64)length)) {
        qq_lib$pcerror((byte*)"ax[int] bounds");
    }
;
    if ((elemtype == (i64)26)) {
        (*a).tagx = (i64)1;
        (*a).value = (i64)(*((*p).ptr + index));
    }
    else {
        qq_packed$var_loadpacked(((*p).ptr + (index * qq_tables$ttsize[(elemtype)])),elemtype,a,0);
    }
;
}

void qq_arrays$var_putix_array(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  p;
        i64 elemtype;
        i64 length;
        i64 lower;
    v = (*a);
    p = v.objptr;
    if (((i64)v.tag == (i64)7)) {
        length = qq_tables$ttlength[((i64)(*p).usertag)];
        lower = qq_tables$ttlower[((i64)(*p).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*p).usertag)];
    }
    else {
        length = (*p).length;
        lower = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
        elemtype = (i64)(*p).elemtag;
    }
;
    index -= lower;
    if (((u64)index >= (u64)length)) {
        if ((index < (i64)0)) {
            qq_lib$pcerror((byte*)"lwb");
        }
        else if ((index == length)) {
            if (((i64)v.tag == (i64)7)) {
                qq_lib$pcerror((byte*)"Can't append user type");
            }
;
            qq_arrays$obj_append_array(p,x);
        }
        else {
            qq_lib$pcerror((byte*)"ax[i]:=x bounds");
        }
;
    }
;
    if ((elemtype == (i64)26)) {
        if (((i64)(*x).tag != (i64)1)) {
            qq_lib$pcerror((byte*)"rhs not int");
        }
;
        (*a).tagx = (i64)1;
        (*((*p).ptr + index)) = (*x).value;
    }
    else {
        qq_packed$var_storepacked(((*p).ptr + (index * qq_tables$ttsize[(elemtype)])),x,elemtype);
    }
;
}

void qq_arrays$var_getixref_array(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  p;
        i64 elemtype;
        i64 length;
        i64 lower;
    v = (*a);
    p = v.objptr;
    if (((i64)v.tag == (i64)7)) {
        length = qq_tables$ttlength[((i64)(*p).usertag)];
        lower = qq_tables$ttlower[((i64)(*p).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*p).usertag)];
    }
    else {
        length = (*p).length;
        lower = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
        elemtype = (i64)(*p).elemtag;
    }
;
    index -= lower;
    if (((u64)index >= (u64)length)) {
        if ((index < (i64)0)) {
            qq_lib$pcerror((byte*)"lwb");
        }
        else {
            if (((u64)index == (u64)length)) {
                qq_lib$pcerror((byte*)"PUTIXREF NEEDS IAPPEND");
                p = (*a).objptr;
            }
            else {
                qq_lib$pcerror((byte*)"ax[i]:=x bounds");
            }
;
        }
;
    }
;
    (*a).tagx = (i64)16;
    (*a).elemtag = elemtype;
    (*a).ptr = ((*p).ptr + (index * qq_tables$ttsize[(elemtype)]));
}

static void qq_arrays$obj_append_array(struct qq_decls$objrec *a,struct qq_decls$varrec *x) {
        i64 n;
        byte *  q;
    if (((i64)(*a).objtype != (i64)0)) {
        qq_lib$pcerror((byte*)"Can't extend slice");
    }
;
    if (!(!!(msysc$m_getdotindex((i64)(*a).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    n = ((*a).length + (i64)1);
    if ((n > (*a).alloc64)) {
        qq_arrays$obj_resize_array(a,n);
    }
    else {
        (*a).length = n;
    }
;
    q = ((*a).ptr + ((n - (i64)1) * qq_tables$ttsize[((i64)(*a).elemtag)]));
    qq_packed$var_storepacked(q,x,(i64)(*a).elemtag);
}

void qq_arrays$var_appendto_array(struct qq_decls$varrec *a,struct qq_decls$varrec *x) {
    qq_arrays$obj_append_array((*a).objptr,x);
}

void qq_arrays$obj_resize_array(struct qq_decls$objrec *p,i64 n) {
        byte *  q;
        i64 elemsize;
    elemsize = qq_tables$ttsize[((i64)(*p).elemtag)];
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        q = (byte *)mlib$pcm_alloc((n * elemsize));
        if (!!((*p).length)) {
            memcpy(q,(*p).ptr,(u64)((*p).length * elemsize));
            mlib$pcm_free((*p).ptr,((*p).alloc64 * elemsize));
        }
;
        (*p).ptr = q;
        (*p).length = n;
        (*p).alloc64 = (mlib$allocbytes / elemsize);
    }
;
}

void qq_arrays$var_dupl_array(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = qq_arrays$obj_newarray((i64)(*p).elemtag,(i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0),(*p).length);
    (*a).objptr = q;
    if (!!((*p).length)) {
        memcpy((*q).ptr,(*p).ptr,(u64)((*p).length * qq_tables$ttsize[((i64)(*p).elemtag)]));
    }
;
}

void qq_arrays$var_dupl_vector(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
    p = (*a).objptr;
    length = qq_tables$ttlength[((i64)(*p).usertag)];
    q = qq_arrays$obj_newarray_u((i64)(*p).usertag);
    (*a).objptr = q;
    if (!!(length)) {
        memcpy((*q).ptr,(*p).ptr,(u64)qq_tables$ttsize[((i64)(*p).usertag)]);
    }
;
}

i64 qq_arrays$var_equal_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 elemsize;
    p = (*a).objptr;
    q = (*b).objptr;
    elemsize = (i64)(*p).elemtag;
    if (((i64)(*p).elemtag != (i64)(*q).elemtag)) {
        return (i64)0;
    }
;
    length = (*p).length;
    if ((length != (*q).length)) {
        return (i64)0;
    }
;
    if ((length == (i64)0)) {
        return (i64)1;
    }
;
    return mlib$eqbytes((*p).ptr,(*q).ptr,(qq_tables$ttsize[((i64)(*p).elemtag)] * length));
}

void qq_arrays$var_concatto_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        byte *  d;
        i64 alen;
        i64 blen;
        i64 newlen;
        i64 elemsize;
        struct qq_decls$objrec *  pa;
        struct qq_decls$objrec *  pb;
    pa = (*a).objptr;
    pb = (*b).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*pa).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    if (((i64)(*pa).elemtag != (i64)(*pb).elemtag)) {
        qq_lib$pcerror((byte*)"concat/not compat");
    }
;
    elemsize = qq_tables$ttsize[((i64)(*pa).elemtag)];
    alen = (*pa).length;
    blen = (*pb).length;
    if ((alen == (i64)0)) {
        if (!!(blen)) {
            qq_arrays$obj_resize_array(pa,blen);
            d = (*pa).ptr;
            memcpy(d,(*pb).ptr,(u64)(blen * elemsize));
        }
;
    }
    else if (!!(blen)) {
        newlen = (alen + blen);
        qq_arrays$obj_resize_array(pa,newlen);
        d = ((*pa).ptr + (alen * elemsize));
        memcpy(d,(*pb).ptr,(u64)(blen * elemsize));
    }
;
}

void qq_arrays$var_getslice_array(struct qq_decls$varrec *a,i64 i,i64 j) {
        i64 alower;
        i64 elemsize;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    alower = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    elemsize = qq_tables$ttsize[((i64)(*p).elemtag)];
    if ((((i < alower) || (j > (((*p).length + alower) - (i64)1))) || (i > j))) {
        qq_lib$pcerror((byte*)"array/slice bounds");
    }
;
    q = qq_vars$obj_new();
    (*q).objtype = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,msysc$m_getdotindex((i64)(*p).flags,(i64)1));
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)0,(u64)1u);
    (*q).ptr = ((*p).ptr + ((i - alower) * elemsize));
    (*q).elemtag = (i64)(*p).elemtag;
        {i64 $temp = (i64)(*p).objtype;
if (($temp==(i64)1)) {
        (*q).objptr2 = (*p).objptr2;
        qq_vars$obj_shareu((*q).objptr2);
    }
    else if (($temp==(i64)2)) {
        (*q).objptr2 = 0;
        (*q).objtype = (i64)2;
    }
    else {
        (*q).objptr2 = p;
        ++((*p).refcount);
    }
    };
    (*q).length = ((j - i) + (i64)1);
    (*a).objptr = q;
}

static i64 qq_arrays$u8inarray(byte a,struct qq_decls$objrec *p) {
        i64 i;
        byte *  q;
        i64 $av_1;
    i = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    q = (*p).ptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L55 :;
        if (((i64)(*q) == (i64)a)) {
            return i;
        }
;
        ++(q);
        ++(i);
L56 :;
    }
L57 :;
    ;
    return (i64)(-9223372036854775807-1);
}

i64 qq_arrays$u16inarray(u16 a,struct qq_decls$objrec *p) {
        i64 i;
        u16 *  q;
        i64 $av_1;
    i = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    q = (u16 *)(*p).ptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L58 :;
        if (((i64)(*q) == (i64)a)) {
            return i;
        }
;
        ++(q);
        ++(i);
L59 :;
    }
L60 :;
    ;
    return (i64)(-9223372036854775807-1);
}

i64 qq_arrays$u32inarray(u32 a,struct qq_decls$objrec *p) {
        i64 i;
        u32 *  q;
        i64 $av_1;
    i = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    q = (u32 *)(*p).ptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L61 :;
        if (((i64)(*q) == (i64)a)) {
            return i;
        }
;
        ++(q);
        ++(i);
L62 :;
    }
L63 :;
    ;
    return (i64)(-9223372036854775807-1);
}

i64 qq_arrays$u64inarray(u64 a,struct qq_decls$objrec *p) {
        i64 i;
        u64 *  q;
        i64 $av_1;
    i = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    q = (u64 *)(*p).ptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L64 :;
        if (((*q) == a)) {
            return i;
        }
;
        ++(q);
        ++(i);
L65 :;
    }
L66 :;
    ;
    return (i64)(-9223372036854775807-1);
}

i64 qq_arrays$var_inx_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b,i64 usertag) {
        i64 n;
        struct qq_decls$objrec *  q;
        i64 elemtag;
    q = (*b).objptr;
    if (!!(usertag)) {
        elemtag = (i64)qq_tables$tttarget[(usertag)];
    }
    else {
        elemtag = (i64)(*q).elemtag;
    }
;
    if ((elemtag==(i64)22) || (elemtag==(i64)26)) {
        n = qq_arrays$u8inarray((byte)(*a).value,q);
    }
    else if ((elemtag==(i64)23) || (elemtag==(i64)27)) {
        n = qq_arrays$u16inarray((u16)(*a).value,q);
    }
    else if ((elemtag==(i64)24) || (elemtag==(i64)28)) {
        n = qq_arrays$u32inarray((u32)(*a).value,q);
    }
    else if ((elemtag==(i64)25) || (elemtag==(i64)29)) {
        n = qq_arrays$u64inarray((u64)(*a).value,q);
    }
    else {
        qq_lib$pcustype((byte*)"x in array",b);
    }
;
    return n;
}

void qq_arrays$var_expand_array(struct qq_decls$varrec *p,struct qq_decls$varrec *dest,i64 m) {
        byte *  q;
        i64 n;
        i64 elemtype;
        i64 length;
        struct qq_decls$objrec *  pa;
        i64 $av_1;
    pa = (*p).objptr;
    if (((i64)(*p).tag == (i64)11)) {
        length = (*pa).length;
        elemtype = (i64)(*pa).elemtag;
    }
    else {
        length = qq_tables$ttlength[((i64)(*pa).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*pa).usertag)];
    }
;
    q = (*pa).ptr;
    n = (i64)1;
    $av_1 = m;
    while ($av_1-- > 0) {
L67 :;
        if ((n > length)) {
            (*dest).tagx = (i64)0;
        }
        else {
            qq_packed$var_loadpacked(q,elemtype,dest,0);
            q += qq_tables$ttsize[(elemtype)];
        }
;
        ++(n);
        --(dest);
L68 :;
    }
L69 :;
    ;
}

// START
void qq_arrays$start(void) {

}

void qq_bits$obj_free_bits(struct qq_decls$objrec *p,i64 tag) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).ptr,qq_bits$getbitssize((*p).alloc64,(i64)(*p).elemtag));
    }
;
    mlib$pcm_free32(p);
}

void qq_bits$var_make_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 lower,i64 n,i64 bxtype,i64 elemtype) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 bitwidthx;
        i64 offset;
        i64 $av_1;
    p = qq_bits$obj_newbits(elemtype,lower,n);
    q = (*p).ptr;
    bitwidthx = (i64)qq_tables$ttbitwidth[(elemtype)];
    offset = (i64)0;
    $av_1 = n;
    while ($av_1-- > 0) {
L70 :;
        qq_vars$var_storebit(q,offset,a,elemtype,bitwidthx);
        offset += bitwidthx;
        if ((offset >= (i64)8)) {
            ++(q);
            offset = (i64)0;
        }
;
        ++(a);
L71 :;
    }
L72 :;
    ;
    (*dest).tagx = (bxtype | (i64)256);
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_bits$obj_newbits(i64 elemtype,i64 lower,i64 length) {
        struct qq_decls$objrec *  p;
        i64 nbytes;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)0,(u64)lower);
    (*p).length = length;
    (*p).objtype = (i64)0;
    (*p).elemtag = elemtype;
    if (!!(length)) {
        nbytes = qq_bits$getbitssize(length,elemtype);
        (*p).ptr = (byte *)mlib$pcm_allocz(nbytes);
        (*p).alloc64 = (mlib$allocbytes * ((i64)8 / (i64)qq_tables$ttbitwidth[(elemtype)]));
    }
;
    return p;
}

void qq_bits$var_getix_bits(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 elemtype;
        i64 shift;
    p = (*a).objptr;
    elemtype = (i64)(*p).elemtag;
    index -= (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    if (((u64)index >= (u64)(*p).length)) {
        qq_lib$pcerror((byte*)"ax[int] bounds");
    }
;
    q = (*p).ptr;
    (*a).tagx = (i64)1;
    index += (i64)(*p).indexoffset;
        {i64 $temp = (i64)(*p).elemtag;
if (($temp==(i64)32)) {
        (*a).value = (i64)!!(((i64)(*(q + (index >> (i64)3))) & ((i64)1 << (index & (i64)7))));
    }
    else if (($temp==(i64)33)) {
        shift = ((index & (i64)3) * (i64)2);
        (*a).value = (((i64)(*(q + (index >> (i64)2))) & ((i64)3 << shift)) >> shift);
    }
    else if (($temp==(i64)34)) {
        shift = ((index & (i64)1) * (i64)4);
        (*a).value = (((i64)(*(q + (index >> (i64)1))) & ((i64)15 << shift)) >> shift);
    }
    else {
        qq_lib$pcustype_t((byte*)"bitix",(i64)(*p).elemtag);
    }
    };
}

void qq_bits$var_putix_bits(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 elemtype;
        i64 newoffset;
    p = (*a).objptr;
    elemtype = (i64)(*p).elemtag;
    index -= (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    if (((u64)index >= (u64)(*p).length)) {
        if ((index < (i64)0)) {
            qq_lib$pcerror((byte*)"lwb");
        }
        else if ((index == (*p).length)) {
            qq_bits$obj_append_bits(p,x);
        }
        else {
            qq_lib$pcerror((byte*)"bx[i]:=x bounds");
        }
;
    }
;
    q = qq_bits$getindexoffset((*p).ptr,(i64)(*p).indexoffset,index,elemtype,&newoffset);
    qq_vars$var_storebit(q,(newoffset * (i64)qq_tables$ttbitwidth[(elemtype)]),x,elemtype,(i64)0);
}

void qq_bits$var_getixref_bits(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 newoffset;
        i64 elemtype;
    p = (*a).objptr;
    elemtype = (i64)(*p).elemtag;
    index -= (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    if (((u64)index >= (u64)(*p).length)) {
        qq_lib$pcerror((byte*)"&bx[i] bounds");
    }
;
    q = qq_bits$getindexoffset((*p).ptr,(i64)(*p).indexoffset,index,elemtype,&newoffset);
    (*a).tagx = (i64)15;
    (*a).elemtag = elemtype;
    (*a).ptr = q;
    (*a).bitoffset = (newoffset * (i64)qq_tables$ttbitwidth[(elemtype)]);
}

static byte *qq_bits$getindexoffset(byte *p,i64 offset,i64 index,i64 t,i64 *newoffset) {
    index += offset;
    if ((t==(i64)32)) {
        p += (index >> (i64)3);
        (*newoffset) = (index & (i64)7);
    }
    else if ((t==(i64)33)) {
        p += (index >> (i64)2);
        (*newoffset) = (index & (i64)3);
    }
    else if ((t==(i64)34)) {
        index += (offset >> (i64)2);
        p += (index >> (i64)1);
        (*newoffset) = (index & (i64)1);
    }
;
    return p;
}

static void qq_bits$obj_append_bits(struct qq_decls$objrec *a,struct qq_decls$varrec *x) {
        i64 n;
        i64 newoffset;
        i64 elemtype;
        byte *  q;
    if (((i64)(*a).objtype != (i64)0)) {
        qq_lib$pcerror((byte*)"Can't extend slice");
    }
;
    if (!(!!(msysc$m_getdotindex((i64)(*a).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    n = ((*a).length + (i64)1);
    elemtype = (i64)(*a).elemtag;
    if ((n > (*a).alloc64)) {
        qq_bits$obj_resize_bits(a,n);
    }
    else {
        (*a).length = n;
    }
;
    q = qq_bits$getindexoffset((*a).ptr,(i64)(*a).indexoffset,(n - (i64)msysc$m_getdotindex((i64)(*a).flags,(i64)0)),elemtype,&newoffset);
    qq_vars$var_storebit(q,(newoffset * (i64)qq_tables$ttbitwidth[(elemtype)]),x,elemtype,(i64)0);
}

void qq_bits$var_appendto_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *x) {
    qq_bits$obj_append_bits((*a).objptr,x);
}

void qq_bits$obj_resize_bits(struct qq_decls$objrec *p,i64 n) {
        byte *  q;
        i64 newsize;
        i64 elemtype;
    elemtype = (i64)(*p).elemtag;
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        newsize = qq_bits$getbitssize(n,elemtype);
        q = (byte *)mlib$pcm_alloc(newsize);
        if (!!((*p).length)) {
            memcpy(q,(*p).ptr,(u64)qq_bits$bits_bytesize(p));
            mlib$pcm_free((*p).ptr,qq_bits$getbitssize((*p).alloc64,elemtype));
        }
;
        (*p).ptr = q;
        (*p).length = n;
        (*p).alloc64 = (mlib$allocbytes * ((i64)8 / (i64)qq_tables$ttbitwidth[(elemtype)]));
    }
;
}

void qq_bits$var_dupl_bits(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = qq_bits$obj_newbits((i64)(*p).elemtag,(i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0),(*p).length);
    (*q).indexoffset = (i64)(*p).indexoffset;
    (*a).objptr = q;
    if (!!((*p).length)) {
        memcpy((*q).ptr,(*p).ptr,(u64)qq_bits$bits_bytesize(p));
    }
;
}

i64 qq_bits$var_equal_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 elemsize;
    p = (*a).objptr;
    q = (*b).objptr;
    elemsize = (i64)(*p).elemtag;
    if (((i64)(*p).elemtag != (i64)(*q).elemtag)) {
        return (i64)0;
    }
;
    length = (*p).length;
    if ((length != (*q).length)) {
        return (i64)0;
    }
;
    if ((length == (i64)0)) {
        return (i64)1;
    }
;
    return mlib$eqbytes((*p).ptr,(*q).ptr,qq_bits$bits_bytesize(p));
}

void qq_bits$var_concatto_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        byte *  d;
        i64 alen;
        i64 blen;
        i64 newlen;
        i64 elemsize;
        struct qq_decls$objrec *  pa;
        struct qq_decls$objrec *  pb;
    qq_lib$pcerror_s((byte*)"VAR/BITS/NOT READY",(byte*)"var_concatto_bits");
    pa = (*a).objptr;
    pb = (*b).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*pa).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    if (((i64)(*pa).elemtag != (i64)(*pb).elemtag)) {
        qq_lib$pcerror((byte*)"concat/not compat");
    }
;
    elemsize = qq_tables$ttsize[((i64)(*pa).elemtag)];
    alen = (*pa).length;
    blen = (*pb).length;
    if ((alen == (i64)0)) {
        if (!!(blen)) {
            qq_bits$obj_resize_bits(pa,blen);
            d = (*pa).ptr;
            memcpy(d,(*pb).ptr,(u64)(blen * elemsize));
        }
;
    }
    else if (!!(blen)) {
        newlen = (alen + blen);
        qq_bits$obj_resize_bits(pa,newlen);
        d = ((*pa).ptr + (alen * elemsize));
        memcpy(d,(*pb).ptr,(u64)(blen * elemsize));
    }
;
}

void qq_bits$var_getslice_bits(struct qq_decls$varrec *a,i64 i,i64 j) {
        i64 alower;
        i64 elemtype;
        i64 newoffset;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    alower = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    elemtype = (i64)(*p).elemtag;
    if ((((i < alower) || (j > (((*p).length + alower) - (i64)1))) || (i > j))) {
        qq_lib$pcerror((byte*)"bits/slice bounds");
    }
;
    q = qq_vars$obj_new();
    (*q).objtype = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,msysc$m_getdotindex((i64)(*p).flags,(i64)1));
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)0,(u64)1u);
    (*q).elemtag = elemtype;
    (*q).ptr = qq_bits$getindexoffset((*p).ptr,(i64)(*p).indexoffset,(i - alower),elemtype,&newoffset);
    (*q).indexoffset = newoffset;
        {i64 $temp = (i64)(*p).objtype;
if (($temp==(i64)1)) {
        (*q).objptr2 = (*p).objptr2;
        qq_vars$obj_shareu((*q).objptr2);
    }
    else if (($temp==(i64)2)) {
        (*q).objptr2 = 0;
        (*q).objtype = (i64)2;
    }
    else {
        (*q).objptr2 = p;
        ++((*p).refcount);
    }
    };
    (*q).length = ((j - i) + (i64)1);
    (*a).objptr = q;
}

i64 qq_bits$bits_bytesize(struct qq_decls$objrec *p) {
    return qq_bits$getbitssize((*p).length,(i64)(*p).elemtag);
}

i64 qq_bits$getbitssize(i64 n,i64 t) {
        i64 nbits;
    nbits = (n * (i64)qq_tables$ttbitwidth[(t)]);
    return ((((nbits - (i64)1) / (i64)64) + (i64)1) * (i64)8);
}

// START
void qq_bits$start(void) {

}

void qq_calldll$calldll(struct qq_decls$strec *d,struct qq_decls$varrec *args,struct qq_decls$varrec *result,i64 nargs) {
        struct qq_decls$strec *  e;
        i64 arglist[100];
        i64 n;
        i64 retcode;
        i64 retval;
        void (*fnaddr)(void);
        i64 i;
    if ((nargs > (i64)100)) {
        qq_lib$pcerror((byte*)"Too many dll args");
    }
;
    e = (*d).deflist;
    n = (i64)0;
    for (i=(i64)1;i<=nargs;++i) {
L73 :;
        if ((e == 0)) {
            if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)8))) {
                arglist[(i)-1] = (i64)qq_calldll$vartopacked(args,0);
                ++(args);
            }
            else {
                qq_lib$pcerror((byte*)"Too many dll args");
            }
;
        }
        else {
            arglist[(i)-1] = (i64)qq_calldll$vartopacked(args,e);
            ++(args);
            e = (*e).nextdef;
        }
;
L74 :;
    }
L75 :;
    ;
    if (((i64)(*d).mode == (i64)31)) {
        retcode = (i64)82;
    }
    else {
        retcode = (i64)73;
    }
;
    fnaddr = (void (*)(void))qq_calldll$getlibprocaddr(d);
    retval = (i64)mwindllc$os_calldllfunction((void (*)(void))fnaddr,retcode,nargs,(i64 (*)[])&arglist,0);
    if (!!((i64)(*d).mode)) {
        qq_calldll$packedtovar((u64)retval,(i64)(*d).mode,result);
    }
;
}

static void (*qq_calldll$getlibprocaddr(struct qq_decls$strec *d))(void) {
        void (*fnaddr)(void);
    fnaddr = (void (*)(void))qq_decls$dllprocaddr[((i64)(*d).index)-1];
    if ((fnaddr == 0)) {
        fnaddr = (void (*)(void))qq_calldll$loaddllfunction(d);
    }
;
    return fnaddr;
}

static u64 qq_calldll$vartopacked(struct qq_decls$varrec *p,struct qq_decls$strec *d) {
        i64 s;
        i64 t;
        struct qq_decls$objrec *  a;
    s = (i64)(*p).tag;
    if ((d == 0)) {
        if ((s==(i64)9)) {
            a = (*p).objptr;
            return (u64)qq_lib$convtostringz((*a).strptr,(*a).length);
        }
        else if ((s==(i64)1) || (s==(i64)2) || (s==(i64)16)) {
            return (u64)(*p).value;
        }
        else {
            qq_lib$pcerror((byte*)"Bad variadic param");
        }
;
    }
;
    t = (i64)(*d).mode;
        {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)25) || ($temp==(i64)29) || ($temp==(i64)24) || ($temp==(i64)28) || ($temp==(i64)23) || ($temp==(i64)27)) {
        if ((s==(i64)1) || (s==(i64)16) || (s==(i64)14)) {
            return (u64)(*p).value;
        }
        else if ((s==(i64)2)) {
            return (u64)(i64)(*p).xvalue;
        }
        else {
            //error:
L76 :;
;
            msysc$m_print_startcon();
            msysc$m_print_setfmt((byte*)"'#' should be '#' (param # #)");
            msysc$m_print_str(qq_show$strmode(s,(i64)1),NULL);
            msysc$m_print_str(qq_show$strmode(t,(i64)0),NULL);
            msysc$m_print_str((*d).name,NULL);
            msysc$m_print_i64((i64)(*d).index,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$pcerror((byte*)"DLL: wrong param type");
        }
;
    }
    else if (($temp==(i64)31)) {
        if ((s==(i64)1)) {
            return (u64)msysc$m_tp_r64toi64((r64)(*p).value);
        }
        else if ((s==(i64)2)) {
            return (u64)msysc$m_tp_r64toi64((*p).xvalue);
        }
        else {
            goto L76 ;
;
        }
;
    }
    else if (($temp==(i64)37)) {
        if ((s==(i64)9)) {
            a = (*p).objptr;
            return (u64)qq_lib$convtostringz((*a).strptr,(*a).length);
        }
        else if ((s==(i64)16)) {
            return (u64)(*p).ptr;
        }
        else {
            goto L76 ;
;
        }
;
    }
    else if (($temp==(i64)16)) {
        if ((s==(i64)16)) {
            return (u64)(*p).ptr;
        }
        else if ((s==(i64)11) || (s==(i64)7)) {
            return (u64)(*(*p).objptr).ptr;
        }
        else {
            goto L76 ;
;
        }
;
    }
    else if (($temp==(i64)39)) {
        return (u64)((byte *)(*p).objptr + (i64)8);
    }
    else {
        qq_lib$pcmxtypestt((byte*)"DLL params:",s,t);
    }
    };
    return (u64)0u;
}

static void qq_calldll$packedtovar(u64 retval,i64 t,struct qq_decls$varrec *dest) {
        i64 tbase;
    tbase = (i64)qq_tables$ttbasetype[(t)];
    if ((tbase==(i64)0)) {
    }
    else if ((tbase==(i64)31)) {
        (*dest).tagx = (i64)2;
        (*dest).xvalue = *(r64*)&retval;
    }
    else if ((tbase==(i64)30)) {
        qq_lib$pcerror((byte*)"dll/r32ret");
    }
    else if ((tbase==(i64)25) || (tbase==(i64)29)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)retval;
    }
    else if ((tbase==(i64)24)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)(i32)retval;
    }
    else if ((tbase==(i64)28)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)(u32)retval;
    }
    else if ((tbase==(i64)23)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)(i16)retval;
    }
    else if ((tbase==(i64)27)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)(u16)retval;
    }
    else if ((tbase==(i64)16)) {
        (*dest).tagx = (i64)16;
        (*dest).ptr = (byte *)retval;
        (*dest).elemtag = (i64)qq_tables$tttarget[(t)];
    }
    else if ((tbase==(i64)37)) {
        qq_strings$var_make_string((u8 *)retval,dest,(i64)0);
    }
    else {
        qq_lib$pcerror_s((byte*)"Rettype not supported:",qq_tables$ttname[(t)]);
    }
;
}

static void (*qq_calldll$loaddllfunction(struct qq_decls$strec *d))(void) {
        i64 fnindex;
        i64 libindex;
        u64 dllinst;
        void (*fnaddr)(void);
        u8 *  name;
    fnindex = (i64)(*d).index;
    fnaddr = (void (*)(void))qq_decls$dllprocaddr[(fnindex)-1];
    if (!!(fnaddr)) {
        return (void (*)(void))fnaddr;
    }
;
    libindex = (i64)qq_decls$dllproclibindex[(fnindex)-1];
    dllinst = qq_decls$dllinsttable[(libindex)-1];
    if (((i64)dllinst == (i64)0)) {
        dllinst = mlinux$os_getdllinst((*qq_decls$libtable[(libindex)-1]).name);
        if (((i64)dllinst == (i64)0)) {
            qq_lib$pcerror_s((byte*)"Can't load DLL:",(*qq_decls$libtable[(libindex)-1]).name);
        }
;
        qq_decls$dllinsttable[(libindex)-1] = dllinst;
    }
;
    name = (!!((*d).truename) ? (*d).truename : (*d).name);
    fnaddr = (void (*)(void))mlinux$os_getdllprocaddr((i64)dllinst,name);
    if ((fnaddr == 0)) {
        qq_lib$pcerror_s((byte*)"Can't find DLL func:",name);
    }
;
    qq_decls$dllprocaddr[(fnindex)-1] = fnaddr;
    return (void (*)(void))fnaddr;
}

// START
void qq_calldll$start(void) {

}

void qq_decimal$obj_free_dec(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).num,((*p).length * (i64)4));
    }
;
    mlib$pcm_free32(p);
}

void qq_decimal$var_dupl_dec(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 size;
    q = (*a).objptr;
    p = qq_vars$obj_new();
    (*p).length = (*q).length;
    (*p).expon = (i64)(*q).expon;
    (*p).neg = (i64)(*q).neg;
    (*p).numtype = (i64)(*q).numtype;
    size = ((*q).length * (i64)4);
    if (!!(size)) {
        (*p).num = (i32 (*)[])mlib$pcm_alloc(size);
        memcpy((*p).num,(*q).num,(u64)size);
    }
;
    (*a).objptr = p;
}

void qq_decimal$var_empty_dec(struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)259;
    (*dest).objptr = qq_decimal$makebignum((i64)0);
}

void qq_decimal$var_make_dec_str(u8 *s,i64 length,struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)259;
    (*dest).objptr = qq_decimal$bn_makestr(s,length);
}

void qq_decimal$var_make_dec_int(i64 a,struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)259;
    (*dest).objptr = qq_decimal$bn_makeint(a);
}

static struct qq_decls$objrec *qq_decimal$badnumber(void) {
        struct qq_decls$objrec *  c;
    c = qq_decimal$makebignum((i64)0);
    (*c).numtype = (i64)3;
    return c;
}

static struct qq_decls$objrec *qq_decimal$bn_makestr(u8 *s,i64 length) {
        u8 *  t;
        u8 *  u;
        u8 *  oldt;
        i64 tlength;
        i64 neg;
        i64 dpindex;
        i64 expon;
        i64 nonzeros;
        i64 talloc;
        i64 dpseen;
        i64 leadingzeros;
        i64 trailingzeros;
        i64 zerosafterdp;
        i64 d;
        i64 n;
        i64 wd;
        i64 dp;
        i64 wdp;
        i64 w;
        i64 d2;
        i64 na;
        i64 nb;
        i64 c;
        struct qq_decls$objrec *  a;
        i64 $av_1;
        i64 $av_2;
        i64 i;
    if ((length == (i64)0)) {
        length = strlen(s);
    }
;
    if ((length <= (i64)0)) {
        return qq_decimal$badnumber();
    }
;
    t = (u8 *)malloc((u64)(length + (i64)1));
    memcpy((void *)t,(void *)s,(u64)length);
    (*(t + length)) = (u64)0u;
    oldt = t;
    tlength = (length + (i64)1);
    s = t;
    talloc = ((length + (i64)1) + (i64)10);
    neg = (i64)0;
        {u64 $temp = (u64)(*s);
if (($temp=='+')) {
        ++(s);
    }
    else if (($temp=='-')) {
        neg = (i64)1;
        ++(s);
    }
    };
    t = (u = (u8 *)mlib$pcm_alloc(talloc));
    dpindex = (i64)-1;
    dpseen = (zerosafterdp = (i64)0);
    nonzeros = (i64)0;
    leadingzeros = (trailingzeros = (i64)0);
    expon = (i64)0;
    L77 :;
    while (1) {
        if ((($rtemp=(c = (i64)(u64)(*s)), $rtemp >= (i64)49 && $rtemp <= (i64)57))) {
            (*(u)++) = (u64)(*(s)++);
            trailingzeros = (i64)0;
            nonzeros = (i64)1;
        }
        else {
            if ((c==(i64)48)) {
                if (!!(nonzeros)) {
                    ++(trailingzeros);
                    (*(u)++) = (u64)(*(s)++);
                }
                else {
                    ++(leadingzeros);
                    if (!!(dpseen)) {
                        ++(zerosafterdp);
                    }
;
                    ++(s);
                }
;
            }
            else if ((c==(i64)95) || (c==(i64)39) || (c==(i64)96) || (c==(i64)32) || (c==(i64)13) || (c==(i64)10)) {
                ++(s);
            }
            else if ((c==(i64)46)) {
                if ((!!(dpseen) || (dpindex >= (i64)0))) {
                    return qq_decimal$badnumber();
                }
;
                if (!!(nonzeros)) {
                    dpindex = (u - t);
                }
                else {
                    dpseen = (i64)1;
                }
;
                ++(s);
            }
            else if ((c==(i64)0)) {
                goto L78 ;
            }
            else if ((c==(i64)101) || (c==(i64)69)) {
                expon = qq_decimal$readexpon((s + (i64)1));
                goto L78 ;
            }
            else {
                return qq_decimal$badnumber();
            }
;
        }
;
    }
L78 :;
    ;
    (*u) = (u64)0u;
    length = (u - t);
    if ((dpindex < (i64)0)) {
        if (!!(dpseen)) {
            dpindex = -(zerosafterdp);
        }
        else {
            dpindex = length;
        }
;
    }
;
    length -= trailingzeros;
    (*(t + length)) = (u64)0u;
    if ((length == (i64)0)) {
        return qq_decimal$bn_makeint((i64)0);
    }
;
    d = ((dpindex - (i64)1) + expon);
    n = length;
    dp = (i64)0;
    na = (i64)1;
    nb = (n - na);
    w = (i64)9;
    if ((d >= (i64)0)) {
        wd = (d / w);
        wdp = (d % w);
    }
    else {
        d2 = m$llabs((d + (i64)1));
        wd = -(((d2 / w) + (i64)1));
        wdp = ((w - (i64)1) - (d2 % w));
    }
;
    na = (wdp + (i64)1);
    nb = msysc$m_imax((n - na),(i64)0);
    L79 :;
    while (!!((nb % w))) {
        ++(nb);
L80 :;
    }
L81 :;
    ;
    length = ((nb / w) + (i64)1);
    u = (t + n);
    $av_1 = ((na + nb) - n);
    while ($av_1-- > 0) {
L82 :;
        (*(u)++) = '0';
L83 :;
    }
L84 :;
    ;
    n = (na + nb);
    (*(t + n)) = (u64)0u;
    a = qq_decimal$makebignum(length);
    (*a).neg = neg;
    (*a).expon = wd;
    u = t;
    (*(*a).num)[((i64)0)] = qq_decimal$strvaln(u,na);
    u += na;
        ($av_2 = (length - (i64)1));
    for (i=(i64)1;i<=$av_2;++i) {
L85 :;
        (*(*a).num)[(i)] = qq_decimal$strvaln(u,w);
        u += w;
L86 :;
    }
L87 :;
    ;
    mlib$pcm_free((void *)t,talloc);
    free((void *)oldt);
    return a;
}

static i64 qq_decimal$readexpon(u8 *s) {
        i64 neg;
        i64 expon;
        i64 c;
    neg = (expon = (i64)0);
        {u64 $temp = (u64)(*s);
if (($temp=='+')) {
        ++(s);
    }
    else if (($temp=='-')) {
        neg = (i64)1;
        ++(s);
    }
    };
    L88 :;
    while (1) {
        if ((($rtemp=(c = (i64)(u64)(*s)), $rtemp >= (i64)48 && $rtemp <= (i64)57))) {
            expon = ((expon * (i64)10) + (i64)((u64)(*s) - '0'));
            ++(s);
        }
        else {
            if ((c==(i64)95) || (c==(i64)39) || (c==(i64)96) || (c==(i64)32)) {
                ++(s);
            }
            else if ((c==(i64)0)) {
                goto L89 ;
            }
            else {
                qq_lib$pcerror((byte*)"make expon?");
            }
;
        }
;
    }
L89 :;
    ;
    if (!!(neg)) {
        return -(expon);
    }
    else {
        return expon;
    }
;
}

static struct qq_decls$objrec *qq_decimal$bn_makeint(i64 x) {
        struct qq_decls$objrec *  a;
        u8 str[256];
    if ((x == (i64)0)) {
        a = qq_decimal$makebignum((i64)0);
    }
    else if ((($rtemp=x, $rtemp >= (i64)0 && $rtemp <= (i64)999999999))) {
        a = qq_decimal$makebignum((i64)1);
        (*(*a).num)[((i64)0)] = x;
    }
    else if ((($rtemp=-(x), $rtemp >= (i64)0 && $rtemp <= (i64)999999999))) {
        a = qq_decimal$makebignum((i64)1);
        (*(*a).num)[((i64)0)] = -(x);
        (*a).neg = (i64)1;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_i64(x,NULL);
        msysc$m_print_end();
        ;
        a = qq_decimal$bn_makestr(str,(i64)0);
    }
;
    return a;
}

u8 *qq_decimal$var_tostr_dec(struct qq_decls$varrec *a,i64 fmt) {
    return qq_decimal$obj_tostr_dec((*a).objptr,fmt);
}

static u8 *qq_decimal$obj_tostr_dec(struct qq_decls$objrec *a,i64 fmt) {
        u8 *  s;
        u8 *  t;
    t = 0;
    if ((a == 0)) {
        t = (byte*)"<void>";
    }
    else {
                {i64 $temp = (i64)(*a).numtype;
if (($temp==(i64)0)) {
            t = (((fmt == (i64)69) || (fmt == (i64)70)) ? (byte*)"0.0" : (byte*)"0");
        }
        else if (($temp==(i64)2)) {
            t = (!!((i64)(*a).neg) ? (byte*)"-Infinity" : (byte*)"Infinity");
        }
        else if (($temp==(i64)3)) {
            t = (byte*)"<NaN>";
        }
        };
    }
;
    if (!!(t)) {
        s = (u8 *)mlib$pcm_alloc((qq_decimal$decstrsize = (strlen(t) + (i64)1)));
        strcpy(s,t);
        return s;
    }
;
    if (((fmt == (i64)0) || (fmt == (i64)65))) {
        if ((!!(qq_decimal$bn_isint(a)) && ((((i64)(*a).expon - (*a).length) * (i64)9) < (i64)60))) {
            fmt = (i64)73;
        }
        else if ((m$llabs(((i64)(*a).expon * (i64)9)) < (i64)60)) {
            fmt = (i64)70;
        }
        else {
            fmt = (i64)69;
        }
;
    }
;
    if ((fmt == (i64)69)) {
        s = qq_decimal$tostring_scient(a);
    }
    else {
        s = qq_decimal$tostring_float(a,fmt);
    }
;
    return s;
}

static u8 *qq_decimal$tostring_scient(struct qq_decls$objrec *a) {
        u8 *  s;
        u8 *  t;
        i64 expon;
        i64 nchars;
        i64 shift;
        i64 x;
        i64 scale;
        i64 $av_1;
        i64 i;
    nchars = (i64)3;
    expon = ((i64)(*a).expon * (i64)9);
    x = (i64)(*(*a).num)[((i64)0)];
    scale = (i64)1;
    shift = (i64)0;
    L90 :;
    while ((x >= (i64)10)) {
        x = (x / (i64)10);
        scale *= (i64)10;
        ++(expon);
        ++(shift);
L91 :;
    }
L92 :;
    ;
    nchars = (((*a).length * (i64)9) + (i64)16);
    s = (t = (u8 *)mlib$pcm_alloc((qq_decimal$decstrsize = nchars)));
    if (!!((i64)(*a).neg)) {
        (*(t)++) = '-';
    }
;
    msysc$m_print_startstr(t);
    msysc$m_print_i64(x,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)".",NULL);
    msysc$m_print_end();
    ;
    t += strlen(t);
    if (!!(shift)) {
        msysc$m_print_startstr(t);
        msysc$m_print_i64(shift,(byte*)"v");
        msysc$m_print_nogap();
        msysc$m_print_i64(((i64)(*(*a).num)[((i64)0)] - (x * scale)),(byte*)"z*");
        msysc$m_print_end();
        ;
        t += strlen(t);
    }
;
        ($av_1 = ((*a).length - (i64)1));
    for (i=(i64)1;i<=$av_1;++i) {
L93 :;
        msysc$m_print_startstr(t);
        msysc$m_print_i64((i64)(*(*a).num)[(i)],(byte*)"z9");
        msysc$m_print_end();
        ;
        t += strlen(t);
L94 :;
    }
L95 :;
    ;
    L96 :;
    while ((((u64)(*(t - (i64)1)) == '0') && ((u64)(*(t - (i64)2)) != '.'))) {
        --(t);
L97 :;
    }
L98 :;
    ;
    msysc$m_print_startstr(t);
    msysc$m_print_str((byte*)"e",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(expon,NULL);
    msysc$m_print_end();
    ;
    t += strlen(t);
    (*t) = (u64)0u;
    return s;
}

static u8 *qq_decimal$tostring_float(struct qq_decls$objrec *a,i64 fmt) {
        i64 expon;
        i64 upper;
        i64 nchars;
        i64 w;
        i64 prel;
        i64 showdot;
        u8 *  s;
        u8 *  t;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
        i64 i;
    expon = (i64)(*a).expon;
    upper = ((*a).length - (i64)1);
    if (((fmt == (i64)73) && !!(qq_decimal$bn_isint(a)))) {
        showdot = (i64)0;
    }
    else {
        showdot = (i64)1;
    }
;
    w = (i64)9;
    nchars = (i64)3;
    if ((expon < (i64)0)) {
        nchars += (m$llabs((expon - (i64)1)) * w);
    }
;
    nchars += ((*a).length * w);
    if (((expon - upper) > (i64)0)) {
        nchars += ((expon - upper) * w);
    }
;
    nchars += (i64)8;
    s = (t = (u8 *)mlib$pcm_alloc((qq_decimal$decstrsize = nchars)));
    if (!!((i64)(*a).neg)) {
        (*(t)++) = '-';
    }
;
    prel = (i64)0;
    if ((expon < (i64)0)) {
        prel = (i64)1;
        (*(t)++) = '0';
        (*(t)++) = '.';
        $av_2 = (m$llabs(expon) - (i64)1);
        while ($av_2-- > 0) {
L99 :;
            $av_1 = (i64)9;
            while ($av_1-- > 0) {
L102 :;
                (*(t)++) = '0';
L103 :;
            }
L104 :;
            ;
L100 :;
        }
L101 :;
        ;
    }
;
    for (i=(i64)0;i<=upper;++i) {
L105 :;
        msysc$m_print_startstr(t);
        msysc$m_print_i64((i64)(*(*a).num)[(i)],(((i > (i64)0) || !!(prel)) ? (byte*)"z9" : (byte*)""));
        msysc$m_print_end();
        ;
        t += strlen(t);
        if ((((expon == i) && (i < upper)) && !!(showdot))) {
            (*(t)++) = '.';
        }
;
L106 :;
    }
L107 :;
    ;
    $av_4 = (expon - upper);
    while ($av_4-- > 0) {
L108 :;
        $av_3 = (i64)9;
        while ($av_3-- > 0) {
L111 :;
            (*(t)++) = '0';
L112 :;
        }
L113 :;
        ;
L109 :;
    }
L110 :;
    ;
    if (((expon >= upper) && !!(showdot))) {
        (*(t)++) = '.';
        (*(t)++) = '0';
    }
;
    (*t) = (u64)0u;
    return s;
}

static i64 qq_decimal$strvaln(u8 *s,i64 n) {
        i64 a;
        i64 $av_1;
    a = (i64)0;
    $av_1 = n;
    while ($av_1-- > 0) {
L114 :;
        if (((u64)(*s) != '_')) {
            a = (((a * (i64)10) + (i64)(u64)(*s)) - (i64)48);
        }
;
        ++(s);
L115 :;
    }
L116 :;
    ;
    return a;
}

static i64 qq_decimal$bn_isint(struct qq_decls$objrec *a) {
    return (i64)((*a).length <= ((i64)(*a).expon + (i64)1));
}

i64 qq_decimal$obj_len_dec(struct qq_decls$objrec *a) {
    return qq_decimal$bn_getprec(a);
    if (!(!!(qq_decimal$bn_isint(a)))) {
        return (i64)0;
    }
;
    if (!!(qq_decimal$bn_iszero(a))) {
        return (i64)1;
    }
;
    return (strlen(msysc$strint((i64)(*(*a).num)[((i64)0)],0)) + ((i64)(*a).expon * (i64)9));
}

i64 qq_decimal$bn_iszero(struct qq_decls$objrec *a) {
    return (i64)((i64)(*a).numtype == (i64)0);
}

i64 qq_decimal$var_equal_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    return qq_decimal$bn_equal((*a).objptr,(*b).objptr);
}

void qq_decimal$var_add_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_add(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_sub_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_sub(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_mul_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_mul(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_div_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_div(dest,(*a).objptr,(*b).objptr,(i64)0);
    (*a).objptr = dest;
}

void qq_decimal$var_idiv_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_idiv(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_irem_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_irem(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_neg_dec(struct qq_decls$varrec *a) {
    qq_decimal$bn_negto((*a).objptr);
}

void qq_decimal$var_abs_dec(struct qq_decls$varrec *a) {
    qq_decimal$bn_absto((*a).objptr);
}

i64 qq_decimal$var_compare_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    return qq_decimal$bn_cmp((*a).objptr,(*b).objptr);
}

static i64 qq_decimal$bn_cmp(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        struct qq_decls$objrec *  d;
        i64 neg;
    if (!!(qq_decimal$bn_equal(a,b))) {
        return (i64)0;
    }
;
    d = qq_decimal$bn_init();
    qq_decimal$bn_sub(d,a,b);
    neg = (i64)(*d).neg;
    qq_decimal$obj_free_dec(d);
    if (!!(neg)) {
        return (i64)-1;
    }
    else {
        return (i64)1;
    }
;
}

static i64 qq_decimal$bn_equal(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
    if ((((i64)(*a).numtype != (i64)1) && ((i64)(*a).numtype == (i64)(*b).numtype))) {
        return (i64)((i64)(*a).neg == (i64)(*b).neg);
    }
;
    if ((((((*a).length != (*b).length) || ((i64)(*a).numtype != (i64)(*b).numtype)) || ((i64)(*a).neg != (i64)(*b).neg)) || ((i64)(*a).expon != (i64)(*b).expon))) {
        return (i64)0;
    }
;
    if (((*a).length == (i64)0)) {
        return (i64)1;
    }
;
    return mlib$eqbytes((*a).num,(*b).num,((*a).length * (i64)4));
}

static i64 qq_decimal$bn_add(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 nega;
        i64 negb;
        {i64 $temp = qq_decimal$getbintype(a,b);
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)2)) {
        qq_decimal$bn_setzero(dest);
        return (i64)1;
    }
    else if (($temp==(i64)5)) {
        qq_decimal$bn_dupl(dest,a);
        return (i64)1;
    }
    else if (($temp==(i64)7)) {
        qq_decimal$bn_dupl(dest,b);
        return (i64)1;
    }
    else {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    };
    nega = (i64)(*a).neg;
    negb = (i64)(*b).neg;
    if ((!(!!(nega)) && !(!!(negb)))) {
        qq_decimal$bn_addu(dest,a,b);
    }
    else if ((!!(nega) && !!(negb))) {
        qq_decimal$bn_addu(dest,a,b);
        qq_decimal$bn_negto(dest);
    }
    else if ((!(!!(nega)) && !!(negb))) {
        qq_decimal$bn_subu(dest,a,b);
    }
    else {
        qq_decimal$bn_subu(dest,b,a);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_sub(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 nega;
        i64 negb;
        {i64 $temp = qq_decimal$getbintype(a,b);
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)2)) {
        qq_decimal$bn_setzero(dest);
        return (i64)1;
    }
    else if (($temp==(i64)5)) {
        qq_decimal$bn_dupl(dest,a);
        return (i64)1;
    }
    else if (($temp==(i64)7)) {
        qq_decimal$bn_dupl(dest,b);
        qq_decimal$bn_negto(dest);
        return (i64)1;
    }
    else {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    };
    nega = (i64)(*a).neg;
    negb = (i64)(*b).neg;
    if ((!(!!(nega)) && !(!!(negb)))) {
        qq_decimal$bn_subu(dest,a,b);
    }
    else if ((!!(nega) && !!(negb))) {
        qq_decimal$bn_subu(dest,b,a);
    }
    else if ((!(!!(nega)) && !!(negb))) {
        qq_decimal$bn_addu(dest,a,b);
    }
    else {
        qq_decimal$bn_subu(dest,b,a);
    }
;
    return (i64)1;
}

static void qq_decimal$bn_addu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 preca;
        i64 precb;
        i64 precc;
        i64 uppera;
        i64 upperb;
        i64 upperc;
        i64 offset;
        i64 carry;
        i64 expona;
        i64 exponb;
        i64 dc;
        u64 j;
        i32 (*pa)[];
        i32 (*pb)[];
        i32 *  c;
        i32 *  c2;
        i64 i;
    if (((i64)(*a).expon < (i64)(*b).expon)) {
        {struct qq_decls$objrec *  temp = a; a = b; b = temp; };
    }
;
    expona = (i64)(*a).expon;
    exponb = (i64)(*b).expon;
    preca = (*a).length;
    precb = (*b).length;
    offset = (expona - exponb);
    uppera = (preca - (i64)1);
    upperb = (precb - (i64)1);
    if ((uppera > (upperb + offset))) {
        upperc = uppera;
    }
    else {
        upperc = (upperb + offset);
    }
;
    precc = (upperc + (i64)1);
    c = (i32 *)qq_decimal$makesmallnum(precc);
    carry = (i64)0;
    pa = (i32 (*)[])(*a).num;
    pb = (i32 (*)[])(*b).num;
    for (i=upperc;i>=(i64)0;--i) {
L117 :;
        j = (u64)(i - offset);
        if (((i <= uppera) && (j <= (u64)upperb))) {
            dc = (((i64)(*pa)[(i)] + (i64)(*pb)[((i64)j)]) + carry);
        }
        else if ((i <= uppera)) {
            dc = ((i64)(*pa)[(i)] + carry);
        }
        else if ((j <= (u64)upperb)) {
            dc = ((i64)(*pb)[((i64)j)] + carry);
        }
        else {
            dc = carry;
        }
;
        if ((dc >= (i64)1000000000)) {
            carry = (i64)1;
            (*(c + i)) = (dc - (i64)1000000000);
        }
        else {
            (*(c + i)) = dc;
            carry = (i64)0;
        }
;
L118 :;
    }
L119 :;
    ;
    if (!!(carry)) {
        c2 = (i32 *)qq_decimal$makesmallnum((precc + (i64)1));
        (*c2) = carry;
        memcpy((c2 + (i64)1),c,(u64)(precc * (i64)4));
        qq_decimal$freesmall((i32 *)c,precc);
        c = c2;
        ++(precc);
    }
;
    qq_decimal$smalltobig(dest,(i32 *)c,precc,precc,(i64)0);
    (*dest).expon = (expona + carry);
}

static void qq_decimal$bn_subu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 preca;
        i64 precb;
        i64 precc;
        i64 uppera;
        i64 upperb;
        i64 upperc;
        i64 offset;
        i64 carry;
        i64 expona;
        i64 isneg;
        i64 diff;
        u64 j;
        i32 (*pa)[];
        i32 (*pb)[];
        i32 *  c;
        i64 i;
    isneg = (i64)0;
    if (((i64)(*a).expon < (i64)(*b).expon)) {
        {struct qq_decls$objrec *  temp = a; a = b; b = temp; };
        isneg = (i64)1;
    }
;
    //retry:
L120 :;
;
    expona = (i64)(*a).expon;
    preca = (*a).length;
    precb = (*b).length;
    offset = (expona - (i64)(*b).expon);
    uppera = (preca - (i64)1);
    upperb = (precb - (i64)1);
    if ((uppera > (upperb + offset))) {
        upperc = uppera;
    }
    else {
        upperc = (upperb + offset);
    }
;
    precc = (upperc + (i64)1);
    c = (i32 *)qq_decimal$makesmallnum(precc);
    carry = (i64)0;
    pa = (i32 (*)[])(*a).num;
    pb = (i32 (*)[])(*b).num;
    for (i=upperc;i>=(i64)0;--i) {
L121 :;
        j = (u64)(i - offset);
        if (((i <= uppera) && (j <= (u64)upperb))) {
            diff = (((i64)(*pa)[(i)] - (i64)(*pb)[((i64)j)]) - carry);
        }
        else if ((i <= uppera)) {
            diff = ((i64)(*pa)[(i)] - carry);
        }
        else if ((j <= (u64)upperb)) {
            diff = (-((i64)(*pb)[((i64)j)]) - carry);
        }
        else {
            diff = -(carry);
        }
;
        if ((diff < (i64)0)) {
            carry = (i64)1;
            (*(c + i)) = (diff + (i64)1000000000);
        }
        else {
            (*(c + i)) = diff;
            carry = (i64)0;
        }
;
L122 :;
    }
L123 :;
    ;
    if (!!(carry)) {
        if (!!(isneg)) {
            qq_lib$pcerror((byte*)"SUBU/CARRY");
        }
;
        {struct qq_decls$objrec *  temp = a; a = b; b = temp; };
        isneg = (i64)1;
        qq_decimal$freesmall((i32 *)c,precc);
        goto L120 ;
;
    }
;
    qq_decimal$smalltobig(dest,(i32 *)c,precc,precc,(i64)0);
    (*dest).neg = isneg;
    (*dest).expon = (expona - qq_decimal$stblz);
}

static struct qq_decls$objrec *qq_decimal$makebignum(i64 length) {
        struct qq_decls$objrec *  a;
    a = qq_vars$obj_new();
    if (!!(length)) {
        (*a).num = (i32 (*)[])mlib$pcm_alloc((length * (i64)4));
        (*a).numtype = (i64)1;
    }
    else {
        (*a).num = 0;
        (*a).numtype = (i64)0;
    }
;
    (*a).length = length;
    (*a).expon = (i64)0;
    (*a).neg = (i64)0;
    return a;
}

static i32 *qq_decimal$makesmallnum(i64 length) {
    return (i32 *)mlib$pcm_alloc((length * (i64)4));
}

static struct qq_decls$objrec *qq_decimal$smalltobig(struct qq_decls$objrec *c,i32 *a,i64 length,i64 alloc,i64 offset) {
        i32 *  p;
        i64 leadingzeros;
        i64 trailingzeros;
        i64 nonzeros;
        i64 newlength;
        i64 $av_1;
    qq_decimal$bn_setzero(c);
    p = (i32 *)a;
    leadingzeros = (trailingzeros = (nonzeros = (i64)0));
    $av_1 = length;
    while ($av_1-- > 0) {
L124 :;
        if (!!((i64)(*(p)++))) {
            nonzeros = (i64)1;
            trailingzeros = (i64)0;
        }
        else {
            if (!!(nonzeros)) {
                ++(trailingzeros);
            }
            else {
                ++(leadingzeros);
            }
;
        }
;
L125 :;
    }
L126 :;
    ;
    qq_decimal$stblz = leadingzeros;
    if (!!(nonzeros)) {
        newlength = ((length - trailingzeros) - leadingzeros);
        if ((newlength==length && length==alloc)) {
            (*c).num = (i32 (*)[])a;
        }
        else {
            (*c).num = (i32 (*)[])qq_decimal$makesmallnum(newlength);
            memcpy((*c).num,(a + leadingzeros),(u64)(newlength * (i64)4));
            qq_decimal$freesmall((i32 *)(a + offset),alloc);
        }
;
        (*c).length = newlength;
        (*c).numtype = (i64)1;
        (*c).expon = ((length - (i64)1) - leadingzeros);
    }
    else if (!!(alloc)) {
        qq_decimal$freesmall((i32 *)(a + offset),alloc);
    }
;
    return c;
}

static void qq_decimal$freesmall(i32 *p,i64 length) {
    mlib$pcm_free(p,(length * (i64)4));
}

struct qq_decls$objrec *qq_decimal$bn_init(void) {
        struct qq_decls$objrec *  a;
    a = qq_decimal$makebignum((i64)0);
    return a;
}

static void qq_decimal$bn_setzero(struct qq_decls$objrec *a) {
    if (!!(a)) {
        if (!!((*a).num)) {
            qq_decimal$freesmall((i32 *)(*a).num,(*a).length);
        }
;
        (*a).num = 0;
        (*a).length = (i64)0;
        (*a).neg = (i64)0;
        (*a).expon = (i64)0;
        (*a).numtype = (i64)0;
    }
;
}

static void qq_decimal$bn_move(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
    qq_decimal$bn_setzero(a);
    memcpy(&(*a).bignumdescr,&(*b).bignumdescr,24);
    memset(&((*b).bignumdescr),0,24);
}

static void qq_decimal$bn_dupl(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        struct qq_decls$objrec *  c;
        i64 size;
    c = qq_decimal$bn_init();
    (*c) = (*b);
    if (!!((*c).length)) {
        (*c).num = (i32 (*)[])qq_decimal$makesmallnum((size = (*c).length));
        memcpy((*c).num,(*b).num,(u64)(size * (i64)4));
    }
;
    qq_decimal$bn_move(a,c);
    qq_decimal$obj_free_dec(c);
}

static void qq_decimal$bn_setinf(struct qq_decls$objrec *dest) {
    qq_decimal$bn_setzero(dest);
    (*dest).numtype = (i64)2;
}

static void qq_decimal$bn_setnan(struct qq_decls$objrec *dest) {
    qq_decimal$bn_setzero(dest);
    (*dest).numtype = (i64)3;
}

void qq_decimal$var_setnan(struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)259;
    (*dest).objptr = qq_decimal$makebignum((i64)0);
    qq_decimal$bn_setnan((*dest).objptr);
}

void qq_decimal$var_setinf(struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)259;
    (*dest).objptr = qq_decimal$makebignum((i64)0);
    qq_decimal$bn_setinf((*dest).objptr);
}

static i64 qq_decimal$getbintype(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 atype;
        i64 btype;
    atype = (i64)(*a).numtype;
    btype = (i64)(*b).numtype;
    if (((atype == (i64)3) || (btype == (i64)3))) {
        return (i64)4;
    }
;
    if ((atype==(i64)1)) {
        if ((btype==(i64)1)) {
            return (i64)1;
        }
        else if ((btype==(i64)0)) {
            return (i64)5;
        }
        else {
            return (i64)6;
        }
;
    }
    else if ((atype==(i64)0)) {
        if ((btype==(i64)1)) {
            return (i64)7;
        }
        else if ((btype==(i64)0)) {
            return (i64)2;
        }
        else {
            return (i64)9;
        }
;
    }
    else {
        if ((btype==(i64)1)) {
            return (i64)8;
        }
        else if ((btype==(i64)0)) {
            return (i64)10;
        }
        else {
            return (i64)3;
        }
;
    }
;
}

static void qq_decimal$bn_negto(struct qq_decls$objrec *a) {
    if (!(!!(qq_decimal$bn_iszero(a)))) {
        (*a).neg = (i64)!(!!((i64)(*a).neg));
    }
;
}

static void qq_decimal$bn_absto(struct qq_decls$objrec *a) {
    (*a).neg = (i64)0;
}

static i64 qq_decimal$bn_mul(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 neg;
        {i64 $temp = qq_decimal$getbintype(a,b);
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)2) || ($temp==(i64)5) || ($temp==(i64)7)) {
        qq_decimal$bn_setzero(dest);
        return (i64)1;
    }
    else {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    };
    neg = (i64)((i64)(*a).neg != (i64)(*b).neg);
    qq_decimal$bn_mulu(dest,a,b);
    if (!!(neg)) {
        qq_decimal$bn_negto(dest);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_mulp(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 prec) {
        i64 res;
    res = qq_decimal$bn_mul(dest,a,b);
    if (!!(res)) {
        qq_decimal$bn_setprec(dest,((prec == (i64)0) ? qq_decimal$currprec : prec));
    }
;
    return res;
}

static void qq_decimal$bn_mulu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 uppera;
        i64 upperb;
        i64 precc;
        i64 expona;
        i64 exponb;
        i64 ax;
        i64 bx;
        i64 cx;
        i64 cx1;
        i64 nc2;
        i64 pd;
        i64 pr;
        i64 p;
        i64 carry;
        i64 x;
        i32 *  c;
    expona = (i64)(*a).expon;
    exponb = (i64)(*b).expon;
    uppera = ((*a).length - (i64)1);
    upperb = ((*b).length - (i64)1);
    precc = ((uppera + upperb) + (i64)2);
    nc2 = precc;
    c = (i32 *)qq_decimal$makesmallnum(nc2);
    memset(c,(i32)(i64)0,(u64)(precc * (i64)4));
    cx = (precc - (i64)1);
    for (bx=upperb;bx>=(i64)0;--bx) {
L127 :;
        carry = (i64)0;
        cx1 = cx;
        for (ax=uppera;ax>=(i64)0;--ax) {
L130 :;
            p = (((i64)(*(*a).num)[(ax)] * (i64)(*(*b).num)[(bx)]) + carry);
            pd = (p / (i64)1000000000);
            pr = (p - (pd * (i64)1000000000));
            x = ((i64)(*(c + cx1)) + pr);
            if ((x > (i64)999999999)) {
                carry = (pd + (i64)1);
                (*(c + (cx1)--)) = (x - (i64)1000000000);
            }
            else {
                carry = pd;
                (*(c + (cx1)--)) = x;
            }
;
L131 :;
        }
L132 :;
        ;
        (*(c + cx1)) = carry;
        --(cx);
L128 :;
    }
L129 :;
    ;
    qq_decimal$smalltobig(dest,(i32 *)c,precc,nc2,(i64)0);
    (*dest).expon = (((expona + exponb) + (i64)1) - qq_decimal$stblz);
}

static i64 qq_decimal$smallmulto(i32 *p,i32 *q,i64 plen,i64 m) {
        i32 *  pp;
        i32 *  qq;
        i64 carry;
        i64 d;
        i64 $av_1;
        i64 $av_2;
    if ((m==(i64)0)) {
        (*p) = (i64)0;
        return (i64)1;
    }
    else if ((m==(i64)1)) {
        memcpy(p,q,(u64)(plen * (i64)4));
        return plen;
    }
;
    pp = (i32 *)((p + plen) - (i64)1);
    qq = (i32 *)((q + plen) - (i64)1);
    carry = (i64)0;
    $av_1 = plen;
    while ($av_1-- > 0) {
L133 :;
        d = (((i64)(*qq) * m) + carry);
        (*pp) = (d % (i64)1000000000);
        carry = (d / (i64)1000000000);
        --(qq);
        --(pp);
L134 :;
    }
L135 :;
    ;
    if (!!(carry)) {
        pp = (i32 *)(p + plen);
        $av_2 = plen;
        while ($av_2-- > 0) {
L136 :;
            (*pp) = (i64)(*(pp - (i64)1));
            --(pp);
L137 :;
        }
L138 :;
        ;
        (*pp) = carry;
        ++(plen);
    }
;
    return plen;
}

static i64 qq_decimal$bn_div(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 prec) {
        i64 neg;
        {i64 $temp = qq_decimal$getbintype(a,b);
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)7)) {
        qq_decimal$bn_setzero(dest);
        return (i64)1;
    }
    else if (($temp==(i64)2) || ($temp==(i64)5)) {
        qq_decimal$bn_setinf(dest);
        return (i64)0;
    }
    else {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    };
    neg = (i64)((i64)(*a).neg != (i64)(*b).neg);
    qq_decimal$bn_fdivu(dest,a,b,prec);
    if (!!(neg)) {
        qq_decimal$bn_negto(dest);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_idiv(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 neg;
        {i64 $temp = qq_decimal$getbintype(a,b);
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)7)) {
        qq_decimal$bn_setzero(dest);
        return (i64)1;
    }
    else if (($temp==(i64)2) || ($temp==(i64)5)) {
        qq_decimal$bn_setinf(dest);
        return (i64)0;
    }
    else {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    };
    neg = (i64)((i64)(*a).neg != (i64)(*b).neg);
    qq_decimal$bn_idivu(dest,a,b,0);
    if (!!(neg)) {
        qq_decimal$bn_negto(dest);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_idivrem(struct qq_decls$objrec *dest,struct qq_decls$objrec *rm,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 nega;
        i64 negb;
        {i64 $temp = qq_decimal$getbintype(a,b);
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)7)) {
        qq_decimal$bn_setzero(dest);
        qq_decimal$bn_setzero(rm);
        return (i64)1;
    }
    else if (($temp==(i64)2) || ($temp==(i64)5)) {
        qq_decimal$bn_setinf(dest);
        qq_decimal$bn_setzero(rm);
        return (i64)0;
    }
    else {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    };
    nega = (i64)(*a).neg;
    negb = (i64)(*b).neg;
    qq_decimal$bn_idivu(dest,a,b,rm);
    if ((nega != negb)) {
        qq_decimal$bn_negto(dest);
    }
;
    if (!!(nega)) {
        qq_decimal$bn_negto(rm);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_irem(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        struct qq_decls$objrec *  d;
        i64 nega;
        {i64 $temp = qq_decimal$getbintype(a,b);
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)7)) {
        qq_decimal$bn_dupl(dest,b);
        return (i64)1;
    }
    else if (($temp==(i64)2) || ($temp==(i64)5)) {
        qq_decimal$bn_setinf(dest);
        qq_decimal$bn_setzero(dest);
        return (i64)0;
    }
    else {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    };
    nega = (i64)(*a).neg;
    d = qq_decimal$bn_init();
    qq_decimal$bn_idivu(d,a,b,dest);
    if (!!(nega)) {
        qq_decimal$bn_negto(dest);
    }
;
    qq_decimal$obj_free_dec(d);
    return (i64)1;
}

static void qq_decimal$bn_idivu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,struct qq_decls$objrec *rm) {
        i32 *  c;
        i32 *  x;
        i64 expona;
        i64 exponb;
        i64 badjust;
        i64 na;
        i64 nb;
        i64 nc;
        i64 nx;
        i64 nx2;
        i64 cx;
        i64 nupper;
        i64 uppera;
        i64 upperb;
        i64 upperc;
        i64 n;
        i64 k;
        i64 nexta;
        i32 *  pa;
        i32 *  pb;
        struct qq_decls$objrec *  d;
        i64 i;
    na = (*a).length;
    nb = (*b).length;
    expona = (i64)(*a).expon;
    exponb = (i64)(*b).expon;
    badjust = ((exponb + (i64)1) - nb);
    if (((na > (expona + (i64)1)) || (nb > (exponb + (i64)1)))) {
        qq_lib$pcerror((byte*)"idivu:a or b not int");
    }
;
    nc = (expona + (i64)1);
    if ((expona < exponb)) {
        qq_decimal$bn_setzero(dest);
        if (!!(rm)) {
            qq_decimal$bn_dupl(rm,a);
        }
;
        return;
    }
;
    uppera = (na - (i64)1);
    upperb = (nb - (i64)1);
    upperc = (nc - (i64)1);
    pa = (i32 *)(*a).num;
    pb = (i32 *)(*b).num;
    n = nb;
    x = (i32 *)qq_decimal$makesmallnum((nx2 = (n + (i64)1)));
    nx = n;
    nupper = (nc - badjust);
    for (i=(i64)0;i<=upperb;++i) {
L139 :;
        if ((i <= uppera)) {
            (*(x + i)) = (i64)(*(pa + i));
        }
        else {
            (*(x + i)) = (i64)0;
        }
;
L140 :;
    }
L141 :;
    ;
    c = (i32 *)qq_decimal$makesmallnum(nc);
    cx = (i64)0;
    L142 :;
    while (1) {
        k = qq_decimal$smalldiv((i32 *)x,(i32 *)pb,&nx,nb);
        (*(c + (cx)++)) = k;
        if ((n >= nupper)) {
            goto L143 ;
        }
;
        nexta = ((n > uppera) ? (i64)0 : (i64)(*(pa + n)));
        ++(n);
        if (((nx == (i64)1) && ((i64)(*x) == (i64)0))) {
            (*x) = nexta;
        }
        else {
            (*(x + nx)) = nexta;
            ++(nx);
        }
;
    }
L143 :;
    ;
    if ((!!(rm) && (exponb < nb))) {
        qq_decimal$smalltobig(rm,(i32 *)x,nx,nx2,(i64)0);
    }
    else {
        qq_decimal$freesmall((i32 *)x,nx2);
    }
;
    if (((cx == (i64)1) && ((i64)(*c) == (i64)0))) {
        qq_decimal$freesmall((i32 *)c,nc);
        qq_decimal$bn_setzero(dest);
        if (!!(rm)) {
            qq_decimal$bn_dupl(rm,a);
        }
;
        return;
    }
;
    if ((((i64)(*c) == (i64)0) && (cx >= (i64)2))) {
        qq_decimal$smalltobig(dest,(i32 *)(c + (i64)1),(cx - (i64)1),nc,(i64)-1);
    }
    else {
        qq_decimal$smalltobig(dest,(i32 *)c,cx,nc,(i64)0);
    }
;
    if ((!!(rm) && (exponb >= nb))) {
        d = qq_decimal$bn_init();
        qq_decimal$bn_mulu(d,b,dest);
        qq_decimal$bn_subu(rm,a,d);
        qq_decimal$obj_free_dec(d);
    }
;
}

static void qq_decimal$bn_fdivu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 precision) {
        i32 *  c;
        i32 *  x;
        i64 expona;
        i64 exponb;
        i64 na;
        i64 nb;
        i64 nc;
        i64 nx;
        i64 nx2;
        i64 cx;
        i64 nc2;
        i64 uppera;
        i64 upperb;
        i64 upperc;
        i64 n;
        i64 k;
        i64 nexta;
        i32 *  pa;
        i32 *  pb;
        i64 i;
    na = (*a).length;
    nb = (*b).length;
    expona = (i64)(*a).expon;
    exponb = (i64)(*b).expon;
    if (!!(precision)) {
        precision = (((precision - (i64)1) / (i64)9) + (i64)1);
    }
    else {
        precision = qq_decimal$currprec;
    }
;
    nc = precision;
    uppera = (na - (i64)1);
    upperb = (nb - (i64)1);
    upperc = (nc - (i64)1);
    pa = (i32 *)(*a).num;
    pb = (i32 *)(*b).num;
    n = nb;
    x = (i32 *)qq_decimal$makesmallnum((nx2 = (n + (i64)1)));
    nx = n;
    for (i=(i64)0;i<=upperb;++i) {
L144 :;
        if ((i <= uppera)) {
            (*(x + i)) = (i64)(*(pa + i));
        }
        else {
            (*(x + i)) = (i64)0;
        }
;
L145 :;
    }
L146 :;
    ;
    c = (i32 *)qq_decimal$makesmallnum((nc2 = (nc + (i64)1)));
    cx = (i64)0;
    L147 :;
    while (1) {
        k = qq_decimal$smalldiv((i32 *)x,(i32 *)pb,&nx,nb);
        (*(c + (cx)++)) = k;
        if ((cx > nc)) {
            goto L148 ;
        }
;
        nexta = ((n > uppera) ? (i64)0 : (i64)(*(pa + n)));
        ++(n);
        if (((nx == (i64)1) && ((i64)(*x) == (i64)0))) {
            (*x) = nexta;
        }
        else {
            (*(x + nx)) = nexta;
            ++(nx);
        }
;
    }
L148 :;
    ;
    qq_decimal$freesmall((i32 *)x,nx2);
    if (((cx == (i64)1) && ((i64)(*c) == (i64)0))) {
        qq_decimal$freesmall((i32 *)c,nc2);
        qq_decimal$bn_setzero(dest);
        return;
    }
;
    if ((((i64)(*c) == (i64)0) && (cx >= (i64)2))) {
        qq_decimal$smalltobig(dest,(i32 *)(c + (i64)1),(cx - (i64)1),nc2,(i64)-1);
        (*dest).expon = ((expona - exponb) - (i64)1);
    }
    else {
        qq_decimal$smalltobig(dest,(i32 *)c,cx,nc2,(i64)0);
        (*dest).expon = (expona - exponb);
    }
;
}

static i64 qq_decimal$smalldiv(i32 *x,i32 *b,i64 *xlen,i64 nb) {
        i64 k;
        i64 count;
        i64 xx;
        i64 y;
        i32 xi;
        i32 bi;
        i32 *  e;
        i64 esize;
        i64 ne;
        i64 nx;
        i64 $av_1;
        i64 i;
    nx = (*xlen);
    k = (i64)0;
    count = (i64)0;
    e = (i32 *)qq_decimal$makesmallnum((esize = (nb + (i64)1)));
    L149 :;
    while (1) {
        if ((nx < nb)) {
            goto L150 ;
        }
        else if ((nx > nb)) {
            xx = (((i64)(*x) * (i64)1000000000) + (i64)(*(x + (i64)1)));
            y = (xx / ((i64)(*b) + (i64)1));
        }
        else {
            if (((i64)(*x) >= ((i64)(*b) + (i64)1))) {
                y = ((i64)(*x) / ((i64)(*b) + (i64)1));
            }
            else {
                y = (i64)1;
                                ($av_1 = (nb - (i64)1));
                for (i=(i64)0;i<=$av_1;++i) {
L151 :;
                    xi = (i64)(*(x + i));
                    bi = (i64)(*(b + i));
                    if (((i64)xi < (i64)bi)) {
                        y = (i64)0;
                        goto L150 ;
                    }
                    else if (((i64)xi > (i64)bi)) {
                        goto L153 ;
                    }
;
L152 :;
                }
L153 :;
                ;
            }
;
        }
;
        k += y;
        if ((y > (i64)1)) {
            ne = qq_decimal$smallmulto((i32 *)e,(i32 *)b,nb,y);
            nx = qq_decimal$smallsubto((i32 *)x,(i32 *)e,nx,ne);
        }
        else if (!!(y)) {
            nx = qq_decimal$smallsubto((i32 *)x,(i32 *)b,nx,nb);
        }
        else {
            qq_lib$pcerror((byte*)"smalldiv:Y=0");
        }
;
    }
L150 :;
    ;
    qq_decimal$freesmall((i32 *)e,esize);
    (*xlen) = nx;
    return k;
}

static i64 qq_decimal$smallsubto(i32 *p,i32 *q,i64 plen,i64 qlen) {
        i32 *  pp;
        i32 *  qq;
        i64 carry;
        i64 diff;
        i64 z;
        i64 $av_1;
        i64 $av_2;
    pp = (i32 *)((p + plen) - (i64)1);
    qq = (i32 *)((q + qlen) - (i64)1);
    carry = (i64)0;
    z = (i64)0;
    $av_1 = plen;
    while ($av_1-- > 0) {
L154 :;
        if ((qq >= q)) {
            diff = (((i64)(*pp) - (i64)(*qq)) - carry);
            --(qq);
        }
        else {
            diff = ((i64)(*pp) - carry);
        }
;
        if ((diff < (i64)0)) {
            carry = (i64)1;
            (*pp) = (diff + (i64)1000000000);
        }
        else {
            (*pp) = diff;
            carry = (i64)0;
        }
;
        if (!!((i64)(*pp))) {
            z = (i64)0;
        }
        else {
            ++(z);
        }
;
        --(pp);
L155 :;
    }
L156 :;
    ;
    if (!!(carry)) {
        qq_lib$pcerror((byte*)"SSUBTO/CARRY?");
    }
;
    if ((z == plen)) {
        --(z);
    }
;
    if (!!(z)) {
        plen -= z;
        pp = (i32 *)p;
        qq = (i32 *)(p + z);
        $av_2 = plen;
        while ($av_2-- > 0) {
L157 :;
            (*(pp)++) = (i64)(*(qq)++);
L158 :;
        }
L159 :;
        ;
    }
;
    return plen;
}

static i64 qq_decimal$bn_getprec(struct qq_decls$objrec *a) {
    return ((*a).length * (i64)9);
}

static void qq_decimal$bn_setprec(struct qq_decls$objrec *a,i64 prec) {
        i64 oldlength;
        i64 newlength;
        struct qq_decls$objrec *  c;
        i64 $av_1;
        i64 i;
    if (((i64)(*a).numtype != (i64)1)) {
        return;
    }
;
    if (((prec < (i64)1) || (prec > (i64)10000000))) {
        return;
    }
;
    prec = ((((prec - (i64)1) / (i64)9) + (i64)1) * (i64)9);
    newlength = (prec / (i64)9);
    oldlength = (*a).length;
    if ((oldlength <= newlength)) {
        return;
    }
;
    c = qq_decimal$makebignum(newlength);
    (*c).neg = (i64)(*a).neg;
    (*c).expon = (i64)(*a).expon;
        ($av_1 = (newlength - (i64)1));
    for (i=(i64)0;i<=$av_1;++i) {
L160 :;
        if ((i < oldlength)) {
            (*(*c).num)[(i)] = (i64)(*(*a).num)[(i)];
        }
        else {
            (*(*c).num)[(i)] = (i64)0;
        }
;
L161 :;
    }
L162 :;
    ;
    qq_decimal$bn_move(a,c);
    qq_decimal$obj_free_dec(c);
}

static i64 qq_decimal$bn_getglobalprec(void) {
    return (qq_decimal$currprec * (i64)9);
}

static void qq_decimal$bn_setglobalprec(i64 prec) {
    qq_decimal$currprec = (((prec - (i64)1) / (i64)9) + (i64)1);
}

static struct qq_decls$objrec *qq_decimal$bn_makefloat(r64 x) {
        u8 str[2048];
    msysc$m_print_startstr(str);
    msysc$m_print_r64(x,(byte*)".15g");
    msysc$m_print_end();
    ;
    return qq_decimal$bn_makestr((u8 *)str,(i64)0);
}

struct qq_decls$varrec *qq_decimal$dectemp(struct qq_decls$varrec *a) {
    qq_decimal$vtemp.tagx = (i64)259;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        qq_decimal$vtemp.objptr = qq_decimal$bn_makeint((*a).value);
    }
    else if (($temp==(i64)2)) {
        qq_decimal$vtemp.objptr = qq_decimal$bn_makefloat((*a).xvalue);
    }
    else {
        qq_lib$pcerror((byte*)"dectemp");
    }
    };
    (*a) = qq_decimal$vtemp;
    return a;
}

void qq_decimal$freedectemp(void) {
    qq_decimal$obj_free_dec(qq_decimal$vtemp.objptr);
}

static void qq_decimal$bn_ipower(struct qq_decls$objrec *d,struct qq_decls$objrec *a,i64 n) {
        struct qq_decls$objrec *  e;
        struct qq_decls$objrec *  f;
    if ((n < (i64)0)) {
        qq_decimal$bn_setzero(d);
    }
    else if ((n == (i64)0)) {
        qq_decimal$bn_move(d,qq_decimal$bn_makeint((i64)1));
    }
    else if ((n == (i64)1)) {
        qq_decimal$bn_dupl(d,a);
    }
    else if (((n & (i64)1) == (i64)0)) {
        e = qq_decimal$bn_init();
        qq_decimal$bn_mulu(e,a,a);
        qq_decimal$bn_ipower(d,e,(n / (i64)2));
        qq_decimal$obj_free_dec(e);
    }
    else {
        e = qq_decimal$bn_init();
        f = qq_decimal$bn_init();
        qq_decimal$bn_mulu(e,a,a);
        qq_decimal$bn_ipower(f,e,((n - (i64)1) / (i64)2));
        qq_decimal$bn_mulu(d,a,f);
        qq_decimal$obj_free_dec(e);
        qq_decimal$obj_free_dec(f);
    }
;
}

void qq_decimal$var_power_dec(struct qq_decls$varrec *a,i64 n) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_ipower(dest,(*a).objptr,n);
    (*a).objptr = dest;
}

i64 qq_decimal$var_convert_dec_int(struct qq_decls$varrec *a) {
    return qq_decimal$bn_toint((*a).objptr);
}

static i64 qq_decimal$bn_toint(struct qq_decls$objrec *a) {
        i64 x;
        i64 $av_1;
        i64 $av_2;
        i64 i;
    if (!(!!(qq_decimal$bn_isint(a)))) {
        qq_lib$pcerror((byte*)"dec-float->int not ready");
        return (i64)0;
    }
;
    if (!!(qq_decimal$bn_iszero(a))) {
        return (i64)0;
    }
;
    x = (i64)0;
        ($av_1 = ((*a).length - (i64)1));
    for (i=(i64)0;i<=$av_1;++i) {
L163 :;
        x = ((x * (i64)1000000000) + (i64)(*(*a).num)[(i)]);
L164 :;
    }
L165 :;
    ;
        ($av_2 = (i64)(*a).expon);
    for (i=(*a).length;i<=$av_2;++i) {
L166 :;
        x *= (i64)1000000000;
L167 :;
    }
L168 :;
    ;
    if (!!((i64)(*a).neg)) {
        return -(x);
    }
    else {
        return x;
    }
;
}

// START
void qq_decimal$start(void) {

}

// START
void qq_decls$start(void) {

}

void qq_dicts$var_make_dict(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  b;
        struct qq_decls$varrec v;
        i64 $av_1;
    p = qq_dicts$obj_new_dict(n);
    b = (*p).varptr;
    v.tagx = (i64)262;
    v.objptr = p;
    $av_1 = n;
    while ($av_1-- > 0) {
L169 :;
        qq_dicts$adddictitem(&v,a,(a + (i64)1));
        a += (i64)2;
L170 :;
    }
L171 :;
    ;
    (*p).dictitems = n;
    (*dest) = v;
}

struct qq_decls$objrec *qq_dicts$obj_new_dict(i64 n) {
        struct qq_decls$objrec *  p;
        i64 m;
    m = msysc$m_imax((i64)16,qq_lib$nextpoweroftwo((n * (i64)2)));
    p = qq_lists$obj_newlist(m,(i64)1,0);
    (*p).dictitems = (i64)0;
    return p;
}

void qq_dicts$obj_free_dict(struct qq_decls$objrec *p,i64 internal) {
        struct qq_decls$varrec *  q;
        i64 $av_1;
    q = (*p).varptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L172 :;
        if (!!((i64)(*q).hasref)) {
            qq_vars$var_unshareu(q);
        }
;
        ++(q);
L173 :;
    }
L174 :;
    ;
    if (!!((*p).length)) {
        mlib$pcm_free((*p).varptr,((i64)(*p).alloc32 * (i64)16));
    }
;
    if (!(!!(internal))) {
        mlib$pcm_free32(p);
    }
;
}

void qq_dicts$var_dupl_dict(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$varrec *  plist;
        struct qq_decls$varrec *  qlist;
        i64 $av_1;
    p = (*a).objptr;
    q = qq_dicts$obj_new_dict((i64)(*p).dictitems);
    (*q) = (*p);
    (*q).refcount = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,(u64)1u);
    (*a).objptr = q;
    if (((*q).length == (i64)0)) {
        return;
    }
;
    qlist = ((*q).varptr = (struct qq_decls$varrec *)mlib$pcm_alloc(((*p).length * (i64)16)));
    (*q).alloc32 = (mlib$allocbytes / (i64)16);
    plist = (*p).varptr;
    $av_1 = (*q).length;
    while ($av_1-- > 0) {
L175 :;
        (*qlist) = (*plist);
        if (!!((i64)(*qlist).hasref)) {
            qq_vars$var_duplu(qlist);
        }
;
        ++(qlist);
        ++(plist);
L176 :;
    }
L177 :;
    ;
}

i64 qq_dicts$var_equal_dict(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
    qq_lib$pcerror((byte*)"EQUALDICT");
    return (i64)1;
}

struct qq_decls$varrec *qq_dicts$var_finddictitem(struct qq_decls$varrec *vd,struct qq_decls$varrec *p,i64 doins) {
        i64 index;
        i64 size;
        i64 keytag;
        i64 wrapped;
        i64 limit;
        i64 keyvalue;
        struct qq_decls$varrec *  q;
        struct qq_decls$objrec *  pa;
        struct qq_decls$objrec *  qa;
        struct qq_decls$objrec *  d;
    //retry:
L178 :;
;
    d = (*vd).objptr;
    size = ((*d).length / (i64)2);
    index = (qq_vars$var_gethashvalue(p) & (size - (i64)1));
    q = ((*d).varptr + (index * (i64)2));
    wrapped = (i64)0;
    keytag = (i64)(*p).tag;
    keyvalue = (*p).value;
    pa = (*p).objptr;
    L179 :;
    while (1) {
        if (((i64)(*q).tag == (i64)0)) {
            goto L180 ;
        }
        else if (((i64)(*q).tag == keytag)) {
            if ((keytag==(i64)1) || (keytag==(i64)2) || (keytag==(i64)4)) {
                if (((*q).value == keyvalue)) {
                    ++(q);
                    if (!!((i64)(*q).hasref)) {
                        ++((*(*q).objptr).refcount);
                    }
;
                    return q;
                }
;
            }
            else if ((keytag==(i64)9)) {
                qa = (*q).objptr;
                if (((*pa).length == (*qa).length)) {
                    if ((memcmp((void *)(*pa).strptr,(void *)(*qa).strptr,(u64)(*pa).length) == (i64)0)) {
                        ++(q);
                        if (!!((i64)(*q).hasref)) {
                            ++((*(*q).objptr).refcount);
                        }
;
                        return q;
                    }
;
                }
;
            }
;
        }
;
        ++(index);
        q += (i64)2;
        if ((index >= size)) {
            if (!!(wrapped)) {
                qq_lib$pcerror((byte*)"DICT FULL?");
            }
;
            wrapped = (i64)1;
            index = (i64)0;
            q = (*d).varptr;
        }
;
    }
L180 :;
    ;
    if (!!(doins)) {
        limit = ((size * (i64)3) / (i64)4);
        if (((i64)(*d).dictitems >= limit)) {
            qq_dicts$expanddict(vd);
            goto L178 ;
;
        }
;
        (*q) = (*p);
        if (!!((i64)(*q).hasref)) {
            ++((*(*q).objptr).refcount);
        }
;
        ++((*d).dictitems);
        return (q + (i64)1);
    }
    else {
        return 0;
    }
;
}

static void qq_dicts$expanddict(struct qq_decls$varrec *vd) {
        i64 n;
        i64 m;
        i64 i;
        i64 oldrefcount;
        struct qq_decls$objrec *  d;
        struct qq_decls$objrec *  e;
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
        struct qq_decls$varrec *  r;
        struct qq_decls$varrec ev;
        static byte inuse;
    if (!!((i64)inuse)) {
        qq_lib$pcerror((byte*)"expanddict?");
    }
;
    inuse = (i64)1;
    d = (*vd).objptr;
    n = (i64)(*d).alloc32;
    m = (n / (i64)2);
    p = (*d).varptr;
    e = qq_dicts$obj_new_dict((m * (i64)2));
    qq_vars$var_objtovar((i64)6,e,&ev);
    q = p;
    for (i=(i64)1;i<=m;++i) {
L181 :;
        if (((i64)(*q).tag != (i64)0)) {
            r = qq_dicts$var_finddictitem(&ev,q,(i64)1);
            ++(q);
            (*r) = (*(q)++);
            if (!!((i64)(*r).hasref)) {
                ++((*(*r).objptr).refcount);
            }
;
        }
        else {
            q += (i64)2;
        }
;
L182 :;
    }
L183 :;
    ;
    qq_dicts$obj_free_dict(d,(i64)1);
    oldrefcount = (i64)(*d).refcount;
    (*d) = (*e);
    mlib$pcm_free(e,(i64)8);
    (*d).refcount = oldrefcount;
    inuse = (i64)0;
}

static void qq_dicts$adddictitem(struct qq_decls$varrec *d,struct qq_decls$varrec *p,struct qq_decls$varrec *q) {
        struct qq_decls$objrec *  da;
        struct qq_decls$varrec *  r;
    da = (*d).objptr;
    if (((*da).length == (i64)0)) {
        qq_lib$pcerror((byte*)"NULL DICT");
    }
;
    r = qq_dicts$var_finddictitem(d,p,(i64)1);
    if (!!((i64)(*q).hasref)) {
        ++((*(*q).objptr).refcount);
    }
;
    if (!!((i64)(*r).hasref)) {
        qq_vars$var_unshareu(r);
    }
;
    (*r) = (*q);
}

// START
void qq_dicts$start(void) {

}

i64 qq_jhandlers_hll$asmavailable(void) {
    return (i64)0;
}

i64 *qq_jhandlers_hll$disploop_asm(void) {
    mlib$abortprogram((byte*)"-ASM NOT AVAILABLE");
    return (i64 *)0;
}

void qq_jhandlers_hll$initjhandlers(void) {
}

// START
void qq_jhandlers_hll$start(void) {

}

void qq_khandlers$kunimpl(void) {
    if (!!(qq_decls$hasbytecodes)) {
        qq_lib$pcerror_s((byte*)"Unimplemented:",qq_tables$pclnames[((*qq_decls$pcptr))]);
    }
    else {
        qq_lib$pcerror((byte*)"Unimplemented (use -fdebug to see opcode)");
    }
;
}

void qq_khandlers$k_pushci(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushnil(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)16;
    (*qq_decls$sptr).elemtag = (i64)0;
    (*qq_decls$sptr).ptr = 0;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pushcs(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)265;
    (*qq_decls$sptr).objptr = (struct qq_decls$objrec *)(*(qq_decls$pcptr + (i64)1));
    ++((*(*qq_decls$sptr).objptr).refcount);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushcr(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)2;
    (*qq_decls$sptr).xvalue = (r64)msysc$m_tp_i64tor64((*(qq_decls$pcptr + (i64)1)));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_stop(void) {
    qq_decls$stopped = (i64)1;
}

void qq_khandlers$k_stoprunproc(void) {
    qq_decls$stopped = (i64)1;
}

void qq_khandlers$k_pushm(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = (*(struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1)));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushf(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = (*(struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1))));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushff(void) {
    qq_decls$sptr += (i64)2;
    (*(qq_decls$sptr - (i64)1)) = (*(struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1))));
    if (!!((i64)(*(qq_decls$sptr - (i64)1)).hasref)) {
        ++((*(*(qq_decls$sptr - (i64)1)).objptr).refcount);
    }
;
    (*qq_decls$sptr) = (*(struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2))));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
}

void qq_khandlers$k_pushmref(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)14;
    (*qq_decls$sptr).varptr = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushfref(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)14;
    (*qq_decls$sptr).varptr = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_popm(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
    if (!!((i64)(*p).hasref)) {
        qq_vars$var_unshareu(p);
    }
;
    (*p) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_storem(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    if (!!((i64)(*p).hasref)) {
        qq_vars$var_unshareu(p);
    }
;
    (*p) = (*qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_zpopm(void) {
    (*(struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1))) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_popf(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    if (!!((i64)(*p).hasref)) {
        qq_vars$var_unshareu(p);
    }
;
    (*p) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_storef(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    if (!!((i64)(*p).hasref)) {
        qq_vars$var_unshareu(p);
    }
;
    (*p) = (*qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_zpopf(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    (*p) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_popretval(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    (*p) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_tom(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    --((*p).value);
    if (!!((*p).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
    }
;
}

void qq_khandlers$k_tof(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    --((*p).value);
    if (!!((*p).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
    }
;
}

void qq_khandlers$k_add(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_add(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_sub(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_sub(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_mul(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_mul(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_div(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_div(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_idiv(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_idiv(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_irem(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_irem(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_iand(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_iand(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ior(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_ior(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ixor(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_ixor(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_shl(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_shl(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_shr(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_shr(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_sqr(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        (*qq_decls$sptr).value = ((*qq_decls$sptr).value*(*qq_decls$sptr).value);
    }
    else if (($temp==(i64)2)) {
        (*qq_decls$sptr).xvalue = ((*qq_decls$sptr).xvalue*(*qq_decls$sptr).xvalue);
    }
    else {
        qq_lib$pcustype((byte*)"Sqr",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_sign(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        (*qq_decls$sptr).value = (((*qq_decls$sptr).value < (i64)0) ? (i64)-1 : (((*qq_decls$sptr).value > (i64)0) ? (i64)1 : (i64)0));
    }
    else if (($temp==(i64)2)) {
        (*qq_decls$sptr).tag = (i64)1;
        (*qq_decls$sptr).value = (((*qq_decls$sptr).xvalue < (double)0.) ? (i64)-1 : (((*qq_decls$sptr).xvalue > (double)0.) ? (i64)1 : (i64)0));
    }
    else {
        qq_lib$pcustype((byte*)"Sign",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_sqrt(void) {
    qq_khandlers$domaths((i64)102);
}

void qq_khandlers$k_sin(void) {
    qq_khandlers$domaths((i64)104);
}

void qq_khandlers$k_cos(void) {
    qq_khandlers$domaths((i64)105);
}

void qq_khandlers$k_tan(void) {
    qq_khandlers$domaths((i64)106);
}

void qq_khandlers$k_asin(void) {
    qq_khandlers$domaths((i64)107);
}

void qq_khandlers$k_acos(void) {
    qq_khandlers$domaths((i64)108);
}

void qq_khandlers$k_atan(void) {
    qq_khandlers$domaths((i64)109);
}

void qq_khandlers$k_log(void) {
    qq_khandlers$domaths((i64)111);
}

void qq_khandlers$k_log10(void) {
    qq_khandlers$domaths((i64)112);
}

void qq_khandlers$k_exp(void) {
    qq_khandlers$domaths((i64)113);
}

void qq_khandlers$k_round(void) {
    qq_khandlers$domaths((i64)114);
}

void qq_khandlers$k_floor(void) {
    qq_khandlers$domaths((i64)115);
}

void qq_khandlers$k_ceil(void) {
    qq_khandlers$domaths((i64)116);
}

void qq_khandlers$k_fract(void) {
    qq_khandlers$domaths((i64)117);
}

void qq_khandlers$k_neg(void) {
        struct qq_decls$varrec x;
    x = (*qq_decls$sptr);
    qq_vars$var_neg(qq_decls$sptr);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_negto(void) {
        struct qq_decls$varrec *  px;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace_unary(px,(void (*)(struct qq_decls$varrec *,...))qq_vars$var_neg);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_absto(void) {
        struct qq_decls$varrec *  px;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace_unary(px,(void (*)(struct qq_decls$varrec *,...))qq_vars$var_abs);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_inotto(void) {
        struct qq_decls$varrec *  px;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace_unary(px,(void (*)(struct qq_decls$varrec *,...))qq_vars$var_inot);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_atan2(void) {
    qq_lib$pcerror((byte*)"ATAN2 NOT READY");
}

void qq_khandlers$k_fmod(void) {
    qq_lib$pcerror((byte*)"FMOD NOT READY");
}

void qq_khandlers$k_abs(void) {
        struct qq_decls$varrec x;
    x = (*qq_decls$sptr);
    qq_vars$var_abs(qq_decls$sptr);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_inot(void) {
        struct qq_decls$varrec x;
    x = (*qq_decls$sptr);
    qq_vars$var_inot(qq_decls$sptr);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_istruel(void) {
        i64 res;
    res = qq_vars$var_istruel(qq_decls$sptr);
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_notl(void) {
        i64 res;
    res = (i64)!(!!(qq_vars$var_istruel(qq_decls$sptr)));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_jumpeq(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  x;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if (!!(qq_vars$var_equal(x,y))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumpne(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_equal(x,y)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumplt(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = qq_decls$sptr;
    x = (qq_decls$sptr - (i64)1);
    qq_decls$sptr -= (i64)2;
    if ((qq_vars$var_compare(x,y) < (i64)0)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumple(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if ((qq_vars$var_compare(x,y) <= (i64)0)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumpge(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = qq_decls$sptr;
    x = (qq_decls$sptr - (i64)1);
    qq_decls$sptr -= (i64)2;
    if ((qq_vars$var_compare(x,y) >= (i64)0)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumpgt(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if ((qq_vars$var_compare(x,y) > (i64)0)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumpfalse(void) {
        struct qq_decls$varrec *  x;
    x = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_istruel(x)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
}

void qq_khandlers$k_jumptrue(void) {
        struct qq_decls$varrec *  x;
    x = (qq_decls$sptr)--;
    if (!!(qq_vars$var_istruel(x))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
}

void qq_khandlers$k_incrtom(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        ++((*p).value);
    }
    else if (($temp==(i64)14)) {
        ++((*p).varptr);
    }
    else if (($temp==(i64)16)) {
        (*p).ptr += qq_tables$ttsize[((i64)(*p).elemtag)];
    }
    else if (($temp==(i64)2)) {
        (*p).xvalue += (double)1.;
    }
    else {
        qq_lib$pcustype((byte*)"incrtom",p);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_incrtof(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        ++((*p).value);
    }
    else if (($temp==(i64)14)) {
        ++((*p).varptr);
    }
    else if (($temp==(i64)16)) {
        (*p).ptr += qq_tables$ttsize[((i64)(*p).elemtag)];
    }
    else if (($temp==(i64)2)) {
        (*p).xvalue += (double)1.;
    }
    else {
        qq_lib$pcustype((byte*)"incrtof",p);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_decrtom(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        --((*p).value);
    }
    else if (($temp==(i64)14)) {
        --((*p).varptr);
    }
    else if (($temp==(i64)16)) {
        (*p).value -= qq_tables$ttsize[((i64)(*p).elemtag)];
    }
    else if (($temp==(i64)2)) {
        (*p).xvalue -= (double)1.;
    }
    else {
        qq_lib$pcustype((byte*)"decrtom",p);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_decrtof(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        --((*p).value);
    }
    else if (($temp==(i64)2)) {
        (*p).xvalue -= (double)1.;
    }
    else if (($temp==(i64)14)) {
        --((*p).varptr);
    }
    else if (($temp==(i64)16)) {
        (*p).ptr -= qq_tables$ttsize[((i64)(*p).elemtag)];
    }
    else {
        qq_lib$pcustype((byte*)"decrtof",p);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_incrload(void) {
        struct qq_decls$varrec v;
    v = (*qq_decls$sptr);
    qq_khandlers$k_incrptr();
    qq_vars$var_loadptr(&v,++(qq_decls$sptr));
}

void qq_khandlers$k_loadincr(void) {
        struct qq_decls$varrec v;
    v = (*qq_decls$sptr);
    qq_vars$var_loadptr(qq_decls$sptr,qq_decls$sptr);
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = v;
    qq_khandlers$k_incrptr();
}

void qq_khandlers$k_decrload(void) {
        struct qq_decls$varrec v;
    v = (*qq_decls$sptr);
    qq_khandlers$k_decrptr();
    qq_vars$var_loadptr(&v,++(qq_decls$sptr));
}

void qq_khandlers$k_loaddecr(void) {
        struct qq_decls$varrec v;
    v = (*qq_decls$sptr);
    qq_vars$var_loadptr(qq_decls$sptr,qq_decls$sptr);
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = v;
    qq_khandlers$k_decrptr();
}

void qq_khandlers$k_incrptr(void) {
        struct qq_decls$varrec *  p;
    p = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)14)) {
        p = (*p).varptr;
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
            ++((*p).value);
        }
        else if (($temp==(i64)14)) {
            ++((*p).varptr);
        }
        else if (($temp==(i64)16)) {
            (*p).ptr += qq_tables$ttsize[((i64)(*p).elemtag)];
        }
        else if (($temp==(i64)2)) {
            (*p).xvalue += (double)1.;
        }
        else {
            qq_lib$pcustype((byte*)"incrptr/refvar",p);
        }
        };
    }
    else if (($temp==(i64)16)) {
                {i64 $temp = (i64)(*p).elemtag;
if (($temp==(i64)26) || ($temp==(i64)22)) {
            ++((*(*p).ptr));
        }
        else if (($temp==(i64)27) || ($temp==(i64)23)) {
            ++((*(u16 *)(*p).ptr));
        }
        else {
            qq_lib$pcustype_t((byte*)"incrptr/ref",(i64)(*p).elemtag);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"incrptr",p);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_decrptr(void) {
        struct qq_decls$varrec *  p;
    p = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)14)) {
        p = (*p).varptr;
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
            --((*p).value);
        }
        else if (($temp==(i64)14)) {
            --((*p).varptr);
        }
        else if (($temp==(i64)16)) {
            (*p).ptr -= qq_tables$ttsize[((i64)(*p).elemtag)];
        }
        else if (($temp==(i64)2)) {
            (*p).xvalue -= (double)1.;
        }
        else {
            qq_lib$pcustype((byte*)"incrptr/refvar",p);
        }
        };
    }
    else if (($temp==(i64)16)) {
                {i64 $temp = (i64)(*p).elemtag;
if (($temp==(i64)26) || ($temp==(i64)22)) {
            --((*(*p).ptr));
        }
        else if (($temp==(i64)27) || ($temp==(i64)23)) {
            --((*(u16 *)(*p).ptr));
        }
        else {
            qq_lib$pcustype_t((byte*)"incrptr/ref",(i64)(*p).elemtag);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"incrptr",p);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pushvoid(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)0;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_callproc(void) {
        static i64 count = (i64)100;
    if ((qq_decls$sptr >= qq_decls$stacklimit)) {
        qq_lib$pcerror((byte*)"Stack Overflow");
    }
;
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)20;
    (*qq_decls$sptr).retaddr = (qq_decls$pcptr + (i64)3);
    (*qq_decls$sptr).frameptr_low = (i64)(u64)qq_decls$frameptr;
    qq_decls$frameptr = (byte *)qq_decls$sptr;
    qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
}

void qq_khandlers$k_callptr(void) {
        struct qq_decls$strec *  d;
    if (((i64)(*qq_decls$sptr).tag != (i64)17)) {
        qq_lib$pcerror((byte*)"Probably undefined function");
    }
;
    d = (*qq_decls$sptr).def;
    if (((i64)(*d).nameid == (i64)21)) {
        d = (*d).alias;
    }
;
    if (((i64)(*d).nparams != (*(qq_decls$pcptr + (i64)1)))) {
        qq_lib$pcerror_s((byte*)"Callptr: wrong # params; need:",msysc$strint((i64)(*d).nparams,0));
    }
;
    (*qq_decls$sptr).tagx = (i64)20;
    (*qq_decls$sptr).retaddr = (qq_decls$pcptr + (i64)3);
    (*qq_decls$sptr).frameptr_low = (i64)(u64)qq_decls$frameptr;
    qq_decls$frameptr = (byte *)qq_decls$sptr;
    qq_decls$pcptr = (*d).pcaddress;
}

void qq_khandlers$k_procentry(void) {
        i64 $av_1;
    $av_1 = (*(qq_decls$pcptr + (i64)1));
    while ($av_1-- > 0) {
L184 :;
        ++(qq_decls$sptr);
        (*qq_decls$sptr).tagx = (i64)0;
L185 :;
    }
L186 :;
    ;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_return(void) {
        i64 nargs;
        i64 $av_1;
    if ((u64)0u) {
        if (((i64)(*qq_decls$sptr).tag != (i64)20)) {
            qq_lib$pcerror_s((byte*)"Not tretaddr:",qq_tables$ttname[((i64)(*qq_decls$sptr).tag)]);
        }
;
    }
;
    nargs = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (*qq_decls$sptr).retaddr;
    (*(i32 *)&qq_decls$frameptr) = (i64)(*qq_decls$sptr).frameptr_low;
    --(qq_decls$sptr);
    $av_1 = nargs;
    while ($av_1-- > 0) {
L187 :;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        --(qq_decls$sptr);
L188 :;
    }
L189 :;
    ;
}

void qq_khandlers$k_return0(void) {
    if ((u64)0u) {
        if (((i64)(*qq_decls$sptr).tag != (i64)20)) {
            qq_lib$pcerror_s((byte*)"Not tretaddr:",qq_tables$ttname[((i64)(*qq_decls$sptr).tag)]);
        }
;
    }
;
    qq_decls$pcptr = (*qq_decls$sptr).retaddr;
    (*(i32 *)&qq_decls$frameptr) = (i64)(*qq_decls$sptr).frameptr_low;
    --(qq_decls$sptr);
}

void qq_khandlers$k_unshare(void) {
        i64 $av_1;
    $av_1 = (*(qq_decls$pcptr + (i64)1));
    while ($av_1-- > 0) {
L190 :;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        --(qq_decls$sptr);
L191 :;
    }
L192 :;
    ;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_unshare1(void) {
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    --(qq_decls$sptr);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_formci(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    ++((*p).value);
    if (((*p).value <= (*(qq_decls$pcptr + (i64)3)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_forfci(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    ++((*p).value);
    if (((*p).value <= (*(qq_decls$pcptr + (i64)3)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_fordmci(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    --((*p).value);
    if (((*p).value >= (*(qq_decls$pcptr + (i64)3)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_fordfci(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    --((*p).value);
    if (((*p).value >= (*(qq_decls$pcptr + (i64)3)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_formm(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    q = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)3));
    ++((*p).value);
    if (((*p).value <= (*q).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_fordmm(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    q = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)3));
    --((*p).value);
    if (((*p).value >= (*q).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_forff(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    q = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)3)));
    ++((*p).value);
    if (((*p).value <= (*q).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_fordff(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    q = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)3)));
    --((*p).value);
    if (((*p).value >= (*q).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_comment(void) {
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_makelist(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_decls$sptr = x;
    qq_lists$var_make_list(x,qq_decls$sptr,n,(*(qq_decls$pcptr + (i64)2)));
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_makedict(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - (n * (i64)2)) + (i64)1);
    qq_dicts$var_make_dict(x,x,n);
    qq_decls$sptr = x;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_makeset(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_sets$var_make_set(x,x,n);
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_makerecord(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_records$var_make_record(x,x,n,(*(qq_decls$pcptr + (i64)2)));
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_makestruct(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_packed$var_make_struct(x,x,n,(*(qq_decls$pcptr + (i64)2)));
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_makearray(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)2));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_arrays$var_make_array(x,x,(*(qq_decls$pcptr + (i64)1)),n,(*(qq_decls$pcptr + (i64)3)),(*(qq_decls$pcptr + (i64)4)));
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)5);
}

void qq_khandlers$k_makebits(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)2));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_bits$var_make_bits(x,x,(*(qq_decls$pcptr + (i64)1)),n,(*(qq_decls$pcptr + (i64)3)),(*(qq_decls$pcptr + (i64)4)));
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)5);
}

void qq_khandlers$k_index(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
        {i64 $temp = (i64)(*y).tag;
if (($temp==(i64)1)) {
        qq_vars$var_getix(qq_decls$sptr,(*y).value);
    }
    else if (($temp==(i64)4)) {
        qq_vars$var_getslice(qq_decls$sptr,msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63),(i64)(*y).range_upper);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Index",&x,y);
    }
    };
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_popindex(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  z;
    z = (qq_decls$sptr)--;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*z).tag;
if (($temp==(i64)1)) {
        qq_vars$var_putix(y,(*z).value,x);
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else if (($temp==(i64)4)) {
        qq_vars$var_putslice(y,msysc$m_getdotslice((*z).dummy,(i64)16,(i64)63),(i64)(*z).range_upper,x);
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        qq_lib$pcmxtypes((byte*)"Popindex",y,z);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_indexref(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
        {i64 $temp = (i64)(*y).tag;
if (($temp==(i64)1)) {
        qq_vars$var_getixref(qq_decls$sptr,(*y).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Indexref",qq_decls$sptr,y);
    }
    };
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_keyindex(void) {
        struct qq_decls$varrec *  d;
        struct qq_decls$varrec *  k;
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  def;
    def = (qq_decls$sptr)--;
    k = (qq_decls$sptr)--;
    d = qq_decls$sptr;
    if (((i64)(*d).tag != (i64)6)) {
        qq_lib$pcustype((byte*)"dict{}",d);
    }
;
    p = qq_dicts$var_finddictitem(d,k,(i64)0);
    if (!!((i64)(*d).hasref)) {
        qq_vars$var_unshareu(d);
    }
;
    if (!!((i64)(*k).hasref)) {
        qq_vars$var_unshareu(k);
    }
;
    if (!!(p)) {
        (*qq_decls$sptr) = (*p);
        if (!!((i64)(*def).hasref)) {
            qq_vars$var_unshareu(def);
        }
;
    }
    else {
        (*qq_decls$sptr) = (*def);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_popkeyindex(void) {
        struct qq_decls$varrec *  d;
        struct qq_decls$varrec *  k;
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  x;
    k = (qq_decls$sptr)--;
    d = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if (((i64)(*d).tag != (i64)6)) {
        qq_lib$pcustype((byte*)"dict{}:=",d);
    }
;
    p = qq_dicts$var_finddictitem(d,k,(i64)1);
    if (((i64)(*p).tag != (i64)0)) {
        if (!!((i64)(*p).hasref)) {
            qq_vars$var_unshareu(p);
        }
;
    }
;
    (*p) = (*x);
    if (!!((i64)(*d).hasref)) {
        qq_vars$var_unshareu(d);
    }
;
    if (!!((i64)(*k).hasref)) {
        qq_vars$var_unshareu(k);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_keyindexref(void) {
        struct qq_decls$varrec *  d;
        struct qq_decls$varrec *  k;
        struct qq_decls$varrec *  p;
    k = (qq_decls$sptr)--;
    d = qq_decls$sptr;
    if (((i64)(*d).tag != (i64)6)) {
        qq_lib$pcustype((byte*)"&dict{}",d);
    }
;
    p = qq_dicts$var_finddictitem(d,k,(i64)0);
    if ((p == 0)) {
        qq_lib$pcerror((byte*)"&dict{} not found");
    }
;
    if (!!((i64)(*p).hasref)) {
        ++((*(*p).objptr).refcount);
    }
;
    if (!!((i64)(*k).hasref)) {
        qq_vars$var_unshareu(k);
    }
;
    if (!!((i64)(*d).hasref)) {
        qq_vars$var_unshareu(d);
    }
;
    (*qq_decls$sptr).tagx = (i64)14;
    (*qq_decls$sptr).varptr = p;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_dot(void) {
        struct qq_decls$strec *  d;
        struct qq_decls$varrec *  p;
        i64 rectype;
        struct qq_decls$varrec v;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)12) || ($temp==(i64)13)) {
    }
    else {
        qq_lib$pcustype((byte*)"dot/not record",qq_decls$sptr);
    }
    };
    rectype = (i64)(*(*qq_decls$sptr).objptr).usertag;
    d = qq_khandlers$resolvefield((*(qq_decls$pcptr + (i64)1)),rectype);
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)11)) {
        p = ((*(*qq_decls$sptr).objptr).varptr + ((i64)(*d).fieldoffset / (i64)16));
        if (!!((i64)(*p).hasref)) {
            ++((*(*p).objptr).refcount);
        }
;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr) = (*p);
    }
    else if (($temp==(i64)12)) {
        qq_packed$var_loadpacked(((*(*qq_decls$sptr).objptr).ptr + (i64)(*d).fieldoffset),(i64)(*d).mode,&v,0);
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr) = v;
    }
    else if (($temp==(i64)5)) {
        (*qq_decls$sptr).tagx = (i64)17;
        (*qq_decls$sptr).def = d;
    }
    else if (($temp==(i64)21)) {
        (*qq_decls$sptr).tagx = (i64)17;
        (*qq_decls$sptr).def = (*d).alias;
    }
    else {
        qq_lib$pcerror_s((byte*)"DOT: can't do this fieldtype:",qq_tables$namenames[((i64)(*d).nameid)]);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_dotref(void) {
        struct qq_decls$strec *  d;
        struct qq_decls$varrec *  p;
        byte *  q;
        i64 rectype;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)12) || ($temp==(i64)13)) {
    }
    else {
        qq_lib$pcerror((byte*)"dot/not record");
    }
    };
    rectype = (i64)(*(*qq_decls$sptr).objptr).usertag;
    d = qq_khandlers$resolvefield((*(qq_decls$pcptr + (i64)1)),rectype);
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)11)) {
        p = ((*(*qq_decls$sptr).objptr).varptr + ((i64)(*d).fieldoffset / (i64)16));
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr).tagx = (i64)14;
        (*qq_decls$sptr).varptr = p;
    }
    else if (($temp==(i64)12)) {
        q = ((*(*qq_decls$sptr).objptr).ptr + (i64)(*d).fieldoffset);
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr).tagx = (i64)16;
        (*qq_decls$sptr).ptr = q;
        (*qq_decls$sptr).elemtag = (i64)(*d).mode;
    }
    else {
        qq_lib$pcerror_s((byte*)"DOTREF: can't do this fieldtype:",qq_tables$namenames[((i64)(*d).nameid)]);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_popdot(void) {
        struct qq_decls$strec *  d;
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    x = (qq_decls$sptr)--;
    y = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)12) || ($temp==(i64)13)) {
    }
    else {
        qq_lib$pcustype((byte*)"dot/not record",x);
    }
    };
    d = qq_khandlers$resolvefield((*(qq_decls$pcptr + (i64)1)),(i64)(*(*x).objptr).usertag);
    if (!(!!((i64)(*x).hasref))) {
        qq_lib$pcerror((byte*)"POPDOT");
    }
;
    if (!(!!(msysc$m_getdotindex((i64)(*(*x).objptr).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)11)) {
        p = ((*(*x).objptr).varptr + ((i64)(*d).fieldoffset / (i64)16));
        if (!!((i64)(*p).hasref)) {
            qq_vars$var_unshareu(p);
        }
;
        (*p) = (*y);
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
    }
    else if (($temp==(i64)12)) {
        qq_packed$var_storepacked(((*(*x).objptr).ptr + (i64)(*d).fieldoffset),y,(i64)(*d).mode);
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
    }
    else {
        qq_lib$pcerror_s((byte*)"POPDOT: can't do this fieldtype:",qq_tables$namenames[((i64)(*d).nameid)]);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_dotindex(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
        {i64 $temp = (i64)(*y).tag;
if (($temp==(i64)1)) {
        qq_vars$var_getdotix(qq_decls$sptr,(*y).value);
    }
    else if (($temp==(i64)4)) {
        qq_vars$var_getdotslice(qq_decls$sptr,msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63),(i64)(*y).range_upper);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Dotindex",&x,y);
    }
    };
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_dotindexref(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
        {i64 $temp = (i64)(*y).tag;
if (($temp==(i64)1)) {
        qq_vars$var_getdotixref(qq_decls$sptr,(*y).value);
    }
    else if (($temp==(i64)4)) {
        qq_vars$var_getdotsliceref(qq_decls$sptr,msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63),(i64)(*y).range_upper);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Dotindexref",qq_decls$sptr,y);
    }
    };
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_popdotindex(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  z;
    z = (qq_decls$sptr)--;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*z).tag;
if (($temp==(i64)1)) {
        qq_vars$var_putdotix(y,(*z).value,x);
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else if (($temp==(i64)4)) {
        qq_vars$var_putdotslice(y,msysc$m_getdotslice((*z).dummy,(i64)16,(i64)63),(i64)(*z).range_upper,x);
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        qq_lib$pcmxtypes((byte*)"Popdotindex",y,z);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_len(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$objrec *  p;
        i64 n;
    x = qq_decls$sptr;
    p = (*x).objptr;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)10) || ($temp==(i64)12) || ($temp==(i64)11) || ($temp==(i64)6) || ($temp==(i64)8)) {
        n = (*p).length;
    }
    else if (($temp==(i64)9)) {
        n = (*p).length;
    }
    else if (($temp==(i64)12) || ($temp==(i64)7) || ($temp==(i64)13)) {
        n = qq_tables$ttlength[((i64)(*p).usertag)];
    }
    else if (($temp==(i64)5)) {
        n = (*p).length;
    }
    else if (($temp==(i64)4)) {
        n = (((i64)(*x).range_upper - msysc$m_getdotslice((*x).dummy,(i64)16,(i64)63)) + (i64)1);
    }
    else if (($temp==(i64)3)) {
        n = qq_decimal$obj_len_dec(p);
    }
    else {
        qq_lib$pcustype((byte*)"Len",x);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_upb(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$objrec *  p;
        i64 n;
        i64 t;
    x = qq_decls$sptr;
    p = (*x).objptr;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)10)) {
        n = (((*p).length + (i64)(*p).lower16) - (i64)1);
    }
    else if (($temp==(i64)9) || ($temp==(i64)6)) {
        n = (*p).length;
    }
    else if (($temp==(i64)11) || ($temp==(i64)8)) {
        n = (((*p).length + (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0)) - (i64)1);
    }
    else if (($temp==(i64)12) || ($temp==(i64)13)) {
        n = qq_tables$ttlength[((i64)(*p).usertag)];
    }
    else if (($temp==(i64)7)) {
        t = (i64)(*p).usertag;
        goto L193 ;
;
    }
    else if (($temp==(i64)5)) {
        n = ((*p).length - (i64)1);
    }
    else if (($temp==(i64)4)) {
        n = (i64)(*x).range_upper;
    }
    else if (($temp==(i64)18)) {
        t = (*qq_decls$sptr).value;
        //dotype:
L193 :;
;
                {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)7)) {
            n = ((qq_tables$ttlength[(t)] + qq_tables$ttlower[(t)]) - (i64)1);
        }
        else {
            qq_lib$pcustype((byte*)"t.upb",x);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"Upb",x);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_lwb(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$objrec *  p;
        i64 n;
    x = qq_decls$sptr;
    p = (*x).objptr;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)10)) {
        n = (i64)(*p).lower16;
    }
    else if (($temp==(i64)9) || ($temp==(i64)6)) {
        n = (i64)1;
    }
    else if (($temp==(i64)11) || ($temp==(i64)8)) {
        n = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    }
    else if (($temp==(i64)12) || ($temp==(i64)13)) {
        n = (i64)1;
    }
    else if (($temp==(i64)7)) {
        n = qq_tables$ttlower[((i64)(*p).usertag)];
    }
    else if (($temp==(i64)5)) {
        n = (i64)0;
    }
    else if (($temp==(i64)4)) {
        n = msysc$m_getdotslice((*x).dummy,(i64)16,(i64)63);
    }
    else {
        qq_lib$pcustype((byte*)"Lwb",x);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_bounds(void) {
    qq_khandlers$do_bounds((i64)0);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_boundsx(void) {
    qq_khandlers$do_bounds((i64)1);
    ++(qq_decls$pcptr);
}

static void qq_khandlers$do_bounds(i64 sx) {
        i64 a;
        i64 b;
        i64 m;
        i64 t;
        struct qq_decls$objrec *  p;
    m = (i64)(*qq_decls$sptr).tag;
    p = (*qq_decls$sptr).objptr;
    if ((m==(i64)10)) {
        a = (i64)(*p).lower16;
        b = (((*p).length + a) - (i64)1);
    }
    else if ((m==(i64)11) || (m==(i64)8)) {
        a = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
        b = (((*p).length + a) - (i64)1);
    }
    else if ((m==(i64)9) || (m==(i64)6)) {
        a = (i64)1;
        b = (*p).length;
    }
    else if ((m==(i64)4)) {
        a = msysc$m_getdotslice((*qq_decls$sptr).dummy,(i64)16,(i64)63);
        b = (i64)(*qq_decls$sptr).range_upper;
    }
    else if ((m==(i64)13) || (m==(i64)12)) {
        a = (i64)1;
        b = qq_tables$ttlength[((i64)(*p).usertag)];
    }
    else if ((m==(i64)7)) {
        t = (i64)(*p).usertag;
        goto L194 ;
;
    }
    else if ((m==(i64)5)) {
        a = (i64)0;
        b = ((*p).length - (i64)1);
    }
    else if ((m==(i64)18)) {
        t = (*qq_decls$sptr).value;
        //dotype:
L194 :;
;
                {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)7) || ($temp==(i64)13)) {
            a = qq_tables$ttlower[(t)];
            b = ((qq_tables$ttlength[(t)] + a) - (i64)1);
        }
        else {
            qq_lib$pcustype((byte*)"t.bounds",qq_decls$sptr);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"Bounds",qq_decls$sptr);
    }
;
    if (!!(sx)) {
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr).tagx = (i64)1;
        (*qq_decls$sptr).value = a;
        ++(qq_decls$sptr);
        (*qq_decls$sptr).tagx = (i64)1;
        (*qq_decls$sptr).value = b;
    }
    else {
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr).tagx = (i64)4;
        (*qq_decls$sptr).dummy = msysc$m_setdotslice((*qq_decls$sptr).dummy,(i64)16,(i64)63,a);
        (*qq_decls$sptr).range_upper = (u64)b;
    }
;
}

void qq_khandlers$k_dictitems(void) {
        i64 n;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)6)) {
        n = (i64)(*(*qq_decls$sptr).objptr).dictitems;
    }
    else if (($temp==(i64)3)) {
        n = (*(*qq_decls$sptr).objptr).length;
    }
    else {
        qq_lib$pcustype((byte*)"Dictitems/digits",qq_decls$sptr);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isfound(void) {
    if (((i64)(*qq_decls$sptr).tag != (i64)1)) {
        qq_lib$pcerror((byte*)"isfound");
    }
;
    (*qq_decls$sptr).value = (i64)((*qq_decls$sptr).value != (i64)(-9223372036854775807-1));
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_append(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_append(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_concat(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_concat(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_appendto(void) {
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*px).tag;
if (($temp==(i64)14)) {
        qq_vars$var_appendto((*px).varptr,y);
    }
    else {
        qq_lib$pcustype((byte*)"Appendto",px);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_concatto(void) {
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*px).tag;
if (($temp==(i64)14)) {
        qq_vars$var_concatto((*px).varptr,y);
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        qq_lib$pcustype((byte*)"Concatto",px);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_addto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_addto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_add,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_addmixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_subto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_sub,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_multo(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_mul,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_divto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_div,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_idivto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_idiv,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_iandto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_iand,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_iorto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_ior,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ixorto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_ixor,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_shlto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_shl,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_shrto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_shr,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_copy(void) {
        struct qq_decls$varrec x;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        x = (*qq_decls$sptr);
        qq_vars$var_duplu(qq_decls$sptr);
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_dupl(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = (*(qq_decls$sptr - (i64)1));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_makerange(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 lower;
        i64 upper;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if ((((i64)(*x).tag != (i64)1) || ((i64)(*y).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"makerange/not int");
    }
;
    (*qq_decls$sptr).tagx = (i64)4;
    lower = (*x).value;
    upper = (*y).value;
    if (!((($rtemp=lower, $rtemp >= (i64)-281474976710656 && $rtemp <= (i64)281474976710655)))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"LOWER=",NULL);
        msysc$m_print_i64(lower,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$pcerror((byte*)"Range lwb bounds");
    }
;
    (*qq_decls$sptr).range_upper = (u64)upper;
    (*qq_decls$sptr).dummy = msysc$m_setdotslice((*qq_decls$sptr).dummy,(i64)16,(i64)63,lower);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_makerangelen(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if ((((i64)(*x).tag != (i64)1) || ((i64)(*y).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"makerangelen/not int");
    }
;
    (*qq_decls$sptr).tagx = (i64)4;
    (*qq_decls$sptr).range_upper = (u64)(((*x).value + (*y).value) - (i64)1);
    (*qq_decls$sptr).dummy = msysc$m_setdotslice((*qq_decls$sptr).dummy,(i64)16,(i64)63,(*x).value);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_makedecimal(void) {
        struct qq_decls$varrec x;
        struct qq_decls$objrec *  p;
    x = (*qq_decls$sptr);
    if (((i64)x.tag != (i64)9)) {
        qq_lib$pcerror((byte*)"Not str");
    }
;
    p = x.objptr;
    if (((*p).length == (i64)0)) {
        qq_lib$pcerror((byte*)"Null str");
    }
;
    qq_decimal$var_make_dec_str((*p).strptr,(*p).length,qq_decls$sptr);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_makeclosure(void) {
    qq_lib$pcerror((byte*)"MK CLOSURE NOT READY");
    ++(qq_decls$pcptr);
}

static struct qq_decls$strec *qq_khandlers$resolvefield(i64 index,i64 rectype) {
        struct qq_decls$strec *  d;
        struct qq_decls$genfieldrec *  g;
    if ((index == (i64)0)) {
        qq_lib$pcerror((byte*)"Not a field");
    }
;
    g = (struct qq_decls$genfieldrec *)qq_decls$genfieldtable[(index)-1];
    L195 :;
    while (!!(g)) {
        d = (*g).def;
        if (((i64)(*(*d).owner).mode == rectype)) {
            return d;
        }
;
        g = (struct qq_decls$genfieldrec *)(*g).nextdef;
L196 :;
    }
L197 :;
    ;
    qq_lib$pcerror_s((byte*)"Can't resolve field:",(*d).name);
    return (struct qq_decls$strec *)0;
}

void qq_khandlers$k_pushptr(void) {
        struct qq_decls$varrec *  p;
    p = qq_decls$sptr;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)14)) {
        if (!(!!((*p).varptr))) {
            qq_lib$pcerror((byte*)"Nil^");
        }
;
        (*qq_decls$sptr) = (*(*p).varptr);
    }
    else if (($temp==(i64)16)) {
        if (!(!!((*p).ptr))) {
            qq_lib$pcerror((byte*)"Nil^");
        }
;
        qq_packed$var_loadpacked((*p).ptr,(i64)(*p).elemtag,qq_decls$sptr,0);
    }
    else if (($temp==(i64)15)) {
        qq_vars$var_loadbit((*p).ptr,(i64)(*p).bitoffset,(i64)(*p).elemtag,(i64)(*p).bitlength,qq_decls$sptr);
    }
    else {
        qq_lib$pcustype((byte*)"Pushptr",p);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_popptr(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  x;
    p = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)14)) {
        if (!!((i64)(*(*p).varptr).hasref)) {
            qq_vars$var_unshareu((*p).varptr);
        }
;
        (*(*p).varptr) = (*x);
    }
    else if (($temp==(i64)16)) {
        qq_packed$var_storepacked((*p).ptr,x,(i64)(*p).elemtag);
    }
    else if (($temp==(i64)15)) {
        qq_vars$var_storebit((*p).ptr,(i64)(*p).bitoffset,x,(i64)(*p).elemtag,(i64)(*p).bitlength);
    }
    else {
        qq_lib$pcustype((byte*)"Popptr",p);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_islist(void) {
    qq_khandlers$istype((i64)10,(i64)0);
}

void qq_khandlers$k_isarray(void) {
    qq_khandlers$istype((i64)11,(i64)0);
}

void qq_khandlers$k_isstring(void) {
    qq_khandlers$istype((i64)9,(i64)0);
}

void qq_khandlers$k_isrecord(void) {
    qq_khandlers$istype((i64)12,(i64)0);
}

void qq_khandlers$k_swap(void) {
        byte tempbuffer[1024];
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec v;
        i64 s;
        i64 t;
        i64 n;
        byte *  p;
        byte *  q;
        i64 a;
    x = (qq_decls$sptr)--;
    y = (qq_decls$sptr)--;
    if (((i64)(*x).tag != (i64)(*y).tag)) {
        qq_lib$pcerror((byte*)"Swap mismatch");
    }
;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)14)) {
        v = (*(*x).varptr);
        (*(*x).varptr) = (*(*y).varptr);
        (*(*y).varptr) = v;
    }
    else if (($temp==(i64)16)) {
        s = (i64)(*x).elemtag;
        t = (i64)(*y).elemtag;
        if ((s != t)) {
            goto L198 ;
;
        }
;
        n = qq_tables$ttsize[(s)];
        if ((n==(i64)1)) {
            p = (*x).ptr;
            q = (*y).ptr;
            a = (i64)(*p);
            (*p) = (i64)(*q);
            (*q) = a;
        }
        else {
            if ((qq_tables$ttsize[(s)] <= (i64)1024)) {
                memcpy(&tempbuffer,(*x).ptr,(u64)n);
                memcpy((*x).ptr,(*y).ptr,(u64)n);
                memcpy((*y).ptr,&tempbuffer,(u64)n);
            }
            else {
                goto L198 ;
;
            }
;
        }
;
    }
    else {
        //swaperror:
L198 :;
;
        qq_lib$pcmxtypes((byte*)"Swap",x,y);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_jumptesteq(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 xt;
        i64 yt;
        i64 res;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    xt = (i64)(*x).tag;
    yt = (i64)(*y).tag;
    if ((xt != yt)) {
                {i64 $temp = ((xt << (i64)16) | yt);
if (($temp==(i64)65540)) {
            if (!((($rtemp=(*x).value, $rtemp >= msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63) && $rtemp <= (i64)(*y).range_upper)))) {
                qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
                return;
            }
;
        }
        else if (($temp==(i64)65541)) {
            if (!(!!(qq_sets$var_in_set(x,y)))) {
                qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
                return;
            }
;
        }
        };
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
        --(qq_decls$sptr);
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
        return;
    }
;
    res = qq_vars$var_equal(x,y);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    if (!!(res)) {
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        --(qq_decls$sptr);
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
        return;
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_jumptestne(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 xt;
        i64 yt;
        i64 res;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    xt = (i64)(*x).tag;
    yt = (i64)(*y).tag;
    if ((xt != yt)) {
                {i64 $temp = ((xt << (i64)16) | yt);
if (($temp==(i64)65540)) {
            if ((($rtemp=(*x).value, $rtemp >= msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63) && $rtemp <= (i64)(*y).range_upper))) {
                --(qq_decls$sptr);
                qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
                return;
            }
;
        }
        else if (($temp==(i64)65541)) {
            if (!!(qq_sets$var_in_set(x,y))) {
                --(qq_decls$sptr);
                qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
                return;
            }
;
        }
        };
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
        return;
    }
;
    res = qq_vars$var_equal(x,y);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    if (!(!!(res))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
        return;
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_jump(void) {
    qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
}

void qq_khandlers$k_jumpptr(void) {
        struct qq_decls$strec *  d;
    if (((i64)(*qq_decls$sptr).tag != (i64)17)) {
        qq_lib$pcerror((byte*)"symbol expected");
    }
;
    d = (*qq_decls$sptr).def;
    ++(qq_decls$sptr);
    if (((i64)(*d).nameid != (i64)17)) {
        qq_lib$pcerror((byte*)"label expected");
    }
;
    if (!(!!((i64)(*d).procfixed))) {
        (*d).pcaddress = ((*qq_decls$modules[((i64)(*d).moduleno)]).pcstart + (*d).labelno);
        (*d).procfixed = (i64)1;
    }
;
    qq_decls$pcptr = (*d).pcaddress;
}

void qq_khandlers$k_incr(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        ++((*qq_decls$sptr).value);
    }
    else {
        qq_lib$pcustype((byte*)"incr",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_decr(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        --((*qq_decls$sptr).value);
    }
    else {
        qq_lib$pcustype((byte*)"decr",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_chr(void) {
    if (((i64)(*qq_decls$sptr).tag == (i64)1)) {
        qq_strings$var_makechar((*qq_decls$sptr).value,qq_decls$sptr);
    }
    else {
        qq_lib$pcustype((byte*)"CHR",qq_decls$sptr);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_asc(void) {
        i64 c;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)9)) {
        if (!!((*(*qq_decls$sptr).objptr).length)) {
            c = (i64)(u64)(*(*(*qq_decls$sptr).objptr).strptr);
        }
        else {
            c = (i64)0;
        }
;
        qq_vars$var_unshareu(qq_decls$sptr);
        (*qq_decls$sptr).tagx = (i64)1;
        (*qq_decls$sptr).value = c;
    }
    else {
        qq_lib$pcustype((byte*)"ASC",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pusht(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)18;
    (*qq_decls$sptr).value = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_type(void) {
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)18;
    (*qq_decls$sptr).value = t;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_basetype(void) {
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    if ((t==(i64)12) || (t==(i64)13) || (t==(i64)7)) {
        t = (i64)qq_tables$ttbasetype[((i64)(*(*qq_decls$sptr).objptr).usertag)];
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)18;
    (*qq_decls$sptr).value = t;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_usertype(void) {
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    if ((t==(i64)12) || (t==(i64)13) || (t==(i64)7)) {
        t = (i64)(*(*qq_decls$sptr).objptr).usertag;
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)18;
    (*qq_decls$sptr).value = t;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_elemtype(void) {
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    if ((t==(i64)11) || (t==(i64)8)) {
        t = (i64)(*(*qq_decls$sptr).objptr).elemtag;
    }
    else if ((t==(i64)16) || (t==(i64)14) || (t==(i64)15)) {
        t = (i64)(*qq_decls$sptr).elemtag;
    }
    else if ((t==(i64)5)) {
        t = (i64)32;
    }
    else if ((t==(i64)7)) {
        t = (i64)qq_tables$tttarget[((i64)(*(*qq_decls$sptr).objptr).usertag)];
    }
    else {
        qq_lib$pcustype_t((byte*)"elemtype",t);
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)18;
    (*qq_decls$sptr).value = t;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_nop(void) {
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_modulecall(void) {
        struct qq_decls$strec *  d;
        i64 moduleno;
    d = (struct qq_decls$strec *)(*(qq_decls$pcptr + (i64)1));
    moduleno = (i64)(*d).moduleno;
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)20;
    (*qq_decls$sptr).retaddr = (qq_decls$pcptr + (i64)2);
    qq_decls$pcptr = (*qq_decls$modules[(moduleno)]).pcstart;
}

void qq_khandlers$k_modulereturn(void) {
    qq_decls$pcptr = (*qq_decls$sptr).retaddr;
    --(qq_decls$sptr);
}

void qq_khandlers$k_maxvalue(void) {
        i64 a;
    if (((i64)(*qq_decls$sptr).tag == (i64)18)) {
        (*qq_decls$sptr).tag = (*qq_decls$sptr).value;
    }
;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)26)) {
        a = (i64)255;
    }
    else if (($temp==(i64)27)) {
        a = (i64)65536;
    }
    else if (($temp==(i64)28)) {
        a = (i64)4294967295;
    }
    else if (($temp==(i64)29)) {
        a = (i64)-1;
    }
    else if (($temp==(i64)22)) {
        a = (i64)127;
    }
    else if (($temp==(i64)23)) {
        a = (i64)32767;
    }
    else if (($temp==(i64)24)) {
        a = (i64)2147483647;
    }
    else if (($temp==(i64)25) || ($temp==(i64)1)) {
        a = (i64)9223372036854775807;
    }
    else {
        qq_lib$pcustype((byte*)"MAXVALUE",qq_decls$sptr);
    }
    };
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = a;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_minvalue(void) {
        i64 a;
    if (((i64)(*qq_decls$sptr).tag == (i64)18)) {
        (*qq_decls$sptr).tag = (*qq_decls$sptr).value;
    }
;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)26) || ($temp==(i64)27) || ($temp==(i64)28) || ($temp==(i64)29)) {
        a = (i64)0;
    }
    else if (($temp==(i64)22)) {
        a = (i64)-128;
    }
    else if (($temp==(i64)23)) {
        a = (i64)-32768;
    }
    else if (($temp==(i64)24)) {
        a = (i64)-2147483648;
    }
    else if (($temp==(i64)1) || ($temp==(i64)25)) {
        a = (i64)(-9223372036854775807-1);
    }
    else {
        qq_lib$pcustype((byte*)"MINVALUE",qq_decls$sptr);
    }
    };
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = a;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_callhost(void) {
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    qq_host$callhostfunction(n);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_expand(void) {
        struct qq_decls$varrec *  dest;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    dest = ((qq_decls$sptr + n) - (i64)1);
    qq_vars$var_expand(qq_decls$sptr,dest,n);
    qq_decls$sptr = dest;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushsymbol(void) {
        struct qq_decls$strec *  d;
    d = (struct qq_decls$strec *)(*(qq_decls$pcptr + (i64)1));
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)17;
    (*qq_decls$sptr).def = (struct qq_decls$strec *)(*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_eq(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 res;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    res = qq_vars$var_equal(x,y);
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ne(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 res;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    res = (i64)!(!!(qq_vars$var_equal(x,y)));
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_lt(void) {
    qq_khandlers$do_cmp((i64)173);
}

void qq_khandlers$k_le(void) {
    qq_khandlers$do_cmp((i64)174);
}

void qq_khandlers$k_ge(void) {
    qq_khandlers$do_cmp((i64)175);
}

void qq_khandlers$k_gt(void) {
    qq_khandlers$do_cmp((i64)176);
}

static void qq_khandlers$do_cmp(i64 opc) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 res;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    res = qq_vars$var_compare(x,y);
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    if ((opc==(i64)173)) {
        (*qq_decls$sptr).value = (i64)(res < (i64)0);
    }
    else if ((opc==(i64)174)) {
        (*qq_decls$sptr).value = (i64)(res <= (i64)0);
    }
    else if ((opc==(i64)175)) {
        (*qq_decls$sptr).value = (i64)(res >= (i64)0);
    }
    else {
        (*qq_decls$sptr).value = (i64)(res > (i64)0);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_calldll(void) {
        struct qq_decls$strec *  d;
        i64 nargs;
    d = (struct qq_decls$strec *)(*(qq_decls$pcptr + (i64)1));
    nargs = (*(qq_decls$pcptr + (i64)2));
    qq_calldll$calldll(d,((qq_decls$sptr - nargs) + (i64)1),(qq_decls$sptr - nargs),nargs);
    qq_decls$sptr -= nargs;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_in(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 n;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    n = qq_vars$var_in(x,y);
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_notin(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 n;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    n = (i64)!(!!(qq_vars$var_in(x,y)));
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_inx(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 n;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    n = qq_vars$var_inx(x,y);
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_convrefpack(void) {
        struct qq_decls$varrec *  a;
        i64 elemtype;
        void *  p;
        struct qq_decls$objrec *  pa;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)14)) {
        a = (*qq_decls$sptr).varptr;
        pa = (*a).objptr;
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1) || ($temp==(i64)16)) {
            p = &(*a).value;
            elemtype = (i64)25;
        }
        else if (($temp==(i64)2)) {
            p = &(*a).value;
            elemtype = (i64)31;
        }
        else if (($temp==(i64)11)) {
            p = (*pa).ptr;
            elemtype = (i64)(*pa).elemtag;
        }
        else if (($temp==(i64)8)) {
            (*qq_decls$sptr).ptr = (*pa).ptr;
            (*qq_decls$sptr).bitoffset = ((i64)(*pa).indexoffset * (i64)qq_tables$ttbitwidth[((i64)(*pa).elemtag)]);
            (*qq_decls$sptr).bitlength = (i64)0;
            (*qq_decls$sptr).tagx = (i64)15;
            (*qq_decls$sptr).elemtag = (i64)(*pa).elemtag;
            ++(qq_decls$pcptr);
            return;
        }
        else if (($temp==(i64)5)) {
            (*qq_decls$sptr).ptr = (*pa).ptr;
            (*qq_decls$sptr).bitoffset = (i64)0;
            (*qq_decls$sptr).bitlength = (i64)0;
            (*qq_decls$sptr).tagx = (i64)15;
            (*qq_decls$sptr).elemtag = (i64)32;
            ++(qq_decls$pcptr);
            return;
        }
        else if (($temp==(i64)9)) {
            p = (void *)(*pa).strptr;
            elemtype = (i64)26;
            if ((p == 0)) {
                p = (byte*)"";
            }
;
        }
        else if (($temp==(i64)13)) {
            p = (*pa).ptr;
            elemtype = (i64)(*pa).usertag;
        }
        else if (($temp==(i64)7)) {
            p = (*pa).ptr;
            elemtype = (i64)(*pa).usertag;
        }
        else if (($temp==(i64)3)) {
            p = (*pa).num;
            elemtype = (i64)24;
        }
        else {
            qq_lib$pcustype((byte*)"Getrefpack1",a);
        }
        };
    }
    else if (($temp==(i64)16) || ($temp==(i64)15)) {
        ++(qq_decls$pcptr);
        return;
    }
    else {
        qq_lib$pcustype((byte*)"Getrefpack2",qq_decls$sptr);
    }
    };
    //done:
L199 :;
;
    (*qq_decls$sptr).tagx = (i64)16;
    (*qq_decls$sptr).ptr = (byte *)p;
    (*qq_decls$sptr).elemtag = elemtype;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isdef(void) {
        i64 res;
    res = (i64)((i64)(*qq_decls$sptr).tag != (i64)0);
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isvoid(void) {
        i64 res;
    res = (i64)((i64)(*qq_decls$sptr).tag == (i64)0);
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isint(void) {
    qq_khandlers$istype((i64)1,(i64)0);
}

void qq_khandlers$k_isnumber(void) {
        i64 res;
    if (((i64)(*qq_decls$sptr).tag == (i64)1 || (i64)(*qq_decls$sptr).tag == (i64)2 || (i64)(*qq_decls$sptr).tag == (i64)3)) {
        res = (i64)1;
    }
    else {
        res = (i64)0;
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ismutable(void) {
        i64 res;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        res = (i64)msysc$m_getdotindex((i64)(*(*qq_decls$sptr).objptr).flags,(i64)1);
    }
    else {
        res = (i64)1;
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isreal(void) {
    qq_khandlers$istype((i64)2,(i64)0);
}

void qq_khandlers$k_isrange(void) {
    qq_khandlers$istype((i64)4,(i64)0);
}

void qq_khandlers$k_isset(void) {
    qq_khandlers$istype((i64)5,(i64)0);
}

void qq_khandlers$k_ispointer(void) {
    qq_khandlers$istype((i64)14,(i64)16);
}

static void qq_khandlers$istype(i64 t1,i64 t2) {
        i64 res;
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    res = (i64)(t == t1);
    if ((!(!!(res)) && !!(t2))) {
        res = (i64)(t == t2);
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_convert(void) {
        struct qq_decls$varrec x;
        i64 t;
    t = (*(qq_decls$pcptr + (i64)1));
    if (((i64)(*qq_decls$sptr).tag != t)) {
        x = (*qq_decls$sptr);
        qq_vars$var_convert(&x,t,qq_decls$sptr);
        if (!!((i64)x.hasref)) {
            qq_vars$var_unshareu(&x);
        }
;
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_switch(void) {
        i64 index;
        i64 n;
        i64 lower;
    n = (*(qq_decls$pcptr + (i64)1));
    lower = (*(qq_decls$pcptr + (i64)2));
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1) || ($temp==(i64)18)) {
    }
    else {
        qq_lib$pcerror_s((byte*)"switch not int",qq_tables$ttname[((i64)(*qq_decls$sptr).tag)]);
    }
    };
    index = ((*qq_decls$sptr).value - lower);
    --(qq_decls$sptr);
    if (((u64)index >= (u64)n)) {
        qq_decls$pcptr = (i64 *)(*((qq_decls$pcptr + (n * (i64)2)) + (i64)4));
    }
    else {
        qq_decls$pcptr = (i64 *)(*((qq_decls$pcptr + (index * (i64)2)) + (i64)4));
    }
;
}

void qq_khandlers$k_bytesize(void) {
        i64 n;
        i64 t;
        struct qq_decls$objrec *  p;
    p = (*qq_decls$sptr).objptr;
    t = (i64)(*qq_decls$sptr).tag;
    if ((t==(i64)18)) {
        t = (*qq_decls$sptr).value;
    }
    else if ((t==(i64)13) || (t==(i64)12) || (t==(i64)7)) {
        t = (i64)(*(*qq_decls$sptr).objptr).usertag;
    }
;
    if ((t==(i64)11)) {
        n = ((*p).length * qq_tables$ttsize[((i64)(*p).elemtag)]);
    }
    else if ((t==(i64)5)) {
        n = qq_bits$getbitssize((*p).length,(i64)32);
    }
    else if ((t==(i64)9)) {
        n = (*p).length;
    }
    else if ((t==(i64)8)) {
        n = qq_bits$bits_bytesize(p);
    }
    else if ((t==(i64)10) || (t==(i64)6)) {
        n = ((*p).length * (i64)16);
    }
    else if ((t==(i64)12) || (t==(i64)13) || (t==(i64)7)) {
        n = qq_tables$ttsize[(t)];
    }
    else if ((t==(i64)3)) {
        n = (*p).length;
        if (!!(n)) {
            n = (n * (i64)4);
        }
;
    }
    else {
        n = qq_tables$ttsize[(t)];
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_bitwidth(void) {
    if (((i64)(*qq_decls$sptr).tag == (i64)18)) {
        (*qq_decls$sptr).value = (i64)qq_tables$ttbitwidth[((*qq_decls$sptr).value)];
    }
    else if (!!((i64)qq_tables$ttbitwidth[((i64)(*qq_decls$sptr).tag)])) {
        (*qq_decls$sptr).value = (i64)qq_tables$ttbitwidth[((i64)(*qq_decls$sptr).tag)];
    }
    else {
        qq_lib$pcerror((byte*)"bitwidth");
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_min(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if ((qq_vars$var_compare(x,y) < (i64)0)) {
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        (*qq_decls$sptr) = (*y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_max(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if ((qq_vars$var_compare(x,y) >= (i64)0)) {
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        (*qq_decls$sptr) = (*y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_addsp(void) {
    qq_decls$sptr -= (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushtry(void) {
    (*++(qq_decls$sptr)).tagx = (i64)21;
    (*qq_decls$sptr).ptr = (byte *)(*(qq_decls$pcptr + (i64)1));
    (*qq_decls$sptr).frameoffset = (qq_decls$frameptr - (byte *)qq_decls$sptr);
    (*qq_decls$sptr).exceptiontype = (*(qq_decls$pcptr + (i64)2));
    (*qq_decls$sptr).nexceptions = (*(qq_decls$pcptr + (i64)3));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
}

void qq_khandlers$k_raise(void) {
    if (((i64)(*qq_decls$sptr).tag != (i64)1)) {
        qq_lib$pcerror((byte*)"Raise: not Int on stack [not proceeding direct to RAISE]");
    }
;
    qq_decls$pcptr = qq_lib$raiseexception((*qq_decls$sptr).value);
}

void qq_khandlers$k_isequal(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 res;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if (((!!((i64)(*x).hasref) && !!((i64)(*y).hasref)) && ((*x).objptr == (*y).objptr))) {
        res = (i64)1;
    }
    else {
        res = (i64)0;
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_minto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_min,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_maxto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))qq_vars$var_max,0);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_power(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_power(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

static void qq_khandlers$domaths(i64 opcode) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        (*qq_decls$sptr).tagx = (i64)2;
        (*qq_decls$sptr).xvalue = qq_khandlers$getmaths(opcode,(r64)(*qq_decls$sptr).value);
    }
    else if (($temp==(i64)2)) {
        (*qq_decls$sptr).xvalue = qq_khandlers$getmaths(opcode,(*qq_decls$sptr).xvalue);
    }
    else {
        qq_lib$pcustype((byte*)"Maths:",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

static r64 qq_khandlers$getmaths(i64 opcode,r64 x) {
    if ((opcode==(i64)102)) {
        return sqrt(x);
    }
    else if ((opcode==(i64)104)) {
        return sin(x);
    }
    else if ((opcode==(i64)105)) {
        return cos(x);
    }
    else if ((opcode==(i64)106)) {
        return tan(x);
    }
    else if ((opcode==(i64)107)) {
        return asin(x);
    }
    else if ((opcode==(i64)108)) {
        return acos(x);
    }
    else if ((opcode==(i64)109)) {
        return atan(x);
    }
    else if ((opcode==(i64)111)) {
        return log10(x);
    }
    else if ((opcode==(i64)112)) {
        return log10(x);
    }
    else if ((opcode==(i64)113)) {
        return exp(x);
    }
    else if ((opcode==(i64)114)) {
        if ((x >= (double)0.)) {
            return floor((x + (double)0.5));
        }
        else {
            return ceil((x - (double)0.5));
        }
;
    }
    else if ((opcode==(i64)115)) {
        return floor(x);
    }
    else if ((opcode==(i64)116)) {
        x = ceil(x);
        if ((x == (double)0.)) {
            x = (double)0.;
        }
;
        return ceil(x);
    }
    else {
        qq_lib$pcerror_s((byte*)"Maths",qq_tables$pclnames[(opcode)]);
    }
;
    return (double)0.;
}

void qq_khandlers$k_typepun(void) {
    (*qq_decls$sptr).tagx = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_andlto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  x;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    x = (*px).varptr;
    if ((((i64)(*px).tag != (i64)14) || ((i64)(*x).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"andlto");
    }
;
    (*x).value &= qq_vars$var_istruel(y);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_orlto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  x;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    x = (*px).varptr;
    if ((((i64)(*px).tag != (i64)14) || ((i64)(*x).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"orlto");
    }
;
    (*x).value |= qq_vars$var_istruel(y);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_notlto(void) {
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  x;
    px = (qq_decls$sptr)--;
    x = (*px).varptr;
    if ((((i64)(*px).tag != (i64)14) || ((i64)(*x).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"notlto");
    }
;
    (*x).value ^= (i64)1;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pushoperator(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)19;
    (*qq_decls$sptr).value = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_maps(void) {
    qq_khandlers$k_mapss();
}

void qq_khandlers$k_mapss(void) {
        static i64 codeseq[10];
        i64 nargs;
        i64 $av_1;
        i64 i;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)19)) {
        codeseq[((i64)1)-1] = (i64)qq_tables$cmdmap[((*qq_decls$sptr).value)];
        --(qq_decls$sptr);
        codeseq[((i64)2)-1] = (*(qq_decls$pcptr + (i64)1));
        codeseq[((i64)3)-1] = (*(qq_decls$pcptr + (i64)2));
    }
    else if (($temp==(i64)17)) {
        nargs = (((*qq_decls$pcptr) == (i64)qq_tables$cmdmap[((i64)214)]) ? (i64)1 : (i64)2);
                ($av_1 = -((nargs + (i64)1)));
        for (i=(i64)0;i>=$av_1;--i) {
L200 :;
            (*((qq_decls$sptr + i) + (i64)1)) = (*(qq_decls$sptr + i));
L201 :;
        }
L202 :;
        ;
        (*(qq_decls$sptr - nargs)).tagx = (i64)0;
        ++(qq_decls$sptr);
        codeseq[((i64)1)-1] = (i64)qq_tables$cmdmap[((i64)61)];
        codeseq[((i64)2)-1] = nargs;
        codeseq[((i64)3)-1] = (i64)0;
        codeseq[((i64)4)-1] = (*(qq_decls$pcptr + (i64)1));
        codeseq[((i64)5)-1] = (*(qq_decls$pcptr + (i64)2));
    }
    else {
        qq_lib$pcerror((byte*)"Apply:no op");
    }
    };
    qq_decls$pcptr = &codeseq[((i64)1)-1];
}

void qq_khandlers$k_idivrem(void) {
    qq_lib$pcerror((byte*)"IDIVREM");
}

void qq_khandlers$k_odd(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        (*qq_decls$sptr).value = (i64)msysc$m_getdotindex((*qq_decls$sptr).value,(i64)0);
    }
    else {
        qq_lib$pcustype((byte*)"Odd",qq_decls$sptr);
    }
    };
    (*qq_decls$sptr).tagx = (i64)1;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_even(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        (*qq_decls$sptr).value = (i64)!(msysc$m_getdotindex((*qq_decls$sptr).value,(i64)0));
    }
    else {
        qq_lib$pcustype((byte*)"Even",qq_decls$sptr);
    }
    };
    (*qq_decls$sptr).tagx = (i64)1;
    ++(qq_decls$pcptr);
}

// START
void qq_khandlers$start(void) {

}

void qq_host$callhostfunction(i64 hostfn) {
        void (*fnaddr)(void);
        i64 nparams;
        i64 isfn;
        i64 $av_1;
    fnaddr = (void (*)(void))qq_tables$hosthandlers[(hostfn)];
    nparams = (i64)qq_tables$hostnparams[(hostfn)];
    isfn = (i64)qq_tables$hostisfn[(hostfn)];
    if ((fnaddr == 0)) {
        qq_lib$pcerror_s((byte*)"Hostfn not implemented:",qq_tables$hostfnnames[(hostfn)]);
    }
;
        {i64 $temp = (nparams + isfn);
if (($temp==(i64)0)) {
        ((*(void (*)(void))fnaddr))();
    }
    else if (($temp==(i64)1)) {
        ((*(void (*)(struct qq_decls$varrec *,...))fnaddr))(qq_decls$sptr);
    }
    else if (($temp==(i64)2)) {
        ((*(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,...))fnaddr))(qq_decls$sptr,(qq_decls$sptr - (i64)1));
    }
    else if (($temp==(i64)3)) {
        ((*(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,...))fnaddr))(qq_decls$sptr,(qq_decls$sptr - (i64)1),(qq_decls$sptr - (i64)2));
    }
    else if (($temp==(i64)4)) {
        ((*(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,...))fnaddr))(qq_decls$sptr,(qq_decls$sptr - (i64)1),(qq_decls$sptr - (i64)2),(qq_decls$sptr - (i64)3));
    }
    else if (($temp==(i64)5)) {
        ((*(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,...))fnaddr))(qq_decls$sptr,(qq_decls$sptr - (i64)1),(qq_decls$sptr - (i64)2),(qq_decls$sptr - (i64)3),(qq_decls$sptr - (i64)4));
    }
    else {
        qq_lib$pcerror((byte*)"callhost/proc");
    }
    };
    $av_1 = nparams;
    while ($av_1-- > 0) {
L203 :;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            if (!!((i64)(*qq_decls$sptr).hasref)) {
                qq_vars$var_unshareu(qq_decls$sptr);
            }
;
        }
;
        --(qq_decls$sptr);
L204 :;
    }
L205 :;
    ;
}

void qq_host$pch_leftstr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
        i64 n;
        i64 length;
        i64 padchar;
        u8 *  s;
        struct qq_decls$objrec *  pa;
    padchar = (i64)32;
        {i64 $temp = (i64)(*c).tag;
if (($temp==(i64)0)) {
    }
    else if (($temp==(i64)9)) {
        if (((*(*c).objptr).length == (i64)1)) {
            padchar = (i64)(u64)(*(*(*c).objptr).strptr);
        }
        else {
            qq_lib$pcerror((byte*)"left/padx");
        }
;
    }
    else if (($temp==(i64)1)) {
        padchar = (*c).value;
    }
    else {
        qq_lib$pcerror((byte*)"left/pad?");
    }
    };
        {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)0)) {
        n = (i64)1;
    }
    else if (($temp==(i64)1)) {
        n = (*b).value;
    }
    else {
        qq_lib$pcerror((byte*)"left:bad n");
    }
    };
    if (((i64)(*a).tag != (i64)9)) {
        qq_lib$pcerror((byte*)"left:not str");
    }
;
    pa = (*a).objptr;
    length = (*pa).length;
    s = (*pa).strptr;
    if ((n == (i64)0)) {
        qq_strings$var_empty_string(result,(i64)1);
        return;
    }
;
    (*result).tagx = (i64)265;
    if ((n > (i64)0)) {
        if ((n <= length)) {
            qq_host$leftstring(a,n,result);
        }
        else {
            qq_host$padstring_right(a,n,padchar,result);
        }
;
    }
    else {
        n = -(n);
        if ((n < length)) {
            qq_host$leftstring(a,(length - n),result);
        }
        else {
            qq_strings$var_empty_string(result,(i64)1);
        }
;
    }
;
}

void qq_host$pch_rightstr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
        i64 n;
        i64 length;
        i64 padchar;
        u8 *  s;
        struct qq_decls$objrec *  pa;
    padchar = (i64)32;
        {i64 $temp = (i64)(*c).tag;
if (($temp==(i64)0)) {
    }
    else if (($temp==(i64)9)) {
        if (((*(*c).objptr).length == (i64)1)) {
            padchar = (i64)(u64)(*(*(*c).objptr).strptr);
        }
        else {
            qq_lib$pcerror((byte*)"right/padx");
        }
;
    }
    else if (($temp==(i64)1)) {
        padchar = (*c).value;
    }
    else {
        qq_lib$pcerror((byte*)"right/pad?");
    }
    };
        {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)0)) {
        n = (i64)1;
    }
    else if (($temp==(i64)1)) {
        n = (*b).value;
    }
    else {
        qq_lib$pcerror((byte*)"right:bad n");
    }
    };
    pa = (*a).objptr;
    if (((i64)(*a).tag != (i64)9)) {
        qq_lib$pcerror((byte*)"right:not str");
    }
;
    length = (*pa).length;
    s = (*pa).strptr;
    (*result).tagx = (i64)265;
    if ((n == (i64)0)) {
        qq_strings$var_empty_string(result,(i64)1);
        return;
    }
;
    if ((n > (i64)0)) {
        if ((n <= length)) {
            qq_host$rightstring(a,n,result);
        }
        else {
            qq_host$padstring_left(a,n,padchar,result);
        }
;
    }
    else {
        n = -(n);
        if ((n < length)) {
            qq_host$rightstring(a,(length - n),result);
        }
        else {
            qq_strings$var_empty_string(result,(i64)1);
        }
;
    }
;
}

void qq_host$pch_convlc(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)9,(i64)-999999);
    (*result) = (*a);
    ++((*(*result).objptr).refcount);
    qq_vars$var_duplu(result);
    qq_strings$var_iconvcase(result,b,(i64)0);
}

void qq_host$pch_convuc(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)9,(i64)-999999);
    (*result) = (*a);
    ++((*(*result).objptr).refcount);
    if (!!((i64)(*result).hasref)) {
        if (!!((i64)(*result).hasref)) {
            qq_vars$var_duplu(result);
        }
;
    }
;
    qq_strings$var_iconvcase(result,b,(i64)1);
}

void qq_host$pch_waitkey(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mlinux$os_getch();
}

void qq_host$pch_execwait(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
        u8 *  workdir;
        i64 flag;
        struct qq_decls$objrec *  pa;
    qq_host$checkparam(a,(i64)9,(i64)-999999);
    pa = (*a).objptr;
    flag = qq_host$checkparam(b,(i64)1,(i64)0);
    if (((i64)(*c).tag == (i64)0)) {
        workdir = 0;
    }
    else {
        qq_host$checkparam(c,(i64)9,(i64)-999999);
        workdir = qq_lib$convtostringz((*(*c).objptr).strptr,(*(*c).objptr).length);
    }
;
    (*result).tagx = (i64)1;
    (*result).value = mlinux$os_execwait(qq_lib$convtostringz((*pa).strptr,(*pa).length),flag,workdir);
}

void qq_host$pch_execcmd(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
        u8 *  workdir;
        i64 flag;
        struct qq_decls$objrec *  pa;
    qq_host$checkparam(a,(i64)9,(i64)-999999);
    pa = (*a).objptr;
    flag = qq_host$checkparam(b,(i64)1,(i64)0);
    if (((i64)(*c).tag == (i64)0)) {
        workdir = 0;
    }
    else {
        qq_host$checkparam(c,(i64)9,(i64)-999999);
        workdir = qq_lib$convtostringz((*(*c).objptr).strptr,(*(*c).objptr).length);
    }
;
    (*result).tagx = (i64)1;
    (*result).value = mlinux$os_execcmd(qq_lib$convtostringz((*pa).strptr,(*pa).length),flag);
}

void qq_host$pch_makestr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
        i64 n;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)16)) {
    }
    else if (($temp==(i64)1)) {
    }
    else {
        qq_lib$pcerror((byte*)"makestr");
    }
    };
    n = qq_vars$var_getintvalue(b);
    (*result).tagx = (i64)265;
    (*result).objptr = qq_strings$obj_make_strslicexobj((u8 *)(*a).ptr,n);
}

void qq_host$pch_makeref(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
        byte *  ptr;
        {i64 $temp = (i64)qq_tables$ttbasetype[((i64)(*a).tag)];
if (($temp==(i64)14) || ($temp==(i64)16) || ($temp==(i64)1)) {
        ptr = (*a).ptr;
    }
    else if (($temp==(i64)9) || ($temp==(i64)11) || ($temp==(i64)10) || ($temp==(i64)5)) {
        ptr = (*(*a).objptr).ptr;
    }
    else {
        qq_lib$pcerror((byte*)"makeref");
    }
    };
    (*result).tagx = (i64)16;
    (*result).ptr = ptr;
    (*result).elemtag = qq_vars$var_getintvalue(b);
        {i64 $temp = (i64)(*result).elemtag;
if (($temp==(i64)32) || ($temp==(i64)33) || ($temp==(i64)34)) {
        (*result).tag = (i64)15;
        (*result).bitoffset = (i64)0;
        (*result).bitlength = (i64)0;
    }
    };
}

void qq_host$pch_getcmdparam(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        i64 n;
    if (((i64)(*a).tag == (i64)0)) {
        (*result).tagx = (i64)1;
        (*result).value = qq_decls$nqparams;
        return;
    }
;
    n = qq_vars$var_getintvalue(a);
    if (!((($rtemp=n, $rtemp >= (i64)1 && $rtemp <= qq_decls$nqparams)))) {
        qq_lib$pcerror((byte*)"getcmdpm");
    }
;
    qq_strings$var_make_string(qq_decls$qparamtable[(n)-1],result,(i64)0);
}

void qq_host$pch_clock(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mlinux$os_clock();
}

void qq_host$pch_allocexec(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        i64 n;
        byte *  p;
    n = qq_vars$var_getintvalue(a);
    p = mlinux$os_allocexecmem(n);
    (*result).tagx = (i64)16;
    (*result).ptr = p;
    (*result).elemtag = (i64)26;
}

void qq_host$pch_runnative(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
        i64 (*fnptr)(i64,...);
    if (((i64)(*a).tag != (i64)16)) {
        qq_lib$pcerror((byte*)"runnative?");
    }
;
    fnptr = (i64 (*)(i64,...))(*a).ptr;
    (*result).value = ((*fnptr))((*b).value);
    (*result).tagx = (i64)1;
}

void qq_host$pch_setlwb(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 n;
        struct qq_decls$objrec *  p;
    if (!(!!((i64)(*a).hasref))) {
        goto L206 ;
;
    }
;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    n = qq_host$checkparam(b,(i64)1,(i64)-999999);
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)10)) {
        if (!((($rtemp=n, $rtemp >= (i64)-32768 && $rtemp <= (i64)32767)))) {
            qq_lib$pcerror((byte*)"lwb not i16");
        }
;
        (*p).lower16 = n;
    }
    else if (($temp==(i64)11) || ($temp==(i64)8)) {
        if (!((($rtemp=n, $rtemp >= (i64)0 && $rtemp <= (i64)1)))) {
            qq_lib$pcerror((byte*)"lwb not 0/1");
        }
;
        (*p).flags = msysc$m_setdotindex((*p).flags,(i64)0,(u64)n);
    }
    else {
        //error:
L206 :;
;
        qq_lib$pcerror((byte*)"Can't set lwb");
    }
    };
}

void qq_host$pch_ticks(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mlinux$os_ticks();
}

void qq_host$pch_sleep(struct qq_decls$varrec *a) {
    qq_host$checkparam(a,(i64)1,(i64)-999999);
    mlinux$os_sleep((*a).value);
}

void qq_host$pch_random(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        i64 n;
        i64 x;
    (*result).tagx = (i64)1;
    if (((i64)(*a).tag == (i64)4)) {
        x = mlib$mrandomrange(msysc$m_getdotslice((*a).dummy,(i64)16,(i64)63),(i64)(*a).range_upper);
    }
    else {
        qq_host$checkparam(a,(i64)1,(i64)-999999);
        n = (*a).value;
        if ((n > (i64)1)) {
            x = mlib$mrandomint(n);
        }
        else if ((n == (i64)0)) {
            x = (i64)mlib$mrandom();
        }
        else if ((n == (i64)1)) {
            (*result).tagx = (i64)2;
            (*result).xvalue = mlib$mrandomreal();
            return;
        }
        else {
            mlib$mseed((u64)-(n),(u64)0u);
            x = (i64)0;
        }
;
    }
;
    (*result).value = x;
}

void qq_host$pch_system(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)9,(i64)-999999);
    (*result).tagx = (i64)1;
    (*result).value = system(qq_lib$convtostringz((*(*a).objptr).strptr,(*(*a).objptr).length));
}

void qq_host$pch_$getparam(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)1,(i64)-999999);
    (*result) = (*(struct qq_decls$varrec *)(qq_decls$frameptr - ((*a).value * (i64)16)));
    if (!!((i64)(*result).hasref)) {
        ++((*(*result).objptr).refcount);
    }
;
}

static i64 qq_host$checkparam(struct qq_decls$varrec *p,i64 tag,i64 defaultx) {
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)0)) {
        if ((defaultx == (i64)-999999)) {
            qq_lib$pcerror((byte*)"Missing host param");
        }
;
        return defaultx;
    }
    else if (($temp==tag)) {
        return (*p).value;
    }
    };
    if ((tag == (i64)1)) {
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)2)) {
            return (i64)(*p).xvalue;
        }
        };
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_lib$pcerror((byte*)"Host param wrong type");
    return (i64)0;
}

static void qq_host$leftstring(struct qq_decls$varrec *a,i64 n,struct qq_decls$varrec *result) {
    qq_strings$var_make_stringn((*(*a).objptr).strptr,n,result,(i64)1);
}

static void qq_host$rightstring(struct qq_decls$varrec *a,i64 n,struct qq_decls$varrec *result) {
    qq_strings$var_make_stringn(((*(*a).objptr).strptr + ((*(*a).objptr).length - n)),n,result,(i64)1);
}

static void qq_host$padstring_right(struct qq_decls$varrec *a,i64 n,i64 fillchar,struct qq_decls$varrec *result) {
        u8 *  s;
        i64 length;
        i64 $av_1;
    length = (*(*a).objptr).length;
    qq_strings$var_new_stringn(n,result);
    s = (*(*result).objptr).strptr;
    if (!!(length)) {
        memcpy((void *)s,(void *)(*(*a).objptr).strptr,(u64)length);
        s += length;
    }
;
    $av_1 = (n - length);
    while ($av_1-- > 0) {
L207 :;
        (*s) = (u64)fillchar;
        ++(s);
L208 :;
    }
L209 :;
    ;
}

static void qq_host$padstring_left(struct qq_decls$varrec *a,i64 n,i64 fillchar,struct qq_decls$varrec *result) {
        u8 *  s;
        i64 length;
        i64 padlen;
        i64 $av_1;
    length = (*(*a).objptr).length;
    padlen = (n - length);
    qq_strings$var_make_stringn(0,n,result,(i64)0);
    s = (*(*result).objptr).strptr;
    s += padlen;
    if (!!(length)) {
        memcpy((void *)s,(void *)(*(*a).objptr).strptr,(u64)length);
    }
;
    $av_1 = padlen;
    while ($av_1-- > 0) {
L210 :;
        --(s);
        (*s) = (u64)fillchar;
L211 :;
    }
L212 :;
    ;
}

static void qq_host$getbounds(struct qq_decls$varrec *p,struct qq_host$dimrec *dims,i64 lower) {
        i64 n;
    if (!(!!(p))) {
        qq_lib$pcerror((byte*)"New: no bounds");
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)0)) {
        (*dims).lbound = lower;
        (*dims).upper = (i64)0;
        (*dims).length = (i64)0;
    }
    else if (($temp==(i64)4)) {
        (*dims).lbound = msysc$m_getdotslice((*p).dummy,(i64)16,(i64)63);
        (*dims).upper = (i64)(*p).range_upper;
        (*dims).length = (((i64)(*p).range_upper - msysc$m_getdotslice((*p).dummy,(i64)16,(i64)63)) + (i64)1);
        if (((*dims).length < (i64)0)) {
            (*dims).length = (i64)0;
            (*dims).upper = ((*dims).lbound - (i64)1);
        }
;
    }
    else {
        n = qq_vars$var_getintvalue(p);
        (*dims).lbound = lower;
        (*dims).upper = ((*dims).length = n);
    }
    };
}

void qq_host$pch_new(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *d,struct qq_decls$varrec *result) {
        struct qq_decls$varrec v;
        i64 t;
        i64 offset;
        i64 elemtype;
        i64 usertag;
        struct qq_host$dimrec dims;
        byte *  qbyte;
        struct qq_decls$objrec *  p;
        i64 $av_1;
        i64 $av_2;
    t = qq_vars$var_getintvalue(a);
    if (((t < (i64)0) || (t > qq_tables$ntypes))) {
        qq_lib$pcustype_t((byte*)"New:bad type",t);
    }
;
    v.tagx = (t | (i64)256);
    usertag = (i64)0;
    switch ((i64)qq_tables$ttbasetype[(t)]) {
    case 9:;
        {
            qq_strings$var_new_string(b,c,result);
            return;
        }
        break;
    case 10:;
        {
            qq_host$getbounds(b,&dims,(i64)1);
            p = qq_lists$obj_newlist(dims.length,dims.lbound,c);
            v.objptr = p;
        }
        break;
    case 11:;
        {
            elemtype = qq_vars$var_getintvalue(b);
            qq_host$getbounds(c,&dims,(i64)1);
            if (((elemtype >= (i64)32) && (elemtype <= (i64)34))) {
                v.tag = (t = (i64)8);
                goto L213 ;
;
            }
;
            p = qq_arrays$obj_newarray(elemtype,dims.lbound,dims.length);
            //doarray2:
L214 :;
;
            v.objptr = p;
            if (!!(dims.length)) {
                if ((!!(d) && ((i64)(*d).tag != (i64)0))) {
                    qbyte = (*p).ptr;
                    $av_1 = dims.length;
                    while ($av_1-- > 0) {
L215 :;
                        qq_packed$var_storepacked(qbyte,d,elemtype);
                        qbyte += qq_tables$ttsize[(elemtype)];
L216 :;
                    }
L217 :;
                    ;
                }
;
            }
;
        }
        break;
    case 7:;
        {
            usertag = t;
            v.tag = (i64)7;
            elemtype = (i64)qq_tables$tttarget[(t)];
            dims.length = qq_tables$ttlength[(t)];
            dims.lbound = qq_tables$ttlower[(t)];
            dims.upper = ((dims.length + dims.lbound) - (i64)1);
            d = b;
            p = qq_arrays$obj_newarray_u(t);
            goto L214 ;
;
        }
        break;
    case 8:;
        {
            elemtype = qq_vars$var_getintvalue(b);
            if (!((($rtemp=elemtype, $rtemp >= (i64)32 && $rtemp <= (i64)34)))) {
                qq_lib$pcerror((byte*)"new: bad bits elem");
            }
;
            qq_host$getbounds(c,&dims,(i64)1);
            //dobits2:
L213 :;
;
            p = qq_bits$obj_newbits(elemtype,dims.lbound,dims.length);
            v.objptr = p;
            if (!!(dims.length)) {
                if ((!!(d) && ((i64)(*d).tag != (i64)0))) {
                    qbyte = (*p).ptr;
                    offset = (i64)0;
                    $av_2 = dims.length;
                    while ($av_2-- > 0) {
L218 :;
                        qq_vars$var_storebit(qbyte,offset,d,elemtype,(i64)0);
                        offset += (i64)qq_tables$ttbitwidth[(elemtype)];
                        if ((offset >= (i64)8)) {
                            offset = (i64)0;
                            ++(qbyte);
                        }
;
L219 :;
                    }
L220 :;
                    ;
                }
;
            }
;
        }
        break;
    case 5:;
        {
            qq_host$getbounds(b,&dims,(i64)0);
            if ((dims.lbound < (i64)0)) {
                qq_lib$pcerror((byte*)"new:set:lwb");
            }
;
            if ((dims.lbound != (i64)0)) {
                dims.lbound = (i64)0;
                dims.length = (dims.upper + (i64)1);
            }
;
            p = qq_sets$obj_newset(dims.length);
            v.objptr = p;
        }
        break;
    case 12:;
        {
            p = qq_records$obj_new_record(t,b);
            qq_vars$var_fromobj(t,p,&v);
            v.tag = (i64)12;
            usertag = t;
        }
        break;
    case 13:;
        {
            p = qq_packed$obj_new_struct(t);
            qq_vars$var_objtovar(t,p,&v);
            v.tag = (i64)13;
            usertag = t;
            if ((!!(b) && ((i64)(*b).tag != (i64)0))) {
                qq_lib$pcerror((byte*)"New: struct init");
            }
;
        }
        break;
    case 1:;
    case 2:;
    case 14:;
        {
            v.value = (i64)0;
            v.hasref = (i64)0;
            if ((!!(b) && ((i64)(*b).tag != (i64)0))) {
                qq_lib$pcerror((byte*)"NEW(int/value)");
            }
;
        }
        break;
    case 6:;
        {
            qq_host$getbounds(b,&dims,(i64)1);
            if ((dims.lbound != (i64)1)) {
                qq_lib$pcerror((byte*)"new:dict:lwb");
            }
;
            p = qq_dicts$obj_new_dict(dims.length);
            v.objptr = p;
        }
        break;
    case 3:;
        {
            qq_decimal$var_empty_dec(result);
            return;
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"new",t);
    }
    } //SW
;
    //finish:
L221 :;
;
    if (!!(usertag)) {
        (*v.objptr).usertag = usertag;
    }
;
    (*result) = v;
}

void qq_host$pch_gethostname(struct qq_decls$varrec *result) {
        static u8 name[256];
    strcpy(name,mlinux$os_gethostname());
    qq_strings$var_make_string(name,result,(i64)0);
}

void qq_host$pch_getprogname(struct qq_decls$varrec *result) {
        static u8 name[256];
    strcpy(name,qq_api$inputfile);
    qq_strings$var_make_string(name,result,(i64)0);
}

void qq_host$pch_$test(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = (((*a).value + (*b).value) + (*c).value);
}

void qq_host$pch_$test2(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)0;
}

void qq_host$pch_$refcount(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    if (!!((i64)(*a).hasref)) {
        (*result).value = (i64)(*(*a).objptr).refcount;
    }
    else {
        (*result).value = (i64)0;
    }
;
}

void qq_host$pch_testkey(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mlinux$os_kbhit();
}

void qq_host$pch_getos(struct qq_decls$varrec *result) {
    qq_strings$var_make_string(mlinux$os_getos(),result,(i64)0);
}

void qq_host$pch_setmesshandler(struct qq_decls$varrec *fn) {
    if ((((i64)(*fn).tag != (i64)17) || ((i64)(*(*fn).def).nameid != (i64)5))) {
        qq_lib$pcerror((byte*)"Not proc ref");
    }
;
    qq_decls$pcl_callbackfn = (void (*)(void))(*(*fn).def).pcaddress;
    mlinux$os_setmesshandler(&qq_api$runproc_m);
}

void qq_host$pch_$smallmemtotal(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = (mlib$smallmemtotal / (i64)16);
}

void qq_host$pch_$id(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = (*a).value;
}

void qq_host$pch_iswindows(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mlinux$os_iswindows();
}

void qq_host$pch_$setdebug(struct qq_decls$varrec *a) {
    qq_host$checkparam(a,(i64)1,(i64)-999999);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"SETDEBUG.................",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$fdebug = (*a).value;
}

void qq_host$pch_copy(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
    (*dest) = (*a);
    if (!!((i64)(*dest).hasref)) {
        qq_vars$var_duplu(dest);
    }
;
}

void qq_host$pch_gethash(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = qq_vars$var_gethashvalue(a);
}

void qq_host$pch_makeempty(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        struct qq_decls$objrec *  p;
        i64 t;
    t = (i64)qq_tables$ttbasetype[((i64)(*a).tag)];
    if ((t == (i64)18)) {
        t = (*a).value;
    }
;
    p = (*a).objptr;
    if ((t==(i64)10)) {
        qq_lists$var_empty_list((i64)(*p).lower16,result);
        return;
    }
    else if ((t==(i64)9)) {
        p = qq_strings$emptystring;
        ++((*p).refcount);
    }
    else if ((t==(i64)11)) {
        qq_arrays$var_empty_array(t,(i64)(*p).elemtag,(i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0),result);
        return;
    }
    else {
        qq_lib$pcustype_t((byte*)"makeempty?",t);
    }
;
    (*result).tagx = (t | (i64)256);
    (*result).objptr = p;
}

void qq_host$pch_$infinity(struct qq_decls$varrec *dest) {
    qq_decimal$var_setinf(dest);
}

void qq_host$pch_$nan(struct qq_decls$varrec *dest) {
    qq_decimal$var_setnan(dest);
}

void qq_host$setcmdparam(i64 index,u8 *s) {
    if ((s == 0)) {
        qq_decls$nqparams = index;
    }
    else if ((index <= (i64)32)) {
        qq_decls$qparamtable[(index)-1] = mlib$pcm_copyheapstring(s);
        qq_decls$nqparams=(qq_decls$nqparams>index?qq_decls$nqparams:index);
;
    }
;
}

void qq_host$pch_$nprocs(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = qq_decls$nproclist;
}

static void qq_host$initprocrefs(void) {
        struct qq_decls$procrec *  pp;
        static i64 oldnprocs;
        i64 i;
    if ((oldnprocs == qq_decls$nproclist)) {
        return;
    }
;
    qq_host$procrefs = (struct qq_decls$strec *(*)[])mlib$pcm_alloc((qq_decls$nproclist * (i64)8));
    pp = (struct qq_decls$procrec *)qq_decls$proclist;
    for (i=(i64)1;i<=qq_decls$nproclist;++i) {
L222 :;
        (*qq_host$procrefs)[(i)-1] = (*pp).def;
        pp = (struct qq_decls$procrec *)(*pp).nextproc;
L223 :;
    }
L224 :;
    ;
    oldnprocs = qq_decls$nproclist;
}

void qq_host$pch_$procname(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        i64 n;
    n = qq_host$checkparam(a,(i64)1,(i64)-999999);
    qq_host$initprocrefs();
    qq_strings$var_make_string((*(*qq_host$procrefs)[(n)-1]).name,result,(i64)0);
}

void qq_host$pch_$procref(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        i64 n;
    n = qq_host$checkparam(a,(i64)1,(i64)-999999);
    qq_host$initprocrefs();
    (*result).tagx = (i64)17;
    (*result).def = (*qq_host$procrefs)[(n)-1];
}

// START
void qq_host$start(void) {

}

void qq_lex$lexreadtoken(void) {
        i64 c;
        i64 hsum;
        i64 commentseen;
    qq_decls$nextlx.subcode = (i64)0;
    L225 :;
    switch ((qq_lex$lxstart = qq_lex$lxsptr, (i64)(u64)(*(qq_lex$lxsptr)++))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
        {
            //dolower:
L227 :;
;
            qq_decls$nextlx.svalue = (qq_lex$lxsptr - (i64)1);
            //doname:
L228 :;
;
            hsum = (i64)(u64)(*qq_decls$nextlx.svalue);
            L229 :;
                        {i64 $temp = (i64)qq_lex$namemap[((c = (i64)(u64)(*(qq_lex$lxsptr)++)))];
if (($temp==(i64)1)) {
                hsum = (((hsum << (i64)4) - hsum) + c);
            }
            else if (($temp==(i64)2)) {
                (*(qq_lex$lxsptr - (i64)1)) = (u64)(c + (i64)32);
                hsum = ((((hsum << (i64)4) - hsum) + c) + (i64)32);
            }
            else {
                --(qq_lex$lxsptr);
                goto L230 ;
            }
            }goto L229 ;
L230 :;
            ;
            qq_lex$lookup(qq_decls$nextlx.svalue,(qq_lex$lxsptr - qq_decls$nextlx.svalue),(((hsum << (i64)5) - hsum) & (i64)32767));
            return;
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
        {
            //doupper:
L231 :;
;
            qq_decls$nextlx.svalue = (qq_lex$lxsptr - (i64)1);
            (*qq_decls$nextlx.svalue) += (u8)(i64)32;
            goto L228 ;
;
        }
        break;
    case 102:;
        {
            if (((u64)(*qq_lex$lxsptr) != '"')) {
                goto L227 ;
;
            }
;
            qq_lex$readrawstring();
            return;
        }
        break;
    case 70:;
        {
            if (((u64)(*qq_lex$lxsptr) != '"')) {
                goto L231 ;
;
            }
;
            qq_lex$readrawstring();
            return;
        }
        break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp==')') || ($temp==(u64)13u) || ($temp==',') || ($temp==' ')) {
                qq_decls$nextlx.symbol = (i64)73;
                qq_decls$nextlx.subcode = (i64)1;
                qq_decls$nextlx.value = (i64)((u64)(*qq_lex$lxstart) - '0');
            }
            else if (($temp=='x') || ($temp=='X')) {
                                {u64 $temp = (u64)(*qq_lex$lxstart);
if (($temp=='0')) {
                    ++(qq_lex$lxsptr);
                    qq_lex$readhex();
                }
                else if (($temp=='2')) {
                    ++(qq_lex$lxsptr);
                    qq_lex$readbin();
                }
                else {
                    qq_lib$lxerror((byte*)"Bad base");
                }
                };
            }
            else {
                --(qq_lex$lxsptr);
                qq_lex$readdec();
            }
            };
            return;
        }
        break;
    case 33:;
    case 35:;
        {
            //docomment:
L232 :;
;
            L233 :;
                        {i64 $temp = (c = (i64)(u64)(*(qq_lex$lxsptr)++));
if (($temp==(i64)13)) {
                ++(qq_lex$lxsptr);
                goto L234 ;
            }
            else if (($temp==(i64)10)) {
                goto L234 ;
            }
            else if (($temp==(i64)26) || ($temp==(i64)0)) {
                --(qq_lex$lxsptr);
                goto L234 ;
            }
            }goto L233 ;
L234 :;
            ;
            qq_decls$nextlx.symbol = (i64)70;
            return;
        }
        break;
    case 92:;
        {
            commentseen = (i64)0;
            L235 :;
                        {u64 $temp = (u64)(*(qq_lex$lxsptr)++);
if (($temp==(u64)13u)) {
                ++(qq_lex$lxsptr);
                ++(qq_decls$nalllines);
                goto L236 ;
            }
            else if (($temp==(u64)10u)) {
                ++(qq_decls$nalllines);
                goto L236 ;
            }
            else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
                qq_decls$nextlx.symbol = (i64)71;
                --(qq_lex$lxsptr);
                return;
            }
            else if (($temp==' ') || ($temp==(u64)9u)) {
            }
            else if (($temp=='!')) {
                commentseen = (i64)1;
            }
            else {
                if (!(!!(commentseen))) {
                    qq_lib$lxerror((byte*)"\\ not followed by eol");
                }
;
            }
            }goto L235 ;
L236 :;
            ;
            L237 :;
                        {u64 $temp = (u64)(*(qq_lex$lxsptr)++);
if (($temp==(u64)13u)) {
                ++(qq_lex$lxsptr);
                ++(qq_decls$nalllines);
            }
            else if (($temp==(u64)10u)) {
                ++(qq_decls$nalllines);
            }
            else if (($temp==' ') || ($temp==(u64)9u)) {
            }
            else {
                --(qq_lex$lxsptr);
                goto L238 ;
            }
            }goto L237 ;
L238 :;
            ;
        }
        break;
    case 123:;
        {
            qq_decls$nextlx.symbol = (i64)16;
            return;
        }
        break;
    case 125:;
        {
            qq_decls$nextlx.symbol = (i64)17;
            return;
        }
        break;
    case 46:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='.')) {
                ++(qq_lex$lxsptr);
                if (((u64)(*qq_lex$lxsptr) == '.')) {
                    ++(qq_lex$lxsptr);
                    qq_decls$nextlx.symbol = (i64)25;
                }
                else {
                    qq_decls$nextlx.symbol = (i64)24;
                    qq_decls$nextlx.subcode = (i64)183;
                }
;
                return;
            }
            else {
                if ((($rtemp=(u64)(*qq_lex$lxsptr), $rtemp >= (i64)48 && $rtemp <= (i64)57))) {
                    --(qq_lex$lxsptr);
                    qq_lex$readreal();
                    return;
                }
                else {
                    qq_decls$nextlx.symbol = (i64)2;
                    return;
                }
;
            }
            };
        }
        break;
    case 44:;
        {
            qq_decls$nextlx.symbol = (i64)4;
            return;
        }
        break;
    case 59:;
        {
            qq_decls$nextlx.symbol = (i64)5;
            return;
        }
        break;
    case 58:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='=')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)8;
                qq_decls$nextlx.subcode = (i64)2;
            }
            else if (($temp==':')) {
                ++(qq_lex$lxsptr);
                                {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='=')) {
                    ++(qq_lex$lxsptr);
                    qq_decls$nextlx.symbol = (i64)9;
                    qq_decls$nextlx.subcode = (i64)3;
                }
                else {
                    qq_decls$nextlx.symbol = (i64)7;
                }
                };
            }
            else {
                qq_decls$nextlx.symbol = (i64)6;
            }
            };
            return;
        }
        break;
    case 40:;
        {
            qq_decls$nextlx.symbol = (i64)12;
            return;
        }
        break;
    case 41:;
        {
            qq_decls$nextlx.symbol = (i64)13;
            return;
        }
        break;
    case 91:;
        {
            qq_decls$nextlx.symbol = (i64)14;
            return;
        }
        break;
    case 93:;
        {
            qq_decls$nextlx.symbol = (i64)15;
            return;
        }
        break;
    case 124:;
        {
            qq_decls$nextlx.symbol = (i64)19;
            return;
        }
        break;
    case 94:;
        {
            qq_decls$nextlx.symbol = (i64)18;
            qq_decls$nextlx.subcode = (i64)58;
            return;
        }
        break;
    case 64:;
        {
            qq_decls$nextlx.symbol = (i64)20;
            return;
        }
        break;
    case 63:;
        {
            qq_decls$nextlx.symbol = (i64)21;
            return;
        }
        break;
    case 43:;
        {
            qq_decls$nextlx.symbol = (i64)27;
            if (((u64)(*qq_lex$lxsptr) == '+')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)68;
                qq_decls$nextlx.subcode = (i64)74;
                return;
            }
            else {
                qq_decls$nextlx.subcode = (i64)137;
            }
;
            return;
        }
        break;
    case 45:;
        {
            qq_decls$nextlx.symbol = (i64)28;
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='-')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)68;
                qq_decls$nextlx.subcode = (i64)75;
                return;
            }
            else if (($temp=='>')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)11;
            }
            else {
                qq_decls$nextlx.subcode = (i64)138;
            }
            };
            return;
        }
        break;
    case 42:;
        {
            qq_decls$nextlx.symbol = (i64)29;
            if (((u64)(*qq_lex$lxsptr) == '*')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)49;
                qq_decls$nextlx.subcode = (i64)165;
            }
            else {
                qq_decls$nextlx.subcode = (i64)139;
            }
;
            return;
        }
        break;
    case 47:;
        {
            qq_decls$nextlx.symbol = (i64)30;
            qq_decls$nextlx.subcode = (i64)140;
            return;
        }
        break;
    case 37:;
        {
            qq_decls$nextlx.symbol = (i64)31;
            qq_decls$nextlx.subcode = (i64)141;
            return;
        }
        break;
    case 61:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='>')) {
                qq_decls$nextlx.symbol = (i64)10;
                ++(qq_lex$lxsptr);
            }
            else if (($temp=='=')) {
                qq_decls$nextlx.symbol = (i64)56;
                qq_decls$nextlx.subcode = (i64)134;
                ++(qq_lex$lxsptr);
            }
            else {
                qq_decls$nextlx.symbol = (i64)50;
                qq_decls$nextlx.subcode = (i64)155;
            }
            };
            return;
        }
        break;
    case 60:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='=')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)53;
                qq_decls$nextlx.subcode = (i64)158;
            }
            else if (($temp=='>')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)51;
                qq_decls$nextlx.subcode = (i64)156;
            }
            else if (($temp=='<')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)39;
                qq_decls$nextlx.subcode = (i64)147;
            }
            else {
                qq_decls$nextlx.symbol = (i64)52;
                qq_decls$nextlx.subcode = (i64)157;
            }
            };
            return;
        }
        break;
    case 62:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='=')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)54;
                qq_decls$nextlx.subcode = (i64)159;
            }
            else if (($temp=='>')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)40;
                qq_decls$nextlx.subcode = (i64)148;
            }
            else {
                qq_decls$nextlx.symbol = (i64)55;
                qq_decls$nextlx.subcode = (i64)160;
            }
            };
            return;
        }
        break;
    case 38:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='&')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)23;
                qq_decls$nextlx.subcode = (i64)163;
            }
            else {
                qq_decls$nextlx.symbol = (i64)22;
                qq_decls$nextlx.subcode = (i64)57;
            }
            };
            return;
        }
        break;
    case 39:;
        {
            qq_lex$lxreadstring((i64)39);
            return;
        }
        break;
    case 34:;
        {
            qq_lex$lxreadstring((i64)34);
            return;
        }
        break;
    case 96:;
        {
            qq_lex$readrawxname();
            return;
        }
        break;
    case 32:;
    case 9:;
        {
        }
        break;
    case 13:;
        {
            ++(qq_lex$lxsptr);
            ++(qq_decls$nalllines);
            qq_decls$nextlx.symbol = (i64)70;
            return;
        }
        break;
    case 10:;
        {
            qq_decls$nextlx.symbol = (i64)70;
            ++(qq_decls$nalllines);
            return;
        }
        break;
    case 26:;
    case 0:;
        {
            qq_decls$nextlx.symbol = (i64)71;
            --(qq_lex$lxsptr);
            return;
        }
        break;
    default: {
        c = (i64)(u64)(*(qq_lex$lxsptr - (i64)1));
        if ((((c == (i64)226) && ((i64)(u64)(*qq_lex$lxsptr) == (i64)136)) && ((i64)(u64)(*(qq_lex$lxsptr + (i64)1)) == (i64)154))) {
            qq_lex$lxsptr += (i64)2;
            qq_decls$nextlx.symbol = (i64)65;
            qq_decls$nextlx.subcode = (i64)85;
            return;
        }
;
        if ((c >= (i64)128)) {
            goto L228 ;
;
        }
;
        qq_decls$nextlx.symbol = (i64)1;
        qq_decls$nextlx.value = c;
        return;
    }
    } //SW
goto L225 ;
L226 :;
    ;
}

static void qq_lex$lxreadstring(i64 termchar) {
        u8 *  dest;
        u8 *  pstart;
        i64 c;
        i64 d;
        i64 length;
        i64 hasescape;
        u8 str[8];
        i64 $av_1;
    if ((termchar == (i64)34)) {
        qq_decls$nextlx.symbol = (i64)77;
    }
    else {
        qq_decls$nextlx.symbol = (i64)76;
        qq_decls$nextlx.subcode = (i64)1;
    }
;
    pstart = qq_lex$lxsptr;
    length = (i64)0;
    hasescape = (i64)0;
    L239 :;
        {i64 $temp = (c = (i64)(u64)(*(qq_lex$lxsptr)++));
if (($temp==(i64)92)) {
        c = (i64)(u64)(*qq_lex$lxsptr);
        if ((($rtemp=c, $rtemp >= (i64)65 && $rtemp <= (i64)90))) {
            c += (i64)32;
        }
;
        ++(qq_lex$lxsptr);
        hasescape = (i64)1;
        if ((c==(i64)119)) {
            length += (i64)2;
        }
        else if ((c==(i64)120)) {
            qq_lex$lxsptr += (i64)2;
            ++(length);
        }
        else {
            ++(length);
        }
;
    }
    else if (($temp==(i64)34) || ($temp==(i64)39)) {
        if ((c == termchar)) {
            if (((i64)(u64)(*qq_lex$lxsptr) == c)) {
                hasescape = (i64)1;
                ++(qq_lex$lxsptr);
                ++(length);
            }
            else {
                goto L240 ;
            }
;
        }
        else {
            ++(length);
        }
;
    }
    else if (($temp==(i64)13) || ($temp==(i64)10) || ($temp==(i64)0)) {
        qq_lib$lxerror((byte*)"String not terminated");
    }
    else {
        ++(length);
    }
    }goto L239 ;
L240 :;
    ;
    qq_lex$nextlxlength = length;
    if ((length == (i64)0)) {
        qq_decls$nextlx.svalue = (byte*)"";
        return;
    }
    else if (!(!!(hasescape))) {
        qq_decls$nextlx.svalue = mlib$pcm_copyheapstringn(pstart,length);
        return;
    }
;
    qq_decls$nextlx.svalue = (dest = (u8 *)mlib$pcm_alloc((length + (i64)1)));
    L241 :;
    while (1) {
                {i64 $temp = (c = (i64)(u64)(*(pstart)++));
if (($temp==(i64)92)) {
            c = (i64)(u64)(*pstart);
            if (((c >= (i64)65) && (c <= (i64)90))) {
                c += (i64)32;
            }
;
            ++(pstart);
            switch (c) {
            case 97:;
                {
                    c = (i64)7;
                }
                break;
            case 98:;
                {
                    c = (i64)8;
                }
                break;
            case 99:;
            case 114:;
                {
                    c = (i64)13;
                }
                break;
            case 101:;
                {
                    msysc$m_print_startcon();
                    msysc$m_print_str((byte*)"<E> ETX SEEN",NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    c = (i64)26;
                }
                break;
            case 102:;
                {
                    c = (i64)12;
                }
                break;
            case 108:;
            case 110:;
                {
                    c = (i64)10;
                }
                break;
            case 115:;
                {
                    c = (i64)27;
                }
                break;
            case 116:;
                {
                    c = (i64)9;
                }
                break;
            case 118:;
                {
                    c = (i64)11;
                }
                break;
            case 119:;
                {
                    (*(dest)++) = (u64)13u;
                    c = (i64)10;
                }
                break;
            case 120:;
                {
                    c = (i64)0;
                    $av_1 = (i64)2;
                    while ($av_1-- > 0) {
L243 :;
                        if ((($rtemp=(d = (i64)(u64)(*(pstart)++)), $rtemp >= (i64)65 && $rtemp <= (i64)70))) {
                            c = ((((c * (i64)16) + d) - (i64)65) + (i64)10);
                        }
                        else if ((($rtemp=d, $rtemp >= (i64)97 && $rtemp <= (i64)102))) {
                            c = ((((c * (i64)16) + d) - (i64)97) + (i64)10);
                        }
                        else if ((($rtemp=d, $rtemp >= (i64)48 && $rtemp <= (i64)57))) {
                            c = (((c * (i64)16) + d) - (i64)48);
                        }
                        else {
                            qq_lib$lxerror((byte*)"Bad \\x code");
                        }
;
L244 :;
                    }
L245 :;
                    ;
                }
                break;
            case 121:;
                {
                    c = (i64)16;
                }
                break;
            case 122:;
                {
                    c = (i64)0;
                }
                break;
            default: {
                if ((c==(i64)34) || (c==(i64)81)) {
                    c = (i64)34;
                }
                else if ((c==(i64)92)) {
                    c = (i64)92;
                }
                else if ((c==(i64)39)) {
                    c = (i64)39;
                }
                else if ((c==(i64)48)) {
                    c = (i64)0;
                }
                else {
                    str[((i64)1)-1] = (u64)c;
                    str[((i64)2)-1] = (u64)0u;
                    qq_lex$lxerror_s((byte*)"Unknown string escape: \\%s",(u8 *)str);
                }
;
            }
            } //SW
;
        }
        else if (($temp==(i64)34) || ($temp==(i64)39)) {
            if ((c == termchar)) {
                if (((i64)(u64)(*pstart) == c)) {
                    ++(pstart);
                }
                else {
                    goto L242 ;
                }
;
            }
;
        }
        else if (($temp==(i64)13) || ($temp==(i64)10) || ($temp==(i64)26) || ($temp==(i64)0)) {
            qq_lib$lxerror((byte*)"String not terminated");
        }
        };
        (*(dest)++) = (u64)c;
    }
L242 :;
    ;
    (*(qq_decls$nextlx.svalue + qq_lex$nextlxlength)) = (u64)0u;
}

void qq_lex$lexinit(void) {
    memset(&qq_lex$hashtable,(i32)(i64)0,(u64)3670016u);
    qq_lex$hashtablelast = &qq_lex$hashtable[((i64)32767)];
    qq_lex$inithashtable();
}

static void qq_lex$readrawstring(void) {
        u8 *  pstart;
        i64 length;
    qq_decls$nextlx.symbol = (i64)77;
    pstart = ++(qq_lex$lxsptr);
    length = (i64)0;
    L246 :;
        {u64 $temp = (u64)(*(qq_lex$lxsptr)++);
if (($temp=='"')) {
        goto L247 ;
    }
    else if (($temp==(u64)13u) || ($temp==(u64)10u) || ($temp==(u64)0u)) {
        qq_lib$lxerror((byte*)"Raw string not terminated");
        --(qq_lex$lxsptr);
        goto L247 ;
    }
    else {
        ++(length);
    }
    }goto L246 ;
L247 :;
    ;
    qq_lex$nextlxlength = length;
    qq_decls$nextlx.svalue = mlib$pcm_copyheapstringn(pstart,length);
}

i64 qq_lex$lookup(u8 *name,i64 length,i64 hashindex) {
        i64 wrapped;
        i64 n;
        struct qq_decls$strec *  d;
    d = &qq_lex$hashtable[(hashindex)];
    wrapped = (i64)0;
    L248 :;
    while (1) {
        if ((((n = (i64)(*d).namelen) == length) && (memcmp((void *)(*d).name,(void *)name,(u64)n) == (i64)0))) {
            qq_decls$nextlx.symptr = (struct qq_decls$strec *)d;
            qq_decls$nextlx.symbol = (i64)(*d).symbolcode;
            qq_decls$nextlx.subcode = (i64)(*d).subcode;
            return (i64)1;
        }
        else if ((n == (i64)0)) {
            goto L249 ;
        }
;
        if ((++(d) > qq_lex$hashtablelast)) {
            if (!!(wrapped)) {
                mlib$abortprogram((byte*)"HASHTABLE FULL");
            }
;
            wrapped = (i64)1;
            d = &qq_lex$hashtable[((i64)0)];
        }
;
    }
L249 :;
    ;
    (*d).name = mlib$pcm_copyheapstringn(name,length);
    (*d).namelen = length;
    (*d).symbolcode = (i64)79;
    qq_decls$nextlx.symptr = (struct qq_decls$strec *)d;
    qq_decls$nextlx.symbol = (i64)(*d).symbolcode;
    qq_decls$nextlx.subcode = (i64)(*d).subcode;
    return (i64)0;
}

i64 qq_lex$gethashvaluez(u8 *s) {
        i64 c;
        i64 hsum;
    if (((i64)(u64)(*s) == (i64)0)) {
        return (i64)0;
    }
;
    hsum = (i64)(u64)(*(s)++);
    L250 :;
    while (1) {
        c = (i64)(u64)(*(s)++);
        if ((c == (i64)0)) {
            goto L251 ;
        }
;
        hsum = (((hsum << (i64)4) - hsum) + c);
    }
L251 :;
    ;
    return (((hsum << (i64)5) - hsum) & (i64)32767);
}

// START
void qq_lex$start(void) {

        i64 c;
    for (c=(i64)0;c<=(i64)255;++c) {
L252 :;
        if (((((($rtemp=c, $rtemp >= (i64)97 && $rtemp <= (i64)122)) || (($rtemp=c, $rtemp >= (i64)48 && $rtemp <= (i64)57))) || (c == '_' || c == '$')) || (($rtemp=c, $rtemp >= (i64)128 && $rtemp <= (i64)255)))) {
            qq_lex$namemap[(c)] = (i64)1;
        }
        else if ((($rtemp=c, $rtemp >= (i64)65 && $rtemp <= (i64)90))) {
            qq_lex$namemap[(c)] = (i64)2;
        }
;
L253 :;
    }
L254 :;
    ;
}

static void qq_lex$inithashtable(void) {
        i64 i;
        u8 *  name;
    for (i=(i64)1;i<=(i64)212;++i) {
L255 :;
        qq_lex$addstname(qq_tables$stnames[(i)-1],(i64)qq_tables$stsymbols[(i)-1],(i64)qq_tables$stsubcodes[(i)-1]);
L256 :;
    }
L257 :;
    ;
    for (i=(i64)1;i<=(i64)59;++i) {
L258 :;
        if (!(!!((i64)qq_tables$hostinternal[(i)]))) {
            name = (qq_tables$hostfnnames[(i)] + (i64)2);
            qq_lex$addstname(name,(i64)147,i);
        }
;
L259 :;
    }
L260 :;
    ;
}

static void qq_lex$addstname(u8 *name,i64 symbol,i64 subcode) {
    if (!!(qq_lex$lookup(name,strlen(name),qq_lex$gethashvaluez(name)))) {
        msysc$m_print_startcon();
        msysc$m_print_str(name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mlib$abortprogram((byte*)"Dupl ST entry");
    }
;
    (*qq_decls$nextlx.symptr).symbolcode = symbol;
    (*qq_decls$nextlx.symptr).subcode = subcode;
}

void qq_lex$startlex(struct qq_decls$filerec *pm) {
    qq_lex$lxsource = (qq_lex$lxsptr = mlib$pcm_copyheapstring((*pm).text));
    qq_lex$lxfileno = (i64)(*pm).moduleno;
    qq_decls$nextlx.symbol = (i64)5;
    qq_decls$nextlx.subcode = (i64)0;
    qq_decls$nextlx.pos = msysc$m_setdotslice(qq_decls$nextlx.pos,(i64)24,(i64)31,(i64)(*pm).moduleno);
}

struct qq_decls$strec *qq_lex$addnamestr(u8 *name) {
        struct qq_decls$lexrec oldlx;
        struct qq_decls$strec *  symptr;
    oldlx = qq_decls$nextlx;
    qq_lex$nextlxlength = strlen(name);
    qq_decls$nextlx.svalue = (u8 *)mlib$pcm_alloc((qq_lex$nextlxlength + (i64)1));
    memcpy((void *)qq_decls$nextlx.svalue,(void *)name,(u64)(qq_lex$nextlxlength + (i64)1));
    qq_lex$lookup(qq_decls$nextlx.svalue,qq_lex$nextlxlength,qq_lex$gethashvaluez(name));
    symptr = (struct qq_decls$strec *)qq_decls$nextlx.symptr;
    qq_decls$nextlx = oldlx;
    return symptr;
}

void qq_lex$ps(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":::",NULL);
    msysc$m_print_end();
    ;
    qq_show$printsymbol(&qq_decls$lx);
}

void qq_lex$psnext(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"\t",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":##",NULL);
    msysc$m_print_end();
    ;
    qq_show$printsymbol(&qq_decls$nextlx);
}

void qq_lex$lex(void) {
    qq_decls$lx = qq_decls$nextlx;
    qq_lex$lxlength = qq_lex$nextlxlength;
    qq_decls$lx.pos = msysc$m_setdotslice(qq_decls$lx.pos,(i64)0,(i64)23,(u64)(qq_lex$lxstart - qq_lex$lxsource));
    //reenter:
L261 :;
;
    qq_lex$lexreadtoken();
    //reenter2:
L262 :;
;
        {i64 $temp = (i64)qq_decls$nextlx.symbol;
if (($temp==(i64)78)) {
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)73)) {
                        {i64 $temp = (i64)(*qq_decls$nextlx.symptr).subcode;
if (($temp==(i64)2)) {
                qq_decls$lx.value *= (i64)1000000;
            }
            else if (($temp==(i64)3)) {
                qq_decls$lx.value *= (i64)1000000000;
            }
            else if (($temp==(i64)1)) {
                qq_decls$lx.value *= (i64)1000;
            }
            else {
                qq_lib$lxerror((byte*)"Can't do this unit index");
            }
            };
            qq_decls$lx.subcode = (i64)1;
            goto L261 ;
;
        }
        else if (($temp==(i64)75)) {
            qq_lib$lxerror((byte*)"unit symbol after float?");
        }
        else {
            qq_decls$nextlx.symbol = (i64)79;
        }
        };
    }
    else if (($temp==(i64)146)) {
                {i64 $temp = (i64)qq_decls$nextlx.subcode;
if (($temp==(i64)3)) {
            qq_decls$nextlx.symbol = (i64)73;
            qq_decls$nextlx.value = (i64)0;
            qq_decls$nextlx.subcode = (i64)1;
        }
        else if (($temp==(i64)1)) {
            qq_decls$nextlx.symbol = (i64)75;
            qq_decls$nextlx.xvalue = (double)3.1415926535897931;
            qq_decls$nextlx.subcode = (i64)2;
        }
        else if (($temp==(i64)2)) {
            qq_decls$nextlx.symbol = (i64)77;
            qq_decls$nextlx.svalue = (byte*)"\t";
            qq_lex$nextlxlength = (i64)1;
        }
        else if (($temp==(i64)4)) {
            qq_decls$nextlx.symbol = (i64)73;
            qq_decls$nextlx.value = (i64)1;
            qq_decls$nextlx.subcode = (i64)1;
        }
        else if (($temp==(i64)5)) {
            qq_decls$nextlx.symbol = (i64)73;
            qq_decls$nextlx.value = (i64)0;
            qq_decls$nextlx.subcode = (i64)1;
        }
        else {
            qq_lib$lxerror((byte*)"sysconst?");
        }
        };
    }
    else if (($temp==(i64)70)) {
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)4) || ($temp==(i64)14) || ($temp==(i64)12) || ($temp==(i64)8) || ($temp==(i64)5)) {
            qq_lex$lexreadtoken();
            goto L262 ;
;
            goto L261 ;
;
        }
        else {
            if ((!!((i64)qq_tables$binopset[((i64)qq_decls$lx.symbol)]) && !(((i64)qq_decls$lx.symbol == (i64)42 || (i64)qq_decls$lx.symbol == (i64)41)))) {
                qq_lex$lexreadtoken();
                goto L262 ;
;
            }
;
        }
        };
        qq_decls$nextlx.symbol = (i64)5;
    }
    else if (($temp==(i64)45)) {
        if (((i64)qq_decls$lx.symbol == (i64)57)) {
            qq_decls$lx.symbol = (i64)46;
            qq_decls$lx.subcode = (i64)150;
            goto L261 ;
;
        }
;
    }
    };
}

void qq_lex$lxerror_s(u8 *mess,u8 *a) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt(mess);
    msysc$m_print_str(a,NULL);
    msysc$m_print_end();
    ;
    qq_lib$lxerror((u8 *)str);
}

static void qq_lex$makedecimal(u8 *s,i64 length,i64 base) {
    if ((base != (i64)10)) {
        qq_lib$lxerror((byte*)"MAKEDECIMAL/16/2");
    }
;
    qq_decls$nextlx.symbol = (i64)74;
    qq_decls$nextlx.subcode = (i64)3;
    qq_decls$nextlx.svalue = mlib$pcm_copyheapstringn(s,length);
    qq_lex$nextlxlength = length;
}

static void qq_lex$readdec(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 islong;
        i64 length;
        byte str[1024];
        u64 a;
        i64 $av_1;
    islong = (i64)0;
    pstart = qq_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L263 :;
    while (1) {
        if ((($rtemp=(c = (i64)(u64)(*(qq_lex$lxsptr)++)), $rtemp >= (i64)48 && $rtemp <= (i64)57))) {
            a = (u64)((((i64)a * (i64)10) + c) - (i64)48);
            (*(dest)++) = (u64)c;
        }
        else {
            if ((c==(i64)101) || (c==(i64)69)) {
                qq_lex$lxsptr = pstart;
                qq_lex$readreal();
                return;
            }
            else if ((c==(i64)46)) {
                if (((u64)(*qq_lex$lxsptr) != '.')) {
                    qq_lex$lxsptr = pstart;
                    qq_lex$readreal();
                    return;
                }
;
                --(qq_lex$lxsptr);
                goto L264 ;
            }
            else if ((c==(i64)95) || (c==(i64)39)) {
            }
            else if ((c==(i64)108) || (c==(i64)76)) {
                (*dest) = (u64)0u;
                qq_lex$makedecimal((u8 *)str,(dest - str),(i64)10);
                return;
            }
            else if ((c==(i64)98) || (c==(i64)66)) {
                length = (dest - str);
                if ((length > (i64)64)) {
                    qq_lib$lxerror((byte*)"bin overflow");
                }
;
                dest = (u8 *)str;
                a = (u64)0u;
                $av_1 = length;
                while ($av_1-- > 0) {
L265 :;
                    if (((u64)(*dest) >= '2')) {
                        qq_lib$lxerror((byte*)"bad bin digit");
                    }
;
                    a = (u64)((((i64)a * (i64)2) + (i64)(u64)(*(dest)++)) - (i64)48);
L266 :;
                }
L267 :;
                ;
                goto L268 ;
;
            }
            else {
                --(qq_lex$lxsptr);
                goto L264 ;
            }
;
        }
;
        if ((dest >= destend)) {
            qq_lib$lxerror((byte*)"Numlit too long");
        }
;
    }
L264 :;
    ;
    length = (dest - str);
    if (((length > (i64)20) || ((length == (i64)20) && (strncmp((u8 *)str,qq_lex$u64maxstr,(u64)20u) > (i64)0)))) {
        qq_lex$makedecimal((u8 *)str,length,(i64)10);
        return;
    }
;
    //finish:
L268 :;
;
    qq_decls$nextlx.symbol = (i64)73;
    qq_decls$nextlx.subcode = (i64)1;
    qq_decls$nextlx.value = (i64)a;
}

static void qq_lex$readhex(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 length;
        byte str[1024];
        u64 a;
    pstart = qq_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L269 :;
    while (1) {
        if ((($rtemp=(c = (i64)(u64)(*(qq_lex$lxsptr)++)), $rtemp >= (i64)48 && $rtemp <= (i64)57))) {
            a = (u64)((((i64)a * (i64)16) + c) - (i64)48);
            (*(dest)++) = (u64)c;
        }
        else if ((($rtemp=c, $rtemp >= (i64)65 && $rtemp <= (i64)70))) {
            (*(dest)++) = (u64)c;
            a = (u64)(((((i64)a * (i64)16) + c) - (i64)65) + (i64)10);
        }
        else if ((($rtemp=c, $rtemp >= (i64)97 && $rtemp <= (i64)102))) {
            (*(dest)++) = (u64)(c - (i64)32);
            a = (u64)(((((i64)a * (i64)16) + c) - (i64)97) + (i64)10);
        }
        else {
            if ((c==(i64)95) || (c==(i64)39)) {
            }
            else if ((c==(i64)108) || (c==(i64)76)) {
                (*dest) = (u64)0u;
                qq_lex$makedecimal((u8 *)str,(dest - str),(i64)16);
                return;
            }
            else if ((c==(i64)46)) {
                --(qq_lex$lxsptr);
                goto L270 ;
            }
            else {
                --(qq_lex$lxsptr);
                goto L270 ;
            }
;
        }
;
        if ((dest >= destend)) {
            qq_lib$lxerror((byte*)"Numlit too long");
        }
;
    }
L270 :;
    ;
    length = (dest - str);
    if ((length > (i64)16)) {
        qq_lex$makedecimal((u8 *)str,length,(i64)16);
        return;
    }
;
    qq_decls$nextlx.symbol = (i64)73;
    qq_decls$nextlx.subcode = (i64)1;
    qq_decls$nextlx.value = (i64)a;
}

static void qq_lex$readbin(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 length;
        byte str[1024];
        u64 a;
    pstart = qq_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L271 :;
    while (1) {
                {i64 $temp = (c = (i64)(u64)(*(qq_lex$lxsptr)++));
if (($temp==(i64)48) || ($temp==(i64)49)) {
            a = (u64)((((i64)a * (i64)2) + c) - (i64)48);
            (*(dest)++) = (u64)c;
        }
        else if (($temp==(i64)95) || ($temp==(i64)39)) {
        }
        else if (($temp==(i64)108) || ($temp==(i64)76)) {
            (*dest) = (u64)0u;
            qq_lex$makedecimal((u8 *)str,(dest - str),(i64)2);
            return;
        }
        else if (($temp==(i64)46)) {
            --(qq_lex$lxsptr);
            goto L272 ;
        }
        else {
            if ((($rtemp=c, $rtemp >= (i64)50 && $rtemp <= (i64)57))) {
                qq_lib$lxerror((byte*)"bin bad digit");
            }
            else {
                --(qq_lex$lxsptr);
                goto L272 ;
            }
;
        }
        };
        if ((dest >= destend)) {
            qq_lib$lxerror((byte*)"bin overflow");
        }
;
    }
L272 :;
    ;
    length = (dest - str);
    if ((length > (i64)64)) {
        qq_lex$makedecimal((u8 *)str,length,(i64)2);
        return;
    }
;
    qq_decls$nextlx.symbol = (i64)73;
    qq_decls$nextlx.subcode = (i64)1;
    qq_decls$nextlx.value = (i64)a;
}

static void qq_lex$readreal(void) {
        i64 c;
        i64 negexpon;
        i64 dotseen;
        i64 length;
        i64 fractlen;
        i64 expon;
        i64 expseen;
        r64 x;
        u8 str[1024];
        u8 *  dest;
        u8 *  destend;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 i;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)100);
    length = (negexpon = (dotseen = (expseen = (expon = (fractlen = (i64)0)))));
    L273 :;
    while (1) {
        if ((($rtemp=(c = (i64)(u64)(*(qq_lex$lxsptr)++)), $rtemp >= (i64)48 && $rtemp <= (i64)57))) {
            (*(dest)++) = (u64)c;
            ++(length);
            if (!!(dotseen)) {
                ++(fractlen);
            }
;
        }
        else {
            if ((c==(i64)46)) {
                if (!!(dotseen)) {
                    --(qq_lex$lxsptr);
                    goto L274 ;
                }
;
                dotseen = (i64)1;
                (*(dest)++) = (u64)c;
            }
            else if ((c==(i64)101) || (c==(i64)69)) {
                if (!!(expseen)) {
                    qq_lib$lxerror((byte*)"double expon");
                }
;
                expseen = (i64)1;
                (*(dest)++) = (u64)c;
                L275 :;
                while (((u64)(*qq_lex$lxsptr) == ' ')) {
                    ++(qq_lex$lxsptr);
L276 :;
                }
L277 :;
                ;
                if (((u64)(*qq_lex$lxsptr) == '+' || (u64)(*qq_lex$lxsptr) == '-')) {
                    if (((u64)(*qq_lex$lxsptr) == '-')) {
                        negexpon = (i64)1;
                    }
;
                    (*(dest)++) = (u64)(*(qq_lex$lxsptr)++);
                }
;
                expon = (i64)0;
                L278 :;
                while (1) {
                    if ((($rtemp=(c = (i64)(u64)(*(qq_lex$lxsptr)++)), $rtemp >= (i64)48 && $rtemp <= (i64)57))) {
                        expon = (((expon * (i64)10) + c) - (i64)48);
                        (*(dest)++) = (u64)c;
                        if ((dest >= destend)) {
                            qq_lib$lxerror((byte*)"expon?");
                        }
;
                    }
                    else {
                        if ((c==(i64)95) || (c==(i64)39)) {
                        }
                        else if ((c==(i64)108) || (c==(i64)76)) {
                            (*dest) = (u64)0u;
                            qq_lex$makedecimal((u8 *)str,(dest - str),(i64)10);
                            return;
                        }
                        else {
                            --(qq_lex$lxsptr);
                            goto L274 ;
                        }
;
                    }
;
                }
L279 :;
                ;
            }
            else if ((c==(i64)95) || (c==(i64)39)) {
            }
            else if ((c==(i64)108) || (c==(i64)76)) {
                qq_lex$makedecimal((u8 *)str,(dest - str),(i64)10);
                return;
            }
            else {
                --(qq_lex$lxsptr);
                goto L274 ;
            }
;
        }
;
        if ((dest >= destend)) {
            qq_lib$lxerror((byte*)"r64lit too long");
        }
;
    }
L274 :;
    ;
    (*dest) = (u64)0u;
    if (!!(negexpon)) {
        expon = -(expon);
    }
;
    expon -= fractlen;
    x = (double)0.;
        ($av_1 = (length + dotseen));
    for (i=(i64)1;i<=$av_1;++i) {
L280 :;
        c = (i64)(u64)str[(i)-1];
        if ((c != (i64)46)) {
            x = (((x * (double)10.) + (r64)c) - (r64)'0');
        }
;
L281 :;
    }
L282 :;
    ;
    if ((expon >= (i64)0)) {
        $av_2 = expon;
        while ($av_2-- > 0) {
L283 :;
            x *= (double)10.;
L284 :;
        }
L285 :;
        ;
    }
    else {
        $av_3 = -(expon);
        while ($av_3-- > 0) {
L286 :;
            x /= (double)10.;
L287 :;
        }
L288 :;
        ;
    }
;
    qq_decls$nextlx.xvalue = x;
    qq_decls$nextlx.symbol = (i64)75;
    qq_decls$nextlx.subcode = (i64)2;
}

static void qq_lex$readrawxname(void) {
        i64 c;
        i64 hsum;
    qq_decls$nextlx.svalue = qq_lex$lxsptr;
    hsum = (i64)0;
    L289 :;
    while (!!((i64)qq_lex$namemap[((c = (i64)(u64)(*(qq_lex$lxsptr)++)))])) {
        hsum = (((hsum << (i64)4) - hsum) + c);
L290 :;
    }
L291 :;
    ;
    --(qq_lex$lxsptr);
    qq_lex$lookup(qq_decls$nextlx.svalue,(qq_lex$lxsptr - qq_decls$nextlx.svalue),(((hsum << (i64)5) - hsum) & (i64)32767));
    return;
}

void qq_lib$reportcterror(u8 *errortype,u8 *mess,i64 pos,struct qq_decls$strec *currproc) {
        struct qq_decls$locrec loc;
    loc = qq_lib$geterrorinfo((u64)pos,currproc);
    msysc$m_print_startcon();
    msysc$m_print_str(errortype,NULL);
    msysc$m_print_str((byte*)"Error:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"    ",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_lib$showerrorsource(loc);
    qq_lib$stopcompiler(loc);
}

struct qq_decls$locrec qq_lib$geterrorinfo(u64 pos,struct qq_decls$strec *currproc) {
        i64 soffset;
        i64 moduleno;
        struct qq_decls$locrec loc;
    memset(&(loc),0,48);
    soffset = (i64)msysc$m_getdotslice(pos,(i64)0,(i64)23);
    moduleno = (i64)msysc$m_getdotslice(pos,(i64)24,(i64)31);
    if ((moduleno == (i64)0)) {
        mlib$abortprogram((byte*)"GETERRORINFO: no module");
    }
;
    if ((currproc == 0)) {
        mlib$abortprogram((byte*)"GETERRORINFO: no currproc");
    }
;
    loc.pm = qq_decls$modules[(moduleno)];
    loc.sp = qq_decls$subprogs[((i64)(*loc.pm).subprogno)-1];
    loc.def = currproc;
    qq_lib$setlineno(&loc,soffset);
    return loc;
}

void qq_lib$setlineno(struct qq_decls$locrec *loc,i64 offset) {
        u8 *  sline;
        u8 *  s;
        u8 *  source;
    source = (*(*loc).pm).text;
    sline = (source + offset);
    L292 :;
    while (((sline > source) && ((i64)(u64)(*sline) != (i64)10))) {
        --(sline);
L293 :;
    }
L294 :;
    ;
    if (((i64)(u64)(*sline) == (i64)10)) {
        ++(sline);
    }
;
    (*loc).startline = sline;
    (*loc).column = ((source + offset) - sline);
    s = sline;
    (*loc).lineno = (i64)1;
    L295 :;
    while ((s > source)) {
        if (((i64)(u64)(*s) == (i64)10)) {
            ++((*loc).lineno);
        }
;
        --(s);
L296 :;
    }
L297 :;
    ;
}

static void qq_lib$showerrorsource(struct qq_decls$locrec loc) {
        u8 *  s;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Line:",NULL);
    msysc$m_print_i64(loc.lineno,NULL);
    msysc$m_print_str((byte*)"in Module",NULL);
    msysc$m_print_str((*loc.pm).name,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)".q:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if (!!(loc.def)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"In function:",NULL);
        msysc$m_print_str((*loc.def).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)" |",NULL);
    msysc$m_print_end();
    ;
    s = loc.startline;
    L298 :;
    while (!(((u64)(*s) == (i64)13 || (u64)(*s) == (i64)10 || (u64)(*s) == (i64)26 || (u64)(*s) == (i64)0))) {
        msysc$m_print_startcon();
        msysc$m_print_c8((u64)(*s),NULL);
        msysc$m_print_end();
        ;
        ++(s);
L299 :;
    }
L300 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"|",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void qq_lib$stopcompiler(struct qq_decls$locrec loc) {
        void *  f;
    f = fopen((byte*)"$error.tmp",(byte*)"w");
    msysc$m_print_startfile(f);
    msysc$m_print_str((*loc.pm).filespec,NULL);
    msysc$m_print_i64(loc.lineno,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    fclose(f);
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

void qq_lib$gerror(u8 *mess,struct qq_decls$unitrec *p) {
    qq_lib$reportcterror((byte*)"Code Gen",mess,(!!(p) ? (i64)(*p).pos : qq_decls$qpos),qq_decls$stcurrproc);
}

void qq_lib$gerror_s(u8 *mess,u8 *param,struct qq_decls$unitrec *p) {
        u8 str[300];
    msysc$m_print_startstr(str);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str(param,NULL);
    msysc$m_print_end();
    ;
    qq_lib$reportcterror((byte*)"Code Gen",(u8 *)str,(!!(p) ? (i64)(*p).pos : qq_decls$qpos),qq_decls$stcurrproc);
}

void qq_lib$serror(u8 *mess) {
    qq_lib$reportcterror((byte*)"Syntax",mess,(i64)qq_decls$lx.pos,qq_decls$stcurrproc);
}

void qq_lib$serror_s(u8 *mess,u8 *param) {
        u8 str[300];
    strcpy((u8 *)str,mess);
    strcat((u8 *)str,(byte*)" ");
    strcat((u8 *)str,param);
    qq_lib$reportcterror((byte*)"Syntax",str,(i64)qq_decls$lx.pos,qq_decls$stcurrproc);
}

void qq_lib$rxerror(u8 *mess,struct qq_decls$unitrec *p) {
    qq_lib$reportcterror((byte*)"Resolve",mess,(!!(p) ? (i64)(*p).pos : qq_decls$qpos),qq_decls$stcurrproc);
}

void qq_lib$rxerror_s(u8 *mess,u8 *param,struct qq_decls$unitrec *p) {
        u8 str[300];
    strcpy((u8 *)str,mess);
    strcat((u8 *)str,(byte*)" ");
    strcat((u8 *)str,param);
    qq_lib$rxerror(str,p);
}

void qq_lib$lxerror(u8 *mess) {
    qq_lib$reportcterror((byte*)"Lex",mess,(i64)qq_decls$lx.pos,qq_decls$stcurrproc);
}

void qq_lib$pcnotmut(void) {
    qq_lib$pcerror((byte*)"Not mutable");
}

void qq_lib$pcerror(u8 *mess) {
    qq_lib$errormess = mess;
    qq_lib$reportpcerror(mess,qq_decls$pcptr);
}

void qq_lib$pcerror_s(u8 *mess,u8 *param) {
        u8 str[300];
    qq_lib$errormess = mess;
    strcpy((u8 *)str,mess);
    strcat((u8 *)str,(byte*)" ");
    strcat((u8 *)str,param);
    qq_lib$reportpcerror(str,qq_decls$pcptr);
}

void qq_lib$reportpcerror(u8 *mess,i64 *pcptr) {
        struct qq_decls$varrec *  s;
        struct qq_decls$varrec *  send;
        i64 *  pc;
        i64 count;
        struct qq_decls$filerec *  pm;
        struct qq_decls$locrec loc;
        struct qq_decls$locrec loc2;
    loc = qq_lib$getpcerrorpos(pcptr);
    pm = loc.pm;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)" ",(byte*)"80p*");
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"PC Error:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"    ",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_lib$showerrorsource(loc);
    s = qq_decls$sptr;
    send = &qq_decls$varstack[((i64)1)-1];
    count = (i64)0;
    L301 :;
    while (((s >= send) && (count < (i64)5))) {
        if (((i64)(*s).tag == (i64)20)) {
            pc = ((*s).retaddr - (i64)3);
            loc2 = qq_lib$getpcerrorpos(pc);
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Called from line",NULL);
            msysc$m_print_i64(loc2.lineno,NULL);
            msysc$m_print_str((byte*)"in",NULL);
            msysc$m_print_str((*loc2.pm).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            ++(count);
        }
;
        --(s);
L302 :;
    }
L303 :;
    ;
    qq_lib$stopcompiler(loc);
}

struct qq_decls$locrec qq_lib$getpcerrorpos(i64 *pc) {
        i64 offset;
        i64 pos;
        i64 soffset;
        i64 moduleno;
        i64 *  pcstart;
        i32 *  pcsrcstart;
        struct qq_decls$filerec *  pm;
        struct qq_decls$locrec loc;
    memset(&(loc),0,48);
    pm = qq_decls$modules[(qq_lib$findmodulefrompc(pc))];
    pcstart = (*pm).pcstart;
    pcsrcstart = (*pm).pcsrcstart;
    offset = (pc - pcstart);
    pos = (i64)(*(pcsrcstart + offset));
    soffset = (i64)msysc$m_getdotslice(pos,(i64)0,(i64)23);
    moduleno = (i64)msysc$m_getdotslice(pos,(i64)24,(i64)31);
    if ((moduleno == (i64)0)) {
        moduleno = (i64)1;
        soffset = (i64)0;
    }
;
    loc.pm = qq_decls$modules[(moduleno)];
    loc.sp = qq_decls$subprogs[((i64)(*pm).subprogno)-1];
    loc.def = 0;
    qq_lib$setlineno(&loc,soffset);
    return loc;
}

void qq_lib$loaderror(u8 *mess,u8 *mess2) {
        u8 str[512];
    if (!!(strchr(mess,(i32)'#'))) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt(mess);
        msysc$m_print_str(mess2,NULL);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_str(mess,NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Load Error:",NULL);
    msysc$m_print_str(str,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Stopping",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

static i64 qq_lib$findmodulefrompc(i64 *pc) {
        i64 i;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L304 :;
        if (((pc >= (*qq_decls$modules[(i)]).pcstart) && (pc < (*qq_decls$modules[(i)]).pcend))) {
            return i;
        }
;
L305 :;
    }
L306 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Can't find pcptr module",NULL);
    msysc$m_print_ptr(pc,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if (!!(qq_lib$errormess)) {
        msysc$m_print_startcon();
        msysc$m_print_setfmt((byte*)"(#)");
        msysc$m_print_str(qq_lib$errormess,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    exit((i64)1);
    return (i64)0;
}

void qq_lib$prterror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Print error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlinux$os_getch();
    exit((i64)1);
}

void qq_lib$pcustype(u8 *mess,struct qq_decls$varrec *x) {
    qq_lib$pcustype_t(mess,(i64)(*x).tag);
}

void qq_lib$pcustype_t(u8 *mess,i64 t) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Type not supported: # : #");
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str(qq_tables$ttname[(t)],NULL);
    msysc$m_print_end();
    ;
    qq_lib$reportpcerror(str,qq_decls$pcptr);
}

void qq_lib$pcmxtypes(u8 *mess,struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
    qq_lib$pcmxtypestt(mess,(i64)(*x).tag,(i64)(*y).tag);
}

void qq_lib$pcmxtypestt(u8 *mess,i64 t,i64 u) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Types not supported: # : #/#");
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str(qq_tables$ttname[(t)],NULL);
    msysc$m_print_str(qq_tables$ttname[(u)],NULL);
    msysc$m_print_end();
    ;
    qq_lib$reportpcerror(str,qq_decls$pcptr);
}

struct qq_decls$unitrec *qq_lib$allocunitrec(void) {
        struct qq_decls$unitrec *  p;
    p = (struct qq_decls$unitrec *)mlib$pcm_alloc((i64)32);
    (*p).word1 = ((*p).nextunit = ((*p).a = ((*p).b = 0)));
    (*p).nextunit = ((*p).a = ((*p).b = 0));
    (*p).pos = (i64)qq_decls$lx.pos;
    return p;
}

struct qq_decls$unitrec *qq_lib$createintunit(i64 a) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = (i64)45;
    (*u).value = a;
    return u;
}

struct qq_decls$unitrec *qq_lib$createrealunit(r64 x) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = (i64)46;
    (*u).xvalue = x;
    return u;
}

struct qq_decls$unitrec *qq_lib$createstringunit(u8 *s,i64 slength) {
        struct qq_decls$unitrec *  u;
    if ((slength == (i64)-1)) {
        slength = strlen(s);
    }
;
    u = qq_lib$allocunitrec();
    (*u).tag = (i64)47;
    (*u).svalue = (u8 *)mlib$pcm_alloc((slength + (i64)1));
    if (!!(slength)) {
        memcpy((void *)(*u).svalue,(void *)s,(u64)slength);
    }
;
    (*((*u).svalue + slength)) = (u64)0u;
    (*u).slength = slength;
    return u;
}

struct qq_decls$unitrec *qq_lib$createunit0(i64 tag) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = tag;
    return u;
}

struct qq_decls$unitrec *qq_lib$createunit1(i64 tag,struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    return u;
}

struct qq_decls$unitrec *qq_lib$createunit2(i64 tag,struct qq_decls$unitrec *p,struct qq_decls$unitrec *q) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    return u;
}

struct qq_decls$unitrec *qq_lib$createname(struct qq_decls$strec *p) {
        struct qq_decls$unitrec *  u;
    u = (struct qq_decls$unitrec *)qq_lib$allocunitrec();
    (*u).tag = (i64)43;
    (*u).def = (struct qq_decls$strec *)p;
    return (struct qq_decls$unitrec *)u;
}

void qq_lib$addlistunit(struct qq_decls$unitrec **ulist,struct qq_decls$unitrec **ulistx,struct qq_decls$unitrec *p) {
    L307 :;
    while (!!(p)) {
        if (((*ulist) == 0)) {
            (*ulist) = ((*ulistx) = p);
        }
        else {
            (*(*ulistx)).nextunit = p;
        }
;
        (*ulistx) = p;
        p = (*p).nextunit;
L308 :;
    }
L309 :;
    ;
}

struct qq_decls$unitrec *qq_lib$createavname(void) {
        struct qq_decls$strec *  p;
        u8 str[32];
        u8 *  name;
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"av$",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(++(qq_lib$nextavindex),NULL);
    msysc$m_print_end();
    ;
    name = mlib$pcm_copyheapstring((u8 *)str);
    p = qq_lex$addnamestr(name);
    return (struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)p);
}

u8 *qq_lib$convtostringz(u8 *svalue,i64 length) {
        static u8 strbuffer1[2000];
        static u8 strbuffer2[2000];
        static u8 strbuffer3[2000];
        static u8 strbuffer4[2000];
        static u8 strbuffer5[2000];
        static u8 strbuffer6[2000];
        static i64 strindex = (i64)0;
        static u8 (*table[6])[] = {(u8 (*)[])&strbuffer1,(u8 (*)[])&strbuffer2,(u8 (*)[])&strbuffer3,(u8 (*)[])&strbuffer4,(u8 (*)[])&strbuffer5,(u8 (*)[])&strbuffer6};
        u8 (*p)[];
        static u8 *  longstr = 0;
    if ((length >= (i64)2000)) {
        if (!!(longstr)) {
            free((void *)longstr);
        }
;
        longstr = (u8 *)malloc((u64)(length + (i64)1));
        memcpy((void *)longstr,(void *)svalue,(u64)length);
        (*(longstr + length)) = (u64)0u;
        return longstr;
    }
;
    if ((svalue == 0)) {
        return (byte*)"";
    }
;
    if ((++(strindex) == (i64)6)) {
        strindex = (i64)0;
    }
;
    p = (u8 (*)[])table[(strindex)];
    memcpy(p,(void *)svalue,(u64)length);
    (*p)[(length)] = (u64)0u;
    return (u8 *)p;
}

u8 *qq_lib$findprocname(void (*fnptr)(void)) {
        i64 n;
        i64 i;
    n = msysc$m_get_nprocs();
    for (i=(i64)1;i<=n;++i) {
L310 :;
        if ((msysc$m_get_procaddr(i) == fnptr)) {
            return msysc$m_get_procname(i);
        }
;
L311 :;
    }
L312 :;
    ;
    return (byte*)"?";
}

struct mlib$strbuffer *qq_lib$strexpr(struct qq_decls$unitrec *p) {
    mlib$gs_init((struct mlib$strbuffer *)qq_lib$exprstr);
    qq_lib$jeval(p);
    return (struct mlib$strbuffer *)qq_lib$exprstr;
}

u8 *qq_lib$strexpr_s(struct qq_decls$unitrec *p) {
    if ((p == 0)) {
        return (byte*)"";
    }
;
    mlib$gs_init((struct mlib$strbuffer *)qq_lib$exprstr);
    qq_lib$jeval(p);
    return (*qq_lib$exprstr).strptr;
}

static void qq_lib$jeval(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
        u8 str[500];
        i64 i;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)45)) {
        qq_lib$additem(msysc$strint((*p).value,0));
    }
    else if (($temp==(i64)46)) {
        qq_lib$additem(msysc$strreal((r64)(*p).value,0));
    }
    else if (($temp==(i64)47)) {
        if (((*p).slength > (i64)250)) {
            strcpy((u8 *)str,(byte*)"LONGSTR)");
        }
        else {
            qq_lib$convertstring((*p).svalue,(u8 *)str);
        }
;
        qq_lib$additem((byte*)"\"");
        qq_lib$additem((u8 *)str);
        qq_lib$additem((byte*)"\"");
    }
    else if (($temp==(i64)43)) {
        qq_lib$additem((*(*p).def).name);
    }
    else if (($temp==(i64)31)) {
        qq_lib$additem((byte*)"Host<");
        qq_lib$additem((qq_tables$hostfnnames[((*p).index)] + (i64)2));
        qq_lib$additem((byte*)">(");
        q = (*p).a;
        L313 :;
        while (!!(q)) {
            qq_lib$jeval(q);
            q = (*q).nextunit;
            if (!!(q)) {
                qq_lib$additem((byte*)",");
            }
;
L314 :;
        }
L315 :;
        ;
        qq_lib$additem((byte*)")");
    }
    else if (($temp==(i64)50) || ($temp==(i64)51)) {
        qq_lib$jeval((*p).a);
        if (((i64)(*p).tag == (i64)51)) {
            qq_lib$additem((byte*)".");
        }
;
        qq_lib$additem((byte*)"[");
        qq_lib$jeval((*p).b);
        qq_lib$additem((byte*)"]");
    }
    else if (($temp==(i64)52)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)"{");
        qq_lib$jeval((*p).b);
        qq_lib$additem((byte*)"}");
    }
    else if (($temp==(i64)49)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)".");
        qq_lib$jeval((*p).b);
    }
    else if (($temp==(i64)2)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)":=");
        qq_lib$jeval((*p).b);
    }
    else if (($temp==(i64)37)) {
        qq_lib$additem(qq_show$strmode((i64)(*p).mode,(i64)0));
    }
    else if (($temp==(i64)39)) {
        qq_lib$additem(qq_show$strmode((i64)(*p).mode,(i64)0));
        qq_lib$additem((byte*)"(");
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)")");
    }
    else if (($temp==(i64)5)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)":");
        qq_lib$jeval((*p).b);
    }
    else if (($temp==(i64)32)) {
        qq_lib$additem((byte*)"nil");
    }
    else if (($temp==(i64)44)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)".$");
    }
    else if (($temp==(i64)42)) {
        qq_lib$additem((byte*)"CMPCHAIN:");
        q = (*p).a;
        qq_lib$jeval(q);
        for (i=(i64)1;i<=(i64)4;++i) {
L316 :;
            q = (*q).nextunit;
            if (((i64)(*p).cmpgenop[(i)-1] == (i64)0)) {
                goto L318 ;
            }
;
            qq_lib$additem(qq_tables$jtagnames[((i64)(*p).cmpgenop[(i)-1])]);
            qq_lib$jeval(q);
L317 :;
        }
L318 :;
        ;
    }
    else {
        if (((i64)qq_tables$jflags[((i64)(*p).tag)] == (i64)2)) {
            strcpy((u8 *)str,qq_lib$getopcname((i64)(*p).tag));
            qq_lib$additem((byte*)"(");
            qq_lib$jevallist((*p).a);
            qq_lib$additem((u8 *)str);
            qq_lib$jevallist((*p).b);
            qq_lib$additem((byte*)")");
        }
        else if (((i64)qq_tables$jflags[((i64)(*p).tag)] == (i64)1)) {
            strcpy((u8 *)str,qq_lib$getopcname((i64)(*p).tag));
            qq_lib$additem((u8 *)str);
            qq_lib$additem((byte*)"(");
            qq_lib$jevallist((*p).a);
            qq_lib$additem((byte*)")");
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(qq_tables$jtagnames[((i64)(*p).tag)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$loaderror((byte*)"CAN'T DO JEVAL:",qq_tables$jtagnames[((i64)(*p).tag)]);
        }
;
    }
    };
}

static void qq_lib$jevallist(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
    if (!(!!(p))) {
        return;
    }
;
    if (!!((*p).nextunit)) {
        qq_lib$additem((byte*)"(");
        q = p;
        L319 :;
        while (!!(q)) {
            qq_lib$jeval(q);
            q = (*q).nextunit;
            if (!!(q)) {
                qq_lib$additem((byte*)",");
            }
;
L320 :;
        }
L321 :;
        ;
        qq_lib$additem((byte*)")");
        return;
    }
    else {
        qq_lib$jeval(p);
    }
;
}

void qq_lib$additem(u8 *s) {
        u8 *  d;
        i64 lastchar;
        i64 nextchar;
    d = (*qq_lib$exprstr).strptr;
    if (!!((i64)(*qq_lib$exprstr).length)) {
        lastchar = (i64)(u64)(*((d + (i64)(*qq_lib$exprstr).length) - (i64)1));
        nextchar = (i64)(u64)(*s);
        if ((!!(qq_lib$isalphanum(lastchar)) && !!(qq_lib$isalphanum(nextchar)))) {
            mlib$strbuffer_add((struct mlib$strbuffer *)qq_lib$exprstr,(byte*)" ",(i64)-1);
        }
;
    }
;
    mlib$strbuffer_add((struct mlib$strbuffer *)qq_lib$exprstr,s,(i64)-1);
}

static i64 qq_lib$isalphanum(i64 c) {
    if (((((c >= (i64)65) && (c <= (i64)90)) || ((c >= (i64)97) && (c <= (i64)122))) || ((c >= (i64)48) && (c <= (i64)57)))) {
        return (i64)1;
    }
;
    return (i64)0;
}

u8 *qq_lib$getopcname(i64 opc) {
        static u64 a[2];
    a[((i64)2)-1] = (u64)0u;
    a[((i64)1)-1] = (u64)(i64)qq_tables$jshortnames[(opc)];
    if (((i64)a[((i64)1)-1] == (i64)0)) {
        return (qq_tables$jtagnames[(opc)] + (i64)1);
    }
    else {
        return (u8 *)&a;
    }
;
}

void qq_lib$convertstring(u8 *s,u8 *t) {
        i64 c;
    L322 :;
    while (!!((c = (i64)(u64)(*(s)++)))) {
        switch (c) {
        case 34:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = '"';
            }
            break;
        case 10:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'n';
            }
            break;
        case 13:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'c';
            }
            break;
        case 9:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 't';
            }
            break;
        case 92:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = (u64)92u;
            }
            break;
        case 7:;
        case 8:;
        case 26:;
        case 27:;
            {
                (*(t)++) = '<';
                (*(t)++) = (u64)((c / (i64)10) + (i64)48);
                (*(t)++) = (u64)((c % (i64)10) + (i64)48);
                (*(t)++) = '>';
            }
            break;
        default: {
            (*(t)++) = (u64)c;
        }
        } //SW
;
L323 :;
    }
L324 :;
    ;
    (*t) = (u64)0u;
}

struct qq_decls$unitrec *qq_lib$createavnamex(struct qq_decls$strec *owner) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$strec *  d;
    p = qq_lib$createavname();
    qq_resolve$resolvename(owner,p,(i64)0);
    d = (*p).def;
    if (((i64)(*d).nameid == (i64)14)) {
        ++(qq_pclgen$nproclocals);
        (*d).index = qq_pclgen$nproclocals;
        (*qq_pclgen$pproclocals) = qq_pclgen$nproclocals;
    }
;
    return p;
}

void qq_lib$storemode(struct qq_decls$strec *owner,i64 m,i16 *p) {
        struct qq_decls$userxrec *  q;
    (*p) = m;
    if ((m >= (i64)0)) {
        return;
    }
;
    q = (struct qq_decls$userxrec *)mlib$pcm_alloc((i64)24);
    (*q).owner = owner;
    if ((owner == 0)) {
        qq_lib$serror((byte*)"STOREMODE/OWNER=0");
    }
;
    (*q).pmode = p;
    (*q).nextmode = (struct qq_decls$userxrec *)qq_tables$userxmodelist;
    qq_tables$userxmodelist = (struct qq_decls$userxrec *)q;
}

i64 qq_lib$nextpoweroftwo(i64 x) {
        i64 a;
    if ((x == (i64)0)) {
        return (i64)0;
    }
;
    a = (i64)1;
    L325 :;
    while ((a < x)) {
        a <<= (i64)1;
L326 :;
    }
L327 :;
    ;
    return a;
}

i64 *qq_lib$raiseexception(i64 exceptno) {
        struct qq_decls$varrec *  stackend;
        struct qq_decls$varrec *  oldsptr;
    stackend = &qq_decls$varstack[((i64)1)-1];
    oldsptr = qq_decls$sptr;
    L328 :;
    while (1) {
        if ((qq_decls$sptr <= stackend)) {
            qq_decls$sptr = oldsptr;
            qq_lib$pcerror((byte*)"DEFAULT EXCEPTION");
        }
;
        if ((((i64)(*qq_decls$sptr).tag == (i64)21) && ((exceptno == (i64)0) || ((i64)(*qq_decls$sptr).exceptiontype == exceptno)))) {
            goto L329 ;
        }
;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        --(qq_decls$sptr);
    }
L329 :;
    ;
    qq_decls$frameptr = ((byte *)qq_decls$sptr + (i64)(*qq_decls$sptr).frameoffset);
    return (i64 *)(*qq_decls$sptr).ptr;
}

void qq_lib$raise_error(i64 error_no) {
    (*++(qq_decls$sptr)).tagx = (i64)1;
    (*qq_decls$sptr).value = error_no;
    qq_decls$err_pcptr = qq_decls$pcptr;
    qq_decls$pcptr = qq_decls$raiseseq;
}

i64 qq_lib$testelem(byte (*p)[],i64 n) {
    if (!!(((i64)(*p)[((n >> (i64)3))] & (i64)qq_lib$bytemasks[((n & (i64)7))]))) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

void qq_lib$setelem(byte (*p)[],i64 n) {
    (*p)[((n >> (i64)3))] |= (byte)(i64)qq_lib$bytemasks[((n & (i64)7))];
}

void qq_lib$setelemblock(byte (*p)[],i64 a,i64 b) {
        i64 ax;
        i64 bx;
        i64 nwords;
        i64 nx;
        i64 alast;
        i64 bfirst;
        u64 *  q;
        i64 $av_1;
        i64 i;
    if ((a > b)) {
        return;
    }
;
    ax = (a & (i64)-64);
    bx = ((b & (i64)-64) + (i64)64);
    nx = ax;
    alast = (bfirst = (i64)-1);
    nwords = ((bx - ax) / (i64)64);
    if ((nwords == (i64)1)) {
        if (((ax != a) || (b != (bx - (i64)1)))) {
            for (i=a;i<=b;++i) {
L330 :;
                qq_lib$setelem(p,i);
L331 :;
            }
L332 :;
            ;
            return;
        }
;
    }
    else {
        if ((ax != a)) {
            --(nwords);
            nx = (ax + (i64)64);
            alast = (nx - (i64)1);
        }
;
        if ((b != (bx - (i64)1))) {
            --(nwords);
            bfirst = (b & (i64)-64);
        }
;
    }
;
    if ((alast >= (i64)0)) {
        for (i=a;i<=alast;++i) {
L333 :;
            qq_lib$setelem(p,i);
L334 :;
        }
L335 :;
        ;
    }
;
    q = (u64 *)&(*p)[((nx >> (i64)3))];
    $av_1 = nwords;
    while ($av_1-- > 0) {
L336 :;
        (*q) = (u64)18446744073709551615u;
        ++(q);
L337 :;
    }
L338 :;
    ;
    if ((bfirst >= (i64)0)) {
        for (i=bfirst;i<=b;++i) {
L339 :;
            qq_lib$setelem(p,i);
L340 :;
        }
L341 :;
        ;
    }
;
}

i64 qq_lib$ispoweroftwo(i64 x) {
        i64 a;
        i64 n;
        i64 $av_1;
    a = (i64)1;
    n = (i64)0;
    $av_1 = (i64)60;
    while ($av_1-- > 0) {
L342 :;
        ++(n);
        a = (a << (i64)1);
        if ((a == x)) {
            return n;
        }
;
L343 :;
    }
L344 :;
    ;
    return (i64)0;
}

void qq_lib$deleteunit(struct qq_decls$unitrec *p,struct qq_decls$unitrec *q) {
        struct qq_decls$unitrec *  r;
    r = (*p).nextunit;
    (*p) = (*q);
    (*p).nextunit = r;
}

void qq_lib$skipsemi(void) {
    L345 :;
    while (((i64)qq_decls$lx.symbol == (i64)5)) {
        qq_lex$lex();
L346 :;
    }
L347 :;
    ;
}

void qq_lib$checksymbol(i64 symbol) {
        u8 str[100];
    if (((i64)qq_decls$lx.symbol != symbol)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"# expected, not #");
        msysc$m_print_u64(qq_tables$symbolnames[(symbol)-1],(byte*)"d");
        msysc$m_print_u64(qq_tables$symbolnames[((i64)qq_decls$lx.symbol)-1],(byte*)"d");
        msysc$m_print_end();
        ;
        qq_lib$serror((u8 *)str);
    }
;
}

void qq_lib$skipsymbol(i64 symbol) {
    qq_lib$checksymbol(symbol);
    qq_lex$lex();
}

// START
void qq_lib$start(void) {

}

// START
void qq_lists$start(void) {

    qq_lists$emptylist = qq_vars$obj_new();
    (*qq_lists$emptylist).lower16 = (i64)1;
    (*qq_lists$emptylist).objtype = (i64)0;
}

void qq_lists$var_empty_list(i64 lower,struct qq_decls$varrec *dest) {
    (*dest).objptr = qq_lists$obj_newlist((i64)0,lower,0);
    (*dest).tagx = (i64)266;
}

void qq_lists$var_make_list(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 lower) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  b;
        i64 $av_1;
    p = qq_lists$obj_newlist(n,lower,0);
    b = (*p).varptr;
    if ((!!(n) && !!(a))) {
        $av_1 = n;
        while ($av_1-- > 0) {
L348 :;
            (*b) = (*a);
            ++(a);
            ++(b);
L349 :;
        }
L350 :;
        ;
    }
;
    (*dest).tagx = (i64)266;
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_lists$obj_newlist(i64 n,i64 lower,struct qq_decls$varrec *defval) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  a;
        i64 $av_1;
        i64 $av_2;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    if (!((($rtemp=lower, $rtemp >= (i64)-32768 && $rtemp <= (i64)32767)))) {
        qq_lib$pcerror((byte*)"List LWB not 16-bit");
    }
;
    (*p).lower16 = lower;
    (*p).length = n;
    (*p).objtype = (i64)0;
    if (!!(n)) {
        (*p).varptr = (a = (struct qq_decls$varrec *)mlib$pcm_alloc((n * (i64)16)));
        (*p).alloc64 = (mlib$allocbytes / (i64)16);
        if ((!!(defval) && ((i64)(*defval).tag != (i64)0))) {
            $av_1 = n;
            while ($av_1-- > 0) {
L351 :;
                if (!!((i64)(*defval).hasref)) {
                    ++((*(*defval).objptr).refcount);
                }
;
                (*a) = (*defval);
                ++(a);
L352 :;
            }
L353 :;
            ;
        }
        else {
            $av_2 = n;
            while ($av_2-- > 0) {
L354 :;
                (*a).tagx = (i64)0;
                ++(a);
L355 :;
            }
L356 :;
            ;
        }
;
    }
;
    return p;
}

void qq_lists$obj_free_list(struct qq_decls$objrec *p) {
        struct qq_decls$varrec *  q;
        i64 $av_1;
    q = (*p).varptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L357 :;
        if (!!((i64)(*q).hasref)) {
            qq_vars$var_unshareu(q);
        }
;
        ++(q);
L358 :;
    }
L359 :;
    ;
    if (!!((*p).length)) {
        mlib$pcm_free((*p).varptr,((*p).alloc64 * (i64)16));
    }
;
    mlib$pcm_free32(p);
}

void qq_lists$var_getix_list(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
        u64 offset;
        i64 lower;
    q = (*a).objptr;
    lower = (i64)(*q).lower16;
    offset = (u64)(index - lower);
    if ((offset >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"getlist[int] bounds");
    }
;
    (*a) = (*((*q).varptr + (i64)offset));
    if (!!((i64)(*a).hasref)) {
        ++((*(*a).objptr).refcount);
    }
;
}

void qq_lists$var_getslice_list(struct qq_decls$varrec *a,i64 i,i64 j) {
        struct qq_decls$varrec v;
        i64 alower;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    alower = (i64)(*p).lower16;
    if ((((i < alower) || (j > (((*p).length + alower) - (i64)1))) || (i > j))) {
        qq_lib$pcerror((byte*)"list/slice bounds");
    }
;
    q = qq_vars$obj_new();
    v.objptr = q;
    (*q).objtype = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,msysc$m_getdotindex((i64)(*p).flags,(i64)1));
    (*q).lower16 = (i64)1;
    (*q).varptr = (((*p).varptr + i) - alower);
        {i64 $temp = (i64)(*p).objtype;
if (($temp==(i64)1)) {
        (*q).objptr2 = (*p).objptr2;
        qq_vars$obj_shareu((*q).objptr2);
    }
    else if (($temp==(i64)2)) {
        (*q).objptr2 = 0;
        (*q).objtype = (i64)2;
    }
    else {
        (*q).objptr2 = p;
        ++((*p).refcount);
    }
    };
    (*q).length = ((j - i) + (i64)1);
    (*a).objptr = q;
}

void qq_lists$var_getixref_list(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$varrec *  p;
        struct qq_decls$objrec *  q;
        u64 offset;
        struct qq_decls$varrec v;
    q = (*a).objptr;
    offset = (u64)(index - (i64)(*q).lower16);
    if ((offset >= (u64)(*q).length)) {
        if (((i64)offset < (i64)0)) {
            qq_lib$pcerror((byte*)"&list[int] lwb");
        }
        else if (((i64)offset == (*q).length)) {
            if (((i64)(*q).objtype != (i64)0)) {
                qq_lib$pcerror((byte*)"Can't extend slice/ext");
            }
;
            v.tagx = (i64)0;
            qq_lists$obj_append_list(q,&v);
        }
        else {
            qq_lib$pcerror((byte*)"putlist[int] bounds");
        }
;
    }
;
    p = ((*q).varptr + (i64)offset);
    (*a).tagx = (i64)14;
    (*a).varptr = p;
}

void qq_lists$var_putix_list(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  dest;
        struct qq_decls$objrec *  q;
        u64 offset;
    q = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*q).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    offset = (u64)(index - (i64)(*q).lower16);
    if ((offset >= (u64)(*q).length)) {
        if (((i64)offset < (i64)0)) {
            qq_lib$pcerror((byte*)"putlist[int] lwb");
        }
        else if (((i64)offset == (*q).length)) {
            if (((i64)(*q).objtype != (i64)0)) {
                qq_lib$pcerror((byte*)"Can't extend slice/ext");
            }
;
            qq_lists$obj_append_list(q,x);
            return;
        }
        else {
            qq_lib$pcerror((byte*)"putlist[int] bounds");
        }
;
    }
;
    dest = ((*q).varptr + (i64)offset);
    if (!!((i64)(*dest).hasref)) {
        qq_vars$var_unshareu(dest);
    }
;
    (*dest) = (*x);
}

void qq_lists$var_putslice_list(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  r;
        struct qq_decls$varrec *  s;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 sublength;
        i64 $av_1;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    length = (*p).length;
    if ((((i < (i64)1) || (j > (*p).length)) || (i > j))) {
        qq_lib$pcerror((byte*)"list/slice bounds");
    }
;
    sublength = ((j - i) + (i64)1);
    q = (*x).objptr;
    if (((*q).length < sublength)) {
        qq_lib$pcerror((byte*)"substr too short");
    }
;
    r = (((*p).varptr + i) - (i64)1);
    s = (*q).varptr;
    $av_1 = sublength;
    while ($av_1-- > 0) {
L360 :;
        (*r) = (*s);
        if (!!((i64)(*r).hasref)) {
            ++((*(*r).objptr).refcount);
        }
;
        ++(r);
        ++(s);
L361 :;
    }
L362 :;
    ;
}

static void qq_lists$obj_append_list(struct qq_decls$objrec *a,struct qq_decls$varrec *x) {
        i64 n;
    if (((i64)(*a).objtype != (i64)0)) {
        qq_lib$pcerror((byte*)"Can't extend slice");
    }
;
    if (!(!!(msysc$m_getdotindex((i64)(*a).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    n = ((*a).length + (i64)1);
    if ((n > (*a).alloc64)) {
        qq_lists$obj_resize_list(a,n);
    }
    else {
        (*a).length = n;
    }
;
    if (!!(x)) {
        (*(((*a).varptr + n) - (i64)1)) = (*x);
    }
;
}

void qq_lists$obj_resize_list(struct qq_decls$objrec *p,i64 n) {
        struct qq_decls$varrec *  q;
        u32 allocated;
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        q = (struct qq_decls$varrec *)mlib$pcm_alloc((n * (i64)16));
        allocated = (mlib$allocbytes / (i64)16);
        if (!!((*p).length)) {
            memcpy(q,(*p).varptr,(u64)((*p).length * (i64)16));
            mlib$pcm_free((*p).varptr,((*p).alloc64 * (i64)16));
        }
;
        (*p).varptr = q;
        (*p).length = n;
        (*p).alloc64 = (i64)allocated;
    }
;
}

void qq_lists$var_appendto_list(struct qq_decls$varrec *a,struct qq_decls$varrec *x) {
    qq_lists$obj_append_list((*a).objptr,x);
}

void qq_lists$var_dupl_list(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$varrec *  plist;
        struct qq_decls$varrec *  qlist;
        i64 $av_1;
    p = (*a).objptr;
    q = qq_vars$obj_new();
    (*q) = (*p);
    (*q).refcount = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,(u64)1u);
    (*q).objtype = (i64)0;
    (*a).objptr = q;
    if (((*q).length == (i64)0)) {
        return;
    }
;
    qlist = ((*q).varptr = (struct qq_decls$varrec *)mlib$pcm_alloc(((*p).length * (i64)16)));
    (*q).alloc64 = (mlib$allocbytes / (i64)16);
    plist = (*p).varptr;
    $av_1 = (*q).length;
    while ($av_1-- > 0) {
L363 :;
        (*qlist) = (*plist);
        if (((i64)(*qlist).tag == (i64)12)) {
            if (!!((i64)(*qlist).hasref)) {
                ++((*(*qlist).objptr).refcount);
            }
;
        }
        else {
            if (!!((i64)(*qlist).hasref)) {
                qq_vars$var_duplu(qlist);
            }
;
        }
;
        ++(qlist);
        ++(plist);
L364 :;
    }
L365 :;
    ;
}

void qq_lists$var_mul_list(struct qq_decls$varrec *p,i64 m) {
        i64 oldlength;
        i64 newlength;
        i64 n;
        struct qq_decls$objrec *  q;
        struct qq_decls$objrec *  r;
        struct qq_decls$varrec *  a;
        struct qq_decls$varrec *  b;
        i64 $av_1;
    q = (*p).objptr;
    oldlength = (*q).length;
    newlength = (oldlength * m);
    if ((oldlength == (i64)0)) {
        return;
    }
;
    if ((newlength < (i64)0)) {
        qq_lib$pcerror((byte*)"list*int <0");
    }
    else if ((newlength == (i64)0)) {
        (*p).objptr = qq_lists$obj_newlist((i64)0,(i64)(*q).lower16,0);
        return;
    }
;
    r = qq_lists$obj_newlist(newlength,(i64)(*q).lower16,0);
    a = (*r).varptr;
    b = (*q).varptr;
    n = (i64)0;
    $av_1 = newlength;
    while ($av_1-- > 0) {
L366 :;
        (*a) = (*b);
        if (!!((i64)(*a).hasref)) {
            ++((*(*a).objptr).refcount);
        }
;
        ++(a);
        if ((oldlength > (i64)1)) {
            ++(b);
            if ((++(n) == oldlength)) {
                b = (*q).varptr;
                n = (i64)0;
            }
;
        }
;
L367 :;
    }
L368 :;
    ;
    (*p).objptr = r;
}

i64 qq_lists$var_equal_list(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
        struct qq_decls$varrec *  a;
        struct qq_decls$varrec *  b;
        i64 $av_1;
    px = (*x).objptr;
    py = (*y).objptr;
    if ((px == py)) {
        return (i64)1;
    }
;
    xlen = (*px).length;
    ylen = (*py).length;
    if ((xlen != ylen)) {
        return (i64)0;
    }
;
    if ((xlen == (i64)0)) {
        return (i64)1;
    }
;
    a = (*px).varptr;
    b = (*py).varptr;
    $av_1 = xlen;
    while ($av_1-- > 0) {
L369 :;
        if ((qq_vars$var_equal(a,b) == (i64)0)) {
            return (i64)0;
        }
;
        ++(a);
        ++(b);
L370 :;
    }
L371 :;
    ;
    return (i64)1;
}

void qq_lists$var_concatto_list(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  d;
        i64 alen;
        i64 blen;
        i64 newlen;
        struct qq_decls$objrec *  pa;
        struct qq_decls$objrec *  pb;
        i64 $av_1;
        i64 $av_2;
    pa = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*pa).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    pb = (*b).objptr;
    alen = (*pa).length;
    blen = (*pb).length;
    if ((alen == (i64)0)) {
        if (!!(blen)) {
            qq_lists$obj_resize_list(pa,blen);
            d = (*pa).varptr;
            memcpy(d,(*pb).varptr,(u64)(blen * (i64)16));
            $av_1 = blen;
            while ($av_1-- > 0) {
L372 :;
                if (!!((i64)(*d).hasref)) {
                    ++((*(*d).objptr).refcount);
                }
;
                ++(d);
L373 :;
            }
L374 :;
            ;
        }
;
    }
    else if (!!(blen)) {
        newlen = (alen + blen);
        qq_lists$obj_resize_list(pa,newlen);
        d = ((*pa).varptr + alen);
        memcpy(d,(*pb).varptr,(u64)(blen * (i64)16));
        $av_2 = blen;
        while ($av_2-- > 0) {
L375 :;
            if (!!((i64)(*d).hasref)) {
                ++((*(*d).objptr).refcount);
            }
;
            ++(d);
L376 :;
        }
L377 :;
        ;
    }
;
}

i64 qq_lists$var_inx_list(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 n;
        i64 lowerm1;
        struct qq_decls$varrec *  x;
        i64 i;
    n = (*(*b).objptr).length;
    lowerm1 = ((i64)(*(*b).objptr).lower16 - (i64)1);
    x = (*(*b).objptr).varptr;
    for (i=(i64)1;i<=n;++i) {
L378 :;
        if ((qq_vars$var_equal(a,x) == (i64)1)) {
            return (i + lowerm1);
        }
;
        ++(x);
L379 :;
    }
L380 :;
    ;
    return (i64)(-9223372036854775807-1);
}

struct qq_decls$subprogrec *qq_modules$loadsp(u8 *filename,u8 *source) {
        struct qq_decls$subprogrec *  sp;
        u8 *  modnames[100];
        u8 *  subnames[100];
        i64 nmods;
        i64 nsubs;
        i64 firstmod;
        i64 lastmod;
        i64 issyslib;
        struct qq_decls$filerec *  pm;
        struct qq_decls$strec *  d;
        u8 path[300];
        i64 i;
    nmods = (i64)0;
    nsubs = (i64)0;
    issyslib = (i64)0;
    if (!!(source)) {
        pm = qq_modules$loadstring(filename,source);
        path[((i64)1)-1] = (u64)0u;
    }
    else {
        if (!!(mlib$eqstring(mlib$extractbasefile(filename),(byte*)"sysp"))) {
            issyslib = (i64)1;
        }
;
        pm = qq_modules$loadsourcefile(filename,issyslib);
        if ((pm == 0)) {
            qq_lib$loaderror((byte*)"Can't load lead module: #",filename);
        }
;
        strcpy(path,(*pm).path);
    }
;
    for (i=(i64)1;i<=qq_decls$nsubprogs;++i) {
L381 :;
        if (!!(mlib$eqstring((*pm).name,(*qq_decls$subprogs[(i)-1]).name))) {
            qq_lib$loaderror((byte*)"Subprog already loaded: #",(*sp).name);
        }
;
L382 :;
    }
L383 :;
    ;
    qq_lex$startlex(pm);
    L384 :;
    while (1) {
        qq_lex$lex();
        qq_lib$skipsemi();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)119)) {
            qq_lex$lex();
            qq_lib$checksymbol((i64)79);
            if (!(!!(mlib$eqstring((*qq_decls$lx.symptr).name,(*pm).name)))) {
                if ((nmods >= (i64)100)) {
                    qq_lib$loaderror((byte*)"Too many modules in header",(byte*)"");
                }
;
                modnames[(++(nmods))-1] = (*qq_decls$lx.symptr).name;
            }
;
        }
        else if (($temp==(i64)120)) {
            qq_lex$lex();
            qq_lib$checksymbol((i64)79);
            if ((nsubs >= (i64)100)) {
                qq_lib$loaderror((byte*)"Too many imports in header",(byte*)"");
            }
;
            subnames[(++(nsubs))-1] = (*qq_decls$lx.symptr).name;
        }
        else if (($temp==(i64)5)) {
        }
        else {
            goto L385 ;
        }
        };
    }
L385 :;
    ;
    for (i=(i64)1;i<=nsubs;++i) {
L386 :;
        if (!!(mlib$eqstring(subnames[(i)-1],(*pm).name))) {
            qq_lib$loaderror((byte*)"Importing self",(byte*)"");
        }
;
        qq_api$compile_sp(qq_modules$getmodulefilename((byte*)"",subnames[(i)-1]),0);
L387 :;
    }
L388 :;
    ;
    if ((qq_decls$nsubprogs >= (i64)30)) {
        qq_lib$loaderror((byte*)"Too many subprogs",(byte*)"");
    }
;
    sp = (struct qq_decls$subprogrec *)mlib$pcm_allocz((i64)32);
    qq_decls$subprogs[(++(qq_decls$nsubprogs))-1] = sp;
    (*sp).subprogno = qq_decls$nsubprogs;
    firstmod = (qq_decls$nmodules + (i64)1);
    lastmod = (firstmod + nmods);
    if ((lastmod > (i64)200)) {
        qq_lib$loaderror((byte*)"Too many modules",(byte*)"");
    }
;
    qq_decls$nmodules = lastmod;
    (*pm).subprogno = qq_decls$nsubprogs;
    (*pm).islead = (i64)1;
    (*pm).moduleno = firstmod;
    (*pm).stmodule = (d = qq_names$createdupldef(qq_decls$stprogram,qq_lex$addnamestr((*pm).name),(i64)3));
    (*d).moduleno = firstmod;
    (*sp).name = (*pm).name;
    (*sp).path = (*pm).path;
    (*sp).filespec = (*pm).filespec;
    (*sp).firstmodule = firstmod;
    (*sp).lastmodule = lastmod;
    (*sp).issyslib = issyslib;
    qq_decls$modules[(firstmod)] = pm;
    for (i=(i64)1;i<=nmods;++i) {
L389 :;
        pm = qq_modules$loadsourcefile(qq_modules$getmodulefilename(path,modnames[(i)-1]),issyslib);
        if (!(!!(pm))) {
            qq_lib$loaderror((byte*)"Can't load: ##",modnames[(i)-1]);
        }
;
        qq_decls$modules[((firstmod + i))] = pm;
        (*pm).stmodule = (d = qq_names$createdupldef(qq_decls$stprogram,qq_lex$addnamestr((*pm).name),(i64)3));
        (*pm).subprogno = qq_decls$nsubprogs;
        (*d).moduleno = ((*pm).moduleno = (firstmod + i));
L390 :;
    }
L391 :;
    ;
    return sp;
}

static u8 *qq_modules$getmodulefilename(u8 *path,u8 *name) {
        static u8 str[300];
    strcpy(str,path);
    strcat(str,name);
    strcat(str,(byte*)".q");
    return str;
}

struct qq_decls$filerec *qq_modules$loadsourcefile(u8 *filespec,i64 issyslib) {
        struct qq_decls$filerec *  pm;
        u8 *  s;
        u8 *  basefilename;
    pm = (struct qq_decls$filerec *)mlib$pcm_allocz((i64)120);
    basefilename = mlib$extractbasefile(filespec);
    (*pm).filespec = mlib$pcm_copyheapstring(filespec);
    (*pm).path = mlib$pcm_copyheapstring(mlib$extractpath(filespec));
    (*pm).name = mlib$pcm_copyheapstring(basefilename);
    (*pm).issyslib = issyslib;
    if ((!!(qq_decls$nqafiles) && !!(qq_modules$loadqafile(pm)))) {
        return pm;
    }
;
    if ((!!(issyslib) && !!((i64)qq_decls$usebundled))) {
        (*pm).issyslib = issyslib;
        if (!(!!(qq_syslibs$loadsysmodule(pm)))) {
            qq_lib$loaderror((byte*)"LS:Can't load syslib",filespec);
        }
;
        return pm;
    }
;
    s = (u8 *)mlib$readfile(filespec);
    if (!(!!(s))) {
        return 0;
    }
;
    (*pm).text = s;
    (*pm).size = mlib$rfsize;
    (*(s + mlib$rfsize)) = (u64)0u;
    return pm;
}

struct qq_decls$filerec *qq_modules$loadstring(u8 *name,u8 *source) {
        struct qq_decls$filerec *  pm;
        u8 str[16];
        static i64 nextstrname = (i64)0;
    if ((name == 0)) {
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"S$",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64(++(nextstrname),NULL);
        msysc$m_print_end();
        ;
        name = mlib$pcm_copyheapstring(str);
    }
;
    pm = (struct qq_decls$filerec *)mlib$pcm_allocz((i64)120);
    (*pm).filespec = (byte*)"<string>";
    (*pm).path = (byte*)"";
    (*pm).name = name;
    (*pm).text = source;
    (*pm).size = strlen(source);
    return pm;
}

static u8 *qq_modules$readfileline(u8 *s) {
        u8 str[2048];
        u8 *  t;
        i64 n;
        i64 c;
    t = str;
    n = (i64)0;
    L392 :;
        {i64 $temp = (c = (i64)(u64)(*(s)++));
if (($temp==(i64)0)) {
        --(s);
        goto L393 ;
    }
    else if (($temp==(i64)10)) {
        goto L393 ;
    }
    else {
        if ((n < (i64)2048)) {
            (*(t)++) = (u64)c;
        }
;
    }
    }goto L392 ;
L393 :;
    ;
    (*t) = (u64)0u;
    msysc$m_read_strline(str);
    ;
    return s;
}

static u8 *qq_modules$findnextlineheader(u8 *s) {
        i64 c;
    L394 :;
        {i64 $temp = (c = (i64)(u64)(*(s)++));
if (($temp==(i64)0)) {
        return 0;
    }
    else if (($temp==(i64)10)) {
        if (((((u64)(*s) == '=') && ((u64)(*(s + (i64)1)) == '=')) && ((u64)(*(s + (i64)2)) == '='))) {
            return (s + (i64)3);
        }
;
    }
    }goto L394 ;
L395 :;
    ;
    return (u8 *)0;
}

static i64 qq_modules$loadqafile(struct qq_decls$filerec *pm) {
        u8 filename[300];
        i64 i;
    strcpy(filename,mlib$extractfile((*pm).filespec));
    for (i=(i64)1;i<=qq_decls$nqafiles;++i) {
L396 :;
        if (!!(mlib$eqstring(filename,qq_decls$qafilenames[(i)-1]))) {
            (*pm).text = qq_decls$qatext[(i)-1];
            (*pm).size = qq_decls$qasize[(i)-1];
            return (i64)1;
        }
;
L397 :;
    }
L398 :;
    ;
    return (i64)0;
}

void qq_modules$readqabundle(void) {
        u8 name[100];
        u8 *  s;
        u8 *  t;
        i64 sys;
        i64 support;
        i64 i;
    s = mlib$extractext(qq_api$inputfile,(i64)0);
    mlib$convlcstring(s);
    if (!(!!(mlib$eqstring(s,(byte*)"qa")))) {
        return;
    }
;
    s = (u8 *)mlib$readfile(qq_api$inputfile);
    if ((s == 0)) {
        qq_lib$loaderror((byte*)"Can't find QA file ##",qq_api$inputfile);
    }
;
    qq_api$inputfile = mlib$pcm_copyheapstring(mlib$changeext(qq_api$inputfile,(byte*)"q"));
    s = qq_modules$readfileline((s + (i64)3));
    msysc$readstr(name,(i64)110,(i64)0);
    if (!(!!(mlib$eqstring(name,(byte*)"qa")))) {
        qq_lib$loaderror((byte*)"QA: bad header",(byte*)"");
    }
;
    --(s);
    s = qq_modules$findnextlineheader(s);
    L399 :;
    while (1) {
        if ((s == 0)) {
            qq_lib$loaderror((byte*)"Unexpected EOF in QA file",(byte*)"");
            goto L400 ;
        }
;
        s = qq_modules$readfileline(s);
        msysc$readstr(name,(i64)110,(i64)0);
        {
            sys = msysc$m_read_i64((i64)0);
            ;
            support = msysc$m_read_i64((i64)0);
            ;
        }
        if (!!(mlib$eqstring(name,(byte*)"end"))) {
            goto L400 ;
        }
;
        if ((qq_decls$nqafiles >= (i64)100)) {
            qq_lib$loaderror((byte*)"Too many QA files",(byte*)"");
        }
;
        t = qq_modules$findnextlineheader(s);
        if ((t == 0)) {
            qq_lib$loaderror((byte*)"QA error",(byte*)"");
        }
;
        ++(qq_decls$nqafiles);
        qq_decls$qafilenames[(qq_decls$nqafiles)-1] = mlib$pcm_copyheapstring(name);
        qq_decls$qasize[(qq_decls$nqafiles)-1] = ((t - s) - (i64)3);
        qq_decls$qatext[(qq_decls$nqafiles)-1] = s;
        s = t;
    }
L400 :;
    ;
    for (i=(i64)1;i<=qq_decls$nqafiles;++i) {
L401 :;
        (*(qq_decls$qatext[(i)-1] + qq_decls$qasize[(i)-1])) = (u64)0u;
L402 :;
    }
L403 :;
    ;
}

// START
void qq_modules$start(void) {

}

struct qq_decls$strec *qq_names$addglobalname(u8 *name) {
        struct qq_decls$lexrec oldlx;
        struct qq_decls$strec *  d;
    oldlx = qq_decls$nextlx;
    qq_lex$lookup(name,strlen(name),qq_lex$gethashvaluez(name));
    d = (struct qq_decls$strec *)qq_decls$nextlx.symptr;
    qq_decls$nextlx = oldlx;
    return d;
}

static struct qq_decls$strec *qq_names$newstrec(void) {
        struct qq_decls$strec *  p;
    p = (struct qq_decls$strec *)mlib$pcm_alloc((i64)112);
    memset(p,(i32)(i64)0,(u64)112u);
    return p;
}

struct qq_decls$strec *qq_names$addsymbol(struct qq_decls$strec *owner,struct qq_decls$strec *d,i64 id,i64 isglobal) {
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  f;
    e = qq_names$newstrec();
    (*e).name = (*d).name;
    (*e).namelen = (i64)(*d).namelen;
    (*e).owner = owner;
    (*e).nameid = id;
    (*e).flags = msysc$m_setdotindex((*e).flags,(i64)9,(u64)((id == (i64)14) || (id == (i64)15)));
    if (!!(qq_decls$currmodule)) {
        (*e).moduleno = (i64)(*qq_decls$currmodule).moduleno;
    }
;
    (*e).firstdupl = d;
    (*e).flags = msysc$m_setdotslice((*e).flags,(i64)0,(i64)1,(u64)isglobal);
    if (!(!!(owner))) {
        return e;
    }
;
    if (!(((i64)(*owner).nameid == (i64)5 || (i64)(*owner).nameid == (i64)6))) {
        (*e).nextdupl = (*d).nextdupl;
        (*d).nextdupl = e;
        if ((!!((*e).nextdupl) && ((*(*e).nextdupl).owner == owner))) {
            msysc$m_print_startcon();
            msysc$m_print_str((*e).name,NULL);
            msysc$m_print_str((byte*)"in",NULL);
            msysc$m_print_str((*owner).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$serror((byte*)"AS:Duplicate name");
        }
;
    }
    else {
        f = (*owner).deflist;
        L404 :;
        while (!!(f)) {
            if (((*f).firstdupl == (*e).firstdupl)) {
                msysc$m_print_startcon();
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_str((byte*)"in",NULL);
                msysc$m_print_str((*owner).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                qq_lib$serror((byte*)"AS2:Duplicate name");
            }
;
            f = (*f).nextdef;
L405 :;
        }
L406 :;
        ;
    }
;
    if (((*owner).deflist == 0)) {
        (*owner).deflist = e;
    }
    else {
        (*(*owner).deflistx).nextdef = e;
    }
;
    (*owner).deflistx = e;
    return e;
}

void qq_names$addproc(struct qq_decls$strec *d) {
        struct qq_decls$procrec *  p;
    p = (struct qq_decls$procrec *)mlib$pcm_allocz((i64)16);
    (*p).def = d;
    if ((qq_decls$proclist == 0)) {
        qq_decls$proclist = (struct qq_decls$procrec *)p;
    }
    else {
        (*qq_decls$proclistx).nextproc = (struct qq_decls$procrec *)p;
    }
;
    qq_decls$proclistx = (struct qq_decls$procrec *)p;
    ++(qq_decls$nproclist);
}

i64 qq_names$newusertypex(struct qq_decls$strec *d,struct qq_decls$strec *e) {
    if ((qq_tables$nuserxtypes >= (i64)5000)) {
        qq_lib$serror((byte*)"Too many external user types");
    }
;
    ++(qq_tables$nuserxtypes);
    qq_tables$ttnamedefx[(qq_tables$nuserxtypes)] = (struct qq_decls$strec *)d;
    qq_tables$ttxmoduleno[(qq_tables$nuserxtypes)] = (i64)(*qq_decls$stcurrmodule).moduleno;
    return -(qq_tables$nuserxtypes);
}

struct qq_decls$strec *qq_names$resolvedottedname(struct qq_decls$strec *owner,struct qq_decls$strec *d) {
        struct qq_decls$strec *  e;
    e = (*d).nextdupl;
    L407 :;
    while ((!!(e) && ((*e).owner != owner))) {
        e = (*e).nextdupl;
L408 :;
    }
L409 :;
    ;
    return e;
}

void qq_names$addgenfield(struct qq_decls$strec *d) {
        i64 index;
        struct qq_decls$strec *  dgen;
        struct qq_decls$genfieldrec *  g;
    dgen = (*d).firstdupl;
    index = (*dgen).genfieldindex;
    if ((index == (i64)0)) {
        if ((qq_decls$ngenfields >= (i64)1000)) {
            qq_lib$pcerror((byte*)"Too many genfields");
        }
;
        (*dgen).genfieldindex = (index = ++(qq_decls$ngenfields));
    }
;
    g = (struct qq_decls$genfieldrec *)mlib$pcm_alloc((i64)16);
    (*g).def = d;
    (*g).nextdef = (struct qq_decls$genfieldrec *)qq_decls$genfieldtable[(index)-1];
    qq_decls$genfieldtable[(index)-1] = (struct qq_decls$genfieldrec *)g;
}

i64 qq_names$makereftype(i64 target,struct qq_decls$strec *owner) {
        i64 newtype;
        i64 i;
    if ((owner == 0)) {
        for (i=(i64)40;i<=qq_tables$ntypes;++i) {
L410 :;
            if ((((i64)qq_tables$ttbasetype[(i)] == (i64)16) && ((i64)qq_tables$tttarget[(i)] == target))) {
                return i;
            }
;
L411 :;
        }
L412 :;
        ;
    }
;
    newtype = qq_names$addanontype();
    qq_tables$ttbasetype[(newtype)] = (i64)16;
    qq_lib$storemode(qq_decls$stcurrproc,target,&qq_tables$tttarget[(newtype)]);
    qq_tables$ttsize[(newtype)] = (i64)8;
    qq_tables$ttbitwidth[(newtype)] = (i64)64;
    return newtype;
}

i64 qq_names$makeaxtype(i64 target,struct qq_decls$unitrec *plower,struct qq_decls$unitrec *plength) {
        i64 newtype;
    newtype = qq_names$addanontype();
    qq_tables$ttbasetype[(newtype)] = (i64)7;
    qq_lib$storemode(qq_decls$stcurrproc,target,&qq_tables$tttarget[(newtype)]);
    qq_tables$ttlower[(newtype)] = (i64)1;
    qq_tables$ttlengthexpr[(newtype)] = plength;
    qq_tables$ttlowerexpr[(newtype)] = plower;
    return newtype;
}

i64 qq_names$makeslicetype(i64 target) {
        i64 newtype;
    newtype = qq_names$addanontype();
    qq_tables$ttbasetype[(newtype)] = (i64)39;
    qq_lib$storemode(qq_decls$stcurrproc,target,&qq_tables$tttarget[(newtype)]);
    qq_tables$ttlower[(newtype)] = (i64)1;
    qq_tables$ttsize[(newtype)] = (i64)16;
    return newtype;
}

i64 qq_names$makestrtype(i64 m,struct qq_decls$unitrec *pwidth) {
        i64 newtype;
    newtype = qq_names$addanontype();
    qq_tables$ttbasetype[(newtype)] = m;
    qq_tables$ttlengthexpr[(newtype)] = pwidth;
    qq_tables$ttlower[(newtype)] = (i64)1;
    qq_tables$ttowner[(newtype)] = qq_decls$stcurrproc;
    return newtype;
}

i64 qq_names$addanontype(void) {
        u8 str[32];
    if ((qq_tables$ntypes >= (i64)250)) {
        qq_lib$pcerror((byte*)"Too many types");
    }
;
    ++(qq_tables$ntypes);
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"$T",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(qq_tables$ntypes,NULL);
    msysc$m_print_end();
    ;
    qq_tables$ttname[(qq_tables$ntypes)] = mlib$pcm_copyheapstring(str);
    qq_tables$ttowner[(qq_tables$ntypes)] = qq_decls$stcurrproc;
    return qq_tables$ntypes;
}

void qq_names$createusertype(struct qq_decls$strec *d,i64 m) {
    qq_lib$storemode(qq_decls$stcurrproc,m,&(*d).mode);
    if (((m > (i64)39) && (qq_tables$ttnamedef[(m)] == 0))) {
        qq_tables$ttnamedef[(m)] = d;
        qq_tables$ttname[(m)] = (*d).name;
        qq_tables$ttowner[(m)] = (*d).owner;
    }
;
}

i64 qq_names$getalignment(i64 m) {
        i64 a;
        {i64 $temp = (i64)qq_tables$ttbasetype[(m)];
if (($temp==(i64)7)) {
        return qq_names$getalignment((i64)qq_tables$tttarget[(m)]);
    }
    else if (($temp==(i64)13)) {
    }
    };
    a = qq_tables$ttsize[(m)];
    if ((a==(i64)1) || (a==(i64)2) || (a==(i64)4) || (a==(i64)8)) {
        return a;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str(qq_tables$ttname[(m)],NULL);
    msysc$m_print_i64(a,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_lib$pcerror((byte*)"Getalign not 1248");
    return (i64)0;
}

void qq_names$duplfield(struct qq_decls$strec *p,struct qq_decls$strec *q) {
    if (!!((*p).code)) {
        qq_lib$serror((byte*)"DUPLFIELD");
    }
;
    (*q).atfield = (*p).atfield;
    (*q).index = (i64)(*p).index;
    (*q).fieldoffset = (i64)(*p).fieldoffset;
}

static void qq_names$writesig(struct qq_decls$strec *d,void *dev) {
        struct qq_decls$strec *  e;
        i64 n;
    msysc$m_print_startfile(dev);
    msysc$m_print_setfmt((byte*)"# #(");
    msysc$m_print_str((!!(msysc$m_getdotindex((i64)(*d).flags,(i64)4)) ? (byte*)"function" : (byte*)"proc"),NULL);
    msysc$m_print_str((*d).name,NULL);
    msysc$m_print_end();
    ;
    e = (*d).deflist;
    n = (i64)0;
    L413 :;
    while (!!(e)) {
        if (((i64)(*e).nameid == (i64)15)) {
            ++(n);
            if ((!!(msysc$m_getdotindex((i64)(*e).flags,(i64)7)) && !!((*e).code))) {
                msysc$m_print_startfile(dev);
                msysc$m_print_setfmt((byte*)"#=#");
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_str((*qq_lib$strexpr((*e).code)).strptr,NULL);
                msysc$m_print_end();
                ;
            }
            else if (!!(msysc$m_getdotindex((i64)(*e).flags,(i64)7))) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)"?",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_end();
                ;
            }
            else {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_end();
                ;
            }
;
            if ((n < (i64)(*d).nparams)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)", ",NULL);
                msysc$m_print_end();
                ;
            }
;
        }
;
L414 :;
        e = (*e).nextdef;
L416 :;
            }
L415 :;
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_setfmt((byte*)")\t[#]");
    msysc$m_print_str((*(*d).owner).name,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

struct qq_decls$strec *qq_names$createdupldef(struct qq_decls$strec *owner,struct qq_decls$strec *symptr,i64 id) {
        struct qq_decls$strec *  p;
    p = qq_names$newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (i64)(*symptr).namelen;
    (*p).symbolcode = (i64)79;
    (*p).owner = owner;
    (*p).nameid = id;
    (*p).nextdupl = (*symptr).nextdupl;
    (*symptr).nextdupl = p;
    if (!!(owner)) {
        if (((*owner).deflist == 0)) {
            (*owner).deflist = ((*owner).deflistx = p);
        }
        else {
            (*(*owner).deflistx).nextdef = p;
            (*owner).deflistx = p;
        }
;
    }
;
    return p;
}

// START
void qq_names$start(void) {

}

void qq_optimdummy$optimise_module(i64 n) {
}

// START
void qq_optimdummy$start(void) {

}

void qq_packed$var_loadpacked(void *p,i64 t,struct qq_decls$varrec *dest,struct qq_decls$objrec *ownerobj) {
        i64 length;
        struct qq_decls$objrec *  s;
        u8 *  ss;
        i64 $av_1;
    (*dest).tagx = (i64)1;
    switch ((i64)qq_tables$ttbasetype[(t)]) {
    case 22:;
        {
            (*dest).value = (i64)(*(i8 *)p);
        }
        break;
    case 23:;
        {
            (*dest).value = (i64)(*(i16 *)p);
        }
        break;
    case 24:;
        {
            (*dest).value = (i64)(*(i32 *)p);
        }
        break;
    case 25:;
        {
            (*dest).value = (*(i64 *)p);
        }
        break;
    case 26:;
        {
            (*dest).value = (i64)(*(byte *)p);
        }
        break;
    case 27:;
        {
            (*dest).value = (i64)(*(u16 *)p);
        }
        break;
    case 28:;
        {
            (*dest).value = (i64)(*(u32 *)p);
        }
        break;
    case 29:;
        {
            (*dest).tagx = (i64)1;
            (*dest).uvalue = (*(u64 *)p);
        }
        break;
    case 31:;
        {
            (*dest).tagx = (i64)2;
            (*dest).xvalue = (*(r64 *)p);
        }
        break;
    case 30:;
        {
            (*dest).tagx = (i64)2;
            (*dest).xvalue = (r64)(*(r32 *)p);
        }
        break;
    case 35:;
        {
            (*dest).tagx = (i64)265;
            length = qq_tables$ttlength[(t)];
            if ((length >= (i64)2)) {
                length = qq_packed$getfslength((u8 *)p,length);
            }
            else {
                length = (i64)1;
            }
;
            s = qq_strings$obj_make_strslicexobj((u8 *)p,length);
            (*dest).objptr = s;
        }
        break;
    case 36:;
        {
            (*dest).tagx = (i64)265;
            ss = (u8 *)p;
            $av_1 = qq_tables$ttlength[(t)];
            while ($av_1-- > 0) {
L417 :;
                if (((i64)(u64)(*ss) == (i64)0)) {
                    goto L419 ;
                }
;
                ++(ss);
L418 :;
            }
L419 :;
            ;
            s = qq_strings$obj_make_strslicexobj((u8 *)p,(ss - (u8 *)p));
            (*dest).objptr = s;
        }
        break;
    default: {
                {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)16)) {
            (*dest).tagx = (i64)16;
            (*dest).ptr = (byte *)(*(i64 *)p);
            (*dest).elemtag = (i64)qq_tables$tttarget[(t)];
        }
        else if (($temp==(i64)13)) {
            s = qq_vars$obj_new();
            (*s).flags = msysc$m_setdotindex((*s).flags,(i64)1,(u64)1u);
            (*s).ptr = (byte *)p;
            (*dest).objptr = s;
            (*dest).tagx = (i64)269;
            (*s).usertag = t;
            if (!!(ownerobj)) {
                (*s).objtype = (i64)1;
                (*s).objptr2 = ownerobj;
                ++((*ownerobj).refcount);
            }
            else {
                (*s).objtype = (i64)2;
            }
;
        }
        else if (($temp==(i64)7)) {
            s = qq_arrays$obj_newarray((i64)qq_tables$tttarget[(t)],qq_tables$ttlower[(t)],qq_tables$ttlength[(t)]);
            (*s).flags = msysc$m_setdotindex((*s).flags,(i64)1,(u64)1u);
            (*s).ptr = (byte *)p;
            (*dest).objptr = s;
            (*dest).tagx = (i64)263;
            (*s).usertag = t;
            if (!!(ownerobj)) {
                (*s).objtype = (i64)1;
                (*s).objptr2 = ownerobj;
                ++((*ownerobj).refcount);
            }
            else {
                (*s).objtype = (i64)2;
            }
;
        }
        else {
            qq_lib$pcmxtypestt((byte*)"loadpacked",(i64)qq_tables$ttbasetype[(t)],t);
        }
        };
    }
    } //SW
;
}

void qq_packed$var_storepacked(byte *p,struct qq_decls$varrec *q,i64 t) {
        i64 plength;
        i64 qlength;
        i64 s;
        i64 sbase;
        i64 tbase;
        struct qq_decls$objrec *  qa;
    s = (sbase = (i64)(*q).tag);
    tbase = (i64)qq_tables$ttbasetype[(t)];
    switch (sbase) {
    case 1:;
    case 16:;
        {
            switch (tbase) {
            case 22:;
            case 26:;
                {
                    (*p) = (*q).value;
                    return;
                }
                break;
            case 23:;
            case 27:;
                {
                    (*(u16 *)p) = (*q).value;
                    return;
                }
                break;
            case 24:;
            case 28:;
                {
                    (*(i32 *)p) = (*q).value;
                    return;
                }
                break;
            case 25:;
            case 29:;
            case 16:;
                {
                    (*(i64 *)p) = (*q).value;
                    return;
                }
                break;
            case 30:;
                {
                    (*(r32 *)p) = (r32)(*q).value;
                    return;
                }
                break;
            case 31:;
                {
                    (*(r64 *)p) = (r64)(*q).value;
                    return;
                }
                break;
            } //SW
;
        }
        break;
    case 2:;
        {
            switch (tbase) {
            case 24:;
            case 28:;
                {
                    (*(i32 *)p) = (i64)(*q).xvalue;
                    return;
                }
                break;
            case 25:;
            case 29:;
                {
                    (*(i64 *)p) = (i64)(*q).xvalue;
                    return;
                }
                break;
            case 30:;
                {
                    (*(r32 *)p) = (r32)(*q).xvalue;
                    return;
                }
                break;
            case 31:;
                {
                    (*(r64 *)p) = (*q).xvalue;
                    return;
                }
                break;
            case 23:;
            case 27:;
                {
                    (*(i16 *)p) = (i64)(*q).xvalue;
                    return;
                }
                break;
            } //SW
;
        }
        break;
    case 9:;
        {
            qa = (*q).objptr;
            plength = qq_tables$ttlength[(t)];
            qlength = (*qa).length;
            switch (tbase) {
            case 35:;
                {
                    if ((t == tbase)) {
                        if ((qlength != (i64)1)) {
                            qq_lib$pcerror((byte*)"Str not len 1");
                        }
;
                        (*(u8 *)p) = (u64)(*(*qa).strptr);
                        return;
                    }
;
                    if ((qlength > plength)) {
                        qlength = plength;
                    }
;
                    memcpy(p,(void *)(*qa).strptr,(u64)qlength);
                    qq_packed$setfslength((u8 *)p,plength,qlength);
                    return;
                }
                break;
            case 36:;
                {
                    if ((qlength >= plength)) {
                        memcpy(p,(void *)(*qa).strptr,(u64)plength);
                        (*((p + plength) - (i64)1)) = (i64)0;
                    }
                    else {
                        memcpy(p,(void *)(*qa).strptr,(u64)qlength);
                        (*(p + qlength)) = (i64)0;
                    }
;
                    return;
                }
                break;
            } //SW
;
        }
        break;
    case 13:;
        {
            s = (i64)(*(*q).objptr).usertag;
            if ((s != t)) {
                qq_lib$pcmxtypestt((byte*)"spack struct",s,t);
            }
;
            memcpy(p,(*(*q).objptr).ptr,(u64)qq_tables$ttsize[(t)]);
            return;
        }
        break;
    case 7:;
        {
            s = (i64)(*(*q).objptr).usertag;
            if ((s != t)) {
                qq_lib$pcmxtypestt((byte*)"spack array",s,t);
            }
;
            memcpy(p,(*(*q).objptr).ptr,(u64)qq_tables$ttsize[(t)]);
            return;
        }
        break;
    } //SW
;
    qq_lib$pcmxtypestt((byte*)"storepacked (source->dest)",s,t);
}

static void qq_packed$setfslength(u8 *s,i64 m,i64 n) {
    if ((m == n)) {
    }
    else if ((n == (m - (i64)1))) {
        (*((s + m) - (i64)1)) = (u64)0u;
    }
    else {
        (*((s + m) - (i64)2)) = (u64)0u;
        (*((s + m) - (i64)1)) = (u64)n;
    }
;
}

i64 qq_packed$getfslength(u8 *s,i64 m) {
    s += (m - (i64)1);
    if (((i64)(u64)(*(s - (i64)1)) == (i64)0)) {
        return (i64)(u64)(*s);
    }
    else if (((i64)(u64)(*s) == (i64)0)) {
        return (m - (i64)1);
    }
    else {
        return m;
    }
;
}

void qq_packed$var_make_struct(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 rectype) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec **  r;
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  b;
        i64 m;
        byte *  q;
        i64 $av_1;
    p = qq_packed$obj_new_struct(rectype);
    b = (*p).varptr;
    m = qq_tables$ttlength[(rectype)];
    d = qq_tables$ttnamedef[(rectype)];
    r = (struct qq_decls$strec **)(*d).topfieldlist;
    if ((n < m)) {
        qq_lib$pcerror((byte*)"Too few elements");
    }
    else if ((n > m)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=",NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_str((byte*)"M=",NULL);
        msysc$m_print_i64(m,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$pcerror((byte*)"Too many elements");
    }
;
    q = (*p).ptr;
    $av_1 = n;
    while ($av_1-- > 0) {
L420 :;
        qq_packed$var_storepacked(q,a,(i64)(*(*r)).mode);
        q += qq_tables$ttsize[((i64)(*(*r)).mode)];
        ++(r);
        ++(a);
L421 :;
    }
L422 :;
    ;
    (*dest).tagx = (i64)269;
    (*p).usertag = rectype;
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_packed$obj_new_struct(i64 m) {
        struct qq_decls$objrec *  p;
        i64 size;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).usertag = m;
    size = qq_tables$ttsize[(m)];
    if (!!(size)) {
        (*p).ptr = (byte *)mlib$pcm_allocz(size);
    }
;
    return p;
}

void qq_packed$var_dupl_struct(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 size;
    p = (*a).objptr;
    size = qq_tables$ttsize[((i64)(*p).usertag)];
    q = qq_packed$obj_new_struct((i64)(*p).usertag);
    (*a).objptr = q;
    memcpy((*q).ptr,(*p).ptr,(u64)size);
}

void qq_packed$obj_free_struct(struct qq_decls$objrec *p) {
    mlib$pcm_free((*p).ptr,qq_tables$ttsize[((i64)(*p).usertag)]);
    mlib$pcm_free32(p);
}

i64 qq_packed$var_equal_struct(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
    return mlib$eqbytes((*(*x).objptr).ptr,(*(*y).objptr).ptr,qq_tables$ttsize[((i64)(*x).tag)]);
}

void qq_packed$var_getix_struct(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec **  r;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  p;
    v = (*a);
    p = (*a).objptr;
    if (((index < (i64)1) || (index > qq_tables$ttlength[((i64)(*a).tag)]))) {
        qq_lib$pcerror((byte*)"struct[int] bounds");
    }
;
    d = qq_tables$ttnamedef[((i64)(*p).usertag)];
    r = (struct qq_decls$strec **)(((*d).topfieldlist + index) - (i64)1);
    qq_packed$var_loadpacked(((*p).ptr + (i64)(*(*r)).fieldoffset),(i64)(*(*r)).mode,a,0);
}

// START
void qq_packed$start(void) {

}

void qq_parse$parsemodule(struct qq_decls$filerec *pm) {
        struct qq_decls$unitrec *  p;
    if (!!((i64)(*pm).compiled)) {
        return;
    }
;
    qq_decls$currmodule = pm;
    qq_decls$stcurrmodule = (*qq_decls$currmodule).def;
    qq_lex$startlex(qq_decls$currmodule);
    qq_lex$lex();
    qq_lex$lex();
    qq_decls$stcurrproc = qq_decls$stcurrmodule;
    p = qq_parse$readsunit((i64)0);
    (*qq_decls$stcurrmodule).code = ((*pm).ast = p);
    qq_lib$skipsemi();
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)4)) {
        qq_lib$serror((byte*)"Comma seq not allowed");
    }
    else if (($temp==(i64)71)) {
    }
    else {
        qq_lex$ps((byte*)"EOF");
        qq_lib$serror((byte*)"Bad symbol at eof");
    }
    };
}

static struct qq_decls$unitrec *qq_parse$readexpression(void) {
        struct qq_decls$unitrec *  p;
    p = qq_parse$readterm2();
    if (!!((i64)qq_tables$exprendset[((i64)qq_decls$lx.symbol)])) {
        return p;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)8 || (i64)qq_decls$lx.symbol == (i64)9)) {
        return qq_parse$readassignment(p);
    }
    else {
        return qq_parse$readorterms(p);
    }
;
}

static struct qq_decls$unitrec *qq_parse$readassignment(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 opc;
    if (!!((i64)qq_tables$exprendset[((i64)qq_decls$lx.symbol)])) {
        return p;
    }
;
    p = qq_parse$readorterms(p);
    if (((i64)qq_decls$lx.symbol == (i64)8 || (i64)qq_decls$lx.symbol == (i64)9)) {
        opc = (i64)qq_decls$lx.subcode;
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        p = qq_lib$createunit2(opc,p,qq_parse$readassignment(qq_parse$readterm2()));
        (*p).pos = pos;
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readorterms(struct qq_decls$unitrec *p) {
        i64 pos;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
    if (!!((i64)qq_tables$exprendset[((i64)qq_decls$lx.symbol)])) {
        return p;
    }
;
    p = qq_parse$readandterms(p);
    L423 :;
    while (((i64)qq_decls$lx.symbol == (i64)35)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)8)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)173,p,qq_parse$readexpression());
            (*p).pos = pos;
            goto L425 ;
        }
;
        p = qq_lib$createunit2((i64)154,p,qq_parse$readandterms(qq_parse$readterm2()));
        (*p).pos = pos;
L424 :;
    }
L425 :;
    ;
    L426 :;
    while (((i64)qq_decls$lx.symbol == (i64)11)) {
        qq_lex$lex();
        q = (r = qq_parse$readterm2());
        if (((i64)(*q).tag == (i64)30)) {
            r = (*q).b;
            L429 :;
            while (!!((*r).nextunit)) {
L430 :;
                r = (*r).nextunit;
L432 :;
                            }
L431 :;
            ;
            (*r).nextunit = p;
            p = q;
        }
        else {
            p = qq_lib$createunit2((i64)30,q,p);
        }
;
L427 :;
    }
L428 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readandterms(struct qq_decls$unitrec *p) {
        i64 pos;
    p = qq_parse$readcmpterms(p);
    L433 :;
    while (((i64)qq_decls$lx.symbol == (i64)34)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)8)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)172,p,qq_parse$readexpression());
            (*p).pos = pos;
            goto L435 ;
        }
;
        p = qq_lib$createunit2((i64)153,p,qq_parse$readcmpterms(qq_parse$readterm2()));
        (*p).pos = pos;
L434 :;
    }
L435 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readcmpterms(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 n;
        struct qq_decls$unitrec *  px;
        struct qq_decls$unitrec *  q;
        byte genops[4];
    p = qq_parse$readinterms(p);
    if (!(!!((i64)qq_tables$cmpopset[((i64)qq_decls$lx.symbol)]))) {
        return p;
    }
;
    memset(&(genops),0,4);
    px = p;
    p = qq_lib$createunit1((i64)42,p);
    n = (i64)0;
    L436 :;
    while (!!((i64)qq_tables$cmpopset[((i64)qq_decls$lx.symbol)])) {
        ++(n);
        if ((n > (i64)4)) {
            qq_lib$serror((byte*)"cmpchain: Too many items");
        }
;
        genops[(n)-1] = (i64)qq_decls$lx.subcode;
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        q = qq_parse$readinterms(qq_parse$readterm2());
        (*px).nextunit = q;
        px = q;
        (*q).pos = pos;
L437 :;
    }
L438 :;
    ;
    if ((n == (i64)1)) {
        (*p).tag = (i64)genops[((i64)1)-1];
        q = (*p).a;
        (*p).b = (*q).nextunit;
        (*q).nextunit = 0;
    }
    else {
        memcpy(&(*p).cmpgenop,&genops,4);
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readinterms(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 opc;
    p = qq_parse$readrangeterm(p);
    L439 :;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)45) || ($temp==(i64)46) || ($temp==(i64)47)) {
        opc = (i64)qq_decls$lx.subcode;
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        p = qq_lib$createunit2(opc,p,qq_parse$readrangeterm(qq_parse$readterm2()));
        (*p).pos = pos;
    }
    else {
        goto L440 ;
    }
    }goto L439 ;
L440 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readrangeterm(struct qq_decls$unitrec *p) {
        i64 pos;
    p = qq_parse$readaddterms(p);
    if (((i64)qq_decls$lx.symbol == (i64)24)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        p = qq_lib$createunit2((i64)183,p,qq_parse$readaddterms(qq_parse$readterm2()));
        (*p).pos = pos;
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readaddterms(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 opc;
        struct qq_decls$unitrec *  q;
    p = qq_parse$readmulterms(p);
    L441 :;
    while (!!((i64)qq_tables$addopset[((i64)qq_decls$lx.symbol)])) {
                {i64 $temp = (opc = (i64)qq_decls$lx.subcode);
if (($temp==(i64)57)) {
            opc = (i64)164;
        }
        };
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)8)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)qq_tables$jtocodes[(opc)],p,qq_parse$readassignment(qq_parse$readterm2()));
            (*p).pos = pos;
            goto L443 ;
        }
;
        q = qq_parse$readmulterms(qq_parse$readterm2());
        p = qq_lib$createunit2(opc,p,q);
        (*p).pos = pos;
L442 :;
    }
L443 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readmulterms(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 opc;
    p = qq_parse$readpowerterms(p);
    L444 :;
    while (!!((i64)qq_tables$mulopset[((i64)qq_decls$lx.symbol)])) {
        opc = (i64)qq_decls$lx.subcode;
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)8)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)qq_tables$jtocodes[(opc)],p,qq_parse$readassignment(qq_parse$readterm2()));
            (*p).pos = pos;
            goto L446 ;
        }
;
        p = qq_lib$createunit2(opc,p,qq_parse$readpowerterms(qq_parse$readterm2()));
        (*p).pos = pos;
L445 :;
    }
L446 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readpowerterms(struct qq_decls$unitrec *p) {
        i64 pos;
    L447 :;
    while (((i64)qq_decls$lx.symbol == (i64)49)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        p = qq_lib$createunit2((i64)165,p,qq_parse$readpowerterms(qq_parse$readterm2()));
        (*p).pos = pos;
L448 :;
    }
L449 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readterm2(void) {
        struct qq_decls$unitrec *  p;
        i64 pos;
    pos = (i64)qq_decls$lx.pos;
    p = qq_parse$readterm();
    p = qq_parse$readtermsuffix(p,pos);
    return p;
}

static struct qq_decls$unitrec *qq_parse$readtermsuffix(struct qq_decls$unitrec *p,i64 pos) {
        struct qq_decls$unitrec *  q;
        i64 opc;
        i64 nparams;
    L450 :;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)12)) {
        qq_lex$lex();
        q = qq_parse$readslist(&nparams,(i64)1);
        qq_lib$skipsymbol((i64)13);
        p = qq_lib$createunit2((i64)30,p,q);
        p = qq_parse$readcondsuffix(p);
    }
    else if (($temp==(i64)18)) {
        p = qq_lib$createunit1((i64)56,p);
        qq_lex$lex();
    }
    else if (($temp==(i64)14)) {
        p = qq_parse$readindex(p,(i64)0);
    }
    else if (($temp==(i64)2)) {
        p = qq_parse$readdotsuffix(p);
    }
    else if (($temp==(i64)16)) {
        p = qq_parse$readkeyindex(p);
    }
    else if (($temp==(i64)6)) {
        if ((qq_parse$listtype==(i64)331808391504)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)4,p,qq_parse$readexpression());
        }
        else if ((qq_parse$listtype==(i64)1413695812)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)5,p,qq_parse$readexpression());
        }
        else {
            goto L451 ;
        }
;
    }
    else if (($temp==(i64)68)) {
                {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)74)) {
            opc = (i64)76;
        }
        else if (($temp==(i64)75)) {
            opc = (i64)77;
        }
        };
        qq_lex$lex();
        p = qq_lib$createunit1(opc,p);
    }
    else {
        goto L451 ;
    }
    }goto L450 ;
L451 :;
    ;
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readterm(void) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 opc;
        i64 pos;
        i64 length;
        struct qq_parse$readterm$dummy ustr;
    pos = (i64)qq_decls$lx.pos;
    switch ((i64)qq_decls$lx.symbol) {
    case 79:;
        {
            p = (struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)qq_decls$lx.symptr);
            (*p).pos = (i64)qq_decls$lx.pos;
            qq_lex$lex();
        }
        break;
    case 73:;
        {
            p = qq_lib$createintunit(qq_decls$lx.value);
            qq_lex$lex();
        }
        break;
    case 75:;
        {
            p = qq_lib$createrealunit(qq_decls$lx.xvalue);
            qq_lex$lex();
        }
        break;
    case 77:;
        {
            p = qq_lib$createstringunit(qq_decls$lx.svalue,(i64)-1);
            qq_lex$lex();
        }
        break;
    case 74:;
        {
            p = qq_lib$createstringunit(qq_decls$lx.svalue,(i64)-1);
            (*p).tag = (i64)71;
            qq_lex$lex();
        }
        break;
    case 76:;
        {
            length = strlen(qq_decls$lx.svalue);
            ustr.sa = (i64)0;
            if ((length > (i64)8)) {
                qq_lib$serror((byte*)"char const too long");
            }
;
            memcpy(ustr.str,(void *)qq_decls$lx.svalue,(u64)length);
            p = qq_lib$createintunit(ustr.sa);
            qq_lex$lex();
        }
        break;
    case 12:;
        {
            p = qq_parse$readlbrack();
        }
        break;
    case 80:;
        {
            if (((i64)qq_decls$lx.subcode == (i64)0)) {
                qq_lex$lex();
                if ((((i64)qq_decls$lx.symbol == (i64)2) && ((i64)qq_decls$nextlx.symbol == (i64)122))) {
                    qq_lex$lex();
                    qq_lex$lex();
                    p = qq_lib$createunit0((i64)37);
                    (*p).mode = (i64)0;
                }
                else {
                    p = qq_lib$createunit0((i64)59);
                }
;
            }
            else {
                p = qq_parse$readcast();
            }
;
        }
        break;
    case 27:;
        {
            p = qq_parse$checkoperator();
            if (!(!!(p))) {
                qq_lex$lex();
                p = qq_parse$readterm2();
            }
;
        }
        break;
    case 28:;
        {
            p = qq_parse$checkoperator();
            if (!(!!(p))) {
                qq_lex$lex();
                if (((i64)qq_decls$lx.symbol == (i64)8)) {
                    opc = (i64)78;
                    goto L452 ;
;
                }
;
                p = qq_parse$readterm2();
                if (((i64)(*p).tag == (i64)45)) {
                    (*p).value = -((*p).value);
                }
                else {
                    p = qq_lib$createunit1((i64)78,p);
                }
;
            }
;
        }
        break;
    case 57:;
    case 59:;
    case 58:;
    case 60:;
    case 61:;
    case 62:;
    case 63:;
    case 64:;
    case 68:;
    case 69:;
    case 65:;
    case 66:;
        {
            p = qq_parse$checkoperator();
            if (!(!!(p))) {
                opc = (i64)qq_decls$lx.subcode;
                qq_lex$lex();
                if (((i64)qq_decls$lx.symbol == (i64)8)) {
                    //dounary:
L452 :;
;
                    qq_lex$lex();
                    p = qq_lib$createunit1((i64)qq_tables$jtocodes[(opc)],qq_parse$readterm2());
                }
                else {
                    p = qq_lib$createunit1(opc,qq_parse$readterm2());
                }
;
            }
;
        }
        break;
    case 29:;
    case 30:;
    case 31:;
    case 32:;
    case 34:;
    case 35:;
    case 36:;
    case 37:;
    case 38:;
    case 39:;
    case 40:;
    case 45:;
    case 46:;
    case 47:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 49:;
    case 43:;
    case 44:;
    case 23:;
    case 67:;
    case 56:;
    case 151:;
        {
            if (!(!!((p = qq_parse$checkoperator())))) {
                qq_lib$serror((byte*)"Operator?");
            }
;
        }
        break;
    case 14:;
        {
            p = qq_parse$readset();
        }
        break;
    case 41:;
    case 42:;
        {
            if (!!((p = qq_parse$checkoperator()))) {
            }
            else {
                p = qq_parse$readpair((i64)qq_decls$lx.subcode);
            }
;
        }
        break;
    case 109:;
        {
            p = qq_parse$readsprint();
        }
        break;
    case 111:;
    case 112:;
        {
            p = qq_parse$readsread();
        }
        break;
    case 22:;
    case 18:;
        {
            opc = (i64)qq_decls$lx.subcode;
            qq_lex$lex();
            p = qq_lib$createunit1(opc,qq_parse$readterm2());
            if (((i64)(*(*p).a).tag == (i64)30)) {
                if (!!((*(*p).a).b)) {
                    qq_lib$serror((byte*)"Params not allowed");
                }
;
                (*p).a = (*(*p).a).a;
            }
;
        }
        break;
    case 139:;
        {
            p = qq_parse$readcompilervar();
            qq_lex$lex();
        }
        break;
    case 140:;
        {
            if (!!(qq_parse$intabledata)) {
                if ((qq_parse$tabledataname == 0)) {
                    qq_lib$serror((byte*)"$:No enum");
                }
;
                p = qq_lib$createstringunit(qq_parse$tabledataname,(i64)-1);
            }
            else {
                if ((qq_parse$ndollar <= (i64)0)) {
                    qq_lib$serror((byte*)"[$] No array");
                }
;
                p = qq_lib$createunit1((i64)108,qq_parse$dollarstack[(qq_parse$ndollar)-1]);
            }
;
            qq_lex$lex();
        }
        break;
    case 2:;
    case 130:;
        {
            qq_parse$lexchecksymbol((i64)79);
            p = (struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)qq_decls$lx.symptr);
            (*p).pos = (i64)qq_decls$lx.pos;
            qq_lex$lex();
        }
        break;
    case 143:;
        {
            p = qq_parse$readpair((i64)41);
        }
        break;
    case 144:;
        {
            qq_parse$lexchecksymbol((i64)12);
            qq_lex$lex();
            p = qq_parse$readexpression();
            qq_lib$skipsymbol((i64)4);
            q = qq_parse$readexpression();
            if ((((i64)qq_decls$lx.symbol == (i64)13) && ((i64)(*q).tag == (i64)183))) {
                r = (*q).b;
                q = (*q).a;
            }
            else {
                qq_lib$skipsymbol((i64)4);
                r = qq_parse$readexpression();
                qq_lib$checksymbol((i64)13);
            }
;
            qq_lex$lex();
            q = qq_lib$createunit2((i64)162,p,q);
            p = qq_lib$createunit2((i64)161,q,r);
        }
        break;
    case 105:;
        {
            p = qq_parse$readgoto();
        }
        break;
    case 82:;
        {
            p = qq_parse$readif();
        }
        break;
    case 90:;
        {
            p = qq_parse$readunless();
        }
        break;
    case 91:;
    case 92:;
    case 106:;
    case 107:;
        {
            p = qq_parse$readswitchcase();
        }
        break;
    case 95:;
        {
            p = qq_parse$readfor();
        }
        break;
    case 96:;
        {
            p = qq_parse$readto();
        }
        break;
    case 98:;
        {
            p = qq_parse$readdo();
        }
        break;
    case 99:;
        {
            p = qq_parse$readwhile();
        }
        break;
    case 100:;
        {
            p = qq_parse$readrepeat();
        }
        break;
    case 104:;
        {
            p = qq_parse$readloopcontrol();
        }
        break;
    case 102:;
        {
            p = qq_parse$readreturn();
        }
        break;
    case 103:;
        {
            p = qq_parse$readstop();
        }
        break;
    case 108:;
    case 21:;
        {
            p = qq_parse$readprint();
        }
        break;
    case 110:;
        {
            p = qq_parse$readread();
        }
        break;
    case 133:;
        {
            p = qq_parse$readtry();
        }
        break;
    case 135:;
        {
            qq_lex$lex();
            p = qq_lib$createunit1((i64)29,qq_parse$readexpression());
        }
        break;
    case 145:;
        {
            p = qq_parse$readpair((i64)33);
        }
        break;
    case 147:;
        {
            p = qq_parse$readhostparams(0,(i64)1);
        }
        break;
    case 149:;
        {
            p = qq_lib$createunit0((i64)32);
            qq_lex$lex();
        }
        break;
    case 150:;
        {
            qq_lex$lex();
            p = qq_lib$createunit1((i64)48,qq_parse$readterm2());
        }
        break;
    case 141:;
        {
            qq_lex$lex();
            p = qq_lib$createunit1((i64)38,qq_parse$readexpression());
        }
        break;
    case 16:;
        {
            p = qq_parse$readlambda();
        }
        break;
    default: {
        //error:
L453 :;
;
        msysc$m_print_startcon();
        msysc$m_print_u64(qq_tables$symbolnames[((i64)qq_decls$lx.symbol)-1],(byte*)"d");
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$serror((byte*)"readterm?");
    }
    } //SW
;
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readsunit(i64 inwhile) {
        i64 lineno;
        i64 globalflag;
        i64 staticflag;
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
    lineno = (i64)qq_decls$lx.pos;
    ulist = (ulistx = 0);
    globalflag = (i64)0;
    staticflag = (i64)0;
    L454 :;
    do {
        L457 :;
        while (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
L458 :;
        }
L459 :;
        ;
        switch ((i64)qq_decls$lx.symbol) {
        case 131:;
            {
                qq_lex$lex();
                staticflag = (i64)1;
                goto L454 ;
            }
            break;
        case 130:;
            {
                if (!!(globalflag)) {
                    qq_lib$serror((byte*)"global global?");
                }
;
                globalflag = (i64)qq_decls$lx.subcode;
                qq_lex$lex();
                goto L454 ;
            }
            break;
        case 113:;
        case 114:;
            {
                qq_parse$readprocdef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 124:;
            {
                q = qq_parse$readvardef(globalflag,staticflag);
                L460 :;
                while (!!(q)) {
                    r = (*q).nextunit;
                    (*q).nextunit = 0;
                    qq_lib$addlistunit(&ulist,&ulistx,q);
                    q = r;
L461 :;
                }
L462 :;
                ;
                globalflag = (staticflag = (i64)0);
            }
            break;
        case 128:;
            {
                if (!!(staticflag)) {
                    qq_lib$serror((byte*)"static?");
                }
;
                qq_parse$readconstdef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 122:;
            {
                qq_parse$readtypedef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 116:;
        case 117:;
            {
                qq_parse$readrecorddef(globalflag,0);
                globalflag = (i64)0;
            }
            break;
        case 142:;
            {
                qq_parse$readtabledef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 121:;
            {
                qq_parse$readimportdll();
            }
            break;
        case 126:;
            {
                qq_parse$readmacrodef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 71:;
            {
                goto L456 ;
            }
            break;
        case 13:;
        case 83:;
        case 84:;
        case 85:;
        case 101:;
        case 94:;
        case 10:;
        case 86:;
        case 87:;
        case 134:;
        case 89:;
        case 17:;
            {
                goto L456 ;
            }
            break;
        case 79:;
            {
                                {i64 $temp = (i64)qq_decls$nextlx.symbol;
if (($temp==(i64)6)) {
                    p = qq_lib$createunit1((i64)1,(struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)17,(i64)0)));
                    qq_lex$lex();
                    qq_decls$lx.symbol = (i64)5;
                    qq_lib$addlistunit(&ulist,&ulistx,p);
                }
                else {
                    goto L463 ;
;
                }
                };
            }
            break;
        case 98:;
            {
                if (!!(inwhile)) {
                    goto L456 ;
                }
;
                goto L463 ;
;
            }
            break;
        case 119:;
        case 120:;
            {
                L464 :;
                do {
                    qq_lex$lex();
L465 :;
                }
                while (!((i64)qq_decls$lx.symbol == (i64)5));
L466 :;
                ;
            }
            break;
        case 5:;
            {
            }
            break;
        case 14:;
            {
                goto L463 ;
;
            }
            break;
        default: {
            //doexec:
L463 :;
;
            p = qq_parse$readexpression();
            if ((((i64)(*p).tag == (i64)43) && ((i64)qq_decls$lx.symbol == (i64)79))) {
                qq_lib$serror((byte*)"Possibly var/let needed");
            }
;
            qq_lib$addlistunit(&ulist,&ulistx,p);
            if (((i64)qq_decls$lx.symbol == (i64)98)) {
                goto L456 ;
            }
;
        }
        } //SW
;
L455 :;
    }
    while (!((i64)qq_decls$lx.symbol != (i64)5));
L456 :;
    ;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)13) || ($temp==(i64)83) || ($temp==(i64)84) || ($temp==(i64)85) || ($temp==(i64)101) || ($temp==(i64)94) || ($temp==(i64)98) || ($temp==(i64)10) || ($temp==(i64)86) || ($temp==(i64)87) || ($temp==(i64)134) || ($temp==(i64)89) || ($temp==(i64)17) || ($temp==(i64)4) || ($temp==(i64)19) || ($temp==(i64)71)) {
    }
    else {
        qq_lib$serror((byte*)"Readsunit: \";\" expected, or bad unit starter");
    }
    };
    if (((ulist == 0) || !!((*ulist).nextunit))) {
        return qq_lib$createunit1((i64)7,ulist);
    }
    else {
        return ulist;
    }
;
}

static void qq_parse$checkequals(void) {
    if (((i64)qq_decls$lx.symbol != (i64)50)) {
        qq_lib$serror((byte*)"\"=\" expected");
    }
;
}

static struct qq_decls$unitrec *qq_parse$readindex(struct qq_decls$unitrec *p,i64 dot) {
        struct qq_decls$unitrec *  q;
    qq_lex$lex();
    L467 :;
    while (1) {
        if ((qq_parse$ndollar >= (i64)10)) {
            qq_lib$serror((byte*)"Too many nested a[$]");
        }
;
        qq_parse$dollarstack[(++(qq_parse$ndollar))-1] = p;
        q = qq_parse$readexpression();
        --(qq_parse$ndollar);
        p = qq_lib$createunit2((!!(dot) ? (i64)51 : (i64)50),p,q);
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L468 ;
        }
;
        qq_lex$lex();
    }
L468 :;
    ;
    qq_lib$skipsymbol((i64)15);
    return p;
}

static struct qq_decls$unitrec *qq_parse$readdotsuffix(struct qq_decls$unitrec *p) {
    L469 :;
    while (((i64)qq_decls$lx.symbol == (i64)2)) {
        qq_lex$lex();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)14)) {
            p = qq_parse$readindex(p,(i64)1);
        }
        else if (($temp==(i64)79)) {
            p = qq_lib$createunit2((i64)49,p,(struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)qq_decls$lx.symptr));
            qq_lex$lex();
        }
        else if (($temp==(i64)67)) {
            //doprop:
L472 :;
;
            p = qq_lib$createunit1((i64)qq_decls$lx.subcode,p);
            qq_lex$lex();
        }
        else if (($temp==(i64)122)) {
            if (((i64)(*p).tag != (i64)37)) {
                p = qq_lib$createunit1((i64)113,p);
            }
;
            qq_lex$lex();
        }
        else if (($temp==(i64)42)) {
            qq_decls$lx.subcode = (i64)120;
            goto L472 ;
;
        }
        else if (($temp==(i64)41)) {
            qq_decls$lx.subcode = (i64)119;
            qq_decls$lx.symbol = (i64)67;
            goto L472 ;
;
        }
        else if (($temp==(i64)140)) {
            if (!(((i64)(*p).tag == (i64)43 || (i64)(*p).tag == (i64)49))) {
                qq_lib$serror((byte*)"...name.$ needed");
            }
;
            p = qq_lib$createunit1((i64)44,p);
            qq_lex$lex();
        }
        else {
            qq_lib$serror((byte*)"Unknown dot suffix");
        }
        };
L470 :;
    }
L471 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readslist(i64 *nparams,i64 ftrailing) {
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        i64 donulls;
    ulist = (ulistx = 0);
    (*nparams) = (i64)0;
    qq_lib$skipsemi();
    if (((i64)qq_decls$lx.symbol == (i64)13)) {
        return ulist;
    }
;
    qq_parse$pushlisttype((i64)331808391504);
    donulls = (i64)1;
    L473 :;
    while (1) {
        qq_lib$skipsemi();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)4)) {
            qq_lib$serror((byte*)"null comma expr not allowed");
        }
        else if (($temp==(i64)13)) {
            goto L474 ;
        }
        else {
            qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readexpression());
            ++((*nparams));
            if (((i64)qq_decls$lx.symbol == (i64)4)) {
                qq_lex$lex();
                if (((i64)qq_decls$lx.symbol == (i64)13)) {
                    if ((((*nparams) != (i64)1) || !(!!(ftrailing)))) {
                        qq_lib$serror((byte*)"Trailing comma");
                    }
;
                    goto L474 ;
                }
;
            }
            else {
                qq_lib$skipsemi();
                if (((i64)qq_decls$lx.symbol == (i64)13)) {
                    goto L474 ;
                }
;
                qq_lib$serror((byte*)"SLIST?");
            }
;
        }
        };
    }
L474 :;
    ;
    qq_parse$poplisttype();
    return ulist;
}

static struct qq_decls$unitrec *qq_parse$readcondsuffix(struct qq_decls$unitrec *p) {
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)94)) {
        qq_lex$lex();
        return qq_lib$createunit2((i64)8,qq_parse$readexpression(),qq_lib$createunit1((i64)7,p));
    }
    else if (($temp==(i64)90)) {
        qq_lex$lex();
        return qq_lib$createunit2((i64)8,qq_lib$createunit1((i64)80,qq_parse$readexpression()),qq_lib$createunit1((i64)7,p));
    }
    else {
        return p;
    }
    };
}

static struct qq_decls$unitrec *qq_parse$readkeyindex(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
    qq_lex$lex();
    q = qq_parse$readexpression();
    if (((i64)qq_decls$lx.symbol == (i64)4)) {
        qq_lex$lex();
        (*q).nextunit = qq_parse$readexpression();
    }
;
    p = qq_lib$createunit2((i64)52,p,q);
    qq_lib$skipsymbol((i64)17);
    return p;
}

static struct qq_decls$unitrec *qq_parse$readlbrack(void) {
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 length;
        i64 lower;
        i64 lowerseen;
        i64 elemtype;
        i64 opc;
    qq_lex$lex();
    ulist = (ulistx = 0);
    length = (i64)0;
    lower = (i64)1;
    lowerseen = (i64)0;
    elemtype = (i64)0;
    if ((((i64)qq_decls$lx.symbol == (i64)80) && ((i64)qq_decls$nextlx.symbol == (i64)6))) {
        elemtype = (i64)qq_decls$lx.subcode;
        qq_lex$lex();
        qq_lex$lex();
    }
;
    if ((((i64)qq_decls$lx.symbol == (i64)73) && ((i64)qq_decls$nextlx.symbol == (i64)6))) {
        lower = qq_decls$lx.value;
        lowerseen = (i64)1;
        qq_lex$lex();
        qq_lex$lex();
    }
;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)13)) {
        qq_lex$lex();
        p = qq_lib$createunit0((i64)185);
        (*p).length = (i64)0;
        (*p).lower = lower;
        (*p).elemtype = elemtype;
        return p;
    }
    else {
        if ((((!!((i64)qq_tables$binopset[((i64)qq_decls$lx.symbol)]) || !!((i64)qq_tables$unaryopset[((i64)qq_decls$lx.symbol)])) || ((i64)qq_decls$lx.symbol == (i64)67)) && ((i64)qq_decls$nextlx.symbol == (i64)13))) {
            opc = (i64)qq_tables$jpclcodes[((i64)qq_decls$lx.subcode)];
            if (((i64)qq_decls$lx.symbol == (i64)22)) {
                opc = (i64)180;
            }
;
            //doopc:
L475 :;
;
            if ((opc == (i64)0)) {
                qq_lib$pcerror((byte*)"Bad op");
            }
;
            p = qq_lib$createunit0((i64)6);
            (*p).pclopcode = opc;
            qq_lex$lex();
            qq_lib$skipsymbol((i64)13);
            return p;
        }
        else {
                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)151)) {
                                {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)45)) {
                    opc = (i64)95;
                }
                else if (($temp==(i64)23899)) {
                    opc = (i64)200;
                }
                else {
                    opc = (i64)0;
                }
                };
                goto L475 ;
;
            }
            else if (($temp==(i64)45)) {
                opc = (i64)168;
                goto L475 ;
;
            }
            else if (($temp==(i64)46)) {
                opc = (i64)169;
                goto L475 ;
;
            }
            else if (($temp==(i64)47)) {
                opc = (i64)170;
                goto L475 ;
;
            }
            else if (($temp==(i64)23)) {
                opc = (i64)179;
                goto L475 ;
;
            }
            else {
                p = qq_parse$readexpression();
            }
            };
        }
;
    }
    };
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)13)) {
        qq_lex$lex();
        if (!!(lowerseen)) {
            p = qq_lib$createunit2((i64)5,qq_lib$createintunit(lower),p);
        }
;
        return p;
    }
    else if (($temp==(i64)4)) {
        length = (i64)1;
        if (((i64)qq_decls$nextlx.symbol == (i64)13)) {
            qq_lex$lex();
            qq_lex$lex();
            p = qq_lib$createunit1((i64)185,p);
            (*p).length = length;
            (*p).lower = lower;
            (*p).elemtype = elemtype;
            return p;
        }
;
        ulist = (ulistx = p);
        L476 :;
        do {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)13)) {
                goto L478 ;
            }
;
            if (((i64)qq_decls$lx.symbol == (i64)4)) {
                qq_lib$serror((byte*)",, null expr not allowed");
            }
;
            qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readexpression());
            ++(length);
            qq_lib$skipsemi();
L477 :;
        }
        while (!((i64)qq_decls$lx.symbol != (i64)4));
L478 :;
        ;
        qq_lib$skipsymbol((i64)13);
        p = qq_lib$createunit1((i64)185,ulist);
        (*p).length = length;
        (*p).lower = lower;
        (*p).elemtype = elemtype;
        return p;
    }
    else if (($temp==(i64)19)) {
        qq_lex$lex();
        q = qq_parse$readexpression();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)19)) {
            qq_lex$lex();
            r = qq_parse$readsunit((i64)0);
            qq_lib$skipsymbol((i64)13);
            (*q).nextunit = r;
            return qq_lib$createunit2((i64)8,p,q);
        }
        else if (($temp==(i64)13)) {
            qq_lex$lex();
            return qq_lib$createunit2((i64)8,p,q);
        }
        };
        qq_lib$addlistunit(&ulist,&ulistx,q);
        qq_lib$checksymbol((i64)4);
        if (((i64)qq_decls$nextlx.symbol != (i64)19)) {
            L479 :;
            do {
                qq_lex$lex();
                qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readexpression());
L480 :;
            }
            while (!((i64)qq_decls$lx.symbol != (i64)4));
L481 :;
            ;
            qq_lib$checksymbol((i64)19);
        }
        else {
            qq_lex$lex();
        }
;
        qq_lex$lex();
        r = qq_parse$readexpression();
        qq_lib$skipsymbol((i64)13);
        (*p).nextunit = r;
        return qq_lib$createunit2((i64)9,p,ulist);
    }
    else if (($temp==(i64)5)) {
        ulist = (ulistx = p);
        L482 :;
        do {
            qq_lib$skipsemi();
            if (((i64)qq_decls$lx.symbol == (i64)13)) {
                goto L484 ;
            }
;
            qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readexpression());
L483 :;
        }
        while (!((i64)qq_decls$lx.symbol != (i64)5));
L484 :;
        ;
        qq_lib$skipsymbol((i64)13);
        return qq_parse$makeblock(ulist);
    }
    else {
        qq_lib$serror((byte*)"(x ...");
    }
    };
    return (struct qq_decls$unitrec *)0;
}

static struct qq_decls$unitrec *qq_parse$readif(void) {
        i64 line;
        i64 kwd;
        struct qq_decls$unitrec *  pthen;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  p;
    line = (i64)qq_decls$lx.pos;
    kwd = (i64)qq_decls$lx.symbol;
    qq_lex$lex();
    pcond = qq_parse$readsunit((i64)0);
    qq_lib$skipsemi();
    qq_lib$skipsymbol((i64)83);
    pthen = qq_parse$readsunit((i64)0);
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)84)) {
        qq_decls$lx.symbol = (i64)82;
        pelse = qq_parse$readif();
    }
    else if (($temp==(i64)85)) {
        qq_lex$lex();
        pelse = qq_parse$readsunit((i64)0);
        qq_parse$checkend(kwd,(i64)0,(i64)0);
    }
    else if (($temp==(i64)86) || ($temp==(i64)87)) {
        qq_decls$lx.symbol = kwd;
        pelse = qq_parse$makeblock(qq_parse$readswitchcase());
    }
    else {
        pelse = 0;
        qq_parse$checkend(kwd,(i64)0,(i64)0);
    }
    };
    (*pthen).nextunit = pelse;
    p = qq_lib$createunit2((i64)8,pcond,pthen);
    (*p).pos = line;
    return p;
}

static void qq_parse$checkend(i64 endkwd1,i64 endkwd2,i64 startline) {
        u8 str[256];
    qq_lib$skipsemi();
    if (((i64)qq_decls$lx.symbol != (i64)89)) {
        qq_lib$serror((byte*)"'End' expected");
    }
;
    if (!!((i64)qq_decls$lx.subcode)) {
        if (((i64)qq_decls$lx.subcode == endkwd1 || (i64)qq_decls$lx.subcode == endkwd2)) {
            qq_lex$lex();
            return;
        }
        else {
            //error:
L485 :;
;
            strcpy(str,(byte*)"Mismatched end ");
            if (!!(startline)) {
                msysc$m_print_startstr((str + strlen((u8 *)str)));
                msysc$m_print_setfmt((byte*)" (from line #)");
                msysc$m_print_i64(startline,NULL);
                msysc$m_print_end();
                ;
            }
;
            qq_lib$serror((u8 *)str);
        }
;
    }
;
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == endkwd1 || (i64)qq_decls$lx.symbol == endkwd2)) {
        qq_lex$lex();
    }
    else if (((i64)qq_decls$lx.symbol != (i64)5)) {
        goto L485 ;
;
    }
;
}

static struct qq_decls$unitrec *qq_parse$readunless(void) {
        i64 line;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  pthen;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  p;
    line = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    pcond = qq_parse$readsunit((i64)0);
    qq_lib$skipsymbol((i64)83);
    pthen = qq_parse$readsunit((i64)0);
    if (((i64)qq_decls$lx.symbol == (i64)85)) {
        qq_lex$lex();
        pelse = qq_parse$readsunit((i64)0);
    }
    else {
        pelse = 0;
    }
;
    qq_parse$checkend((i64)90,(i64)0,(i64)0);
    (*pthen).nextunit = pelse;
    p = qq_lib$createunit2((i64)8,qq_lib$createunit1((i64)80,pcond),pthen);
    (*p).pos = line;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readwhile(void) {
        i64 pos;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  pbody;
        struct qq_decls$unitrec *  p;
    pos = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    pcond = qq_parse$readsunit((i64)1);
    if (((i64)qq_decls$lx.symbol == (i64)4)) {
        qq_lex$lex();
        (*pcond).nextunit = qq_parse$readsunit((i64)1);
    }
;
    qq_lib$skipsymbol((i64)98);
    pbody = qq_parse$readsunit((i64)0);
    qq_parse$checkend((i64)99,(i64)98,(i64)0);
    p = qq_lib$createunit2((i64)25,pcond,pbody);
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readrepeat(void) {
        i64 pos;
        struct qq_decls$unitrec *  pbody;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  p;
    pos = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    pbody = qq_parse$readsunit((i64)0);
    qq_lib$skipsymbol((i64)101);
    pcond = qq_parse$readexpression();
    p = qq_lib$createunit2((i64)26,pbody,pcond);
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readfor(void) {
        i64 line;
        i64 opc;
        i64 down;
        i64 isforeach;
        struct qq_decls$unitrec *  pstep;
        struct qq_decls$unitrec *  pvar;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  pfrom;
        struct qq_decls$unitrec *  pto;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  pbody;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  plist;
        struct qq_decls$unitrec *  pvar2;
    line = (i64)qq_decls$lx.pos;
    isforeach = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    pvar = qq_parse$readterm2();
    if (((i64)(*pvar).tag != (i64)43)) {
        qq_lib$serror((byte*)"For: name expected");
    }
    else {
        (*(*pvar).def).forindex = (i64)1;
    }
;
    opc = (i64)16;
    pstep = 0;
    pcond = 0;
    pvar2 = 0;
    if (((i64)qq_decls$lx.symbol == (i64)4)) {
        qq_lex$lex();
        pvar2 = qq_parse$readterm2();
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)45 || (i64)qq_decls$lx.symbol == (i64)48)) {
        down = (i64)((i64)qq_decls$lx.symbol == (i64)48);
        qq_lex$lex();
        plist = qq_parse$readexpression();
                {i64 $temp = (i64)(*plist).tag;
if (($temp==(i64)183)) {
            opc = (i64)16;
            pfrom = (*plist).a;
            pto = (*plist).b;
        }
        else if (($temp==(i64)109)) {
            (*plist).tag = (i64)110;
            opc = (i64)17;
        }
        else {
            opc = (i64)20;
        }
        };
    }
    else {
        if (((i64)qq_decls$lx.symbol == (i64)8)) {
            qq_lex$lex();
            pfrom = qq_parse$readexpression();
        }
        else {
            pfrom = qq_lib$createintunit((i64)1);
        }
;
        qq_lib$checksymbol((i64)96);
        down = (i64)((i64)qq_decls$lx.subcode == (i64)1);
        opc = (i64)16;
        qq_lex$lex();
        pto = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)97)) {
            qq_lex$lex();
            pstep = qq_parse$readexpression();
            if (((i64)(*pstep).tag != (i64)45)) {
                qq_lib$serror((byte*)"BY needs int constant");
            }
;
            if (((*pstep).value < (i64)0)) {
                qq_lib$serror((byte*)"Step must be positive");
            }
            else if (((*pstep).value == (i64)0)) {
                qq_lib$serror((byte*)"Zero step");
            }
;
            (*pstep).value = m$llabs((*pstep).value);
            if (((*pstep).value == (i64)1)) {
                pstep = 0;
            }
;
        }
;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)94)) {
        qq_lex$lex();
        pcond = qq_parse$readexpression();
    }
;
    qq_lib$skipsymbol((i64)98);
    pbody = qq_parse$readsunit((i64)0);
    if ((pcond != 0)) {
        pbody = qq_parse$makeblock(qq_lib$createunit2((i64)8,pcond,pbody));
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)85)) {
        qq_lex$lex();
        pelse = qq_parse$readsunit((i64)0);
        (*pbody).nextunit = pelse;
    }
    else {
        pelse = 0;
    }
;
    qq_parse$checkend((i64)95,(i64)98,(i64)0);
    if ((opc==(i64)20)) {
        (*pvar).nextunit = plist;
        (*plist).nextunit = pvar2;
        p = qq_lib$createunit2((!!(down) ? (i64)21 : (i64)20),pvar,pbody);
    }
    else if ((opc==(i64)17)) {
        (*pvar).nextunit = plist;
        p = qq_lib$createunit2((!!(down) ? (i64)19 : (i64)17),pvar,pbody);
    }
    else {
        (*pvar).nextunit = pfrom;
        (*pfrom).nextunit = pto;
        (*pto).nextunit = pstep;
        p = qq_lib$createunit2((!!(down) ? (i64)18 : (i64)16),pvar,pbody);
    }
;
    if (!!(isforeach)) {
        if (((i64)(*p).tag == (i64)20)) {
            (*p).tag = (i64)22;
        }
        else {
            qq_lib$serror((byte*)"Foreach?");
        }
;
    }
;
    (*p).pos = line;
    if ((!!(pvar2) && !((opc == (i64)20 || opc == (i64)21)))) {
        qq_lib$serror((byte*)"for i,j not allowed");
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readdo(void) {
        struct qq_decls$unitrec *  p;
        i64 line;
    line = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    p = qq_parse$readsunit((i64)0);
    qq_parse$checkend((i64)98,(i64)0,(i64)0);
    p = qq_lib$createunit1((i64)23,p);
    (*p).pos = line;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readto(void) {
        i64 line;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  pcount;
        struct qq_decls$unitrec *  pbody;
    line = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    pcount = qq_parse$readexpression();
    qq_lib$skipsymbol((i64)98);
    pbody = qq_parse$readsunit((i64)0);
    qq_parse$checkend((i64)96,(i64)98,(i64)0);
    (*pcount).nextunit = qq_lib$createavname();
    p = qq_lib$createunit2((i64)24,pcount,pbody);
    (*p).pos = line;
    return p;
}

static struct qq_decls$unitrec *qq_parse$makeblock(struct qq_decls$unitrec *p) {
    return qq_lib$createunit1((i64)7,p);
}

static struct qq_decls$unitrec *qq_parse$readvardef(i64 isglobal,i64 isstatic) {
        i64 nvars;
        i64 varid;
        i64 opc;
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
    qq_lex$lex();
    if (((i64)(*qq_decls$stcurrproc).nameid == (i64)5 || (i64)(*qq_decls$stcurrproc).nameid == (i64)6)) {
        varid = (!!(isstatic) ? (i64)13 : (i64)14);
    }
    else {
        varid = (i64)13;
    }
;
    nvars = (i64)0;
    ulist = (ulistx = 0);
    L486 :;
    while (((i64)qq_decls$lx.symbol == (i64)79)) {
        ++(nvars);
        d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,varid,isglobal);
        qq_lex$lex();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)8) || ($temp==(i64)9)) {
            opc = (i64)qq_decls$lx.subcode;
            if ((varid == (i64)13)) {
                if (((i64)(*qq_decls$stcurrproc).nameid == (i64)5 || (i64)(*qq_decls$stcurrproc).nameid == (i64)6)) {
                    qq_lib$serror((byte*)"Need '=' for static in proc");
                }
;
            }
;
            (*d).flags = msysc$m_setdotslice((*d).flags,(i64)11,(i64)12,(u64)(((i64)qq_decls$lx.symbol == (i64)8) ? (i64)2 : (i64)3));
            qq_lex$lex();
            (*d).code = qq_parse$readexpression();
            if ((varid == (i64)14)) {
                p = qq_lib$createunit2(opc,(struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)d),(*d).code);
                qq_lib$addlistunit(&ulist,&ulistx,p);
            }
;
        }
        else if (($temp==(i64)50)) {
            if ((varid != (i64)13)) {
                qq_lib$serror((byte*)"Need ':=' for non-static");
            }
;
            qq_lex$lex();
            (*d).flags = msysc$m_setdotslice((*d).flags,(i64)11,(i64)12,(u64)1u);
            (*d).code = qq_parse$readexpression();
        }
        };
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L488 ;
        }
;
        qq_lex$lex();
L487 :;
    }
L488 :;
    ;
    if ((nvars == (i64)0)) {
        qq_lib$serror((byte*)"No vars declared");
    }
;
    return ulist;
}

static void qq_parse$readconstdef(i64 isglobal) {
        i64 nvars;
        struct qq_decls$strec *  d;
    qq_lex$lex();
    nvars = (i64)0;
    L489 :;
    while (((i64)qq_decls$lx.symbol == (i64)79)) {
        ++(nvars);
        d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)18,isglobal);
        qq_parse$lexchecksymbol((i64)50);
        qq_lex$lex();
        (*d).code = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L491 ;
        }
;
        qq_lex$lex();
L490 :;
    }
L491 :;
    ;
    if ((nvars == (i64)0)) {
        qq_lib$serror((byte*)"No consts declared");
    }
;
}

static struct qq_decls$unitrec *qq_parse$readreturn(void) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
    qq_lex$lex();
    q = 0;
    if (!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)])) {
        q = qq_parse$readexpression();
    }
;
    p = qq_lib$createunit1((i64)36,q);
    return qq_parse$readcondsuffix(p);
}

static struct qq_decls$unitrec *qq_parse$readprint(void) {
        i64 opc;
        i64 isfprint;
        i64 fshowname;
        struct qq_decls$unitrec *  pformat;
        struct qq_decls$unitrec *  pdev;
        struct qq_decls$unitrec *  printlist;
        struct qq_decls$unitrec *  printlistx;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct mlib$strbuffer *  expr;
        u8 *  s;
    qq_parse$pushlisttype((i64)362090680912);
    if (((i64)qq_decls$lx.symbol == (i64)21)) {
        opc = (i64)61;
    }
    else {
        opc = (i64)qq_decls$lx.subcode;
    }
;
    if ((opc==(i64)62) || (opc==(i64)63)) {
        isfprint = (i64)1;
    }
    else {
        isfprint = (i64)0;
    }
;
    qq_lex$lex();
    printlist = (printlistx = 0);
    pformat = (pdev = 0);
    if (((i64)qq_decls$lx.symbol == (i64)20)) {
        qq_lex$lex();
        pdev = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
        }
        else {
            goto L492 ;
;
        }
;
    }
;
    if (!!(isfprint)) {
        pformat = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
        }
        else {
            goto L492 ;
;
        }
;
    }
;
    if (!(!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)]))) {
        goto L492 ;
;
    }
;
    L493 :;
    while (1) {
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)4)) {
            qq_lib$addlistunit(&printlist,&printlistx,qq_lib$createunit0((i64)66));
        }
        else if (($temp==(i64)140)) {
            qq_lib$addlistunit(&printlist,&printlistx,qq_lib$createunit0((i64)67));
            qq_lex$lex();
        }
        else {
            fshowname = (i64)0;
            if (((i64)qq_decls$lx.symbol == (i64)50)) {
                fshowname = (i64)1;
                qq_lex$lex();
            }
;
            p = qq_parse$readexpression();
            if (((i64)qq_decls$lx.symbol == (i64)6)) {
                qq_lex$lex();
                p = qq_lib$createunit2((i64)68,p,qq_parse$readexpression());
            }
;
            if (!!(fshowname)) {
                expr = (struct mlib$strbuffer *)qq_lib$strexpr(p);
                mlib$strbuffer_add((struct mlib$strbuffer *)expr,(byte*)"=",(i64)-1);
                s = (*expr).strptr;
                mlib$iconvucn((*expr).strptr,(i64)(*expr).length);
                qq_lib$addlistunit(&printlist,&printlistx,(q = qq_lib$createstringunit(s,(i64)(*expr).length)));
            }
;
            qq_lib$addlistunit(&printlist,&printlistx,p);
        }
        };
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L494 ;
        }
;
        qq_lex$lex();
    }
L494 :;
    ;
    //finish:
L492 :;
;
    if (((opc == (i64)60) && (printlist == 0))) {
        qq_lib$serror((byte*)"No print items");
    }
;
    if ((((opc == (i64)62) && (printlist == 0)) && (pformat == 0))) {
        qq_lib$serror((byte*)"No print items");
    }
;
    qq_parse$poplisttype();
    if (!!(isfprint)) {
        if ((pformat == 0)) {
            qq_lib$serror((byte*)"No fmt str");
        }
;
        if ((pformat == 0)) {
            pformat = qq_parse$makeblock(pformat);
        }
;
        (*pformat).nextunit = printlist;
        return qq_lib$createunit2(opc,pdev,pformat);
        return pformat;
    }
    else {
        return qq_lib$createunit2(opc,pdev,printlist);
    }
;
}

static struct qq_decls$unitrec *qq_parse$readread(void) {
        i64 opc;
        struct qq_decls$unitrec *  pformat;
        struct qq_decls$unitrec *  pdev;
        struct qq_decls$unitrec *  readlist;
        struct qq_decls$unitrec *  readlistx;
        struct qq_decls$unitrec *  p;
    qq_parse$pushlisttype((i64)362090680912);
    opc = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    readlist = (readlistx = 0);
    pformat = (pdev = 0);
    if (((i64)qq_decls$lx.symbol == (i64)20)) {
        if ((opc == (i64)69)) {
            qq_lib$serror((byte*)"@ on read");
        }
;
        qq_lex$lex();
        pdev = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
        }
        else {
            goto L495 ;
;
        }
;
    }
;
    if (!(!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)]))) {
        goto L495 ;
;
    }
;
    L496 :;
    while (1) {
        p = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)6)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)68,p,qq_parse$readexpression());
        }
;
        qq_lib$addlistunit(&readlist,&readlistx,p);
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L497 ;
        }
;
        qq_lex$lex();
    }
L497 :;
    ;
    //finish:
L495 :;
;
    if (((opc == (i64)69) && (readlist == 0))) {
        qq_lib$serror((byte*)"No read items");
    }
;
    qq_parse$poplisttype();
    return qq_lib$createunit2(opc,pdev,readlist);
}

static struct qq_decls$unitrec *qq_parse$readloopcontrol(void) {
        i64 opc;
        struct qq_decls$unitrec *  p;
    opc = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    if ((((i64)qq_decls$lx.symbol == (i64)79) && !!(mlib$eqstring((*qq_decls$lx.symptr).name,(byte*)"all")))) {
        qq_lex$lex();
        p = qq_lib$createunit1(opc,qq_lib$createintunit((i64)0));
    }
    else if (!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)])) {
        p = qq_lib$createunit1(opc,qq_parse$readintunit());
    }
    else {
        p = qq_lib$createunit1(opc,qq_lib$createintunit((i64)1));
    }
;
    return qq_parse$readcondsuffix(p);
}

static struct qq_decls$unitrec *qq_parse$readintunit(void) {
        struct qq_decls$unitrec *  p;
    p = qq_parse$readexpression();
    if (((i64)(*p).tag != (i64)45)) {
        qq_lib$serror((byte*)"int expr needed");
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readswitchcase(void) {
        i64 pos;
        i64 kwd;
        i64 opc;
        i64 rangeused;
        i64 nwhen;
        struct qq_decls$unitrec *  pexpr;
        struct qq_decls$unitrec *  pwhenlist;
        struct qq_decls$unitrec *  pwhenlistx;
        struct qq_decls$unitrec *  pwhen;
        struct qq_decls$unitrec *  pwhenx;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  pthen;
        struct qq_decls$unitrec *  pwhenthen;
    pos = (i64)qq_decls$lx.pos;
    kwd = (i64)qq_decls$lx.symbol;
    opc = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    qq_lib$skipsemi();
    if (((i64)qq_decls$lx.symbol == (i64)94)) {
        if ((kwd == (i64)106)) {
            qq_lib$serror((byte*)"switch expr missing");
        }
;
        pexpr = qq_lib$createunit0((i64)0);
    }
    else {
        pexpr = qq_parse$readsunit((i64)0);
    }
;
    pwhenlist = (pwhenlistx = 0);
    rangeused = (i64)0;
    nwhen = (i64)0;
    qq_lib$skipsemi();
    L498 :;
    while (((i64)qq_decls$lx.symbol == (i64)94)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        pwhen = (pwhenx = 0);
        L501 :;
        while (1) {
            p = qq_parse$readexpression();
            ++(nwhen);
            (*p).pos = pos;
            if (((i64)(*p).tag == (i64)183)) {
                rangeused = (i64)1;
            }
;
            qq_lib$addlistunit(&pwhen,&pwhenx,p);
            if (((i64)qq_decls$lx.symbol != (i64)4)) {
                goto L502 ;
            }
;
            qq_lex$lex();
        }
L502 :;
        ;
        if (((i64)qq_decls$lx.symbol != (i64)83)) {
            qq_lib$checksymbol((i64)10);
        }
;
        qq_lex$lex();
        pthen = qq_parse$readsunit((i64)0);
        pwhenthen = qq_lib$createunit2((i64)10,pwhen,pthen);
        (*pwhenthen).pos = pos;
        qq_lib$addlistunit(&pwhenlist,&pwhenlistx,pwhenthen);
L499 :;
    }
L500 :;
    ;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)85)) {
        qq_lex$lex();
        pelse = qq_parse$readsunit((i64)0);
        qq_parse$checkend(kwd,(i64)0,(i64)0);
    }
    else if (($temp==(i64)84)) {
        qq_decls$lx.symbol = kwd;
        pelse = qq_parse$makeblock(qq_parse$readif());
    }
    else if (($temp==(i64)86) || ($temp==(i64)87)) {
        qq_decls$lx.symbol = kwd;
        pelse = qq_parse$readswitchcase();
    }
    else {
        pelse = 0;
        qq_parse$checkend(kwd,(i64)0,(i64)0);
    }
    };
    (*pexpr).nextunit = pelse;
    p = qq_lib$createunit2(opc,pexpr,pwhenlist);
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readgoto(void) {
    qq_lex$lex();
    return qq_parse$readcondsuffix(qq_lib$createunit1((i64)34,qq_parse$readexpression()));
}

static struct qq_decls$unitrec *qq_parse$readstop(void) {
        struct qq_decls$unitrec *  p;
    qq_lex$lex();
    if (!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)])) {
        p = qq_lib$createunit1((i64)35,qq_parse$readexpression());
    }
    else {
        p = qq_lib$createunit1((i64)35,qq_lib$createintunit((i64)0));
    }
;
    return qq_parse$readcondsuffix(p);
}

static struct qq_decls$unitrec *qq_parse$readcast(void) {
        struct qq_decls$unitrec *  p;
        i64 t;
        i64 opc;
    t = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    if (((t == (i64)4) && ((i64)qq_decls$lx.symbol == (i64)12))) {
        qq_lex$lex();
        p = qq_parse$readexpression();
        if (((i64)(*p).tag == (i64)5 || (i64)(*p).tag == (i64)4)) {
            (*p).tag = (i64)184;
        }
        else if (((i64)(*p).tag == (i64)183)) {
        }
        else {
            qq_lib$serror((byte*)"need a..b or a:n");
        }
;
        qq_lib$skipsymbol((i64)13);
        return p;
    }
;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)20) || ($temp==(i64)12)) {
    }
    else {
        p = qq_lib$createunit0((i64)37);
        (*p).mode = t;
        return p;
    }
    };
    if (((i64)qq_decls$lx.symbol == (i64)20)) {
        qq_lex$lex();
        opc = (i64)40;
    }
    else {
        opc = (i64)39;
    }
;
    qq_lib$checksymbol((i64)12);
    p = qq_parse$readterm();
    p = qq_lib$createunit1(opc,p);
    qq_lib$storemode(qq_decls$stcurrproc,t,&(*p).mode);
    return p;
}

static struct qq_decls$unitrec *qq_parse$readset(void) {
        i64 length;
        i64 nkeyvalues;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
    qq_lex$lex();
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)15)) {
        qq_lex$lex();
        return qq_lib$createunit1((i64)186,0);
    }
    else if (($temp==(i64)6)) {
        qq_parse$lexchecksymbol((i64)15);
        qq_lex$lex();
        return qq_lib$createunit1((i64)187,0);
    }
    };
    qq_parse$pushlisttype((i64)1413695812);
    p = qq_parse$readexpression();
    length = (i64)1;
    nkeyvalues = (i64)0;
    if (((i64)(*p).tag == (i64)5)) {
        ++(nkeyvalues);
    }
;
    ulist = (ulistx = p);
    L503 :;
    while (((i64)qq_decls$lx.symbol == (i64)4)) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)15)) {
            goto L505 ;
        }
;
        qq_lib$addlistunit(&ulist,&ulistx,(p = qq_parse$readexpression()));
        if (((i64)(*p).tag == (i64)5)) {
            ++(nkeyvalues);
        }
;
        ++(length);
        qq_lib$skipsemi();
L504 :;
    }
L505 :;
    ;
    qq_lib$skipsymbol((i64)15);
    if (!!(nkeyvalues)) {
        if ((length > nkeyvalues)) {
            qq_lib$serror((byte*)"dict: mixed elements");
        }
;
        p = qq_lib$createunit1((i64)187,ulist);
    }
    else {
        p = qq_lib$createunit1((i64)186,ulist);
    }
;
    (*p).length = length;
    qq_parse$poplisttype();
    return p;
}

void qq_parse$readtabledef(i64 isglobal) {
        i64 i;
        i64 ncols;
        i64 nrows;
        i64 enums;
        i64 nextenumvalue;
        i64 startline;
        i64 firstvalue;
        byte commas;
        byte semis;
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
        struct qq_decls$strec *  varnames[20];
        struct qq_decls$unitrec *  plist[20];
        struct qq_decls$unitrec *  plistx[20];
        struct qq_decls$strec *  d;
    commas = (i64)0;
    semis = (i64)0;
    enums = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    firstvalue = (nextenumvalue = (i64)1);
    nrows = (i64)0;
    ncols = (i64)0;
    L506 :;
    while (((i64)qq_decls$lx.symbol == (i64)79)) {
        if ((++(ncols) > (i64)20)) {
            qq_lib$serror((byte*)"tabledata/too many columns");
        }
;
        varnames[(ncols)-1] = (struct qq_decls$strec *)qq_decls$lx.symptr;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
        }
        else {
            goto L508 ;
        }
;
L507 :;
    }
L508 :;
    ;
    qq_parse$checkequals();
    qq_lex$lex();
    qq_lib$skipsemi();
    startline = (i64)qq_decls$lx.pos;
    qq_lib$skipsemi();
    for (i=(i64)1;i<=ncols;++i) {
L509 :;
        plist[(i)-1] = (plistx[(i)-1] = 0);
L510 :;
    }
L511 :;
    ;
    ulist = (ulistx = 0);
    qq_parse$intabledata = (i64)1;
    L512 :;
    while (1) {
        qq_lib$skipsemi();
        if ((ncols > (i64)0)) {
            qq_lib$skipsymbol((i64)12);
        }
;
        if ((++(nrows) > (i64)500)) {
            qq_lib$serror((byte*)"tabledata:too many rows");
        }
;
        if (!!(enums)) {
            qq_lib$checksymbol((i64)79);
            d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)19,isglobal);
            qq_lex$lex();
                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)50)) {
                if ((nrows > (i64)1)) {
                    qq_lib$serror((byte*)"tabledata '=' not 1st");
                }
;
                qq_lex$lex();
                p = qq_parse$readexpression();
                if (((i64)(*p).tag == (i64)45)) {
                    firstvalue = (nextenumvalue = (*p).value);
                }
                else {
                    qq_lib$serror((byte*)"TABLEDATA: COMPLEX ENUM VAL");
                }
;
            }
            };
            (*d).index = (nextenumvalue)++;
            qq_parse$tabledataname = (*d).name;
            if (!!(ncols)) {
                qq_lib$skipsymbol((i64)4);
            }
;
        }
;
        for (i=(i64)1;i<=ncols;++i) {
L514 :;
            qq_lib$addlistunit(&plist[(i)-1],&plistx[(i)-1],qq_parse$readexpression());
            if ((i == ncols)) {
                qq_lib$skipsymbol((i64)13);
            }
            else {
                qq_lib$skipsymbol((i64)4);
            }
;
L515 :;
        }
L516 :;
        ;
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)4)) {
            ++(commas);
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)89)) {
                goto L513 ;
            }
;
        }
        else {
            qq_lib$skipsemi();
            if (((i64)qq_decls$lx.symbol == (i64)89)) {
                goto L513 ;
            }
;
            ++(semis);
        }
        };
    }
L513 :;
    ;
    if ((!!((i64)semis) && !!((i64)commas))) {
        qq_lib$serror((byte*)"mixed commas");
    }
;
    qq_parse$intabledata = (i64)0;
    qq_lib$skipsemi();
    qq_parse$checkend((i64)142,(i64)0,startline);
    if ((nrows == (i64)0)) {
        qq_lib$serror((byte*)"No table data");
    }
;
    for (i=(i64)1;i<=ncols;++i) {
L517 :;
        d = qq_names$addsymbol(qq_decls$stcurrproc,varnames[(i)-1],(i64)13,isglobal);
        p = ((*d).code = qq_lib$createunit1((i64)185,plist[(i)-1]));
        (*p).length = nrows;
        (*p).lower = firstvalue;
L518 :;
    }
L519 :;
    ;
}

static struct qq_decls$unitrec *qq_parse$readtry(void) {
        struct qq_decls$unitrec *  ptry;
        struct qq_decls$unitrec *  pexceptlist;
        struct qq_decls$unitrec *  pexceptlistx;
        struct qq_decls$unitrec *  px;
        struct qq_decls$unitrec *  exlist;
        struct qq_decls$unitrec *  exlistx;
    qq_lex$lex();
    ptry = qq_parse$readsunit((i64)0);
    pexceptlist = (pexceptlistx = 0);
    L520 :;
    while (((i64)qq_decls$lx.symbol == (i64)134)) {
        qq_lex$lex();
        exlist = (exlistx = 0);
        L523 :;
        while (1) {
            qq_lib$addlistunit(&exlist,&exlistx,qq_parse$readexpression());
            if (((i64)qq_decls$lx.symbol != (i64)4)) {
                goto L524 ;
            }
;
            qq_lex$lex();
        }
L524 :;
        ;
        qq_lib$skipsymbol((i64)83);
        px = qq_parse$readsunit((i64)0);
        qq_lib$addlistunit(&pexceptlist,&pexceptlistx,qq_lib$createunit2((i64)28,exlist,px));
L521 :;
    }
L522 :;
    ;
    qq_parse$checkend((i64)133,(i64)0,(i64)0);
    return qq_lib$createunit2((i64)27,ptry,pexceptlist);
}

static struct qq_decls$unitrec *qq_parse$readsprint(void) {
        i64 opc;
        i64 isfprint;
        struct qq_decls$unitrec *  pformat;
        struct qq_decls$unitrec *  pdev;
        struct qq_decls$unitrec *  printlist;
        struct qq_decls$unitrec *  printlistx;
        struct qq_decls$unitrec *  p;
    qq_parse$pushlisttype((i64)362090680912);
    opc = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)12);
    qq_lex$lex();
    if ((opc==(i64)65)) {
        isfprint = (i64)1;
    }
    else {
        isfprint = (i64)0;
    }
;
    printlist = (printlistx = 0);
    pformat = (pdev = 0);
    if (((i64)qq_decls$lx.symbol == (i64)20)) {
        qq_lex$lex();
        pdev = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
        }
        else {
            goto L525 ;
;
        }
;
    }
;
    if (!!(isfprint)) {
        pformat = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
        }
        else {
            goto L525 ;
;
        }
;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)13)) {
        goto L525 ;
;
    }
;
    L526 :;
    while (1) {
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lib$addlistunit(&printlist,&printlistx,qq_lib$createunit0((i64)66));
        }
        else {
            p = qq_parse$readexpression();
            if (((i64)qq_decls$lx.symbol == (i64)6)) {
                qq_lex$lex();
                p = qq_lib$createunit2((i64)68,p,qq_parse$readexpression());
            }
;
            qq_lib$addlistunit(&printlist,&printlistx,p);
        }
;
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L527 ;
        }
;
        qq_lex$lex();
    }
L527 :;
    ;
    qq_lib$checksymbol((i64)13);
    //finish:
L525 :;
;
    qq_lex$lex();
    if ((((opc == (i64)60) || (opc == (i64)62)) && (printlist == 0))) {
        qq_lib$serror((byte*)"No print items");
    }
;
    qq_parse$poplisttype();
    if (!!(isfprint)) {
        if ((pformat == 0)) {
            qq_lib$serror((byte*)"No fmt str");
        }
;
        (*pformat).nextunit = printlist;
        return qq_lib$createunit2(opc,pdev,pformat);
    }
    else {
        return qq_lib$createunit2(opc,pdev,printlist);
    }
;
}

static struct qq_decls$unitrec *qq_parse$readsread(void) {
        i64 opc;
        struct qq_decls$unitrec *  pformat;
        struct qq_decls$unitrec *  pdev;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  readlist;
        struct qq_decls$unitrec *  readlistx;
    qq_parse$pushlisttype((i64)362090680912);
    opc = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)12);
    qq_lex$lex();
    readlist = (readlistx = 0);
    pformat = (pdev = 0);
    if (((i64)qq_decls$lx.symbol == (i64)20)) {
        if ((opc == (i64)69)) {
            qq_lib$serror((byte*)"@ on read");
        }
;
        qq_lex$lex();
        pdev = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
        }
        else {
            goto L528 ;
;
        }
;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)13)) {
        goto L528 ;
;
    }
;
    L529 :;
    while (1) {
        p = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)6)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)68,p,qq_parse$readexpression());
        }
;
        qq_lib$addlistunit(&readlist,&readlistx,p);
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L530 ;
        }
;
        qq_lex$lex();
    }
L530 :;
    ;
    qq_lib$checksymbol((i64)13);
    //finish:
L528 :;
;
    qq_lex$lex();
    if (((opc == (i64)69) && (readlist == 0))) {
        qq_lib$serror((byte*)"No read items");
    }
;
    qq_parse$poplisttype();
    return qq_lib$createunit2(opc,pdev,readlist);
}

static void qq_parse$readimportdll(void) {
        u8 str[256];
        struct qq_decls$strec *  stproc;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  stname;
        i64 startpos;
        i64 isfunc;
        i64 isnew;
        i64 libtype;
        i64 i;
    libtype = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)79);
    stname = (struct qq_decls$strec *)qq_decls$lx.symptr;
    qq_parse$lexchecksymbol((i64)50);
    qq_lex$lex();
    isnew = (i64)1;
    d = (*stname).nextdupl;
    for (i=(i64)1;i<=qq_decls$nlibfiles;++i) {
L531 :;
        if (!!(mlib$eqstring((*qq_decls$libtable[(i)-1]).name,(*stname).name))) {
            stname = qq_decls$libtable[(i)-1];
            isnew = (i64)0;
            goto L533 ;
        }
;
L532 :;
    }
L533 :;
    ;
    if (!!(isnew)) {
        stname = qq_names$addsymbol(0,stname,(i64)4,(i64)0);
        if ((qq_decls$nlibfiles >= (i64)50)) {
            qq_lib$serror((byte*)"Too many DLL libs");
        }
;
        qq_decls$libtable[(++(qq_decls$nlibfiles))-1] = stname;
        qq_decls$libtypes[(qq_decls$nlibfiles)-1] = libtype;
        (*stname).index = qq_decls$nlibfiles;
    }
;
    qq_parse$currdllindex = (i64)(*stname).index;
    startpos = (i64)qq_decls$lx.pos;
    L534 :;
    while (1) {
        qq_lib$skipsemi();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)129)) {
            qq_lex$lex();
        }
        else if (($temp==(i64)113) || ($temp==(i64)114)) {
            isfunc = (i64)((i64)qq_decls$lx.symbol == (i64)114);
            qq_lex$lex();
                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)79)) {
                stproc = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)7,(i64)1);
            }
            else if (($temp==(i64)77)) {
                strcpy(str,qq_decls$lx.svalue);
                mlib$convlcstring(str);
                stproc = qq_names$addsymbol(qq_decls$stcurrproc,qq_names$addglobalname(str),(i64)7,(i64)1);
                (*stproc).truename = mlib$pcm_copyheapstring(qq_decls$lx.svalue);
            }
            else {
                qq_lib$serror((byte*)"fn name expected");
            }
            };
            (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)4,(u64)isfunc);
            (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)2,(u64)1u);
            if ((qq_decls$ndllprocs >= (i64)2000)) {
                qq_lib$serror((byte*)"Too many DLL procs");
            }
;
            qq_decls$dllproctable[(++(qq_decls$ndllprocs))-1] = stproc;
            qq_decls$dllproclibindex[(qq_decls$ndllprocs)-1] = qq_parse$currdllindex;
            (*stproc).index = qq_decls$ndllprocs;
            qq_lex$lex();
            if ((((i64)qq_decls$lx.symbol == (i64)79) && !!(mlib$eqstring((*qq_decls$lx.symptr).name,(byte*)"as")))) {
                qq_parse$lexchecksymbol((i64)79);
                d = qq_names$addsymbol((*stproc).owner,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)20,(i64)1);
                (*d).alias = stproc;
                qq_lex$lex();
            }
;
            qq_parse$readffiparams(stproc);
        }
        else if (($temp==(i64)122)) {
            qq_parse$readtypedef((i64)1);
        }
        else if (($temp==(i64)89)) {
            goto L535 ;
        }
        else {
            qq_parse$readpackvars(qq_decls$stcurrproc,(i64)8);
        }
        };
    }
L535 :;
    ;
    qq_parse$checkend((i64)121,(i64)0,startpos);
}

static void qq_parse$readffiparams(struct qq_decls$strec *stproc) {
        i64 pret;
        i64 ptype;
    if (((i64)qq_decls$lx.symbol == (i64)12)) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)13)) {
            qq_lex$lex();
        }
        else {
            ptype = qq_parse$readtypespec((i64)0,0);
            if (((i64)qq_decls$lx.symbol == (i64)4 || (i64)qq_decls$lx.symbol == (i64)13)) {
                qq_parse$readtypeparams(stproc,ptype);
            }
            else {
                qq_parse$readtypenameparams(stproc,ptype);
            }
;
        }
;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)6 || (i64)qq_decls$lx.symbol == (i64)10)) {
        if (!(!!(msysc$m_getdotindex((i64)(*stproc).flags,(i64)4)))) {
            qq_lib$serror((byte*)"Return type for proc?");
        }
;
        qq_lex$lex();
    }
;
    pret = (i64)0;
    if (!!(msysc$m_getdotindex((i64)(*stproc).flags,(i64)4))) {
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lib$serror((byte*)"Return type missing");
        }
;
        pret = qq_parse$readtypespec((i64)0,0);
    }
;
    qq_lib$storemode((*stproc).owner,pret,&(*stproc).mode);
}

static void qq_parse$readtypeparams(struct qq_decls$strec *stproc,i64 ptype) {
        u8 str[32];
        i64 nparams;
        struct qq_decls$strec *  stname;
    nparams = (i64)0;
    L536 :;
    while (1) {
        ++(nparams);
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"$",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_end();
        ;
        stname = qq_names$addsymbol(stproc,qq_names$addglobalname(str),(i64)16,(i64)0);
        qq_lib$storemode(stproc,ptype,&(*stname).mode);
        ++((*stproc).nparams);
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)25)) {
                (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)8,(u64)1u);
                qq_lex$lex();
                goto L537 ;
            }
;
            ptype = qq_parse$readtypespec((i64)0,0);
        }
        else {
            goto L537 ;
        }
;
    }
L537 :;
    ;
    qq_lib$skipsymbol((i64)13);
}

static void qq_parse$readtypenameparams(struct qq_decls$strec *stproc,i64 ptype) {
        struct qq_decls$strec *  stname;
    qq_lib$checksymbol((i64)79);
    stname = qq_names$addsymbol(stproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)16,(i64)0);
    qq_lib$storemode(stproc,ptype,&(*stname).mode);
    ++((*stproc).nparams);
    qq_lex$lex();
    L538 :;
    while (1) {
        if (((i64)qq_decls$lx.symbol == (i64)50)) {
            qq_lex$lex();
            (*stname).code = qq_parse$readexpression();
            (*stname).flags = msysc$m_setdotindex((*stname).flags,(i64)7,(u64)1u);
        }
;
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)4)) {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)25)) {
                (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)8,(u64)1u);
                qq_lex$lex();
                goto L539 ;
            }
;
            if (!!(qq_parse$istypestarter())) {
                ptype = qq_parse$readtypespec((i64)0,0);
            }
;
            qq_lib$checksymbol((i64)79);
            stname = qq_names$addsymbol(stproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)16,(i64)0);
            qq_lib$storemode(stproc,ptype,&(*stname).mode);
            ++((*stproc).nparams);
            qq_lex$lex();
        }
        else {
            goto L539 ;
        }
        };
    }
L539 :;
    ;
    qq_lib$skipsymbol((i64)13);
}

void qq_parse$readrecorddef(i64 isglobal,struct qq_decls$strec *d) {
        i64 kwd;
        i64 baseclass;
        i64 m;
        i64 startline;
        i64 caligned;
        struct qq_decls$strec *  nameptr;
    baseclass = (i64)0;
    if (!!(d)) {
        kwd = (i64)122;
        goto L540 ;
;
    }
;
    kwd = (i64)qq_decls$lx.symbol;
    qq_parse$lexchecksymbol((i64)79);
    nameptr = (struct qq_decls$strec *)qq_decls$lx.symptr;
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == (i64)12)) {
        qq_lex$lex();
        baseclass = qq_parse$readtypespec((i64)0,0);
        qq_lib$skipsymbol((i64)13);
    }
;
    qq_parse$checkequals();
    qq_lex$lex();
    d = qq_names$addsymbol(qq_decls$stcurrproc,nameptr,((kwd == (i64)116) ? (i64)9 : (i64)10),isglobal);
    if (!!(baseclass)) {
        if ((baseclass > (i64)0)) {
            qq_lib$serror((byte*)"baseclass?");
        }
;
        if ((qq_decls$nbaseclasses >= (i64)255)) {
            qq_lib$serror((byte*)"Too many base classes");
        }
;
        ++(qq_decls$nbaseclasses);
        qq_lib$storemode(qq_decls$stcurrproc,baseclass,&qq_decls$baseclasstable[(qq_decls$nbaseclasses)]);
        (*d).baseclassindex = qq_decls$nbaseclasses;
        qq_decls$baseclassdef[(qq_decls$nbaseclasses)] = (struct qq_decls$strec *)d;
    }
;
    //gotname:
L540 :;
;
    qq_lib$skipsemi();
    startline = (i64)qq_decls$lx.pos;
    if ((kwd == (i64)116)) {
        m = qq_parse$readrecordbody(d);
    }
    else {
        caligned = (i64)0;
        m = qq_parse$readstructbody(d,caligned);
    }
;
    qq_parse$checkend((i64)116,(i64)0,startline);
}

static i64 qq_parse$readrecordbody(struct qq_decls$strec *owner) {
        struct qq_decls$strec *  oldstcurrproc;
        struct qq_decls$strec *  e;
        i64 m;
    m = qq_names$addanontype();
    oldstcurrproc = qq_decls$stcurrproc;
    qq_decls$stcurrproc = owner;
    L541 :;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)128)) {
        qq_parse$readconstdef((i64)0);
    }
    else if (($temp==(i64)124)) {
        qq_parse$readrecordfields(owner);
    }
    else if (($temp==(i64)114) || ($temp==(i64)113)) {
        qq_parse$readprocdef((i64)0);
    }
    else if (($temp==(i64)116)) {
        qq_parse$readrecorddef((i64)0,0);
    }
    else if (($temp==(i64)122)) {
        qq_lex$lex();
        qq_lib$serror((byte*)"CLASS TYPE");
    }
    else if (($temp==(i64)89) || ($temp==(i64)13) || ($temp==(i64)17)) {
        goto L542 ;
    }
    else if (($temp==(i64)71)) {
        qq_lib$serror((byte*)"Class eof?");
        goto L542 ;
    }
    else if (($temp==(i64)5)) {
        qq_lex$lex();
    }
    else {
        if ((!!(qq_parse$istypestarter()) && ((i64)qq_decls$nextlx.symbol != (i64)12))) {
            qq_parse$readrecordfields(owner);
        }
        else {
            qq_lib$serror((byte*)"Unknown record field decl");
        }
;
    }
    }goto L541 ;
L542 :;
    ;
    qq_tables$ttfields[(m)] = (*owner).deflist;
    qq_tables$ttlength[(m)] = (i64)(*owner).nfields;
    qq_tables$ttlower[(m)] = (i64)1;
    qq_tables$ttbasetype[(m)] = (i64)12;
    qq_names$createusertype(owner,m);
    e = (*owner).deflist;
    L543 :;
    while (!!(e)) {
        qq_names$addgenfield(e);
        e = (*e).nextdef;
L544 :;
    }
L545 :;
    ;
    qq_tables$ttsize[(m)] = ((i64)16 * (i64)(*owner).nfields);
    qq_decls$stcurrproc = oldstcurrproc;
    return m;
}

static void qq_parse$readrecordfields(struct qq_decls$strec *owner) {
        i64 nvars;
        i64 offset;
        i64 index;
        struct qq_decls$strec *  d;
    qq_lex$lex();
    nvars = (i64)0;
    index = (i64)(*owner).nfields;
    offset = (index * (i64)16);
    L546 :;
    while (((i64)qq_decls$lx.symbol == (i64)79)) {
        ++(nvars);
        d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)11,(i64)0);
        (*d).atfield = 0;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)20)) {
            qq_lex$lex();
            (*d).atfield = qq_parse$readatfield();
            (*d).fieldoffset = (i64)(*(*d).atfield).fieldoffset;
            (*d).index = (i64)(*(*d).atfield).index;
        }
        else {
            (*d).fieldoffset = offset;
            offset += (i64)16;
            (*d).index = ++(index);
        }
;
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L548 ;
        }
;
        qq_lex$lex();
L547 :;
    }
L548 :;
    ;
    if ((nvars == (i64)0)) {
        qq_lib$serror((byte*)"No fields");
    }
;
    (*qq_decls$stcurrproc).nfields += (i16)nvars;
}

static i64 qq_parse$readstructbody(struct qq_decls$strec *owner,i64 caligned) {
        i64 m;
        i64 ngroups;
        struct qq_decls$strec *  e;
    m = qq_names$addanontype();
    ngroups = (i64)0;
    L549 :;
    while (1) {
        qq_lib$skipsemi();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)117)) {
            ++(ngroups);
            qq_lex$lex();
            qq_parse$addstructflag(owner,(i64)24);
        }
        else if (($temp==(i64)118)) {
            ++(ngroups);
            qq_lex$lex();
            qq_parse$addstructflag(owner,(i64)25);
        }
        else if (($temp==(i64)89)) {
            if (((i64)qq_decls$nextlx.symbol == (i64)117 || (i64)qq_decls$nextlx.symbol == (i64)118)) {
                qq_lex$lex();
            }
;
            if (!!(ngroups)) {
                --(ngroups);
                qq_lex$lex();
                qq_parse$addstructflag(owner,(i64)26);
            }
            else {
                goto L550 ;
            }
;
        }
        else {
            qq_parse$readpackvars(owner,(i64)12);
        }
        };
    }
L550 :;
    ;
    qq_tables$ttfields[(m)] = (*owner).deflist;
    qq_tables$ttlength[(m)] = (i64)(*owner).nfields;
    qq_tables$ttlower[(m)] = (i64)1;
    qq_tables$ttcaligned[(m)] = caligned;
    qq_tables$ttbasetype[(m)] = (i64)13;
    qq_names$createusertype(owner,m);
    e = (*owner).deflist;
    L551 :;
    while (!!(e)) {
                {i64 $temp = (i64)(*e).nameid;
if (($temp==(i64)24) || ($temp==(i64)25) || ($temp==(i64)26)) {
        }
        else {
            qq_names$addgenfield(e);
        }
        };
        e = (*e).nextdef;
L552 :;
    }
L553 :;
    ;
    return m;
}

static void qq_parse$addstructflag(struct qq_decls$strec *owner,i64 id) {
        static i64 structseqno;
        u8 str[32];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"$$#");
    msysc$m_print_i64(++(structseqno),NULL);
    msysc$m_print_end();
    ;
    qq_names$addsymbol(owner,qq_names$addglobalname(str),id,(i64)0);
}

static void qq_parse$readprocdef(i64 isglobal) {
        i64 kwd;
        i64 startline;
        i64 shortfun;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  oldstcurrproc;
    kwd = (i64)qq_decls$lx.symbol;
    shortfun = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)79);
    if (((i64)(*qq_decls$stcurrproc).nameid == (i64)5 || (i64)(*qq_decls$stcurrproc).nameid == (i64)6)) {
        qq_lib$serror((byte*)"Nested proc");
    }
;
    oldstcurrproc = qq_decls$stcurrproc;
    qq_decls$stcurrproc = (d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)5,isglobal));
    qq_names$addproc(d);
    qq_lex$lex();
    (*d).mode = (i64)0;
    if (((i64)qq_decls$lx.symbol == (i64)12)) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol != (i64)13)) {
            qq_parse$readparams(d);
        }
        else {
            qq_lex$lex();
        }
;
    }
;
    qq_parse$checkequals();
    qq_lex$lex();
    startline = (i64)qq_decls$lx.pos;
    if (!(!!(shortfun))) {
        (*d).code = qq_parse$readsunit((i64)0);
        qq_parse$checkend(kwd,(i64)0,startline);
    }
    else {
        (*d).code = qq_parse$readexpression();
        qq_lib$checksymbol((i64)5);
    }
;
    if (!!(mlib$eqstring((*d).name,(byte*)"start"))) {
        (*qq_decls$currmodule).startfn = d;
    }
    else if (!!(mlib$eqstring((*d).name,(byte*)"main"))) {
        (*qq_decls$currmodule).mainfn = d;
    }
;
    (*qq_decls$stcurrproc).flags = msysc$m_setdotindex((*qq_decls$stcurrproc).flags,(i64)4,(u64)(kwd == (i64)114));
    qq_decls$stcurrproc = oldstcurrproc;
}

static struct qq_decls$strec *qq_parse$readatfield(void) {
        struct qq_decls$strec *  p;
        struct qq_decls$strec *  d;
    qq_lib$checksymbol((i64)79);
    d = (struct qq_decls$strec *)qq_decls$lx.symptr;
    qq_lex$lex();
    p = (*qq_decls$stcurrproc).deflist;
    L554 :;
    while (!!(p)) {
        if (!!(mlib$eqstring((*p).name,(*d).name))) {
            return p;
        }
;
        p = (*p).nextdef;
L555 :;
    }
L556 :;
    ;
    qq_lib$serror_s((byte*)"Can't find @ field",(*d).name);
    return (struct qq_decls$strec *)0;
}

static i64 qq_parse$istypestarter(void) {
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)80) || ($temp==(i64)123) || ($temp==(i64)124) || ($temp==(i64)125) || ($temp==(i64)14)) {
        return (i64)1;
    }
    else {
        if (((i64)qq_decls$lx.symbol == (i64)79)) {
            if (((i64)qq_decls$nextlx.symbol == (i64)79)) {
                return (i64)1;
            }
;
        }
;
    }
    };
    return (i64)0;
}

static void qq_parse$readmacrodef(i64 isglobal) {
        struct qq_decls$strec *  stmacro;
        struct qq_decls$strec *  stname;
        struct qq_decls$strec *  owner;
    qq_parse$lexchecksymbol((i64)79);
    stmacro = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)22,isglobal);
    owner = stmacro;
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == (i64)12)) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol != (i64)13)) {
            L557 :;
            while (1) {
                                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)79)) {
                    stname = qq_names$addsymbol(owner,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)23,(i64)0);
                    (*stname).firstdupl = (struct qq_decls$strec *)qq_decls$lx.symptr;
                    qq_lex$lex();
                    if (((i64)qq_decls$lx.symbol == (i64)13)) {
                        goto L558 ;
                    }
;
                    qq_lib$skipsymbol((i64)4);
                }
                else {
                    qq_lib$serror((byte*)"macro def params");
                }
                };
            }
L558 :;
            ;
        }
;
        qq_lex$lex();
    }
;
    qq_parse$checkequals();
    qq_lex$lex();
    (*stmacro).code = qq_parse$readexpression();
}

static struct qq_decls$unitrec *qq_parse$readhostparams(struct qq_decls$unitrec *lhs,i64 isfn) {
        i64 fnindex;
        i64 nargs;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
    fnindex = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)12);
    qq_lex$lex();
    q = qq_parse$readslist(&nargs,(i64)0);
    qq_lib$skipsymbol((i64)13);
    if (!!(lhs)) {
        (*lhs).nextunit = q;
        q = lhs;
    }
;
    p = qq_lib$createunit1((i64)31,q);
    (*p).index = fnindex;
    return p;
}

static void qq_parse$pushlisttype(i64 ltype) {
    if ((qq_parse$nlisttype >= (i64)20)) {
        qq_lib$serror((byte*)"listtype overflow");
    }
;
    qq_parse$listtypestack[(++(qq_parse$nlisttype))-1] = qq_parse$listtype;
    qq_parse$listtype = ltype;
}

static void qq_parse$poplisttype(void) {
    qq_parse$listtype = qq_parse$listtypestack[((qq_parse$nlisttype)--)-1];
}

static struct qq_decls$unitrec *qq_parse$readcompilervar(void) {
        u8 str[100];
        struct mlinux$rsystemtime tm;
        static u8 *  monthnames[12] = {
    (byte*)"Jan",
    (byte*)"Feb",
    (byte*)"Mar",
    (byte*)"Apr",
    (byte*)"May",
    (byte*)"Jun",
    (byte*)"Jul",
    (byte*)"Aug",
    (byte*)"Sep",
    (byte*)"Oct",
    (byte*)"Nov",
    (byte*)"Dec"
};
        struct qq_decls$locrec loc;
        {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)188)) {
        loc.pm = qq_decls$currmodule;
        qq_lib$setlineno(&loc,(i64)msysc$m_getdotslice((i64)qq_decls$lx.pos,(i64)0,(i64)23));
        return qq_lib$createintunit(loc.lineno);
    }
    else if (($temp==(i64)189)) {
        loc.pm = qq_decls$currmodule;
        qq_lib$setlineno(&loc,(i64)msysc$m_getdotslice((i64)qq_decls$lx.pos,(i64)0,(i64)23));
        strcpy(str,msysc$strint(loc.lineno,0));
    }
    else if (($temp==(i64)190)) {
        strcpy((u8 *)str,(*qq_decls$currmodule).name);
    }
    else if (($temp==(i64)191)) {
        strcpy((u8 *)str,(*qq_decls$currmodule).filespec);
    }
    else if (($temp==(i64)192)) {
        strcpy((u8 *)str,(!!(qq_decls$stcurrproc) ? (*qq_decls$stcurrproc).name : (byte*)"<none>"));
    }
    else if (($temp==(i64)193)) {
        mlinux$os_getsystime(&tm);
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#-#-#");
        msysc$m_print_i64((i64)tm.day,NULL);
        msysc$m_print_str(monthnames[((i64)tm.month)-1],NULL);
        msysc$m_print_i64((i64)tm.year,(byte*)"4");
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)194)) {
        mlinux$os_getsystime(&tm);
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#:#:#");
        msysc$m_print_i64((i64)tm.hour,(byte*)"2");
        msysc$m_print_i64((i64)tm.minute,(byte*)"z2");
        msysc$m_print_i64((i64)tm.second,(byte*)"z2");
        msysc$m_print_end();
        ;
    }
    else {
        qq_lib$serror((byte*)"compiler var not impl");
    }
    };
    return qq_lib$createstringunit(mlib$pcm_copyheapstring((u8 *)str),(i64)-1);
}

static struct qq_decls$unitrec *qq_parse$readpair(i64 opc) {
        struct qq_decls$unitrec *  a;
        struct qq_decls$unitrec *  b;
    qq_parse$lexchecksymbol((i64)12);
    qq_lex$lex();
    a = (struct qq_decls$unitrec *)qq_parse$readexpression();
    qq_lib$skipsymbol((i64)4);
    b = (struct qq_decls$unitrec *)qq_parse$readexpression();
    if ((((i64)qq_decls$lx.symbol == (i64)4) && (opc == (i64)41))) {
        qq_lex$lex();
        (*b).nextunit = qq_parse$readexpression();
    }
;
    qq_lib$skipsymbol((i64)13);
    return qq_lib$createunit2(opc,(struct qq_decls$unitrec *)a,(struct qq_decls$unitrec *)b);
}

void qq_parse$lexchecksymbol(i64 symbol) {
    qq_lex$lex();
    qq_lib$checksymbol(symbol);
}

static void qq_parse$readtypedef(i64 isglobal) {
        i64 ptype;
        struct qq_decls$strec *  d;
    qq_parse$lexchecksymbol((i64)79);
    d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)10,isglobal);
    qq_parse$lexchecksymbol((i64)50);
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == (i64)116)) {
        qq_lex$lex();
        (*d).nameid = (i64)9;
        qq_parse$readrecorddef(isglobal,d);
        return;
    }
;
    ptype = qq_parse$readtypespec((i64)0,d);
    qq_names$createusertype(d,ptype);
}

static i64 qq_parse$readtypespec(i64 allowvar,struct qq_decls$strec *owner) {
        i64 t;
        i64 startline;
        i64 caligned;
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  lowerdims[10];
        struct qq_decls$unitrec *  lengthdims[10];
        i64 ndims;
        struct qq_decls$unitrec *  x;
        struct qq_decls$unitrec *  lowerx;
        struct qq_decls$unitrec *  upperx;
        struct qq_decls$unitrec *  lengthx;
        i64 i;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)14)) {
        //dolsq:
L559 :;
;
        qq_lex$lex();
        ndims = (i64)0;
        qq_parse$pushlisttype((i64)0);
        L560 :;
        while (1) {
            lowerx = (lengthx = 0);
            if ((((i64)qq_decls$lx.symbol == (i64)15) || ((i64)qq_decls$lx.symbol == (i64)4))) {
            }
            else {
                x = qq_parse$readexpression();
                if (((i64)(*x).tag == (i64)183)) {
                    lowerx = (*x).a;
                    upperx = (*x).b;
                    if ((((i64)(*lowerx).tag == (i64)45) && ((i64)(*upperx).tag == (i64)45))) {
                        lengthx = qq_lib$createintunit((((*upperx).value - (*lowerx).value) + (i64)1));
                    }
                    else {
                        lengthx = qq_lib$createunit2((i64)138,upperx,lowerx);
                        lengthx = qq_lib$createunit2((i64)137,lengthx,qq_lib$createintunit((i64)1));
                    }
;
                }
                else {
                                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)15) || ($temp==(i64)4)) {
                        lengthx = x;
                    }
                    else if (($temp==(i64)6)) {
                        lowerx = x;
                        qq_lex$lex();
                        if (!((((i64)qq_decls$lx.symbol == (i64)4) || ((i64)qq_decls$lx.symbol == (i64)15)))) {
                            lengthx = qq_parse$readexpression();
                        }
;
                    }
                    };
                }
;
            }
;
            lowerdims[(++(ndims))-1] = lowerx;
            lengthdims[(ndims)-1] = lengthx;
            if (((i64)qq_decls$lx.symbol != (i64)4)) {
                goto L561 ;
            }
;
            qq_lex$lex();
        }
L561 :;
        ;
        qq_lib$skipsymbol((i64)15);
        qq_parse$poplisttype();
        t = qq_parse$readtypespec((i64)0,0);
        for (i=ndims;i>=(i64)1;--i) {
L562 :;
            t = qq_names$makeaxtype(t,lowerdims[(i)-1],lengthdims[(i)-1]);
L563 :;
        }
L564 :;
        ;
        return t;
    }
    else if (($temp==(i64)123)) {
        qq_lex$lex();
        if ((((i64)qq_decls$lx.symbol == (i64)80) && ((i64)qq_decls$lx.subcode == (i64)0))) {
            qq_lex$lex();
            return qq_names$makereftype((i64)0,owner);
        }
        else {
            return qq_names$makereftype(qq_parse$readtypespec((i64)0,0),owner);
        }
;
    }
    else if (($temp==(i64)79)) {
        d = (struct qq_decls$strec *)qq_decls$lx.symptr;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)2)) {
            qq_parse$lexchecksymbol((i64)79);
            t = qq_names$newusertypex((struct qq_decls$strec *)d,(struct qq_decls$strec *)qq_decls$lx.symptr);
            qq_lex$lex();
            return t;
        }
        else {
            return qq_names$newusertypex((struct qq_decls$strec *)d,0);
        }
;
    }
    else if (($temp==(i64)80)) {
                {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)36)) {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)29)) {
                qq_lex$lex();
                return qq_names$makestrtype((i64)36,qq_parse$readexpression());
            }
            else {
                return (i64)37;
            }
;
        }
        else if (($temp==(i64)35)) {
            qq_parse$lexchecksymbol((i64)29);
            qq_lex$lex();
            return qq_names$makestrtype((i64)35,qq_parse$readexpression());
        }
        else if (($temp==(i64)11)) {
            qq_parse$lexchecksymbol((i64)14);
            goto L559 ;
;
        }
        else {
            t = (i64)qq_decls$lx.subcode;
            if ((t==(i64)1)) {
                t = (i64)25;
            }
            else if ((t==(i64)2)) {
                t = (i64)31;
            }
;
            qq_lex$lex();
            return t;
        }
        };
    }
    else if (($temp==(i64)116)) {
        if ((owner == 0)) {
            qq_lib$serror((byte*)"anon record");
        }
;
        qq_lex$lex();
        startline = (i64)qq_decls$lx.pos;
        t = qq_parse$readrecordbody(owner);
        qq_parse$checkend((i64)116,(i64)0,startline);
        return t;
    }
    else if (($temp==(i64)117)) {
        if ((owner == 0)) {
            qq_lib$serror((byte*)"anon struct");
        }
;
        qq_lex$lex();
        caligned = (i64)0;
        if (((i64)qq_decls$lx.symbol == (i64)132)) {
            caligned = (i64)1;
            qq_lex$lex();
        }
;
        startline = (i64)qq_decls$lx.pos;
        t = qq_parse$readstructbody(owner,caligned);
        qq_parse$checkend((i64)117,(i64)0,startline);
        return t;
    }
    else if (($temp==(i64)125)) {
        qq_parse$lexchecksymbol((i64)14);
        qq_parse$lexchecksymbol((i64)15);
        qq_lex$lex();
        t = qq_names$makeslicetype(qq_parse$readtypespec((i64)0,0));
    }
    else {
        qq_lib$serror((byte*)"Type expected");
    }
    };
    return t;
}

static void qq_parse$readparams(struct qq_decls$strec *stproc) {
        i64 isbyref;
        i64 isoptional;
        struct qq_decls$strec *  d;
    isbyref = (isoptional = (i64)0);
    L565 :;
    while (1) {
        if (((i64)qq_decls$lx.symbol == (i64)22)) {
            ++(isbyref);
            qq_lex$lex();
        }
;
        if (((i64)qq_decls$lx.symbol == (i64)21)) {
            ++(isoptional);
            qq_lex$lex();
        }
;
        qq_lib$checksymbol((i64)79);
        d = qq_names$addsymbol(stproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)15,(i64)0);
        ++((*stproc).nparams);
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)50)) {
            isoptional = (i64)1;
            qq_lex$lex();
            (*d).code = qq_parse$readexpression();
        }
;
        if ((!!(isbyref) && !!(isoptional))) {
            qq_lib$serror((byte*)"Mixed byref/optional");
        }
;
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)5,(u64)isbyref);
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)7,(u64)isoptional);
        isbyref = (isoptional = (i64)0);
        if (((i64)qq_decls$lx.symbol == (i64)4)) {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)25)) {
                (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)8,(u64)1u);
                qq_lex$lex();
                goto L566 ;
            }
;
        }
        else {
            goto L566 ;
        }
;
    }
L566 :;
    ;
    qq_lib$skipsymbol((i64)13);
}

static struct qq_decls$unitrec *qq_parse$checkoperator(void) {
        struct qq_decls$unitrec *  p;
        i64 opc;
    if (((i64)qq_decls$nextlx.symbol == (i64)4 || (i64)qq_decls$nextlx.symbol == (i64)13 || (i64)qq_decls$nextlx.symbol == (i64)5)) {
        p = qq_lib$createunit0((i64)6);
        if (((i64)qq_decls$lx.symbol == (i64)151)) {
                        {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)45)) {
                opc = (i64)95;
            }
            else if (($temp==(i64)23899)) {
                opc = (i64)200;
            }
            else {
                opc = (i64)0;
            }
            };
            (*p).pclopcode = opc;
        }
        else {
            (*p).pclopcode = (i64)qq_tables$jpclcodes[((i64)qq_decls$lx.subcode)];
        }
;
        qq_lex$lex();
        return p;
    }
;
    return (struct qq_decls$unitrec *)0;
}

static struct qq_decls$unitrec *qq_parse$readlambda(void) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$strec *  params[100];
        struct qq_decls$strec *  oldstcurrproc;
        struct qq_decls$strec *  stproc;
        struct qq_decls$strec *  d;
        u8 str[20];
        i64 nparams;
        {i64 $temp = (i64)(*qq_decls$stcurrproc).nameid;
if (($temp==(i64)5)) {
    }
    else if (($temp==(i64)6)) {
        qq_lib$serror((byte*)"Nested {}");
    }
    else {
        qq_lib$serror((byte*)"{} not in fn");
    }
    };
    oldstcurrproc = qq_decls$stcurrproc;
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"$F",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(++(qq_parse$nextlambdaindex),NULL);
    msysc$m_print_end();
    ;
    stproc = qq_names$addsymbol(qq_decls$stcurrproc,qq_lex$addnamestr(str),(i64)6,(i64)0);
    qq_decls$stcurrproc = stproc;
    qq_names$addproc(stproc);
    qq_lex$lex();
    nparams = (i64)0;
    if ((((i64)qq_decls$lx.symbol == (i64)79) && ((i64)qq_decls$nextlx.symbol == (i64)4 || (i64)qq_decls$nextlx.symbol == (i64)6))) {
        L567 :;
        while (1) {
            qq_lib$checksymbol((i64)79);
            d = qq_names$addsymbol(stproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)15,(i64)0);
            params[(++(nparams))-1] = d;
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol != (i64)4)) {
                goto L568 ;
            }
;
            qq_lex$lex();
        }
L568 :;
        ;
        qq_lib$checksymbol((i64)6);
        qq_lex$lex();
    }
;
    (*stproc).nparams = nparams;
    (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)4,(u64)1u);
    (*stproc).code = qq_parse$readsunit((i64)0);
    qq_lib$skipsymbol((i64)17);
    p = (struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)stproc);
    qq_decls$stcurrproc = oldstcurrproc;
    return p;
}

static void qq_parse$readpackvars(struct qq_decls$strec *owner,i64 id) {
        i64 t;
        i64 nvars;
        struct qq_decls$strec *  d;
    t = qq_parse$readtypespec((i64)0,0);
    nvars = (i64)0;
    L569 :;
    while (((i64)qq_decls$lx.symbol == (i64)79)) {
        ++(nvars);
        d = qq_names$addsymbol(owner,(struct qq_decls$strec *)qq_decls$lx.symptr,id,(i64)0);
        qq_lib$storemode(owner,t,&(*d).mode);
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol != (i64)4)) {
            goto L571 ;
        }
;
        qq_parse$lexchecksymbol((i64)79);
L570 :;
    }
L571 :;
    ;
    if ((nvars == (i64)0)) {
        qq_lib$serror((byte*)"bad decl?");
    }
;
}

// START
void qq_parse$start(void) {

}

void qq_print$pch_print(struct qq_decls$varrec *p,struct qq_decls$varrec *fmt) {
        struct qq_decls$varrec v;
        struct qq_decls$varrec emptyfmt;
    if ((fmt == 0)) {
        fmt = &emptyfmt;
        emptyfmt.tagx = (i64)0;
    }
;
    if ((qq_print$mfmtstr == 0)) {
        if (!!((i64)qq_print$mgapneeded)) {
            qq_print$printstr_n((byte*)" ",(i64)1);
        }
        else {
            qq_print$mgapneeded = (i64)1;
        }
;
    }
    else {
        qq_print$printnextfmtchars((i64)0);
    }
;
    qq_print$listdepth = (i64)0;
    qq_print$pch_tostr(p,fmt,&v);
    qq_print$printstr_n((*v.objptr).strptr,(*v.objptr).length);
    if (!!((i64)v.hasref)) {
        qq_vars$var_unshareu(&v);
    }
;
}

void qq_print$pch_print_nf(struct qq_decls$varrec *p) {
    qq_print$pch_print(p,0);
}

void qq_print$pch_printnogap(void) {
    qq_print$mgapneeded = (i64)0;
}

void qq_print$pch_println(void) {
    if (!!(qq_print$mfmtstr)) {
        qq_print$printnextfmtchars((i64)1);
    }
;
    qq_print$mgapneeded = (i64)0;
    qq_print$printstr_n((byte*)"\n",(i64)-1);
}

void qq_print$pch_reread(void) {
    qq_print$kb_pos = qq_print$kb_lastpos;
    qq_print$kb_length = qq_print$kb_lastlength;
}

void qq_print$pch_rereadln(void) {
    qq_print$kb_pos = qq_print$kb_start;
    qq_print$kb_length = qq_print$kb_linelength;
}

void qq_print$pch_startprint(struct qq_decls$varrec *p) {
        struct qq_decls$objrec *  s;
        {i64 $temp = ++(qq_print$noclevels);
if (($temp==(i64)0) || ($temp==(i64)1)) {
    }
    else if (($temp==(i64)7)) {
        qq_lib$prterror((byte*)"print #x overflow");
    }
    else {
        qq_print$moutdevstack[((qq_print$noclevels - (i64)1))] = qq_print$moutdev;
        qq_print$moutchanstack[((qq_print$noclevels - (i64)1))] = qq_print$moutchan;
        qq_print$moutvarstack[((qq_print$noclevels - (i64)1))] = qq_print$moutvar;
        qq_print$mfmtstrstack[((qq_print$noclevels - (i64)1))] = qq_print$mfmtstr;
        qq_print$mfmtcurrstack[((qq_print$noclevels - (i64)1))] = qq_print$mfmtcurr;
        qq_print$mgapstack[((qq_print$noclevels - (i64)1))] = (i64)qq_print$mgapneeded;
    }
    };
    qq_print$mfmtstr = 0;
    qq_print$mfmtcurr = 0;
    if ((p == 0)) {
        goto L572 ;
;
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        switch ((*p).value) {
        case 0:;
            {
                //doconsole:
L572 :;
;
                qq_print$moutdev = (i64)0;
                qq_print$moutchan = 0;
            }
            break;
        case 1:;
            {
                qq_print$moutdev = (i64)2;
                qq_print$moutchan = 0;
                qq_print$moutvar.tagx = (i64)265;
                s = qq_vars$obj_new();
                (*s).flags = msysc$m_setdotindex((*s).flags,(i64)1,(u64)1u);
                qq_print$moutvar.objptr = s;
            }
            break;
        case 2:;
            {
                if ((qq_print$testfilech == 0)) {
                    qq_lib$prterror((byte*)"@2: file not open");
                }
;
                qq_print$moutdev = (i64)1;
                qq_print$moutchan = qq_print$testfilech;
            }
            break;
        default: {
            qq_print$moutdev = (i64)1;
            qq_print$moutchan = (void *)(*p).value;
        }
        } //SW
;
    }
    else if (($temp==(i64)14)) {
        p = (*p).varptr;
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)9)) {
            qq_print$moutdev = (i64)4;
            qq_print$moutchan = 0;
            qq_print$moutvar.tagx = (i64)14;
            qq_print$moutvar.varptr = p;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$prterror((byte*)"Print@^?");
        }
        };
    }
    else {
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)12) || ($temp==(i64)13)) {
            qq_print$moutdev = (i64)0;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$prterror((byte*)"Can't do startprint...");
        }
        };
    }
    };
    qq_print$mgapneeded = (i64)0;
}

void qq_print$pch_startprintcon(void) {
        struct qq_decls$varrec v;
    v.tagx = (i64)1;
    v.value = (i64)0;
    qq_print$pch_startprint(&v);
}

void qq_print$pch_endprint(void) {
        struct qq_decls$varrec *  p;
    if (!!(qq_print$mfmtstr)) {
        qq_print$printnextfmtchars((i64)1);
    }
;
    if ((qq_print$moutdev==(i64)4)) {
        p = qq_print$moutvar.varptr;
    }
;
    if ((qq_print$mfmtstr != 0)) {
        mlib$pcm_free((void *)qq_print$mfmtstr,(strlen(qq_print$mfmtstr) + (i64)1));
    }
;
    if ((--(qq_print$noclevels) == (i64)-1)) {
        qq_lib$prterror((byte*)"resetoc??");
    }
;
    if ((qq_print$noclevels == (i64)0)) {
        qq_print$moutdev = (i64)0;
    }
    else {
        qq_print$moutdev = (i64)qq_print$moutdevstack[(qq_print$noclevels)];
        qq_print$moutchan = qq_print$moutchanstack[(qq_print$noclevels)];
        qq_print$moutvar = qq_print$moutvarstack[(qq_print$noclevels)];
        qq_print$mgapneeded = (i64)qq_print$mgapstack[(qq_print$noclevels)];
        qq_print$mfmtstr = qq_print$mfmtstrstack[(qq_print$noclevels)];
        qq_print$mfmtcurr = qq_print$mfmtcurrstack[(qq_print$noclevels)];
    }
;
    qq_print$mgapneeded = (i64)0;
}

void qq_print$pch_strstartprint(void) {
        struct qq_decls$varrec p;
    p.tagx = (i64)1;
    p.value = (i64)1;
    qq_print$pch_startprint(&p);
}

void qq_print$pch_strendprint(struct qq_decls$varrec *dest) {
    if (!!(qq_print$mfmtstr)) {
        qq_print$printnextfmtchars((i64)1);
    }
;
    if ((qq_print$moutdev != (i64)2)) {
        qq_lib$prterror((byte*)"STRENDPRT/NOT STR");
    }
;
    (*dest) = qq_print$moutvar;
    qq_print$moutvar.tagx = (i64)0;
    qq_print$pch_endprint();
}

void qq_print$pch_printspace(void) {
    qq_print$mgapneeded = (i64)0;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)" ",NULL);
    msysc$m_print_end();
    ;
}

void qq_print$pch_readln(struct qq_decls$varrec *dev) {
        void *  ch;
        i64 length;
        struct qq_decls$objrec *  pdev;
    if ((qq_print$kb_start == 0)) {
        qq_print$kb_start = (u8 *)mlib$pcm_alloc((i64)1048576);
        qq_print$kb_size = (i64)1048576;
        qq_print$kb_lastpos = qq_print$kb_start;
        qq_print$kb_pos = qq_print$kb_start;
        qq_print$kb_length = (i64)0;
        qq_print$kb_lastlength = (i64)0;
        qq_print$kb_linelength = (i64)0;
    }
;
        {i64 $temp = (i64)(*dev).tag;
if (($temp==(i64)0)) {
        //doconsole:
L573 :;
;
        mlib$readlinen(0,qq_print$kb_start,qq_print$kb_size);
        qq_print$kb_length = strlen(qq_print$kb_start);
    }
    else if (($temp==(i64)1)) {
                {i64 $temp = (*dev).value;
if (($temp==(i64)0)) {
            goto L573 ;
;
        }
        else if (($temp==(i64)1)) {
            if ((qq_print$testfilech == 0)) {
                qq_lib$prterror((byte*)"R@2: file not open");
            }
;
            ch = qq_print$testfilech;
        }
        else {
            ch = (void *)(*dev).value;
        }
        };
        mlib$readlinen(ch,qq_print$kb_start,qq_print$kb_size);
        qq_print$kb_length = strlen(qq_print$kb_start);
    }
    else if (($temp==(i64)9)) {
        pdev = (*dev).objptr;
        length = (*pdev).length;
        if ((length == (i64)0)) {
            qq_print$kb_length = (i64)0;
            (*qq_print$kb_start) = (u64)0u;
        }
        else if ((length >= qq_print$kb_size)) {
            qq_lib$prterror((byte*)"KB overflow");
        }
        else {
            qq_print$kb_length = length;
            memcpy((void *)qq_print$kb_start,(void *)(*pdev).strptr,(u64)length);
        }
;
    }
    else {
        qq_lib$pcustype((byte*)"readln@",dev);
    }
    };
    qq_print$kb_pos = qq_print$kb_start;
    qq_print$kb_lastpos = qq_print$kb_pos;
    qq_print$kb_linelength = qq_print$kb_length;
}

void qq_print$pch_sread(struct qq_decls$varrec *fmt,struct qq_decls$varrec *dest) {
        i64 fmtcode;
    fmtcode = qq_print$getreadfmtcode(fmt);
    qq_print$kb_lastpos = qq_print$kb_pos;
    qq_print$kb_lastlength = qq_print$kb_length;
    if ((fmtcode==(i64)73)) {
        qq_print$stepkbpos(qq_print$readint(qq_print$kb_pos,qq_print$kb_length,dest,(i64)0));
    }
    else if ((fmtcode==(i64)82)) {
        qq_print$stepkbpos(qq_print$readreal(qq_print$kb_pos,qq_print$kb_length,dest));
    }
    else if ((fmtcode==(i64)78)) {
        qq_print$stepkbpos(qq_print$readname(qq_print$kb_pos,qq_print$kb_length,dest));
    }
    else if ((fmtcode==(i64)83)) {
        qq_print$stepkbpos(qq_print$readstring(qq_print$kb_pos,qq_print$kb_length,dest));
    }
    else if ((fmtcode==(i64)72)) {
        qq_print$stepkbpos(qq_print$readhex(qq_print$kb_pos,qq_print$kb_length,dest));
    }
    else if ((fmtcode==(i64)66)) {
        qq_print$stepkbpos(qq_print$readbin(qq_print$kb_pos,qq_print$kb_length,dest));
    }
    else if ((fmtcode==(i64)65)) {
        qq_print$stepkbpos(qq_print$readany(qq_print$kb_pos,qq_print$kb_length,dest));
    }
    else if ((fmtcode==(i64)76)) {
        if ((qq_print$kb_length == (i64)0)) {
            qq_strings$var_empty_string(dest,(i64)0);
        }
        else {
            qq_strings$var_make_stringn(qq_print$kb_pos,qq_print$kb_length,dest,(i64)1);
            qq_print$kb_pos += qq_print$kb_length;
            qq_print$kb_length = (i64)0;
        }
;
    }
    else if ((fmtcode==(i64)67)) {
        if ((qq_print$kb_length == (i64)0)) {
            qq_strings$var_empty_string(dest,(i64)0);
        }
        else {
            qq_print$termchar = (u64)(*qq_print$kb_pos);
            //dochar:
L574 :;
;
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)(u64)qq_print$termchar;
            ++(qq_print$kb_pos);
            --(qq_print$kb_length);
        }
;
    }
    else if ((fmtcode==(i64)90)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)(u64)qq_print$termchar;
    }
    else if ((fmtcode==(i64)69)) {
        (*dest).tagx = (i64)1;
        (*dest).value = qq_print$itemerror;
    }
    else if ((fmtcode==(i64)68)) {
        qq_print$stepkbpos(qq_print$readint(qq_print$kb_pos,qq_print$kb_length,dest,(i64)1));
    }
    else {
        qq_lib$prterror((byte*)"SREAD/FMT?");
    }
;
}

void qq_print$pch_sreadln(struct qq_decls$varrec *dev,struct qq_decls$varrec *dest) {
    qq_print$pch_readln(dev);
    qq_strings$var_make_stringn(qq_print$kb_start,qq_print$kb_length,dest,(i64)1);
}

static u8 *qq_print$readname(u8 *s,i64 length,struct qq_decls$varrec *dest) {
        u8 *  send;
        u8 *  itemstr;
        i64 itemlength;
    send = qq_print$readitem(s,length,&itemstr,&itemlength);
    qq_strings$var_make_stringn(itemstr,itemlength,dest,(i64)1);
    mlib$iconvlcn((*(*dest).objptr).strptr,(*(*dest).objptr).length);
    return send;
}

static u8 *qq_print$readstring(u8 *s,i64 length,struct qq_decls$varrec *dest) {
        u8 *  send;
        u8 *  itemstr;
        i64 itemlength;
    send = qq_print$readitem(s,length,&itemstr,&itemlength);
    qq_strings$var_make_stringn(itemstr,itemlength,dest,(i64)1);
    return send;
}

static u8 *qq_print$readint(u8 *sold,i64 length,struct qq_decls$varrec *dest,i64 dodec) {
        u8 *  s;
        u8 *  send;
        i64 itemlength;
    send = qq_print$readitem(sold,length,&s,&itemlength);
    qq_print$strtoint(s,itemlength,dest,dodec);
    return send;
}

static u8 *qq_print$readhex(u8 *sold,i64 length,struct qq_decls$varrec *dest) {
        u8 str[256];
        u8 *  p;
        u8 *  s;
        i64 aa;
        i64 t;
        i64 nalloc;
        u8 c;
    if ((length == (i64)0)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)0;
        qq_print$termchar = (u64)0u;
        return sold;
    }
;
    L575 :;
    while ((!!(length) && (((u64)(*sold) == ' ') || ((i64)(u64)(*sold) == (i64)9)))) {
        ++(sold);
        --(length);
L576 :;
    }
L577 :;
    ;
    if ((length <= (i64)256)) {
        s = (u8 *)str;
        nalloc = (i64)0;
    }
    else {
        nalloc = (length + (i64)1);
        s = (u8 *)mlib$pcm_alloc(nalloc);
    }
;
    p = s;
    L578 :;
    while (!!(length)) {
        c = (u64)toupper((i32)(u64)(*sold));
        ++(sold);
        --(length);
        if ((((u64)c >= '0') && ((u64)c <= '9'))) {
            (*p) = (u64)c;
            ++(p);
        }
        else if ((((u64)c >= 'A') && ((u64)c <= 'F'))) {
            (*p) = (u64)c;
            ++(p);
        }
        else if (((u64)c == '_')) {
        }
        else {
            qq_print$termchar = (u64)c;
            goto L580 ;
        }
;
L579 :;
    }
L580 :;
    ;
    (*p) = (u64)0u;
    length = (p - s);
    if ((length <= (i64)16)) {
        t = (i64)1;
    }
    else {
        t = (i64)3;
    }
;
    p = s;
    if ((t==(i64)1)) {
        aa = (i64)0;
        L581 :;
        while (1) {
            c = (u64)(*p);
            ++(p);
            if (((i64)(u64)c == (i64)0)) {
                goto L582 ;
            }
;
            if (((u64)c < 'A')) {
                aa = (((aa * (i64)16) + (i64)(u64)c) - (i64)48);
            }
            else {
                aa = (((aa * (i64)16) + (i64)((u64)c - 'A')) + (i64)10);
            }
;
        }
L582 :;
        ;
        (*dest).tagx = (i64)1;
        (*dest).value = aa;
    }
    else {
        qq_lib$prterror((byte*)"Readhex/long");
    }
;
    if (!!(nalloc)) {
        mlib$pcm_free((void *)s,nalloc);
    }
;
    return sold;
}

static u8 *qq_print$readbin(u8 *sold,i64 length,struct qq_decls$varrec *dest) {
        u8 str[256];
        u8 *  p;
        u8 *  s;
        i64 aa;
        i64 t;
        i64 nalloc;
        u8 c;
    if ((length == (i64)0)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)0;
        qq_print$termchar = (u64)0u;
        return sold;
    }
;
    L583 :;
    while ((!!(length) && (((u64)(*sold) == ' ') || ((i64)(u64)(*sold) == (i64)9)))) {
        ++(sold);
        --(length);
L584 :;
    }
L585 :;
    ;
    if ((length <= (i64)256)) {
        s = (u8 *)str;
        nalloc = (i64)0;
    }
    else {
        nalloc = (length + (i64)1);
        s = (u8 *)mlib$pcm_alloc(nalloc);
    }
;
    p = s;
    L586 :;
    while (!!(length)) {
        c = (u64)toupper((i32)(u64)(*sold));
        ++(sold);
        --(length);
        if ((((u64)c >= '0') && ((u64)c <= '1'))) {
            (*p) = (u64)c;
            ++(p);
        }
        else if (((u64)c == '_')) {
        }
        else {
            qq_print$termchar = (u64)c;
            goto L588 ;
        }
;
L587 :;
    }
L588 :;
    ;
    (*p) = (u64)0u;
    length = (p - s);
    if ((length <= (i64)64)) {
        t = (i64)1;
    }
    else {
        t = (i64)3;
    }
;
    p = s;
    if ((t==(i64)1)) {
        aa = (i64)0;
        L589 :;
        while (1) {
            c = (u64)(*p);
            ++(p);
            if (((i64)(u64)c == (i64)0)) {
                goto L590 ;
            }
;
            aa = (((aa * (i64)2) + (i64)(u64)c) - (i64)48);
        }
L590 :;
        ;
        (*dest).tagx = (i64)1;
        (*dest).value = aa;
    }
    else {
        qq_lib$prterror((byte*)"Readbin/long");
    }
;
    if (!!(nalloc)) {
        mlib$pcm_free((void *)s,nalloc);
    }
;
    return sold;
}

static u8 *qq_print$readreal(u8 *sold,i64 length,struct qq_decls$varrec *dest) {
        u8 *  send;
        u8 *  itemstr;
        i64 itemlength;
    send = qq_print$readitem(sold,length,&itemstr,&itemlength);
    qq_print$strtoreal(itemstr,itemlength,dest);
    return send;
}

i64 qq_print$getreadfmtcode(struct qq_decls$varrec *p) {
        u8 c;
    if (((p == 0) || ((i64)(*p).tag == (i64)0))) {
        return (i64)65;
    }
;
    if (((i64)(*p).tag != (i64)9)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"P=%s",NULL);
        msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$prterror((byte*)"Readfmt?");
    }
;
    if (((*(*p).objptr).length == (i64)0)) {
        return (i64)65;
    }
;
    c = (u64)toupper((i32)(u64)(*(*(*p).objptr).strptr));
    if (((u64)c=='I') || ((u64)c=='R') || ((u64)c=='N') || ((u64)c=='S') || ((u64)c=='F') || ((u64)c=='T') || ((u64)c=='Z') || ((u64)c=='C') || ((u64)c=='L') || ((u64)c=='H') || ((u64)c=='B') || ((u64)c=='A') || ((u64)c=='E') || ((u64)c=='D')) {
        return (i64)(u64)c;
    }
;
    qq_lib$prterror((byte*)"Readfmt2?");
    return (i64)0;
}

static void qq_print$stepkbpos(u8 *s) {
        i64 newlen;
    newlen = (s - qq_print$kb_pos);
    if ((newlen == (i64)0)) {
        return;
    }
;
    if ((newlen >= qq_print$kb_length)) {
        qq_print$kb_pos = (qq_print$kb_pos + qq_print$kb_length);
        qq_print$kb_length = (i64)0;
    }
    else {
        qq_print$kb_pos = (qq_print$kb_pos + newlen);
        qq_print$kb_length -= newlen;
    }
;
}

static u8 *qq_print$readany(u8 *sold,i64 length,struct qq_decls$varrec *dest) {
        u8 *  p;
        u8 *  s;
        i64 digits;
        i64 expon;
        i64 other;
        u8 *  send;
        i64 itemlength;
        i64 $av_1;
    qq_print$itemerror = (i64)0;
    send = qq_print$readitem(sold,length,&s,&itemlength);
    p = s;
    digits = (expon = (other = (i64)0));
    $av_1 = itemlength;
    while ($av_1-- > 0) {
L591 :;
        switch ((i64)(u64)(*(p)++)) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 43:;
        case 45:;
        case 95:;
            {
                digits = (i64)1;
            }
            break;
        case 69:;
        case 101:;
        case 46:;
            {
                expon = (i64)1;
            }
            break;
        default: {
            other = (i64)1;
        }
        } //SW
;
L592 :;
    }
L593 :;
    ;
    (*dest).tagx = (i64)1;
    if ((!!(other) || (itemlength == (i64)0))) {
        (*dest).value = (i64)5395539;
        qq_strings$var_make_stringn(s,itemlength,dest,(i64)1);
    }
    else if (!!(expon)) {
        qq_print$strtoreal(s,itemlength,dest);
    }
    else {
        qq_print$strtoint(s,itemlength,dest,(i64)0);
    }
;
    return send;
}

static u8 *qq_print$readitem(u8 *s,i64 length,u8 **itemstr,i64 *itemlength) {
        u8 *  p;
        u8 quotechar;
        u8 c;
    L594 :;
    while ((!!(length) && (((u64)(*s) == ' ') || ((i64)(u64)(*s) == (i64)9)))) {
        ++(s);
        --(length);
L595 :;
    }
L596 :;
    ;
    (*itemstr) = s;
    if ((length == (i64)0)) {
        qq_print$termchar = (u64)0u;
        (*itemlength) = (i64)0;
        return s;
    }
;
    quotechar = (u64)0u;
    if (((u64)(*s) == '"')) {
        quotechar = '"';
        ++(s);
        --(length);
    }
    else if (((u64)(*s) == (u64)39u)) {
        quotechar = (u64)39u;
        ++(s);
        --(length);
    }
;
    p = ((*itemstr) = s);
    L597 :;
    while (!!(length)) {
        c = (u64)(*(s)++);
        --(length);
        if (((u64)c==' ') || ((u64)c==(u64)9u) || ((u64)c==',') || ((u64)c=='=') || ((u64)c==';')) {
            if ((!!((u64)quotechar) || (p == s))) {
                goto L600 ;
;
            }
;
            qq_print$termchar = (u64)c;
            goto L599 ;
        }
        else {
            //normalchar:
L600 :;
;
            if (((u64)c == (u64)quotechar)) {
                if ((!!(length) && ((u64)(*s) == (u64)quotechar))) {
                    (*p) = (u64)c;
                    ++(s);
                    ++(p);
                }
                else {
                    qq_print$termchar = (u64)(*s);
                    if ((((u64)qq_print$termchar == ',') || ((u64)qq_print$termchar == '='))) {
                        ++(s);
                        qq_print$termchar = (u64)(*s);
                    }
;
                    goto L599 ;
                }
;
            }
            else {
                (*p) = (u64)c;
                ++(p);
            }
;
        }
;
L598 :;
    }
L599 :;
    ;
    if ((length == (i64)0)) {
        qq_print$termchar = (u64)0u;
    }
;
    (*itemlength) = (p - (*itemstr));
    return s;
}

static void qq_print$strtoreal(u8 *s,i64 length,struct qq_decls$varrec *dest) {
        u8 str[512];
        r64 x;
        i32 numlength;
    (*dest).tagx = (i64)2;
    if (((length >= (i64)512) || (length == (i64)0))) {
        (*dest).xvalue = (double)0.;
        return;
    }
;
    memcpy(str,(void *)s,(u64)length);
    str[((length + (i64)1))-1] = (u64)0u;
    qq_print$itemerror = (i64)0;
    if (((sscanf((u8 *)str,(byte*)"%lf%n",&x,&numlength) == (i64)0) || ((i64)numlength != length))) {
        if (((i64)numlength == length)) {
            x = (double)0.;
        }
;
        qq_print$itemerror = (i64)1;
    }
;
    (*dest).xvalue = x;
}

static void qq_print$strtoint(u8 *s,i64 length,struct qq_decls$varrec *dest,i64 dodec) {
        u8 *  p;
        u8 *  q;
        byte signd;
        i64 aa;
        i64 cat;
        i64 t;
        u8 c;
    qq_print$itemerror = (i64)0;
    if ((length == (i64)0)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)0;
        return;
    }
;
    signd = (i64)0;
    if ((!!(length) && ((u64)(*s) == '-'))) {
        signd = (i64)1;
        ++(s);
        --(length);
    }
    else if ((!!(length) && ((u64)(*s) == '+'))) {
        ++(s);
        --(length);
    }
;
    L601 :;
    while ((((u64)(*s) == '0') && (length > (i64)1))) {
        ++(s);
        --(length);
L602 :;
    }
L603 :;
    ;
    p = (q = s);
    L604 :;
    while (!!(length)) {
        c = (u64)(*(q)++);
        --(length);
        if ((((u64)c >= '0') && ((u64)c <= '9'))) {
            (*p) = (u64)c;
            ++(p);
        }
        else {
            if (((u64)c == '_')) {
            }
            else {
                qq_print$itemerror = (i64)1;
                goto L606 ;
            }
;
        }
;
L605 :;
    }
L606 :;
    ;
    (*p) = (u64)0u;
    length = (p - s);
    if ((length <= (i64)18)) {
        cat = (i64)65;
    }
    else if ((length == (i64)19)) {
                {i64 $temp = mlib$cmpstring(s,(byte*)"9223372036854775808");
if (($temp==(i64)-1)) {
            cat = (i64)65;
        }
        else if (($temp==(i64)0)) {
            cat = (i64)66;
        }
        else {
            cat = (i64)67;
        }
        };
    }
    else if ((length == (i64)20)) {
        if ((mlib$cmpstring(s,(byte*)"18446744073709551615") <= (i64)0)) {
            cat = (i64)67;
        }
        else {
            cat = (i64)68;
        }
;
    }
    else {
        cat = (i64)68;
    }
;
    if (!!(dodec)) {
        cat = (i64)68;
    }
;
    if (!!((i64)signd)) {
        if ((cat==(i64)66)) {
            cat = (i64)65;
        }
        else if ((cat==(i64)67)) {
            cat = (i64)68;
        }
;
    }
;
    if ((cat==(i64)65)) {
        t = (i64)1;
    }
    else {
        t = (i64)3;
    }
;
    p = s;
    if ((t != (i64)3)) {
        aa = (i64)0;
        L607 :;
        while (1) {
            c = (u64)(*p);
            ++(p);
            if (((i64)(u64)c == (i64)0)) {
                goto L608 ;
            }
;
            aa = ((aa * (i64)10) + (i64)((u64)c - '0'));
        }
L608 :;
        ;
        if (!!((i64)signd)) {
            aa = -(aa);
        }
;
        (*dest).tagx = t;
        (*dest).value = aa;
    }
    else {
        qq_decimal$var_make_dec_str(s,length,dest);
    }
;
}

static void qq_print$printnextfmtchars(i64 lastx) {
        u8 c;
        u8 *  pstart;
        i64 n;
    pstart = qq_print$mfmtcurr;
    n = (i64)0;
    L609 :;
    while (1) {
        c = (u64)(*qq_print$mfmtcurr);
        if (((u64)c=='#')) {
            if (!!(lastx)) {
                goto L611 ;
;
            }
;
            ++(qq_print$mfmtcurr);
            if (!!(n)) {
                qq_print$printstr_n(pstart,n);
            }
;
            return;
        }
        else if (((u64)c==(u64)0u)) {
            if (!!(n)) {
                qq_print$printstr_n(pstart,n);
            }
            else if (!(!!(lastx))) {
                qq_print$printstr_n((byte*)"|",(i64)1);
            }
;
            return;
        }
        else if (((u64)c=='~')) {
            if (!!(n)) {
                qq_print$printstr_n(pstart,n);
                n = (i64)0;
            }
;
            ++(qq_print$mfmtcurr);
            c = (u64)(*qq_print$mfmtcurr);
            if (!!((u64)c)) {
                ++(qq_print$mfmtcurr);
                qq_print$printstr_n((u8 *)&c,(i64)1);
            }
;
            pstart = qq_print$mfmtcurr;
        }
        else {
            //skip:
L611 :;
;
            ++(n);
            ++(qq_print$mfmtcurr);
        }
;
    }
L610 :;
    ;
}

void qq_print$pch_setformat(struct qq_decls$varrec *p) {
        i64 n;
        u8 *  s;
    if (((i64)(*p).tag != (i64)9)) {
        qq_lib$prterror((byte*)"(str)");
    }
;
    if (!!(qq_print$mfmtstr)) {
        qq_lib$prterror((byte*)"Setfmt?");
    }
;
    n = (*(*p).objptr).length;
    qq_print$mfmtstr = (u8 *)mlib$pcm_alloc((n + (i64)1));
    if (!!(n)) {
        memcpy((void *)qq_print$mfmtstr,(void *)(*(*p).objptr).strptr,(u64)n);
    }
;
    s = (qq_print$mfmtstr + n);
    (*s) = (u64)0u;
    qq_print$mfmtcurr = qq_print$mfmtstr;
}

struct msysc$fmtrec *qq_print$pc_getfmt(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt) {
    if (((p == 0) || ((i64)(*p).tag == (i64)0))) {
        return (struct msysc$fmtrec *)&qq_print$defaultfmt;
    }
    else {
        if (((i64)(*p).tag != (i64)9)) {
            qq_lib$prterror((byte*)"pc_getfmt/not str?");
        }
;
        if (((*(*p).objptr).strptr == 0)) {
            return (struct msysc$fmtrec *)&qq_print$defaultfmt;
        }
        else {
            msysc$strtofmt((*(*p).objptr).strptr,(*(*p).objptr).length,(struct msysc$fmtrec *)fmt);
            return (struct msysc$fmtrec *)fmt;
        }
;
    }
;
}

void qq_print$addstring(struct qq_decls$objrec *p,u8 *t,i64 n) {
        i64 oldlen;
        i64 newlen;
        i64 oldbytes;
        i64 newbytes;
        u8 *  newptr;
    if (((n == (i64)0) || ((i64)(u64)(*t) == (i64)0))) {
        return;
    }
;
    if ((n < (i64)0)) {
        n = strlen(t);
    }
;
    oldlen = (*p).length;
    if (((i64)(*p).refcount == (i64)0)) {
        if ((oldlen == (i64)0)) {
            memcpy((void *)(*p).strptr,(void *)t,(u64)n);
            (*p).length = n;
        }
        else {
            memcpy((void *)((*p).strptr + oldlen),(void *)t,(u64)n);
            (*p).length = (oldlen + n);
        }
;
        return;
    }
;
    if ((oldlen == (i64)0)) {
        (*p).strptr = (u8 *)mlib$pcm_alloc(n);
        (*p).length = n;
        (*p).alloc64 = mlib$allocbytes;
        memcpy((void *)(*p).strptr,(void *)t,(u64)n);
    }
    else {
        newlen = (oldlen + n);
        oldbytes = (*p).alloc64;
        newbytes = (oldlen + n);
        if ((newbytes <= oldbytes)) {
            memcpy((void *)((*p).strptr + oldlen),(void *)t,(u64)n);
        }
        else {
            newptr = (u8 *)mlib$pcm_alloc(newbytes);
            memcpy((void *)newptr,(void *)(*p).strptr,(u64)oldlen);
            memcpy((void *)(newptr + oldlen),(void *)t,(u64)n);
            (*p).alloc64 = mlib$allocbytes;
            mlib$pcm_free((void *)(*p).strptr,oldbytes);
            (*p).strptr = newptr;
        }
;
        (*p).length = newlen;
    }
;
}

static void qq_print$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt) {
        u8 str[20];
        u8 *  q;
        i64 nchars;
        i64 $av_1;
    q = (u8 *)str;
    nchars = n;
    $av_1 = n;
    while ($av_1-- > 0) {
L612 :;
        if (((i64)(u64)(*p) == (i64)0)) {
            goto L614 ;
        }
;
        (*q) = (u64)(*p);
        ++(q);
        ++(p);
L613 :;
    }
L614 :;
    ;
    (*q) = (u64)0u;
    msysc$expandstr(str,dest,nchars,(struct msysc$fmtrec *)fmt);
}

static void qq_print$printstr_n(u8 *s,i64 n) {
        struct qq_decls$varrec *  p;
    if ((n == (i64)-1)) {
        n = strlen(s);
    }
;
    if ((n == (i64)0)) {
        return;
    }
;
    if ((qq_print$moutdev==(i64)0)) {
        msysc$printstrn_app(s,n,0);
    }
    else if ((qq_print$moutdev==(i64)1)) {
        msysc$printstrn_app(s,n,qq_print$moutchan);
    }
    else if ((qq_print$moutdev==(i64)2)) {
        qq_print$addstring(qq_print$moutvar.objptr,s,n);
    }
    else if ((qq_print$moutdev==(i64)4)) {
        p = qq_print$moutvar.varptr;
        if (((i64)(*p).tag != (i64)9)) {
            qq_lib$prterror((byte*)"prtstrn1");
        }
;
        qq_print$addstring(qq_print$moutvar.objptr,s,n);
    }
    else if ((qq_print$moutdev==(i64)3)) {
    }
;
}

void qq_print$pch_strtoval(struct qq_decls$varrec *p,struct qq_decls$varrec *fmt,struct qq_decls$varrec *dest) {
        i64 fmtcode;
        i64 length;
        struct qq_decls$objrec *  q;
        u8 str[1024];
        u8 *  s;
    s = (u8 *)str;
    q = (*p).objptr;
    if (((*q).length < (i64)1024)) {
        memcpy((void *)s,(void *)(*q).strptr,(u64)(*q).length);
        str[(((*q).length + (i64)1))-1] = (u64)0u;
    }
    else {
        qq_lib$pcerror((byte*)"STRTOVAL/string too long");
    }
;
    fmtcode = qq_print$getreadfmtcode(fmt);
    if (((i64)(*p).tag != (i64)9)) {
        qq_lib$prterror((byte*)"strval");
    }
;
    length = (*(*p).objptr).length;
    if ((fmtcode==(i64)73)) {
        qq_print$readint(s,length,dest,(i64)0);
    }
    else if ((fmtcode==(i64)68)) {
        qq_print$readint(s,length,dest,(i64)1);
    }
    else if ((fmtcode==(i64)82)) {
        qq_print$readreal(s,length,dest);
    }
    else if ((fmtcode==(i64)78)) {
        qq_print$readname(s,length,dest);
    }
    else if ((fmtcode==(i64)83)) {
        qq_print$readstring(s,length,dest);
    }
    else if ((fmtcode==(i64)72)) {
        qq_print$readhex(s,length,dest);
    }
    else if ((fmtcode==(i64)66)) {
        qq_print$readbin(s,length,dest);
    }
    else if ((fmtcode==(i64)65)) {
        qq_print$readany(s,length,dest);
    }
    else {
        qq_lib$prterror((byte*)"strval:fmt?");
    }
;
}

static void qq_print$tostr_int(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp=='M') || ($temp=='D')) {
        qq_print$domultichar((u8 *)&(*p).value,(i64)8,str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='C')) {
        str[((i64)0)] = (u64)(*p).value;
        str[((i64)1)] = (u64)0u;
    }
    else {
        msysc$i64tostrfmt((*p).value,str,(struct msysc$fmtrec *)fmt);
    }
    };
    if (!!(msysc$m_getdotindex((i64)(*fmt).spare,(i64)0))) {
        qq_print$addstring(dest,(byte*)"I:",(i64)2);
    }
;
    qq_print$addstring(dest,str,strlen(str));
}

static void qq_print$tostr_real(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
        u8 str2[1024];
        u8 cfmt[10];
        i64 n;
    if (!!((i64)(*fmt).precision)) {
        cfmt[((i64)1)-1] = '.';
        cfmt[((i64)2)-1] = '*';
        cfmt[((i64)3)-1] = (u64)(*fmt).realfmt;
        cfmt[((i64)4)-1] = (u64)0u;
        msysc$m_print_startstr(str);
        msysc$m_print_i64((i64)(*fmt).precision,(byte*)"v");
        msysc$m_print_r64((*p).xvalue,cfmt);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_r64((*p).xvalue,(byte*)"fmt");
        msysc$m_print_end();
        ;
    }
;
    n = strlen(str);
    if ((n < (i64)(*fmt).minwidth)) {
        msysc$expandstr(str,str2,n,(struct msysc$fmtrec *)fmt);
        strcpy(str,str2);
    }
;
    qq_print$addstring(dest,str,strlen(str));
}

static void qq_print$tostr_str(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        i64 oldlen;
        i64 newlen;
        u8 *  s;
        struct qq_decls$objrec *  q;
    q = (*p).objptr;
    oldlen = (*q).length;
    newlen = oldlen;
    if ((!!((u64)(*fmt).quotechar) || ((i64)(*fmt).minwidth > newlen))) {
        if (!!((u64)(*fmt).quotechar)) {
            newlen += (i64)2;
        }
;
        if (((i64)(*fmt).minwidth > newlen)) {
            newlen = (i64)(*fmt).minwidth;
        }
;
        s = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        msysc$strtostrfmt((*q).strptr,s,oldlen,(struct msysc$fmtrec *)fmt);
        qq_print$addstring(dest,s,newlen);
        mlib$pcm_free((void *)s,(newlen + (i64)1));
    }
    else {
        qq_print$addstring(dest,(*q).strptr,oldlen);
    }
;
}

void qq_print$pch_tostr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
        struct msysc$fmtrec fmt;
        struct msysc$fmtrec *  ifmt;
        struct qq_decls$objrec *  p;
    ifmt = (struct msysc$fmtrec *)qq_print$pc_getfmt(b,&fmt);
    p = qq_strings$obj_new_string((i64)0);
    qq_print$listdepth = (i64)0;
    qq_print$tostr(a,(struct msysc$fmtrec *)ifmt,p);
    (*result).tagx = (i64)265;
    (*result).objptr = p;
}

static void qq_print$tostr_range(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
    msysc$i64tostrfmt(msysc$m_getdotslice((*p).dummy,(i64)16,(i64)63),str,(struct msysc$fmtrec *)fmt);
    strcat(str,(byte*)"..");
    qq_print$addstring(dest,str,(i64)-1);
    msysc$i64tostrfmt((i64)(*p).range_upper,str,(struct msysc$fmtrec *)fmt);
    qq_print$addstring(dest,str,(i64)-1);
}

static void qq_print$tostr_array(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
        byte *  q;
        i64 i;
        i64 m;
        i64 elemtype;
        i64 a;
        i64 b;
        i64 lower;
        i64 length;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  pa;
    m = (i64)(*p).tag;
    pa = (*p).objptr;
    if (((i64)(*p).tag == (i64)11)) {
        length = (*pa).length;
        lower = (i64)msysc$m_getdotindex((i64)(*pa).flags,(i64)0);
        elemtype = (i64)(*pa).elemtag;
    }
    else {
        length = qq_tables$ttlength[((i64)(*pa).usertag)];
        lower = qq_tables$ttlower[((i64)(*pa).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*pa).usertag)];
    }
;
    a = lower;
    b = ((length + lower) - (i64)1);
    q = (*pa).ptr;
    if (!!(msysc$m_getdotindex((i64)(*fmt).spare,(i64)0))) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#[#:#]A");
        msysc$m_print_str(qq_tables$ttname[(m)],NULL);
        msysc$m_print_i64(lower,NULL);
        msysc$m_print_str(qq_tables$ttname[(elemtype)],NULL);
        msysc$m_print_end();
        ;
        qq_print$addstring(dest,str,(i64)-1);
    }
;
    qq_print$addstring(dest,(byte*)"(",(i64)-1);
    for (i=a;i<=b;++i) {
L615 :;
        qq_packed$var_loadpacked(q,elemtype,&v,0);
        q += qq_tables$ttsize[(elemtype)];
        qq_print$tostr(&v,(struct msysc$fmtrec *)fmt,dest);
        if ((i < b)) {
            qq_print$addstring(dest,(byte*)",",(i64)1);
        }
;
L616 :;
    }
L617 :;
    ;
    qq_print$addstring(dest,(byte*)")",(i64)1);
}

static void qq_print$tostr_bits(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
        byte *  q;
        i64 i;
        i64 m;
        i64 elemtype;
        i64 a;
        i64 b;
        i64 bitwidthx;
        i64 offset;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  pa;
    m = (i64)(*p).tag;
    pa = (*p).objptr;
    a = (i64)(*pa).lower16;
    elemtype = (i64)(*pa).elemtag;
    b = (((*pa).length + a) - (i64)1);
    bitwidthx = (i64)qq_tables$ttbitwidth[(elemtype)];
    offset = ((i64)(*pa).indexoffset * bitwidthx);
    q = (*pa).ptr;
    if (!!(msysc$m_getdotindex((i64)(*fmt).spare,(i64)0))) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#[#:#]A");
        msysc$m_print_str(qq_tables$ttname[(m)],NULL);
        msysc$m_print_i64((i64)(*pa).lower16,NULL);
        msysc$m_print_str(qq_tables$ttname[(elemtype)],NULL);
        msysc$m_print_end();
        ;
        qq_print$addstring(dest,str,(i64)-1);
    }
;
    qq_print$addstring(dest,(byte*)"(",(i64)-1);
    for (i=a;i<=b;++i) {
L618 :;
        qq_vars$var_loadbit(q,offset,elemtype,(i64)0,&v);
        offset += bitwidthx;
        if ((offset >= (i64)8)) {
            offset = (i64)0;
            ++(q);
        }
;
        qq_print$tostr(&v,(struct msysc$fmtrec *)fmt,dest);
        if ((i < b)) {
            qq_print$addstring(dest,(byte*)",",(i64)1);
        }
;
L619 :;
    }
L620 :;
    ;
    qq_print$addstring(dest,(byte*)")",(i64)1);
}

static void qq_print$tostr_struct(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        i64 i;
        i64 m;
        i64 nfields;
        i64 needcomma;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  pa;
        struct qq_decls$strec *  d;
        struct qq_decls$strec **  r;
    pa = (*p).objptr;
    m = (i64)(*pa).usertag;
    d = qq_tables$ttnamedef[(m)];
    r = (struct qq_decls$strec **)(*d).topfieldlist;
    nfields = qq_tables$ttlength[(m)];
    needcomma = (i64)0;
    qq_print$addstring(dest,(byte*)"(",(i64)-1);
    for (i=(i64)1;i<=nfields;++i) {
L621 :;
        qq_packed$var_loadpacked(((*pa).ptr + (i64)(*(*r)).fieldoffset),(i64)(*(*r)).mode,&v,0);
        if (!!(needcomma)) {
            qq_print$addstring(dest,(byte*)",",(i64)-1);
        }
;
        needcomma = (i64)1;
        qq_print$tostr(&v,(struct msysc$fmtrec *)fmt,dest);
        ++(r);
L622 :;
    }
L623 :;
    ;
    qq_print$addstring(dest,(byte*)")",(i64)-1);
}

static void qq_print$tostr_set(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        i64 i;
        i64 j;
        i64 first;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  s;
    if ((fmt == 0)) {
        fmt = (struct msysc$fmtrec *)&qq_print$defaultfmt;
    }
;
    qq_print$addstring(dest,(byte*)"[",(i64)1);
    s = (*p).objptr;
    first = (i64)1;
    i = (i64)0;
    L624 :;
    while ((i < (*s).length)) {
        if (!!(qq_lib$testelem((byte (*)[])(*s).ptr,i))) {
            j = (i + (i64)1);
            L627 :;
            while (((j < (*s).length) && !!(qq_lib$testelem((byte (*)[])(*s).ptr,j)))) {
                ++(j);
L628 :;
            }
L629 :;
            ;
            --(j);
            if (!(!!(first))) {
                qq_print$addstring(dest,(byte*)",",(i64)1);
            }
;
            first = (i64)0;
            if ((i == j)) {
                v.tagx = (i64)1;
                v.value = i;
            }
            else {
                v.tagx = (i64)4;
                v.dummy = msysc$m_setdotslice(v.dummy,(i64)16,(i64)63,i);
                v.range_upper = (u64)j;
            }
;
            qq_print$tostr(&v,(struct msysc$fmtrec *)fmt,dest);
            i = (j + (i64)1);
        }
        else {
            ++(i);
        }
;
L625 :;
    }
L626 :;
    ;
    qq_print$addstring(dest,(byte*)"]",(i64)1);
}

static void qq_print$tostr_dict(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        struct qq_decls$varrec *  q;
        i64 i;
        i64 length;
        i64 needcomma;
        struct qq_decls$objrec *  pa;
    needcomma = (i64)0;
    if ((fmt == 0)) {
        fmt = (struct msysc$fmtrec *)&qq_print$defaultfmt;
    }
;
    qq_print$addstring(dest,(byte*)"[",(i64)-1);
    pa = (*p).objptr;
    q = (*pa).varptr;
    length = ((*pa).length / (i64)2);
    for (i=length;i>=(i64)1;--i) {
L630 :;
        if (((i64)(*q).tag == (i64)0)) {
            q += (i64)2;
            goto L631 ;
        }
;
        if (!!(needcomma)) {
            qq_print$addstring(dest,(byte*)",",(i64)1);
        }
;
        needcomma = (i64)1;
        qq_print$tostr(q,(struct msysc$fmtrec *)fmt,dest);
        ++(q);
        qq_print$addstring(dest,(byte*)":",(i64)1);
        qq_print$tostr(q,(struct msysc$fmtrec *)fmt,dest);
        ++(q);
L631 :;
    }
L632 :;
    ;
    qq_print$addstring(dest,(byte*)"]",(i64)1);
}

static void qq_print$tostr_decimal(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 *  s;
    s = qq_decimal$var_tostr_dec(p,(i64)0);
    qq_print$addstring(dest,s,(i64)-1);
    mlib$pcm_free((void *)s,qq_decimal$decstrsize);
}

static void qq_print$tostr(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        qq_print$tostr_int(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)2)) {
        qq_print$tostr_real(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)9)) {
        qq_print$tostr_str(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)4)) {
        qq_print$tostr_range(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)10) || ($temp==(i64)12)) {
        qq_print$tostr_list(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)11) || ($temp==(i64)7)) {
        qq_print$tostr_array(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)8)) {
        qq_print$tostr_bits(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)5)) {
        qq_print$tostr_set(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)13)) {
        qq_print$tostr_struct(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)3)) {
        qq_print$tostr_decimal(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)6)) {
        qq_print$tostr_dict(p,(struct msysc$fmtrec *)fmt,dest);
    }
    else if (($temp==(i64)0)) {
        qq_print$addstring(dest,(byte*)"<Void>",(i64)-1);
    }
    else if (($temp==(i64)14)) {
        if (!!(msysc$m_getdotindex((i64)(*fmt).spare,(i64)0))) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"#<#>:");
            msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
            msysc$m_print_str((!!((*p).varptr) ? qq_tables$ttname[((i64)(*(*p).varptr).tag)] : (byte*)""),NULL);
            msysc$m_print_end();
            ;
            qq_print$addstring(dest,str,(i64)-1);
        }
;
        //showptr:
L633 :;
;
        if (((*p).varptr == 0)) {
            qq_print$addstring(dest,(byte*)"nil",(i64)-1);
        }
        else {
            qq_print$addstring(dest,msysc$strint((i64)(*p).varptr,(byte*)"H"),(i64)-1);
        }
;
    }
    else if (($temp==(i64)16)) {
        if (!!(msysc$m_getdotindex((i64)(*fmt).spare,(i64)0))) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"#<#>:");
            msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
            msysc$m_print_str((!!((*p).varptr) ? qq_tables$ttname[((i64)(*p).elemtag)] : (byte*)""),NULL);
            msysc$m_print_end();
            ;
            qq_print$addstring(dest,str,(i64)-1);
        }
;
        goto L633 ;
;
    }
    else if (($temp==(i64)15)) {
        if (!!(msysc$m_getdotindex((i64)(*fmt).spare,(i64)0))) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"#<#>(#,#):");
            msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
            msysc$m_print_str((!!((*p).varptr) ? qq_tables$ttname[((i64)(*p).elemtag)] : (byte*)""),NULL);
            msysc$m_print_i64((i64)(*p).bitoffset,NULL);
            msysc$m_print_i64((i64)(*p).bitlength,NULL);
            msysc$m_print_end();
            ;
            qq_print$addstring(dest,str,(i64)-1);
        }
;
        goto L633 ;
;
    }
    else if (($temp==(i64)17)) {
        if (!!((*p).def)) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"<#:\"#\">");
            msysc$m_print_str(qq_tables$namenames[((i64)(*(*p).def).nameid)],NULL);
            msysc$m_print_str((*(*p).def).name,NULL);
            msysc$m_print_end();
            ;
            qq_print$addstring(dest,str,(i64)-1);
        }
        else {
            qq_print$addstring(dest,(byte*)"<nil>",(i64)-1);
        }
;
    }
    else if (($temp==(i64)18)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#");
        msysc$m_print_str(qq_tables$ttname[((*p).value)],NULL);
        msysc$m_print_end();
        ;
        qq_print$addstring(dest,str,(i64)-1);
    }
    else if (($temp==(i64)19)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"(#)");
        msysc$m_print_str((qq_tables$pclnames[((*p).value)] + (i64)1),NULL);
        msysc$m_print_end();
        ;
        qq_print$addstring(dest,str,(i64)-1);
    }
    else {
        qq_lib$pcustype((byte*)"Tostr:",p);
    }
    };
}

static void qq_print$tostr_list(struct qq_decls$varrec *p,struct msysc$fmtrec *fmt,struct qq_decls$objrec *dest) {
        struct qq_decls$varrec *  q;
        i64 i;
        i64 n;
        struct qq_decls$objrec *  r;
        i64 $av_1;
    ++(qq_print$listdepth);
    r = (*p).objptr;
    if ((((i64)(*r).refcount < (i64)0) || (qq_print$listdepth > (i64)4))) {
        qq_print$addstring(dest,(byte*)"...",(i64)3);
        --(qq_print$listdepth);
        return;
    }
;
    (*r).refcount = -((i64)(*r).refcount);
    q = (*r).varptr;
    if (((i64)(*p).tag == (i64)10)) {
        n = (*(*p).objptr).length;
    }
    else {
        n = qq_tables$ttlength[((i64)(*r).usertag)];
    }
;
    if (!!(msysc$m_getdotindex((i64)(*fmt).spare,(i64)1))) {
        $av_1 = n;
        while ($av_1-- > 0) {
L634 :;
            qq_print$tostr(q,(struct msysc$fmtrec *)fmt,dest);
            qq_print$addstring(dest,(byte*)"\n",(i64)-1);
            ++(q);
L635 :;
        }
L636 :;
        ;
    }
    else {
        qq_print$addstring(dest,(byte*)"(",(i64)1);
        for (i=n;i>=(i64)1;--i) {
L637 :;
            qq_print$tostr(q,(struct msysc$fmtrec *)fmt,dest);
            ++(q);
            if ((i != (i64)1)) {
                qq_print$addstring(dest,(byte*)",",(i64)1);
            }
;
L638 :;
        }
L639 :;
        ;
        qq_print$addstring(dest,(byte*)")",(i64)1);
    }
;
    (*r).refcount = -((i64)(*r).refcount);
    --(qq_print$listdepth);
}

// START
void qq_print$start(void) {

}

void qq_pclgen$evalunit(struct qq_decls$unitrec *p,i64 res) {
        struct qq_decls$unitrec *  a;
        struct qq_decls$unitrec *  b;
        struct qq_decls$strec *  d;
        i64 procflag;
        i64 index;
    qq_decls$qpos = (i64)(*p).pos;
    a = (*p).a;
    b = (*p).b;
    switch ((i64)(*p).tag) {
    case 45:;
        {
            qq_pcllib$genpc_int((i64)19,(*p).value);
        }
        break;
    case 46:;
        {
            qq_pcllib$genpc_real((i64)22,(*p).xvalue);
        }
        break;
    case 0:;
        {
        }
        break;
    case 47:;
        {
            qq_pclgen$pushstring((*p).svalue,(i64)(*p).length);
        }
        break;
    case 43:;
        {
            d = (*p).def;
                        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)14)) {
                qq_pcllib$genpc_name((i64)10,(struct qq_decls$strec *)d);
            }
            else if (($temp==(i64)15)) {
                qq_pcllib$genpc_name((i64)10,(struct qq_decls$strec *)d);
                if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)5))) {
                    qq_pcllib$genpc((i64)28);
                }
;
            }
            else if (($temp==(i64)13)) {
                qq_pcllib$genpc_name((i64)9,(struct qq_decls$strec *)d);
            }
            else if (($temp==(i64)17)) {
                if (!(!!(res))) {
                    if (((*d).labelno == (i64)0)) {
                        (*d).labelno = qq_pcllib$createfwdlabel();
                    }
;
                    qq_pcllib$genpc_lab((i64)36,(*d).labelno);
                    return;
                }
                else {
                    qq_pcllib$genpc_name((i64)26,(struct qq_decls$strec *)d);
                }
;
            }
            else if (($temp==(i64)8)) {
                qq_pcllib$genpc_name((i64)17,(struct qq_decls$strec *)d);
            }
            else {
                qq_pcllib$genpc_name((i64)26,(struct qq_decls$strec *)d);
            }
            };
        }
        break;
    case 44:;
        {
            if (((i64)(*a).tag == (i64)43)) {
                qq_pcllib$genpc_name((i64)26,(struct qq_decls$strec *)(*a).def);
            }
            else {
                qq_lib$gerror((byte*)".$ name expected",0);
            }
;
        }
        break;
    case 7:;
        {
            if (!!(a)) {
                L640 :;
                while ((!!(a) && !!((*a).nextunit))) {
                    qq_pclgen$evalunit(a,(i64)0);
                    a = (*a).nextunit;
L641 :;
                }
L642 :;
                ;
                if (!!(a)) {
                    qq_pclgen$evalunit(a,res);
                }
;
            }
            else {
            }
;
        }
        break;
    case 71:;
        {
            qq_pclgen$pushstring((*p).svalue,(i64)(*p).length);
            qq_pcllib$genpc((i64)82);
        }
        break;
    case 30:;
        {
            qq_pclgen$do_call(p,a,b,res,&procflag);
        }
        break;
    case 36:;
        {
            qq_pclgen$do_return(p,a);
        }
        break;
    case 31:;
        {
            qq_pclgen$do_callhost(p,a,res);
        }
        break;
    case 2:;
        {
            qq_pclgen$do_assign(a,b,res,(i64)0);
        }
        break;
    case 3:;
        {
            qq_pclgen$do_assign(a,b,res,(i64)1);
        }
        break;
    case 24:;
        {
            qq_pclgen$do_to(p,a,b);
        }
        break;
    case 8:;
        {
            qq_pclgen$do_if(p,a,b,(*b).nextunit,res);
        }
        break;
    case 16:;
    case 18:;
        {
            qq_pclgen$do_for(p,a,b);
        }
        break;
    case 17:;
    case 19:;
        {
            qq_pclgen$do_forx(p,a,b);
        }
        break;
    case 20:;
    case 21:;
        {
            qq_pclgen$do_forall(p,a,b);
        }
        break;
    case 22:;
        {
            qq_pclgen$do_forall(p,a,b);
        }
        break;
    case 25:;
        {
            qq_pclgen$do_while(p,a,b);
        }
        break;
    case 26:;
        {
            qq_pclgen$do_repeat(p,a,b);
        }
        break;
    case 34:;
        {
            if ((((i64)(*a).tag == (i64)43) && ((i64)(*(*a).def).nameid == (i64)17))) {
                d = (*a).def;
                if (((*d).labelno == (i64)0)) {
                    (*d).labelno = qq_pcllib$createfwdlabel();
                }
;
                qq_pcllib$genpc_lab((i64)36,(*d).labelno);
            }
            else {
                qq_pclgen$evalunit(a,(i64)1);
                qq_pcllib$genpc((i64)37);
            }
;
        }
        break;
    case 1:;
        {
            d = (*a).def;
            if (((*d).labelno == (i64)0)) {
                (*d).labelno = qq_pcllib$definelabel();
            }
            else {
                index = (*d).labelno;
                qq_pcllib$definefwdlabel(&index);
            }
;
        }
        break;
    case 53:;
        {
            qq_pclgen$do_exit(p,(i64)1);
        }
        break;
    case 54:;
        {
            qq_pclgen$do_exit(p,(i64)2);
        }
        break;
    case 55:;
        {
            qq_pclgen$do_exit(p,(i64)3);
        }
        break;
    case 23:;
        {
            qq_pclgen$do_do(p,a);
        }
        break;
    case 11:;
    case 12:;
        {
            qq_pclgen$do_case(p,a,b,res);
        }
        break;
    case 13:;
    case 14:;
        {
            qq_pclgen$do_switch(p,a,b,res);
        }
        break;
    case 33:;
        {
            qq_pclgen$evalref(a);
            qq_pclgen$evalref(b);
            qq_pcllib$genpc((i64)34);
        }
        break;
    case 9:;
        {
            qq_pclgen$do_select(a,b,res);
        }
        break;
    case 60:;
    case 61:;
    case 64:;
        {
            qq_pclgen$do_print(p,a,b);
        }
        break;
    case 62:;
    case 63:;
    case 65:;
        {
            qq_pclgen$do_fprint(p,a,b,(*b).nextunit);
        }
        break;
    case 69:;
    case 70:;
        {
            qq_pclgen$do_read(p,a,b);
        }
        break;
    case 35:;
        {
            if (!!(a)) {
                qq_pclgen$evalunit(a,(i64)1);
            }
            else {
                qq_pcllib$genpc_int((i64)19,(i64)0);
            }
;
            qq_pcllib$genpc((i64)71);
        }
        break;
    case 27:;
        {
            qq_pclgen$do_try(p,a,b);
        }
        break;
    case 153:;
        {
            qq_pclgen$do_andl(a,b);
        }
        break;
    case 154:;
        {
            qq_pclgen$do_orl(a,b);
        }
        break;
    case 185:;
        {
            qq_pclgen$do_pushlist(a,(i64)(*p).length);
            qq_pcllib$genpc_int2((i64)73,(i64)(*p).length,(i64)(*p).lower);
        }
        break;
    case 186:;
        {
            qq_pclgen$do_pushlist(a,(i64)(*p).length);
            qq_pcllib$genpc_int((i64)78,(i64)(*p).length);
        }
        break;
    case 187:;
        {
            qq_pclgen$do_makedict(a,(i64)(*p).length);
        }
        break;
    case 5:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
        }
        break;
    case 41:;
        {
            qq_pclgen$do_map(p,a,b);
        }
        break;
    case 137:;
    case 138:;
    case 139:;
    case 140:;
    case 143:;
    case 144:;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
    case 161:;
    case 162:;
    case 183:;
    case 184:;
    case 155:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    case 160:;
    case 165:;
    case 163:;
    case 164:;
    case 134:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
            qq_pcllib$genpc((i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
        }
        break;
    case 167:;
    case 168:;
    case 169:;
    case 170:;
    case 171:;
    case 174:;
    case 175:;
    case 176:;
    case 177:;
    case 178:;
    case 179:;
    case 180:;
    case 181:;
    case 182:;
    case 172:;
    case 173:;
        {
            qq_pclgen$evalref(a);
            qq_pclgen$evalunit(b,(i64)1);
            qq_pcllib$genpc((i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
        }
        break;
    case 141:;
        {
            qq_pclgen$do_idiv(p,a,b);
        }
        break;
    case 142:;
        {
            qq_pclgen$do_irem(p,a,b);
        }
        break;
    case 78:;
    case 79:;
    case 107:;
    case 108:;
    case 106:;
    case 109:;
    case 80:;
    case 81:;
    case 129:;
    case 121:;
    case 122:;
    case 112:;
    case 133:;
    case 96:;
    case 132:;
    case 113:;
    case 111:;
    case 82:;
    case 86:;
    case 85:;
    case 126:;
    case 83:;
    case 84:;
    case 123:;
    case 131:;
    case 115:;
    case 116:;
    case 114:;
    case 128:;
    case 124:;
    case 127:;
    case 97:;
    case 98:;
    case 110:;
    case 125:;
    case 130:;
    case 101:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    case 91:;
    case 92:;
    case 95:;
    case 93:;
    case 94:;
    case 119:;
    case 120:;
    case 117:;
    case 135:;
    case 136:;
    case 118:;
        {
            qq_pclgen$do_unary(a,(i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
        }
        break;
    case 102:;
    case 103:;
    case 105:;
    case 104:;
        {
            qq_pclgen$evalref(a);
            qq_pcllib$genpc((i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
        }
        break;
    case 49:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pcllib$genpc_name((i64)199,(struct qq_decls$strec *)(*b).def);
        }
        break;
    case 50:;
        {
            qq_pclgen$do_bin(a,b,(i64)200);
        }
        break;
    case 51:;
        {
            qq_pclgen$do_bin(a,b,(i64)201);
        }
        break;
    case 52:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
            if (!!((*b).nextunit)) {
                qq_pclgen$evalunit((*b).nextunit,(i64)1);
            }
            else {
                qq_pcllib$genpc((i64)20);
            }
;
            qq_pcllib$genpc((i64)202);
        }
        break;
    case 56:;
        {
            qq_pclgen$do_unary(a,(i64)28);
        }
        break;
    case 58:;
        {
            if (((i64)(*a).tag == (i64)56)) {
                qq_pclgen$evalunit((*a).a,(i64)1);
            }
            else {
                qq_pclgen$evalref(a);
            }
;
        }
        break;
    case 57:;
        {
            qq_pclgen$evalref(a);
            qq_pcllib$genpc((i64)35);
        }
        break;
    case 39:;
        {
            qq_pclgen$do_convert(p);
        }
        break;
    case 40:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pcllib$genpc_int((i64)153,(i64)(*p).mode);
        }
        break;
    case 37:;
        {
            qq_pcllib$genpc_int((i64)25,(i64)(*p).mode);
        }
        break;
    case 6:;
        {
            qq_pcllib$genpc_int((i64)27,(*p).pclopcode);
        }
        break;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
        {
            qq_pclgen$do_incr(p,a,res);
        }
        break;
    case 32:;
        {
            qq_pcllib$genpc((i64)21);
        }
        break;
    case 29:;
        {
            qq_pclgen$do_unary(a,(i64)213);
        }
        break;
    case 59:;
        {
            qq_pcllib$genpc((i64)20);
        }
        break;
    default: {
        qq_lib$gerror_s((byte*)"UNSUPPORTED TAG:",qq_tables$jtagnames[((i64)(*p).tag)],p);
    }
    } //SW
;
        {i64 $temp = (i64)qq_tables$jhasvalue[((i64)(*p).tag)];
if (($temp==(i64)0)) {
        if (!!(res)) {
            qq_lib$gerror_s((byte*)"Value expected:",qq_tables$jtagnames[((i64)(*p).tag)],0);
        }
;
    }
    else if (($temp==(i64)1)) {
        if (!(!!(res))) {
            if ((((i64)(*p).tag == (i64)30) && (procflag == (i64)1))) {
            }
            else if (((i64)(*p).tag == (i64)74 || (i64)(*p).tag == (i64)75 || (i64)(*p).tag == (i64)76 || (i64)(*p).tag == (i64)77)) {
            }
            else if ((((i64)(*p).tag == (i64)31) && ((i64)qq_tables$hostisfn[((*p).index)] == (i64)0))) {
            }
            else {
                qq_pcllib$genpc_int((i64)69,(i64)1);
            }
;
        }
;
    }
    };
}

void qq_pclgen$gencodemodule(struct qq_decls$subprogrec *sp,i64 moduleno) {
        struct qq_decls$strec *  anonprocs[100];
        i64 nanonprocs;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        i64 lab;
        i64 a;
        i64 b;
        struct qq_decls$filerec *  pm;
        i64 $av_1;
        i64 $av_2;
        i64 i;
    nanonprocs = (i64)0;
    a = (i64)(*sp).firstmodule;
    b = (i64)(*sp).lastmodule;
    pm = qq_decls$modules[(moduleno)];
    qq_decls$currmodule = pm;
    qq_decls$stcurrproc = (qq_decls$stcurrmodule = (*qq_decls$currmodule).def);
    qq_pcllib$resetpcl((*pm).size);
    qq_pcllib$gencomment((byte*)"Module data init code:");
    qq_decls$qpos = (i64)0;
    qq_decls$qpos = msysc$m_setdotslice(qq_decls$qpos,(i64)24,(i64)31,(u64)moduleno);
    if ((moduleno == a)) {
        lab = qq_pcllib$createfwdlabel();
        qq_pcllib$genpc_lab((i64)36,lab);
        qq_pcllib$genpc((i64)72);
        qq_decls$stopseq = qq_pcllib$pcllast;
        qq_decls$raiseseq = (qq_pcllib$pcllast + (i64)1);
        qq_pcllib$genpc_int((i64)19,(i64)0);
        qq_pcllib$genpc((i64)213);
        qq_pcllib$definefwdlabel(&lab);
    }
;
    d = (*qq_decls$stcurrmodule).deflist;
    L643 :;
    while (!!(d)) {
        if ((((i64)(*d).nameid == (i64)13) && !!((*d).code))) {
            qq_pclgen$evalunit((*d).code,(i64)1);
            if (((i64)msysc$m_getdotslice((i64)(*d).flags,(i64)11,(i64)12) == (i64)3)) {
                qq_pcllib$genpc((i64)33);
            }
;
            qq_pcllib$genpc_name((i64)30,(struct qq_decls$strec *)d);
        }
        else if (((i64)(*d).nameid == (i64)5)) {
            e = (*d).deflist;
            L646 :;
            while (!!(e)) {
                if ((((i64)(*e).nameid == (i64)13) && !!((*e).code))) {
                    qq_pclgen$evalunit((*e).code,(i64)1);
                    qq_pcllib$genpc_name((i64)30,(struct qq_decls$strec *)e);
                }
                else if (((i64)(*e).nameid == (i64)6)) {
                    if ((nanonprocs >= (i64)100)) {
                        qq_lib$gerror((byte*)"Too many anons",0);
                    }
;
                    anonprocs[(++(nanonprocs))-1] = e;
                }
;
                e = (*e).nextdef;
L647 :;
            }
L648 :;
            ;
        }
;
        d = (*d).nextdef;
L644 :;
    }
L645 :;
    ;
    if ((moduleno == a)) {
                ($av_1 = (a + (i64)1));
        for (i=b;i>=$av_1;--i) {
L649 :;
            qq_pcllib$genpc_name((i64)65,(struct qq_decls$strec *)(*qq_decls$modules[(i)]).def);
L650 :;
        }
L651 :;
        ;
                ($av_2 = (a + (i64)1));
        for (i=b;i>=$av_2;--i) {
L652 :;
            if (!!((*qq_decls$modules[(i)]).startfn)) {
                qq_pcllib$genpc_name((i64)60,(struct qq_decls$strec *)(*qq_decls$modules[(i)]).startfn);
                qq_pcllib$genopnd_int((i64)0);
            }
;
L653 :;
        }
L654 :;
        ;
        if (!!((*qq_decls$currmodule).startfn)) {
            qq_pcllib$genpc_name((i64)60,(struct qq_decls$strec *)(*qq_decls$currmodule).startfn);
            qq_pcllib$genopnd_int((i64)0);
        }
;
        if (!!((*qq_decls$currmodule).mainfn)) {
            qq_pcllib$genpc_name((i64)60,(struct qq_decls$strec *)(*qq_decls$currmodule).mainfn);
            qq_pcllib$genopnd_int((i64)0);
        }
;
        qq_pclgen$evalunit((*qq_decls$stcurrmodule).code,(i64)0);
        qq_pcllib$genpc_int((i64)19,(i64)0);
        qq_pcllib$genpc((i64)71);
    }
    else {
        qq_pclgen$evalunit((*qq_decls$stcurrmodule).code,(i64)0);
        qq_pcllib$genpc((i64)66);
    }
;
    qq_pcllib$gencomment((byte*)"Procs:");
    d = (*qq_decls$stcurrmodule).deflist;
    L655 :;
    while (!!(d)) {
        switch ((i64)(*d).nameid) {
        case 5:;
        case 6:;
            {
                qq_pclgen$do_procdef(d);
            }
            break;
        case 13:;
            {
            }
            break;
        case 9:;
            {
                e = (*d).deflist;
                L658 :;
                while (!!(e)) {
                    if (((i64)(*e).nameid == (i64)5)) {
                        qq_pclgen$do_procdef(e);
                    }
;
L659 :;
                    e = (*e).nextdef;
L661 :;
                                    }
L660 :;
                ;
            }
            break;
        case 18:;
            {
            }
            break;
        case 19:;
            {
            }
            break;
        case 17:;
            {
            }
            break;
        case 10:;
            {
            }
            break;
        case 7:;
            {
            }
            break;
        case 20:;
            {
            }
            break;
        case 22:;
            {
            }
            break;
        case 8:;
            {
            }
            break;
        default: {
            qq_lib$gerror_s((byte*)"?Module def:",qq_tables$namenames[((i64)(*d).nameid)],0);
        }
        } //SW
;
        d = (*d).nextdef;
L656 :;
    }
L657 :;
    ;
    for (i=(i64)1;i<=nanonprocs;++i) {
L662 :;
        qq_pclgen$do_procdef(anonprocs[(i)-1]);
L663 :;
    }
L664 :;
    ;
    qq_pcllib$genpc((i64)6);
    //finish:
L665 :;
;
    (*pm).pcstart = qq_pcllib$pclstart;
    (*pm).pcend = qq_pcllib$pclend;
    (*pm).pcsize = (qq_pcllib$pclend - qq_pcllib$pclstart);
    (*pm).pcsrcstart = qq_pcllib$pclsrcstart;
}

static void qq_pclgen$do_procdef(struct qq_decls$strec *p) {
        i64 nfreevars;
        i64 nnofreevars;
        i64 isfunc;
        struct qq_decls$strec *  oldcurrproc;
    oldcurrproc = qq_decls$stcurrproc;
    qq_decls$stcurrproc = p;
    qq_pclgen$retindex = qq_pcllib$createfwdlabel();
    isfunc = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)4);
    qq_pclgen$genprocentry(p,&nfreevars,&nnofreevars);
    if (((*p).code == 0)) {
        qq_lib$gerror_s((byte*)"Empty proc body",(*p).name,0);
    }
    else {
        qq_pclgen$evalunit((*p).code,isfunc);
    }
;
    qq_pcllib$definefwdlabel(&qq_pclgen$retindex);
    qq_pclgen$genprocexit(nfreevars,nnofreevars,isfunc);
    qq_pcllib$genpc((i64)5);
    if (((*qq_pclgen$pproclocals) == (i64)0)) {
        (*p).labelno = qq_pclgen$procskiplabel;
    }
;
    qq_decls$stcurrproc = oldcurrproc;
}

static void qq_pclgen$genprocentry(struct qq_decls$strec *p,i64 *nfreevars,i64 *nnofreevars) {
        i64 n;
        struct qq_decls$strec *  d;
    qq_pcllib$genpc_name((i64)3,(struct qq_decls$strec *)p);
    qq_pclgen$nprocparams = (qq_pclgen$nproclocals = (i64)0);
    d = (*p).deflist;
    L666 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)14)) {
            ++(qq_pclgen$nproclocals);
            (*d).index = qq_pclgen$nproclocals;
        }
        else if (($temp==(i64)15)) {
            ++(qq_pclgen$nprocparams);
        }
        };
        d = (*d).nextdef;
L667 :;
    }
L668 :;
    ;
    d = (*p).deflist;
    n = qq_pclgen$nprocparams;
    L669 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)15)) {
            --(n);
            (*d).index = -((n + (i64)1));
        }
        };
L670 :;
        d = (*d).nextdef;
L672 :;
            }
L671 :;
    ;
    qq_pclgen$retvaloffset = -((qq_pclgen$nprocparams + (i64)1));
    (*p).labelno = qq_pcllib$definelabel();
    qq_pcllib$genpc_int((i64)4,qq_pclgen$nproclocals);
    qq_pclgen$procskiplabel = qq_pcllib$definelabel();
    qq_pclgen$pproclocals = (qq_pcllib$pclnext - (i64)1);
    d = (*p).deflist;
    L673 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)14)) {
            if (!!((*d).code)) {
                qq_pclgen$evalunit((*d).code,(i64)1);
                if (((i64)msysc$m_getdotslice((i64)(*d).flags,(i64)11,(i64)12) == (i64)3)) {
                    qq_pcllib$genpc((i64)33);
                }
;
                qq_pcllib$genpc_name((i64)31,(struct qq_decls$strec *)d);
            }
;
        }
        };
        d = (*d).nextdef;
L674 :;
    }
L675 :;
    ;
}

static void qq_pclgen$genprocexit(i64 nfree,i64 nnofree,i64 isfunc) {
        i64 offset;
    if (!!(isfunc)) {
        offset = (-((qq_pclgen$nprocparams + (i64)1)) * (i64)16);
        qq_pcllib$genpc_int((i64)64,offset);
    }
;
    if (!!(qq_pclgen$nproclocals)) {
        qq_pcllib$genpc_int((i64)69,qq_pclgen$nproclocals);
    }
;
    if ((qq_pclgen$nprocparams == (i64)0)) {
        qq_pcllib$genpc((i64)62);
    }
    else {
        qq_pcllib$genpc_int((i64)63,qq_pclgen$nprocparams);
    }
;
}

static void qq_pclgen$evalref(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  a;
        struct qq_decls$unitrec *  b;
        struct qq_decls$strec *  d;
        i64 lab1;
        i64 lab2;
    a = (*p).a;
    b = (*p).b;
    switch ((i64)(*p).tag) {
    case 43:;
        {
            d = (*p).def;
            if (((i64)(*d).nameid == (i64)5 || (i64)(*d).nameid == (i64)7)) {
                qq_lib$gerror((byte*)"^ not allowed",0);
            }
;
            if ((((i64)(*d).nameid == (i64)15) && !!(msysc$m_getdotindex((i64)(*d).flags,(i64)5)))) {
                qq_pcllib$genpc_name((i64)10,(struct qq_decls$strec *)d);
            }
            else {
                qq_pcllib$genpc_name(((i64)11 + (i64)msysc$m_getdotindex((i64)(*d).flags,(i64)9)),(struct qq_decls$strec *)d);
            }
;
        }
        break;
    case 49:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pcllib$genpc_name((i64)203,(struct qq_decls$strec *)(*b).def);
        }
        break;
    case 50:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
            qq_pcllib$genpc((i64)204);
        }
        break;
    case 51:;
        {
            qq_pclgen$evalref(a);
            qq_pclgen$evalunit(b,(i64)1);
            qq_pcllib$genpc((i64)205);
        }
        break;
    case 52:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
            if (!!((*b).nextunit)) {
                qq_lib$gerror((byte*)"Def val not allowed",0);
            }
;
            qq_pcllib$genpc((i64)206);
        }
        break;
    case 56:;
        {
            qq_pclgen$evalunit(a,(i64)1);
        }
        break;
    case 8:;
        {
            lab1 = qq_pcllib$createfwdlabel();
            lab2 = qq_pcllib$createfwdlabel();
            qq_pclgen$genjumpcond((i64)0,(*p).a,lab1);
            qq_pclgen$evalref((*p).b);
            qq_pclgen$genjumpl(lab2);
            qq_pcllib$definefwdlabel(&lab1);
            qq_pclgen$evalref((*(*p).b).nextunit);
            qq_pcllib$definefwdlabel(&lab2);
        }
        break;
    default: {
        qq_lib$gerror_s((byte*)"evalref",qq_tables$jtagnames[((i64)(*p).tag)],0);
    }
    } //SW
;
}

static void qq_pclgen$genjumpcond(i64 opc,struct qq_decls$unitrec *p,i64 lab) {
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 oldpos;
        i64 lab2;
        i64 i;
    q = (*p).a;
    r = (*p).b;
    switch ((i64)(*p).tag) {
    case 153:;
        {
            if ((opc==(i64)0)) {
                qq_pclgen$genjumpcond((i64)0,q,lab);
                qq_pclgen$genjumpcond((i64)0,r,lab);
            }
            else if ((opc==(i64)1)) {
                lab2 = qq_pcllib$createfwdlabel();
                qq_pclgen$genjumpcond((i64)0,q,lab2);
                qq_pclgen$genjumpcond((i64)1,r,lab);
                qq_pcllib$definefwdlabel(&lab2);
            }
;
        }
        break;
    case 154:;
        {
            if ((opc==(i64)0)) {
                lab2 = qq_pcllib$createfwdlabel();
                qq_pclgen$genjumpcond((i64)1,q,lab2);
                qq_pclgen$genjumpcond((i64)0,r,lab);
                qq_pcllib$definefwdlabel(&lab2);
            }
            else if ((opc==(i64)1)) {
                qq_pclgen$genjumpcond((i64)1,q,lab);
                qq_pclgen$genjumpcond((i64)1,r,lab);
            }
;
        }
        break;
    case 80:;
        {
            if ((opc==(i64)0)) {
                qq_pclgen$genjumpcond((i64)1,q,lab);
            }
            else if ((opc==(i64)1)) {
                qq_pclgen$genjumpcond((i64)0,q,lab);
            }
;
        }
        break;
    case 82:;
        {
            qq_pclgen$genjumpcond(opc,q,lab);
        }
        break;
    case 7:;
        {
            L676 :;
            while ((!!(q) && !!((*q).nextunit))) {
                qq_pclgen$evalunit(q,(i64)1);
                q = (*q).nextunit;
L677 :;
            }
L678 :;
            ;
            qq_pclgen$genjumpcond(opc,q,lab);
        }
        break;
    case 155:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    case 160:;
        {
            qq_pclgen$evalunit(q,(i64)1);
            qq_pclgen$evalunit(r,(i64)1);
            qq_pclgen$gcomparejump(opc,(i64)(*p).tag,lab);
        }
        break;
    case 42:;
        {
            r = (*q).nextunit;
            i = (i64)1;
            if ((opc == (i64)0)) {
                L679 :;
                while (!!(r)) {
                    qq_pclgen$evalunit(q,(i64)1);
                    qq_pclgen$evalunit(r,(i64)1);
                    qq_pclgen$gcomparejump((i64)1,qq_pclgen$reversecond((i64)(*p).cmpgenop[(i)-1]),lab);
                    ++(i);
                    q = r;
                    r = (*r).nextunit;
L680 :;
                }
L681 :;
                ;
            }
            else {
                lab2 = qq_pcllib$createfwdlabel();
                L682 :;
                while (!!(r)) {
                    qq_pclgen$evalunit(q,(i64)1);
                    qq_pclgen$evalunit(r,(i64)1);
                    if (!!((*r).nextunit)) {
                        qq_pclgen$gcomparejump((i64)1,qq_pclgen$reversecond((i64)(*p).cmpgenop[(i)-1]),lab2);
                    }
                    else {
                        qq_pclgen$gcomparejump((i64)1,(i64)(*p).cmpgenop[(i)-1],lab);
                    }
;
                    ++(i);
                    q = r;
                    r = (*r).nextunit;
L683 :;
                }
L684 :;
                ;
                qq_pcllib$definefwdlabel(&lab2);
            }
;
        }
        break;
    default: {
        qq_pclgen$evalunit(p,(i64)1);
        qq_pcllib$genpc_lab(((opc == (i64)1) ? (i64)38 : (i64)39),lab);
    }
    } //SW
;
    qq_decls$qpos = oldpos;
}

static void qq_pclgen$gcomparejump(i64 jumpopc,i64 cond,i64 lab) {
        i64 opc;
    if ((jumpopc == (i64)0)) {
        cond = qq_pclgen$reversecond(cond);
    }
;
    if ((cond==(i64)155)) {
        opc = (i64)40;
    }
    else if ((cond==(i64)156)) {
        opc = (i64)41;
    }
    else if ((cond==(i64)157)) {
        opc = (i64)42;
    }
    else if ((cond==(i64)158)) {
        opc = (i64)43;
    }
    else if ((cond==(i64)159)) {
        opc = (i64)44;
    }
    else if ((cond==(i64)160)) {
        opc = (i64)45;
    }
    else {
        qq_lib$gerror((byte*)"GCOMP: no cond",0);
    }
;
    qq_pcllib$genpc_lab(opc,lab);
}

static void qq_pclgen$genjumpl(i64 lab) {
    qq_pcllib$genpc_lab((i64)36,lab);
}

static i64 qq_pclgen$reversecond(i64 op) {
    if ((op==(i64)155)) {
        return (i64)156;
    }
    else if ((op==(i64)156)) {
        return (i64)155;
    }
    else if ((op==(i64)157)) {
        return (i64)159;
    }
    else if ((op==(i64)158)) {
        return (i64)160;
    }
    else if ((op==(i64)159)) {
        return (i64)157;
    }
    else if ((op==(i64)160)) {
        return (i64)158;
    }
;
    return (i64)0;
}

void qq_pclgen$stacklooplabels(i64 *a,i64 *b,i64 *c) {
    if ((qq_pclgen$loopindex >= (i64)20)) {
        qq_lib$gerror((byte*)"Too many nested loops",0);
    }
;
    ++(qq_pclgen$loopindex);
    qq_pclgen$loopstack[(qq_pclgen$loopindex)-1][((i64)1)-1] = a;
    qq_pclgen$loopstack[(qq_pclgen$loopindex)-1][((i64)2)-1] = b;
    qq_pclgen$loopstack[(qq_pclgen$loopindex)-1][((i64)3)-1] = c;
}

void qq_pclgen$unstacklooplabels(void) {
    --(qq_pclgen$loopindex);
}

i64 qq_pclgen$findlooplabel(i64 k,i64 n) {
        i64 i;
    if ((n == (i64)0)) {
        i = (i64)1;
    }
    else {
        i = (qq_pclgen$loopindex - (n - (i64)1));
    }
;
    if (((i < (i64)1) || (i > qq_pclgen$loopindex))) {
        qq_lib$gerror((byte*)"Bad loop index",0);
    }
;
    qq_pclgen$looptrylevel = qq_pclgen$trylevelstack[(i)-1];
    return (*qq_pclgen$loopstack[(i)-1][(k)-1]);
}

static void qq_pclgen$do_assign(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 res,i64 deepcopy) {
    if (((i64)(*a).tag==(i64)(*b).tag && (i64)(*b).tag==(i64)185)) {
        if (!!(res)) {
            qq_lib$gerror((byte*)"mult/ass::=",0);
        }
;
        qq_pclgen$do_multassign(a,b,deepcopy,res);
        return;
    }
;
    qq_pclgen$evalunit(b,(i64)1);
    if (!!(deepcopy)) {
        qq_pcllib$genpc((i64)33);
    }
;
    qq_pclgen$do_store(a,res);
}

static void qq_pclgen$do_bin(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 opc) {
    qq_pclgen$evalunit(a,(i64)1);
    qq_pclgen$evalunit(b,(i64)1);
    qq_pcllib$genpc(opc);
}

static void qq_pclgen$do_binref(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 opc) {
    qq_pclgen$evalref(a);
    qq_pclgen$evalunit(b,(i64)1);
    qq_pcllib$genpc(opc);
}

static void qq_pclgen$do_unary(struct qq_decls$unitrec *a,i64 opc) {
    qq_pclgen$evalunit(a,(i64)1);
    qq_pcllib$genpc(opc);
}

static void qq_pclgen$do_unaryref(struct qq_decls$unitrec *a,i64 opc) {
    qq_pclgen$evalref(a);
    qq_pcllib$genpc(opc);
}

static void qq_pclgen$do_pushlist(struct qq_decls$unitrec *a,i64 n) {
    L685 :;
    while (!!(a)) {
        qq_pclgen$evalunit(a,(i64)1);
L686 :;
        a = (*a).nextunit;
L688 :;
            }
L687 :;
    ;
}

static void qq_pclgen$do_makedict(struct qq_decls$unitrec *a,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L689 :;
        if (((i64)(*a).tag == (i64)5)) {
            qq_pclgen$evalunit((*a).a,(i64)1);
            qq_pclgen$evalunit((*a).b,(i64)1);
        }
        else {
            qq_lib$gerror((byte*)"dict not key:val",0);
        }
;
        a = (*a).nextunit;
L690 :;
    }
L691 :;
    ;
    qq_pcllib$genpc_int((i64)81,n);
}

static void qq_pclgen$do_call(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 res,i64 *procflag) {
        i64 nargs;
        i64 nsimple;
        i64 isfunc;
        i64 kwdindex;
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  c;
        struct qq_decls$unitrec *  arglist[100];
        i64 i;
    isfunc = (i64)1;
    nargs = (nsimple = (i64)0);
    kwdindex = (i64)0;
    c = b;
    L692 :;
    while (!!(c)) {
        arglist[(++(nargs))-1] = c;
        if (((i64)(*c).tag == (i64)45 || (i64)(*c).tag == (i64)46)) {
            ++(nsimple);
        }
;
        if (((i64)(*c).tag == (i64)4)) {
            if ((kwdindex == (i64)0)) {
                kwdindex = nargs;
            }
;
        }
        else if (!!(kwdindex)) {
            qq_lib$gerror((byte*)"Non-kwd follows kwd arg",0);
        }
;
        c = (*c).nextunit;
L693 :;
    }
L694 :;
    ;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)43)) {
        d = (*a).def;
        //retry:
L695 :;
;
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)5) || ($temp==(i64)6)) {
            if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)4))) {
                qq_pcllib$genpc((i64)20);
                nargs = qq_pclgen$pushparams(d,&arglist,nargs,kwdindex);
                qq_pcllib$genpc_name((i64)60,(struct qq_decls$strec *)d);
            }
            else {
                isfunc = (i64)0;
                nargs = qq_pclgen$pushparams(d,&arglist,nargs,kwdindex);
                qq_pcllib$genpc_name((i64)60,(struct qq_decls$strec *)d);
            }
;
            qq_pcllib$genopnd_int(nargs);
        }
        else if (($temp==(i64)7)) {
            if (!(!!(msysc$m_getdotindex((i64)(*d).flags,(i64)4)))) {
                isfunc = (i64)0;
            }
            else {
                qq_pcllib$genpc((i64)20);
            }
;
            nargs = qq_pclgen$pushparams(d,&arglist,nargs,kwdindex);
            qq_pcllib$genpc_name((i64)67,(struct qq_decls$strec *)d);
            qq_pcllib$genopnd_int(nargs);
        }
        else if (($temp==(i64)20)) {
            d = (*d).alias;
            goto L695 ;
;
        }
        else if (($temp==(i64)13) || ($temp==(i64)14) || ($temp==(i64)15)) {
            goto L696 ;
;
        }
        else {
            qq_lib$gerror_s((byte*)"CAN'T CALL:",qq_tables$namenames[((i64)(*d).nameid)],0);
        }
        };
    }
    else if (($temp==(i64)49)) {
        if (!!(kwdindex)) {
            goto L696 ;
;
        }
;
        qq_pcllib$genpc((i64)20);
        qq_pclgen$evalref((*a).a);
        for (i=(i64)1;i<=nargs;++i) {
L697 :;
            qq_pclgen$evalunit(arglist[(i)-1],(i64)1);
L698 :;
        }
L699 :;
        ;
        qq_pclgen$evalunit(a,(i64)1);
        qq_pcllib$genpc((i64)61);
        ++(nargs);
        qq_pcllib$genopnd_int(nargs);
        qq_pcllib$genopnd_int((i64)0);
    }
    else {
        //docallptr:
L696 :;
;
        if (!!(kwdindex)) {
            qq_lib$gerror((byte*)"Kwd params not allowed for fnptr",0);
        }
;
        qq_pcllib$genpc((i64)20);
        for (i=(i64)1;i<=nargs;++i) {
L700 :;
            qq_pclgen$evalunit(arglist[(i)-1],(i64)1);
L701 :;
        }
L702 :;
        ;
        qq_pclgen$evalunit(a,(i64)1);
        qq_pcllib$genpc((i64)61);
        qq_pcllib$genopnd_int(nargs);
        qq_pcllib$genopnd_int((i64)0);
    }
    };
    if ((!!(res) && !(!!(isfunc)))) {
        qq_lib$gerror((byte*)"Func ret value expected",0);
    }
;
    (*procflag) = (i64)!(!!(isfunc));
}

static i64 qq_pclgen$pushparams(struct qq_decls$strec *d,struct qq_decls$unitrec *(*arglist)[],i64 nargs,i64 kwdindex) {
        i64 nparams;
        i64 extra;
        i64 n;
        struct qq_decls$strec *  paramlist[100];
        byte byreflist[100];
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  p;
        i64 i;
    nparams = (i64)(*d).nparams;
    e = (*d).deflist;
    n = (i64)0;
    L703 :;
    while (!!(e)) {
        ++(n);
        paramlist[(n)-1] = e;
        byreflist[(n)-1] = (i64)msysc$m_getdotindex((i64)(*e).flags,(i64)5);
        e = (*e).nextdef;
L704 :;
    }
L705 :;
    ;
    if (!!(kwdindex)) {
        qq_pclgen$pushkwdparams(d,arglist,nargs,kwdindex);
        return (i64)(*d).nparams;
    }
;
    extra = (i64)0;
    if ((nargs == nparams)) {
        for (i=(i64)1;i<=nargs;++i) {
L706 :;
            qq_pclgen$evalparam((*arglist)[(i)-1],(i64)byreflist[(i)-1]);
L707 :;
        }
L708 :;
        ;
        return nargs;
    }
    else if ((nargs < nparams)) {
        for (i=(i64)1;i<=nargs;++i) {
L709 :;
            qq_pclgen$evalparam((*arglist)[(i)-1],(i64)byreflist[(i)-1]);
L710 :;
        }
L711 :;
        ;
        for (i=(nargs + (i64)1);i<=nparams;++i) {
L712 :;
            p = paramlist[(i)-1];
            if ((!(!!((*p).code)) && !(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)7))))) {
                qq_lib$gerror_s((byte*)"Param not optional:",msysc$strint(i,0),0);
            }
;
            if (!!((*p).code)) {
                if (!!((i64)byreflist[(i)-1])) {
                    qq_lib$gerror((byte*)"byref with default val",0);
                }
;
                qq_pclgen$evalunit((*p).code,(i64)1);
            }
            else {
                qq_pcllib$genpc((i64)20);
            }
;
L713 :;
        }
L714 :;
        ;
        return nparams;
    }
    else {
        for (i=(i64)1;i<=nparams;++i) {
L715 :;
            qq_pclgen$evalparam((*arglist)[(i)-1],(i64)byreflist[(i)-1]);
L716 :;
        }
L717 :;
        ;
        if (!(!!(msysc$m_getdotindex((i64)(*d).flags,(i64)8)))) {
            qq_lib$gerror((byte*)"Too many args",0);
        }
;
        for (i=(nparams + (i64)1);i<=nargs;++i) {
L718 :;
            qq_pclgen$evalunit((*arglist)[(i)-1],(i64)1);
L719 :;
        }
L720 :;
        ;
        return nargs;
    }
;
}

static void qq_pclgen$evalparam(struct qq_decls$unitrec *a,i64 byref) {
    if (!!(byref)) {
        qq_pclgen$evalref(a);
    }
    else {
        qq_pclgen$evalunit(a,(i64)1);
    }
;
}

static void qq_pclgen$pushkwdparams(struct qq_decls$strec *d,struct qq_decls$unitrec *(*arglist)[],i64 nargs,i64 kwdindex) {
        i64 nparams;
        i64 i;
        i64 j;
        i64 k;
        struct qq_decls$strec *  paramlist[100];
        byte byreflist[100];
        struct qq_decls$unitrec *  keyunits[100];
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$strec *  e;
        i64 $av_1;
    nparams = (i64)(*d).nparams;
    e = (*d).deflist;
    for (i=(i64)1;i<=nparams;++i) {
L721 :;
        paramlist[(i)-1] = e;
        byreflist[(i)-1] = (i64)msysc$m_getdotindex((i64)(*e).flags,(i64)5);
        e = (*e).nextdef;
L722 :;
    }
L723 :;
    ;
    if ((nargs > nparams)) {
        qq_lib$gerror((byte*)"Too many args",0);
    }
;
    for (i=kwdindex;i<=nparams;++i) {
L724 :;
        keyunits[(i)-1] = 0;
L725 :;
    }
L726 :;
    ;
        ($av_1 = (kwdindex - (i64)1));
    for (i=(i64)1;i<=$av_1;++i) {
L727 :;
        qq_pclgen$evalparam((*arglist)[(i)-1],(i64)byreflist[(i)-1]);
L728 :;
    }
L729 :;
    ;
    for (i=kwdindex;i<=nargs;++i) {
L730 :;
        p = (*arglist)[(i)-1];
        q = (*p).a;
        if (((i64)(*q).tag != (i64)43)) {
            qq_lib$gerror((byte*)"kwd not a name",0);
        }
;
        e = (*q).def;
        k = (i64)0;
        for (j=(i64)1;j<=nparams;++j) {
L733 :;
            if (!!(mlib$eqstring((*e).name,(*paramlist[(j)-1]).name))) {
                k = j;
                goto L735 ;
            }
;
L734 :;
        }
L735 :;
        ;
        if ((k == (i64)0)) {
            qq_lib$gerror_s((byte*)"Can't find kwd param:",(*e).name,0);
        }
;
        if ((k < kwdindex)) {
            qq_lib$gerror_s((byte*)"Kwd arg already positional:",(*e).name,0);
        }
;
        if (!!(keyunits[(k)-1])) {
            qq_lib$gerror_s((byte*)"Repeating kwd arg:",(*e).name,0);
        }
;
        keyunits[(k)-1] = (*p).b;
L731 :;
    }
L732 :;
    ;
    for (i=kwdindex;i<=nparams;++i) {
L736 :;
        if ((keyunits[(i)-1] == 0)) {
            q = (*paramlist[(i)-1]).code;
            if (((q == 0) && !(!!(msysc$m_getdotindex((i64)(*paramlist[(i)-1]).flags,(i64)7))))) {
                qq_lib$gerror_s((byte*)"Param not optional:",msysc$strint(i,0),0);
            }
;
            keyunits[(i)-1] = q;
        }
;
L737 :;
    }
L738 :;
    ;
    for (i=kwdindex;i<=nparams;++i) {
L739 :;
        if (!!(keyunits[(i)-1])) {
            qq_pclgen$evalparam(keyunits[(i)-1],(i64)byreflist[(i)-1]);
        }
        else if (!!((i64)byreflist[(i)-1])) {
            qq_lib$gerror((byte*)"byref param not optional",0);
        }
        else {
            qq_pcllib$genpc((i64)20);
        }
;
L740 :;
    }
L741 :;
    ;
}

static void qq_pclgen$do_if(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,struct qq_decls$unitrec *pelse,i64 res) {
        i64 lab1;
        i64 lab2;
    lab1 = qq_pcllib$createfwdlabel();
    if ((!!(pelse) || !!(res))) {
        lab2 = qq_pcllib$createfwdlabel();
    }
;
    qq_pclgen$genjumpcond((i64)0,a,lab1);
    qq_pclgen$evalunit(b,res);
    if ((!!(pelse) || !!(res))) {
        qq_pclgen$genjumpl(lab2);
        qq_pcllib$definefwdlabel(&lab1);
        if (!!(pelse)) {
            qq_pclgen$evalunit(pelse,res);
        }
        else {
            qq_pcllib$genpc((i64)20);
        }
;
        qq_pcllib$definefwdlabel(&lab2);
    }
    else {
        qq_pcllib$definefwdlabel(&lab1);
    }
;
}

static void qq_pclgen$do_do(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a) {
        i64 lab_abc;
        i64 lab_d;
    lab_abc = qq_pcllib$definelabel();
    lab_d = qq_pcllib$createfwdlabel();
    qq_pclgen$stacklooplabels(&lab_abc,&lab_abc,&lab_d);
    qq_pclgen$evalunit(a,(i64)0);
    qq_pclgen$genjumpl(lab_abc);
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_exit(struct qq_decls$unitrec *p,i64 k) {
        i64 n;
        i64 index;
    index = (*(*p).a).value;
    if ((index == (i64)0)) {
        index = qq_pclgen$loopindex;
    }
;
    n = qq_pclgen$findlooplabel(k,index);
    if ((n == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"BAD LOOP",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        qq_pclgen$genjumpl(n);
    }
;
}

static void qq_pclgen$do_to(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pcount,struct qq_decls$unitrec *pbody) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        struct qq_decls$strec *  temp;
        struct qq_decls$unitrec *  pav;
    pav = (*pcount).nextunit;
    temp = (*pav).def;
    qq_pclgen$evalunit(pcount,(i64)1);
    qq_pcllib$genpc_name(((i64)30 + (i64)msysc$m_getdotindex((i64)(*temp).flags,(i64)9)),(struct qq_decls$strec *)temp);
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    if (((i64)(*pcount).tag != (i64)45)) {
        qq_pcllib$genpc_name(((i64)9 + (i64)msysc$m_getdotindex((i64)(*temp).flags,(i64)9)),(struct qq_decls$strec *)temp);
        qq_pcllib$genpc_int((i64)19,(i64)0);
        qq_pcllib$genpc_lab((i64)43,lab_d);
    }
    else if (((*pcount).value <= (i64)0)) {
        qq_pcllib$genpc_lab((i64)36,lab_d);
    }
;
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    qq_pcllib$genpc_lab(((i64)50 + (i64)msysc$m_getdotindex((i64)(*temp).flags,(i64)9)),lab_b);
    qq_pcllib$genopnd_name((struct qq_decls$strec *)temp);
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_while(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pcond,struct qq_decls$unitrec *pbody) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_incr;
        struct qq_decls$unitrec *  pincr;
    pincr = (*pcond).nextunit;
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    if (!!(pincr)) {
        lab_incr = qq_pcllib$createfwdlabel();
    }
    else {
        lab_incr = lab_c;
    }
;
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    qq_pclgen$genjumpl(lab_incr);
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if (!!(pincr)) {
        qq_pclgen$evalunit(pincr,(i64)1);
        qq_pcllib$definefwdlabel(&lab_incr);
    }
;
    qq_pclgen$genjumpcond((i64)1,pcond,lab_b);
    qq_pcllib$definefwdlabel(&lab_d);
    --(qq_pclgen$loopindex);
}

static void qq_pclgen$do_repeat(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
    lab_b = qq_pcllib$definelabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    qq_pclgen$evalunit(a,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if (!((((i64)(*b).tag == (i64)45) && ((*b).value == (i64)0)))) {
        qq_pclgen$genjumpcond((i64)0,b,lab_b);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    --(qq_pclgen$loopindex);
}

static void qq_pclgen$do_for(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pvar,struct qq_decls$unitrec *pbody) {
        struct qq_decls$unitrec *  pfrom;
        struct qq_decls$unitrec *  pto;
        struct qq_decls$unitrec *  pstep;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  pautovar;
        struct qq_decls$strec *  dvar;
        struct qq_decls$strec *  limitvar;
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_e;
        i64 opc;
        i64 oldqpos;
        i64 step;
        i64 fromval;
        i64 limit;
        i64 jumpinto;
    pfrom = (*pvar).nextunit;
    pto = (*pfrom).nextunit;
    pstep = (*pto).nextunit;
    pautovar = 0;
    if (!!(pstep)) {
        qq_lib$gerror((byte*)"By N not implem",0);
    }
;
    pelse = (*pbody).nextunit;
    dvar = (*pvar).def;
    if ((!(((i64)(*pto).tag == (i64)45 || (i64)(*pto).tag == (i64)43)) || (((i64)(*pto).tag == (i64)43) && (msysc$m_getdotindex((i64)(*(*pto).def).flags,(i64)9) != msysc$m_getdotindex((i64)(*dvar).flags,(i64)9))))) {
        pautovar = qq_lib$createavnamex(qq_decls$stcurrproc);
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)16)) {
        step = (i64)1;
    }
    else if (($temp==(i64)18)) {
        step = (i64)-1;
    }
    };
    jumpinto = (i64)1;
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    lab_e = (!!(pelse) ? qq_pcllib$createfwdlabel() : lab_d);
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    if (((i64)(*pfrom).tag == (i64)45)) {
        fromval = (*pfrom).value;
        if (((i64)(*pto).tag == (i64)45)) {
            limit = (*pto).value;
            if ((((step == (i64)-1) && (fromval >= limit)) || ((step == (i64)1) && (fromval <= limit)))) {
                jumpinto = (i64)0;
            }
;
        }
;
        if (!!(jumpinto)) {
            if ((step < (i64)0)) {
                ++(fromval);
            }
            else {
                --(fromval);
            }
;
            (*pfrom).value = fromval;
        }
;
        qq_pcllib$genpc_int((i64)19,(*pfrom).value);
        qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),(struct qq_decls$strec *)dvar);
    }
    else {
        qq_pclgen$evalunit(pfrom,(i64)1);
        qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),(struct qq_decls$strec *)dvar);
        qq_pcllib$genpc_name((((step < (i64)0) ? (i64)84 : (i64)89) + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),(struct qq_decls$strec *)dvar);
    }
;
    if (!!(pautovar)) {
        qq_pclgen$evalunit(pto,(i64)1);
        limitvar = (*pautovar).def;
        qq_pcllib$genpc_name(((i64)30 + (i64)msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9)),(struct qq_decls$strec *)limitvar);
        pto = pautovar;
    }
    else {
        limitvar = (*pto).def;
    }
;
    if (!!(jumpinto)) {
        qq_pclgen$genjumpl(lab_c);
    }
;
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if (((i64)(*pto).tag == (i64)45)) {
        opc = (((step < (i64)0) ? (i64)56 : (i64)52) + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9));
    }
    else if ((msysc$m_getdotindex((i64)(*dvar).flags,(i64)9) == msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9))) {
        opc = (((step < (i64)0) ? (i64)58 : (i64)54) + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9));
    }
    else {
        qq_lib$gerror((byte*)"for:mixed m/f vars",0);
    }
;
    oldqpos = qq_decls$qpos;
    qq_decls$qpos = (i64)(*p).pos;
    qq_pcllib$genpc_lab(opc,lab_b);
    qq_decls$qpos = oldqpos;
    qq_pcllib$genopnd_name((struct qq_decls$strec *)dvar);
    if (((i64)(*pto).tag == (i64)45)) {
        qq_pcllib$genopnd_int((*pto).value);
    }
    else {
        qq_pcllib$genopnd_name((struct qq_decls$strec *)limitvar);
    }
;
    if (!!(pelse)) {
        qq_pcllib$definefwdlabel(&lab_e);
        qq_pclgen$evalunit(pelse,(i64)0);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_forx(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pvar,struct qq_decls$unitrec *pbody) {
        struct qq_decls$unitrec *  pbounds;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  pautovar;
        struct qq_decls$strec *  dvar;
        struct qq_decls$strec *  limitvar;
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_e;
    pbounds = (*pvar).nextunit;
    pautovar = qq_lib$createavnamex(qq_decls$stcurrproc);
    pelse = (*pbody).nextunit;
    dvar = (*pvar).def;
    if (((i64)(*p).tag == (i64)19)) {
        qq_lib$gerror((byte*)"Can't down inrev yet",0);
    }
;
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    lab_e = (!!(pelse) ? qq_pcllib$createfwdlabel() : lab_d);
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    qq_pclgen$evalunit(pbounds,(i64)1);
    limitvar = (*pautovar).def;
    qq_pcllib$genpc_name(((i64)30 + (i64)msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9)),(struct qq_decls$strec *)limitvar);
    qq_pcllib$genpc((i64)94);
    qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),(struct qq_decls$strec *)dvar);
    qq_pclgen$genjumpl(lab_c);
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if ((msysc$m_getdotindex((i64)(*dvar).flags,(i64)9) == msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9))) {
        qq_pcllib$genpc_lab(((i64)54 + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),lab_b);
    }
    else {
        qq_lib$gerror((byte*)"forx:mixed m/f",0);
    }
;
    qq_pcllib$genopnd_name((struct qq_decls$strec *)dvar);
    qq_pcllib$genopnd_name((struct qq_decls$strec *)limitvar);
    if (!!(pelse)) {
        qq_pcllib$definefwdlabel(&lab_e);
        qq_pclgen$evalunit(pelse,(i64)0);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_print(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 issprint;
        struct qq_decls$unitrec *  x;
    issprint = (i64)((i64)(*p).tag == (i64)64);
    if (!!(issprint)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"//////ISSPRINT",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_pclgen$callhostfn((i64)3,(i64)0);
    }
    else {
        if (!!(a)) {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$callhostfn((i64)1,(i64)0);
        }
        else {
            qq_pclgen$callhostfn((i64)2,(i64)0);
        }
;
    }
;
    x = b;
    L742 :;
    while (!!(x)) {
                {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)68)) {
            qq_pclgen$evalunit((*x).b,(i64)1);
            qq_pclgen$evalunit((*x).a,(i64)1);
            qq_pclgen$callhostfn((i64)7,(i64)0);
        }
        else if (($temp==(i64)66)) {
            qq_pclgen$callhostfn((i64)10,(i64)0);
        }
        else if (($temp==(i64)67)) {
            qq_pclgen$callhostfn((i64)11,(i64)0);
        }
        else {
            qq_pclgen$evalunit(x,(i64)1);
            qq_pclgen$callhostfn((i64)8,(i64)0);
        }
        };
        x = (*x).nextunit;
L743 :;
    }
L744 :;
    ;
    if (((i64)(*p).tag == (i64)61)) {
        qq_pclgen$callhostfn((i64)9,(i64)0);
    }
;
    if (!!(issprint)) {
        qq_pcllib$genpc((i64)20);
        qq_pclgen$callhostfn((i64)6,(i64)0);
    }
    else {
        qq_pclgen$callhostfn((i64)5,(i64)0);
    }
;
}

static void qq_pclgen$do_fprint(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,struct qq_decls$unitrec *c) {
        i64 issfprint;
        struct qq_decls$unitrec *  x;
    issfprint = (i64)((i64)(*p).tag == (i64)65);
    if (!!(issfprint)) {
        qq_pclgen$callhostfn((i64)3,(i64)0);
    }
    else {
        if (!!(a)) {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$callhostfn((i64)1,(i64)0);
        }
        else {
            qq_pclgen$callhostfn((i64)2,(i64)0);
        }
;
    }
;
    qq_pclgen$evalunit(b,(i64)1);
    qq_pclgen$callhostfn((i64)4,(i64)0);
    x = c;
    L745 :;
    while (!!(x)) {
                {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)68)) {
            qq_pclgen$evalunit((*x).b,(i64)1);
            qq_pclgen$evalunit((*x).a,(i64)1);
            qq_pclgen$callhostfn((i64)7,(i64)0);
        }
        else if (($temp==(i64)66)) {
            qq_pclgen$callhostfn((i64)10,(i64)0);
        }
        else {
            qq_pcllib$genpc((i64)20);
            qq_pclgen$evalunit(x,(i64)1);
            qq_pclgen$callhostfn((i64)7,(i64)0);
        }
        };
        x = (*x).nextunit;
L746 :;
    }
L747 :;
    ;
    if (((i64)(*p).tag == (i64)63)) {
        qq_pclgen$callhostfn((i64)9,(i64)0);
    }
;
    if (!!(issfprint)) {
        qq_pcllib$genpc((i64)20);
        qq_pclgen$callhostfn((i64)6,(i64)0);
    }
    else {
        qq_pclgen$callhostfn((i64)5,(i64)0);
    }
;
}

static void qq_pclgen$do_read(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        struct qq_decls$unitrec *  x;
        struct qq_decls$unitrec *  xloop;
    if (((i64)(*p).tag == (i64)70)) {
        if (!!(a)) {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$callhostfn((i64)12,(i64)0);
        }
        else {
            qq_pcllib$genpc((i64)20);
            qq_pclgen$callhostfn((i64)12,(i64)0);
        }
;
    }
;
    xloop = b;
    L748 :;
    while (!!(xloop)) {
        x = xloop;
        qq_pcllib$genpc((i64)20);
        if (((i64)(*x).tag == (i64)68)) {
            qq_pclgen$evalunit((*x).b,(i64)1);
            qq_pclgen$callhostfn((i64)14,(i64)0);
            x = (*x).a;
        }
        else {
            qq_pcllib$genpc((i64)20);
            qq_pclgen$callhostfn((i64)14,(i64)0);
        }
;
        if (((i64)(*x).tag == (i64)43)) {
            qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*(*x).def).flags,(i64)9)),(struct qq_decls$strec *)(*x).def);
        }
        else {
            qq_pclgen$evalref(x);
            qq_pcllib$genpc((i64)29);
        }
;
        xloop = (*xloop).nextunit;
L749 :;
    }
L750 :;
    ;
}

static void qq_pclgen$do_forall(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pbody) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_e;
        struct qq_decls$unitrec *  ploopvar;
        struct qq_decls$unitrec *  plist;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  plimitvar;
        struct qq_decls$unitrec *  plistvar;
        struct qq_decls$strec *  indexvar;
        struct qq_decls$strec *  limitvar;
        struct qq_decls$strec *  loopvar;
        struct qq_decls$strec *  listvar;
    plist = (*pindex).nextunit;
    ploopvar = (*plist).nextunit;
    if ((ploopvar == 0)) {
        ploopvar = pindex;
        pindex = qq_lib$createavnamex(qq_decls$stcurrproc);
    }
;
    loopvar = (*ploopvar).def;
    plimitvar = qq_lib$createavnamex(qq_decls$stcurrproc);
    limitvar = (*plimitvar).def;
    indexvar = (*pindex).def;
    if ((((i64)(*plist).tag != (i64)43) || (msysc$m_getdotindex((i64)(*(*plist).def).flags,(i64)9) != msysc$m_getdotindex((i64)(*loopvar).flags,(i64)9)))) {
        plistvar = qq_lib$createavnamex(qq_decls$stcurrproc);
        listvar = (*plistvar).def;
        qq_pclgen$evalunit(plist,(i64)1);
        qq_pcllib$genpc_name(((i64)30 + (i64)msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)),(struct qq_decls$strec *)listvar);
    }
    else {
        plistvar = plist;
        listvar = (*plistvar).def;
    }
;
    if (!((msysc$m_getdotindex((i64)(*indexvar).flags,(i64)9)==msysc$m_getdotindex((i64)(*loopvar).flags,(i64)9) && msysc$m_getdotindex((i64)(*loopvar).flags,(i64)9)==msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)))) {
        qq_lib$gerror((byte*)"forall: mixed vars",0);
    }
;
    pelse = (*pbody).nextunit;
    if (((i64)(*p).tag == (i64)21)) {
        qq_lib$gerror((byte*)"Forall/rev not ready",0);
    }
;
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    lab_e = (!!(pelse) ? qq_pcllib$createfwdlabel() : lab_d);
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    qq_pcllib$genpc_name(((i64)9 + (i64)msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)),(struct qq_decls$strec *)listvar);
    qq_pcllib$genpc((i64)127);
    qq_pcllib$genpc_name(((i64)30 + (i64)msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)),(struct qq_decls$strec *)limitvar);
    qq_pcllib$genpc((i64)94);
    qq_pcllib$genpc_name(((i64)30 + (i64)msysc$m_getdotindex((i64)(*indexvar).flags,(i64)9)),(struct qq_decls$strec *)indexvar);
    qq_pclgen$genjumpl(lab_c);
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pcllib$genpc_name(((i64)9 + (i64)msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)),(struct qq_decls$strec *)listvar);
    qq_pclgen$evalunit(pindex,(i64)1);
    if (((i64)(*p).tag == (i64)20 || (i64)(*p).tag == (i64)21)) {
        qq_pcllib$genpc((i64)200);
    }
    else {
        qq_pcllib$genpc((i64)201);
    }
;
    qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*loopvar).flags,(i64)9)),(struct qq_decls$strec *)loopvar);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if ((msysc$m_getdotindex((i64)(*indexvar).flags,(i64)9) == msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9))) {
        qq_pcllib$genpc_lab(((i64)54 + (i64)msysc$m_getdotindex((i64)(*indexvar).flags,(i64)9)),lab_b);
    }
    else {
        qq_lib$gerror((byte*)"forall:mixed m/f",0);
    }
;
    qq_pcllib$genopnd_name((struct qq_decls$strec *)indexvar);
    qq_pcllib$genopnd_name((struct qq_decls$strec *)limitvar);
    if (!!(pelse)) {
        qq_pcllib$definefwdlabel(&lab_e);
        qq_pclgen$evalunit(pelse,(i64)0);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_case(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res) {
        i64 lab_a;
        i64 lab_d;
        i64 loopsw;
        i64 labnextwhen;
        i64 labstmtstart;
        i64 fmult;
        struct qq_decls$unitrec *  w;
        struct qq_decls$unitrec *  wt;
        struct qq_decls$unitrec *  pelse;
    if (((i64)(*pindex).tag == (i64)0)) {
        qq_pclgen$do_case_nc(p,pindex,pwhenthen,res);
        return;
    }
;
    loopsw = (i64)(((i64)(*p).tag == (i64)12) || ((i64)(*p).tag == (i64)14));
    pelse = (*pindex).nextunit;
    if (!!(loopsw)) {
        lab_a = qq_pcllib$definelabel();
        lab_d = qq_pcllib$createfwdlabel();
        qq_pclgen$stacklooplabels(&lab_a,&lab_a,&lab_d);
    }
    else {
        lab_d = qq_pcllib$createfwdlabel();
    }
;
    qq_pclgen$evalunit(pindex,(i64)1);
    wt = pwhenthen;
    L751 :;
    while (!!(wt)) {
        w = (*wt).a;
        fmult = (i64)((*w).nextunit != 0);
        labnextwhen = qq_pcllib$createfwdlabel();
        if (!!(fmult)) {
            labstmtstart = qq_pcllib$createfwdlabel();
        }
;
        L754 :;
        while (!!(w)) {
            qq_pclgen$evalunit(w,(i64)1);
            w = (*w).nextunit;
            if (!!(w)) {
                qq_pcllib$genpc_lab((i64)46,labstmtstart);
            }
            else {
                qq_pcllib$genpc_lab((i64)47,labnextwhen);
            }
;
L755 :;
        }
L756 :;
        ;
        if (!!(fmult)) {
            qq_pcllib$definefwdlabel(&labstmtstart);
        }
;
        qq_pclgen$evalunit((*wt).b,res);
        if (!(!!(loopsw))) {
            qq_pclgen$genjumpl(lab_d);
        }
        else {
            qq_pclgen$genjumpl(lab_a);
        }
;
        qq_pcllib$definefwdlabel(&labnextwhen);
        wt = (*wt).nextunit;
L752 :;
    }
L753 :;
    ;
    qq_pcllib$genpc_int((i64)69,(i64)1);
    if (!!(pelse)) {
        qq_pclgen$evalunit(pelse,res);
    }
    else if (!!(res)) {
        qq_pcllib$genpc((i64)20);
    }
;
    if (!!(loopsw)) {
        qq_pclgen$genjumpl(lab_a);
        qq_pcllib$definefwdlabel(&lab_d);
        qq_pclgen$unstacklooplabels();
    }
    else {
        qq_pcllib$definefwdlabel(&lab_d);
    }
;
}

static void qq_pclgen$do_case_nc(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res) {
        i64 lab_d;
        i64 labnextwhen;
        i64 labstmtstart;
        i64 fmult;
        struct qq_decls$unitrec *  w;
        struct qq_decls$unitrec *  wt;
        struct qq_decls$unitrec *  pelse;
    if (((i64)(*p).tag != (i64)11)) {
        qq_lib$gerror((byte*)"case-nc",0);
    }
;
    pelse = (*pindex).nextunit;
    lab_d = qq_pcllib$createfwdlabel();
    wt = pwhenthen;
    L757 :;
    while (!!(wt)) {
        w = (*wt).a;
        fmult = (i64)((*w).nextunit != 0);
        labnextwhen = qq_pcllib$createfwdlabel();
        if (!!(fmult)) {
            labstmtstart = qq_pcllib$createfwdlabel();
        }
;
        L760 :;
        while (!!(w)) {
            qq_pclgen$evalunit(w,(i64)1);
            w = (*w).nextunit;
            if (!!(w)) {
                qq_pcllib$genpc_lab((i64)38,labstmtstart);
            }
            else {
                qq_pcllib$genpc_lab((i64)39,labnextwhen);
            }
;
L761 :;
        }
L762 :;
        ;
        if (!!(fmult)) {
            qq_pcllib$definefwdlabel(&labstmtstart);
        }
;
        qq_pclgen$evalunit((*wt).b,res);
        qq_pclgen$genjumpl(lab_d);
        qq_pcllib$definefwdlabel(&labnextwhen);
        wt = (*wt).nextunit;
L758 :;
    }
L759 :;
    ;
    if (!!(pelse)) {
        qq_pclgen$evalunit(pelse,res);
    }
    else if (!!(res)) {
        qq_lib$gerror((byte*)"Needs Else branch",0);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
}

static void qq_pclgen$do_try(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 labend;
        i64 labx;
        struct qq_decls$unitrec *  ptry;
        struct qq_decls$unitrec *  pexcept;
        struct qq_decls$unitrec *  pexcode;
    ++(qq_pclgen$trylevel);
    labend = qq_pcllib$createfwdlabel();
    ptry = a;
    labx = qq_pcllib$createfwdlabel();
    pexcept = b;
    if ((pexcept == 0)) {
        qq_lib$gerror((byte*)"try: no except",0);
    }
    else if (!!((*pexcept).nextunit)) {
        qq_lib$gerror((byte*)"Try:multiple except block not implemented",0);
    }
;
    L763 :;
    while (!!(pexcept)) {
        pexcode = (*pexcept).a;
        if (((pexcode == 0) || !!((*pexcode).nextunit))) {
            qq_lib$gerror((byte*)"Try:multiple except codes not implemented",0);
        }
;
        qq_pcllib$genpc_lab((i64)212,labx);
        qq_pcllib$genopnd_int(qq_pclgen$getconstvalue(pexcode));
        qq_pcllib$genopnd_int((i64)1);
        qq_pclgen$evalunit(ptry,(i64)0);
        qq_pclgen$genjumpl(labend);
        qq_pcllib$definefwdlabel(&labx);
        qq_pclgen$evalunit((*pexcept).b,(i64)0);
        qq_pcllib$definefwdlabel(&labend);
        pexcept = (*pexcept).nextunit;
L764 :;
    }
L765 :;
    ;
    qq_pcllib$genpc_int((i64)70,(i64)1);
    --(qq_pclgen$trylevel);
}

static i64 qq_pclgen$unitstoarray(struct qq_decls$unitrec *p,struct qq_decls$unitrec *(*plist)[],i64 maxunits) {
        i64 n;
    n = (i64)0;
    L766 :;
    while (!!(p)) {
        if ((n >= maxunits)) {
            qq_lib$gerror((byte*)"UTA Too many units",0);
        }
;
        (*plist)[(++(n))-1] = p;
        p = (*p).nextunit;
L767 :;
    }
L768 :;
    ;
    return n;
}

static void qq_pclgen$do_select(struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pplist,i64 res) {
        i64 n;
        i64 labend;
        i64 i;
        i64 lab;
        i64 elselab;
        struct qq_decls$unitrec *  x;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  plist[512];
        i64 labels[513];
    pelse = (*pindex).nextunit;
    n = qq_pclgen$unitstoarray(pplist,(struct qq_decls$unitrec *(*)[])&plist,(i64)512);
    if ((n > (i64)512)) {
        qq_lib$gerror((byte*)"Selectx too complex",0);
    }
;
    labend = qq_pcllib$createfwdlabel();
    qq_pclgen$evalunit(pindex,(i64)1);
    qq_pcllib$genpc_int2((i64)49,n,(i64)1);
    for (i=(i64)1;i<=n;++i) {
L769 :;
        labels[(i)-1] = (qq_pcllib$pclnext - qq_pcllib$pclstart);
        qq_pcllib$genpc_lab((i64)48,(i64)0);
L770 :;
    }
L771 :;
    ;
    labels[((n + (i64)1))-1] = (qq_pcllib$pclnext - qq_pcllib$pclstart);
    qq_pcllib$genpc_lab((i64)48,(i64)0);
    i = (i64)1;
    for (i=(i64)1;i<=n;++i) {
L772 :;
        x = plist[(i)-1];
        lab = qq_pcllib$definelabel();
        (*((qq_pcllib$pclstart + labels[(i)-1]) + (i64)1)) = lab;
        qq_pclgen$evalunit(x,res);
        qq_pclgen$genjumpl(labend);
L773 :;
    }
L774 :;
    ;
    elselab = qq_pcllib$definelabel();
    (*((qq_pcllib$pclstart + labels[((n + (i64)1))-1]) + (i64)1)) = elselab;
    if (!!(pelse)) {
        qq_pclgen$evalunit(pelse,res);
    }
    else if (!!(res)) {
        qq_pcllib$genpc((i64)20);
    }
;
    qq_pcllib$genpc((i64)1);
    qq_pcllib$definefwdlabel(&labend);
}

static void qq_pclgen$do_andl(struct qq_decls$unitrec *x,struct qq_decls$unitrec *y) {
        i64 a;
        i64 b;
    a = qq_pcllib$createfwdlabel();
    b = qq_pcllib$createfwdlabel();
    qq_pclgen$genjumpcond((i64)0,x,a);
    qq_pclgen$genjumpcond((i64)0,y,a);
    qq_pcllib$genpc_int((i64)19,(i64)1);
    qq_pclgen$genjumpl(b);
    qq_pcllib$definefwdlabel(&a);
    qq_pcllib$genpc_int((i64)19,(i64)0);
    qq_pcllib$genpc((i64)1);
    qq_pcllib$definefwdlabel(&b);
}

static void qq_pclgen$do_orl(struct qq_decls$unitrec *x,struct qq_decls$unitrec *y) {
        i64 a;
        i64 b;
    a = qq_pcllib$createfwdlabel();
    b = qq_pcllib$createfwdlabel();
    qq_pclgen$genjumpcond((i64)1,x,a);
    qq_pclgen$genjumpcond((i64)1,y,a);
    qq_pcllib$genpc_int((i64)19,(i64)0);
    qq_pclgen$genjumpl(b);
    qq_pcllib$definefwdlabel(&a);
    qq_pcllib$genpc_int((i64)19,(i64)1);
    qq_pcllib$genpc((i64)1);
    qq_pcllib$definefwdlabel(&b);
}

static void qq_pclgen$do_incr(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,i64 res) {
        struct qq_decls$strec *  d;
    if (!!(res)) {
        qq_pclgen$do_unaryref(a,(i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
    }
    else if (((i64)(*a).tag == (i64)43)) {
        d = (*a).def;
        if ((((i64)(*d).nameid == (i64)15) && !!(msysc$m_getdotindex((i64)(*d).flags,(i64)5)))) {
            goto L775 ;
;
        }
        else {
            qq_pcllib$genpc_name(((((i64)(*p).tag == (i64)74 || (i64)(*p).tag == (i64)76) ? (i64)84 : (i64)89) + (i64)msysc$m_getdotindex((i64)(*(*a).def).flags,(i64)9)),(struct qq_decls$strec *)(*a).def);
        }
;
    }
    else {
        //dounary:
L775 :;
;
        qq_pclgen$do_unaryref(a,(((i64)(*p).tag == (i64)74 || (i64)(*p).tag == (i64)76) ? (i64)83 : (i64)88));
    }
;
}

static void qq_pclgen$do_new(struct qq_decls$unitrec *p) {
        i64 n;
        struct qq_decls$unitrec *  q;
        i64 $av_1;
        i64 $av_2;
    n = (i64)(*p).nparams;
    if (((n < (i64)1) || (n > (i64)3))) {
        qq_lib$gerror((byte*)"new args",0);
    }
;
    q = (*p).a;
    qq_pcllib$genpc((i64)20);
    $av_1 = n;
    while ($av_1-- > 0) {
L776 :;
        qq_pclgen$evalunit(q,(i64)1);
        q = (*q).nextunit;
L777 :;
    }
L778 :;
    ;
    $av_2 = ((i64)3 - n);
    while ($av_2-- > 0) {
L779 :;
        qq_pcllib$genpc((i64)20);
L780 :;
    }
L781 :;
    ;
    qq_pclgen$callhostfn((i64)30,(i64)0);
}

static i64 qq_pclgen$checkblockreturn(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
    if ((p == 0)) {
        return (i64)0;
    }
;
    if (((i64)(*p).tag != (i64)7)) {
        qq_lib$gerror((byte*)"CBR?",0);
    }
;
    q = (struct qq_decls$unitrec *)(*p).a;
    if ((q == 0)) {
        return (i64)0;
    }
;
    L782 :;
    while (!!((r = (struct qq_decls$unitrec *)(*q).nextunit))) {
        q = r;
L783 :;
    }
L784 :;
    ;
        {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)36)) {
        return (i64)1;
    }
    else if (($temp==(i64)8)) {
        return (i64)(!!(qq_pclgen$checkblockreturn((*q).b)) && !!(qq_pclgen$checkblockreturn((*(*q).b).nextunit)));
    }
    };
    return (i64)0;
}

static void qq_pclgen$do_callhost(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,i64 res) {
        i64 index;
        i64 isfunc;
        i64 nargs;
        i64 nparams;
        i64 fparams;
        struct qq_decls$unitrec *  plist[10];
        struct qq_decls$unitrec *  q;
        i64 $av_1;
        i64 i;
    index = (*p).index;
    isfunc = (i64)qq_tables$hostisfn[(index)];
    if ((!!(res) && !(!!(isfunc)))) {
        qq_lib$gerror((byte*)"Host proc not a function",0);
    }
;
    if (!!(isfunc)) {
        qq_pcllib$genpc((i64)20);
    }
;
    nargs = (i64)0;
    q = a;
    L785 :;
    while (!!(q)) {
        if ((nargs > (i64)10)) {
            qq_lib$gerror((byte*)"Too many host args",0);
        }
;
        plist[(++(nargs))-1] = q;
        q = (*q).nextunit;
L786 :;
    }
L787 :;
    ;
    nparams = nargs;
    if (((nparams == (i64)0) && !!((i64)qq_tables$hostlvset[(index)]))) {
        qq_lib$gerror((byte*)"LV hostfn: needs 1+ params",0);
    }
;
    fparams = (i64)qq_tables$hostnparams[(index)];
    if ((nparams > fparams)) {
        qq_lib$gerror((byte*)"Hostfn too many params",0);
    }
;
    $av_1 = (fparams - nparams);
    while ($av_1-- > 0) {
L788 :;
        qq_pcllib$genpc((i64)20);
L789 :;
    }
L790 :;
    ;
    for (i=nparams;i>=(i64)1;--i) {
L791 :;
        if (((i == (i64)1) && !!((i64)qq_tables$hostlvset[(index)]))) {
            qq_pclgen$evalref(plist[(i)-1]);
        }
        else {
            qq_pclgen$evalunit(plist[(i)-1],(i64)1);
        }
;
L792 :;
    }
L793 :;
    ;
    qq_pclgen$callhostfn(index,res);
}

static void qq_pclgen$callhostfn(i64 fnindex,i64 calledasfn) {
    qq_pcllib$genpc_int((i64)68,fnindex);
}

static void qq_pclgen$genfree(i64 n) {
    qq_pcllib$genpc_int((i64)69,n);
}

static void qq_pclgen$do_return(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a) {
    if (!!(a)) {
        qq_pclgen$evalunit(a,(i64)1);
    }
    else if ((qq_pclgen$currfunction == (i64)2)) {
        qq_lib$gerror((byte*)"function needs return value",0);
    }
;
    qq_pclgen$genjumpl(qq_pclgen$retindex);
}

static void qq_pclgen$do_multassign(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 deepcopy,i64 res) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  plist[100];
        i64 n;
        i64 i;
    p = (*a).a;
    q = (*b).a;
    n = (i64)0;
    L794 :;
    while (!!(p)) {
        if ((q == 0)) {
            qq_lib$gerror((byte*)"Too few RHS elems",0);
        }
;
        qq_pclgen$evalunit(q,(i64)1);
        if ((n >= (i64)100)) {
            qq_lib$gerror((byte*)"Too many elems",0);
        }
;
        plist[(++(n))-1] = p;
        p = (*p).nextunit;
        q = (*q).nextunit;
L795 :;
    }
L796 :;
    ;
    if (!!(q)) {
        qq_lib$gerror((byte*)"Too few LHS elems",0);
    }
;
    for (i=n;i>=(i64)1;--i) {
L797 :;
        if (!!(deepcopy)) {
            qq_pcllib$genpc((i64)33);
        }
;
        qq_pclgen$do_store(plist[(i)-1],(i64)0);
L798 :;
    }
L799 :;
    ;
}

static void qq_pclgen$do_store(struct qq_decls$unitrec *a,i64 res) {
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  plist[100];
        i64 n;
        i64 i;
    if ((!!(res) && ((i64)(*a).tag != (i64)43))) {
        qq_pcllib$genpc((i64)32);
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)43)) {
        d = (*a).def;
        if ((((i64)(*d).nameid == (i64)15) && !!(msysc$m_getdotindex((i64)(*d).flags,(i64)5)))) {
            if (!!(res)) {
                qq_pcllib$genpc((i64)32);
            }
;
            qq_pcllib$genpc_name((i64)10,(struct qq_decls$strec *)d);
            qq_pcllib$genpc((i64)29);
        }
        else if (!!(res)) {
            qq_pcllib$genpc_name(((i64)15 + (i64)msysc$m_getdotindex((i64)(*d).flags,(i64)9)),(struct qq_decls$strec *)d);
        }
        else if (((i64)(*d).nameid == (i64)8)) {
            qq_pcllib$genpc_name((i64)18,(struct qq_decls$strec *)d);
        }
        else {
            qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*d).flags,(i64)9)),(struct qq_decls$strec *)d);
        }
;
    }
    else if (($temp==(i64)49)) {
        qq_pclgen$evalunit((*a).a,(i64)1);
        qq_pcllib$genpc_name((i64)207,(struct qq_decls$strec *)(*(*a).b).def);
    }
    else if (($temp==(i64)50)) {
        qq_pclgen$do_bin((*a).a,(*a).b,(i64)208);
    }
    else if (($temp==(i64)51)) {
        qq_pclgen$evalref((*a).a);
        qq_pclgen$evalunit((*a).b,(i64)1);
        qq_pcllib$genpc((i64)209);
    }
    else if (($temp==(i64)56)) {
        qq_pclgen$evalunit((*a).a,(i64)1);
        qq_pcllib$genpc((i64)29);
    }
    else if (($temp==(i64)52)) {
        qq_pclgen$do_bin((*a).a,(*a).b,(i64)210);
    }
    else if (($temp==(i64)185)) {
        n = (i64)0;
        p = (*a).a;
        L800 :;
        while (!!(p)) {
            if ((n >= (i64)100)) {
                qq_lib$gerror((byte*)"Too many elems",0);
            }
;
            plist[(++(n))-1] = p;
            p = (*p).nextunit;
L801 :;
        }
L802 :;
        ;
        if ((n == (i64)0)) {
            qq_lib$gerror((byte*)"Empty lhs list",0);
        }
;
        qq_pcllib$genpc_int((i64)211,n);
        for (i=(i64)1;i<=n;++i) {
L803 :;
            qq_pclgen$do_store(plist[(i)-1],(i64)0);
L804 :;
        }
L805 :;
        ;
    }
    else if (($temp==(i64)8)) {
        qq_pclgen$evalref(a);
        qq_pcllib$genpc((i64)29);
    }
    else {
        qq_lib$gerror_s((byte*)"Can't store to this unit yet:",qq_tables$jtagnames[((i64)(*a).tag)],a);
    }
    };
}

static i64 qq_pclgen$getconstvalue(struct qq_decls$unitrec *p) {
    if ((!!(p) && ((i64)(*p).tag == (i64)45))) {
        return (*p).value;
    }
;
    qq_lib$gerror((byte*)"gcv Not const",0);
    return (i64)0;
}

static void qq_pclgen$do_convert(struct qq_decls$unitrec *pconv) {
        i64 n;
        i64 elemmode;
        i64 i;
        i64 lowerx;
        i64 m;
        i64 mbase;
        i64 nfields;
        struct qq_decls$unitrec *  plist[400];
        struct qq_decls$unitrec *  p;
        i64 $av_1;
    m = (i64)(*pconv).mode;
    p = (*pconv).a;
    mbase = (i64)qq_tables$ttbasetype[(m)];
    if ((((i64)(*p).tag != (i64)185) || (mbase == (i64)16))) {
        if (((i64)(*p).tag == (i64)185)) {
            qq_lib$deleteunit(p,(*p).a);
        }
;
        qq_pclgen$evalunit(p,(i64)1);
        qq_pcllib$genpc_int((i64)152,m);
        return;
    }
;
    n = qq_pclgen$unitstoarray((*p).a,(struct qq_decls$unitrec *(*)[])&plist,(i64)400);
    if ((!!(n) && ((i64)(*plist[((i64)1)-1]).tag == (i64)5))) {
        if ((mbase==(i64)12) || (mbase==(i64)13)) {
            qq_pclgen$do_makerecordkv(m,n,&plist);
        }
        else {
            qq_lib$gerror((byte*)"key:value not allowed",0);
        }
;
        return;
    }
;
    for (i=(i64)1;i<=n;++i) {
L806 :;
        qq_pclgen$evalunit(plist[(i)-1],(i64)1);
L807 :;
    }
L808 :;
    ;
    if ((mbase==(i64)12) || (mbase==(i64)13)) {
        nfields = qq_tables$ttlength[(m)];
        if (!!(n)) {
            qq_pclgen$checkelems(n,nfields,p);
        }
        else {
            $av_1 = nfields;
            while ($av_1-- > 0) {
L809 :;
                qq_pcllib$genpc_int((i64)19,(i64)0);
L810 :;
            }
L811 :;
            ;
            n = nfields;
        }
;
        qq_pcllib$genpc_int2(((mbase == (i64)12) ? (i64)74 : (i64)77),n,m);
    }
    else if ((mbase==(i64)10)) {
        lowerx = (i64)(*p).lower;
        qq_pcllib$genpc_int2((i64)73,n,lowerx);
    }
    else if ((mbase==(i64)11)) {
        qq_pcllib$genpc_int4((i64)75,(i64)(*p).lower,n,(i64)11,(i64)(*p).elemtype);
    }
    else if ((mbase==(i64)7)) {
        elemmode = (i64)qq_tables$tttarget[(m)];
        lowerx = qq_tables$ttlower[(m)];
        qq_pclgen$checkelems(n,qq_tables$ttlength[(m)],p);
        qq_pcllib$genpc_int4((i64)75,lowerx,n,m,elemmode);
    }
    else if ((mbase==(i64)8)) {
        if ((m == (i64)8)) {
            qq_pcllib$genpc_int4((i64)76,(i64)(*p).lower,n,(i64)8,(((i64)(*p).elemtype == (i64)0) ? (i64)32 : (i64)(*p).elemtype));
        }
        else {
            qq_lib$gerror((byte*)"user-define bit array not ready",0);
        }
;
    }
    else if ((mbase==(i64)5)) {
        qq_pcllib$genpc_int((i64)78,n);
    }
    else {
        qq_lib$gerror_s((byte*)"Convert list",qq_show$strmode(mbase,(i64)0),0);
    }
;
}

static void qq_pclgen$checkelems(i64 n,i64 length,struct qq_decls$unitrec *p) {
    if ((n < length)) {
        qq_lib$gerror((byte*)"Too few elements",0);
    }
    else if ((n > length)) {
        qq_lib$gerror((byte*)"Too many elements",0);
    }
;
}

static void qq_pclgen$do_switch(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res) {
        i64 minlab;
        i64 maxlab;
        i64 x;
        i64 y;
        i64 i;
        i64 n;
        struct qq_decls$unitrec *  w;
        struct qq_decls$unitrec *  wt;
        struct qq_decls$unitrec *  pelse;
    pelse = (*pindex).nextunit;
    minlab = (i64)1000000;
    maxlab = (i64)-1000000;
    n = (i64)0;
    wt = pwhenthen;
    L812 :;
    while (!!(wt)) {
        w = (*wt).a;
        L815 :;
        while (!!(w)) {
                        {i64 $temp = (i64)(*w).tag;
if (($temp==(i64)183)) {
                x = qq_pclgen$getconstvalue((*w).a);
                y = qq_pclgen$getconstvalue((*w).b);
                //dorange:
L818 :;
;
                for (i=x;i<=y;++i) {
L819 :;
                    minlab = (minlab<i?minlab:i);
                    maxlab = (maxlab>i?maxlab:i);
L820 :;
                }
L821 :;
                ;
            }
            else if (($temp==(i64)45)) {
                x = (y = (*w).value);
                goto L818 ;
;
            }
            else if (($temp==(i64)37)) {
                x = (y = (i64)(*w).mode);
                goto L818 ;
;
            }
            else {
                qq_lib$gerror_s((byte*)"Switch when2: not const",(*qq_lib$strexpr(w)).strptr,0);
            }
            };
            w = (*w).nextunit;
L816 :;
        }
L817 :;
        ;
        wt = (*wt).nextunit;
L813 :;
    }
L814 :;
    ;
    if (((maxlab - minlab) <= (i64)512)) {
        qq_pclgen$do_simpleswitch(p,pindex,pwhenthen,pelse,minlab,maxlab,res);
        return;
    }
;
    qq_lib$gerror((byte*)"COMPLEX SWITCH/NOT COMPLETE",0);
}

static void qq_pclgen$do_simpleswitch(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,struct qq_decls$unitrec *pelse,i64 a,i64 b,i64 res) {
        struct qq_decls$unitrec *  w;
        struct qq_decls$unitrec *  wt;
        i64 loopsw;
        i64 n;
        i64 offset;
        i64 x;
        i64 y;
        i64 x0;
        i64 i;
        i64 labstmt;
        i64 elselab;
        i64 *  labels[513];
        i64 lab_a;
        i64 lab_d;
    loopsw = (i64)((i64)(*p).tag == (i64)14);
    n = ((b - a) + (i64)1);
    offset = (a - (i64)1);
    if (!!(loopsw)) {
        lab_a = qq_pcllib$definelabel();
        lab_d = qq_pcllib$createfwdlabel();
        qq_pclgen$stacklooplabels(&lab_a,&lab_a,&lab_d);
    }
    else {
        lab_d = qq_pcllib$createfwdlabel();
    }
;
    elselab = qq_pcllib$createfwdlabel();
    qq_pclgen$evalunit(pindex,(i64)1);
    qq_pcllib$genpc_int2((i64)49,n,a);
    for (i=(i64)1;i<=n;++i) {
L822 :;
        qq_pcllib$genpc_lab((i64)48,(i64)0);
        labels[(i)-1] = (qq_pcllib$pcllast + (i64)1);
L823 :;
    }
L824 :;
    ;
    qq_pcllib$genpc_lab((i64)48,(i64)0);
    labels[((n + (i64)1))-1] = (qq_pcllib$pcllast + (i64)1);
    wt = pwhenthen;
    L825 :;
    while (!!(wt)) {
        labstmt = qq_pcllib$definelabel();
        w = (*wt).a;
        L828 :;
        while (!!(w)) {
                        {i64 $temp = (i64)(*w).tag;
if (($temp==(i64)183)) {
                x0 = qq_pclgen$getconstvalue((*w).a);
                y = qq_pclgen$getconstvalue((*w).b);
            }
            else if (($temp==(i64)45)) {
                x0 = (y = (*w).value);
            }
            else if (($temp==(i64)37)) {
                x0 = (y = (i64)(*w).mode);
            }
            };
            for (x=x0;x<=y;++x) {
L831 :;
                i = (x - offset);
                if (!!((*labels[(i)-1]))) {
                    msysc$m_print_startcon();
                    msysc$m_print_i64(x,NULL);
                    msysc$m_print_c8((u64)(u8)x,NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    qq_lib$gerror((byte*)"Dupl switch value",0);
                }
;
                (*labels[(i)-1]) = labstmt;
L832 :;
            }
L833 :;
            ;
            w = (*w).nextunit;
L829 :;
        }
L830 :;
        ;
        qq_pclgen$evalunit((*wt).b,res);
        if (!(!!(loopsw))) {
            qq_pclgen$genjumpl(lab_d);
        }
        else {
            qq_pclgen$genjumpl(lab_a);
        }
;
        wt = (*wt).nextunit;
L826 :;
    }
L827 :;
    ;
    qq_pcllib$definefwdlabel(&elselab);
    if (!!(pelse)) {
        qq_pclgen$evalunit(pelse,res);
    }
;
    if (!!(loopsw)) {
        qq_pclgen$genjumpl(lab_a);
        qq_pcllib$definefwdlabel(&lab_d);
        qq_pclgen$unstacklooplabels();
    }
    else {
        qq_pcllib$definefwdlabel(&lab_d);
    }
;
    for (i=(i64)1;i<=n;++i) {
L834 :;
        if (((*labels[(i)-1]) == (i64)0)) {
            (*labels[(i)-1]) = elselab;
        }
;
L835 :;
    }
L836 :;
    ;
    (*labels[((n + (i64)1))-1]) = elselab;
}

static void qq_pclgen$do_makerecordkv(i64 m,i64 nkeyvals,struct qq_decls$unitrec *(*kvlist)[]) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  plist[400];
        i64 nfields;
        i64 index;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  f;
        struct qq_decls$strec *  k;
        i64 i;
    d = qq_tables$ttnamedef[(m)];
    e = (*d).deflist;
    nfields = (i64)0;
    L837 :;
    while (!!(e)) {
        if ((((i64)(*e).nameid == (i64)11 || (i64)(*e).nameid == (i64)12) && ((*e).atfield == 0))) {
            ++(nfields);
            plist[(nfields)-1] = 0;
        }
;
L838 :;
        e = (*e).nextdef;
L840 :;
            }
L839 :;
    ;
    for (i=(i64)1;i<=nkeyvals;++i) {
L841 :;
        k = (*(*(*kvlist)[(i)-1]).a).def;
        p = (*(*kvlist)[(i)-1]).b;
        e = (*d).deflist;
        f = 0;
        L844 :;
        while (!!(e)) {
            if ((((i64)(*e).nameid == (i64)11 || (i64)(*e).nameid == (i64)12) && ((*e).firstdupl == k))) {
                f = e;
                goto L846 ;
            }
;
L845 :;
            e = (*e).nextdef;
L847 :;
                    }
L846 :;
        ;
        if (!(!!(f))) {
            qq_lib$gerror_s((byte*)"Can't find field:",(*k).name,0);
        }
;
        index = (i64)(*f).index;
        if (!!(plist[(index)-1])) {
            qq_lib$gerror_s((byte*)"Dupl key:",(*k).name,0);
        }
;
        plist[(index)-1] = p;
L842 :;
    }
L843 :;
    ;
    for (i=(i64)1;i<=nfields;++i) {
L848 :;
        if (!!(plist[(i)-1])) {
            qq_pclgen$evalunit(plist[(i)-1],(i64)1);
        }
        else {
            qq_pcllib$genpc_int((i64)19,(i64)0);
        }
;
L849 :;
    }
L850 :;
    ;
    qq_pcllib$genpc_int2((i64)74,nfields,m);
}

static void qq_pclgen$do_idiv(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 n;
    qq_pclgen$evalunit(a,(i64)1);
    if ((((i64)(*b).tag == (i64)45) && !!((n = qq_lib$ispoweroftwo((*b).value))))) {
        qq_pcllib$genpc_int((i64)19,n);
        qq_pcllib$genpc((i64)167);
    }
    else {
        qq_pclgen$evalunit(b,(i64)1);
        qq_pcllib$genpc((i64)160);
    }
;
}

static void qq_pclgen$do_irem(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 n;
        u64 m;
    qq_pclgen$evalunit(a,(i64)1);
    if ((((i64)(*b).tag == (i64)45) && !!((n = qq_lib$ispoweroftwo((*b).value))))) {
        m = ~(((u64)18446744073709551615u << n));
        qq_pcllib$genpc_int((i64)19,(i64)m);
        qq_pcllib$genpc((i64)163);
    }
    else {
        qq_pclgen$evalunit(b,(i64)1);
        qq_pcllib$genpc((i64)161);
    }
;
}

static void qq_pclgen$do_map(struct qq_decls$unitrec *p,struct qq_decls$unitrec *popcode,struct qq_decls$unitrec *x) {
        i64 lab;
    qq_pclgen$evalunit(x,(i64)1);
    if (!!((*x).nextunit)) {
        qq_pclgen$evalunit((*x).nextunit,(i64)1);
    }
;
    qq_pclgen$evalunit(popcode,(i64)1);
    qq_pcllib$genpc((!!((*x).nextunit) ? (i64)215 : (i64)214));
    lab = qq_pcllib$createfwdlabel();
    qq_pcllib$genpc_lab((i64)36,lab);
    qq_pcllib$genpc((i64)1);
    qq_pcllib$definefwdlabel(&lab);
}

static void qq_pclgen$pushstring(u8 *s,i64 length) {
        struct qq_decls$stringrec *  ps;
    qq_pcllib$genpc((i64)24);
    ps = (struct qq_decls$stringrec *)mlib$pcm_alloc((i64)16);
    (*ps).svalue = s;
    (*ps).length = length;
    qq_pcllib$genopnd_int((i64)ps);
}

// START
void qq_pclgen$start(void) {

}

// START
void qq_pcllib$start(void) {

        i64 nn;
        i64 i;
        i64 j;
    for (i=(i64)1;i<=(i64)262;++i) {
L851 :;
        nn = (i64)0;
        for (j=(i64)1;j<=(i64)4;++j) {
L854 :;
            if (((i64)qq_tables$pclfmt[(i)][(j)-1] == (i64)0)) {
                goto L856 ;
            }
;
            ++(nn);
L855 :;
        }
L856 :;
        ;
        qq_pcllib$pclnopnds[(i)] = nn;
L852 :;
    }
L853 :;
    ;
    mlib$pcm_init();
    qq_pcllib$labelalloc = (i64)8192;
    qq_pcllib$labeloffsettable = (i64 (*)[])mlib$pcm_alloc(((i64)8 * qq_pcllib$labelalloc));
}

void qq_pcllib$resetpcl(i64 sourcesize) {
        i64 pclsize;
    qq_decls$qpos = (i64)0;
    qq_pcllib$nextlabelno = (i64)0;
    qq_pcllib$pclcurrlineno = (i64)0;
    pclsize = sourcesize;
    qq_pcllib$pclalloc = (i64)1024;
    L857 :;
    while ((qq_pcllib$pclalloc < pclsize)) {
        qq_pcllib$pclalloc <<= (i64)1;
L858 :;
    }
L859 :;
    ;
    qq_pcllib$pclstart = (i64 *)mlib$pcm_alloc((qq_pcllib$pclalloc * (i64)8));
    qq_pcllib$pclnext = qq_pcllib$pclstart;
    qq_pcllib$pclend = ((qq_pcllib$pclstart + qq_pcllib$pclalloc) - (i64)16);
    qq_pcllib$pcllast = 0;
    qq_pcllib$pclsrcstart = (i32 *)mlib$pcm_alloc((qq_pcllib$pclalloc * (i64)4));
    qq_pcllib$pclsrcnext = qq_pcllib$pclsrcstart;
}

void qq_pcllib$genpc(i64 opc) {
    if ((qq_pcllib$pclnext >= qq_pcllib$pclend)) {
        qq_pcllib$extendpcldata();
    }
;
    (*qq_pcllib$pclnext) = opc;
    qq_pcllib$pcllast = qq_pcllib$pclnext;
    (*qq_pcllib$pclsrcnext) = qq_decls$qpos;
    ++(qq_pcllib$pclnext);
    ++(qq_pcllib$pclsrcnext);
    qq_pcllib$labelflag = (i64)0;
}

void qq_pcllib$genopnd_int(i64 x) {
    (*(qq_pcllib$pclnext)++) = x;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genopnd_name(struct qq_decls$strec *d) {
    (*(qq_pcllib$pclnext)++) = (i64)d;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genpc_int(i64 opc,i64 a) {
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = a;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genpc_int2(i64 opc,i64 a,i64 b) {
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = a;
    (*(qq_pcllib$pclnext)++) = b;
    qq_pcllib$pclsrcnext += (i64)2;
}

void qq_pcllib$genpc_int4(i64 opc,i64 a,i64 b,i64 c,i64 d) {
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = a;
    (*(qq_pcllib$pclnext)++) = b;
    (*(qq_pcllib$pclnext)++) = c;
    (*(qq_pcllib$pclnext)++) = d;
    qq_pcllib$pclsrcnext += (i64)4;
}

void qq_pcllib$genpc_name(i64 opc,struct qq_decls$strec *d) {
    if ((((((*qq_pcllib$pcllast) == (i64)14) && (opc == (i64)10)) && !(!!(qq_pcllib$labelflag))) && ((*(qq_pcllib$pcllast + (i64)1)) == (i64)d))) {
        (*qq_pcllib$pcllast) = (i64)16;
        return;
    }
;
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = (i64)d;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genopnd_strz(u8 *s) {
    (*(qq_pcllib$pclnext)++) = (i64)s;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genopnd_str(struct qq_decls$objrec *s) {
    (*(qq_pcllib$pclnext)++) = (i64)s;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genopnd_obj(struct qq_decls$objrec *p) {
    (*(qq_pcllib$pclnext)++) = (i64)p;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genpc_real(i64 opc,r64 x) {
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = *(i64*)&x;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genpc_lab(i64 opc,i64 a) {
    qq_pcllib$genpc(opc);
    qq_pcllib$genopnd_lab(a);
}

void qq_pcllib$genopnd_lab(i64 a) {
        i64 lastpc;
    if ((a >= (i64)0)) {
        (*(qq_pcllib$pclnext)++) = a;
        ++(qq_pcllib$pclsrcnext);
        return;
    }
;
    a = -(a);
    lastpc = (*qq_pcllib$labeloffsettable)[(a)-1];
    (*qq_pcllib$labeloffsettable)[(a)-1] = (qq_pcllib$pclnext - qq_pcllib$pclstart);
    (*(qq_pcllib$pclnext)++) = lastpc;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$gencomment(u8 *s) {
    qq_pcllib$genpc((i64)7);
    qq_pcllib$genopnd_strz(mlib$pcm_copyheapstring(s));
}

static void qq_pcllib$extendpcldata(void) {
        i64 newpclalloc;
        i64 *  newpclstart;
        i32 *  newpclsrcstart;
    newpclalloc = (qq_pcllib$pclalloc * (i64)2);
    newpclstart = (i64 *)mlib$pcm_alloc(((i64)8 * newpclalloc));
    newpclsrcstart = (i32 *)mlib$pcm_alloc(((i64)4 * newpclalloc));
    memcpy(newpclstart,qq_pcllib$pclstart,(u64)((qq_pcllib$pclnext - qq_pcllib$pclstart) * (i64)8));
    memcpy(newpclsrcstart,qq_pcllib$pclsrcstart,(u64)((qq_pcllib$pclnext - qq_pcllib$pclstart) * (i64)4));
    qq_pcllib$pclnext = (newpclstart + (qq_pcllib$pclnext - qq_pcllib$pclstart));
    qq_pcllib$pclend = ((newpclstart + newpclalloc) - (i64)10);
    qq_pcllib$pcllast = (newpclstart + (qq_pcllib$pcllast - qq_pcllib$pclstart));
    qq_pcllib$pclsrcnext = (newpclsrcstart + (qq_pcllib$pclsrcnext - qq_pcllib$pclsrcstart));
    mlib$pcm_free(qq_pcllib$pclstart,(qq_pcllib$pclalloc * (i64)8));
    mlib$pcm_free(qq_pcllib$pclsrcstart,(qq_pcllib$pclalloc * (i64)4));
    qq_pcllib$pclstart = newpclstart;
    qq_pcllib$pclalloc = newpclalloc;
    qq_pcllib$pclsrcstart = newpclsrcstart;
}

void qq_pcllib$extendlabeltable(void) {
        i64 newlabelalloc;
        i64 (*newlabeltable)[];
    newlabelalloc = (qq_pcllib$labelalloc * (i64)2);
    newlabeltable = (i64 (*)[])mlib$pcm_alloc(((i64)8 * newlabelalloc));
    memcpy(newlabeltable,qq_pcllib$labeloffsettable,(u64)(qq_pcllib$labelalloc * (i64)8));
    mlib$pcm_free(qq_pcllib$labeloffsettable,(qq_pcllib$labelalloc * (i64)8));
    qq_pcllib$labeloffsettable = newlabeltable;
    qq_pcllib$labelalloc = newlabelalloc;
}

i64 qq_pcllib$definelabel(void) {
    if ((qq_pcllib$nextlabelno >= qq_pcllib$labelalloc)) {
        qq_pcllib$extendlabeltable();
    }
;
    ++(qq_pcllib$nextlabelno);
    (*qq_pcllib$labeloffsettable)[(qq_pcllib$nextlabelno)-1] = (qq_pcllib$pclnext - qq_pcllib$pclstart);
    qq_pcllib$labelflag = (i64)1;
    return (qq_pcllib$pclnext - qq_pcllib$pclstart);
}

i64 qq_pcllib$createfwdlabel(void) {
    if ((qq_pcllib$nextlabelno >= qq_pcllib$labelalloc)) {
        qq_pcllib$extendlabeltable();
    }
;
    ++(qq_pcllib$nextlabelno);
    (*qq_pcllib$labeloffsettable)[(qq_pcllib$nextlabelno)-1] = (i64)0;
    return -(qq_pcllib$nextlabelno);
}

void qq_pcllib$definefwdlabel(i64 *lab) {
        i64 index;
        i64 laboffset;
        i64 pc;
        i64 nextpc;
    index = (*lab);
    if ((index >= (i64)0)) {
        qq_lib$gerror((byte*)"deffwdlabel?",0);
    }
;
    index = -(index);
    laboffset = (qq_pcllib$pclnext - qq_pcllib$pclstart);
    pc = (*qq_pcllib$labeloffsettable)[(index)-1];
    L860 :;
    while (!!(pc)) {
        nextpc = (*(qq_pcllib$pclstart + pc));
        (*(qq_pcllib$pclstart + pc)) = laboffset;
        pc = nextpc;
L861 :;
    }
L862 :;
    ;
    (*qq_pcllib$labeloffsettable)[(index)-1] = laboffset;
    (*lab) = laboffset;
    qq_pcllib$labelflag = (i64)1;
}

void qq_records$var_make_record(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 rectype) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  b;
        i64 m;
        i64 $av_1;
    p = qq_records$obj_new_record(rectype,0);
    b = (*p).varptr;
    m = qq_tables$ttlength[(rectype)];
    if ((n < m)) {
        qq_lib$pcerror((byte*)"Too few elements");
    }
    else if ((n > m)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=",NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_str((byte*)"M=",NULL);
        msysc$m_print_i64(m,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$pcerror((byte*)"Too many elements");
    }
;
    $av_1 = n;
    while ($av_1-- > 0) {
L863 :;
        (*b) = (*a);
        ++(a);
        ++(b);
L864 :;
    }
L865 :;
    ;
    (*dest).tagx = (i64)268;
    (*p).usertag = rectype;
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_records$obj_new_record(i64 m,struct qq_decls$varrec *defval) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  a;
        i64 n;
        i64 $av_1;
        i64 $av_2;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    n = qq_tables$ttlength[(m)];
    (*p).objtype = (i64)0;
    if (!!(n)) {
        (*p).varptr = (a = (struct qq_decls$varrec *)mlib$pcm_alloc((n * (i64)16)));
        if ((!!(defval) && ((i64)(*defval).tag != (i64)0))) {
            a = (*p).varptr;
            $av_1 = n;
            while ($av_1-- > 0) {
L866 :;
                (*a) = (*defval);
                if (!!((i64)(*a).hasref)) {
                    ++((*(*a).objptr).refcount);
                }
;
                ++(a);
L867 :;
            }
L868 :;
            ;
        }
        else {
            $av_2 = n;
            while ($av_2-- > 0) {
L869 :;
                (*a).tagx = (i64)1;
                (*a).value = (i64)0;
                ++(a);
L870 :;
            }
L871 :;
            ;
        }
;
    }
;
    return p;
}

void qq_records$obj_free_record(struct qq_decls$objrec *p) {
        struct qq_decls$varrec *  q;
        i64 $av_1;
    q = (*p).varptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L872 :;
        if (!!((i64)(*q).hasref)) {
            qq_vars$var_unshareu(q);
        }
;
        ++(q);
L873 :;
    }
L874 :;
    ;
    if (!!((*p).length)) {
        mlib$pcm_free((*p).varptr,((*p).length * (i64)16));
    }
;
    mlib$pcm_free32(p);
}

void qq_records$var_dupl_record(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$varrec *  plist;
        struct qq_decls$varrec *  qlist;
        i64 length;
        i64 $av_1;
    p = (*a).objptr;
    q = qq_vars$obj_new();
    (*q) = (*p);
    (*q).refcount = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,(u64)1u);
    (*a).objptr = q;
    length = qq_tables$ttlength[((i64)(*p).usertag)];
    if ((length == (i64)0)) {
        return;
    }
;
    qlist = ((*q).varptr = (struct qq_decls$varrec *)mlib$pcm_alloc((length * (i64)16)));
    plist = (*p).varptr;
    $av_1 = length;
    while ($av_1-- > 0) {
L875 :;
        (*qlist) = (*plist);
        if (((i64)(*qlist).tag == (i64)12)) {
            if (!!((i64)(*qlist).hasref)) {
                ++((*(*qlist).objptr).refcount);
            }
;
        }
        else {
            if (!!((i64)(*qlist).hasref)) {
                qq_vars$var_duplu(qlist);
            }
;
        }
;
        ++(qlist);
        ++(plist);
L876 :;
    }
L877 :;
    ;
}

i64 qq_records$var_equal_record(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
        struct qq_decls$varrec *  a;
        struct qq_decls$varrec *  b;
        i64 $av_1;
    px = (*x).objptr;
    py = (*y).objptr;
    if (((i64)(*px).usertag != (i64)(*py).usertag)) {
        return (i64)0;
    }
;
    if ((px == py)) {
        return (i64)1;
    }
;
    a = (*px).varptr;
    b = (*py).varptr;
    $av_1 = qq_tables$ttlength[((i64)(*px).usertag)];
    while ($av_1-- > 0) {
L878 :;
        if ((qq_vars$var_equal(a,b) == (i64)0)) {
            return (i64)0;
        }
;
        ++(a);
        ++(b);
L879 :;
    }
L880 :;
    ;
    return (i64)1;
}

void qq_records$var_getix_record(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
        u64 offset;
    q = (*a).objptr;
    offset = (u64)(index - (i64)1);
    if ((offset >= (u64)qq_tables$ttlength[((i64)(*q).usertag)])) {
        qq_lib$pcerror((byte*)"record[int] bounds");
    }
;
    (*a) = (*((*q).varptr + (i64)offset));
    if (!!((i64)(*a).hasref)) {
        ++((*(*a).objptr).refcount);
    }
;
}

void qq_records$var_putix_record(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  dest;
        struct qq_decls$objrec *  q;
        u64 offset;
    q = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*q).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    offset = (u64)(index - (i64)1);
    if ((offset >= (u64)qq_tables$ttlength[((i64)(*q).usertag)])) {
        qq_lib$pcerror((byte*)"rec[int] bounds");
    }
;
    dest = ((*q).varptr + (i64)offset);
    if (!!((i64)(*dest).hasref)) {
        qq_vars$var_unshareu(dest);
    }
;
    (*dest) = (*x);
}

void qq_records$var_getixref_record(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *dest) {
        struct qq_decls$varrec *  p;
        struct qq_decls$objrec *  q;
        u64 offset;
    q = (*a).objptr;
    offset = (u64)(index - (i64)1);
    if ((offset >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"^rec[int] bounds");
    }
;
    p = ((*q).varptr + (i64)offset);
    (*dest).tagx = (i64)14;
    (*dest).varptr = p;
}

// START
void qq_records$start(void) {

}

void qq_resolve$rx_module(struct qq_decls$filerec *pm) {
    qq_decls$currmodule = pm;
    qq_decls$stcurrproc = (qq_decls$stcurrmodule = (*qq_decls$currmodule).def);
    qq_resolve$nprocs = (i64)0;
    qq_resolve$rx_passdef(qq_decls$stprogram,qq_decls$stcurrmodule);
    if ((qq_resolve$nprocs == (i64)0)) {
        qq_resolve$rx_unit(qq_decls$stcurrmodule,(*qq_decls$currmodule).ast);
    }
    else if (!!((*qq_decls$currmodule).ast)) {
        qq_resolve$rx_unit(qq_decls$stcurrmodule,(*qq_decls$currmodule).ast);
    }
;
}

void qq_resolve$rx_passdef(struct qq_decls$strec *owner,struct qq_decls$strec *p) {
        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)3)) {
        qq_resolve$rx_deflist(p,(*p).deflist,(i64)0);
    }
    else if (($temp==(i64)5) || ($temp==(i64)6)) {
        ++(qq_resolve$nprocs);
        qq_resolve$fixmode((struct qq_decls$strec *)owner,(struct qq_decls$strec *)p);
        qq_resolve$rx_deflist(p,(*p).deflist,(i64)0);
        qq_decls$stcurrproc = p;
        qq_resolve$rx_unit(p,(*p).code);
        qq_decls$stcurrproc = qq_decls$stcurrmodule;
        qq_resolve$rx_deflist(p,(*p).deflist,(i64)1);
    }
    else if (($temp==(i64)7)) {
        qq_resolve$fixmode((struct qq_decls$strec *)owner,(struct qq_decls$strec *)p);
        qq_resolve$rx_deflist(p,(*p).deflist,(i64)0);
    }
    else if (($temp==(i64)18) || ($temp==(i64)13) || ($temp==(i64)14) || ($temp==(i64)15)) {
        qq_resolve$fixmode((struct qq_decls$strec *)owner,(struct qq_decls$strec *)p);
        if (!!((*p).code)) {
            qq_resolve$rx_unit(owner,(*p).code);
        }
;
    }
    else if (($temp==(i64)10) || ($temp==(i64)9)) {
        qq_resolve$fixmode((struct qq_decls$strec *)owner,(struct qq_decls$strec *)p);
        qq_resolve$rx_deflist(p,(*p).deflist,(i64)0);
    }
    };
}

void qq_resolve$rx_deflist(struct qq_decls$strec *owner,struct qq_decls$strec *p,i64 doanon) {
    L881 :;
    while (!!(p)) {
        if (((!!(doanon) && ((i64)(*p).nameid == (i64)6)) || ((doanon == (i64)0) && ((i64)(*p).nameid != (i64)6)))) {
            qq_resolve$rx_passdef(owner,p);
        }
;
        p = (*p).nextdef;
L882 :;
    }
L883 :;
    ;
}

void qq_resolve$rx_unit(struct qq_decls$strec *owner,struct qq_decls$unitrec *p) {
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  a;
        struct qq_decls$unitrec *  b;
        i64 n;
        i64 flags;
        i64 oldnoexpand;
        i64 oldsymbolmode;
        i64 nk;
        struct qq_decls$filerec *  pm;
    a = (*p).a;
    b = (*p).b;
    qq_decls$qpos = (i64)(*p).pos;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)43)) {
        qq_resolve$resolvename(owner,p,(i64)0);
        if (((((i64)(*p).tag == (i64)43) && ((i64)(*(*p).def).nameid == (i64)22)) && !(!!(qq_resolve$noexpand)))) {
            ++(qq_resolve$macrolevels);
            qq_resolve$expandmacro(p,p,0);
            qq_resolve$rx_unit(owner,p);
            --(qq_resolve$macrolevels);
        }
;
    }
    else if (($temp==(i64)4)) {
        qq_resolve$rx_unit(owner,b);
    }
    else if (($temp==(i64)49)) {
        qq_resolve$resolvedot(owner,p);
    }
    else if (($temp==(i64)30)) {
        if (((i64)(*a).tag == (i64)43)) {
            oldnoexpand = qq_resolve$noexpand;
            qq_resolve$noexpand = (i64)1;
            qq_resolve$rx_unit(owner,a);
            qq_resolve$noexpand = oldnoexpand;
        }
        else {
            qq_resolve$rx_unit(owner,a);
        }
;
        qq_resolve$rx_unitlist(owner,b);
        if (((i64)(*a).tag == (i64)37)) {
            (*p).tag = (i64)39;
            (*p).a = b;
            (*p).b = 0;
            (*p).mode = (i64)(*a).mode;
            nk = (i64)0;
            (*p).a = qq_lib$createunit1((i64)185,b);
            n = (i64)0;
            L884 :;
            while (!!(b)) {
                if (((i64)(*b).tag == (i64)4)) {
                    ++(nk);
                    (*b).tag = (i64)5;
                }
;
                ++(n);
                b = (*b).nextunit;
L885 :;
            }
L886 :;
            ;
            if ((!!(nk) && (nk != n))) {
                qq_lib$rxerror((byte*)"Mixed key:value",0);
            }
;
            if (!!((*a).nextunit)) {
                n = -(n);
            }
;
            (*(*p).a).length = n;
        }
        else if ((((i64)(*a).tag == (i64)43) && ((i64)(*(*a).def).nameid == (i64)22))) {
            ++(qq_resolve$macrolevels);
            qq_resolve$expandmacro(p,a,b);
            qq_resolve$rx_unit(owner,p);
            --(qq_resolve$macrolevels);
        }
;
    }
    else if (($temp==(i64)137) || ($temp==(i64)138) || ($temp==(i64)139) || ($temp==(i64)140) || ($temp==(i64)141) || ($temp==(i64)142) || ($temp==(i64)144) || ($temp==(i64)145) || ($temp==(i64)146) || ($temp==(i64)147) || ($temp==(i64)148) || ($temp==(i64)183)) {
        qq_resolve$rx_unit(owner,a);
        if (!(!!(b))) {
            qq_lib$rxerror((byte*)"Binop missing opnd",0);
        }
;
        qq_resolve$rx_unit(owner,b);
        qq_resolve$evalbinop(p,a,b);
    }
    else if (($temp==(i64)78) || ($temp==(i64)79) || ($temp==(i64)106) || ($temp==(i64)107) || ($temp==(i64)108) || ($temp==(i64)112) || ($temp==(i64)85)) {
        qq_resolve$rx_unit(owner,a);
        qq_resolve$evalmonop(p);
    }
    else if (($temp==(i64)16) || ($temp==(i64)18)) {
        qq_resolve$resolvename(owner,a,(i64)1);
        a = (*a).nextunit;
        goto L887 ;
;
    }
    else if (($temp==(i64)39)) {
        qq_resolve$rx_unit(owner,a);
        qq_resolve$evalmonop(p);
    }
    else if (($temp==(i64)44)) {
        oldnoexpand = qq_resolve$noexpand;
        oldsymbolmode = qq_resolve$symbolmode;
        qq_resolve$noexpand = (i64)1;
        qq_resolve$symbolmode = (i64)1;
        qq_resolve$rx_unit(owner,a);
        qq_resolve$noexpand = oldnoexpand;
        qq_resolve$symbolmode = oldsymbolmode;
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)43)) {
        }
        else if (($temp==(i64)37)) {
            d = qq_tables$ttnamedef[((i64)(*a).mode)];
            if (!!(d)) {
                (*a).def = d;
                (*a).tag = (i64)43;
            }
            else {
                qq_lib$rxerror((byte*)"T.$?",0);
            }
;
        }
        else {
            qq_show$printunit((struct qq_decls$unitrec *)a,(i64)0,(byte*)"*",0);
            qq_lib$rxerror((byte*)".$ not name",0);
        }
        };
    }
    else if (($temp==(i64)48)) {
        qq_resolve$rx_unit(owner,a);
        if (((i64)(*a).tag != (i64)47)) {
            qq_lib$rxerror((byte*)"Not strconst",0);
        }
;
        pm = qq_modules$loadsourcefile((*a).svalue,(i64)0);
        (*a).svalue = (*pm).text;
        (*a).slength = ((*pm).size - (i64)1);
        qq_lib$deleteunit(p,a);
    }
    else {
        //doabc:
L887 :;
;
        flags = (i64)qq_tables$jflags[((i64)(*p).tag)];
        if ((flags >= (i64)1)) {
            qq_resolve$rx_unitlist(owner,a);
        }
;
        if ((flags == (i64)2)) {
            qq_resolve$rx_unitlist(owner,b);
        }
;
    }
    };
}

static void qq_resolve$rx_unitlist(struct qq_decls$strec *owner,struct qq_decls$unitrec *p) {
    L888 :;
    while (!!(p)) {
        qq_resolve$rx_unit(owner,p);
        p = (*p).nextunit;
L889 :;
    }
L890 :;
    ;
}

static void qq_resolve$evalmonop(struct qq_decls$unitrec *p) {
        i64 a;
        i64 c;
        r64 x;
        r64 z;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)112)) {
        if (((i64)(*(*p).a).tag == (i64)37)) {
            c = qq_tables$ttsize[((i64)(*(*p).a).mode)];
            goto L891 ;
;
        }
;
    }
    else {
                {i64 $temp = (i64)(*(*p).a).tag;
if (($temp==(i64)45)) {
            a = (*(*p).a).value;
                        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)78)) {
                c = -(a);
            }
            else if (($temp==(i64)79)) {
                c = m$llabs(a);
            }
            else {
                return;
            }
            };
            //newint:
L891 :;
;
            qq_resolve$makeintconst((struct qq_decls$unitrec *)p,c);
        }
        else if (($temp==(i64)46)) {
            x = (*(*p).a).xvalue;
                        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)78)) {
                z = -(x);
            }
            else if (($temp==(i64)79)) {
                z = fabs(x);
            }
            else {
                return;
            }
            };
            qq_resolve$makerealconst((struct qq_decls$unitrec *)p,z);
        }
        else {
            return;
        }
        };
    }
    };
}

static void qq_resolve$evalbinop(struct qq_decls$unitrec *p,struct qq_decls$unitrec *lhs,struct qq_decls$unitrec *rhs) {
        i64 a;
        i64 b;
        i64 c;
        r64 x;
        r64 y;
        r64 z;
        {i64 $temp = (((i64)(*lhs).tag << (i64)16) | (i64)(*rhs).tag);
if (($temp==(i64)2949165)) {
        a = (*lhs).value;
        b = (*rhs).value;
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)137)) {
            c = (a + b);
        }
        else if (($temp==(i64)138)) {
            c = (a - b);
        }
        else if (($temp==(i64)139)) {
            c = (a * b);
        }
        else if (($temp==(i64)141)) {
            if ((b == (i64)0)) {
                qq_lib$rxerror((byte*)"x/0",0);
            }
;
            c = (a / b);
        }
        else {
            return;
        }
        };
        qq_resolve$makeintconst((struct qq_decls$unitrec *)p,c);
    }
    else if (($temp==(i64)3014702)) {
        x = (*lhs).xvalue;
        y = (*rhs).xvalue;
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)137)) {
            z = (x + y);
        }
        else if (($temp==(i64)138)) {
            z = (x - y);
        }
        else if (($temp==(i64)139)) {
            z = (x * y);
        }
        else if (($temp==(i64)140)) {
            z = (x / y);
        }
        else {
            return;
        }
        };
        qq_resolve$makerealconst((struct qq_decls$unitrec *)p,z);
    }
    else {
        return;
    }
    };
}

static void qq_resolve$makeintconst(struct qq_decls$unitrec *p,i64 value) {
    (*p).tag = (i64)45;
    (*p).a = ((*p).b = 0);
    (*p).value = value;
    (*p).mode = (i64)1;
}

static void qq_resolve$makerealconst(struct qq_decls$unitrec *p,r64 xvalue) {
    (*p).tag = (i64)46;
    (*p).a = ((*p).b = 0);
    (*p).xvalue = xvalue;
    (*p).mode = (i64)2;
}

void qq_resolve$resolvename(struct qq_decls$strec *owner,struct qq_decls$unitrec *p,i64 mode) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        struct qq_decls$unitrec *  q;
        i64 moduleno;
    d = (*p).def;
    moduleno = msysc$m_getdotslice((i64)(*p).pos,(i64)24,(i64)31);
    if (((i64)(*d).nameid != (i64)0)) {
        return;
    }
;
    e = qq_resolve$resolvetopname(owner,d,moduleno,qq_resolve$allowmodname);
    if (!(!!(e))) {
                {i64 $temp = (i64)(*owner).nameid;
if (($temp==(i64)5) || ($temp==(i64)6)) {
            e = ((*p).def = qq_names$addsymbol(owner,d,(i64)14,(i64)0));
        }
        else if (($temp==(i64)3)) {
            e = ((*p).def = qq_names$addsymbol(owner,d,(i64)13,(i64)0));
        }
        else {
            qq_lib$rxerror_s((byte*)"Undefined: #",(*d).name,p);
        }
        };
    }
    else {
        //$else:
L892 :;
;
        //retry:
L893 :;
;
        (*p).def = e;
                {i64 $temp = (i64)(*e).nameid;
if (($temp==(i64)18)) {
            if (!!(qq_resolve$symbolmode)) {
                return;
            }
;
            q = (*e).code;
            qq_resolve$rx_unit(owner,q);
            if (!(((i64)(*q).tag == (i64)45 || (i64)(*q).tag == (i64)46 || (i64)(*q).tag == (i64)47))) {
                qq_lib$rxerror_s((byte*)"Not const expr: #",qq_tables$jtagnames[((i64)(*q).tag)],0);
            }
;
            (*e).mode = (i64)(*q).mode;
            (*p).tag = (i64)(*q).tag;
            (*p).value = (*q).value;
            (*p).mode = (i64)(*q).mode;
            (*p).slength = (*q).slength;
        }
        else if (($temp==(i64)19)) {
            if (!!(qq_resolve$symbolmode)) {
                return;
            }
;
            (*p).tag = (i64)45;
            (*p).value = (i64)(*e).index;
            (*p).mode = (i64)1;
        }
        else if (($temp==(i64)13)) {
        }
        else if (($temp==(i64)10) || ($temp==(i64)9)) {
            (*p).tag = (i64)37;
            (*p).mode = (i64)(*(*p).def).mode;
        }
        else if (($temp==(i64)21)) {
            qq_lib$rxerror((byte*)"FOUND LINK",p);
        }
        else if (($temp==(i64)14) || ($temp==(i64)15)) {
            if ((((i64)(*qq_decls$stcurrproc).nameid == (i64)6) && ((i64)(*(*e).owner).nameid != (i64)6))) {
                qq_lib$rxerror((byte*)"Accessing transient vars from {}",0);
            }
;
        }
        };
    }
;
}

struct qq_decls$strec *qq_resolve$resolvetopname(struct qq_decls$strec *owner,struct qq_decls$strec *stnewname,i64 moduleno,i64 allowmod) {
        i64 extcount;
        i64 subprogno;
        struct qq_decls$strec *  p;
        struct qq_decls$strec *  q;
        struct qq_decls$strec *  powner;
        struct qq_decls$strec *  extdef;
        struct qq_decls$strec *  moddef;
        struct qq_decls$strec *  ambiglist[10];
        i64 i;
    if (((i64)(*owner).nameid == (i64)6)) {
        q = (*owner).deflist;
        L894 :;
        while (!!(q)) {
            if (((*q).firstdupl == stnewname)) {
                return q;
            }
;
L895 :;
            q = (*q).nextdef;
L897 :;
                    }
L896 :;
        ;
        owner = (*owner).owner;
    }
;
    if (((i64)(*owner).nameid == (i64)5)) {
        q = (*owner).deflist;
        L898 :;
        while (!!(q)) {
            if (((*q).firstdupl == stnewname)) {
                return q;
            }
;
L899 :;
            q = (*q).nextdef;
L901 :;
                    }
L900 :;
        ;
    }
;
    p = (*stnewname).nextdupl;
    subprogno = (i64)(*qq_decls$modules[(moduleno)]).subprogno;
    extcount = (i64)0;
    extdef = (moddef = 0);
    L902 :;
    while (!!(p)) {
        powner = (*p).owner;
                {i64 $temp = (i64)(*powner).nameid;
if (($temp==(i64)3)) {
            if (((i64)(*powner).moduleno == moduleno)) {
                return p;
            }
            else if (!!(msysc$m_getdotslice((i64)(*p).flags,(i64)0,(i64)1))) {
                if (((((i64)(*qq_decls$modules[((i64)(*powner).moduleno)]).subprogno == subprogno) || ((i64)msysc$m_getdotslice((i64)(*p).flags,(i64)0,(i64)1) == (i64)2)) || !!(msysc$m_getdotindex((i64)(*p).flags,(i64)2)))) {
                    ++(extcount);
                    extdef = p;
                    if ((extcount < (i64)10)) {
                        ambiglist[(extcount)-1] = extdef;
                    }
;
                }
;
            }
;
        }
        else if (($temp==(i64)10)) {
            if (((powner == owner) || (powner == (*owner).owner))) {
                return p;
            }
;
        }
        else if (($temp==(i64)1)) {
                        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)3) || ($temp==(i64)2)) {
                if (!!(allowmod)) {
                    moddef = p;
                }
;
            }
            else if (($temp==(i64)22)) {
                return p;
            }
            };
        }
        };
L903 :;
        p = (*p).nextdupl;
L905 :;
            }
L904 :;
    ;
    if (!!(extdef)) {
        if ((extcount > (i64)1)) {
            for (i=(i64)1;i<=extcount;++i) {
L906 :;
                extdef = ambiglist[(i)-1];
                msysc$m_print_startcon();
                msysc$m_print_i64(i,NULL);
                msysc$m_print_str((*(*extdef).owner).name,NULL);
                msysc$m_print_str(qq_tables$namenames[((i64)(*(*extdef).owner).nameid)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
L907 :;
            }
L908 :;
            ;
            qq_lib$rxerror_s((byte*)"Ambiguous ext name: #",(*extdef).name,0);
        }
;
        return extdef;
    }
;
    return moddef;
}

static void qq_resolve$resolvedot(struct qq_decls$strec *owner,struct qq_decls$unitrec *p) {
        struct qq_decls$strec *  rdef;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  newd;
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  fielddef;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 nfields;
        i64 oldallowmod;
    if (!!(qq_resolve$symbolmode)) {
        qq_resolve$resolvedot_sym(owner,p);
        return;
    }
;
    q = (*p).a;
    r = (*p).b;
    rdef = (*r).def;
    oldallowmod = qq_resolve$allowmodname;
    qq_resolve$allowmodname = (i64)((i64)(*q).tag == (i64)43);
    qq_resolve$rx_unit(owner,q);
    qq_resolve$allowmodname = oldallowmod;
        {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)43)) {
        d = (*q).def;
    }
    else if (($temp==(i64)37)) {
        d = (*q).def;
        goto L909 ;
;
    }
    else {
        rdef = (*r).def;
        goto L910 ;
;
    }
    };
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)3) || ($temp==(i64)10) || ($temp==(i64)5) || ($temp==(i64)7)) {
        //dotype:
L909 :;
;
        newd = qq_resolve$finddupl(d,rdef);
        if (!!(newd)) {
            switch ((i64)(*newd).nameid) {
            case 19:;
                {
                    (*p).tag = (i64)45;
                    (*p).value = (i64)(*newd).index;
                    (*p).mode = (i64)1;
                }
                break;
            case 18:;
                {
                    q = (*newd).code;
                                        {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)45)) {
                        (*p).tag = (i64)45;
                        (*p).a = ((*p).b = 0);
                        (*p).value = (*q).value;
                        (*p).mode = (i64)(*newd).mode;
                    }
                    else {
                        qq_lib$rxerror((byte*)"Rxdot:const?",p);
                    }
                    };
                }
                break;
            case 10:;
                {
                    (*p).tag = (i64)37;
                    (*p).mode = (i64)(*newd).mode;
                    (*p).def = newd;
                }
                break;
            case 13:;
                {
                    (*p).tag = (i64)43;
                    (*p).def = newd;
                }
                break;
            case 5:;
            case 7:;
                {
                    (*p).tag = (i64)43;
                    (*p).a = ((*p).b = 0);
                    (*p).def = newd;
                }
                break;
            case 22:;
                {
                    if ((((i64)(*e).nameid == (i64)22) && !(!!(qq_resolve$noexpand)))) {
                        ++(qq_resolve$macrolevels);
                        qq_resolve$expandmacro(p,p,0);
                        qq_resolve$rx_unit(owner,p);
                        --(qq_resolve$macrolevels);
                    }
;
                }
                break;
            default: {
                msysc$m_print_startcon();
                msysc$m_print_str(qq_tables$namenames[((i64)(*newd).nameid)],NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)".",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((*newd).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                qq_lib$rxerror((byte*)"Rxdot:.name not allowed here",p);
            }
            } //SW
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((*d).name,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)".",NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((*rdef).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$rxerror((byte*)"Can't resolve",p);
        }
;
    }
    else if (($temp==(i64)14) || ($temp==(i64)13) || ($temp==(i64)15) || ($temp==(i64)11) || ($temp==(i64)12)) {
        //doexprdot:
L910 :;
;
        nfields = (i64)0;
        fielddef = 0;
        e = (*rdef).nextdupl;
        L911 :;
        while (!!(e)) {
                        {i64 $temp = (i64)(*e).nameid;
if (($temp==(i64)11) || ($temp==(i64)12) || ($temp==(i64)18) || ($temp==(i64)5) || ($temp==(i64)10) || ($temp==(i64)13) || ($temp==(i64)7)) {
                ++(nfields);
                fielddef = e;
            }
            };
            e = (*e).nextdupl;
L912 :;
        }
L913 :;
        ;
        if ((nfields==(i64)0)) {
            msysc$m_print_startcon();
            msysc$m_print_str((*rdef).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$rxerror((byte*)"Can't find field",0);
        }
        else {
            if (((i64)(*rdef).nameid != (i64)0)) {
                qq_lib$rxerror((byte*)"Field name not generic",0);
            }
;
        }
;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(qq_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$rxerror((byte*)"RXDOT:Unknown nameid",p);
    }
    };
}

static void qq_resolve$resolvedot_sym(struct qq_decls$strec *owner,struct qq_decls$unitrec *p) {
        struct qq_decls$strec *  rdef;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  newd;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 oldallowmod;
    q = (*p).a;
    r = (*p).b;
    rdef = (*r).def;
    oldallowmod = qq_resolve$allowmodname;
    qq_resolve$allowmodname = (i64)((i64)(*q).tag == (i64)43);
    qq_resolve$rx_unit(owner,q);
    qq_resolve$allowmodname = oldallowmod;
        {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)43)) {
        d = (*q).def;
    }
    else if (($temp==(i64)37)) {
        d = (*q).def;
        if (!!(qq_resolve$symbolmode)) {
            newd = qq_resolve$finddupl(d,rdef);
            if ((newd == 0)) {
                qq_lib$rxerror_s((byte*)"Can't resolve .",(*rdef).name,0);
            }
;
                        {i64 $temp = (i64)(*newd).nameid;
if (($temp==(i64)11) || ($temp==(i64)12)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"*******FIELD.$",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
            else {
                qq_lib$rxerror_s((byte*)".$ ON type:",qq_tables$namenames[((i64)(*newd).nameid)],0);
            }
            };
        }
;
        goto L914 ;
;
    }
    else {
        qq_lib$rxerror((byte*)"RXDOTSYM?",0);
    }
    };
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)3) || ($temp==(i64)10) || ($temp==(i64)5) || ($temp==(i64)7)) {
        //dotype:
L914 :;
;
        newd = qq_resolve$finddupl(d,rdef);
        if (!!(newd)) {
            (*p).tag = (i64)43;
            (*p).a = ((*p).b = 0);
            (*p).def = newd;
        }
        else {
            qq_lib$rxerror_s((byte*)".$ Can't resolve",(*d).name,0);
        }
;
    }
    else {
        qq_lib$rxerror_s((byte*)"RX.$: Unknown nameid:",qq_tables$namenames[((i64)(*d).nameid)],p);
    }
    };
}

struct qq_decls$strec *qq_resolve$finddupl(struct qq_decls$strec *d,struct qq_decls$strec *pdupl) {
    if (((i64)(*pdupl).nameid != (i64)0)) {
        return pdupl;
    }
;
    pdupl = (*pdupl).nextdupl;
    L915 :;
    while (!!(pdupl)) {
        if (((*pdupl).owner == d)) {
            return pdupl;
        }
;
        pdupl = (*pdupl).nextdupl;
L916 :;
    }
L917 :;
    ;
    return (struct qq_decls$strec *)0;
}

static void qq_resolve$expandmacro(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  pm;
        struct qq_decls$unitrec *  pnew;
        i64 ignoreargs;
    if ((qq_resolve$macrolevels > (i64)10)) {
        qq_lib$rxerror((byte*)"Too many macro levels (recursive macro?)",0);
    }
;
    d = (*a).def;
    pm = (*d).deflist;
    qq_resolve$nmacroparams = (i64)0;
    L918 :;
    while (!!(pm)) {
        if ((qq_resolve$nmacroparams >= (i64)50)) {
            qq_lib$rxerror((byte*)"macro param overflow",0);
        }
;
        qq_resolve$macroparams[(++(qq_resolve$nmacroparams))-1] = pm;
        qq_resolve$macroparamsgen[(qq_resolve$nmacroparams)-1] = (*pm).firstdupl;
        pm = (*pm).nextdef;
L919 :;
    }
L920 :;
    ;
    qq_resolve$nmacroargs = (i64)0;
    L921 :;
    while (!!(b)) {
        if ((qq_resolve$nmacroargs >= (i64)50)) {
            qq_lib$rxerror((byte*)"macro arg overflow",0);
        }
;
        qq_resolve$macroargs[(++(qq_resolve$nmacroargs))-1] = b;
        b = (*b).nextunit;
L922 :;
    }
L923 :;
    ;
    if ((qq_resolve$nmacroargs < qq_resolve$nmacroparams)) {
        qq_lib$rxerror((byte*)"Too few macro args",0);
    }
;
    ignoreargs = (i64)0;
    if (((qq_resolve$nmacroargs > (i64)0) && (qq_resolve$nmacroparams == (i64)0))) {
        ignoreargs = (i64)1;
        qq_resolve$nmacroargs = (qq_resolve$nmacroparams = (i64)0);
    }
    else if ((qq_resolve$nmacroargs > qq_resolve$nmacroparams)) {
        qq_lib$rxerror((byte*)"Too many macro args",0);
    }
;
    pnew = qq_resolve$copyunit((*d).code);
    if (!(!!(ignoreargs))) {
        qq_resolve$replaceunit(p,pnew);
    }
    else {
        (*p).a = pnew;
    }
;
}

static struct qq_decls$unitrec *qq_resolve$copylistunit(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  plist;
        struct qq_decls$unitrec *  plistx;
    plist = (plistx = 0);
    L924 :;
    while (!!(p)) {
        q = qq_resolve$copyunit(p);
        qq_lib$addlistunit(&plist,&plistx,q);
        p = (*p).nextunit;
L925 :;
    }
L926 :;
    ;
    return plist;
}

static struct qq_decls$unitrec *qq_resolve$copyunit(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
        struct qq_decls$strec *  d;
        i64 i;
    if ((p == 0)) {
        return 0;
    }
;
    if (((i64)(*p).tag == (i64)43)) {
        d = (*p).def;
        for (i=(i64)1;i<=qq_resolve$nmacroparams;++i) {
L927 :;
            if ((qq_resolve$macroparamsgen[(i)-1] == d)) {
                return qq_resolve$copyunit(qq_resolve$macroargs[(i)-1]);
                goto L929 ;
            }
;
L928 :;
        }
L929 :;
        ;
    }
;
    q = qq_lib$createunit0((i64)(*p).tag);
    (*q) = (*p);
    (*q).nextunit = 0;
    if (!!((i64)qq_tables$jflags[((i64)(*q).tag)])) {
        (*q).a = qq_resolve$copylistunit((*q).a);
        if (((i64)qq_tables$jflags[((i64)(*q).tag)] == (i64)2)) {
            (*q).b = qq_resolve$copylistunit((*q).b);
        }
;
    }
;
    return q;
}

static void qq_resolve$replaceunit(struct qq_decls$unitrec *p,struct qq_decls$unitrec *q) {
        struct qq_decls$unitrec *  pnext;
    pnext = (*p).nextunit;
    (*p) = (*q);
    (*p).nextunit = pnext;
}

static void qq_resolve$fixmode(struct qq_decls$strec *owner,struct qq_decls$strec *p) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        i64 m;
    m = (i64)(*p).mode;
    if ((m >= (i64)0)) {
        return;
    }
;
    m = -(m);
    if (!!(qq_tables$ttxmap[(m)])) {
        (*p).mode = qq_tables$ttxmap[(m)];
        return;
    }
;
    d = (struct qq_decls$strec *)qq_tables$ttnamedefx[(m)];
    e = (struct qq_decls$strec *)qq_resolve$resolvetopname((struct qq_decls$strec *)owner,(struct qq_decls$strec *)d,(i64)qq_tables$ttxmoduleno[(m)],(i64)0);
    if (!!(e)) {
        qq_tables$ttxmap[(m)] = (i64)(*e).mode;
        (*p).mode = (i64)(*e).mode;
    }
    else {
        qq_lib$rxerror_s((byte*)"Can't resolve type: #",(*d).name,0);
    }
;
}

static i64 qq_resolve$fixmode2(struct qq_decls$strec *owner,i64 m) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        u8 str[256];
    if ((m >= (i64)0)) {
        return m;
    }
;
    m = -(m);
    if (!!(qq_tables$ttxmap[(m)])) {
        return qq_tables$ttxmap[(m)];
    }
;
    d = (struct qq_decls$strec *)qq_tables$ttnamedefx[(m)];
    if ((owner == 0)) {
        qq_lib$rxerror((byte*)"FM2/owner",0);
    }
;
    e = (struct qq_decls$strec *)qq_resolve$resolvetopname((struct qq_decls$strec *)owner,(struct qq_decls$strec *)d,(i64)qq_tables$ttxmoduleno[(m)],(i64)0);
    if (!!(e)) {
        qq_tables$ttxmap[(m)] = (i64)(*e).mode;
        return (i64)(*e).mode;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"# in module #, line:#");
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_str((*qq_decls$modules[((i64)qq_tables$ttxmoduleno[(m)])]).name,NULL);
        msysc$m_print_end();
        ;
        qq_lib$rxerror_s((byte*)"2:Can't resolve type: #",(u8 *)str,0);
    }
;
    return (i64)0;
}

void qq_resolve$fixusertypes(void) {
        struct qq_decls$userxrec *  p;
        i64 m;
        i64 rescan;
        i64 i;
    for (i=(i64)1;i<=(i64)2;++i) {
L930 :;
        p = (struct qq_decls$userxrec *)qq_tables$userxmodelist;
        rescan = (i64)0;
        L933 :;
        while (!!(p)) {
            m = (i64)(*(*p).pmode);
            if ((m < (i64)0)) {
                m = qq_resolve$fixmode2((struct qq_decls$strec *)(*p).owner,m);
                if ((((m < (i64)0) && (i == (i64)2)) && !!(qq_tables$ttxmap[(m$llabs(m))]))) {
                    m = qq_tables$ttxmap[(m$llabs(m))];
                }
;
                if ((m < (i64)0)) {
                    rescan = (i64)1;
                }
                else {
                    (*(*p).pmode) = m;
                    if (((i64)qq_tables$tttarget[(m)] == m)) {
                        qq_lib$rxerror_s((byte*)"recursive type?",qq_tables$ttname[(m)],0);
                    }
;
                }
;
            }
;
            p = (struct qq_decls$userxrec *)(*p).nextmode;
L934 :;
        }
L935 :;
        ;
        if (!(!!(rescan))) {
            goto L932 ;
        }
;
L931 :;
    }
L932 :;
    ;
    if (!!(rescan)) {
        qq_lib$rxerror((byte*)"FUT Phase Error",0);
    }
;
    for (i=(i64)1;i<=qq_decls$nbaseclasses;++i) {
L936 :;
        qq_resolve$dobaseclass(i);
L937 :;
    }
L938 :;
    ;
}

void qq_resolve$tx_typetable(void) {
        i64 i;
    for (i=(i64)40;i<=qq_tables$ntypes;++i) {
L939 :;
        qq_resolve$converttype(i);
L940 :;
    }
L941 :;
    ;
}

static i64 qq_resolve$getconstint(struct qq_decls$strec *owner,struct qq_decls$unitrec *a,i64 ownerid) {
    qq_resolve$rx_unit(owner,a);
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)45)) {
        return (*a).value;
    }
    else if (($temp==(i64)46)) {
        return (i64)(*a).xvalue;
    }
    else {
        qq_lib$rxerror_s((byte*)"Getconstint: not int/real",qq_tables$jtagnames[((i64)(*a).tag)],0);
    }
    };
    return (i64)0;
}

void qq_resolve$converttype(i64 m) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  f;
        struct qq_decls$strec *  owner;
        i64 index;
        i64 elemtype;
        i64 nbits;
        struct qq_decls$strec *  fieldlist[257];
        i64 ownerid;
        i64 maxalign;
        i64 nfields;
        i64 size;
        struct qq_decls$unitrec *  plength;
        struct qq_decls$unitrec *  plower;
    if (!!(qq_tables$ttsize[(m)])) {
        return;
    }
;
    owner = qq_tables$ttowner[(m)];
    plower = qq_tables$ttlowerexpr[(m)];
    plength = qq_tables$ttlengthexpr[(m)];
        {i64 $temp = (i64)qq_tables$ttbasetype[(m)];
if (($temp==(i64)35) || ($temp==(i64)36)) {
        qq_tables$ttsize[(m)] = (qq_tables$ttlength[(m)] = qq_resolve$getconstint(owner,plength,(i64)0));
    }
    else if (($temp==(i64)7)) {
        if ((m == (i64)11)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"CT:ARRAY/ARRAY",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        if (!!(qq_tables$ttowner[(m)])) {
            ownerid = (i64)(*qq_tables$ttowner[(m)]).nameid;
        }
        else {
            ownerid = (i64)0;
        }
;
        if (!!(plower)) {
            qq_tables$ttlower[(m)] = qq_resolve$getconstint(owner,plower,ownerid);
        }
        else {
            qq_tables$ttlower[(m)] = (i64)1;
        }
;
        if (!!(plength)) {
            qq_tables$ttlength[(m)] = qq_resolve$getconstint(owner,plength,ownerid);
        }
        else {
            qq_tables$ttlength[(m)] = (i64)0;
        }
;
        elemtype = (i64)qq_tables$tttarget[(m)];
        if ((elemtype==(i64)32) || (elemtype==(i64)33) || (elemtype==(i64)34)) {
            nbits = (qq_tables$ttlength[(m)] * (i64)qq_tables$ttbitwidth[((i64)qq_tables$tttarget[(m)])]);
            qq_tables$ttsize[(m)] = (((nbits - (i64)1) / (i64)8) + (i64)1);
        }
        else {
            qq_resolve$converttype((i64)qq_tables$tttarget[(m)]);
            qq_tables$ttsize[(m)] = (qq_tables$ttlength[(m)] * qq_tables$ttsize[((i64)qq_tables$tttarget[(m)])]);
        }
;
    }
    else if (($temp==(i64)13)) {
        d = qq_tables$ttnamedef[(m)];
        f = (*d).deflist;
        nfields = (i64)0;
        L942 :;
        while (!!(f)) {
            if ((nfields >= (i64)256)) {
                qq_lib$rxerror((byte*)"Too many fields",0);
            }
;
            fieldlist[(++(nfields))-1] = f;
            f = (*f).nextdef;
L943 :;
        }
L944 :;
        ;
        fieldlist[((nfields + (i64)1))-1] = 0;
        qq_resolve$ntopfields = (qq_resolve$nallfields = (i64)0);
        maxalign = (i64)1;
        index = (i64)1;
        qq_resolve$scanstruct((i64)1,&fieldlist,&index,&size,(i64)0,(i64)qq_tables$ttcaligned[(m)],&maxalign,(i64)2);
        if (!!((i64)qq_tables$ttcaligned[(m)])) {
            size = mlib$roundtoblock(size,maxalign);
            (*d).maxalign = maxalign;
        }
        else {
            (*d).maxalign = (i64)1;
        }
;
        qq_tables$ttsize[(m)] = size;
        qq_tables$ttlower[(m)] = (i64)1;
        qq_tables$ttlength[(m)] = qq_resolve$ntopfields;
        (*d).topfieldlist = (struct qq_decls$strec **)mlib$pcm_alloc(((i64)8 * qq_resolve$ntopfields));
        memcpy((*d).topfieldlist,&qq_resolve$structfields,(u64)((i64)8 * qq_resolve$ntopfields));
    }
    else if (($temp==(i64)12)) {
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"CAN'T DO:",NULL);
        msysc$m_print_str(qq_show$strmode(m,(i64)0),NULL);
        msysc$m_print_str(qq_show$strmode((i64)qq_tables$ttbasetype[(m)],(i64)0),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    };
}

static void qq_resolve$scanstruct(i64 smode,struct qq_decls$strec *(*fields)[],i64 *index,i64 *isize,i64 offset,i64 calign,i64 *maxalign,i64 countmode) {
        struct qq_decls$strec *  f;
        i64 newoffset;
        i64 fieldsize;
        i64 alignment;
        i64 size;
    size = (i64)0;
    L945 :;
    while (!!((f = (*fields)[(((*index))++)-1]))) {
                {i64 $temp = (i64)(*f).nameid;
if (($temp==(i64)12)) {
            qq_resolve$converttype((i64)(*f).mode);
            fieldsize = qq_tables$ttsize[((i64)(*f).mode)];
            if (!!(calign)) {
                alignment = qq_names$getalignment((i64)(*f).mode);
                (*maxalign)=((*maxalign)>alignment?(*maxalign):alignment);
;
                newoffset = mlib$roundtoblock(offset,alignment);
                size += (newoffset - offset);
            }
            else {
                newoffset = offset;
            }
;
            (*f).fieldoffset = newoffset;
            (*f).index = ((*index) - (i64)1);
            offset = newoffset;
            //countfields:
L948 :;
;
            ++(qq_resolve$nallfields);
            if (!!(countmode)) {
                qq_resolve$structfields[(++(qq_resolve$ntopfields))-1] = f;
            }
;
        }
        else if (($temp==(i64)24)) {
            qq_resolve$scanstruct((i64)1,fields,index,&fieldsize,offset,calign,maxalign,countmode);
        }
        else if (($temp==(i64)25)) {
            qq_resolve$scanstruct((i64)0,fields,index,&fieldsize,offset,calign,maxalign,(!!(countmode) ? (i64)1 : (i64)0));
        }
        else if (($temp==(i64)26)) {
            (*isize) = size;
            return;
        }
        };
        if (!!(smode)) {
            offset += fieldsize;
            size += fieldsize;
        }
        else {
            size = (size>fieldsize?size:fieldsize);
            countmode = (i64)0;
        }
;
L946 :;
    }
L947 :;
    ;
    (*isize) = size;
}

static void qq_resolve$dobaseclass(i64 baseclassindex) {
        struct qq_decls$strec *  sttype;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  newd;
        i64 baseclass;
        i64 normalexit;
    baseclass = (i64)qq_decls$baseclasstable[(baseclassindex)];
    sttype = (struct qq_decls$strec *)qq_decls$baseclassdef[(baseclassindex)];
    d = (struct qq_decls$strec *)(*qq_tables$ttnamedef[(baseclass)]).deflist;
    L949 :;
    while (!!(d)) {
        e = (struct qq_decls$strec *)(*sttype).deflist;
        normalexit = (i64)1;
        L952 :;
        while (!!(e)) {
            if (!!(mlib$eqstring((*d).name,(*e).name))) {
                normalexit = (i64)0;
                goto L954 ;
            }
;
            e = (struct qq_decls$strec *)(*e).nextdef;
L953 :;
        }
L954 :;
        ;
        if (!!(normalexit)) {
                        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)5) || ($temp==(i64)21)) {
                newd = (struct qq_decls$strec *)qq_names$addsymbol((struct qq_decls$strec *)sttype,(*d).firstdupl,(i64)21,(i64)0);
                (*newd).alias = (struct qq_decls$strec *)d;
            }
            else {
                newd = (struct qq_decls$strec *)qq_names$addsymbol((struct qq_decls$strec *)sttype,(*d).firstdupl,(i64)(*d).nameid,(i64)0);
                qq_names$duplfield((struct qq_decls$strec *)d,(struct qq_decls$strec *)newd);
                ++((*sttype).nfields);
                qq_tables$ttlength[((i64)(*sttype).mode)] = (i64)(*sttype).nfields;
                (*newd).index = (i64)(*sttype).nfields;
                (*newd).fieldoffset = (((i64)(*newd).index - (i64)1) * (i64)16);
            }
            };
            qq_names$addgenfield((struct qq_decls$strec *)newd);
        }
;
        d = (struct qq_decls$strec *)(*d).nextdef;
L950 :;
    }
L951 :;
    ;
}

// START
void qq_resolve$start(void) {

}

void qq_sets$obj_free_set(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).ptr,qq_bits$getbitssize((*p).alloc64,(i64)32));
    }
;
    mlib$pcm_free32(p);
}

void qq_sets$var_dupl_set(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 nbits;
    p = (*a).objptr;
    nbits = (*p).length;
    q = qq_sets$obj_newset(nbits);
    if (!!(nbits)) {
        memcpy((*q).ptr,(*p).ptr,(u64)qq_bits$getbitssize(nbits,(i64)32));
    }
;
    (*a).objptr = q;
}

i64 qq_sets$var_equal_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xbytes;
        i64 ybytes;
    xbytes = qq_sets$getsetbytes(x);
    ybytes = qq_sets$getsetbytes(y);
    if ((xbytes != ybytes)) {
        return (i64)0;
    }
;
    return mlib$eqbytes((*(*x).objptr).ptr,(*(*y).objptr).ptr,xbytes);
}

static i64 qq_sets$getsetbytes(struct qq_decls$varrec *x) {
        i64 nbits;
    nbits = (*(*x).objptr).length;
    if (!!(nbits)) {
        if (!!((nbits & (i64)7))) {
            return ((nbits / (i64)8) + (i64)1);
        }
        else {
            return (nbits / (i64)8);
        }
;
    }
    else {
        return (i64)0;
    }
;
}

void qq_sets$var_make_set(struct qq_decls$varrec *data,struct qq_decls$varrec *dest,i64 n) {
        struct qq_decls$varrec *  q;
        i64 top;
        i64 a;
        i64 b;
        struct qq_decls$objrec *  s;
        static i64 count = (i64)0;
        i64 $av_1;
        i64 $av_2;
    if ((n == (i64)0)) {
        qq_sets$var_emptyset(dest);
        return;
    }
;
    top = (i64)0;
    q = data;
    $av_1 = n;
    while ($av_1-- > 0) {
L955 :;
        switch ((i64)(*q).tag) {
        case 4:;
            {
                a = msysc$m_getdotslice((*q).dummy,(i64)16,(i64)63);
                b = (i64)(*q).range_upper;
            }
            break;
        case 1:;
            {
                a = (*q).value;
                if ((a < (i64)0)) {
                    a = (-(a) - (i64)1);
                    if ((a > top)) {
                        top = a;
                    }
;
                    goto L956 ;
                }
;
                b = a;
            }
            break;
        default: {
            b = (a = qq_vars$var_getintvalue(q));
        }
        } //SW
;
        if (((a < (i64)0) || (b < (i64)0))) {
            qq_lib$pcerror((byte*)"Neg range element");
        }
;
        top=(top>a?top:a);
;
        top=(top>b?top:b);
;
        ++(q);
L956 :;
    }
L957 :;
    ;
    s = qq_sets$obj_newset((top + (i64)1));
    q = data;
    $av_2 = n;
    while ($av_2-- > 0) {
L958 :;
        switch ((i64)(*q).tag) {
        case 4:;
            {
                a = msysc$m_getdotslice((*q).dummy,(i64)16,(i64)63);
                b = (i64)(*q).range_upper;
                if ((a > b)) {
                    {i64 temp = a; a = b; b = temp; };
                }
;
            }
            break;
        case 1:;
            {
                b = (a = (*q).value);
                if ((a < (i64)0)) {
                    goto L959 ;
                }
;
            }
            break;
        default: {
            b = (a = qq_vars$var_getintvalue(q));
        }
        } //SW
;
        qq_lib$setelemblock((byte (*)[])(*s).ptr,a,b);
        ++(q);
L959 :;
    }
L960 :;
    ;
    qq_vars$var_objtovar((i64)5,s,dest);
}

struct qq_decls$objrec *qq_sets$obj_newset(i64 length) {
        struct qq_decls$objrec *  p;
        i64 nbytes;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).length = length;
    nbytes = ((((length - (i64)1) / (i64)64) + (i64)1) * (i64)8);
    if (!!(length)) {
        (*p).ptr = (byte *)mlib$pcm_alloc(nbytes);
        (*p).alloc64 = ((i64)(u64)mlib$allocbytes * (i64)8);
        mlib$pcm_clearmem((*p).ptr,mlib$allocbytes);
    }
    else {
        (*p).ptr = 0;
    }
;
    return p;
}

void qq_sets$var_emptyset(struct qq_decls$varrec *dest) {
    qq_vars$var_objtovar((i64)5,qq_sets$obj_newset((i64)0),dest);
}

void qq_sets$var_getix_set(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  p;
    p = (*a).objptr;
    if (((u64)index >= (u64)(*p).length)) {
        qq_lib$pcerror((byte*)"set[int] bounds");
    }
;
    (*a).tagx = (i64)1;
    (*a).value = (i64)!!(((i64)(*((*p).ptr + (index >> (i64)3))) & ((i64)1 << (index & (i64)7))));
}

void qq_sets$var_putix_set(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 newoffset;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    if (((u64)index >= (u64)(*p).length)) {
        if ((index < (i64)0)) {
            qq_lib$pcerror((byte*)"lwb");
        }
        else {
            qq_lib$pcerror((byte*)"set[i]:=x bounds");
        }
;
    }
;
    q = qq_sets$getoffset((*p).ptr,index,&newoffset);
    qq_vars$var_storebit(q,newoffset,x,(i64)32,(i64)0);
}

void qq_sets$var_getixref_set(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 newoffset;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    if (((u64)index >= (u64)(*p).length)) {
        qq_lib$pcerror((byte*)"&set[i] bounds");
    }
;
    q = qq_sets$getoffset((*p).ptr,index,&newoffset);
    (*a).tagx = (i64)15;
    (*a).elemtag = (i64)32;
    (*a).ptr = q;
    (*a).bitoffset = newoffset;
}

static byte *qq_sets$getoffset(byte *p,i64 index,i64 *newoffset) {
    p += (index >> (i64)3);
    (*newoffset) = (index & (i64)7);
    return p;
}

i64 qq_sets$var_in_set(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 i;
        static byte masks[8] = {(u8)1u,(u8)2u,(u8)4u,(u8)8u,(u8)16u,(u8)32u,(u8)64u,(u8)128u};
        struct qq_decls$objrec *  p;
    i = (*a).value;
    p = (*b).objptr;
    if (((u64)i >= (u64)(*p).length)) {
        return (i64)0;
    }
;
    if (!!(((i64)(*((*p).ptr + (i >> (i64)3))) & (i64)masks[((i & (i64)7))]))) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

void qq_sets$iresizeset(struct qq_decls$varrec *p,i64 n) {
        struct qq_decls$objrec *  pp;
    pp = (*p).objptr;
    if (((*pp).length >= n)) {
        return;
    }
;
    qq_sets$obj_resize_set(pp,n);
}

void qq_sets$obj_resize_set(struct qq_decls$objrec *p,i64 n) {
        byte *  q;
        i64 newsize;
        i64 elemtype;
    elemtype = (i64)(*p).elemtag;
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        newsize = qq_bits$getbitssize(n,(i64)32);
        q = (byte *)mlib$pcm_allocz(newsize);
        if (!!((*p).length)) {
            memcpy(q,(*p).ptr,(u64)qq_bits$getbitssize((*p).length,(i64)32));
            mlib$pcm_free((*p).ptr,qq_bits$getbitssize((*p).alloc64,(i64)32));
        }
;
        (*p).ptr = q;
        (*p).length = n;
        (*p).alloc64 = (mlib$allocbytes * (i64)8);
    }
;
}

void qq_sets$iorsetbits(i64 *p,i64 *q,i64 n) {
        i64 $av_1;
    $av_1 = (((n - (i64)1) / (i64)64) + (i64)1);
    while ($av_1-- > 0) {
L961 :;
        (*(p)++) |= (*(q)++);
L962 :;
    }
L963 :;
    ;
}

void qq_sets$ixorsetbits(i64 *p,i64 *q,i64 n) {
        i64 $av_1;
    $av_1 = (((n - (i64)1) / (i64)64) + (i64)1);
    while ($av_1-- > 0) {
L964 :;
        (*(p)++) ^= (*(q)++);
L965 :;
    }
L966 :;
    ;
}

void qq_sets$iandsetbits(u64 *p,u64 *q,i64 n) {
        i64 $av_1;
    $av_1 = (((n - (i64)1) / (i64)64) + (i64)1);
    while ($av_1-- > 0) {
L967 :;
        (*(p)++) &= (*(q)++);
L968 :;
    }
L969 :;
    ;
}

void qq_sets$inotsetbits(u64 *p,i64 n) {
        i64 $av_1;
    $av_1 = (((n - (i64)1) / (i64)64) + (i64)1);
    while ($av_1-- > 0) {
L970 :;
        (*p) = ~((*p));
        ++(p);
L971 :;
    }
L972 :;
    ;
}

void qq_sets$var_iorto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (*px).length;
    ylen = (*py).length;
    if ((ylen == (i64)0)) {
    }
    else if ((xlen == (i64)0)) {
        (*x) = (*y);
        qq_sets$var_dupl_set(x);
    }
    else {
        px = (*x).objptr;
        qq_sets$iresizeset(x,ylen);
        qq_sets$iorsetbits((i64 *)(*px).ptr,(i64 *)(*py).ptr,ylen);
    }
;
}

void qq_sets$var_iandto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (*px).length;
    ylen = (*py).length;
    if ((ylen == (i64)0)) {
        qq_sets$var_emptyset(x);
    }
    else if ((xlen == (i64)0)) {
    }
    else {
        px = (*x).objptr;
        qq_sets$iresizeset(x,ylen);
        qq_sets$iandsetbits((u64 *)(*px).ptr,(u64 *)(*py).ptr,ylen);
    }
;
}

void qq_sets$var_ixorto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (*px).length;
    ylen = (*py).length;
    if ((ylen == (i64)0)) {
        qq_sets$var_emptyset(x);
    }
    else if ((xlen == (i64)0)) {
        (*x) = (*y);
        qq_sets$var_dupl_set(x);
    }
    else {
        px = (*x).objptr;
        qq_sets$iresizeset(x,ylen);
        qq_sets$ixorsetbits((i64 *)(*px).ptr,(i64 *)(*py).ptr,ylen);
    }
;
}

void qq_sets$var_inotto_set(struct qq_decls$varrec *x) {
        i64 xlen;
        struct qq_decls$objrec *  px;
    px = (*x).objptr;
    xlen = (*px).length;
    if (!!(xlen)) {
        qq_sets$inotsetbits((u64 *)(*px).ptr,xlen);
    }
;
}

// START
void qq_sets$start(void) {

}

// START
void qq_strings$start(void) {

    qq_strings$emptystring = qq_vars$obj_new();
    (*qq_strings$emptystring).refcount = (i64)1;
    (*qq_strings$emptystring).objtype = (i64)0;
}

void qq_strings$var_empty_string(struct qq_decls$varrec *dest,i64 mutable) {
    (*dest).tagx = (i64)265;
    if (!(!!(mutable))) {
        (*dest).objptr = qq_strings$emptystring;
        ++((*qq_strings$emptystring).refcount);
    }
    else {
        (*dest).objptr = qq_strings$obj_make_stringn(0,(i64)0,(i64)1);
    }
;
}

void qq_strings$var_make_string(u8 *s,struct qq_decls$varrec *dest,i64 mutable) {
    (*dest).tagx = (i64)265;
    (*dest).objptr = qq_strings$obj_make_string(s,mutable);
}

void qq_strings$var_make_stringn(u8 *s,i64 length,struct qq_decls$varrec *dest,i64 mutable) {
    (*dest).tagx = (i64)265;
    (*dest).objptr = qq_strings$obj_make_stringn(s,length,mutable);
}

struct qq_decls$objrec *qq_strings$obj_new_string(i64 n) {
        struct qq_decls$objrec *  p;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).length = n;
    (*p).objtype = (i64)0;
    if (!!(n)) {
        (*p).strptr = (u8 *)mlib$pcm_alloc(n);
        (*p).alloc64 = mlib$allocbytes;
    }
;
    return p;
}

struct qq_decls$objrec *qq_strings$obj_make_string(u8 *s,i64 mutable) {
        struct qq_decls$objrec *  p;
        i64 n;
    p = qq_strings$obj_new_string((n = strlen(s)));
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)mutable);
    if (!!(n)) {
        memcpy((void *)(*p).strptr,(void *)s,(u64)n);
    }
;
    return p;
}

struct qq_decls$objrec *qq_strings$obj_make_stringn(u8 *s,i64 length,i64 mutable) {
        struct qq_decls$objrec *  p;
    p = qq_strings$obj_new_string(length);
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)mutable);
    if (!!(length)) {
        if (!!(s)) {
            memcpy((void *)(*p).strptr,(void *)s,(u64)length);
        }
        else {
            memset((void *)(*p).strptr,(i32)(i64)0,(u64)length);
        }
;
    }
;
    return p;
}

void qq_strings$obj_free_string(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((void *)(*p).strptr,(*p).alloc64);
    }
;
    mlib$pcm_free32(p);
}

void qq_strings$var_dupl_string(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = qq_strings$obj_new_string((*p).length);
    (*a).objptr = q;
    if (!!((*q).length)) {
        memcpy((void *)(*q).strptr,(void *)(*p).strptr,(u64)(*q).length);
    }
;
}

void qq_strings$var_getix_string(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    if (((u64)(index - (i64)1) >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"getstring[int] bounds");
    }
;
    qq_strings$stringslice(a,index,index,a);
}

void qq_strings$var_getixref_string(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    if (((u64)(index - (i64)1) >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"getixref[int] bounds");
    }
;
    (*a).tagx = (i64)16;
    (*a).elemtag = (i64)26;
    (*a).ptr = (byte *)(((*q).strptr + index) - (i64)1);
}

void qq_strings$var_getdotix_string(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    if (((u64)(index - (i64)1) >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"x.[] bounds");
    }
;
    (*a).tagx = (i64)1;
    (*a).value = (i64)(u64)(*(((*q).strptr + index) - (i64)1));
}

void qq_strings$var_getdotixref_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    --(index);
    if (((u64)index >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"x.[] bounds");
    }
;
    (*dest).tagx = (i64)16;
    (*dest).elemtag = (i64)26;
    (*dest).ptr = (byte *)((*q).strptr + index);
}

void qq_strings$var_getslice_string(struct qq_decls$varrec *a,i64 i,i64 j) {
        struct qq_decls$objrec *  p;
    p = (*a).objptr;
    if ((((i < (i64)1) || (j > (*p).length)) || (i > j))) {
        qq_lib$pcerror((byte*)"string/slice bounds");
    }
;
    qq_strings$stringslice(a,i,j,a);
}

static void qq_strings$stringslice(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = qq_vars$obj_new();
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,msysc$m_getdotindex((i64)(*p).flags,(i64)1));
    (*q).length = ((j - i) + (i64)1);
    (*q).objtype = (i64)1;
        {i64 $temp = (i64)(*p).objtype;
if (($temp==(i64)1)) {
        (*q).objptr2 = (*p).objptr2;
        ++((*(*q).objptr2).refcount);
    }
    else if (($temp==(i64)2)) {
        (*q).objptr2 = 0;
        (*q).objtype = (i64)2;
    }
    else {
        ++((*p).refcount);
        (*q).objptr2 = p;
    }
    };
    (*q).strptr = (((*p).strptr + i) - (i64)1);
    (*dest).tagx = (i64)(*a).tagx;
    (*dest).objptr = q;
}

void qq_strings$var_putix_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        u8 *  s;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    length = (*p).length;
    if (!((($rtemp=index, $rtemp >= (i64)1 && $rtemp <= length)))) {
        if ((index == (length + (i64)1))) {
            qq_strings$var_addto_string(a,x);
            return;
        }
        else {
            qq_lib$pcerror((byte*)"putstring[int] bounds");
        }
;
    }
;
    s = (((*p).strptr + index) - (i64)1);
    if (((i64)(*x).tag != (i64)9)) {
        qq_lib$pcerror((byte*)"s[i]:= not str");
    }
;
    q = (*x).objptr;
    if (((*q).length == (i64)0)) {
        qq_lib$pcerror((byte*)"s[i]:=\"\"");
    }
;
    (*s) = (u64)(*(*q).strptr);
}

void qq_strings$var_putslice_string(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x) {
        u8 *  s;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 sublength;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    length = (*p).length;
    if ((((i < (i64)1) || (j > (*p).length)) || (i > j))) {
        qq_lib$pcerror((byte*)"string/slice bounds");
    }
;
    sublength = ((j - i) + (i64)1);
    s = (((*p).strptr + i) - (i64)1);
    if (((i64)(*x).tag != (i64)9)) {
        qq_lib$pcerror((byte*)"s[i..j]:= not str");
    }
;
    q = (*x).objptr;
    if (((*q).length < sublength)) {
        qq_lib$pcerror((byte*)"substr too short");
    }
;
    memcpy((void *)s,(void *)(*q).strptr,(u64)sublength);
}

void qq_strings$var_putdotix_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$objrec *  p;
        i64 length;
        i64 ch;
    if (((i64)(*x).tag != (i64)1)) {
        qq_lib$pcerror((byte*)"s.[i]:= not int");
    }
;
    ch = (*x).value;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    length = (*p).length;
    if (!((($rtemp=index, $rtemp >= (i64)1 && $rtemp <= length)))) {
        if ((index == (length + (i64)1))) {
            qq_strings$var_addto_string_ch(a,ch);
            return;
        }
        else {
            qq_lib$pcerror((byte*)"str.[int] bounds");
        }
;
    }
;
    (*(((*p).strptr + index) - (i64)1)) = (u64)ch;
}

void qq_strings$obj_resize_string(struct qq_decls$objrec *p,i64 n) {
        u8 *  s;
        i64 oldalloc;
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        oldalloc = (*p).alloc64;
        s = (u8 *)mlib$pcm_alloc(n);
        (*p).alloc64 = mlib$allocbytes;
        if (!!((*p).length)) {
            memcpy((void *)s,(void *)(*p).strptr,(u64)(*p).length);
            mlib$pcm_free((void *)(*p).strptr,oldalloc);
        }
;
        (*p).strptr = s;
        (*p).length = n;
    }
;
}

void qq_strings$var_add_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$objrec *  r;
        i64 alen;
        i64 blen;
        i64 newlen;
    p = (*a).objptr;
    q = (*b).objptr;
    alen = (*p).length;
    blen = (*q).length;
    if ((blen == (i64)0)) {
        ++((*(*a).objptr).refcount);
        return;
    }
    else if ((alen == (i64)0)) {
        qq_strings$var_make_stringn((*q).strptr,blen,a,(i64)1);
        return;
    }
;
    newlen = (alen + blen);
    r = qq_strings$obj_new_string(newlen);
    memcpy((void *)(*r).strptr,(void *)(*p).strptr,(u64)alen);
    memcpy((void *)((*r).strptr + alen),(void *)(*q).strptr,(u64)blen);
    (*a).objptr = r;
}

void qq_strings$var_addto_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 alen;
        i64 blen;
        i64 newlen;
    p = (*a).objptr;
    q = (*b).objptr;
    alen = (*p).length;
    blen = (*q).length;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    if ((blen == (i64)0)) {
        return;
    }
    else if ((alen == (i64)0)) {
        qq_vars$var_unshareu(a);
        (*a) = (*b);
        qq_vars$var_duplu(a);
        return;
    }
;
    newlen = (alen + blen);
    qq_strings$obj_resize_string(p,newlen);
    memcpy((void *)((*p).strptr + alen),(void *)(*q).strptr,(u64)blen);
}

void qq_strings$var_addto_string_ch(struct qq_decls$varrec *a,i64 ch) {
        struct qq_decls$objrec *  p;
        i64 alen;
    p = (*a).objptr;
    alen = (*p).length;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcnotmut();
    }
;
    qq_strings$obj_resize_string(p,(alen + (i64)1));
    (*((*p).strptr + alen)) = (u64)ch;
}

i64 qq_strings$var_equal_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 n;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    if ((px == py)) {
        return (i64)1;
    }
;
    n = (*px).length;
    if ((n != (*py).length)) {
        return (i64)0;
    }
    else if ((n == (i64)0)) {
        return (i64)1;
    }
    else {
        return mlib$eqbytes((void *)(*px).strptr,(void *)(*py).strptr,n);
    }
;
}

i64 qq_strings$var_compare_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 res;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    res = qq_strings$cmpstring_len((*px).strptr,(*py).strptr,(*px).length,(*py).length);
    return res;
}

static i64 qq_strings$cmpstring_len(u8 *s,u8 *t,i64 slen,i64 tlen) {
    if ((slen == (i64)0)) {
        if ((tlen == (i64)0)) {
            return (i64)0;
        }
        else {
            return (i64)-1;
        }
;
    }
    else if ((tlen == (i64)0)) {
        return (i64)1;
    }
    else {
        if ((slen == tlen)) {
            if ((slen == (i64)1)) {
                if (((u64)(*s) < (u64)(*t))) {
                    return (i64)-1;
                }
                else if (((u64)(*s) > (u64)(*t))) {
                    return (i64)1;
                }
                else {
                    return (i64)0;
                }
;
            }
;
            return mlib$cmpstringn(s,t,slen);
        }
        else {
            return mlib$cmpstring(qq_lib$convtostringz(s,slen),qq_lib$convtostringz(t,tlen));
        }
;
    }
;
}

i64 qq_strings$var_inx_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        i64 i;
        i64 j;
        i64 k;
        u8 *  sx;
        u8 *  sy;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (*px).length;
    ylen = (*py).length;
    if (((xlen == (i64)0) || (ylen == (i64)0))) {
        return (i64)(-9223372036854775807-1);
    }
;
    k = (ylen - xlen);
    for (i=(i64)0;i<=k;++i) {
L973 :;
        sx = (*px).strptr;
        sy = ((*py).strptr + i);
        for (j=(i64)1;j<=xlen;++j) {
L976 :;
            if (((u64)(*sx) != (u64)(*sy))) {
                goto L979 ;
;
            }
;
            ++(sx);
            ++(sy);
L977 :;
        }
L978 :;
        ;
        return (i + (i64)1);
        //nextpos:
L979 :;
;
L974 :;
    }
L975 :;
    ;
    return (i64)(-9223372036854775807-1);
}

void qq_strings$var_iconvcase(struct qq_decls$varrec *a,struct qq_decls$varrec *b,i64 upper) {
        i64 n;
        u8 *  s;
        struct qq_decls$objrec *  pa;
        i64 $av_1;
        i64 $av_2;
    pa = (*a).objptr;
    if (((i64)(*b).tag > (i64)0)) {
        n = qq_vars$var_getintvalue(b);
    }
    else {
        n = (*pa).length;
    }
;
    if (((i64)(*a).tag != (i64)9)) {
        qq_lib$pcerror((byte*)"convcase/notstr");
    }
;
    if ((n < (i64)0)) {
        qq_lib$pcerror((byte*)"CONVCASE N<0");
    }
;
    if ((n == (i64)0)) {
        return;
    }
;
    if ((n > (*pa).length)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=",NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_i64((*pa).length,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$pcerror((byte*)"convcase/N?");
    }
;
    s = (*pa).strptr;
    if (!!(upper)) {
        $av_1 = n;
        while ($av_1-- > 0) {
L980 :;
            (*s) = (u64)toupper((i32)(u64)(*s));
            ++(s);
L981 :;
        }
L982 :;
        ;
    }
    else {
        $av_2 = n;
        while ($av_2-- > 0) {
L983 :;
            (*s) = (u64)tolower((i32)(u64)(*s));
            ++(s);
L984 :;
        }
L985 :;
        ;
    }
;
}

void qq_strings$var_makestrslicexobj(u8 *s,i64 length,struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)265;
    (*dest).objptr = qq_strings$obj_make_strslicexobj(s,length);
}

struct qq_decls$objrec *qq_strings$obj_make_strslicexobj(u8 *s,i64 length) {
        struct qq_decls$objrec *  p;
    if ((length == (i64)0)) {
        s = 0;
    }
;
    p = qq_vars$obj_new();
    (*p).strptr = s;
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).length = length;
    (*p).objtype = (i64)2;
    return p;
}

static i64 qq_strings$var_asc(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
    if (((i64)(*a).tag != (i64)9)) {
        qq_lib$pcerror((byte*)"Asc:not str");
    }
;
    p = (*a).objptr;
    if (((*p).length < (i64)1)) {
        qq_lib$pcerror((byte*)"Asc:empty");
    }
;
    return (i64)(u64)(*(*p).strptr);
}

void qq_strings$var_new_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *dest) {
        i64 length;
        i64 ch;
    length = qq_vars$var_getintvalue(a);
    if ((length < (i64)0)) {
        qq_lib$pcerror((byte*)"Length<0");
    }
;
    qq_strings$var_make_stringn(0,length,dest,(i64)0);
        {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)1)) {
        ch = (*b).value;
    }
    else if (($temp==(i64)9)) {
        ch = qq_strings$var_asc(b);
    }
    else if (($temp==(i64)0)) {
        ch = (i64)32;
    }
    else {
        qq_lib$pcerror((byte*)"Not int/str");
    }
    };
    if (!!(length)) {
        memset((void *)(*(*dest).objptr).strptr,(i32)ch,(u64)length);
    }
;
}

void qq_strings$var_new_stringn(i64 length,struct qq_decls$varrec *dest) {
    if ((length < (i64)0)) {
        qq_lib$pcerror((byte*)"Length<0");
    }
;
    qq_strings$var_make_stringn(0,length,dest,(i64)0);
}

void qq_strings$var_mul_string(struct qq_decls$varrec *a,i64 m) {
        i64 oldlen;
        i64 newlen;
        u8 *  p;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  pa;
        i64 $av_1;
    if ((m < (i64)0)) {
        qq_lib$pcerror((byte*)"neg str mul");
    }
    else if ((m == (i64)0)) {
        qq_strings$var_empty_string(a,(i64)0);
        return;
    }
    else if ((m == (i64)1)) {
        ++((*(*a).objptr).refcount);
        return;
    }
    else {
        pa = (*a).objptr;
        oldlen = (*pa).length;
        if (!!(oldlen)) {
            newlen = (oldlen * m);
            v.objptr = qq_strings$obj_new_string(newlen);
            v.tagx = (i64)265;
            p = (*v.objptr).strptr;
            if ((oldlen == (i64)1)) {
                memset((void *)p,(i32)(u64)(*(*pa).strptr),(u64)m);
            }
            else {
                $av_1 = m;
                while ($av_1-- > 0) {
L986 :;
                    memcpy((void *)p,(void *)(*pa).strptr,(u64)oldlen);
                    p += oldlen;
L987 :;
                }
L988 :;
                ;
            }
;
            (*a) = v;
        }
        else {
            qq_strings$var_empty_string(a,(i64)0);
            return;
        }
;
    }
;
}

void qq_strings$var_convert_string_list(struct qq_decls$varrec *a,i64 t,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  q;
        i64 length;
        u8 *  s;
        i64 $av_1;
    p = (*a).objptr;
    length = (*p).length;
    qq_lists$var_make_list(0,dest,length,(i64)1);
    q = (*(*dest).objptr).varptr;
    s = (*p).strptr;
    $av_1 = length;
    while ($av_1-- > 0) {
L989 :;
        qq_strings$var_make_stringn(s,(i64)1,q,(i64)1);
        ++(s);
        ++(q);
L990 :;
    }
L991 :;
    ;
}

void qq_strings$var_expand_string(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 m) {
        struct qq_decls$varrec *  b;
        struct qq_decls$objrec *  p;
        u8 *  s;
        i64 n;
        i64 $av_1;
    p = (*a).objptr;
    b = dest;
    s = (*p).strptr;
    n = (i64)1;
    $av_1 = m;
    while ($av_1-- > 0) {
L992 :;
        if ((n > (*p).length)) {
            qq_strings$var_empty_string(dest,(i64)0);
        }
        else {
            qq_strings$var_make_stringn(s,(i64)1,dest,(i64)1);
            ++(s);
        }
;
        ++(n);
        --(dest);
L993 :;
    }
L994 :;
    ;
}

void qq_strings$var_makechar(i64 ch,struct qq_decls$varrec *dest) {
        struct qq_decls$varrec v;
        u8 str[8];
        struct qq_decls$objrec *  p;
    if (!((($rtemp=ch, $rtemp >= (i64)0 && $rtemp <= (i64)255)))) {
        qq_lib$pcerror((byte*)"chr range");
    }
;
    p = qq_decls$chrtable[(ch)];
    if ((p == 0)) {
        str[((i64)1)-1] = (u64)ch;
        str[((i64)2)-1] = (u64)0u;
        qq_strings$var_make_stringn(str,(i64)1,&v,(i64)0);
        qq_decls$chrtable[(ch)] = (p = v.objptr);
    }
;
    ++((*p).refcount);
    (*dest).tagx = (i64)265;
    (*dest).objptr = p;
}

static u8 *qq_syslibs$findsyslib(u8 *filename) {
        i64 i;
    for (i=(i64)1;i<=(i64)13;++i) {
L995 :;
        if (!!(mlib$eqstring(filename,qq_syslibs$syslibnames[(i)-1]))) {
            return qq_syslibs$libtext[(i)-1];
        }
;
L996 :;
    }
L997 :;
    ;
    return (u8 *)0;
}

i64 qq_syslibs$loadsysmodule(struct qq_decls$filerec *pm) {
        u8 *  source;
    source = qq_syslibs$findsyslib((*pm).filespec);
    if (!!(source)) {
        (*pm).text = source;
        (*pm).size = strlen(source);
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

// START
void qq_syslibs$start(void) {

}

// START
void qq_tables$start(void) {

        i64 i;
    for (i=(i64)1;i<=(i64)28;++i) {
L998 :;
        qq_tables$binopset[((i64)qq_tables$d_binopset[(i)-1])] = (i64)1;
        qq_tables$exprstarterset[((i64)qq_tables$d_binopset[(i)-1])] = (i64)1;
L999 :;
    }
L1000 :;
    ;
    for (i=(i64)1;i<=(i64)9;++i) {
L1001 :;
        qq_tables$unaryopset[((i64)qq_tables$d_unaryopset[(i)-1])] = (i64)1;
        qq_tables$exprstarterset[((i64)qq_tables$d_unaryopset[(i)-1])] = (i64)1;
L1002 :;
    }
L1003 :;
    ;
    for (i=(i64)1;i<=(i64)29;++i) {
L1004 :;
        qq_tables$exprstarterset[(qq_tables$d_exprstarterset[(i)-1])] = (i64)1;
L1005 :;
    }
L1006 :;
    ;
    qq_tables$exprendset[((i64)5)] = (i64)1;
    qq_tables$exprendset[((i64)4)] = (i64)1;
    qq_tables$exprendset[((i64)15)] = (i64)1;
    qq_tables$exprendset[((i64)13)] = (i64)1;
    qq_tables$exprendset[((i64)89)] = (i64)1;
    qq_tables$exprendset[((i64)98)] = (i64)1;
    qq_tables$exprendset[((i64)96)] = (i64)1;
    for (i=(i64)1;i<=(i64)11;++i) {
L1007 :;
        qq_tables$addopset[((i64)qq_tables$d_addopset[(i)-1])] = (i64)1;
L1008 :;
    }
L1009 :;
    ;
    for (i=(i64)1;i<=(i64)6;++i) {
L1010 :;
        qq_tables$mulopset[((i64)qq_tables$d_mulopset[(i)-1])] = (i64)1;
L1011 :;
    }
L1012 :;
    ;
    for (i=(i64)1;i<=(i64)7;++i) {
L1013 :;
        qq_tables$cmpopset[((i64)qq_tables$d_cmpopset[(i)-1])] = (i64)1;
L1014 :;
    }
L1015 :;
    ;
    for (i=(i64)0;i<=(i64)39;++i) {
L1016 :;
        qq_tables$ttname[(i)] = qq_tables$stdtypenames[(i)];
        qq_tables$ttbasetype[(i)] = i;
        qq_tables$ttlower[(i)] = (i64)1;
        qq_tables$ttbitwidth[(i)] = (i64)qq_tables$stdtypewidths[(i)];
        qq_tables$ttsize[(i)] = ((i64)qq_tables$stdtypewidths[(i)] / (i64)8);
L1017 :;
    }
L1018 :;
    ;
    qq_tables$ntypes = (i64)39;
}

void qq_show$printunit(struct qq_decls$unitrec *p,i64 level,u8 *prefix,void *dev) {
        struct qq_decls$strec *  d;
        i64 flags;
        u8 *  idname;
        i64 i;
    if ((p == 0)) {
        return;
    }
;
    qq_show$currlineno = ((i64)(*p).pos & (i64)16777215);
    msysc$m_print_startfile(dev);
    msysc$m_print_ptr(p,NULL);
    msysc$m_print_str((byte*)":",NULL);
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str(qq_show$getprefix(level,prefix,(struct qq_decls$unitrec *)p),NULL);
    msysc$m_print_end();
    ;
    idname = qq_tables$jtagnames[((i64)(*p).tag)];
    if (((u64)(*idname) == 'j')) {
        ++(idname);
    }
;
    msysc$m_print_startfile(dev);
    msysc$m_print_str(idname,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)": ",NULL);
    msysc$m_print_end();
    ;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)43)) {
        d = (*p).def;
        if (!!((*d).owner)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((*(*d).owner).name,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)".",NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_str(qq_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_str((byte*)"Module:",NULL);
        msysc$m_print_i64(msysc$m_getdotslice((i64)(*p).pos,(i64)24,(i64)31),NULL);
        msysc$m_print_end();
        ;
        if ((!!((*d).truename) && ((i64)(*d).nameid == (i64)7))) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" ",NULL);
            msysc$m_print_str((*d).truename,NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if (($temp==(i64)45)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_i64((*p).value,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)46)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_r64((*p).xvalue,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)47)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_setfmt((byte*)"\"#\"");
        msysc$m_print_str((*p).svalue,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)71)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*p).svalue,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)"L",NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)42)) {
        for (i=(i64)1;i<=(i64)4;++i) {
L1019 :;
            if (((i64)(*p).cmpgenop[(i)-1] == (i64)0)) {
                goto L1021 ;
            }
;
            msysc$m_print_startfile(dev);
            msysc$m_print_str(qq_tables$jtagnames[((i64)(*p).cmpgenop[(i)-1])],NULL);
            msysc$m_print_space();
            msysc$m_print_end();
            ;
L1020 :;
        }
L1021 :;
        ;
    }
    else if (($temp==(i64)6)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str(qq_tables$pclnames[((*p).pclopcode)],NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)185)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_i64((i64)(*p).lower,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)":",NULL);
        msysc$m_print_str((byte*)"P.LENGTH=",NULL);
        msysc$m_print_i64((i64)(*p).length,NULL);
        msysc$m_print_str(qq_tables$ttname[((i64)(*p).elemtype)],NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)37) || ($temp==(i64)39)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str(qq_tables$ttname[((i64)(*p).mode)],NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)31)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((qq_tables$hostfnnames[((*p).index)] + (i64)2),NULL);
        msysc$m_print_end();
        ;
    }
    };
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    flags = (i64)qq_tables$jflags[((i64)(*p).tag)];
    if ((flags >= (i64)1)) {
        qq_show$printunitlist(dev,(struct qq_decls$unitrec *)(*p).a,(level + (i64)1),(byte*)"1");
    }
;
    if ((flags == (i64)2)) {
        qq_show$printunitlist(dev,(struct qq_decls$unitrec *)(*p).b,(level + (i64)1),(byte*)"2");
    }
;
}

static void qq_show$printunitlist(void *dev,struct qq_decls$unitrec *p,i64 level,u8 *prefix) {
    if ((p == 0)) {
        return;
    }
;
    L1022 :;
    while (!!(p)) {
        qq_show$printunit((struct qq_decls$unitrec *)p,level,prefix,dev);
        p = (struct qq_decls$unitrec *)(*p).nextunit;
L1023 :;
    }
L1024 :;
    ;
}

static u8 *qq_show$getprefix(i64 level,u8 *prefix,struct qq_decls$unitrec *p) {
        static u8 str[1024];
        u8 indentstr[1024];
        i64 $av_1;
    indentstr[((i64)1)-1] = (u64)0u;
    if ((level > (i64)20)) {
        level = (i64)10;
    }
;
    $av_1 = level;
    while ($av_1-- > 0) {
L1025 :;
        strcat((u8 *)indentstr,(byte*)"- ");
L1026 :;
    }
L1027 :;
    ;
    strcpy((u8 *)str,qq_show$getlineinfok());
    strcat((u8 *)str,(u8 *)indentstr);
    strcat((u8 *)str,prefix);
    if (!!((u64)(*prefix))) {
        strcat((u8 *)str,(byte*)" ");
    }
;
    return (u8 *)str;
}

static u8 *qq_show$getlineinfok(void) {
        static u8 str[40];
    strcpy(str,msysc$strint(qq_show$currlineno,(byte*)"z4"));
    return (u8 *)str;
}

static void qq_show$gstr(u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)qq_show$pcldest,s);
}

static void qq_show$gstrln(u8 *s) {
    mlib$gs_strln((struct mlib$strbuffer *)qq_show$pcldest,s);
}

static void qq_show$gline(void) {
    mlib$gs_line((struct mlib$strbuffer *)qq_show$pcldest);
}

static void qq_show$gstrint(i64 a) {
    mlib$gs_strint((struct mlib$strbuffer *)qq_show$pcldest,a);
}

static void qq_show$glabeldef(u64 lab) {
    L1028 :;
    while (!!(lab)) {
        qq_show$gstr((byte*)"L");
        qq_show$gstrint(((i64)lab & (i64)65535));
        qq_show$gstr((byte*)": ");
        lab >>= (i64)16;
L1029 :;
    }
L1030 :;
    ;
    qq_show$gline();
}

void qq_show$printglobalsymbols(void *f) {
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"PROC Global Symbol Table",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_show$printst(f,qq_decls$stprogram,(i64)0);
}

void qq_show$printst(void *f,struct qq_decls$strec *p,i64 level) {
        struct qq_decls$strec *  q;
    qq_show$printstrec(f,p,level);
    q = (struct qq_decls$strec *)(*p).deflist;
    L1031 :;
    while ((q != 0)) {
        qq_show$printst(f,(struct qq_decls$strec *)q,(level + (i64)1));
        q = (struct qq_decls$strec *)(*q).nextdef;
L1032 :;
    }
L1033 :;
    ;
}

static void qq_show$printstrec(void *f,struct qq_decls$strec *p,i64 level) {
        struct qq_decls$strec dd;
        struct mlib$strbuffer v;
        struct mlib$strbuffer *  d;
        i64 col;
        i64 offset;
        u8 str[256];
        u8 *  s;
        i64 $av_1;
        u8 *  tab;
    d = (struct mlib$strbuffer *)&v;
    offset = (i64)0;
    $av_1 = level;
    while ($av_1-- > 0) {
L1034 :;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"    ",NULL);
        msysc$m_print_end();
        ;
        offset += (i64)4;
        col += (i64)4;
L1035 :;
    }
L1036 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str(mlib$padstr((*p).name,((i64)22 - offset),(byte*)"-"),NULL);
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str(mlib$padstr(qq_tables$namenames[((i64)(*p).nameid)],(i64)12,(byte*)"."),NULL);
    msysc$m_print_end();
    ;
    col = (i64)40;
    dd = (*p);
    if (!!(msysc$m_getdotindex((i64)dd.flags,(i64)2))) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"Imp ",NULL);
        msysc$m_print_end();
        ;
    }
    else if (!!(msysc$m_getdotslice((i64)dd.flags,(i64)0,(i64)1))) {
        msysc$m_print_startfile(f);
        msysc$m_print_str(((i64)msysc$m_getdotslice((i64)dd.flags,(i64)0,(i64)1)==1?(byte*)"Glob ":((i64)msysc$m_getdotslice((i64)dd.flags,(i64)0,(i64)1)==2?(byte*)"Exp ":(byte*)"Local ")),NULL);
        msysc$m_print_end();
        ;
    }
;
    if (!!(msysc$m_getdotindex((i64)dd.flags,(i64)5))) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"byref ",NULL);
        msysc$m_print_end();
        ;
    }
;
    if (!!(msysc$m_getdotindex((i64)dd.flags,(i64)7))) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"opt ",NULL);
        msysc$m_print_end();
        ;
    }
;
    if (!!((i64)dd.moduleno)) {
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"Modno:#");
        msysc$m_print_i64((i64)dd.moduleno,NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"==========",NULL);
    msysc$m_print_end();
    ;
    if (!!(dd.owner)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"(#)");
        msysc$m_print_str((*dd.owner).name,NULL);
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(mlib$padstr((u8 *)str,(i64)18,(byte*)"-"),NULL);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startfile(f);
        msysc$m_print_str(mlib$padstr((byte*)"()",(i64)18,(byte*)"-"),NULL);
        msysc$m_print_end();
        ;
    }
;
        {i64 $temp = (i64)dd.nameid;
if (($temp==(i64)11) || ($temp==(i64)14) || ($temp==(i64)15) || ($temp==(i64)19)) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)" Ix:",NULL);
        msysc$m_print_i64((i64)dd.index,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
        if ((((i64)dd.nameid == (i64)11) && !!(dd.atfield))) {
            msysc$m_print_startfile(f);
            msysc$m_print_str((byte*)"@",NULL);
            msysc$m_print_str((*dd.atfield).name,NULL);
            msysc$m_print_space();
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)" Offset:",NULL);
        msysc$m_print_i64((i64)dd.fieldoffset,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)12)) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)" Offset:",NULL);
        msysc$m_print_i64((i64)dd.fieldoffset,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" Ix:",NULL);
        msysc$m_print_i64((i64)dd.index,NULL);
        msysc$m_print_space();
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)9)) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)" Nfields:",NULL);
        msysc$m_print_i64((i64)dd.nfields,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)5) || ($temp==(i64)7) || ($temp==(i64)6)) {
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)" Nparms:# ");
        msysc$m_print_i64((i64)dd.nparams,NULL);
        msysc$m_print_str((byte*)"DD.MISFUNC=",NULL);
        msysc$m_print_u64(msysc$m_getdotindex((i64)dd.flags,(i64)4),NULL);
        msysc$m_print_end();
        ;
    }
    };
        {i64 $temp = (i64)dd.nameid;
if (($temp==(i64)14) || ($temp==(i64)13) || ($temp==(i64)18) || ($temp==(i64)22) || ($temp==(i64)15) || ($temp==(i64)16)) {
        if (!!(dd.code)) {
                        {u64 $temp = msysc$m_getdotslice((i64)dd.flags,(i64)11,(i64)12);
if (($temp==(u64)3u)) {
                s = (byte*)"::=";
            }
            else if (($temp==(u64)2u)) {
                s = (byte*)":=";
            }
            else {
                s = (byte*)"=";
            }
            };
            msysc$m_print_startfile(f);
            msysc$m_print_str(s,NULL);
            msysc$m_print_str((*qq_lib$strexpr(dd.code)).strptr,NULL);
            msysc$m_print_space();
            msysc$m_print_end();
            ;
        }
;
    }
    };
    if (!!((i64)dd.mode)) {
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"Mode:#");
        msysc$m_print_str(qq_show$strmode((i64)dd.mode,(i64)0),NULL);
        msysc$m_print_i64((i64)dd.mode,NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    tab = (byte*)"          ";
}

void qq_show$printtypetables(void *f) {
        struct qq_decls$strec *  d;
        struct qq_decls$userxrec *  p;
        i64 m;
        i64 i;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"PRINT TYPE TABLES",NULL);
    msysc$m_print_i64(qq_tables$nuserxtypes,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"PROC TYPE TABLES",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (m=(i64)0;m<=qq_tables$ntypes;++m) {
L1037 :;
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"#: # ");
        msysc$m_print_i64(m,(byte*)"3");
        msysc$m_print_str(qq_tables$ttname[(m)],(byte*)"jl12");
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        d = qq_tables$ttnamedef[(m)];
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"\tST=",NULL);
        msysc$m_print_ptr(d,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"\tLen=",NULL);
        msysc$m_print_i64(qq_tables$ttlength[(m)],NULL);
        msysc$m_print_str((byte*)"Lower",NULL);
        msysc$m_print_i64(qq_tables$ttlower[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"\tSize=",NULL);
        msysc$m_print_i64(qq_tables$ttsize[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"\tBasetype=",NULL);
        msysc$m_print_i64((i64)qq_tables$ttbasetype[(m)],NULL);
        msysc$m_print_str(qq_tables$ttname[((i64)qq_tables$ttbasetype[(m)])],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"\tTarget=",NULL);
        msysc$m_print_i64((i64)qq_tables$tttarget[(m)],NULL);
        msysc$m_print_str(qq_tables$ttname[((i64)qq_tables$tttarget[(m)])],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"\tCaligned=",NULL);
        msysc$m_print_i64((i64)qq_tables$ttcaligned[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        d = qq_tables$ttfields[(m)];
        if (!!(d)) {
            msysc$m_print_startfile(f);
            msysc$m_print_str((byte*)"\tFields:",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            L1040 :;
            while (!!(d)) {
                msysc$m_print_startfile(f);
                msysc$m_print_str((byte*)"\t\t",NULL);
                msysc$m_print_str((*d).name,NULL);
                msysc$m_print_str((!!((i64)(*d).mode) ? qq_show$strmode((i64)(*d).mode,(i64)0) : (byte*)""),NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                d = (*d).nextdef;
L1041 :;
            }
L1042 :;
            ;
        }
;
L1038 :;
    }
L1039 :;
    ;
    p = (struct qq_decls$userxrec *)qq_tables$userxmodelist;
    for (i=(i64)1;i<=qq_tables$nuserxtypes;++i) {
L1043 :;
        msysc$m_print_startfile(f);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_i64(-(i),NULL);
        msysc$m_print_str((*qq_tables$ttnamedefx[(i)]).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L1044 :;
    }
L1045 :;
    ;
}

void qq_show$showsttree(void) {
        void *  f;
        struct qq_decls$filerec *  m;
        struct qq_decls$strec *  d;
        struct qq_decls$genfieldrec *  g;
        struct qq_decls$procrec *  p;
        i64 i;
    if (!(!!((i64)qq_api$fshowst))) {
        return;
    }
;
    f = fopen((byte*)"ST",(byte*)"w");
    qq_show$printglobalsymbols(f);
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"Modules",NULL);
    msysc$m_print_i64(qq_decls$nmodules,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L1046 :;
        m = qq_decls$modules[(i)];
        if (!!(m)) {
            msysc$m_print_startfile(f);
            msysc$m_print_str((byte*)"\t",NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64(i,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_str((*m).name,NULL);
            msysc$m_print_str((byte*)"M.COMPILED=",NULL);
            msysc$m_print_i64((i64)(*m).compiled,NULL);
            msysc$m_print_str((byte*)"M.PCSTART=",NULL);
            msysc$m_print_ptr((*m).pcstart,NULL);
            msysc$m_print_str((byte*)"M.PCSIZE=",NULL);
            msysc$m_print_i64((*m).pcsize,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startfile(f);
            msysc$m_print_str((byte*)"MODULE",NULL);
            msysc$m_print_i64(i,NULL);
            msysc$m_print_str((byte*)"MISSING",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
L1047 :;
    }
L1048 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"PROC Global GenField Table",NULL);
    msysc$m_print_i64(qq_decls$ngenfields,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=qq_decls$ngenfields;++i) {
L1049 :;
        g = (struct qq_decls$genfieldrec *)qq_decls$genfieldtable[(i)-1];
        if ((g == 0)) {
            goto L1050 ;
        }
;
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"   #) #:");
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((*(*g).def).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        L1052 :;
        while (!!(g)) {
            d = (*g).def;
            msysc$m_print_startfile(f);
            msysc$m_print_str((byte*)"      ",NULL);
            msysc$m_print_str((*d).name,NULL);
            msysc$m_print_str(qq_tables$namenames[((i64)(*d).nameid)],NULL);
            msysc$m_print_str((*(*d).owner).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            g = (struct qq_decls$genfieldrec *)(*g).nextdef;
L1053 :;
        }
L1054 :;
        ;
L1050 :;
    }
L1051 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"DLL Table",NULL);
    msysc$m_print_i64(qq_decls$nlibfiles,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=qq_decls$nlibfiles;++i) {
L1055 :;
        msysc$m_print_startfile(f);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((byte*)":",NULL);
        msysc$m_print_str((*qq_decls$libtable[(i)-1]).name,NULL);
        msysc$m_print_u64(qq_decls$dllinsttable[(i)-1],NULL);
        msysc$m_print_i64((i64)qq_decls$libtypes[(i)-1],(byte*)"c");
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L1056 :;
    }
L1057 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"DLL Proc Table",NULL);
    msysc$m_print_i64(qq_decls$ndllprocs,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=qq_decls$ndllprocs;++i) {
L1058 :;
        d = qq_decls$dllproctable[(i)-1];
        msysc$m_print_startfile(f);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((byte*)":",NULL);
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_i64((i64)qq_decls$dllproclibindex[(i)-1],NULL);
        msysc$m_print_ptr(qq_decls$dllprocaddr[(i)-1],NULL);
        msysc$m_print_str((!!(msysc$m_getdotindex((i64)(*d).flags,(i64)8)) ? (byte*)"Variadic" : (byte*)""),NULL);
        msysc$m_print_i64((i64)qq_decls$libtypes[((i64)qq_decls$dllproclibindex[(i)-1])-1],(byte*)"c");
        msysc$m_print_str((byte*)"D.INDEX=",NULL);
        msysc$m_print_i64((i64)(*d).index,NULL);
        msysc$m_print_str((byte*)"DLLPROCTABLE[D.INDEX]=",NULL);
        msysc$m_print_ptr(qq_decls$dllproctable[((i64)(*d).index)-1],NULL);
        msysc$m_print_str((byte*)"D=",NULL);
        msysc$m_print_ptr(d,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L1059 :;
    }
L1060 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"All Proc Table",NULL);
    msysc$m_print_i64(qq_decls$nproclist,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    p = (struct qq_decls$procrec *)qq_decls$proclist;
    L1061 :;
    while (!!(p)) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"Proc:",NULL);
        msysc$m_print_str((*(*p).def).name,NULL);
        msysc$m_print_str((*(*(*p).def).owner).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        p = (struct qq_decls$procrec *)(*p).nextproc;
L1062 :;
    }
L1063 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    fclose(f);
}

void qq_show$showtypes(void) {
        void *  f;
    if (!(!!((i64)qq_api$fshowtypes))) {
        return;
    }
;
    if (((i64)qq_api$runcode == (i64)6)) {
        return;
    }
;
    f = fopen((byte*)"TYPES",(byte*)"w");
    qq_show$printtypetables(f);
    fclose(f);
}

void qq_show$showpcl(struct qq_decls$subprogrec *sp,i64 pass) {
        void *  f;
        i64 i;
    if (((i64)qq_api$runcode == (i64)6)) {
        return;
    }
;
    mlib$gs_init((struct mlib$strbuffer *)qq_show$pcldest);
    mlib$gs_str((struct mlib$strbuffer *)qq_show$pcldest,(byte*)"PROC ALL PCL pass:");
    mlib$gs_strint((struct mlib$strbuffer *)qq_show$pcldest,pass);
    mlib$gs_line((struct mlib$strbuffer *)qq_show$pcldest);
    if (!!(sp)) {
        qq_show$showpcl2(sp,pass);
    }
    else {
        for (i=(i64)1;i<=qq_decls$nsubprogs;++i) {
L1064 :;
            qq_show$showpcl2(qq_decls$subprogs[(i)-1],pass);
L1065 :;
        }
L1066 :;
        ;
    }
;
    f = fopen((pass==1?(byte*)"PCL1":(pass==2?(byte*)"PCL2":(byte*)"PCL3")),(byte*)"w");
    if (!(!!(f))) {
        return;
    }
;
    mlib$gs_println((struct mlib$strbuffer *)qq_show$pcldest,f);
    fclose(f);
}

void qq_show$showpcl2(struct qq_decls$subprogrec *sp,i64 pass) {
        i64 $av_1;
        i64 i;
        ($av_1 = (i64)(*sp).lastmodule);
    for (i=(i64)(*sp).firstmodule;i<=$av_1;++i) {
L1067 :;
        qq_show$writeallpcl(qq_decls$modules[(i)],pass);
L1068 :;
    }
L1069 :;
    ;
}

void qq_show$showast(struct qq_decls$subprogrec *sp,u8 *file) {
        void *  f;
        i64 i;
    if (((i64)qq_api$runcode == (i64)6)) {
        return;
    }
;
    f = fopen(file,(byte*)"w");
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"SHOWAST",NULL);
    msysc$m_print_str(file,NULL);
    msysc$m_print_str((byte*)"F=",NULL);
    msysc$m_print_ptr(f,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if (!(!!(f))) {
        return;
    }
;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"PROC",NULL);
    msysc$m_print_str(file,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if (!!(sp)) {
        qq_show$showast2(f,sp);
    }
    else {
        for (i=(i64)1;i<=qq_decls$nsubprogs;++i) {
L1070 :;
            qq_show$showast2(f,qq_decls$subprogs[(i)-1]);
L1071 :;
        }
L1072 :;
        ;
    }
;
    fclose(f);
}

void qq_show$showast2(void *f,struct qq_decls$subprogrec *sp) {
        struct qq_decls$filerec *  pm;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        i64 i;
        i64 $av_1;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"Proc Subprog",NULL);
    msysc$m_print_str((*sp).name,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)": ******\n",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
        ($av_1 = (i64)(*sp).lastmodule);
    for (i=(i64)(*sp).firstmodule;i<=$av_1;++i) {
L1073 :;
        pm = qq_decls$modules[(i)];
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"Module:",NULL);
        msysc$m_print_str((*pm).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_show$printunit((struct qq_decls$unitrec *)(*pm).ast,(i64)0,(byte*)"*",f);
        d = (*(*pm).def).deflist;
        L1076 :;
        while (!!(d)) {
            if (((i64)(*d).nameid == (i64)5)) {
                msysc$m_print_startfile(f);
                msysc$m_print_str((byte*)"\n---PROC",NULL);
                msysc$m_print_str((*d).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                qq_show$printunit((struct qq_decls$unitrec *)(*d).code,(i64)0,(byte*)"*",f);
                e = (*d).deflist;
                L1080 :;
                while (!!(e)) {
                    if (((i64)(*e).nameid == (i64)6)) {
                        msysc$m_print_startfile(f);
                        msysc$m_print_str((byte*)"\n---ANONPROC",NULL);
                        msysc$m_print_str((*e).name,NULL);
                        msysc$m_print_newline();
                        msysc$m_print_end();
                        ;
                        msysc$m_print_startcon();
                        msysc$m_print_str((byte*)"ANON",NULL);
                        msysc$m_print_ptr((*e).code,NULL);
                        msysc$m_print_newline();
                        msysc$m_print_end();
                        ;
                        qq_show$printunit((struct qq_decls$unitrec *)(*e).code,(i64)0,(byte*)"*",f);
                    }
;
L1081 :;
                    e = (*e).nextdef;
L1083 :;
                                    }
L1082 :;
                ;
            }
;
L1077 :;
            d = (*d).nextdef;
L1079 :;
                    }
L1078 :;
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L1074 :;
    }
L1075 :;
    ;
}

void qq_show$showlogfile(void) {
        u8 str[256];
        void *  logdev;
    if (((((((((((i64)qq_api$fshowpcl1 + (i64)qq_api$fshowpcl2) + (i64)qq_api$fshowpcl3) + (i64)qq_api$fshowast1) + (i64)qq_api$fshowast2) + (i64)qq_api$fshowst) + (i64)qq_api$fshowtypes) + (i64)qq_api$fshowmodules) + (i64)qq_api$fshowstflat) == (i64)0)) {
        return;
    }
;
    if (((i64)qq_api$runcode == (i64)6)) {
        return;
    }
;
    if (!!((i64)qq_api$fshowst)) {
        qq_show$showsttree();
    }
;
    if (!!((i64)qq_api$fshowstflat)) {
        qq_show$showstflat();
    }
;
    if (!!((i64)qq_api$fshowtypes)) {
        qq_show$showtypes();
    }
;
    logdev = fopen((byte*)"qq.log",(byte*)"w");
    if (!!((i64)qq_api$fshowmodules)) {
        qq_show$showmoduleinfo(logdev);
    }
;
    if ((((i64)qq_api$runcode >= (i64)5) && !!((i64)qq_api$fshowpcl3))) {
        qq_show$addtolog((byte*)"PCL3",logdev);
    }
;
    if (((((i64)qq_api$runcode >= (i64)4) && !!((i64)qq_api$foptimise)) && !!((i64)qq_api$fshowpcl2))) {
        qq_show$addtolog((byte*)"PCL2",logdev);
    }
;
    if ((((i64)qq_api$runcode >= (i64)4) && !!((i64)qq_api$fshowpcl1))) {
        qq_show$addtolog((byte*)"PCL1",logdev);
    }
;
    if ((((i64)qq_api$runcode >= (i64)3) && !!((i64)qq_api$fshowast2))) {
        qq_show$addtolog((byte*)"AST2",logdev);
    }
;
    if ((((i64)qq_api$runcode >= (i64)2) && !!((i64)qq_api$fshowast1))) {
        qq_show$addtolog((byte*)"AST1",logdev);
    }
;
    if (!!((i64)qq_api$fshowst)) {
        qq_show$addtolog((byte*)"ST",logdev);
    }
;
    if (!!((i64)qq_api$fshowstflat)) {
        qq_show$addtolog((byte*)"STFLAT",logdev);
    }
;
    if (!!((i64)qq_api$fshowtypes)) {
        qq_show$addtolog((byte*)"TYPES",logdev);
    }
;
    fclose(logdev);
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"c:/m/scripts/med.bat #");
    msysc$m_print_str((byte*)"qq.log",NULL);
    msysc$m_print_end();
    ;
    mlinux$os_execwait(str,(i64)0,0);
}

static void qq_show$addtolog(u8 *filename,void *logdest) {
        void *  f;
        i64 c;
    f = fopen(filename,(byte*)"rb");
    if ((f == 0)) {
        return;
    }
;
    L1084 :;
    while (1) {
        c = fgetc(f);
        if ((c == (i64)-1)) {
            goto L1085 ;
        }
;
        fputc((i32)c,logdest);
    }
L1085 :;
    ;
    fclose(f);
}

void qq_show$showstflat(void) {
        void *  f;
        struct qq_decls$strec *  p;
        i64 sym;
        i64 i;
    if (!(!!((i64)qq_api$fshowstflat))) {
        return;
    }
;
    f = fopen((byte*)"STFLAT",(byte*)"w");
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"GLOBAL FLAT SYMBOL TABLE:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)0;i<=(i64)32766;++i) {
L1086 :;
        p = &qq_lex$hashtable[(i)];
        if (!!((*p).name)) {
                        {i64 $temp = (i64)(*p).symbolcode;
if (($temp==(i64)79)) {
                msysc$m_print_startfile(f);
                msysc$m_print_i64(i,NULL);
                msysc$m_print_ptr(p,NULL);
                msysc$m_print_str((byte*)":",NULL);
                msysc$m_print_str((*p).name,NULL);
                msysc$m_print_u64(qq_tables$symbolnames[((i64)(*p).symbolcode)-1],(byte*)"d");
                msysc$m_print_str(qq_tables$namenames[((i64)(*p).nameid)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                p = (*p).nextdupl;
                L1089 :;
                while (!!(p)) {
                    sym = (i64)(*p).symbolcode;
                    if ((sym == (i64)0)) {
                        sym = (i64)1;
                    }
;
                    msysc$m_print_startfile(f);
                    msysc$m_print_str((byte*)"\t",NULL);
                    msysc$m_print_ptr(p,NULL);
                    msysc$m_print_str((*p).name,NULL);
                    msysc$m_print_u64(qq_tables$symbolnames[(sym)-1],(byte*)"d");
                    msysc$m_print_str(qq_tables$namenames[((i64)(*p).nameid)],NULL);
                    msysc$m_print_str((byte*)"(From",NULL);
                    msysc$m_print_str((!!((*p).owner) ? (*(*p).owner).name : (byte*)"-"),NULL);
                    msysc$m_print_nogap();
                    msysc$m_print_str((byte*)")",NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    p = (*p).nextdupl;
L1090 :;
                }
L1091 :;
                ;
            }
            };
        }
;
L1087 :;
    }
L1088 :;
    ;
    fclose(f);
}

void qq_show$showmoduleinfo(void *dev) {
        struct qq_decls$filerec *  pm;
        struct qq_decls$subprogrec *  ps;
        static u8 *  tab = (byte*)"    ";
        i64 $av_1;
        struct qq_decls$strec *  d;
        u8 *  id;
        i64 i;
        i64 j;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"SMI0",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"Project Structure:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"---------------------------------------",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"Modules",NULL);
    msysc$m_print_i64(qq_decls$nmodules,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L1092 :;
        pm = qq_decls$modules[(i)];
        msysc$m_print_startfile(dev);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_i64(i,(byte*)"2");
        msysc$m_print_str((*pm).name,(byte*)"16jl");
        msysc$m_print_str((byte*)"Lead:",NULL);
        msysc$m_print_i64((i64)(*pm).islead,NULL);
        msysc$m_print_str((byte*)"Sys:",NULL);
        msysc$m_print_i64((i64)(*pm).issyslib,NULL);
        msysc$m_print_str((byte*)"Path:",NULL);
        msysc$m_print_str((*pm).path,NULL);
        msysc$m_print_str((byte*)"Sub:",NULL);
        msysc$m_print_str((*qq_decls$subprogs[((i64)(*pm).subprogno)-1]).name,NULL);
        msysc$m_print_str((byte*)"File:",NULL);
        msysc$m_print_str((*pm).filespec,NULL);
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(dev);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L1093 :;
    }
L1094 :;
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"Subprograms",NULL);
    msysc$m_print_i64(qq_decls$nsubprogs,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=qq_decls$nsubprogs;++i) {
L1095 :;
        ps = (struct qq_decls$subprogrec *)qq_decls$subprogs[(i)-1];
        msysc$m_print_startfile(dev);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((*ps).name,NULL);
        msysc$m_print_str((byte*)"Sys:",NULL);
        msysc$m_print_i64((i64)(*ps).issyslib,NULL);
        msysc$m_print_str((byte*)"Path:",NULL);
        msysc$m_print_str((*ps).path,NULL);
        msysc$m_print_str((byte*)"Spec:",NULL);
        msysc$m_print_str((*ps).filespec,NULL);
        msysc$m_print_str((byte*)"Comp:",NULL);
        msysc$m_print_i64((i64)(*ps).compiled,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        if (!!((i64)(*ps).firstmodule)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str(tab,NULL);
            msysc$m_print_str(tab,NULL);
            msysc$m_print_i64((i64)(*ps).firstmodule,NULL);
            msysc$m_print_i64((i64)(*ps).lastmodule,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)": ",NULL);
            msysc$m_print_end();
            ;
                        ($av_1 = (i64)(*ps).lastmodule);
            for (j=(i64)(*ps).firstmodule;j<=$av_1;++j) {
L1098 :;
                msysc$m_print_startfile(dev);
                msysc$m_print_str((*qq_decls$modules[(j)]).name,NULL);
                msysc$m_print_space();
                msysc$m_print_end();
                ;
L1099 :;
            }
L1100 :;
            ;
            msysc$m_print_startfile(dev);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
L1096 :;
    }
L1097 :;
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if (!(!!(qq_decls$stprogram))) {
        return;
    }
;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"Symboltable:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    d = (*qq_decls$stprogram).deflist;
    L1101 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)3)) {
            id = (byte*)"Mod";
        }
        else if (($temp==(i64)2)) {
            id = (byte*)"Sub";
        }
        else {
            id = (byte*)"---";
        }
        };
        msysc$m_print_startfile(dev);
        msysc$m_print_setfmt((byte*)"    # # (m#, s#)");
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_str(id,NULL);
        msysc$m_print_i64((i64)(*d).moduleno,NULL);
        msysc$m_print_i64((i64)(*d).subprogno,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L1102 :;
        d = (*d).nextdef;
L1104 :;
            }
L1103 :;
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void qq_show$printsymbol(struct qq_decls$lexrec *lp) {
        struct qq_decls$lexrec l;
    l = (*lp);
    msysc$m_print_startcon();
    msysc$m_print_u64(qq_tables$symbolnames[((i64)l.symbol)-1],(byte*)"d 18 jl");
    msysc$m_print_end();
    ;
        {i64 $temp = (i64)l.symbol;
if (($temp==(i64)79)) {
        msysc$printstr_n((*l.symptr).name,(i64)(*l.symptr).namelen);
    }
    else if (($temp==(i64)73)) {
                {i64 $temp = (i64)l.subcode;
if (($temp==(i64)1)) {
            msysc$m_print_startcon();
            msysc$m_print_i64(l.value,NULL);
            msysc$m_print_str((byte*)"int",NULL);
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_i64(l.value,NULL);
            msysc$m_print_end();
            ;
        }
        };
    }
    else if (($temp==(i64)75)) {
        msysc$m_print_startcon();
        msysc$m_print_r64(l.xvalue,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)77)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\"",NULL);
        msysc$m_print_space();
        msysc$m_print_end();
        ;
        msysc$printstr(l.svalue);
        msysc$m_print_startcon();
        msysc$m_print_space();
        msysc$m_print_str((byte*)"\"",NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)76)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"'",NULL);
        msysc$m_print_space();
        msysc$m_print_end();
        ;
        msysc$printstr(l.svalue);
        msysc$m_print_startcon();
        msysc$m_print_space();
        msysc$m_print_str((byte*)"'",NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)74)) {
        msysc$printstr(l.svalue);
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"L",NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)8) || ($temp==(i64)22) || ($temp==(i64)18) || ($temp==(i64)9) || ($temp==(i64)24)) {
        msysc$m_print_startcon();
        msysc$m_print_str(qq_tables$jtagnames[((i64)l.subcode)],NULL);
        msysc$m_print_end();
        ;
    }
    else {
        if (!!((i64)l.subcode)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"#",NULL);
            msysc$m_print_i64((i64)l.subcode,NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    };
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

u8 *qq_show$strmode(i64 t,i64 expand) {
        static u8 str[2048];
    qq_show$istrmode(t,(u8 *)str,expand);
    return str;
}

static void qq_show$istrmode(i64 t,u8 *dest,i64 expand) {
        struct qq_decls$strec *  d;
    if ((t < (i64)0)) {
        strcpy(dest,(byte*)"*");
        strcat(dest,(*qq_tables$ttnamedefx[(-(t))]).name);
        return;
    }
;
    if ((t < (i64)39)) {
        strcpy(dest,qq_tables$ttname[(t)]);
        return;
    }
;
        {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)16)) {
        strcpy(dest,(byte*)"ref ");
        qq_show$istrmode((i64)qq_tables$tttarget[(t)],(dest + strlen(dest)),(i64)0);
    }
    else if (($temp==(i64)7)) {
        msysc$m_print_startstr(dest);
        msysc$m_print_setfmt((byte*)"[#..#]");
        msysc$m_print_i64(qq_tables$ttlower[(t)],NULL);
        msysc$m_print_i64(((qq_tables$ttlength[(t)] + qq_tables$ttlower[(t)]) - (i64)1),NULL);
        msysc$m_print_end();
        ;
        qq_show$istrmode((i64)qq_tables$tttarget[(t)],(dest + strlen(dest)),(i64)0);
    }
    else if (($temp==(i64)13)) {
        if (!(!!(expand))) {
            goto L1105 ;
;
        }
;
        strcpy(dest,(byte*)"struct(");
        //dostruct:
L1106 :;
;
        d = qq_tables$ttfields[(t)];
        L1107 :;
        while (!!(d)) {
            qq_show$istrmode((i64)(*d).mode,(dest + strlen(dest)),(i64)0);
            strcat(dest,(byte*)" ");
            strcat(dest,(*d).name);
            if (!!((*d).nextdef)) {
                strcat(dest,(byte*)", ");
            }
;
L1108 :;
            d = (*d).nextdef;
L1110 :;
                    }
L1109 :;
        ;
        strcat(dest,(byte*)")");
    }
    else if (($temp==(i64)12)) {
        if (!(!!(expand))) {
            goto L1105 ;
;
        }
;
        strcpy(dest,(byte*)"record(");
        goto L1106 ;
;
    }
    else {
        //$else:
L1105 :;
;
        strcpy(dest,qq_tables$ttname[(t)]);
    }
    };
}

static void qq_show$writepcl(i64 *pcstart,i64 *pc,i32 *pclsource,i64 pass,u8 *sourcecode) {
        u8 str[512];
        byte fmt[4];
        i64 cmdcode;
        i64 a;
        i64 needcomma;
        i64 i;
        i64 offset;
        i64 labeldone;
        i64 commentdone;
        i64 soffset;
    cmdcode = (*pc);
    memcpy(&fmt,&qq_tables$pclfmt[(cmdcode)],(u64)4u);
    labeldone = (commentdone = (i64)0);
    if ((cmdcode==(i64)2)) {
        return;
    }
    else if ((cmdcode==(i64)3)) {
        qq_show$currpclproc = (struct qq_decls$strec *)(*(pc + (i64)1));
        qq_show$gstr((byte*)"!      ----------");
        qq_show$gstr((byte*)"Procdef:");
        qq_show$gstr((*qq_show$currpclproc).name);
        qq_show$gline();
        return;
    }
    else if ((cmdcode==(i64)5)) {
        qq_show$gstr((byte*)"!      ----------");
        qq_show$gstrln((byte*)"End");
        return;
    }
;
    offset = (pc - pcstart);
    soffset = (i64)(*(pclsource + offset));
    qq_show$currlineno = (soffset & (i64)16777215);
    ++(pc);
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"# [#]: #: ");
    msysc$m_print_ptr((pc - (i64)1),(byte*)"8zh");
    msysc$m_print_i64(qq_show$currlineno,(byte*)"05jr");
    msysc$m_print_i64(((pc - pcstart) - (i64)1),(byte*)"4");
    msysc$m_print_end();
    ;
    qq_show$gstr((u8 *)str);
    offset = ((pc - pcstart) - (i64)1);
    if (!!((*qq_show$labelmap)[(offset)])) {
        qq_show$glabeldef((u64)offset);
        qq_show$gstr((u8 *)str);
    }
;
    if ((cmdcode==(i64)3)) {
        qq_show$currpclproc = (struct qq_decls$strec *)(*pc);
        return;
    }
    else if ((cmdcode==(i64)7)) {
        qq_show$gstr((byte*)"! ");
        qq_show$gstrln((u8 *)(*pc));
        return;
    }
    else if ((cmdcode==(i64)8)) {
        qq_show$gstr((*(struct qq_decls$strec *)(*pc)).name);
        qq_show$gstr((byte*)" /");
        qq_show$gstr(qq_tables$namenames[((i64)(*(struct qq_decls$strec *)(*pc)).nameid)]);
        ++(pc);
        qq_show$gstrln((byte*)":");
        return;
    }
;
    strcpy((u8 *)str,(qq_tables$pclnames[(cmdcode)] + (i64)1));
    a = (i64)1;
    mlib$gs_leftstr((struct mlib$strbuffer *)qq_show$pcldest,(byte*)" ",(i64)7,(i64)45);
    mlib$gs_leftstr((struct mlib$strbuffer *)qq_show$pcldest,(u8 *)str,(i64)10,(i64)32);
    qq_show$gstr((byte*)"     ");
    needcomma = (i64)0;
    for (i=a;i<=(i64)4;++i) {
L1111 :;
                {i64 $temp = (i64)fmt[(i)-1];
if (($temp==(i64)0)) {
            goto L1113 ;
        }
        else {
            if (!!(needcomma)) {
                qq_show$gstr((byte*)", ");
            }
;
            strcpy((u8 *)str,qq_show$writepclopnd((i64)fmt[(i)-1],(*(pc)++),i,cmdcode,pass,pcstart));
            qq_show$gstr((u8 *)str);
            needcomma = (i64)1;
        }
        };
L1112 :;
    }
L1113 :;
    ;
    qq_show$gline();
}

static u8 *qq_show$writepclopnd(i64 fmt,i64 x,i64 n,i64 cmdcode,i64 pass,i64 *pcstart) {
        static u8 str[512];
        static u8 str2[512];
        struct qq_decls$strec *  d;
        u8 *  suffix;
        u8 *  s;
        i64 slen;
        struct qq_decls$objrec *  p;
        struct qq_decls$stringrec *  ps;
        i64 i;
    d = (struct qq_decls$strec *)(struct qq_decls$strec *)x;
    if ((fmt==(i64)0)) {
        return (byte*)"None";
    }
    else if ((fmt==(i64)7) || (fmt==(i64)8)) {
        if ((fmt==(i64)7)) {
            suffix = (byte*)"";
        }
        else if ((fmt==(i64)8)) {
            suffix = (byte*)"u";
        }
        else {
            suffix = (byte*)"";
        }
;
        msysc$m_print_startstr(str);
        msysc$m_print_i64(x,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(suffix,NULL);
        msysc$m_print_space();
        msysc$m_print_end();
        ;
        if ((cmdcode == (i64)68)) {
            strcat(str,(qq_tables$hostfnnames[(x)] + (i64)2));
        }
;
    }
    else if ((fmt==(i64)9)) {
        strcpy(str,msysc$strreal(*(r64*)&x,0));
    }
    else if ((fmt==(i64)10)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#..#");
        msysc$m_print_i64((x & (i64)4294967295),NULL);
        msysc$m_print_i64((x >> (i64)32),NULL);
        msysc$m_print_end();
        ;
    }
    else if ((fmt==(i64)11)) {
        if ((pass <= (i64)2)) {
            ps = (struct qq_decls$stringrec *)x;
            s = (*ps).svalue;
            slen = (*ps).length;
            goto L1114 ;
;
        }
        else {
            p = (struct qq_decls$objrec *)x;
            if (((slen = (*p).length) == (i64)0)) {
                return (byte*)"\"";
            }
;
            s = (*p).strptr;
            goto L1114 ;
;
        }
;
    }
    else if ((fmt==(i64)12)) {
        s = (u8 *)x;
        slen = strlen(s);
        //dostring:
L1114 :;
;
        if ((slen >= (i64)255)) {
            slen = (i64)255;
        }
;
        memcpy(str,(void *)s,(u64)slen);
        str[((slen + (i64)1))-1] = (u64)0u;
        qq_lib$convertstring((u8 *)str,(u8 *)str2);
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"\"#\"");
        msysc$m_print_str(str2,NULL);
        msysc$m_print_end();
        ;
    }
    else if ((fmt==(i64)1)) {
        if ((pass <= (i64)2)) {
            strcpy(str,(*d).name);
        }
        else {
            d = 0;
            for (i=(i64)1;i<=qq_api$nstatics;++i) {
L1115 :;
                if ((qq_api$statictable[(i)-1] == (struct qq_decls$varrec *)x)) {
                    d = qq_api$staticdefs[(i)-1];
                    goto L1117 ;
                }
;
L1116 :;
            }
L1117 :;
            ;
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"[#] (#:#)");
            msysc$m_print_i64(x,(byte*)"h");
            msysc$m_print_str((!!(d) ? (*(*d).owner).name : (byte*)"?"),NULL);
            msysc$m_print_str((!!(d) ? (*d).name : (byte*)"?"),NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if ((fmt==(i64)2)) {
        if ((pass <= (i64)2)) {
            strcpy(str,(*d).name);
        }
        else {
            d = (*qq_show$currpclproc).deflist;
            L1118 :;
            while (!!(d)) {
                if ((((i64)(*d).nameid == (i64)14 || (i64)(*d).nameid == (i64)15) && (((i64)(*d).index * (i64)16) == x))) {
                    msysc$m_print_startstr(str);
                    msysc$m_print_setfmt((byte*)"[#] (#)");
                    msysc$m_print_i64((x / (i64)16),NULL);
                    msysc$m_print_str((*d).name,NULL);
                    msysc$m_print_end();
                    ;
                    return str;
                }
;
                d = (*d).nextdef;
L1119 :;
            }
L1120 :;
            ;
        }
;
    }
    else if ((fmt==(i64)14)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"[#]");
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_end();
        ;
    }
    else if ((fmt==(i64)3)) {
        if ((pass <= (i64)2)) {
            strcpy(str,(*d).name);
        }
        else {
            d = 0;
            for (i=(i64)1;i<=qq_api$nprocs;++i) {
L1121 :;
                if ((qq_api$proctable[(i)-1] == (i64 *)x)) {
                    d = qq_api$procdefs[(i)-1];
                    goto L1123 ;
                }
;
L1122 :;
            }
L1123 :;
            ;
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"[#] (#)");
            msysc$m_print_i64(x,(byte*)"h");
            msysc$m_print_str((!!(d) ? (*d).name : (byte*)"?"),NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if ((fmt==(i64)4)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"[DLL:#]");
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_end();
        ;
    }
    else if ((fmt==(i64)5)) {
        if ((pass <= (i64)2)) {
            d = (struct qq_decls$strec *)x;
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)".#");
            msysc$m_print_str((*d).name,NULL);
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"## (#)");
            msysc$m_print_str((byte*)"#",NULL);
            msysc$m_print_i64(x,NULL);
            msysc$m_print_str((*(*qq_decls$genfieldtable[(x)-1]).def).name,NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if ((fmt==(i64)13)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"T:# <#>");
        msysc$m_print_str(qq_show$strmode(x,(i64)0),NULL);
        msysc$m_print_i64(x,NULL);
        msysc$m_print_end();
        ;
    }
    else if ((fmt==(i64)6)) {
        if ((pass <= (i64)2)) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"L#");
            msysc$m_print_i64(x,NULL);
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"&# (L#)");
            msysc$m_print_i64(x,(byte*)"h");
            msysc$m_print_i64(((i64 *)x - pcstart),NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if ((fmt==(i64)15)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"(#)");
        msysc$m_print_str(qq_tables$pclnames[(x)],NULL);
        msysc$m_print_end();
        ;
    }
    else {
        //other:
L1124 :;
;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"<# #>");
        msysc$m_print_i64(fmt,NULL);
        msysc$m_print_str(qq_tables$opndnames[(fmt)],NULL);
        msysc$m_print_end();
        ;
    }
;
    return str;
}

void qq_show$writeallpcl(struct qq_decls$filerec *pm,i64 pass) {
        i64 cmd;
        i64 i;
        i64 size;
        i64 nopnds;
        i64 x;
        i64 *  pc;
        i64 *  pclcode;
        i32 *  pclsource;
        u8 *  sourcecode;
    qq_show$currlineno = (i64)0;
    if (((pass == (i64)3) && !(!!(qq_decls$hasbytecodes)))) {
        qq_show$gstrln((byte*)"Can't show PCL; use -debug");
        return;
    }
;
    qq_show$gstr((byte*)"PCL FOR MODULE:");
    qq_show$gstrln((*pm).name);
    pc = (pclcode = (*pm).pcstart);
    pclsource = (*pm).pcsrcstart;
    sourcecode = (*pm).text;
    size = (*pm).pcsize;
    qq_show$labelmap = (i64 (*)[])mlib$pcm_allocz(((size + (i64)1) * (i64)8));
    L1125 :;
    do {
        cmd = (*pc);
        nopnds = (i64)qq_pcllib$pclnopnds[(cmd)];
        for (i=(i64)1;i<=nopnds;++i) {
L1128 :;
                        {i64 $temp = (i64)qq_tables$pclfmt[(cmd)][(i)-1];
if (($temp==(i64)0)) {
                goto L1130 ;
            }
            else if (($temp==(i64)6)) {
                x = (*(pc + i));
                if ((pass == (i64)3)) {
                    x = ((i64 *)x - pclcode);
                }
;
                if ((x > (i64)100000)) {
                }
                else {
                    (*qq_show$labelmap)[(x)] = (i64)1;
                }
;
            }
            };
L1129 :;
        }
L1130 :;
        ;
        pc += ((i64)qq_pcllib$pclnopnds[(cmd)] + (i64)1);
L1126 :;
    }
    while (!(cmd == (i64)0 || cmd == (i64)6));
L1127 :;
    ;
    pc = (*pm).pcstart;
    L1131 :;
    do {
        cmd = (*pc);
        qq_show$writepcl(pclcode,pc,pclsource,pass,sourcecode);
        pc += ((i64)qq_pcllib$pclnopnds[(cmd)] + (i64)1);
L1132 :;
    }
    while (!(cmd == (i64)0 || cmd == (i64)6));
L1133 :;
    ;
    qq_show$gline();
    mlib$pcm_free(qq_show$labelmap,((size + (i64)1) * (i64)8));
}

void qq_show$deletetempfiles(void) {
    remove((byte*)"PCL1");
    remove((byte*)"PCL2");
    remove((byte*)"PCL3");
    remove((byte*)"AST1");
    remove((byte*)"AST2");
    remove((byte*)"TYPES");
    remove((byte*)"STFLAT");
    remove((byte*)"ST");
    remove((byte*)"qq.log");
}

// START
void qq_show$start(void) {

}

void qq_vars$var_unshareu(struct qq_decls$varrec *p) {
    if ((--((*(*p).objptr).refcount) <= (i64)0)) {
        qq_vars$var_free(p);
    }
;
}

void qq_vars$obj_shareu(struct qq_decls$objrec *p) {
    ++((*p).refcount);
}

struct qq_decls$varrec *qq_vars$void_new(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)mlib$pcm_alloc((i64)16);
    (*p).tagx = (i64)0;
    return p;
}

struct qq_decls$objrec *qq_vars$obj_new(void) {
        struct qq_decls$objrec *  p;
    p = (struct qq_decls$objrec *)mlib$pcm_alloc((i64)32);
    (*p) = qq_vars$zeroobj;
    (*p).refcount = (i64)1;
    return p;
}

i64 qq_vars$var_getintvalue(struct qq_decls$varrec *p) {
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1) || ($temp==(i64)18)) {
        return (*p).value;
    }
    else if (($temp==(i64)2)) {
        return (i64)(*p).xvalue;
    }
    else {
        qq_lib$pcustype((byte*)"getintvalue",p);
    }
    };
    return (i64)0;
}

void qq_vars$var_fromobj(i64 tag,struct qq_decls$objrec *p,struct qq_decls$varrec *dest) {
    (*dest).tagx = (tag | (i64)256);
    (*dest).objptr = p;
}

void qq_vars$var_free(struct qq_decls$varrec *a) {
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
        {i64 $temp = (i64)(*q).objtype;
if (($temp==(i64)0)) {
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)10)) {
            qq_lists$obj_free_list(q);
        }
        else if (($temp==(i64)12)) {
            qq_records$obj_free_record(q);
        }
        else if (($temp==(i64)9)) {
            qq_strings$obj_free_string(q);
        }
        else if (($temp==(i64)11)) {
            qq_arrays$obj_free_array(q);
        }
        else if (($temp==(i64)7)) {
            qq_arrays$obj_free_vector(q);
        }
        else if (($temp==(i64)8)) {
            qq_bits$obj_free_bits(q,(i64)(*a).tag);
        }
        else if (($temp==(i64)13)) {
            qq_packed$obj_free_struct(q);
        }
        else if (($temp==(i64)6)) {
            qq_dicts$obj_free_dict(q,(i64)0);
        }
        else if (($temp==(i64)5)) {
            qq_sets$obj_free_set(q);
        }
        else if (($temp==(i64)3)) {
            qq_decimal$obj_free_dec(q);
        }
        else {
            qq_lib$pcustype((byte*)"free",a);
        }
        };
    }
    else if (($temp==(i64)1)) {
        v.tagx = (i64)(*a).tag;
        v.objptr = (*q).objptr2;
        qq_vars$var_unshareu(&v);
        mlib$pcm_free32(q);
    }
    else {
        mlib$pcm_free32(q);
    }
    };
}

void qq_vars$var_duplu(struct qq_decls$varrec *a) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_dupl_string(a);
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_dupl_set(a);
    }
    else if (($temp==(i64)10)) {
        qq_lists$var_dupl_list(a);
    }
    else if (($temp==(i64)6)) {
        qq_dicts$var_dupl_dict(a);
    }
    else if (($temp==(i64)11)) {
        qq_arrays$var_dupl_array(a);
    }
    else if (($temp==(i64)7)) {
        qq_arrays$var_dupl_vector(a);
    }
    else if (($temp==(i64)8)) {
        qq_bits$var_dupl_bits(a);
    }
    else if (($temp==(i64)12)) {
        qq_records$var_dupl_record(a);
    }
    else if (($temp==(i64)13)) {
        qq_packed$var_dupl_struct(a);
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_dupl_dec(a);
    }
    else {
        qq_lib$pcustype_t((byte*)"dupl",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_neg(struct qq_decls$varrec *a) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value = -((*a).value);
    }
    else if (($temp==(i64)2)) {
        (*a).xvalue = -((*a).xvalue);
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_dupl_dec(a);
        qq_decimal$var_neg_dec(a);
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_dupl_set(a);
        qq_sets$var_inotto_set(a);
    }
    else {
        qq_lib$pcustype_t((byte*)"neg",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_abs(struct qq_decls$varrec *a) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value = m$llabs((*a).value);
    }
    else if (($temp==(i64)2)) {
        (*a).xvalue = fabs((*a).xvalue);
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_dupl_dec(a);
        qq_decimal$var_abs_dec(a);
    }
    else {
        qq_lib$pcustype_t((byte*)"abs",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_inot(struct qq_decls$varrec *a) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value = ~((*a).value);
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_dupl_set(a);
        qq_sets$var_inotto_set(a);
    }
    else {
        qq_lib$pcustype_t((byte*)"inot",(i64)(*a).tag);
    }
    };
}

i64 qq_vars$var_istruel(struct qq_decls$varrec *a) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1) || ($temp==(i64)14) || ($temp==(i64)16) || ($temp==(i64)15) || ($temp==(i64)18) || ($temp==(i64)17)) {
        return (i64)!!((*a).value);
    }
    else if (($temp==(i64)2)) {
        return (((*a).xvalue != (double)0.) ? (i64)1 : (i64)0);
    }
    else if (($temp==(i64)9) || ($temp==(i64)10) || ($temp==(i64)11) || ($temp==(i64)8) || ($temp==(i64)7)) {
        return (i64)((*(*a).objptr).length != (i64)0);
    }
    else if (($temp==(i64)5)) {
        return (i64)((*(*a).objptr).length != (i64)0);
    }
    else if (($temp==(i64)12) || ($temp==(i64)13)) {
        return (i64)1;
    }
    else if (($temp==(i64)3)) {
        return (i64)!(!!(qq_decimal$bn_iszero((*a).objptr)));
    }
    else if (($temp==(i64)0)) {
        return (i64)0;
    }
    else {
        qq_lib$pcustype_t((byte*)"istruel",(i64)(*a).tag);
    }
    };
    return (i64)0;
}

void qq_vars$var_add(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_addmixed(a,b);
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value += (*b).value;
    }
    else if (($temp==(i64)2)) {
        (*a).xvalue += (*b).xvalue;
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_add_dec(a,b);
    }
    else if (($temp==(i64)9)) {
        qq_strings$var_add_string(a,b);
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_dupl_set(a);
        qq_sets$var_iorto_set(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"add",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_addmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        newtag = (i64)2;
        (*a).xvalue = ((r64)(*a).value + (*b).xvalue);
    }
    else if (($temp==(i64)131073)) {
        (*a).xvalue += (r64)(*b).value;
    }
    else if (($temp==(i64)65539) || ($temp==(i64)131075)) {
        newtag = (i64)3;
        qq_decimal$var_add_dec(qq_decimal$dectemp(a),b);
        qq_decimal$freedectemp();
    }
    else if (($temp==(i64)196609) || ($temp==(i64)196610)) {
        qq_decimal$var_add_dec(a,qq_decimal$dectemp(b));
    }
    else if (($temp==(i64)1048577)) {
        if (((*a).ptr == 0)) {
            qq_lib$pcerror((byte*)"Nil+x");
        }
;
        (*a).ptr += (qq_tables$ttsize[((i64)(*a).elemtag)] * (*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Addmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

i64 qq_vars$var_addto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  a;
        i64 newtag;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)14)) {
        return (i64)0;
    }
;
    newtag = (i64)(*a).tag;
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        if (((newtag == (i64)9) && ((i64)(*b).tag == (i64)1))) {
            qq_strings$var_addto_string_ch(a,(*b).value);
            return (i64)1;
        }
;
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            (*a).value += (*b).value;
        }
        break;
    case 2:;
        {
            (*a).xvalue += (*b).xvalue;
        }
        break;
    case 9:;
        {
            qq_strings$var_addto_string(a,b);
        }
        break;
    case 5:;
        {
            qq_sets$var_iorto_set(a,b);
        }
        break;
    default: {
        return (i64)0;
    }
    } //SW
;
    (*a).tag = newtag;
    return (i64)1;
}

void qq_vars$var_sub(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        byte *  p;
        byte *  q;
        i64 elemsize;
        i64 x;
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_submixed(a,b);
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value -= (*b).value;
    }
    else if (($temp==(i64)2)) {
        (*a).xvalue -= (*b).xvalue;
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_sub_dec(a,b);
    }
    else if (($temp==(i64)16)) {
        p = (*a).ptr;
        q = (*b).ptr;
                {i64 $temp = (elemsize = qq_tables$ttsize[((i64)(*a).elemtag)]);
if (($temp==(i64)1)) {
            x = (p - q);
        }
        else if (($temp==(i64)2)) {
            x = ((p - q) >> (i64)1);
        }
        else if (($temp==(i64)4)) {
            x = ((p - q) >> (i64)2);
        }
        else {
            x = ((p - q) / elemsize);
        }
        };
        (*a).tagx = (i64)1;
        (*a).value = x;
    }
    else {
        qq_lib$pcustype_t((byte*)"sub",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_submixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        newtag = (i64)2;
        (*a).xvalue = ((r64)(*a).value - (*b).xvalue);
    }
    else if (($temp==(i64)131073)) {
        (*a).xvalue -= (r64)(*b).value;
    }
    else if (($temp==(i64)65539) || ($temp==(i64)131075)) {
        newtag = (i64)3;
        qq_decimal$var_sub_dec(qq_decimal$dectemp(a),b);
        qq_decimal$freedectemp();
    }
    else if (($temp==(i64)196609) || ($temp==(i64)196610)) {
        qq_decimal$var_sub_dec(a,qq_decimal$dectemp(b));
    }
    else if (($temp==(i64)1048577)) {
        (*a).ptr -= (qq_tables$ttsize[((i64)(*a).elemtag)] * (*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Submixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_mul(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_mulmixed(a,b);
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value *= (*b).value;
    }
    else if (($temp==(i64)2)) {
        (*a).xvalue *= (*b).xvalue;
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_mul_dec(a,b);
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_dupl_set(a);
        qq_sets$var_iandto_set(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"mul",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_mulmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        newtag = (i64)2;
        (*a).xvalue = ((r64)(*a).value * (*b).xvalue);
    }
    else if (($temp==(i64)131073)) {
        (*a).xvalue *= (r64)(*b).value;
    }
    else if (($temp==(i64)65539) || ($temp==(i64)131075)) {
        newtag = (i64)3;
        qq_decimal$var_mul_dec(qq_decimal$dectemp(a),b);
        qq_decimal$freedectemp();
    }
    else if (($temp==(i64)196609) || ($temp==(i64)196610)) {
        qq_decimal$var_mul_dec(a,qq_decimal$dectemp(b));
    }
    else if (($temp==(i64)589825)) {
        qq_strings$var_mul_string(a,(*b).value);
    }
    else if (($temp==(i64)655361)) {
        qq_lists$var_mul_list(a,(*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Mulmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_div(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_divmixed(a,b);
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).tagx = (i64)2;
        (*a).xvalue = ((r64)(*a).value / (r64)(*b).value);
    }
    else if (($temp==(i64)2)) {
        (*a).xvalue /= (*b).xvalue;
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_div_dec(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"div",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_divmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        newtag = (i64)2;
        (*a).xvalue = ((r64)(*a).value / (*b).xvalue);
    }
    else if (($temp==(i64)131073)) {
        (*a).xvalue /= (r64)(*b).value;
    }
    else {
        qq_lib$pcmxtypes((byte*)"Divmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_idiv(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"idivmixed");
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        if (!!((*b).value)) {
            (*a).value = ((*a).value / (*b).value);
        }
        else {
            qq_lib$pcerror((byte*)"Divide by 0");
        }
;
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_idiv_dec(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"idiv",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_irem(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"iremmixed");
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value = ((*a).value % (*b).value);
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_irem_dec(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"irem",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_iand(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"iand mixed");
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value &= (*b).value;
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_dupl_set(a);
        qq_sets$var_iandto_set(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"iand",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_ior(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"ior mixed");
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value |= (*b).value;
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_dupl_set(a);
        qq_sets$var_iorto_set(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"ior",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_ixor(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"ixor mixed");
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value ^= (*b).value;
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_dupl_set(a);
        qq_sets$var_ixorto_set(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"ixor",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_shl(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"ishl mixed");
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value <<= (*b).value;
    }
    else {
        qq_lib$pcustype_t((byte*)"shl",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_shr(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"ishr mixed");
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value >>= (*b).value;
    }
    else {
        qq_lib$pcustype_t((byte*)"shr",(i64)(*a).tag);
    }
    };
}

i64 qq_vars$var_in(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 n;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65541)) {
        return qq_sets$var_in_set(a,b);
    }
    else if (($temp==(i64)65540)) {
        return ((($rtemp=(*a).value, $rtemp >= msysc$m_getdotslice((*b).dummy,(i64)16,(i64)63) && $rtemp <= (i64)(*b).range_upper)) ? (i64)1 : (i64)0);
    }
    else {
                {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)10) || ($temp==(i64)9) || ($temp==(i64)11) || ($temp==(i64)7)) {
            n = qq_vars$var_inx(a,b);
            return ((n != (i64)(-9223372036854775807-1)) ? (i64)1 : (i64)0);
        }
        else {
            qq_lib$pcmxtypes((byte*)"in",a,b);
        }
        };
    }
    };
    return (i64)0;
}

i64 qq_vars$var_inx(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)589833)) {
        return qq_strings$var_inx_string(a,b);
    }
    else if (($temp==(i64)65547) || ($temp==(i64)131083)) {
        return qq_arrays$var_inx_array(a,b,(i64)0);
    }
    else if (($temp==(i64)65543) || ($temp==(i64)131079)) {
        return qq_arrays$var_inx_array(a,b,(i64)(*(*b).objptr).usertag);
    }
    else {
                {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)10)) {
            return qq_lists$var_inx_list(a,b);
        }
        else {
            qq_lib$pcmxtypes((byte*)"inx",a,b);
        }
        };
    }
    };
    return (i64)0;
}

i64 qq_vars$var_equal(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        return qq_vars$var_equalmixed(a,b);
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1) || ($temp==(i64)14) || ($temp==(i64)16) || ($temp==(i64)18) || ($temp==(i64)17)) {
        return (i64)((*a).value == (*b).value);
    }
    else if (($temp==(i64)2)) {
        return (((*a).xvalue == (*b).xvalue) ? (i64)1 : (i64)0);
    }
    else if (($temp==(i64)3)) {
        return qq_decimal$var_equal_dec(a,b);
    }
    else if (($temp==(i64)9)) {
        return qq_strings$var_equal_string(a,b);
    }
    else if (($temp==(i64)5)) {
        return qq_sets$var_equal_set(a,b);
    }
    else if (($temp==(i64)10)) {
        return qq_lists$var_equal_list(a,b);
    }
    else if (($temp==(i64)6)) {
        return qq_dicts$var_equal_dict(a,b);
    }
    else if (($temp==(i64)11) || ($temp==(i64)7)) {
        return qq_arrays$var_equal_array(a,b);
    }
    else if (($temp==(i64)8)) {
        return qq_bits$var_equal_bits(a,b);
    }
    else if (($temp==(i64)12)) {
        return qq_records$var_equal_record(a,b);
    }
    else if (($temp==(i64)13)) {
        return qq_packed$var_equal_struct(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"equal",(i64)(*a).tag);
    }
    };
    return (i64)0;
}

i64 qq_vars$var_equalmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 result;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        return (((r64)(*a).value == (*b).xvalue) ? (i64)1 : (i64)0);
    }
    else if (($temp==(i64)131073)) {
        return (((*a).xvalue == (r64)(*b).value) ? (i64)1 : (i64)0);
    }
    else if (($temp==(i64)65539) || ($temp==(i64)131075)) {
        result = qq_decimal$var_equal_dec(qq_decimal$dectemp(a),b);
        qq_decimal$freedectemp();
        return result;
    }
    else if (($temp==(i64)196609) || ($temp==(i64)196610)) {
        return qq_decimal$var_equal_dec(a,qq_decimal$dectemp(b));
    }
    else {
        return (i64)0;
    }
    };
    return (i64)0;
}

i64 qq_vars$var_compare(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        return qq_vars$var_comparemixed(a,b);
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1) || ($temp==(i64)16)) {
        return (((*a).value < (*b).value) ? (i64)-1 : (((*a).value > (*b).value) ? (i64)1 : (i64)0));
    }
    else if (($temp==(i64)2)) {
        return (((*a).xvalue < (*b).xvalue) ? (i64)-1 : (((*a).xvalue > (*b).xvalue) ? (i64)1 : (i64)0));
    }
    else if (($temp==(i64)3)) {
        return qq_decimal$var_compare_dec(a,b);
    }
    else if (($temp==(i64)9)) {
        return qq_strings$var_compare_string(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"compare",(i64)(*a).tag);
    }
    };
    return (i64)0;
}

i64 qq_vars$var_comparemixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        return (((r64)(*a).value < (*b).xvalue) ? (i64)-1 : (((r64)(*a).value > (*b).xvalue) ? (i64)1 : (i64)0));
    }
    else if (($temp==(i64)131073)) {
        return (((*a).xvalue < (r64)(*b).value) ? (i64)-1 : (((*a).xvalue > (r64)(*b).value) ? (i64)1 : (i64)0));
    }
    else {
        qq_lib$pcmxtypes((byte*)"comparemixed",a,b);
    }
    };
    return (i64)0;
}

void qq_vars$var_concat(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcmxtypes((byte*)"Concat",a,b);
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_add_string(a,b);
    }
    else if (($temp==(i64)10)) {
        qq_lists$var_dupl_list(a);
        qq_lists$var_concatto_list(a,b);
    }
    else if (($temp==(i64)11)) {
        qq_arrays$var_dupl_array(a);
        qq_arrays$var_concatto_array(a,b);
    }
    else {
        qq_lib$pcustype_t((byte*)"concat",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_append(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)10)) {
            goto L1134 ;
;
        }
        else if (($temp==(i64)11)) {
            goto L1135 ;
;
        }
        else if (($temp==(i64)8)) {
            goto L1136 ;
;
        }
        };
        goto L1137 ;
;
    }
    else {
        switch ((i64)(*a).tag) {
        case 9:;
            {
                qq_strings$var_add_string(a,b);
                qq_vars$var_unshareu(b);
            }
            break;
        case 10:;
            {
                //dolist:
L1134 :;
;
                qq_lists$var_dupl_list(a);
                qq_lists$var_appendto_list(a,b);
            }
            break;
        case 11:;
            {
                //doarray:
L1135 :;
;
                qq_arrays$var_dupl_array(a);
                qq_arrays$var_appendto_array(a,b);
            }
            break;
        case 8:;
            {
                //dobits:
L1136 :;
;
                qq_bits$var_dupl_bits(a);
                qq_bits$var_appendto_bits(a,b);
            }
            break;
        default: {
            //error:
L1137 :;
;
            qq_lib$pcustype_t((byte*)"append",(i64)(*a).tag);
        }
        } //SW
;
    }
;
}

void qq_vars$var_min(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"VARMIN");
        return;
    }
;
    if ((qq_vars$var_compare(a,b) < (i64)0)) {
        if (!!((i64)(*b).hasref)) {
            qq_vars$var_unshareu(b);
        }
;
    }
    else {
        if (!!((i64)(*a).hasref)) {
            qq_vars$var_unshareu(a);
        }
;
        (*a) = (*b);
    }
;
}

void qq_vars$var_max(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"VARMAX");
        return;
    }
;
    if ((qq_vars$var_compare(a,b) >= (i64)0)) {
        if (!!((i64)(*b).hasref)) {
            qq_vars$var_unshareu(b);
        }
;
    }
    else {
        if (!!((i64)(*a).hasref)) {
            qq_vars$var_unshareu(a);
        }
;
        (*a) = (*b);
    }
;
}

i64 qq_vars$var_concatto(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"concatto/mixed");
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_addto_string(a,b);
    }
    else if (($temp==(i64)10)) {
        qq_lists$var_concatto_list(a,b);
    }
    else if (($temp==(i64)11)) {
        qq_arrays$var_concatto_array(a,b);
    }
    else {
        qq_lib$pcustype((byte*)"concat",a);
    }
    };
    return (i64)1;
}

i64 qq_vars$var_appendto(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)10)) {
            goto L1138 ;
;
        }
        else if (($temp==(i64)11)) {
            goto L1139 ;
;
        }
        else if (($temp==(i64)8)) {
            goto L1140 ;
;
        }
        else {
            qq_lib$pcerror((byte*)"appendto/mixed");
        }
        };
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_addto_string(a,b);
        qq_vars$var_unshareu(b);
    }
    else if (($temp==(i64)10)) {
        //dolist:
L1138 :;
;
        qq_lists$var_appendto_list(a,b);
    }
    else if (($temp==(i64)11)) {
        //doarray:
L1139 :;
;
        qq_arrays$var_appendto_array(a,b);
    }
    else if (($temp==(i64)8)) {
        //dobits:
L1140 :;
;
        qq_bits$var_appendto_bits(a,b);
    }
    else {
        qq_lib$pcustype((byte*)"append",a);
        return (i64)0;
    }
    };
    return (i64)1;
}

void qq_vars$var_getix(struct qq_decls$varrec *a,i64 index) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_getix_string(a,index);
    }
    else if (($temp==(i64)10) || ($temp==(i64)6)) {
        qq_lists$var_getix_list(a,index);
    }
    else if (($temp==(i64)11) || ($temp==(i64)7)) {
        qq_arrays$var_getix_array(a,index);
    }
    else if (($temp==(i64)8)) {
        qq_bits$var_getix_bits(a,index);
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_getix_set(a,index);
    }
    else if (($temp==(i64)12)) {
        qq_records$var_getix_record(a,index);
    }
    else if (($temp==(i64)4)) {
        if ((($rtemp=index, $rtemp >= msysc$m_getdotslice((*a).dummy,(i64)16,(i64)63) && $rtemp <= (i64)(*a).range_upper))) {
            (*a).tagx = (i64)1;
            (*a).value = index;
        }
        else {
            qq_lib$pcerror((byte*)"range/bounds");
        }
;
    }
    else {
        qq_lib$pcustype_t((byte*)"getix",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_putix(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_putix_string(a,index,x);
        qq_vars$var_unshareu(x);
    }
    else if (($temp==(i64)10)) {
        qq_lists$var_putix_list(a,index,x);
    }
    else if (($temp==(i64)11) || ($temp==(i64)7)) {
        qq_arrays$var_putix_array(a,index,x);
    }
    else if (($temp==(i64)8)) {
        qq_bits$var_putix_bits(a,index,x);
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_putix_set(a,index,x);
    }
    else if (($temp==(i64)12)) {
        qq_records$var_putix_record(a,index,x);
    }
    else {
        qq_lib$pcustype_t((byte*)"putix",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_getixref(struct qq_decls$varrec *a,i64 index) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_getixref_string(a,index);
    }
    else if (($temp==(i64)10)) {
        qq_lists$var_getixref_list(a,index);
    }
    else if (($temp==(i64)11) || ($temp==(i64)7)) {
        qq_arrays$var_getixref_array(a,index);
    }
    else if (($temp==(i64)8)) {
        qq_bits$var_getixref_bits(a,index);
    }
    else if (($temp==(i64)5)) {
        qq_sets$var_getixref_set(a,index);
    }
    else if (($temp==(i64)12)) {
        qq_records$var_getixref_record(a,index,a);
    }
    else {
        qq_lib$pcustype_t((byte*)"getixref",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_getslice(struct qq_decls$varrec *a,i64 i,i64 j) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_getslice_string(a,i,j);
    }
    else if (($temp==(i64)10)) {
        qq_lists$var_getslice_list(a,i,j);
    }
    else if (($temp==(i64)11)) {
        qq_arrays$var_getslice_array(a,i,j);
    }
    else if (($temp==(i64)8)) {
        qq_bits$var_getslice_bits(a,i,j);
    }
    else {
        qq_lib$pcustype_t((byte*)"getslice",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_putslice(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x) {
    if (((i64)(*a).tag != (i64)(*x).tag)) {
        qq_lib$pcerror((byte*)"putslice: not compatible");
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)9)) {
        qq_strings$var_putslice_string(a,i,j,x);
    }
    else if (($temp==(i64)10)) {
        qq_lists$var_putslice_list(a,i,j,x);
    }
    else {
        qq_lib$pcustype_t((byte*)"putslice",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_getdotix(struct qq_decls$varrec *a,i64 index) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        if (!((($rtemp=index, $rtemp >= (i64)0 && $rtemp <= (i64)63)))) {
            qq_lib$pcerror((byte*)"int.[int] bounds");
        }
;
        (*a).value = (((*a).value >> index) & (i64)1);
    }
    else if (($temp==(i64)9)) {
        qq_strings$var_getdotix_string(a,index);
    }
    else if (($temp==(i64)12)) {
        qq_records$var_getix_record(a,index);
    }
    else {
        qq_lib$pcustype_t((byte*)"getdotix",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_putdotix(struct qq_decls$varrec *p,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  a;
    if (((i64)(*p).tag == (i64)14)) {
        a = (*p).varptr;
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
            if (!((($rtemp=index, $rtemp >= (i64)0 && $rtemp <= (i64)63)))) {
                qq_lib$pcerror((byte*)"int.[int]:= bounds");
            }
;
            qq_vars$var_storebit((byte *)&(*a).value,index,x,(i64)32,(i64)1);
        }
        else if (($temp==(i64)9)) {
            qq_strings$var_putdotix_string(a,index,x);
        }
        else if (($temp==(i64)12)) {
            qq_records$var_putix_record(a,index,x);
        }
        else {
            qq_lib$pcustype((byte*)"putdotix",a);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"putdotix",p);
    }
;
}

void qq_vars$var_getdotixref(struct qq_decls$varrec *p,i64 index) {
        struct qq_decls$varrec *  a;
    if (((i64)(*p).tag == (i64)14)) {
        a = (*p).varptr;
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
            if (!((($rtemp=index, $rtemp >= (i64)0 && $rtemp <= (i64)63)))) {
                qq_lib$pcerror((byte*)"&int.[int] bounds");
            }
;
            (*p).ptr = (byte *)&(*a).value;
            (*p).tagx = (i64)15;
            (*p).elemtag = (i64)32;
            (*p).bitoffset = index;
            (*p).bitlength = (i64)1;
        }
        else if (($temp==(i64)9)) {
            qq_strings$var_getdotixref_string(a,index,p);
        }
        else if (($temp==(i64)12)) {
            qq_records$var_getixref_record(a,index,p);
        }
        else {
            qq_lib$pcustype_t((byte*)"getdotixref",(i64)(*a).tag);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"not refvar",p);
    }
;
}

void qq_vars$var_getdotslice(struct qq_decls$varrec *a,i64 i,i64 j) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        if ((i > j)) {
            {i64 temp = i; i = j; j = temp; };
        }
;
        if (((i < (i64)0) || (j > (i64)63))) {
            qq_lib$pcerror((byte*)"int.[slice] bounds");
        }
;
        (*a).value = (((*a).value >> i) & (i64)~(((u64)18446744073709551615u << ((j - i) + (i64)1))));
    }
    else if (($temp==(i64)9)) {
        qq_strings$var_getslice_string(a,i,j);
    }
    else {
        qq_lib$pcustype_t((byte*)"getdotslice",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_putdotslice(struct qq_decls$varrec *p,i64 i,i64 j,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  a;
    if (((i64)(*p).tag == (i64)14)) {
        a = (*p).varptr;
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
            if ((i > j)) {
                {i64 temp = i; i = j; j = temp; };
            }
;
            if (((i < (i64)0) || (j > (i64)63))) {
                qq_lib$pcerror((byte*)"int.[slice]:= bounds");
            }
;
            qq_vars$var_storebit((byte *)&(*a).value,i,x,(i64)32,((j - i) + (i64)1));
        }
        else if (($temp==(i64)9)) {
            qq_strings$var_putslice_string(a,i,j,x);
        }
        else {
            qq_lib$pcustype((byte*)"putdotslice",a);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"not ref",p);
    }
;
}

void qq_vars$var_getdotsliceref(struct qq_decls$varrec *p,i64 i,i64 j) {
        struct qq_decls$varrec *  a;
    if (((i64)(*p).tag == (i64)14)) {
        a = (*p).varptr;
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
            if ((i > j)) {
                {i64 temp = i; i = j; j = temp; };
            }
;
            if (((i < (i64)0) || (j > (i64)63))) {
                qq_lib$pcerror((byte*)"&int.[slice] bounds");
            }
;
            (*p).ptr = (byte *)&(*a).value;
            (*p).tagx = (i64)15;
            (*p).elemtag = (i64)32;
            (*p).bitoffset = i;
            (*p).bitlength = ((j - i) + (i64)1);
        }
        else {
            qq_lib$pcustype((byte*)"getdotsliceref",a);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"not ref",p);
    }
;
}

void qq_vars$var_expand(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 m) {
        struct qq_decls$varrec *  b;
        struct qq_decls$varrec *  c;
        struct qq_decls$objrec *  p;
        i64 n;
        i64 length;
        i64 $av_1;
        i64 $av_2;
    if ((m < (i64)2)) {
        qq_lib$pcerror((byte*)"Expand: LHS too few");
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)10)) {
        p = (*a).objptr;
        length = (*p).length;
        //dolist:
L1141 :;
;
        b = dest;
        c = (*p).varptr;
        n = (i64)1;
        $av_1 = m;
        while ($av_1-- > 0) {
L1142 :;
            if ((n > length)) {
                (*dest).tagx = (i64)0;
            }
            else {
                (*dest) = (*c);
                if (!!((i64)(*dest).hasref)) {
                    ++((*(*dest).objptr).refcount);
                }
;
                ++(c);
            }
;
            ++(n);
            --(dest);
L1143 :;
        }
L1144 :;
        ;
    }
    else if (($temp==(i64)4)) {
        (*dest).tagx = (i64)1;
        (*dest).value = msysc$m_getdotslice((*a).dummy,(i64)16,(i64)63);
        --(dest);
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)(*a).range_upper;
        $av_2 = (m - (i64)2);
        while ($av_2-- > 0) {
L1145 :;
            --(dest);
            (*dest).tagx = (i64)0;
L1146 :;
        }
L1147 :;
        ;
    }
    else if (($temp==(i64)9)) {
        qq_strings$var_expand_string(a,dest,m);
    }
    else if (($temp==(i64)12)) {
        p = (*a).objptr;
        length = qq_tables$ttlength[((i64)(*p).usertag)];
        goto L1141 ;
;
    }
    else if (($temp==(i64)11) || ($temp==(i64)7)) {
        qq_arrays$var_expand_array(a,dest,m);
    }
    else {
        qq_lib$pcustype((byte*)"expand",a);
    }
    };
}

void qq_vars$var_inplace(struct qq_decls$varrec *px,struct qq_decls$varrec *y,void (*fnadd)(struct qq_decls$varrec *,struct qq_decls$varrec *,...),void (*fnaddmixed)(struct qq_decls$varrec *,struct qq_decls$varrec *,...)) {
        struct qq_decls$varrec x;
    qq_vars$var_loadptr(px,&x);
    if (((i64)x.tag == (i64)(*y).tag)) {
        ((*fnadd))(&x,y);
    }
    else if (!!(fnaddmixed)) {
        ((*fnaddmixed))(&x,y);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Inplace mixed",&x,y);
    }
;
    qq_vars$var_storeptr(px,&x);
}

void qq_vars$var_inplace_unary(struct qq_decls$varrec *px,void (*fnneg)(struct qq_decls$varrec *,...)) {
        struct qq_decls$varrec x;
    qq_vars$var_loadptr(px,&x);
    ((*fnneg))(&x);
    qq_vars$var_storeptr(px,&x);
}

void qq_vars$var_loadptr(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)14)) {
        (*y) = (*(*x).varptr);
        if (!!((i64)(*y).hasref)) {
            ++((*(*y).objptr).refcount);
        }
;
    }
    else if (($temp==(i64)16)) {
        qq_packed$var_loadpacked((*x).ptr,(i64)(*x).elemtag,y,0);
    }
    else if (($temp==(i64)15)) {
        qq_vars$var_loadbit((*x).ptr,(i64)(*x).bitoffset,(i64)(*x).elemtag,(i64)(*x).bitlength,y);
    }
    else {
        qq_lib$pcustype((byte*)"var_loadptr",x);
    }
    };
}

void qq_vars$var_storeptr(struct qq_decls$varrec *p,struct qq_decls$varrec *q) {
        struct qq_decls$varrec *  dest;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)14)) {
        dest = (*p).varptr;
        if (!!((i64)(*dest).hasref)) {
            qq_vars$var_unshareu(dest);
        }
;
        (*dest) = (*q);
    }
    else if (($temp==(i64)16)) {
        qq_packed$var_storepacked((*p).ptr,q,(i64)(*p).elemtag);
    }
    else if (($temp==(i64)15)) {
        qq_vars$var_storebit((*p).ptr,(i64)(*p).bitoffset,q,(i64)(*p).elemtag,(i64)(*p).bitlength);
    }
    else {
        qq_lib$pcustype((byte*)"var_popptr",p);
    }
    };
}

void qq_vars$var_loadbit(byte *p,i64 shift,i64 t,i64 bitlength,struct qq_decls$varrec *dest) {
        u64 *  pd;
        u64 mask;
    (*dest).tagx = (i64)1;
    if ((t==(i64)32)) {
        if ((bitlength == (i64)0)) {
            (*dest).value = (i64)!!(((i64)(*p) & ((i64)1 << shift)));
        }
        else {
            pd = (u64 *)p;
            mask = (u64)18446744073709551614u;
            if ((bitlength==(i64)1)) {
            }
            else if ((bitlength==(i64)64)) {
                mask = (u64)0u;
            }
            else {
                mask <<= (bitlength - (i64)1);
            }
;
            (*dest).value = (i64)(((*pd) >> shift) & ~(mask));
        }
;
    }
    else if ((t==(i64)33)) {
        (*dest).value = (((i64)(*p) & ((i64)3 << shift)) >> shift);
    }
    else if ((t==(i64)34)) {
        (*dest).value = (((i64)(*p) & ((i64)15 << shift)) >> shift);
    }
    else {
        qq_lib$pcustype_t((byte*)"loadbit",t);
    }
;
}

void qq_vars$var_storebit(byte *p,i64 shift,struct qq_decls$varrec *q,i64 t,i64 bitlength) {
        u64 *  pd;
        u64 mask1;
        u64 mask2;
        u64 newvalue;
    if (((i64)(*q).tag != (i64)1)) {
        qq_lib$pcerror((byte*)"storebit not int");
    }
;
    if ((t==(i64)32)) {
        if ((bitlength == (i64)0)) {
            (*p) = (((i64)(*p) & ~(((i64)1 << shift))) | (((*q).value & (i64)1) << shift));
        }
        else {
            pd = (u64 *)p;
            mask1 = (u64)18446744073709551614u;
            if ((bitlength==(i64)1)) {
            }
            else if ((bitlength==(i64)64)) {
                mask1 = (u64)0u;
            }
            else {
                mask1 <<= (bitlength - (i64)1);
            }
;
            mask1 = ~(mask1);
            if (!!(shift)) {
                mask1 <<= shift;
            }
;
            mask2 = ~(mask1);
            newvalue = (u64)(*q).value;
            if (!!(shift)) {
                newvalue <<= shift;
            }
;
            (*pd) = (((*pd) & mask2) | (newvalue & mask1));
        }
;
    }
    else if ((t==(i64)33)) {
        (*p) = (((i64)(*p) & ~(((i64)3 << shift))) | (((*q).value & (i64)3) << shift));
    }
    else if ((t==(i64)34)) {
        (*p) = (((i64)(*p) & ~(((i64)15 << shift))) | (((*q).value & (i64)15) << shift));
    }
    else {
        qq_lib$pcustype_t((byte*)"storebit",t);
    }
;
}

void qq_vars$var_convert(struct qq_decls$varrec *x,i64 t,struct qq_decls$varrec *dest) {
        i64 s;
        i64 tbase;
        i64 aa;
    (*dest) = (*x);
    s = (i64)(*x).tag;
    if ((s == t)) {
        return;
    }
;
    tbase = t;
    (*dest).tag = t;
    if ((s==(i64)1)) {
        if ((tbase==(i64)1)) {
        }
        else if ((tbase==(i64)2)) {
            (*dest).xvalue = (r64)(*x).value;
        }
        else if ((tbase==(i64)3)) {
            qq_decimal$var_make_dec_int((*qq_decls$sptr).value,dest);
        }
        else {
            qq_lib$pcustype_t((byte*)"conv int=>",t);
        }
;
    }
    else if ((s==(i64)2)) {
        if ((tbase==(i64)1)) {
            (*dest).value = (i64)(*x).xvalue;
        }
        else {
            qq_lib$pcustype_t((byte*)"conv real=>",t);
        }
;
    }
    else if ((s==(i64)16) || (s==(i64)14) || (s==(i64)15)) {
                {i64 $temp = (i64)qq_tables$ttbasetype[(tbase)];
if (($temp==(i64)1)) {
        }
        else if (($temp==(i64)16)) {
            (*dest).tag = (i64)16;
            (*dest).elemtag = (i64)qq_tables$tttarget[(t)];
        }
        else {
            qq_lib$pcustype_t((byte*)"conv ptr=>",t);
        }
        };
    }
    else if ((s==(i64)9)) {
        if ((tbase==(i64)10)) {
            qq_strings$var_convert_string_list(x,t,dest);
        }
        else if ((tbase==(i64)3)) {
            qq_decimal$var_make_dec_str((*(*x).objptr).strptr,(*(*x).objptr).length,dest);
        }
        else if ((tbase==(i64)9)) {
        }
        else {
            qq_lib$pcustype_t((byte*)"string=>",t);
        }
;
    }
    else if ((s==(i64)18)) {
        if ((tbase != (i64)1)) {
            qq_lib$pcustype_t((byte*)"type=>",t);
        }
;
    }
    else if ((s==(i64)3)) {
        if ((tbase==(i64)1)) {
            aa = qq_decimal$var_convert_dec_int(x);
            (*dest).tagx = (i64)1;
            (*dest).value = aa;
        }
        else {
            qq_lib$pcustype_t((byte*)"decimal=>",t);
        }
;
    }
    else {
        qq_lib$pcmxtypestt((byte*)"Convert s.t",s,t);
    }
;
}

i64 qq_vars$var_gethashvalue(struct qq_decls$varrec *p) {
        i64 hsum;
        i64 c;
        i64 n;
        i64 result;
        u8 *  s;
        struct qq_decls$objrec *  q;
        i64 $av_1;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)9)) {
        n = (*(*p).objptr).length;
        if (!(!!(n))) {
            return (i64)0;
        }
;
        hsum = (i64)0;
        s = (*(*p).objptr).strptr;
        $av_1 = n;
        while ($av_1-- > 0) {
L1148 :;
            c = (i64)(u64)(*(s)++);
            hsum = (((hsum << (i64)4) - hsum) + c);
L1149 :;
        }
L1150 :;
        ;
        result = ((hsum << (i64)5) - hsum);
        return (result & (i64)9223372036854775807);
    }
    else if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4)) {
        return (*p).value;
    }
    else if (($temp==(i64)3)) {
        q = (*p).objptr;
        if (((*q).length == (i64)0)) {
            return (i64)0;
        }
        else {
            return (i64)(*(*q).num)[((i64)0)];
        }
;
    }
    else {
        qq_lib$pcustype((byte*)"Can't hash:",p);
    }
    };
    return (i64)0;
}

void qq_vars$var_objtovar(i64 tag,struct qq_decls$objrec *p,struct qq_decls$varrec *q) {
    (*q).tagx = (tag | (i64)256);
    (*q).objptr = p;
}

void qq_vars$var_putdotix_intint(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *b) {
        u64 x;
        u64 y;
    x = (u64)(*a).value;
    y = (u64)(*b).value;
    if (!((($rtemp=index, $rtemp >= (i64)0 && $rtemp <= (i64)63)))) {
        qq_lib$pcerror((byte*)"int.[int]:= bounds");
    }
;
    (*a).value = (((i64)x & ~(((i64)1 << index))) | (i64)(y << index));
}

void qq_vars$var_power(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_powermixed(a,b);
        return;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        (*a).value = msysc$m_power_i64((*b).value,(*a).value);
    }
    else if (($temp==(i64)2)) {
        (*a).xvalue = pow((*a).xvalue,(*b).xvalue);
    }
    else if (($temp==(i64)3)) {
        qq_decimal$var_power_dec(a,qq_decimal$var_convert_dec_int(b));
    }
    else {
        qq_lib$pcustype_t((byte*)"power",(i64)(*a).tag);
    }
    };
}

void qq_vars$var_powermixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        newtag = (i64)2;
        (*a).xvalue = pow((r64)(*a).value,(*b).xvalue);
    }
    else if (($temp==(i64)131073)) {
        (*a).xvalue = pow((*a).xvalue,(r64)(*b).value);
    }
    else if (($temp==(i64)196609)) {
        qq_decimal$var_power_dec(a,(*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Powermixed",a,b);
    }
    };
    (*a).tag = newtag;
}

// START
void qq_vars$start(void) {

}

void msysc$m_init(i64 nargs,u8 *(*args)[]) {
        i64 j;
        i64 i;
    msysc$nsysparams = nargs;
    if ((msysc$nsysparams > (i64)128)) {
        printf((byte*)"Too many params\n");
        exit((i64)1);
    }
;
    for (i=(i64)1;i<=nargs;++i) {
L1151 :;
        msysc$sysparams[(i)-1] = (*args)[(i)-1];
L1152 :;
    }
L1153 :;
    ;
    msysc$ncmdparams = (msysc$nsysparams - (msysc$$cmdskip + (i64)1));
    msysc$cmdparams = (u8 *(*)[])&msysc$sysparams[((msysc$$cmdskip + (i64)1))-1];
    j = (i64)1;
    msysc$nenvstrings = (i64)0;
}

i64 msysc$m_getdotindex(u64 a,i64 i) {
    return (((i64)a & ((i64)1 << i)) >> i);
}

u64 msysc$m_setdotindex(u64 a,i64 i,i64 x) {
    return (u64)(((i64)a & ~(((i64)1 << i))) | (i64)((u64)x << i));
}

i64 msysc$m_getdotslice(u64 a,i64 i,i64 j) {
    if ((i >= j)) {
        return (i64)((a >> j) & ~(((u64)18446744073709551615u << ((i - j) + (i64)1))));
    }
    else {
        return (i64)((a >> i) & ~(((u64)18446744073709551615u << ((j - i) + (i64)1))));
    }
;
}

u64 msysc$m_setdotslice(u64 a,i64 i,i64 j,u64 x) {
        u64 mask64;
    if ((i > j)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"SETDOTSLICE?",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)52);
    }
;
    mask64 = (~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i);
    return ((a & ~(mask64)) | (x << i));
}

i64 msysc$m_get_nprocs(void) {
    return msysc$_fnnprocs;
}

i64 msysc$m_get_nexports(void) {
    return msysc$_fnnexports;
}

u8 *msysc$m_get_procname(i64 n) {
    return msysc$_fnnames[(n)-1];
}

void *msysc$m_get_procaddr(i64 n) {
    return msysc$_fnaddresses[(n)-1];
}

void *msysc$m_get_procexport(i64 n) {
    return 0;
}

static void msysc$pushio(void) {
    if ((msysc$niostack >= (i64)10)) {
        printf((byte*)"Too many io levels\n");
        exit((i64)53);
    }
;
    ++(msysc$niostack);
    msysc$outchan_stack[(msysc$niostack)-1] = msysc$outchan;
    msysc$outdev_stack[(msysc$niostack)-1] = msysc$outdev;
    msysc$fmtstr_stack[(msysc$niostack)-1] = msysc$fmtstr;
    msysc$needgap_stack[(msysc$niostack)-1] = msysc$needgap;
    msysc$needgap = (i64)0;
    msysc$fmtstr = 0;
    msysc$outchan = 0;
}

void msysc$m_print_startfile(void *dev) {
    msysc$pushio();
    msysc$outchan = dev;
    if (!!(dev)) {
        msysc$outdev = (i64)2;
    }
    else {
        msysc$outdev = (i64)1;
    }
;
}

void msysc$m_print_startstr(u8 *s) {
        u8 **  p;
    msysc$pushio();
    msysc$ptr_stack[(msysc$niostack)-1] = s;
    p = &msysc$ptr_stack[(msysc$niostack)-1];
    msysc$outchan = p;
    msysc$outdev = (i64)3;
}

void msysc$m_print_startptr(u8 **p) {
    msysc$pushio();
    msysc$outchan = p;
    msysc$outdev = (i64)3;
}

void msysc$m_print_startcon(void) {
    msysc$pushio();
    msysc$outdev = (i64)1;
}

void msysc$m_print_setfmt(u8 *format) {
    msysc$fmtstr = format;
}

void msysc$m_print_end(void) {
    msysc$needgap = (i64)0;
    msysc$nextfmtchars((i64)1);
    if ((msysc$niostack == (i64)0)) {
        return;
    }
;
    msysc$outchan = msysc$outchan_stack[(msysc$niostack)-1];
    msysc$outdev = msysc$outdev_stack[(msysc$niostack)-1];
    msysc$fmtstr = msysc$fmtstr_stack[(msysc$niostack)-1];
    msysc$needgap = (i64)msysc$needgap_stack[(msysc$niostack)-1];
    --(msysc$niostack);
}

void msysc$m_print_ptr(void *a,u8 *fmtstyle) {
    msysc$nextfmtchars((i64)0);
    msysc$printstr(msysc$strword((u64)a,(byte*)"z8h"));
    msysc$needgap = (i64)1;
}

void msysc$m_print_i64(i64 a,u8 *fmtstyle) {
        u8 s[40];
        struct msysc$fmtrec fmt;
        i64 n;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        if ((a >= (i64)0)) {
            n = msysc$u64tostr((u64)a,(u8 *)s,(u64)10u,(i64)0);
        }
        else {
            s[((i64)1)-1] = '-';
            n = (msysc$u64tostr((u64)-(a),(u8 *)&s[((i64)2)-1],(u64)10u,(i64)0) + (i64)1);
        }
;
        msysc$printstr_n((u8 *)s,n);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,(struct msysc$fmtrec *)&fmt);
        if (((u64)fmt.param == 'V')) {
            msysc$fmtparam = a;
            msysc$needgap = (i64)0;
        }
        else {
            msysc$tostr_i64(a,(struct msysc$fmtrec *)&fmt);
        }
;
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_u64(u64 a,u8 *fmtstyle) {
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysc$printstr(msysc$strword(a,0));
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,(struct msysc$fmtrec *)&fmt);
        msysc$tostr_u64(a,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_r64(r64 x,u8 *fmtstyle) {
        u8 s[360];
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        sprintf((u8 *)s,(byte*)"%f",x);
        msysc$printstr((u8 *)s);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,(struct msysc$fmtrec *)&fmt);
        msysc$tostr_r64(x,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_r32(r32 x,u8 *fmtstyle) {
    msysc$m_print_r64((r64)x,fmtstyle);
}

void msysc$m_print_c8(i64 a,u8 *fmtstyle) {
        u8 s[40];
    msysc$nextfmtchars((i64)0);
    s[((i64)1)-1] = (u64)a;
    s[((i64)2)-1] = (u64)0u;
    msysc$printstr((u8 *)s);
    msysc$needgap = (i64)1;
}

void msysc$m_print_str(u8 *s,u8 *fmtstyle) {
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysc$printstr(s);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,(struct msysc$fmtrec *)&fmt);
        msysc$tostr_str(s,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_newline(void) {
    msysc$needgap = (i64)0;
    msysc$nextfmtchars((i64)1);
    msysc$printstr((byte*)"\n");
}

void msysc$m_print_nogap(void) {
    msysc$needgap = (i64)0;
}

void msysc$m_print_space(void) {
    msysc$needgap = (i64)0;
    msysc$printstr((byte*)" ");
}

void msysc$printstr(u8 *s) {
        u8 **  p;
    if ((msysc$outdev==(i64)1)) {
        printf((byte*)"%s",s);
    }
    else if ((msysc$outdev==(i64)2)) {
        fprintf(msysc$outchan,(byte*)"%s",s);
    }
    else if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        strcpy((*p),s);
        (*p) += strlen(s);
    }
;
}

void msysc$printstr_n(u8 *s,i64 n) {
        u8 str[256];
        u8 **  p;
    if ((n==(i64)-1)) {
        n = strlen(s);
    }
    else if ((n==(i64)0)) {
        return;
    }
;
    if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        memcpy((void *)(*p),(void *)s,(u64)n);
        (*p) += n;
        (*(*p)) = (u64)0u;
    }
    else if ((msysc$outdev==(i64)2)) {
        s = msysc$makezstring(s,n,(u8 *)str);
        fprintf(msysc$outchan,(byte*)"%s",s);
        msysc$freezstring(s,n);
    }
    else if ((msysc$outdev==(i64)1)) {
        s = msysc$makezstring(s,n,(u8 *)str);
        printf((byte*)"%s",s);
        msysc$freezstring(s,n);
    }
;
}

void msysc$printstrn_app(u8 *s,i64 length,void *f) {
    if (!!(length)) {
        if ((f == 0)) {
            printf((u8*)"%.*s",(i32)length,s);;
        }
        else {
            fprintf(f,(u8*)"%.*s",(i32)length,s);;
        }
;
    }
;
}

static u8 *msysc$makezstring(u8 *s,i64 n,u8 *local) {
        u8 *  t;
    if ((n < (i64)256)) {
        memcpy((void *)local,(void *)s,(u64)n);
        (*(local + n)) = (u64)0u;
        return local;
    }
    else {
        t = (u8 *)mlib$pcm_alloc((n + (i64)1));
        memcpy((void *)t,(void *)s,(u64)n);
        (*(t + n)) = (u64)0u;
        return t;
    }
;
}

static void msysc$freezstring(u8 *t,i64 n) {
    if ((n >= (i64)256)) {
        mlib$pcm_free((void *)t,(n + (i64)1));
    }
;
}

static void msysc$printchar(i64 ch) {
        u8 **  p;
    if ((msysc$outdev==(i64)1)) {
        printf((u8*)"%c",(int)ch);
    }
    else if ((msysc$outdev==(i64)2)) {
        fprintf(msysc$outchan,(u8*)"%c",(int)ch);
    }
    else if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        (*(*p)) = (u64)ch;
        (*p) += (i64)1;
        (*(*p)) = (u64)0u;
    }
;
}

void msysc$nextfmtchars(i64 lastx) {
        u8 c;
        u8 *  pstart;
        i64 n;
    if (!(!!(msysc$fmtstr))) {
        if (!!(msysc$needgap)) {
            msysc$printchar((i64)32);
        }
;
        msysc$needgap = (i64)0;
        return;
    }
;
    pstart = msysc$fmtstr;
    n = (i64)0;
    L1154 :;
    while (1) {
        c = (u64)(*msysc$fmtstr);
        switch ((i64)(u64)c) {
        case 35:;
            {
                if (!!(lastx)) {
                    goto L1156 ;
;
                }
;
                ++(msysc$fmtstr);
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                }
;
                return;
            }
            break;
        case 0:;
            {
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                }
                else if (!(!!(lastx))) {
                    msysc$printstr_n((byte*)"|",(i64)1);
                }
;
                return;
            }
            break;
        case 126:;
            {
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                    n = (i64)0;
                }
;
                ++(msysc$fmtstr);
                c = (u64)(*msysc$fmtstr);
                if (!!((u64)c)) {
                    ++(msysc$fmtstr);
                    msysc$printchar((i64)(u64)c);
                }
;
                pstart = msysc$fmtstr;
            }
            break;
        default: {
            //skip:
L1156 :;
;
            ++(n);
            ++(msysc$fmtstr);
        }
        } //SW
;
    }
L1155 :;
    ;
}

void msysc$strtofmt(u8 *s,i64 slen,struct msysc$fmtrec *fmt) {
        i64 c;
        i64 base;
        byte wset;
        i64 n;
        u8 str[100];
    (*fmt) = msysc$defaultfmt;
    if ((s == 0)) {
        return;
    }
;
    if ((slen == (i64)-1)) {
        slen = strlen(s);
    }
;
    memcpy(str,(void *)s,(u64)slen);
    str[(slen)] = (u64)0u;
    s = (u8 *)str;
    wset = (i64)0;
    L1157 :;
    while (!!((u64)(*s))) {
        c = (i64)(u64)(*s);
        ++(s);
        if ((c == (i64)65)) {
            (*fmt).lettercase = 'A';
        }
        else if ((c == (i64)97)) {
            (*fmt).lettercase = 'a';
        }
        else {
            switch (toupper((i32)c)) {
            case 66:;
                {
                    (*fmt).base = (i64)2;
                }
                break;
            case 72:;
                {
                    (*fmt).base = (i64)16;
                }
                break;
            case 79:;
                {
                    (*fmt).base = (i64)8;
                }
                break;
            case 88:;
                {
                    base = (i64)0;
                    L1160 :;
                    while (1) {
                        c = (i64)(u64)(*s);
                        if ((($rtemp=c, $rtemp >= (i64)48 && $rtemp <= (i64)57))) {
                            base = (((base * (i64)10) + c) - (i64)48);
                            ++(s);
                        }
                        else {
                            goto L1161 ;
                        }
;
                    }
L1161 :;
                    ;
                    if ((($rtemp=base, $rtemp >= (i64)2 && $rtemp <= (i64)16))) {
                        (*fmt).base = base;
                    }
;
                }
                break;
            case 81:;
                {
                    (*fmt).quotechar = '"';
                }
                break;
            case 74:;
                {
                    (*fmt).justify = (u64)toupper((i32)(u64)(*s));
                    if (!!((u64)(*s))) {
                        ++(s);
                    }
;
                }
                break;
            case 90:;
                {
                    (*fmt).padchar = '0';
                }
                break;
            case 83:;
                {
                    (*fmt).sepchar = (u64)(*s);
                    if (!!((u64)(*s))) {
                        ++(s);
                    }
;
                }
                break;
            case 80:;
                {
                    (*fmt).padchar = (u64)(*s);
                    if (!!((u64)(*s))) {
                        ++(s);
                    }
;
                }
                break;
            case 84:;
                {
                    (*fmt).suffix = (u64)(*s);
                    if (!!((u64)(*s))) {
                        ++(s);
                    }
;
                }
                break;
            case 85:;
                {
                    (*fmt).usigned = 'W';
                }
                break;
            case 69:;
                {
                    (*fmt).realfmt = 'e';
                }
                break;
            case 70:;
                {
                    (*fmt).realfmt = 'f';
                }
                break;
            case 71:;
                {
                    (*fmt).realfmt = 'g';
                }
                break;
            case 68:;
                {
                    (*fmt).charmode = 'D';
                }
                break;
            case 67:;
                {
                    (*fmt).charmode = 'C';
                }
                break;
            case 77:;
                {
                    (*fmt).heapmode = 'M';
                }
                break;
            case 86:;
                {
                    (*fmt).param = 'V';
                }
                break;
            case 89:;
                {
                    (*fmt).spare = msysc$m_setdotindex((*fmt).spare,(i64)0,(u64)1u);
                }
                break;
            case 78:;
                {
                    (*fmt).spare = msysc$m_setdotindex((*fmt).spare,(i64)1,(u64)1u);
                }
                break;
            default: {
                if ((c==(i64)46)) {
                    wset = (i64)1;
                }
                else if ((c==(i64)44) || (c==(i64)95)) {
                    (*fmt).sepchar = (u64)c;
                }
                else if ((c==(i64)43)) {
                    (*fmt).plus = '+';
                }
                else if ((c==(i64)126)) {
                    (*fmt).quotechar = '~';
                }
                else if ((c==(i64)42)) {
                    n = msysc$fmtparam;
                    goto L1162 ;
;
                }
                else {
                    if (((c >= (i64)48) && (c <= (i64)57))) {
                        n = (c - (i64)48);
                        L1163 :;
                        while (1) {
                            c = (i64)(u64)(*s);
                            if (((i64)(u64)(*s) == (i64)0)) {
                                goto L1164 ;
                            }
;
                            if (((c >= (i64)48) && (c <= (i64)57))) {
                                ++(s);
                                n = (((n * (i64)10) + c) - (i64)48);
                            }
                            else {
                                goto L1164 ;
                            }
;
                        }
L1164 :;
                        ;
                        //gotwidth:
L1162 :;
;
                        if (!(!!((i64)wset))) {
                            (*fmt).minwidth = n;
                            wset = (i64)1;
                        }
                        else {
                            (*fmt).precision = n;
                        }
;
                    }
;
                }
;
            }
            } //SW
;
        }
;
L1158 :;
    }
L1159 :;
    ;
}

static i64 msysc$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt) {
        u8 str[20];
        u8 *  q;
        i64 nchars;
        i64 $av_1;
    q = (u8 *)str;
    nchars = n;
    $av_1 = n;
    while ($av_1-- > 0) {
L1165 :;
        if (((i64)(u64)(*p) == (i64)0)) {
            goto L1167 ;
        }
;
        (*q) = (u64)(*p);
        ++(q);
        ++(p);
L1166 :;
    }
L1167 :;
    ;
    (*q) = (u64)0u;
    return msysc$expandstr((u8 *)str,dest,strlen((u8 *)str),(struct msysc$fmtrec *)fmt);
}

i64 msysc$expandstr(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt) {
        i64 i;
        i64 w;
        i64 m;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
        i64 $av_5;
    w = (i64)(*fmt).minwidth;
    if (((w == (i64)0) || (w <= n))) {
        strncpy(t,s,(u64)n);
        (*(t + n)) = (u64)0u;
        return n;
    }
;
    if (((u64)(*fmt).justify == 'L')) {
        strncpy(t,s,(u64)n);
        t += n;
                ($av_1 = (w - n));
        for (i=(i64)1;i<=$av_1;++i) {
L1168 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1169 :;
        }
L1170 :;
        ;
        (*t) = (u64)0u;
    }
    else if (((u64)(*fmt).justify == 'R')) {
        if (((((u64)(*fmt).padchar == '0') && !!((i64)(*fmt).base)) && (((u64)(*s) == '-') || ((u64)(*s) == '+')))) {
            (*t) = (u64)(*s);
            ++(t);
            $av_2 = (w - n);
            while ($av_2-- > 0) {
L1171 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L1172 :;
            }
L1173 :;
            ;
            strncpy(t,(s + (i64)1),(u64)(n - (i64)1));
            (*((t + n) - (i64)1)) = (u64)0u;
        }
        else {
            $av_3 = (w - n);
            while ($av_3-- > 0) {
L1174 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L1175 :;
            }
L1176 :;
            ;
            strncpy(t,s,(u64)n);
            (*(t + n)) = (u64)0u;
        }
;
    }
    else {
        m = (((w - n) + (i64)1) / (i64)2);
        $av_4 = m;
        while ($av_4-- > 0) {
L1177 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1178 :;
        }
L1179 :;
        ;
        strncpy(t,s,(u64)n);
        t += n;
        $av_5 = ((w - n) - m);
        while ($av_5-- > 0) {
L1180 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1181 :;
        }
L1182 :;
        ;
        (*t) = (u64)0u;
    }
;
    return w;
}

static i64 msysc$u64tostr(u64 aa,u8 *s,u64 base,i64 sep) {
        u8 t[1024];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
        u8 *  s0;
    i = (i64)0;
    k = (i64)0;
    g = (((i64)base == (i64)10) ? (i64)3 : (i64)4);
    L1183 :;
    do {
        t[(++(i))] = (u64)msysc$digits[((i64)(aa % base))];
        aa = (aa / base);
        ++(k);
        if (((!!(sep) && ((i64)aa != (i64)0)) && (k == g))) {
            t[(++(i))] = (u64)sep;
            k = (i64)0;
        }
;
L1184 :;
    }
    while (!((i64)aa == (i64)0));
L1185 :;
    ;
    j = i;
    s0 = s;
    L1186 :;
    while (!!(i)) {
        (*s) = (u64)t[((i)--)];
        ++(s);
L1187 :;
    }
L1188 :;
    ;
    (*s) = (u64)0u;
    return j;
}

i64 msysc$i64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt) {
        u8 str[1024];
        i64 n;
        i64 usigned;
        static u64 mindint = (u64)9223372036854775808u;
    usigned = (i64)0;
    if (!!((u64)(*fmt).usigned)) {
        usigned = (i64)1;
    }
;
    if (((aa == (i64)mindint) && !(!!(usigned)))) {
        str[((i64)0)] = '-';
        n = (msysc$i64mintostr((u8 *)&str[((i64)1)],(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
    }
    else {
        if (((!(!!(usigned)) && (aa < (i64)0)) || !!((u64)(*fmt).plus))) {
            if ((aa < (i64)0)) {
                aa = -(aa);
                str[((i64)0)] = '-';
            }
            else {
                str[((i64)0)] = '+';
            }
;
            n = (msysc$u64tostr((u64)aa,(u8 *)&str[((i64)1)],(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
        }
        else {
            n = msysc$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
        }
;
    }
;
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if (((((i64)(*fmt).base > (i64)10) || !!((u64)(*fmt).suffix)) && ((u64)(*fmt).lettercase == 'a'))) {
        msysc$convlcstring((u8 *)str);
    }
;
    return msysc$expandstr((u8 *)str,s,n,(struct msysc$fmtrec *)fmt);
}

i64 msysc$u64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt) {
        u8 str[1024];
        i64 n;
    n = msysc$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if ((((i64)(*fmt).base > (i64)10) || (!!((u64)(*fmt).suffix) && ((u64)(*fmt).lettercase == 'a')))) {
        msysc$convlcstring((u8 *)str);
    }
;
    return msysc$expandstr((u8 *)str,s,n,(struct msysc$fmtrec *)fmt);
}

static i64 msysc$i64mintostr(u8 *s,i64 base,i64 sep) {
        u8 t[1024];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
    switch (base) {
    case 10:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"9223372036854775808");
            j = (i64)3;
        }
        break;
    case 16:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"8000000000000000");
            j = (i64)1;
        }
        break;
    case 2:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"1000000000000000000000000000000000000000000000000000000000000000");
            j = (i64)7;
        }
        break;
    default: {
        strcpy((u8 *)&t[((i64)0)],(byte*)"<mindint>");
    }
    } //SW
;
    i = strlen((u8 *)&t[((i64)0)]);
    s += i;
    if (!!(sep)) {
        s += j;
    }
;
    (*s) = (u64)0u;
    k = (i64)0;
    g = ((base == (i64)10) ? (i64)3 : (i64)4);
    L1189 :;
    while (!!(i)) {
        --(s);
        (*s) = (u64)t[(((i)-- - (i64)1))];
        if (((!!(sep) && !!(i)) && (++(k) == g))) {
            --(s);
            (*s) = (u64)sep;
            k = (i64)0;
        }
;
L1190 :;
    }
L1191 :;
    ;
    return strlen(s);
}

i64 msysc$strtostrfmt(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt) {
        u8 *  u;
        u8 *  v;
        u8 str[256];
        i64 w;
        i64 nheap;
    nheap = (i64)0;
    if ((!!((u64)(*fmt).quotechar) || !!((u64)(*fmt).lettercase))) {
        if ((n < (i64)256)) {
            u = (u8 *)str;
        }
        else {
            nheap = (n + (i64)3);
            u = (u8 *)mlib$pcm_alloc(nheap);
        }
;
        if (!!((u64)(*fmt).quotechar)) {
            v = u;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            if (!!(n)) {
                strcpy(v,s);
                v += n;
            }
;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            (*v) = (u64)0u;
            n += (i64)2;
        }
        else {
            memcpy((void *)u,(void *)s,(u64)n);
        }
;
        switch ((i64)(u64)(*fmt).lettercase) {
        case 97:;
            {
                msysc$convlcstring(u);
            }
            break;
        case 65:;
            {
                msysc$convucstring(u);
            }
            break;
        } //SW
;
        s = u;
    }
;
    w = (i64)(*fmt).minwidth;
    if ((w > n)) {
        n = msysc$expandstr(s,t,n,(struct msysc$fmtrec *)fmt);
    }
    else {
        memcpy((void *)t,(void *)s,(u64)n);
    }
;
    if (!!(nheap)) {
        mlib$pcm_free((void *)u,nheap);
    }
;
    return n;
}

static void msysc$tostr_i64(i64 a,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp==(u64)0u)) {
        n = msysc$i64tostrfmt(a,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='D') || ($temp=='d')) {
        n = msysc$domultichar((u8 *)&a,(i64)8,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else {
        msysc$printchar(a);
        return;
    }
    };
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_u64(u64 a,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp=='D') || ($temp=='d')) {
        n = msysc$domultichar((u8 *)&a,(i64)8,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='C') || ($temp=='c')) {
        msysc$printchar((i64)a);
        return;
    }
    else {
        n = msysc$u64tostrfmt((i64)a,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    };
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_r64(r64 x,struct msysc$fmtrec *fmt) {
        u8 str[360];
        u8 str2[360];
        u8 cfmt[10];
        i64 n;
    cfmt[((i64)0)] = '%';
    if (!!((i64)(*fmt).precision)) {
        cfmt[((i64)1)] = '.';
        cfmt[((i64)2)] = '*';
        cfmt[((i64)3)] = (u64)(*fmt).realfmt;
        cfmt[((i64)4)] = (u64)0u;
        sprintf((u8 *)str,(u8 *)cfmt,(i64)(*fmt).precision,x);
    }
    else {
        cfmt[((i64)1)] = (u64)(*fmt).realfmt;
        cfmt[((i64)2)] = (u64)0u;
        sprintf((u8 *)str,(u8 *)cfmt,x);
    }
;
    n = strlen((u8 *)str);
    if ((n < (i64)(*fmt).minwidth)) {
        n = msysc$expandstr((u8 *)str,(u8 *)str2,n,(struct msysc$fmtrec *)fmt);
        strcpy((u8 *)str,(u8 *)str2);
    }
;
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_str(u8 *s,struct msysc$fmtrec *fmt) {
        i64 oldlen;
        i64 newlen;
        i64 n;
        u8 *  t;
    oldlen = strlen(s);
    newlen = oldlen;
    if (((!!((u64)(*fmt).quotechar) || ((i64)(*fmt).minwidth > newlen)) || !!((u64)(*fmt).lettercase))) {
        if (!!((u64)(*fmt).quotechar)) {
            newlen += (i64)2;
        }
;
        if (((i64)(*fmt).minwidth > newlen)) {
            newlen = (i64)(*fmt).minwidth;
        }
;
        t = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        n = msysc$strtostrfmt(s,t,oldlen,(struct msysc$fmtrec *)fmt);
        msysc$printstr_n(t,n);
        mlib$pcm_free((void *)t,(newlen + (i64)1));
    }
    else {
        msysc$printstr_n(s,oldlen);
    }
;
}

static struct msysc$fmtrec *msysc$getfmt(u8 *fmtstyle) {
        static struct msysc$fmtrec fmt;
    if (!!(fmtstyle)) {
        msysc$strtofmt(fmtstyle,(i64)-1,(struct msysc$fmtrec *)&fmt);
        return (struct msysc$fmtrec *)&fmt;
    }
    else {
        return (struct msysc$fmtrec *)&msysc$defaultfmt;
    }
;
}

u8 *msysc$strint(i64 a,u8 *fmtstyle) {
        static u8 str[100];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_i64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

void msysc$getstrint(i64 a,u8 *dest) {
    msysc$m_print_startstr(dest);
    msysc$tostr_i64(a,(struct msysc$fmtrec *)msysc$getfmt(0));
    msysc$m_print_end();
}

u8 *msysc$strword(u64 a,u8 *fmtstyle) {
        static u8 str[100];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_u64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

u8 *msysc$strreal(r64 a,u8 *fmtstyle) {
        static u8 str[320];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_r64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

static u8 *msysc$getstr(u8 *s,struct msysc$fmtrec *fmt) {
    if (!!((u64)(*fmt).heapmode)) {
        return mlib$pcm_copyheapstring(s);
    }
    else {
        return s;
    }
;
}

static void msysc$initreadbuffer(void) {
    if (!!(msysc$rd_buffer)) {
        return;
    }
;
    msysc$rd_buffer = (u8 *)mlib$pcm_alloc((i64)16384);
    (*msysc$rd_buffer) = (u64)0u;
    msysc$rd_pos = (msysc$rd_lastpos = msysc$rd_buffer);
}

void msysc$m_read_conline(void) {
    msysc$initreadbuffer();
    mlib$readlinen(0,msysc$rd_buffer,(i64)16384);
    msysc$rd_length = strlen(msysc$rd_buffer);
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

void msysc$m_read_fileline(void *f) {
    msysc$initreadbuffer();
    mlib$readlinen(f,msysc$rd_buffer,(i64)16384);
    msysc$rd_length = strlen(msysc$rd_buffer);
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

void msysc$m_read_strline(u8 *s) {
        i64 n;
    msysc$initreadbuffer();
    n = strlen(s);
    if ((n < (i64)16384)) {
        strcpy(msysc$rd_buffer,s);
    }
    else {
        memcpy((void *)msysc$rd_buffer,(void *)s,(u64)16383u);
        (*((msysc$rd_buffer + (i64)16384) - (i64)1)) = (u64)0u;
    }
;
    msysc$rd_length = n;
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

static u8 *msysc$readitem(i64 *itemlength) {
        u8 *  p;
        u8 *  s;
        u8 *  itemstr;
        u8 quotechar;
        u8 c;
    if (!(!!(msysc$rd_buffer))) {
        msysc$initreadbuffer();
    }
;
    s = msysc$rd_pos;
    L1192 :;
    while ((((u64)(*s) == ' ') || ((i64)(u64)(*s) == (i64)9))) {
        ++(s);
L1193 :;
    }
L1194 :;
    ;
    itemstr = s;
    msysc$rd_lastpos = (msysc$rd_pos = s);
    if (((i64)(u64)(*s) == (i64)0)) {
        msysc$termchar = (i64)0;
        (*itemlength) = (i64)0;
        return s;
    }
;
    quotechar = (u64)0u;
    if (((u64)(*s) == '"')) {
        quotechar = '"';
        ++(s);
    }
    else if (((u64)(*s) == (u64)39u)) {
        quotechar = (u64)39u;
        ++(s);
    }
;
    p = (itemstr = s);
    L1195 :;
    while (!!((u64)(*s))) {
        c = (u64)(*(s)++);
        switch ((i64)(u64)c) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
            {
                if ((!!((u64)quotechar) || (p == s))) {
                    goto L1198 ;
;
                }
;
                msysc$termchar = (i64)(u64)c;
                goto L1197 ;
            }
            break;
        default: {
            //normalchar:
L1198 :;
;
            if (((u64)c == (u64)quotechar)) {
                if (((u64)(*s) == (u64)quotechar)) {
                    (*p) = (u64)c;
                    ++(s);
                    ++(p);
                }
                else {
                    msysc$termchar = (i64)(u64)(*s);
                    if (((msysc$termchar == (i64)44) || (msysc$termchar == (i64)61))) {
                        ++(s);
                        msysc$termchar = (i64)(u64)(*s);
                    }
;
                    goto L1197 ;
                }
;
            }
            else {
                (*p) = (u64)c;
                ++(p);
            }
;
        }
        } //SW
;
L1196 :;
    }
L1197 :;
    ;
    if (((i64)(u64)(*s) == (i64)0)) {
        msysc$termchar = (i64)0;
    }
;
    (*itemlength) = (p - itemstr);
    msysc$rd_pos = s;
    return itemstr;
}

i64 msysc$strtoint(u8 *s,i64 length,i64 base) {
        byte signd;
        u64 aa;
        u8 c;
        u8 d;
    msysc$itemerror = (i64)0;
    if ((length == (i64)-1)) {
        length = strlen(s);
    }
;
    signd = (i64)0;
    if ((!!(length) && ((u64)(*s) == '-'))) {
        signd = (i64)1;
        ++(s);
        --(length);
    }
    else if ((!!(length) && ((u64)(*s) == '+'))) {
        ++(s);
        --(length);
    }
;
    aa = (u64)0u;
    L1199 :;
    while (!!(length)) {
        c = (u64)(*(s)++);
        --(length);
        switch ((i64)(u64)c) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
            {
                d = (u64)((i64)((u64)c - 'A') + (i64)10);
            }
            break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
            {
                d = (u64)((i64)((u64)c - 'a') + (i64)10);
            }
            break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                d = ((u64)c - '0');
            }
            break;
        case 95:;
        case 39:;
            {
                goto L1200 ;
            }
            break;
        default: {
            msysc$itemerror = (i64)1;
            goto L1201 ;
        }
        } //SW
;
        if (((i64)(u64)d >= base)) {
            msysc$itemerror = (i64)1;
            goto L1201 ;
        }
;
        aa = (u64)(((i64)aa * base) + (i64)(u64)d);
L1200 :;
    }
L1201 :;
    ;
    if (!!((i64)signd)) {
        return (i64)-(aa);
    }
    else {
        return (i64)aa;
    }
;
}

i64 msysc$m_read_i64(i64 fmt) {
        u8 *  s;
        i64 length;
    if ((fmt==(i64)67) || (fmt==(i64)99)) {
        msysc$rd_lastpos = msysc$rd_pos;
        if (!!((u64)(*msysc$rd_pos))) {
            return (i64)(u64)(*(msysc$rd_pos)++);
        }
        else {
            return (i64)0;
        }
;
    }
    else if ((fmt==(i64)84) || (fmt==(i64)116)) {
        return msysc$termchar;
    }
    else if ((fmt==(i64)69) || (fmt==(i64)101)) {
        return msysc$itemerror;
    }
;
    s = msysc$readitem(&length);
    if ((fmt==(i64)0) || (fmt==(i64)73) || (fmt==(i64)105)) {
        return msysc$strtoint(s,length,(i64)10);
    }
    else if ((fmt==(i64)66) || (fmt==(i64)98)) {
        return msysc$strtoint(s,length,(i64)2);
    }
    else if ((fmt==(i64)72) || (fmt==(i64)104)) {
        return msysc$strtoint(s,length,(i64)16);
    }
;
    return (i64)0;
}

r64 msysc$m_read_r64(i64 fmt) {
        u8 str[512];
        u8 *  s;
        i64 length;
        i32 numlength;
        r64 x;
    s = msysc$readitem(&length);
    if (((length == (i64)0) || (length >= (i64)512))) {
        return (double)0.;
    }
;
    memcpy(str,(void *)s,(u64)length);
    str[((length + (i64)1))-1] = (u64)0u;
    msysc$itemerror = (i64)0;
    if (((sscanf((u8 *)str,(byte*)"%lf%n",&x,&numlength) == (i64)0) || ((i64)numlength != length))) {
        x = (double)0.;
        msysc$itemerror = (i64)1;
    }
;
    return x;
}

void msysc$m_read_str(u8 *dest,i64 destlen,i64 fmt) {
        u8 *  s;
        i64 length;
    msysc$itemerror = (i64)0;
    if (((fmt == (i64)76) || (fmt == (i64)108))) {
        s = msysc$rd_pos;
        length = ((msysc$rd_buffer + msysc$rd_length) - msysc$rd_pos);
    }
    else {
        s = msysc$readitem(&length);
        if (((fmt == (i64)78) || (fmt == (i64)110))) {
            msysc$iconvlcn(s,length);
        }
;
    }
;
    if ((destlen > (i64)0)) {
        if ((length >= destlen)) {
            length = (destlen - (i64)1);
            msysc$itemerror = (i64)1;
        }
;
    }
;
    memcpy((void *)dest,(void *)s,(u64)length);
    (*(dest + length)) = (u64)0u;
}

void msysc$readstr(u8 *dest,i64 fmt,i64 destlen) {
    msysc$m_read_str(dest,destlen,fmt);
}

void msysc$rereadln(void) {
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = msysc$rd_pos;
}

void msysc$reread(void) {
    msysc$rd_pos = msysc$rd_lastpos;
}

i64 msysc$valint(u8 *s,i64 fmt) {
        u8 *  old_pos;
        u8 *  old_lastpos;
        i64 aa;
    msysc$initreadbuffer();
    old_pos = msysc$rd_pos;
    old_lastpos = msysc$rd_lastpos;
    msysc$rd_pos = s;
    aa = msysc$m_read_i64(fmt);
    msysc$rd_pos = old_pos;
    msysc$rd_lastpos = old_lastpos;
    return aa;
}

r64 msysc$valreal(u8 *s) {
        u8 *  old_pos;
        u8 *  old_lastpos;
        r64 x;
    msysc$initreadbuffer();
    old_pos = msysc$rd_pos;
    old_lastpos = msysc$rd_lastpos;
    msysc$rd_pos = s;
    x = msysc$m_read_r64((i64)0);
    msysc$rd_pos = old_pos;
    msysc$rd_lastpos = old_lastpos;
    return x;
}

static void msysc$iconvlcn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1202 :;
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1203 :;
    }
L1204 :;
    ;
}

static void msysc$iconvucn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1205 :;
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1206 :;
    }
L1207 :;
    ;
}

static void msysc$convlcstring(u8 *s) {
    L1208 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1209 :;
    }
L1210 :;
    ;
}

static void msysc$convucstring(u8 *s) {
    L1211 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1212 :;
    }
L1213 :;
    ;
}

i64 msysc$m_power_i64(i64 n,i64 a) {
    if ((n < (i64)0)) {
        return (i64)0;
    }
    else if ((n == (i64)0)) {
        return (i64)1;
    }
    else if ((n == (i64)1)) {
        return a;
    }
    else if (((n & (i64)1) == (i64)0)) {
        return msysc$m_power_i64((n / (i64)2),(a*a));
    }
    else {
        return (msysc$m_power_i64(((n - (i64)1) / (i64)2),(a*a)) * a);
    }
;
}

void msysc$m_intoverflow(void) {
    mlib$abortprogram((byte*)"Integer overflow detected");
}

void msysc$m_dotindex(u64 i,u64 a) {
    mlib$abortprogram((byte*)"DOT INDEX");
}

void msysc$m_dotslice(u64 j,u64 i,u64 a) {
    mlib$abortprogram((byte*)"DOT SLICE");
}

void msysc$m_popdotindex(u64 i,u64 *p,u64 x) {
    mlib$abortprogram((byte*)"POP DOT INDEX");
}

void msysc$m_popdotslice(u64 j,u64 i,u64 *p,u64 x) {
    mlib$abortprogram((byte*)"POP DOT SLICE");
}

i64 msysc$m_imin(i64 a,i64 b) {
    return (a<b?a:b);
}

i64 msysc$m_imax(i64 a,i64 b) {
    return (a>b?a:b);
}

r64 msysc$m_sign(r64 x) {
    if ((x > (double)0.)) {
        return (double)1.;
    }
    else if ((x < (double)0.)) {
        return (double)-1.;
    }
    else {
        return (double)0.;
    }
;
}

r64 msysc$m_tp_i64tor64(i64 a) {
        r64 x;
    memcpy(&x,&a,(u64)8u);
    return x;
}

i64 msysc$m_tp_r64toi64(r64 x) {
        i64 a;
    memcpy(&a,&x,(u64)8u);
    return a;
}

i64 msysc$m_tp_reftoi64(void *p) {
        i64 a;
    memcpy(&a,&p,(u64)8u);
    return a;
}

void *msysc$m_tp_i64toref(i64 a) {
        void *  p;
    memcpy(&p,&a,(u64)8u);
    return p;
}

// START
void msysc$start(void) {
    mlib$start();
    mclib$start();
    mlinux$start();
    mwindllc$start();

}

void *mlib$pcm_alloc(i64 n) {
        byte *  p;
    if (!(!!((i64)mlib$pcm_setup))) {
        mlib$pcm_init();
    }
;
    if ((n > (i64)2048)) {
        mlib$alloccode = mlib$pcm_getac(n);
        mlib$allocbytes = (i64)mlib$allocupper[(mlib$alloccode)];
        p = (byte *)mlib$allocmem(mlib$allocbytes);
        if (!(!!(p))) {
            mlib$abortprogram((byte*)"pcm_alloc failure");
        }
;
        return p;
    }
;
    mlib$alloccode = (i64)mlib$sizeindextable[(n)];
    mlib$allocbytes = (i64)mlib$allocupper[(mlib$alloccode)];
    mlib$smallmemtotal += mlib$allocbytes;
    if (!!((p = (byte *)mlib$freelist[(mlib$alloccode)]))) {
        mlib$freelist[(mlib$alloccode)] = (u64 *)(i64)(*mlib$freelist[(mlib$alloccode)]);
        return p;
    }
;
    p = mlib$pcheapptr;
    mlib$pcheapptr += mlib$allocbytes;
    if ((mlib$pcheapptr >= mlib$pcheapend)) {
        p = (byte *)mlib$pcm_newblock(mlib$allocbytes);
        return p;
    }
;
    return p;
}

void mlib$pcm_free(void *p,i64 n) {
        i64 acode;
    if ((n == (i64)0)) {
        return;
    }
;
    if ((n > (i64)2048)) {
        mlib$memtotal -= n;
        free(p);
        return;
    }
;
    if (!!(p)) {
        acode = (i64)mlib$sizeindextable[(n)];
        mlib$smallmemtotal -= (i64)mlib$allocupper[(acode)];
        (*(u64 *)p) = (u64)(i64)mlib$freelist[(acode)];
        mlib$freelist[(acode)] = (u64 *)p;
    }
;
}

void mlib$pcm_freeac(void *p,i64 alloc) {
    mlib$pcm_free(p,(i64)mlib$allocupper[(alloc)]);
}

void mlib$pcm_clearmem(void *p,i64 n) {
    memset(p,(i32)(i64)0,(u64)n);
}

void mlib$pcm_init(void) {
        i64 j;
        i64 k;
        i64 size;
        i64 i;
    mlib$alloccode = (i64)0;
    if (!!((i64)mlib$pcm_setup)) {
        return;
    }
;
    mlib$pcm_newblock((i64)0);
    for (i=(i64)1;i<=(i64)2048;++i) {
L1214 :;
        j = (i64)1;
        k = (i64)16;
        L1217 :;
        while ((i > k)) {
            k = (k << (i64)1);
            ++(j);
L1218 :;
        }
L1219 :;
        ;
        mlib$sizeindextable[(i)] = j;
L1215 :;
    }
L1216 :;
    ;
    mlib$allocupper[((i64)1)] = (u64)16u;
    size = (i64)16;
    for (i=(i64)2;i<=(i64)27;++i) {
L1220 :;
        size *= (i64)2;
        mlib$allocupper[(i)] = (u64)size;
        if ((size >= (i64)33554432)) {
            k = i;
            goto L1222 ;
        }
;
L1221 :;
    }
L1222 :;
    ;
    for (i=(k + (i64)1);i<=(i64)300;++i) {
L1223 :;
        size += (i64)33554432;
        if ((size < (i64)8589934592)) {
            mlib$allocupper[(i)] = (u64)size;
            mlib$maxmemory = (u64)size;
        }
        else {
            mlib$maxalloccode = (i - (i64)1);
            goto L1225 ;
        }
;
L1224 :;
    }
L1225 :;
    ;
    mlib$pcm_setup = (i64)1;
}

i64 mlib$pcm_getac(i64 size) {
    if ((size <= (i64)2048)) {
        return (i64)mlib$sizeindextable[(size)];
    }
;
    size = ((size + (i64)255) >> (i64)8);
    if ((size <= (i64)2048)) {
        return ((i64)mlib$sizeindextable[(size)] + (i64)8);
    }
;
    size = ((size + (i64)63) >> (i64)6);
    if ((size <= (i64)2048)) {
        return ((i64)mlib$sizeindextable[(size)] + (i64)14);
    }
;
    size = ((((size - (i64)2048) + (i64)2047) / (i64)2048) + (i64)22);
    return size;
}

void *mlib$pcm_newblock(i64 itemsize) {
        static i64 totalheapsize;
        byte *  p;
    totalheapsize += (i64)2097152;
    mlib$alloccode = (i64)0;
    p = (byte *)mlib$allocmem((i64)2097152);
    if ((p == 0)) {
        mlib$abortprogram((byte*)"Can't alloc pc heap");
    }
;
    memset(p,(i32)(i64)0,(u64)2097152u);
    mlib$pcheapptr = p;
    mlib$pcheapend = (p + (i64)2097152);
    if ((mlib$pcheapstart == 0)) {
        mlib$pcheapstart = p;
    }
;
    mlib$pcheapptr += itemsize;
    return (u32 *)p;
}

i64 mlib$pcm_round(i64 n) {
        static i32 allocbytes[9] = {(i32)(i64)0,(i32)(i64)16,(i32)(i64)32,(i32)(i64)64,(i32)(i64)128,(i32)(i64)256,(i32)(i64)512,(i32)(i64)1024,(i32)(i64)2048};
    if ((n > (i64)2048)) {
        return n;
    }
    else {
        return (i64)allocbytes[((i64)mlib$sizeindextable[(n)])];
    }
;
}

void *mlib$pcm_allocz(i64 n) {
        void *  p;
    p = mlib$pcm_alloc(n);
    memset(p,(i32)(i64)0,(u64)n);
    return p;
}

u8 *mlib$pcm_copyheapstring(u8 *s) {
        u8 *  q;
        i64 n;
    if ((s == 0)) {
        return 0;
    }
;
    n = (strlen(s) + (i64)1);
    q = (u8 *)mlib$pcm_alloc(n);
    memcpy((void *)q,(void *)s,(u64)n);
    return q;
}

u8 *mlib$pcm_copyheapstringn(u8 *s,i64 n) {
        u8 *  q;
    if ((s == 0)) {
        return 0;
    }
;
    q = (u8 *)mlib$pcm_alloc((n + (i64)1));
    memcpy((void *)q,(void *)s,(u64)n);
    (*(q + n)) = (u64)0u;
    return q;
}

u8 *mlib$pcm_copyheapblock(u8 *s,i64 length) {
        u8 *  q;
    if ((length == (i64)0)) {
        return 0;
    }
;
    q = (u8 *)mlib$pcm_alloc(length);
    memcpy((void *)q,(void *)s,(u64)length);
    return q;
}

void *mlib$allocmem(i64 n) {
        void *  p;
    p = malloc((u64)n);
    if (!!(p)) {
        mlib$memtotal += n;
        return p;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_i64(mlib$memtotal,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$abortprogram((byte*)"Alloc mem failure");
    return 0;
}

void *mlib$reallocmem(void *p,i64 n) {
    p = realloc(p,(u64)n);
    if (!!(p)) {
        return p;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$abortprogram((byte*)"Realloc mem failure");
    return 0;
}

void mlib$abortprogram(u8 *s) {
    msysc$m_print_startcon();
    msysc$m_print_str(s,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"ABORTING: Press key...",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)5);
}

i64 mlib$getfilesize(void *handlex) {
        u32 p;
        u32 size;
    p = ftell(handlex);
    fseek(handlex,(i32)(i64)0,(i32)(i64)2);
    size = ftell(handlex);
    fseek(handlex,(i32)(i64)p,(i32)(i64)0);
    return (i64)size;
}

void mlib$readrandom(void *handlex,byte *mem,i64 offset,i64 size) {
        i64 a;
    fseek(handlex,(i32)offset,(i32)(i64)0);
    a = (i64)fread(mem,(u64)1u,(u64)size,handlex);
}

i64 mlib$writerandom(void *handlex,byte *mem,i64 offset,i64 size) {
    fseek(handlex,(i32)offset,(i32)(i64)0);
    return (i64)fwrite(mem,(u64)1u,(u64)size,handlex);
}

i64 mlib$setfilepos(void *file,i64 offset) {
    return fseek(file,(i32)offset,(i32)(i64)0);
}

i64 mlib$getfilepos(void *file) {
    return ftell(file);
}

byte *mlib$readfile(u8 *filename) {
        void *  f;
        i64 size;
        byte *  m;
        byte *  p;
    f = fopen(filename,(byte*)"rb");
    if ((f == 0)) {
        return 0;
    }
;
    mlib$rfsize = (size = mlib$getfilesize(f));
    m = (byte *)mlib$pcm_alloc((size + (i64)2));
    if ((m == 0)) {
        return 0;
    }
;
    mlib$readrandom(f,m,(i64)0,size);
    p = (m + size);
    (*(u16 *)p) = (i64)0;
    fclose(f);
    return m;
}

i64 mlib$writefile(u8 *filename,byte *data,i64 size) {
        void *  f;
        i64 n;
    f = fopen(filename,(byte*)"wb");
    if ((f == 0)) {
        return (i64)0;
    }
;
    n = mlib$writerandom(f,data,(i64)0,size);
    fclose(f);
    return n;
}

i64 mlib$checkfile(u8 *file) {
        void *  f;
    if (!!((f = fopen(file,(byte*)"rb")))) {
        fclose(f);
        return (i64)1;
    }
;
    return (i64)0;
}

void mlib$readlinen(void *handlex,u8 *buffer,i64 size) {
        i64 ch;
        u8 *  p;
        i64 n;
        byte crseen;
    if ((handlex == 0)) {
        handlex = mlinux$os_getstdin();
    }
;
    if ((handlex == 0)) {
        n = (i64)0;
        p = buffer;
        L1226 :;
        while (1) {
            ch = getchar();
            if ((((ch == (i64)13) || (ch == (i64)10)) || (ch == (i64)-1))) {
                (*p) = (u64)0u;
                return;
            }
;
            (*(p)++) = (u64)ch;
            ++(n);
            if ((n >= (size - (i64)2))) {
                (*p) = (u64)0u;
                return;
            }
;
        }
L1227 :;
        ;
    }
;
    (*buffer) = (u64)0u;
    if ((fgets(buffer,(size - (i64)2),handlex) == 0)) {
        return;
    }
;
    n = strlen(buffer);
    if ((n == (i64)0)) {
        return;
    }
;
    p = ((buffer + n) - (i64)1);
    crseen = (i64)0;
    L1228 :;
    while (((p >= buffer) && (((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10)))) {
        if ((((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10))) {
            crseen = (i64)1;
        }
;
        (*(p)--) = (u64)0u;
L1229 :;
    }
L1230 :;
    ;
    if ((!(!!((i64)crseen)) && ((n + (i64)4) > size))) {
        msysc$m_print_startcon();
        msysc$m_print_i64(size,NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mlib$abortprogram((byte*)"line too long");
    }
;
}

void mlib$iconvlcn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1231 :;
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1232 :;
    }
L1233 :;
    ;
}

void mlib$iconvucn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1234 :;
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1235 :;
    }
L1236 :;
    ;
}

u8 *mlib$convlcstring(u8 *s) {
        u8 *  s0;
    s0 = s;
    L1237 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1238 :;
    }
L1239 :;
    ;
    return s0;
}

u8 *mlib$convucstring(u8 *s) {
        u8 *  s0;
    s0 = s;
    L1240 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1241 :;
    }
L1242 :;
    ;
    return s0;
}

u8 *mlib$changeext(u8 *s,u8 *newext) {
        static u8 newfile[260];
        u8 newext2[32];
        u8 *  sext;
        i64 n;
    strcpy((u8 *)&newfile[((i64)1)-1],s);
        {u64 $temp = (u64)(*newext);
if (($temp==(u64)0u)) {
        newext2[((i64)1)-1] = (u64)0u;
        newext2[((i64)2)-1] = (u64)0u;
    }
    else if (($temp=='.')) {
        strcpy((u8 *)&newext2[((i64)1)-1],newext);
    }
    else {
        strcpy((u8 *)&newext2[((i64)1)-1],(byte*)".");
        strcat((u8 *)&newext2[((i64)1)-1],newext);
    }
    };
    sext = mlib$extractext(s,(i64)1);
        {u64 $temp = (u64)(*sext);
if (($temp==(u64)0u)) {
        strcat((u8 *)&newfile[((i64)1)-1],(u8 *)&newext2[((i64)1)-1]);
    }
    else if (($temp=='.')) {
        strcat((u8 *)&newfile[((i64)1)-1],(u8 *)&newext2[((i64)2)-1]);
    }
    else {
        n = ((sext - s) - (i64)2);
        strcpy((u8 *)((&newfile[((i64)1)-1] + n) + (i64)1),(u8 *)&newext2[((i64)1)-1]);
    }
    };
    return (u8 *)&newfile[((i64)1)-1];
}

u8 *mlib$extractext(u8 *s,i64 period) {
        u8 *  t;
        u8 *  u;
    t = mlib$extractfile(s);
    if (((i64)(u64)(*t) == (i64)0)) {
        return (byte*)"";
    }
;
    u = ((t + strlen(t)) - (i64)1);
    L1243 :;
    while ((u >= t)) {
        if (((u64)(*u) == '.')) {
            if (((i64)(u64)(*(u + (i64)1)) == (i64)0)) {
                return (!!(period) ? (byte*)"." : (byte*)"");
            }
;
            return (u + (i64)1);
        }
;
        --(u);
L1244 :;
    }
L1245 :;
    ;
    return (byte*)"";
}

u8 *mlib$extractpath(u8 *s) {
        static u8 str[260];
        u8 *  t;
        i64 n;
    t = ((s + strlen(s)) - (i64)1);
    L1246 :;
    while ((t >= s)) {
        switch ((i64)(u64)(*t)) {
        case 92:;
        case 47:;
        case 58:;
            {
                n = ((t - s) + (i64)1);
                memcpy(str,(void *)s,(u64)n);
                str[(n)] = (u64)0u;
                return (u8 *)str;
            }
            break;
        } //SW
;
        --(t);
L1247 :;
    }
L1248 :;
    ;
    return (byte*)"";
}

u8 *mlib$extractfile(u8 *s) {
        u8 *  t;
    t = mlib$extractpath(s);
    if (((i64)(u64)(*t) == (i64)0)) {
        return s;
    }
;
    return (s + strlen(t));
}

u8 *mlib$extractbasefile(u8 *s) {
        static u8 str[100];
        u8 *  f;
        u8 *  e;
        i64 n;
        i64 flen;
    f = mlib$extractfile(s);
    flen = strlen(f);
    if ((flen == (i64)0)) {
        return (byte*)"";
    }
;
    e = mlib$extractext(f,(i64)0);
    if (!!((u64)(*e))) {
        n = ((flen - strlen(e)) - (i64)1);
        memcpy(&str,(void *)f,(u64)n);
        str[(n)] = (u64)0u;
        return (u8 *)str;
    }
;
    if (((u64)(*((f + flen) - (i64)1)) == '.')) {
        memcpy(&str,(void *)f,(u64)(flen - (i64)1));
        str[((flen - (i64)1))] = (u64)0u;
        return (u8 *)str;
    }
;
    return f;
}

u8 *mlib$addext(u8 *s,u8 *newext) {
        u8 *  sext;
    sext = mlib$extractext(s,(i64)1);
    if (((i64)(u64)(*sext) == (i64)0)) {
        return mlib$changeext(s,newext);
    }
;
    return s;
}

void *mlib$pcm_alloc32(void) {
        byte *  p;
    mlib$allocbytes = (i64)32;
    mlib$smallmemtotal += (i64)32;
    if (!!((p = (byte *)mlib$freelist[((i64)2)]))) {
        mlib$freelist[((i64)2)] = (u64 *)(i64)(*mlib$freelist[((i64)2)]);
        return p;
    }
;
    return mlib$pcm_alloc((i64)32);
}

void mlib$pcm_free32(void *p) {
    mlib$smallmemtotal -= (i64)32;
    (*(u64 *)p) = (u64)(i64)mlib$freelist[((i64)2)];
    mlib$freelist[((i64)2)] = (u64 *)p;
}

void mlib$outbyte(void *f,i64 x) {
    fwrite(&x,(u64)1u,(u64)1u,f);
}

void mlib$outword16(void *f,u64 x) {
    fwrite(&x,(u64)2u,(u64)1u,f);
}

void mlib$outword32(void *f,u64 x) {
    fwrite(&x,(u64)4u,(u64)1u,f);
}

void mlib$outword64(void *f,u64 x) {
    fwrite(&x,(u64)8u,(u64)1u,f);
}

void mlib$outstring(void *f,u8 *s) {
    fwrite((void *)s,(u64)(strlen(s) + (i64)1),(u64)1u,f);
}

void mlib$outblock(void *f,void *p,i64 n) {
    fwrite(p,(u64)n,(u64)1u,f);
}

i64 mlib$myeof(void *f) {
        i64 c;
    c = fgetc(f);
    if ((c == (i64)-1)) {
        return (i64)1;
    }
;
    ungetc((i32)c,f);
    return (i64)0;
}

void mlib$strbuffer_add(struct mlib$strbuffer *dest,u8 *s,i64 n) {
        i64 newlen;
        i64 oldlen;
        u8 *  newptr;
    if ((n == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=0",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((n == (i64)-1)) {
        n = strlen(s);
    }
;
    oldlen = (i64)(*dest).length;
    if ((oldlen == (i64)0)) {
        (*dest).strptr = (u8 *)mlib$pcm_alloc((n + (i64)1));
        (*dest).allocated = mlib$allocbytes;
        (*dest).length = n;
        memcpy((void *)(*dest).strptr,(void *)s,(u64)n);
        (*((*dest).strptr + n)) = (u64)0u;
        return;
    }
;
    newlen = (oldlen + n);
    if (((newlen + (i64)1) > (i64)(*dest).allocated)) {
        newptr = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        memcpy((void *)newptr,(void *)(*dest).strptr,(u64)oldlen);
        (*dest).strptr = newptr;
        (*dest).allocated = mlib$allocbytes;
    }
;
    memcpy((void *)((*dest).strptr + oldlen),(void *)s,(u64)n);
    (*((*dest).strptr + newlen)) = (u64)0u;
    (*dest).length = newlen;
}

void mlib$gs_init(struct mlib$strbuffer *dest) {
    mlib$pcm_clearmem(dest,(i64)16);
}

void mlib$gs_free(struct mlib$strbuffer *dest) {
    if (!!((i64)(*dest).allocated)) {
        mlib$pcm_free((void *)(*dest).strptr,(i64)(*dest).allocated);
    }
;
}

void mlib$gs_str(struct mlib$strbuffer *dest,u8 *s) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,(i64)-1);
}

void mlib$gs_char(struct mlib$strbuffer *dest,i64 c) {
        u8 s[16];
    s[((i64)1)-1] = (u64)c;
    s[((i64)2)-1] = (u64)0u;
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(u8 *)s,(i64)1);
}

void mlib$gs_strn(struct mlib$strbuffer *dest,u8 *s,i64 length) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,length);
}

void mlib$gs_strvar(struct mlib$strbuffer *dest,struct mlib$strbuffer *s) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(*s).strptr,(i64)-1);
}

void mlib$gs_strint(struct mlib$strbuffer *dest,i64 a) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,msysc$strint(a,0),(i64)-1);
}

void mlib$gs_strln(struct mlib$strbuffer *dest,u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)dest,s);
    mlib$gs_line((struct mlib$strbuffer *)dest);
}

void mlib$gs_strsp(struct mlib$strbuffer *dest,u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)dest,s);
    mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)" ");
}

void mlib$gs_line(struct mlib$strbuffer *dest) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(byte*)"\r\n",(i64)-1);
}

i64 mlib$gs_getcol(struct mlib$strbuffer *dest) {
    return (i64)(*dest).length;
}

void mlib$gs_leftstr(struct mlib$strbuffer *dest,u8 *s,i64 w,i64 padch) {
        i64 col;
        i64 i;
        i64 n;
        i64 slen;
        u8 str[2560];
    col = (i64)(*dest).length;
    strcpy((u8 *)str,s);
    slen = strlen(s);
    n = (w - slen);
    if ((n > (i64)0)) {
        for (i=(i64)1;i<=n;++i) {
L1249 :;
            str[((slen + i))-1] = (u64)padch;
L1250 :;
        }
L1251 :;
        ;
        str[(((slen + n) + (i64)1))-1] = (u64)0u;
    }
;
    mlib$gs_str((struct mlib$strbuffer *)dest,(u8 *)str);
}

void mlib$gs_leftint(struct mlib$strbuffer *dest,i64 a,i64 w,i64 padch) {
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,msysc$strint(a,0),w,padch);
}

void mlib$gs_padto(struct mlib$strbuffer *dest,i64 col,i64 ch) {
        i64 n;
        u8 str[2560];
        i64 i;
    n = (col - (i64)(*dest).length);
    if ((n <= (i64)0)) {
        return;
    }
;
    for (i=(i64)1;i<=n;++i) {
L1252 :;
        str[(i)-1] = (u64)ch;
L1253 :;
    }
L1254 :;
    ;
    str[((n + (i64)1))-1] = (u64)0u;
    mlib$gs_str((struct mlib$strbuffer *)dest,(u8 *)str);
}

void mlib$gs_println(struct mlib$strbuffer *dest,void *f) {
    if (((i64)(*dest).length == (i64)0)) {
        return;
    }
;
    (*((*dest).strptr + (i64)(*dest).length)) = (u64)0u;
    if ((f == 0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((*dest).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startfile(f);
        msysc$m_print_str((*dest).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

i64 mlib$nextcmdparamnew(i64 *paramno,u8 **name,u8 **value,u8 *defext) {
        static i64 infile = (i64)0;
        static u8 *  filestart = 0;
        static u8 *  fileptr = 0;
        static byte colonseen = (byte)(i64)0;
        u8 *  q;
        u8 *  item;
        u8 *  fileext;
        static i64 atsize;
        static u8 str[300];
    //reenter:
L1255 :;
;
    (*value) = 0;
    (*name) = 0;
    if (!!(infile)) {
        if ((mlib$readnextfileitem(&fileptr,&item) == (i64)0)) {
            mlib$pcm_free((void *)filestart,atsize);
            infile = (i64)0;
            goto L1255 ;
;
        }
;
    }
    else {
        if (((*paramno) > msysc$ncmdparams)) {
            return (i64)0;
        }
;
        item = (*msysc$cmdparams)[((*paramno))];
        ++((*paramno));
        if (((u64)(*item) == '@')) {
            if (!!(infile)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Nested @",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)1);
            }
;
            filestart = (fileptr = (u8 *)mlib$readfile((item + (i64)1)));
            if ((filestart == 0)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Can't open",NULL);
                msysc$m_print_str(item,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)7);
            }
;
            infile = (i64)1;
            atsize = mlib$allocbytes;
            goto L1255 ;
;
        }
;
        if (((u64)(*item) == ':')) {
            colonseen = (i64)1;
            return (i64)4;
        }
;
    }
;
    (*value) = 0;
    if (((u64)(*item) == '-')) {
        (*name) = (item + (!!((i64)colonseen) ? (i64)0 : (i64)1));
        q = strchr(item,(i32)':');
        if (!(!!(q))) {
            q = strchr(item,(i32)'=');
        }
;
        if (!!(q)) {
            (*value) = (q + (i64)1);
            (*q) = (u64)0u;
        }
;
        return (!!((i64)colonseen) ? (i64)5 : (i64)1);
    }
;
    fileext = mlib$extractext(item,(i64)0);
    (*name) = item;
    if (((i64)(u64)(*fileext) == (i64)0)) {
        strcpy((u8 *)str,(*name));
        if ((!!(defext) && !(!!((i64)colonseen)))) {
            (*name) = mlib$addext((u8 *)str,defext);
        }
;
    }
    else if ((!!(mlib$eqstring(fileext,(byte*)"dll")) || !!(mlib$eqstring(fileext,(byte*)"mcx")))) {
        return (!!((i64)colonseen) ? (i64)5 : (i64)3);
    }
;
    if (!!((i64)colonseen)) {
        return (i64)5;
    }
    else {
        return (i64)2;
    }
;
}

static i64 mlib$readnextfileitem(u8 **fileptr,u8 **item) {
        u8 *  p;
        u8 *  pstart;
        u8 *  pend;
        i64 n;
        static u8 str[256];
    p = (*fileptr);
    //reenter:
L1256 :;
;
    L1257 :;
    while (1) {
                {u64 $temp = (u64)(*p);
if (($temp==' ') || ($temp==(u64)9u) || ($temp==(u64)13u) || ($temp==(u64)10u)) {
            ++(p);
        }
        else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
            return (i64)0;
        }
        else {
            goto L1258 ;
        }
        };
    }
L1258 :;
    ;
        {u64 $temp = (u64)(*p);
if (($temp=='!') || ($temp=='#')) {
        ++(p);
        L1259 :;
                {u64 $temp = (u64)(*(p)++);
if (($temp==(u64)10u)) {
            goto L1256 ;
;
        }
        else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
            (*fileptr) = (p - (i64)1);
            return (i64)0;
        }
        else {
        }
        }goto L1259 ;
L1260 :;
        ;
    }
    };
        {u64 $temp = (u64)(*p);
if (($temp=='"')) {
        pstart = ++(p);
        L1261 :;
        while (1) {
                        {u64 $temp = (u64)(*p);
if (($temp==(u64)0u) || ($temp==(u64)26u)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Unexpected EOF in @file",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)8);
            }
            else if (($temp=='"')) {
                pend = (p)++;
                if (((u64)(*p) == ',')) {
                    ++(p);
                }
;
                goto L1262 ;
            }
            };
            ++(p);
        }
L1262 :;
        ;
    }
    else {
        pstart = p;
        L1263 :;
        while (1) {
                        {u64 $temp = (u64)(*p);
if (($temp==(u64)0u) || ($temp==(u64)26u)) {
                pend = p;
                goto L1264 ;
            }
            else if (($temp==' ') || ($temp==(u64)9u) || ($temp==',') || ($temp==(u64)13u) || ($temp==(u64)10u)) {
                pend = (p)++;
                goto L1264 ;
            }
            };
            ++(p);
        }
L1264 :;
        ;
    }
    };
    n = (pend - pstart);
    if ((n >= (i64)256)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"@file item too long",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)9);
    }
;
    memcpy(str,(void *)pstart,(u64)n);
    str[((n + (i64)1))-1] = (u64)0u;
    (*item) = (u8 *)str;
    (*fileptr) = p;
    return (i64)1;
}

void mlib$ipadstr(u8 *s,i64 width,u8 *padchar) {
        i64 n;
        i64 $av_1;
    n = strlen(s);
    $av_1 = (width - n);
    while ($av_1-- > 0) {
L1265 :;
        strcat(s,padchar);
L1266 :;
    }
L1267 :;
    ;
}

u8 *mlib$padstr(u8 *s,i64 width,u8 *padchar) {
        static u8 str[256];
    strcpy((u8 *)str,s);
    mlib$ipadstr((u8 *)str,width,padchar);
    return (u8 *)str;
}

u8 *mlib$chr(i64 c) {
        static u8 str[8];
    str[((i64)1)-1] = (u64)c;
    str[((i64)2)-1] = (u64)0u;
    return (u8 *)str;
}

i64 mlib$cmpstring(u8 *s,u8 *t) {
        i64 res;
    if (((res = strcmp(s,t)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$cmpstringn(u8 *s,u8 *t,i64 n) {
        i64 res;
    if (((res = strncmp(s,t,(u64)n)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$eqstring(u8 *s,u8 *t) {
    return (i64)(strcmp(s,t) == (i64)0);
}

i64 mlib$cmpbytes(void *p,void *q,i64 n) {
        i64 res;
    if (((res = memcmp(p,q,(u64)n)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$eqbytes(void *p,void *q,i64 n) {
    return (i64)(memcmp(p,q,(u64)n) == (i64)0);
}

void mlib$mseed(u64 a,u64 b) {
    mlib$seed[((i64)1)-1] = a;
    if (!!(b)) {
        mlib$seed[((i64)2)-1] = b;
    }
    else {
        mlib$seed[((i64)2)-1] ^= a;
    }
;
}

u64 mlib$mrandom(void) {
        i64 x;
        i64 y;
    x = (i64)mlib$seed[((i64)1)-1];
    y = (i64)mlib$seed[((i64)2)-1];
    mlib$seed[((i64)1)-1] = (u64)y;
    x ^= (x << (i64)23);
    mlib$seed[((i64)2)-1] = (u64)(((x ^ y) ^ (x >> (i64)17)) ^ (y >> (i64)26));
    return (u64)((i64)mlib$seed[((i64)2)-1] + y);
}

i64 mlib$mrandomp(void) {
    return ((i64)mlib$mrandom() & (i64)9223372036854775807);
}

i64 mlib$mrandomint(i64 n) {
    return (mlib$mrandomp() % n);
}

i64 mlib$mrandomrange(i64 a,i64 b) {
        i64 span;
    span = ((b - a) + (i64)1);
    if ((span <= (i64)0)) {
        return (i64)0;
    }
;
    return ((mlib$mrandomp() % span) + a);
}

r64 mlib$mrandomreal(void) {
        r64 x;
    L1268 :;
    do {
        x = ((r64)mlib$mrandomp() / (double)9223372036854775800.);
L1269 :;
    }
    while (!(x != (double)1.));
L1270 :;
    ;
    return x;
}

r64 mlib$mrandomreal1(void) {
    return (r64)(mlib$mrandomp() / (i64)9223372036854775807);
}

u8 *mlib$readline(void) {
    msysc$m_read_conline();
    ;
    return msysc$rd_buffer;
}

void *mlib$findfunction(u8 *name) {
        i64 $av_1;
        i64 i;
        ($av_1 = msysc$m_get_nprocs());
    for (i=(i64)1;i<=$av_1;++i) {
L1271 :;
        if (!!(mlib$eqstring(msysc$m_get_procname(i),name))) {
            return msysc$m_get_procaddr(i);
        }
;
L1272 :;
    }
L1273 :;
    ;
    return 0;
}

i64 mlib$roundtoblock(i64 n,i64 align) {
    if (((n & (align - (i64)1)) == (i64)0)) {
        return n;
    }
;
    return (n + (align - (n & (align - (i64)1))));
}

void *mlib$pcm_allocnfz(i64 n) {
        byte *  p;
    if (!!((n & (i64)7))) {
        n = (n + ((i64)8 - (n & (i64)7)));
    }
;
    p = mlib$pcheapptr;
    mlib$pcheapptr += n;
    if ((mlib$pcheapptr >= mlib$pcheapend)) {
        p = (byte *)mlib$pcm_newblock(n);
    }
;
    return p;
}

// START
void mlib$start(void) {

}

// START
void mclib$start(void) {

}

void mlinux$os_init(void) {
    mlinux$init_flag = (i64)1;
}

i64 mlinux$os_execwait(u8 *cmdline,i64 newconsole,u8 *workdir) {
    return system(cmdline);
}

i64 mlinux$os_execcmd(u8 *cmdline,i64 newconsole) {
    return system(cmdline);
}

i64 mlinux$os_getch(void) {
        struct mlinux$termios old;
        struct mlinux$termios new;
        u8 ch;
    tcgetattr((i32)(i64)0,&old);
    new = old;
    new.c_lflag &= (i32)(i64)-3;
    new.c_lflag &= (i32)(i64)-9;
    tcsetattr((i32)(i64)0,(i32)(i64)0,(struct mlinux$termios *)&new);
    ch = (u64)getchar();
    tcsetattr((i32)(i64)0,(i32)(i64)0,(struct mlinux$termios *)&old);
    return (i64)(u64)ch;
}

i64 mlinux$os_kbhit(void) {
    mlib$abortprogram((byte*)"kbhit");
    return (i64)0;
}

void mlinux$os_flushkeys(void) {
    mlib$abortprogram((byte*)"flushkeys");
}

void *mlinux$os_getconsolein(void) {
    return 0;
}

void *mlinux$os_getconsoleout(void) {
    return 0;
}

void *mlinux$os_proginstance(void) {
    mlib$abortprogram((byte*)"PROGINST");
    return 0;
}

u64 mlinux$os_getdllinst(u8 *name) {
        void *  h;
    h = dlopen(name,(i32)(i64)1);
    if ((h == 0)) {
        if ((strcmp(name,(byte*)"msvcrt") == (i64)0)) {
            h = dlopen((byte*)"libc.so.6",(i32)(i64)1);
        }
;
    }
;
    return (u64)h;
}

void *mlinux$os_getdllprocaddr(i64 hlib,u8 *name) {
        void *  fnaddr;
    if ((hlib == (i64)0)) {
        return 0;
    }
;
    fnaddr = dlsym((void *)hlib,name);
    return fnaddr;
}

void mlinux$os_initwindows(void) {
}

i64 mlinux$os_getchx(void) {
    mlib$abortprogram((byte*)"getchx");
    return (i64)0;
}

u8 *mlinux$os_getos(void) {
    if (((i64)64 == (i64)32)) {
        return (byte*)"L32";
    }
    else {
        return (byte*)"L64";
    }
;
}

i64 mlinux$os_gethostsize(void) {
    return (i64)64;
}

i64 mlinux$os_iswindows(void) {
    return (i64)0;
}

i64 mlinux$os_shellexec(u8 *opc,u8 *file) {
    mlib$abortprogram((byte*)"SHELL EXEC");
    return (i64)0;
}

void mlinux$os_sleep(i64 a) {
}

void *mlinux$os_getstdin(void) {
    return 0;
}

void *mlinux$os_getstdout(void) {
    return 0;
}

u8 *mlinux$os_gethostname(void) {
    return (byte*)"";
}

u8 *mlinux$os_getmpath(void) {
    return (byte*)"";
}

void mlinux$os_exitprocess(i64 x) {
    exit(0);
}

i64 mlinux$os_clock(void) {
    if (!!(mlinux$os_iswindows())) {
        return clock();
    }
    else {
        return (clock() / (i64)1000);
    }
;
}

i64 mlinux$os_ticks(void) {
    return clock();
}

i64 mlinux$os_getclockspersec(void) {
    if (!!(mlinux$os_iswindows())) {
        return (i64)1000;
    }
    else {
        return (i64)1000000;
    }
;
}

void mlinux$os_setmesshandler(void *addr) {
    mlib$abortprogram((byte*)"SETMESSHANDLER");
}

i64 mlinux$os_hpcounter(void) {
    return (i64)1;
}

i64 mlinux$os_hpfrequency(void) {
    return (i64)1;
}

i64 mlinux$os_filelastwritetime(u8 *filename) {
    return (i64)0;
}

void mlinux$os_getsystime(struct mlinux$rsystemtime *tm) {
        struct mlinux$timeval tv;
        struct mlinux$tm_rec tmr;
    gettimeofday(&tv,0);
    gmtime_r(&tv.tv_sec,&tmr);
    (*tm).year = ((i64)tmr.tm_year + (i64)1900);
    (*tm).month = ((i64)tmr.tm_mon + (i64)1);
    (*tm).dayofweek = ((i64)tmr.tm_wday + (i64)1);
    (*tm).day = (i64)tmr.tm_mday;
    (*tm).hour = (i64)tmr.tm_hour;
    (*tm).minute = (i64)tmr.tm_min;
    (*tm).second = (i64)tmr.tm_sec;
    (*tm).milliseconds = (tv.tv_usec / (i64)1000);
    (*tm).month = (i64)1;
}

void mlinux$os_peek(void) {
}

byte *mlinux$os_allocexecmem(i64 n) {
    mlib$abortprogram((byte*)"No allocexec");
    return (byte *)0;
}

i64 mlinux$dirlist(u8 *filespec,u8 *(*dest)[],i64 capacity,i64 t) {
    return (i64)0;
}

// START
void mlinux$start(void) {

}

u64 mwindllc$os_calldllfunction(void (*fnaddr)(void),i64 retcode,i64 nargs,i64 (*args)[],byte (*argcodes)[]) {
    if ((retcode == (i64)73)) {
        return (u64)mwindllc$calldll_cint((void (*)(void))fnaddr,args,nargs);
    }
    else {
        return (u64)mwindllc$calldll_creal((void (*)(void))fnaddr,args,nargs);
    }
;
}

u64 mwindllc$os_pushargs(u64 (*args)[],i64 nargs,i64 nextra,void (*fnaddr)(void),i64 isfloat) {
    return mwindllc$os_calldllfunction((void (*)(void))fnaddr,(!!(isfloat) ? (i64)0 : (i64)73),nargs,(i64 (*)[])args,0);
}

static i64 mwindllc$calldll_cint(void (*fnaddr)(void),i64 (*params)[],i64 nparams) {
    switch (nparams) {
    case 0:;
        {
            return ((*(i64 (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            return ((*(i64 (*)(i64,...))fnaddr))((*params)[((i64)1)-1]);
        }
        break;
    case 2:;
        {
            return ((*(i64 (*)(i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1]);
        }
        break;
    case 3:;
        {
            return ((*(i64 (*)(i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1]);
        }
        break;
    case 4:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1]);
        }
        break;
    case 5:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1]);
        }
        break;
    case 6:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1]);
        }
        break;
    case 9:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1]);
        }
        break;
    case 10:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1]);
        }
        break;
    case 11:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1]);
        }
        break;
    case 12:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1],(*params)[((i64)12)-1]);
        }
        break;
    case 14:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1],(*params)[((i64)12)-1],(*params)[((i64)13)-1],(*params)[((i64)14)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"calldll/c/int unsupported # of params",NULL);
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
    } //SW
;
    return (i64)0;
}

static i64 mwindllc$calldll_creal(void (*fnaddr)(void),i64 (*params)[],i64 nparams) {
        r64 x;
    switch (nparams) {
    case 0:;
        {
            return (i64)((*(r64 (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            mwindllc$os_dummycall((r64)(*params)[((i64)1)-1],(r64)(*params)[((i64)2)-1],(r64)(*params)[((i64)3)-1],(r64)(*params)[((i64)4)-1]);
            x = ((*(r64 (*)(i64,...))fnaddr))((*params)[((i64)1)-1]);
        }
        break;
    case 2:;
        {
            x = ((*(r64 (*)(i64,i64,...))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"calldll/c/real too many params",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
    } //SW
;
    return *(i64*)&x;
}

void mwindllc$os_dummycall(r64 a,r64 b,r64 c,r64 d) {
}

// START
void mwindllc$start(void) {

}


/* ********** End of C Code ********** */
